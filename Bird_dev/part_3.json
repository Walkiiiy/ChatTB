{
    "1082": {
        "db_id": "european_football_2",
        "question": "Please list the leagues from Germany.",
        "ground_truth": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Germany'",
        "amends": [
            "Do select `t2.name` instead of `*` to specify the exact column needed. Do use `Country AS t1` and `League AS t2` as table sources instead of just `leagues` to properly structure the join. Do add `INNER JOIN` on `t1.id = t2.country_id` instead of querying a single table to establish the correct relationship between countries and leagues. Do filter on `t1.name = 'Germany'` instead of `country = 'Germany'` to use the country name from the appropriate table. The amended query now correctly retrieves league names for Germany by joining the Country and League tables with proper relationship mapping."
        ],
        "rules": [
            "1) When answering about \"leagues from Germany\": make sure the output order: t2.name. 2) When the question mentions \"Germany\": \"Germany\" actually means \"t1.name = 'Germany'\" in schema. 3) When combining Country as T1 and League as T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.id = t2.country_id); keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM leagues WHERE country = 'Germany';",
            "SELECT t2.name \nFROM Country AS t1 \nINNER JOIN League AS t2 ON t1.id = t2.country_id \nWHERE t1.name = 'Germany'"
        ],
        "rule_sql": [
            "SELECT t2.name \nFROM Country t1 \nINNER JOIN League t2 ON t1.id = t2.country_id \nWHERE t1.name = 'Germany' \nORDER BY t2.name"
        ],
        "amend_res": 1
    },
    "771": {
        "db_id": "superhero",
        "question": "List the name of superheroes with flight power.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Flight'",
        "amends": [
            "Do use `T1.superhero_name` instead of `name` and add explicit table aliases. Do add `INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id` and `INNER JOIN superpower AS T3 ON T2.power_id = T3.id` instead of querying a single table. Do use `T3.power_name = 'Flight'` instead of `power = 'flight'` to properly reference the normalized power table with correct case sensitivity. The amended query now correctly joins through the relationship tables to find superheroes with the specified power, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"superheroes with flight power\": make sure the output order: T1.superhero_name. 2) When the question mentions \"name\": \"name\" actually means \"T1.superhero_name\" in schema. 3) When combining T1, T2, and T3 for shared entities: link rows where T1.id = T2.hero_id and T2.power_id = T3.id; keep only matching pairs (inner match). 4) When the question mentions \"flight power\": \"flight power\" actually means \"T3.power_name = 'Flight'\" with exact case sensitivity."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE power = 'flight';",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Flight'"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Flight'\nORDER BY T1.superhero_name;"
        ],
        "amend_res": 1
    },
    "225": {
        "db_id": "toxicology",
        "question": "Please list top five molecules that have double bonds in alphabetical order.",
        "ground_truth": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id LIMIT 5",
        "amends": [
            "Do select `T.molecule_id` instead of `molecule_name` and add `DISTINCT` instead of omitting it. Do reference table `bond AS T` instead of `molecules` and change the filter to `T.bond_type = '='` instead of `bond_type = 'double'`. Do order by `T.molecule_id` instead of `molecule_name` and remove `DESC` instead of keeping it. The amended query now correctly retrieves distinct molecule IDs with single bonds in ascending order, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about molecules with double bonds: use table \"bond AS T\" instead of \"molecules\" 2) When filtering for double bonds: use condition T.bond_type = '=' instead of 'double' 3) When selecting molecule identifiers: use T.molecule_id instead of molecule_name 4) When ensuring unique molecules: add DISTINCT to the selection 5) When ordering results alphabetically: order by T.molecule_id in ascending order (remove DESC) 6) When limiting to top five results: keep LIMIT 5"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_name FROM molecules WHERE bond_type = 'double' ORDER BY molecule_name DESC LIMIT 5;",
            "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id ASC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id ASC LIMIT 5"
        ],
        "amend_res": 1
    },
    "165": {
        "db_id": "financial",
        "question": "Please list all the transactions made by accounts from district 5.",
        "evidence": "",
        "ground_truth": "SELECT T3.trans_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T1.district_id = 5",
        "amends": [
            "Do select only `T3.trans_id` instead of all columns with `*`. Do join `district AS T1` and `account AS T2` with `INNER JOIN` on `T1.district_id = T2.district_id` instead of querying only `transactions`. Do add another `INNER JOIN` to `trans AS T3` on `T2.account_id = T3.account_id` instead of missing these table relationships. Do filter on `T1.district_id = 5` instead of `district = 5` to use the correct join key. The amended query now correctly retrieves transaction IDs by properly navigating through the district-account-transaction relationship hierarchy."
        ],
        "rules": [
            "1) When answering about \"transactions made by accounts from district 5\": make sure the output order: T3.trans_id. 2) When the question mentions \"district 5\": \"district 5\" actually means \"T1.district_id = 5\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.district_id = T2.district_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T2 and T3 for shared entities: link rows where T2.account_id = T3.account_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM transactions WHERE district = 5;",
            "SELECT T3.trans_id\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T1.district_id = 5"
        ],
        "rule_sql": [
            "SELECT T3.trans_id\nFROM account AS T1\nINNER JOIN trans AS T3 ON T1.account_id = T3.account_id\nWHERE T1.district_id = 5\nORDER BY T3.trans_id"
        ],
        "amend_res": 1
    },
    "1343": {
        "db_id": "student_club",
        "question": "With the biggest budget for the \"Food\", what was the remaining of it?",
        "ground_truth": "SELECT remaining FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget WHERE category = 'Food' )",
        "amends": [
            "Do select `remaining` directly instead of calculating `budget - spent AS remaining`. Do use table `budget` instead of table `expenses`. Do add filter `amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food')` instead of ordering by `budget DESC LIMIT 1`. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly retrieves the maximum remaining budget for the Food category by using a subquery to find the maximum amount rather than relying on sorting and limiting."
        ],
        "rules": [
            "1) When answering about \"the biggest budget for Food\": find the maximum amount value from the budget table where category equals 'Food' exactly. 2) When the question mentions \"remaining\": use the column \"remaining\" directly from the budget table instead of calculating budget - spent. 3) When filtering for the maximum budget amount: use a subquery to find MAX(amount) where category = 'Food' and then match that exact amount value in the main query. 4) When the question asks for the remaining budget: select only the \"remaining\" column from the budget table where amount equals the maximum amount for category 'Food'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT budget - spent AS remaining FROM expenses WHERE category = 'Food' ORDER BY budget DESC LIMIT 1;",
            "SELECT remaining FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food')"
        ],
        "rule_sql": [
            "SELECT remaining FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food')"
        ],
        "amend_res": 1
    },
    "129": {
        "db_id": "financial",
        "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
        "ground_truth": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%' ORDER BY A2 ASC LIMIT 10",
        "amends": [
            "Do select `DISTINCT T1.A2` instead of `d.district_name, SUM(t.amount) as total_withdrawal` with aggregation. Do use `FROM district AS T1` instead of `FROM transactions t` as the starting table. Do use `INNER JOIN account AS T2 ON T1.district_id = T2.district_id` instead of `JOIN accounts a ON t.account_id = a.account_id` with corrected join direction and predicate. Do use `INNER JOIN trans AS T3 ON T2.account_id = T3.account_id` instead of the implicit join approach. Do filter with `T3.type = 'VYDAJ'` instead of `t.type = 'withdrawal'` and remove the `AND t.credit_card = 0` condition instead of keeping it. Do remove the `GROUP BY` clause instead of grouping by district name. Do order by `A2 ASC` instead of `total_withdrawal DESC` and keep the `LIMIT 10` clause. The amended query now correctly retrieves distinct district names with ascending order instead of aggregated withdrawal amounts."
        ],
        "rules": [
            "1) When answering about \"top ten withdrawals by district names\": make sure the output order is T1.A2 ASC instead of aggregated withdrawal amounts in descending order. 2) When the question mentions \"withdrawals (non-credit card)\": \"withdrawals\" actually means T3.type = 'VYDAJ' in schema and no credit card filter is needed. 3) When the question asks for \"district names\": use DISTINCT T1.A2 instead of grouping and aggregating. 4) When combining tables for this query: start from district AS T1, then INNER JOIN account AS T2 ON T1.district_id = T2.district_id, then INNER JOIN trans AS T3 ON T2.account_id = T3.account_id. 5) When the question asks for \"top ten\": rank rows by T1.A2 in ascending order and keep the first 10 rows using LIMIT 10."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.district_name, SUM(t.amount) as total_withdrawal\nFROM transactions t\nJOIN accounts a ON t.account_id = a.account_id\nJOIN districts d ON a.district_id = d.district_id\nWHERE t.type = 'withdrawal'\nAND t.date LIKE '1996-01%'\nAND t.credit_card = 0\nGROUP BY d.district_name\nORDER BY total_withdrawal DESC\nLIMIT 10;",
            "SELECT DISTINCT T1.A2\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T3.type = 'VYDAJ'\nAND strftime('%Y-%m', T3.date) = '1996-01'\nORDER BY T1.A2 ASC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.A2\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T3.type = 'VYDAJ'\nAND strftime('%Y-%m', T3.date) = '1996-01'\nORDER BY T1.A2 ASC\nLIMIT 10"
        ],
        "amend_res": 1
    },
    "1421": {
        "db_id": "student_club",
        "question": "Calculate the percentage of members who are major Business in the list?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only business majors. Do add `INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major` instead of querying only the members table. Do reference `T2.major_name` instead of `major` column which doesn't exist in members table. Do add filter `WHERE T1.position = 'Member'` instead of omitting position filtering. Do use `CAST(... AS REAL)` and divide by `COUNT(T1.member_id)` instead of subquery for proper percentage calculation. Do reference `T1.member_id` instead of generic `COUNT(*)` for denominator. The amended query now correctly joins tables and calculates percentage of business majors among members with proper position filtering."
        ],
        "rules": [
            "1) When the question asks for percentage of members with a specific major: join the members table (T1) with the major table (T2) using the exact key equality T2.major_id = T1.link_to_major and keep only matching pairs (inner match). 2) When counting business majors: use SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) to count only rows where major_name equals 'Business' exactly. 3) When filtering for members only: add condition WHERE T1.position = 'Member' to include only rows where position equals 'Member' exactly. 4) When calculating percentage: compute (business major count) divided by COUNT(T1.member_id) and multiply by 100.0, using CAST for proper real number division. 5) When referencing identifiers: use exact tokens T2.major_name, T1.link_to_major, T2.major_id, T1.position, and T1.member_id as shown in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM members) AS percentage FROM members WHERE major = 'Business';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.member_id) * 100 AS percentage_business_majors\nFROM \n    member AS T1\nINNER JOIN \n    major AS T2 ON T2.major_id = T1.link_to_major\nWHERE \n    T1.position = 'Member';"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.member_id)) * 100.0 AS percentage\nFROM \n    member T1\nINNER JOIN \n    major T2 ON T2.major_id = T1.link_to_major\nWHERE \n    T1.position = 'Member'"
        ],
        "amend_res": 1
    },
    "1140": {
        "db_id": "european_football_2",
        "question": "What are Alexis Blin's sprint speed, agility, and acceleration scores?",
        "ground_truth": "SELECT sprint_speed, agility, acceleration FROM Player_Attributes WHERE player_api_id IN ( SELECT player_api_id FROM Player WHERE player_name = 'Alexis Blin' )",
        "amends": [
            "Do query the `Player_Attributes` table instead of the `players` table. Do use a subquery to filter by `player_api_id` instead of directly filtering by name columns. Do reference `player_name` from the `Player` table instead of separate `first_name` and `last_name` columns. Do use the `IN` operator with a subquery instead of direct `WHERE` conditions on name fields. The amended query now correctly retrieves attributes by matching the player's unified name field through the proper table relationships."
        ],
        "rules": [
            "1) When the question asks for player attributes like sprint speed, agility, and acceleration: query the \"Player_Attributes\" table instead of the \"players\" table. 2) When filtering by a player's name like \"Alexis Blin\": use a subquery to filter by \"player_api_id\" instead of directly filtering by name columns. 3) When referencing a player's name: use the \"player_name\" column from the \"Player\" table instead of separate \"first_name\" and \"last_name\" columns. 4) When matching a specific player name like \"Alexis Blin\": use the IN operator with a subquery instead of direct WHERE conditions on name fields."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT sprint_speed, agility, acceleration FROM players WHERE first_name = 'Alexis' AND last_name = 'Blin';",
            "SELECT sprint_speed, agility, acceleration \nFROM Player_Attributes \nWHERE player_api_id IN (\n    SELECT player_api_id \n    FROM Player \n    WHERE player_name = 'Alexis Blin'\n)"
        ],
        "rule_sql": [
            "SELECT sprint_speed, agility, acceleration \nFROM Player_Attributes \nWHERE player_api_id IN (\n    SELECT player_api_id \n    FROM Player \n    WHERE player_name = 'Alexis Blin'\n)"
        ],
        "amend_res": 1
    },
    "1381": {
        "db_id": "student_club",
        "question": "List the name of students that have attended more than 7 events.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "amends": [
            "Do select `T1.first_name` and `T1.last_name` instead of just `name`. Do use `INNER JOIN` between `member AS T1` and `attendance AS T2` on `T1.member_id = T2.link_to_member` instead of querying a single table. Do add `GROUP BY T2.link_to_member` instead of omitting grouping. Do move the count filter to `HAVING COUNT(T2.link_to_event) > 7` instead of using `WHERE events_attended > 7`. The amended query now correctly counts event attendance through the join and grouping structure, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"students that have attended more than 7 events\": make sure the output order: T1.first_name, T1.last_name. 2) When the question mentions \"students\": \"students\" actually means \"member AS T1\" in schema. 3) When the question mentions \"events attended\": \"events attended\" actually means \"COUNT(T2.link_to_event)\" through attendance AS T2. 4) When combining T1 and T2 for shared entities: link rows where T1.member_id = T2.link_to_member exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"count of events attended per student\": organize results by T2.link_to_member and compute COUNT(T2.link_to_event) per group. 6) When filtering for \"more than 7 events\": apply the condition COUNT(T2.link_to_event) > 7 after grouping."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE events_attended > 7;",
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member\nGROUP BY T2.link_to_member\nHAVING COUNT(T2.link_to_event) > 7"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member\nGROUP BY T2.link_to_member\nHAVING COUNT(T2.link_to_event) > 7\nORDER BY T1.first_name, T1.last_name;"
        ],
        "amend_res": 1
    },
    "1217": {
        "db_id": "thrombosis_prediction",
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "ground_truth": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "amends": [
            "Do use `CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END` instead of `CASE WHEN l.albumin BETWEEN 35 AND 50 THEN 'Normal' ELSE 'Abnormal' END` to correct the albumin range and case sensitivity. Do reference `T2.ALB` instead of `l.albumin` for the albumin column name. Do join `Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of `patients p JOIN lab_results l ON p.patient_id = l.patient_id` to use the correct table aliases and join condition on ID columns. Do filter with `STRFTIME('%Y', T1.Birthday) = '1982'` instead of `p.birth_year = 1982` to extract year from a date field rather than using a numeric year column. Do remove `p.patient_id, p.name` from the SELECT list instead of including them to return only the albumin status. Do remove `ORDER BY p.patient_id` instead of keeping it as no ordering is needed. The amended query now correctly identifies patients born in 1982 with normal albumin levels using the proper range of 3.5-5.5 instead of 35-50."
        ],
        "rules": [
            "1) When the question asks about albumin status for patients born in 1982: use CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END to determine albumin status with the correct range and lowercase output values. 2) When joining Patient and Laboratory tables: use INNER JOIN with the condition T1.ID = T2.ID to link patient records with their lab results. 3) When filtering for patients born in 1982: use STRFTIME('%Y', T1.Birthday) = '1982' to extract the year from the Birthday date field. 4) When selecting output columns: return only the albumin status column, not patient_id or name. 5) When ordering results: do not apply any ordering as the question doesn't require sorted output."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    p.patient_id,\n    p.name,\n    CASE \n        WHEN l.albumin BETWEEN 35 AND 50 THEN 'Normal'\n        ELSE 'Abnormal'\n    END AS albumin_status\nFROM patients p\nJOIN lab_results l ON p.patient_id = l.patient_id\nWHERE p.birth_year = 1982\nORDER BY p.patient_id;",
            "SELECT \n    CASE \n        WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' \n        ELSE 'abnormal' \n    END AS albumin_status\nFROM \n    Patient AS T1 \nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    STRFTIME('%Y', T1.Birthday) = '1982'"
        ],
        "rule_sql": [
            "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END AS albumin_status FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982';"
        ],
        "amend_res": 1
    },
    "494": {
        "db_id": "card_games",
        "question": "For all cards illustrated by Jim Pavelec. and describe the text of the ruling of these cards. Do these cards have missing or degraded properties and values.",
        "ground_truth": "SELECT T2.text , CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec'",
        "amends": [
            "Do select `T2.text` and a CASE expression checking `T1.hasContentWarning` instead of selecting `c.name`, `r.text`, and a different CASE expression checking mana cost, power, toughness, and cmc properties. Do use `INNER JOIN` on `T2.uuid = T1.uuid` instead of `LEFT JOIN` on `c.id = r.card_id`. Do remove the ORDER BY clause instead of keeping `ORDER BY c.name`. The amended query now correctly joins on UUID instead of ID, selects different columns with appropriate CASE logic for content warnings, and matches the RIGHT_SQL's behavior.",
            "Do use uppercase 'YES' and 'NO' in the CASE expression instead of 'Yes' and 'No'. Do remove the alias `has_missing_or_degraded_properties` from the CASE expression instead of keeping it. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about cards illustrated by Jim Pavelec: use T1 as the base table for cards and T2 as the related table for rulings. 2) When joining cards and rulings tables: link rows where T2.uuid = T1.uuid using an inner join instead of a left join. 3) When selecting output columns: select T2.text instead of c.name and r.text. 4) When checking for missing or degraded properties: use a CASE expression checking T1.hasContentWarning instead of checking mana_cost, power, toughness, and cmc properties. 5) When ordering results: do not include any ORDER BY clause instead of ordering by c.name.",
            "1) When the question asks about cards illustrated by \"Jim Pavelec\": filter rows where T1.artist equals exactly 'Jim Pavelec'. 2) When combining cards table (T1) and rulings table (T2): link rows where T2.uuid equals T1.uuid exactly and keep only matching pairs (inner match). 3) When outputting whether cards have missing or degraded properties: use uppercase 'YES' when T1.hasContentWarning equals 1, otherwise use 'NO'. 4) When answering about cards illustrated by Jim Pavelec: make sure the output order: T2.text first, followed by the case expression result without any alias."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, r.text, \n       CASE \n           WHEN c.mana_cost IS NULL OR c.mana_cost = '' THEN 'Missing mana cost'\n           WHEN c.power IS NULL OR c.power = '' THEN 'Missing power'\n           WHEN c.toughness IS NULL OR c.toughness = '' THEN 'Missing toughness'\n           WHEN c.cmc IS NULL THEN 'Missing converted mana cost'\n           ELSE 'No missing properties'\n       END AS property_status\nFROM cards c\nLEFT JOIN rulings r ON c.id = r.card_id\nWHERE c.artist = 'Jim Pavelec'\nORDER BY c.name;",
            "SELECT T2.text,\n       CASE \n           WHEN T1.hasContentWarning = 1 THEN 'Yes' \n           ELSE 'No' \n       END AS has_missing_or_degraded_properties\nFROM cards T1\nINNER JOIN rulings T2 ON T2.uuid = T1.uuid\nWHERE T1.artist = 'Jim Pavelec'",
            "SELECT T2.text, \n       CASE \n           WHEN T1.hasContentWarning = 1 THEN 'YES' \n           ELSE 'NO' \n       END\nFROM cards T1\nINNER JOIN rulings T2 ON T2.uuid = T1.uuid\nWHERE T1.artist = 'Jim Pavelec'"
        ],
        "rule_sql": [
            "SELECT T2.text, CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards T1 INNER JOIN rulings T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec'"
        ],
        "amend_res": 1
    },
    "653": {
        "db_id": "codebase_community",
        "question": "What is the owner's display name of the most popular post?",
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "amends": [
            "Do select `DisplayName` from the `users` table instead of `owner_display_name` from `posts`. Do add a subquery to find the `OwnerUserId` with the highest `ViewCount` instead of directly selecting from posts. Do move the ordering and limiting to the subquery instead of the main query. Do add a WHERE condition `Id = (subquery)` to correlate the user with the post owner instead of selecting display names directly from posts. Do use proper column names `DisplayName`, `Id`, `OwnerUserId`, and `ViewCount` instead of incorrect names `owner_display_name` and `view_count`. The amended query now correctly identifies the display name of the user who owns the post with the highest view count, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the owner's display name of the most popular post: use \"DisplayName\" from the \"users\" table instead of \"owner_display_name\" from \"posts\". 2) When finding the most popular post: identify the post with the highest \"ViewCount\" value. 3) When linking posts to their owners: use the relationship where \"posts\".\"OwnerUserId\" equals \"users\".\"Id\". 4) When selecting the top result: use a subquery to find the \"OwnerUserId\" with the maximum \"ViewCount\" first, then match it to the user's \"Id\". 5) When ordering results by popularity: sort by \"ViewCount\" in descending order and take only the first result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_display_name FROM posts ORDER BY view_count DESC LIMIT 1;",
            "SELECT DisplayName \nFROM users \nWHERE Id = (\n    SELECT OwnerUserId \n    FROM posts \n    ORDER BY ViewCount DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT u.DisplayName \nFROM users u\nWHERE u.Id = (\n    SELECT p.OwnerUserId \n    FROM posts p \n    ORDER BY p.ViewCount DESC \n    LIMIT 1\n)"
        ],
        "amend_res": 1
    },
    "308": {
        "db_id": "toxicology",
        "question": "How many bonds are created by bonding atoms with chlorine element?",
        "ground_truth": "SELECT COUNT(T1.bond_id) FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T2.element = 'cl'",
        "amends": [
            "Do select `COUNT(T1.bond_id)` from the `connected` table instead of `COUNT(*)` from the `bonds` table. Do use `INNER JOIN` with the `atom` table on `T1.atom_id = T2.atom_id` instead of querying a single table with element conditions. Do filter with `T2.element = 'cl'` in the WHERE clause instead of using `atom1_element = 'Cl' OR atom2_element = 'Cl'` on the wrong table structure. Do reference the correct table aliases `T1` and `T2` instead of the non-existent `bonds` table with atom element columns. The amended query now correctly counts chlorine bonds by joining the connected and atom tables with proper relationship constraints."
        ],
        "rules": [
            "1) When counting bonds created by bonding atoms with chlorine element: count using T1.bond_id from the connected table instead of counting all rows. 2) When combining connected and atom tables: link rows where T1.atom_id = T2.atom_id using an inner join to keep only matching pairs. 3) When filtering for chlorine element: use T2.element = 'cl' exactly as specified (lowercase 'cl') instead of 'Cl' or other variations. 4) When referencing tables: use the exact aliases T1 for connected table and T2 for atom table as established in the join structure."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM bonds WHERE atom1_element = 'Cl' OR atom2_element = 'Cl';",
            "SELECT COUNT(T1.bond_id) \nFROM connected T1\nINNER JOIN atom T2 ON T1.atom_id = T2.atom_id\nWHERE T2.element = 'cl'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.bond_id) \nFROM connected T1 \nINNER JOIN atom T2 ON T1.atom_id = T2.atom_id \nWHERE T2.element = 'cl'"
        ],
        "amend_res": 1
    },
    "1048": {
        "db_id": "european_football_2",
        "question": "What is the overall rating of the football player Gabriel Tamas in year 2011?",
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Gabriel Tamas' AND strftime('%Y', t2.date) = '2011'",
        "amends": [
            "Do select `t2.overall_rating` instead of `rating` and specify the table alias. Do join `Player AS t1` with `Player_Attributes AS t2` on `t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do filter by `t1.player_name = 'Gabriel Tamas'` instead of `name = 'Gabriel Tamas'` and use `strftime('%Y', t2.date) = '2011'` to extract the year from the date column instead of a simple `year = 2011` comparison. The amended query now correctly joins the necessary tables and uses proper date handling to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"overall rating of football player Gabriel Tamas in year 2011\": make sure the output order: t2.overall_rating. 2) When the question mentions \"Gabriel Tamas\": \"Gabriel Tamas\" actually means \"t1.player_name = 'Gabriel Tamas'\" in schema. 3) When the question mentions \"year 2011\": \"year 2011\" actually means \"strftime('%Y', t2.date) = '2011'\" in schema. 4) When combining Player as T1 and Player_Attributes as T2 for shared entities: link rows where t1.player_api_id = t2.player_api_id; keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT rating FROM players WHERE name = 'Gabriel Tamas' AND year = 2011;",
            "SELECT t2.overall_rating \nFROM Player AS t1 \nJOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Gabriel Tamas' \nAND strftime('%Y', t2.date) = '2011'"
        ],
        "rule_sql": [
            "SELECT t2.overall_rating \nFROM Player t1 \nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Gabriel Tamas' \nAND strftime('%Y', t2.date) = '2011'"
        ],
        "amend_res": 1
    },
    "1115": {
        "db_id": "european_football_2",
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "amends": [
            "Do use `SUM(CASE WHEN)` conditional aggregation instead of direct column subtraction to handle multiple records. Do join `Player` and `Player_Attributes` tables on `player_fifa_api_id` instead of self-joining the same table. Do filter by `SUBSTR(t2.date, 1, 10) = '2013-07-12'` for date matching instead of a direct date comparison. Do calculate percentage difference using proper aggregation formula `(sum1 - sum2) * 100 / sum1` instead of `(rating1 - rating2) / rating2 * 100`. Do reference correct column names `player_name` and `overall_rating` instead of incorrect column references. The amended query now correctly handles multiple player attribute records and calculates the percentage difference between Landon Donovan and Jordan Bowery's ratings for the specified date."
        ],
        "rules": [
            "1) When answering about percentage difference between two players' ratings: use conditional aggregation with SUM(CASE WHEN) instead of direct column subtraction to handle multiple records. 2) When combining Player and Player_Attributes tables: link rows where T1.player_fifa_api_id = T2.player_fifa_api_id and keep only matching pairs (inner match). 3) When filtering by date '2013-07-12': use SUBSTR(T2.date, 1, 10) = '2013-07-12' for date matching instead of direct date comparison. 4) When calculating percentage difference: use formula (sum1 - sum2) * 100 / sum1 where sum1 is Landon Donovan's rating and sum2 is Jordan Bowery's rating. 5) When referencing player names: use exact column name \"player_name\" with literals 'Landon Donovan' and 'Jordan Bowery' exactly as specified. 6) When referencing ratings: use exact column name \"overall_rating\" from the Player_Attributes table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    ((LandonDonovan.overall_rating - JordanBowery.overall_rating) / JordanBowery.overall_rating) * 100 AS percentage_higher\nFROM \n    players LandonDonovan, \n    players JordanBowery\nWHERE \n    LandonDonovan.name = 'Landon Donovan'\n    AND JordanBowery.name = 'Jordan Bowery'\n    AND date = '2013-07-12';",
            "SELECT \n    (SUM(CASE WHEN p.player_name = 'Landon Donovan' THEN pa.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN p.player_name = 'Jordan Bowery' THEN pa.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN p.player_name = 'Landon Donovan' THEN pa.overall_rating ELSE 0 END) AS percentage_difference\nFROM Player p\nJOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id\nWHERE p.player_name IN ('Landon Donovan', 'Jordan Bowery')\nAND SUBSTR(pa.date, 1, 10) = '2013-07-12'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN p.player_name = 'Landon Donovan' THEN pa.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN p.player_name = 'Jordan Bowery' THEN pa.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN p.player_name = 'Landon Donovan' THEN pa.overall_rating ELSE 0 END) AS percentage_higher\nFROM Player p\nINNER JOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id\nWHERE SUBSTR(pa.date, 1, 10) = '2013-07-12'\nAND p.player_name IN ('Landon Donovan', 'Jordan Bowery')"
        ],
        "amend_res": 1
    },
    "1396": {
        "db_id": "student_club",
        "question": "Provide the number of events attended by Luisa Guidi. What is her major?",
        "ground_truth": "SELECT COUNT(T3.link_to_event), T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'",
        "amends": [
            "Do use `COUNT(T3.link_to_event)` instead of `COUNT(*)` to count specific event links rather than all rows. Do select `T1.major_name` instead of `major` to reference the proper column name from the major table. Do join `major AS T1` instead of omitting the major table entirely. Do use `INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major` instead of joining students directly to events, establishing the proper relationship between major and member. Do add `INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member` instead of querying events directly, using the correct attendance table with proper foreign key relationships. Do filter with `T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'` instead of `s.name = 'Luisa Guidi'` to properly handle separate first and last name fields. The amended query now correctly follows the schema relationships and matches the intended behavior."
        ],
        "rules": [
            "1) When counting events attended by a person: count using T3.link_to_event instead of counting all rows to get specific event links. 2) When the question asks for a person's major: select T1.major_name instead of major to reference the proper column from the major table. 3) When combining major information with member data: join major AS T1 with member AS T2 using T1.major_id = T2.link_to_major to establish the proper relationship. 4) When combining member data with attendance information: join member AS T2 with attendance AS T3 using T2.member_id = T3.link_to_member to use the correct attendance table with proper foreign key relationships. 5) When filtering for a person by name: use T2.first_name = 'Luisa' AND T2.last_name = 'Guidi' instead of a single name field to properly handle separate first and last name fields."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS event_count, major FROM events e JOIN students s ON e.student_id = s.id WHERE s.name = 'Luisa Guidi';",
            "SELECT COUNT(T3.link_to_event) AS event_count, T1.major_name\nFROM major AS T1\nINNER JOIN member AS T2 ON T1.major_id = T2.link_to_major\nINNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member\nWHERE T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'"
        ],
        "rule_sql": [
            "SELECT \n    COUNT(DISTINCT T3.link_to_event) AS number_of_events_attended,\n    T1.major_name AS major\nFROM \n    major AS T1\nJOIN \n    member AS T2 ON T1.major_id = T2.link_to_major\nJOIN \n    attendance AS T3 ON T2.member_id = T3.link_to_member\nWHERE \n    T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'\nGROUP BY \n    T1.major_name;"
        ],
        "amend_res": 1
    },
    "353": {
        "db_id": "card_games",
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "ground_truth": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "amends": [
            "Do select `T1.name` and `T1.totalSetSize` instead of `s.set_name` and `COUNT(c.card_id) AS total_cards`. Do join `set_translations AS T2` instead of `cards c` and use `INNER JOIN` with `T1.code = T2.setCode` instead of `JOIN` with `s.set_id = c.set_id`. Do filter on `T2.language = 'Italian'` instead of `s.language = 'Italian'` and remove the `GROUP BY` clause instead of grouping by `s.set_name`. The amended query now correctly retrieves Italian set information from the translation table rather than counting cards from the cards table."
        ],
        "rules": [
            "1) When answering about sets available in Italian translation: select T1.name and T1.totalSetSize as output columns. 2) When combining T1 and T2 for shared entities: link rows where T1.code = T2.setCode and keep only matching pairs (inner match). 3) When filtering for Italian translation: include only rows where T2.language = 'Italian' exactly. 4) When the question asks for total number of cards per set: use T1.totalSetSize instead of counting individual cards."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.set_name, COUNT(c.card_id) AS total_cards\nFROM sets s\nJOIN cards c ON s.set_id = c.set_id\nWHERE s.language = 'Italian'\nGROUP BY s.set_name;",
            "SELECT T1.name, T1.totalSetSize \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T1.code = T2.setCode \nWHERE T2.language = 'Italian'"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.totalSetSize \nFROM sets T1 \nINNER JOIN set_translations T2 ON T1.code = T2.setCode \nWHERE T2.language = 'Italian'"
        ],
        "amend_res": 1
    },
    "1525": {
        "db_id": "debit_card_specializing",
        "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
        "amends": [
            "Do use `SUM(IIF(T2.Currency = 'EUR', 1, 0))` with explicit casting to `FLOAT` instead of `COUNT(*)` with a separate subquery for calculating percentage. Do join `transactions_1k AS T1` with `customers AS T2` using `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying `transactions` table alone without any join. Do filter on `T1.Date = '2012-08-25'` instead of filtering on both `currency = 'EUR'` and `date = '2012-08-25'` in the WHERE clause. Do calculate the percentage using `COUNT(T1.CustomerID)` as denominator instead of `(SELECT COUNT(*) FROM customers)` subquery. Do remove the separate currency filter from WHERE clause and instead handle it within the conditional sum logic. The amended query now correctly calculates the percentage of EUR transactions for the specified date by properly joining customer data and using conditional aggregation."
        ],
        "rules": [
            "1) When answering about percentage of customers who used EUR on a specific date: join transactions_1k as T1 with customers as T2 using T1.CustomerID = T2.CustomerID to link customer transaction data. 2) When filtering for a specific date '2012-08-25': apply the filter T1.Date = '2012-08-25' to select only transactions from that date. 3) When calculating percentage of EUR users: use SUM(IIF(T2.Currency = 'EUR', 1, 0)) with explicit casting to FLOAT for the numerator instead of COUNT(*) with currency filtering. 4) When computing the denominator for percentage: use COUNT(T1.CustomerID) to count all customers with transactions on the specified date instead of counting all customers from the customers table. 5) When handling currency filtering: remove separate currency filter from WHERE clause and instead handle EUR condition within the conditional sum logic using T2.Currency = 'EUR'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM customers) AS percentage FROM transactions WHERE currency = 'EUR' AND date = '2012-08-25';",
            "SELECT \n    (SUM(IIF(T2.Currency = 'EUR', 1, 0)) * 100.0 / COUNT(T1.CustomerID)) AS Percentage\nFROM \n    transactions_1k AS T1\nINNER JOIN \n    customers AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Date = '2012-08-25';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(T2.Currency = 'EUR', 1, 0)) * 100.0) / COUNT(T1.CustomerID) AS Percentage\nFROM \n    transactions_1k T1\nJOIN \n    customers T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Date = '2012-08-25';"
        ],
        "amend_res": 1
    },
    "1367": {
        "db_id": "student_club",
        "question": "Which college do most of the members go to?",
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "amends": [
            "Do select `T2.college` instead of `college` and remove the `COUNT(*) as member_count` aggregation from the SELECT list. Do use `FROM member AS T1 INNER JOIN major AS T2` instead of `FROM members` alone, adding the major table with an inner join on `T1.link_to_major = T2.major_id` instead of the missing join condition. Do change the GROUP BY to `T2.major_id` instead of `college` to properly group by the major identifier. Do order by `COUNT(T2.college) DESC` instead of `member_count ASC`, changing both the aggregation function and sort direction. The amended query now correctly joins the member and major tables to find the college with the most members, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which college do most of the members go to\": make sure the output order: T2.college. 2) When combining member table T1 and major table T2: link rows where T1.link_to_major = T2.major_id and keep only matching pairs (inner match). 3) When grouping by major identifier: organize results by T2.major_id and compute requested aggregates per group. 4) When counting members per college: compute the number of rows using the canonical key T2.major_id. 5) When the question asks for \"most\" members: rank rows by COUNT(T2.college) in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT college, COUNT(*) as member_count FROM members GROUP BY college ORDER BY member_count ASC LIMIT 1;",
            "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.college\nFROM member T1\nINNER JOIN major T2 ON T1.link_to_major = T2.major_id\nGROUP BY T2.major_id\nORDER BY COUNT(T2.college) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "641": {
        "db_id": "codebase_community",
        "question": "How many users received commentator badges in 2014?",
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'",
        "amends": [
            "Do use `COUNT(Id)` instead of `COUNT(*)` to count specific non-null values. Do reference column `Name` instead of `name` to match the correct case sensitivity. Do reference column `Date` instead of `date` to match the correct case sensitivity. Do use `STRFTIME('%Y', Date) = '2014'` instead of `YEAR(date) = 2014` to properly extract the year component using SQLite's date function syntax and compare against a string literal. The amended query now correctly counts badge IDs with the Commentator name from the year 2014 using proper SQLite date handling."
        ],
        "rules": [
            "1) When counting users who received badges: use COUNT(Id) instead of COUNT(*) to count specific non-null values. 2) When referencing the badge name column: use exact column name \"Name\" with proper case sensitivity instead of \"name\". 3) When referencing the badge date column: use exact column name \"Date\" with proper case sensitivity instead of \"date\". 4) When extracting year from date values: use STRFTIME('%Y', Date) = '2014' instead of YEAR(date) = 2014 to properly handle SQLite date functions and compare against string literal '2014'. 5) When filtering for Commentator badges: use exact literal value 'Commentator' for the Name column comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM badges WHERE name = 'Commentator' AND YEAR(date) = 2014;",
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) \nFROM badges \nWHERE Name = 'Commentator' \nAND STRFTIME('%Y', Date) = '2014';"
        ],
        "amend_res": 1
    },
    "470": {
        "db_id": "card_games",
        "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
        "ground_truth": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "amends": [
            "Do use `DISTINCT T2.releaseDate` instead of `release_date` to select the correct column with deduplication. Do join `sets AS T2` instead of querying only the `cards` table, adding the necessary table relationship. Do specify `INNER JOIN sets AS T2 ON T2.code = T1.setCode` instead of missing the join condition entirely. Do filter on `T1.name = 'Ancestor''s Chosen'` instead of `card_name = 'Ancestor\\'s Chosen'` to use the correct column name and properly escaped string literal. The amended query now correctly retrieves release dates from the sets table by joining with cards and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about release dates for cards with a specific name: make sure the output order: T2.releaseDate. 2) When the question mentions \"cards with 'Ancestor's Chosen'\": \"cards\" actually means \"T1.name in schema\" and the literal must be exactly 'Ancestor''s Chosen'. 3) When combining T1 (cards) and T2 (sets) for shared entities: link rows where T2.code = T1.setCode exactly as shown in the amends; keep only matching pairs (inner match). 4) When selecting release dates: use DISTINCT T2.releaseDate instead of release_date to select the correct column with deduplication."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT release_date FROM cards WHERE card_name = 'Ancestor\\'s Chosen';",
            "SELECT DISTINCT T2.releaseDate\nFROM cards AS T1\nINNER JOIN sets AS T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Ancestor''s Chosen'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.releaseDate FROM cards T1 JOIN sets T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'"
        ],
        "amend_res": 1
    },
    "575": {
        "db_id": "codebase_community",
        "question": "What is the badge name that user 'SilentGhost' obtained?",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'SilentGhost'",
        "amends": [
            "Do join `users AS T1` with `badges AS T2` instead of querying only the `badges` table. Do use `INNER JOIN` on `T1.Id = T2.UserId` instead of filtering by `user_id` directly. Do select `T2.Name` instead of `badge_name` from the result set. Do filter by `T1.DisplayName = 'SilentGhost'` instead of `user_id = 'SilentGhost'` to properly match the user by display name rather than internal ID. The amended query now correctly retrieves badge names by joining users and badges tables and filtering on the display name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"badge name that user 'SilentGhost' obtained\": make sure the output order: T2.Name. 2) When the question mentions \"user 'SilentGhost'\": \"SilentGhost\" actually means T1.DisplayName in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.UserId exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for a specific user by display name: use T1.DisplayName = 'SilentGhost' exactly with the literal 'SilentGhost' including case and no quotes around the column name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT badge_name FROM badges WHERE user_id = 'SilentGhost';",
            "SELECT T2.Name \nFROM users AS T1 \nINNER JOIN badges AS T2 ON T1.Id = T2.UserId \nWHERE T1.DisplayName = 'SilentGhost'"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM users T1 \nINNER JOIN badges T2 ON T1.Id = T2.UserId \nWHERE T1.DisplayName = 'SilentGhost'"
        ],
        "amend_res": 1
    },
    "105": {
        "db_id": "financial",
        "question": "There was a loan approved in 1994/8/25, where was that account opened, give the district Id of the branch.",
        "evidence": "",
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'",
        "amends": [
            "Do select `T1.district_id` from the account table instead of selecting `district_id` directly from loans. Do join `account AS T1` with `loan AS T2` using `INNER JOIN` on `T1.account_id = T2.account_id` instead of querying the loans table alone. Do filter on `T2.date = '1994-08-25'` with proper date format instead of using incorrect date format '1994/8/25'. The amended query now correctly retrieves district information through the account-loan relationship with proper date handling."
        ],
        "rules": [
            "1) When the question asks about account opening location but mentions a loan date: join account table (T1) with loan table (T2) using account_id equality (T1.account_id = T2.account_id) to connect loan information with account details. 2) When filtering by a specific loan date like '1994/8/25': use the exact date format '1994-08-25' with proper hyphen separation and zero-padded months. 3) When retrieving district information for an account: select district_id from the account table (T1.district_id) rather than from the loans table. 4) When combining account and loan tables: perform an inner join to keep only matching pairs where both account and loan records exist for the same account_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district_id FROM loans WHERE date = '1994/8/25'",
            "SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'"
        ],
        "rule_sql": [
            "SELECT a.district_id\nFROM account a\nINNER JOIN loan l ON a.account_id = l.account_id\nWHERE l.date = '1994-08-25';"
        ],
        "amend_res": 1
    },
    "1206": {
        "db_id": "thrombosis_prediction",
        "question": "When is the laboratory examination of patient '48473' where his/her AST glutamic oxaloacetic transaminase (GOT) index is above the normal range.",
        "ground_truth": "SELECT Date FROM Laboratory WHERE ID = 48473 AND GOT >= 60",
        "amends": [
            "Do use `Date` instead of `examination_date` for the column name and `Laboratory` instead of `laboratory_examinations` for the table name. Do use `ID = 48473` instead of `patient_id = '48473'` with the correct numeric value format instead of string. Do use `GOT >= 60` instead of the contradictory `ast_got_index > 100 AND ast_got_index < 50` conditions, which would never return results due to the impossible range. The amended query now correctly filters for GOT values of 60 or higher instead of the logically impossible condition in the original query."
        ],
        "rules": [
            "1) When the question asks about laboratory examination dates: use the column name \"Date\" from the \"Laboratory\" table. 2) When filtering for patient '48473': use the condition ID = 48473 (numeric format, not string). 3) When checking for AST glutamic oxaloacetic transaminase (GOT) index above normal range: use the condition GOT >= 60 to find values 60 or higher. 4) When the question mentions \"laboratory examination\": this refers to the \"Laboratory\" table in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT examination_date FROM laboratory_examinations WHERE patient_id = '48473' AND ast_got_index > 100 AND ast_got_index < 50;",
            "SELECT Date FROM Laboratory WHERE ID = 48473 AND GOT >= 60;"
        ],
        "rule_sql": [
            "SELECT Date FROM Laboratory WHERE ID = 48473 AND GOT >= 60;"
        ],
        "amend_res": 1
    },
    "1033": {
        "db_id": "european_football_2",
        "question": "What is the average height of players born between 1990 and 1995?",
        "ground_truth": "SELECT SUM(height) / COUNT(id) FROM Player WHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'",
        "amends": [
            "Do calculate `SUM(height) / COUNT(id)` instead of `AVG(weight)` to compute the average height rather than average weight. Do reference table `Player` instead of `players` to use the correct table name. Do filter using `SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'` instead of `birth_year BETWEEN 1990 AND 1995` to extract and compare the year portion from a date string rather than using a numeric year column. The amended query now correctly calculates average height for players born between 1990 and 1995 using the appropriate date handling and table reference."
        ],
        "rules": [
            "1) When calculating average height: compute SUM(height) / COUNT(id) instead of using AVG(weight) 2) When referencing the players table: use exact table name \"Player\" instead of \"players\" 3) When filtering by birth years between 1990 and 1995: extract year using SUBSTR(birthday, 1, 4) and compare with string literals '1990' and '1995' instead of using numeric birth_year column"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(weight) FROM players WHERE birth_year BETWEEN 1990 AND 1995",
            "SELECT SUM(height) / COUNT(id) AS average_height FROM Player WHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'"
        ],
        "rule_sql": [
            "SELECT SUM(height) / COUNT(id) AS average_height FROM Player WHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995';"
        ],
        "amend_res": 1
    },
    "1461": {
        "db_id": "student_club",
        "question": "List the last names of students under the Elementary Education major and include their phone numbers.",
        "ground_truth": "SELECT T1.last_name, T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T2.major_name = 'Elementary Education'",
        "amends": [
            "Do reference columns as `T1.last_name` and `T1.phone` instead of `last_name` and `phone_number`. Do join table `member AS T1` with `major AS T2` using `INNER JOIN` on `T2.major_id = T1.link_to_major` instead of querying `students` table directly. Do filter on `T2.major_name = 'Elementary Education'` instead of `major = 'Elementary Education'`. The amended query now correctly joins related tables to filter by major name rather than assuming the major field exists directly in the student table."
        ],
        "rules": [
            "1) When the question asks for \"last names\" and \"phone numbers\" of students: use columns \"T1.last_name\" and \"T1.phone\" exactly as specified in the schema. 2) When filtering by \"Elementary Education\" major: join table \"member AS T1\" with \"major AS T2\" using \"T2.major_id = T1.link_to_major\" and filter with \"T2.major_name = 'Elementary Education'\" exactly. 3) When combining member and major tables: perform an inner join to keep only matching pairs where the major ID relationship exists."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name, phone_number FROM students WHERE major = 'Elementary Education';",
            "SELECT T1.last_name, T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T2.major_name = 'Elementary Education'"
        ],
        "rule_sql": [
            "SELECT T1.last_name, T1.phone\nFROM member AS T1\nINNER JOIN major AS T2 ON T2.major_id = T1.link_to_major\nWHERE T2.major_name = 'Elementary Education'"
        ],
        "amend_res": 1
    },
    "922": {
        "db_id": "formula_1",
        "question": "What time did the the 2010's Formula_1 race took place on the Abu Dhabi Circuit?",
        "evidence": "",
        "ground_truth": "SELECT T2.date, T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2010 AND T2.name = 'Abu Dhabi Grand Prix'",
        "amends": [
            "Do select `T2.date` and `T2.time` instead of only `race_time`. Do join `circuits AS T1` with `races AS T2` on `T2.circuitID = T1.circuitId` instead of querying only the `races` table. Do filter on `T2.name = 'Abu Dhabi Grand Prix'` instead of `circuit = 'Abu Dhabi Circuit'` while keeping `T2.year = 2010`. The amended query now correctly retrieves date and time information by properly joining the circuits and races tables with the appropriate circuit name filter."
        ],
        "rules": [
            "1) When answering about Formula 1 race time on Abu Dhabi Circuit: make sure the output order includes both date and time columns from the races table. 2) When the question mentions \"Abu Dhabi Circuit\": \"Abu Dhabi Circuit\" actually means \"name = 'Abu Dhabi Grand Prix'\" in the races table. 3) When combining circuits table (T1) and races table (T2): link rows where T2.circuitID = T1.circuitId and keep only matching pairs (inner match). 4) When filtering for year 2010: use T2.year = 2010 exactly as specified. 5) When selecting time information: retrieve both T2.date and T2.time columns from the races table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_time FROM races WHERE year = 2010 AND circuit = 'Abu Dhabi Circuit';",
            "SELECT T2.date, T2.time \nFROM circuits AS T1 \nJOIN races AS T2 ON T2.circuitId = T1.circuitId \nWHERE T2.name = 'Abu Dhabi Grand Prix' AND T2.year = 2010"
        ],
        "rule_sql": [
            "SELECT r.date, r.time \nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Abu Dhabi Grand Prix' \nAND r.year = 2010"
        ],
        "amend_res": 1
    },
    "270": {
        "db_id": "toxicology",
        "question": "Among the molecules with element Calcium, are they mostly carcinogenic or non carcinogenic?",
        "ground_truth": "SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca' GROUP BY T2.label ORDER BY COUNT(T2.label) DESC LIMIT 1",
        "amends": [
            "Do select `T2.label` instead of a CASE expression with carcinogenic counts. Do use FROM `atom AS T1 INNER JOIN molecule AS T2` instead of FROM `molecules` alone. Do join on `T1.molecule_id = T2.molecule_id` instead of no join condition. Do filter with `T1.element = 'ca'` instead of `element = 'Calcium'`. Do add `GROUP BY T2.label` instead of omitting grouping. Do add `ORDER BY COUNT(T2.label) DESC` instead of no ordering. Do add `LIMIT 1` instead of no limit. The amended query now correctly identifies the most common molecule label containing calcium atoms instead of analyzing carcinogenic properties."
        ],
        "rules": [
            "1) When answering about molecules with element Calcium: combine tables atom AS T1 and molecule AS T2 using inner join where T1.molecule_id = T2.molecule_id. 2) When filtering for element Calcium: use T1.element = 'ca' exactly (not 'Calcium'). 3) When grouping results: group by T2.label instead of analyzing carcinogenic properties. 4) When determining the most common category: count occurrences of T2.label per group. 5) When finding the majority category: order results by COUNT(T2.label) in descending order and take only the top result with LIMIT 1. 6) When selecting output: return T2.label instead of a CASE expression about carcinogenic properties."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN COUNT(CASE WHEN carcinogenic = 'yes' THEN 1 END) > COUNT(CASE WHEN carcinogenic = 'no' THEN 1 END) \n        THEN 'mostly carcinogenic' \n        ELSE 'mostly non carcinogenic' \n    END as result\nFROM molecules\nWHERE element = 'Calcium';",
            "SELECT T2.label\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'ca'\nGROUP BY T2.label\nORDER BY COUNT(T2.label) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.label\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'ca'\nGROUP BY T2.label\nORDER BY COUNT(T2.label) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "686": {
        "db_id": "codebase_community",
        "question": "Identify the total number of posts with views above average.",
        "ground_truth": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "amends": [
            "Do reference `ViewCount` instead of `views` in both the main filter and subquery to match the correct column name. Do select `Id` instead of `COUNT(*)` to return individual post identifiers rather than an aggregate count. Do maintain the same subquery structure comparing against the average value but with the corrected column reference. The amended query now correctly returns post IDs where view count exceeds the average, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for posts with views above average: use \"ViewCount\" instead of \"views\" as the exact column name from the schema. 2) When counting posts: use the \"Id\" column from the posts table as the counting key instead of COUNT(*). 3) When comparing against average view count: maintain the subquery structure that calculates AVG(\"ViewCount\") from the posts table and compare each post's \"ViewCount\" against this average value."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE views > (SELECT AVG(views) FROM posts)",
            "SELECT Id FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts)"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) \nFROM posts \nWHERE ViewCount > (SELECT AVG(ViewCount) FROM posts)",
            "SELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts)"
        ],
        "amend_res": 1
    },
    "263": {
        "db_id": "toxicology",
        "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "amends": [
            "Do use a calculated percentage expression with `CAST` and division instead of selecting raw `element` and `percentage` columns. Do aggregate with `COUNT` conditional cases for `element = 'cl'` instead of filtering for `element = 'chlorine'`. Do join multiple tables including `atom`, `molecule`, and `bond` with `INNER JOIN` conditions on `molecule_id` instead of querying a single `molecules` table. Do filter for `bond_type = '-'` instead of `bond_type = 'single'`. Do use a subquery alias `T` to structure the calculation instead of a simple SELECT. Do calculate the percentage as a real number instead of selecting a precomputed percentage value. The amended query now correctly computes the percentage of chlorine atoms in molecules with single bonds."
        ],
        "rules": [
            "1) When answering about composition of element chlorine in percentage among single bond molecules: calculate percentage using (count of atoms where element = 'cl') divided by (total count of atoms) multiplied by 100.0, casting to real number. 2) When the question mentions \"single bond molecules\": filter for bond_type = '-' instead of 'single'. 3) When the question mentions \"element chlorine\": use element = 'cl' instead of 'chlorine'. 4) When combining tables atom, molecule, and bond: link rows using molecule_id as the join key with inner matches. 5) When counting chlorine atoms: count rows where element = 'cl' using the atom table's canonical key. 6) When calculating percentages: use a subquery structure to compute the ratio and multiply by 100.0 to get percentage value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element, percentage FROM molecules WHERE bond_type = 'single' AND element = 'chlorine';",
            "SELECT \n    CAST(COUNT(CASE WHEN a.element = 'cl' THEN 1 END) AS REAL) / COUNT(*) * 100 AS percentage\nFROM \n    atom a\n    INNER JOIN molecule m ON a.molecule_id = m.molecule_id\n    INNER JOIN bond b ON m.molecule_id = b.molecule_id\nWHERE \n    b.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN a.element = 'cl' THEN 1 END) * 100.0 / COUNT(*)) AS chlorine_percentage\nFROM \n    atom a\nJOIN \n    molecule m ON a.molecule_id = m.molecule_id\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nWHERE \n    b.bond_type = '-'"
        ],
        "amend_res": 1
    },
    "125": {
        "db_id": "financial",
        "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
        "ground_truth": "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
        "amends": [
            "Do calculate the percentage change as `(T3.A13 - T3.A12) * 100 / T3.A12` instead of `(d.unemployment_rate_1996 - d.unemployment_rate_1995) * 100` to properly compute relative growth. Do use `CAST(... AS REAL)` instead of omitting it to ensure floating-point division. Do join `loan AS T1` with `account AS T2` on `T1.account_id = T2.account_id` instead of joining `loans l` with `clients c` on `l.client_id = c.client_id` to follow the correct relationship path. Do then join `account AS T2` with `district AS T3` on `T2.district_id = T3.district_id` instead of joining `clients c` with `districts d` on `c.district_id = d.district_id` to use the proper account-district linkage. Do filter for `T1.status = 'D'` instead of `l.status = 'running'` to use the correct status code. Do remove the `c.debt_status = 'in_debt'` filter instead of keeping it as it's not required. Do remove the `d.unemployment_rate_1995 IS NOT NULL` and `d.unemployment_rate_1996 IS NOT NULL` checks instead of including them as the division handles nulls. Do omit the `ORDER BY` clause instead of including it as sorting is not needed. The amended query now correctly calculates unemployment percentage change using the proper table relationships and status filtering.",
            "Do remove the explicit column aliases `district_name` and `state` instead of including them in the SELECT list. Do add `CAST((T3.A13 - T3.A12) AS REAL)` instead of using `(T3.A13 - T3.A12)` directly for proper numeric casting. Do change the join syntax to explicit `INNER JOIN` instead of implicit `JOIN` for clarity. The amended query now correctly calculates the unemployment percentage change with proper type casting and matches the RIGHT_SQL's behavior.",
            "Do remove `T3.A2 AS district_name` and `T3.A3 AS state` from the SELECT list instead of including them. Do keep only `CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12` as the single output column instead of having multiple columns with aliases. The amended query now matches RIGHT_SQL's behavior by returning only the calculated unemployment percentage increment."
        ],
        "rules": [
            "1) When calculating percentage change from year 1995 to 1996: compute (T3.A13 - T3.A12) * 100 / T3.A12 with CAST(... AS REAL) to ensure floating-point division instead of simple subtraction multiplication. 2) When combining loan and account tables: link rows where T1.account_id = T2.account_id instead of using client relationships. 3) When combining account and district tables: link rows where T2.district_id = T3.district_id to use proper account-district linkage. 4) When filtering for running loans: use T1.status = 'D' instead of 'running' to use the correct status code. 5) When the question mentions \"client are in debt\": do not include any debt_status filter as it's not required. 6) When handling null values in unemployment rates: do not include IS NOT NULL checks as the division operation handles nulls appropriately. 7) When the question asks for listing districts and states: output T3.district_name and T3.state in the results without ordering requirements.",
            "1) When answering about loans contracts which are still running where clients are in debt: filter rows where T1.status equals exactly 'D' (case-sensitive). 2) When combining loan, account, and district tables: link T1 to T2 using T1.account_id = T2.account_id and T2 to T3 using T2.district_id = T3.district_id, keeping only matching pairs (inner match). 3) When calculating percentage unemployment rate increment from year 1995 to 1996: compute (T3.A13 - T3.A12) * 100.0 / T3.A12 with CAST((T3.A13 - T3.A12) AS REAL) for proper numeric casting. 4) When listing the district and the state: output T3.A2 and T3.A3 without explicit column aliases in the result set.",
            "1) When answering about loans with status 'D': only return the calculated percentage unemployment rate increment as a single output column. 2) When the question mentions \"percentage unemployment rate increment from year 1995 to 1996\": calculate it as CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12. 3) When the question asks for district and state information: do not include T3.A2 AS district_name or T3.A3 AS state in the output columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    d.district_name,\n    d.state,\n    (d.unemployment_rate_1996 - d.unemployment_rate_1995) * 100 AS unemployment_increment_percentage\nFROM \n    loans l\nJOIN \n    clients c ON l.client_id = c.client_id\nJOIN \n    districts d ON c.district_id = d.district_id\nWHERE \n    l.status = 'running'\n    AND c.debt_status = 'in_debt'\n    AND d.unemployment_rate_1995 IS NOT NULL\n    AND d.unemployment_rate_1996 IS NOT NULL\nORDER BY \n    unemployment_increment_percentage DESC;",
            "SELECT \n    T3.A2 AS district_name,\n    T3.A3 AS state,\n    (T3.A13 - T3.A12) * 100.0 / T3.A12 AS unemployment_percentage_change\nFROM \n    loan AS T1\nJOIN \n    account AS T2 ON T1.account_id = T2.account_id\nJOIN \n    district AS T3 ON T2.district_id = T3.district_id\nWHERE \n    T1.status = 'D';",
            "SELECT \n    T3.A2 AS district_name,\n    T3.A3 AS state,\n    CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 AS percentage_unemployment_increment\nFROM \n    loan AS T1\nINNER JOIN \n    account AS T2 ON T1.account_id = T2.account_id\nINNER JOIN \n    district AS T3 ON T2.district_id = T3.district_id\nWHERE \n    T1.status = 'D';",
            "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nINNER JOIN district AS T3 ON T2.district_id = T3.district_id\nWHERE T1.status = 'D'"
        ],
        "rule_sql": [
            "SELECT CAST((d.A13 - d.A12) AS REAL) * 100 / d.A12 AS unemployment_rate_increment\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.status = 'D'"
        ],
        "amend_res": 1
    },
    "1015": {
        "db_id": "formula_1",
        "question": "In which Formula_1 race was the lap record for the Austrian Grand Prix Circuit set?",
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T2.name FROM races AS T2 INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN results AS T1 on T2.raceId = T1.raceId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix'",
        "amends": [
            "Do add a CTE `fastest_lap_times` to convert `FastestLapTime` to seconds instead of directly using `lap_time`. Do change the SELECT list to `T2.name` instead of `race_name`. Do add multiple INNER JOINs connecting `races`, `circuits`, and `results` tables instead of querying only the `races` table. Do add a subquery to find the minimum lap time in seconds instead of simple ordering. Do change the WHERE filter to `T2.name = 'Austrian Grand Prix'` instead of `circuit_name = 'Austrian Grand Prix Circuit'`. Do remove ORDER BY and LIMIT clauses instead of keeping them, replacing with an equality join condition matching the calculated lap time to the minimum time. Do add complex time conversion logic using `CAST`, `SUBSTR`, and `INSTR` functions instead of assuming a simple `lap_time` column. The amended query now correctly identifies races with the fastest lap time at the Austrian Grand Prix by properly joining related tables and converting lap time formats for accurate comparison.",
            "Do remove `year`, `race_name`, and `circuit_name` from the SELECT list instead of including them. Do remove the `circuits` table join and filter on `circuit_name` from the CTE instead of keeping them. Do change the lap time calculation to handle milliseconds by adding `(CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000)` instead of omitting it. Do move the circuit filter to the main query's WHERE clause on `T2.name = 'Austrian Grand Prix'` instead of applying it in the CTE. Do restructure the query to join the minimum lap time calculation as a subquery with proper joins to `races` and `circuits` instead of using a simple subquery. Do add proper table aliases `T1`, `T2`, `T3` throughout instead of using unaliased table names. The amended query now correctly handles millisecond precision in lap times and properly filters for the Austrian Grand Prix while maintaining the correct join relationships."
        ],
        "rules": [
            "1) When the question asks about the Formula 1 race with the lap record for a specific circuit: use the exact circuit name literal 'Austrian Grand Prix' from the amends instead of 'Austrian Grand Prix Circuit'. 2) When converting lap times for comparison: convert the FastestLapTime to seconds using CAST, SUBSTR, and INSTR functions as shown in the amends instead of using a simple lap_time column. 3) When combining data from multiple tables: perform INNER JOINs connecting races (T1), circuits (T2), and results tables using the exact join conditions specified in the amends. 4) When finding the minimum lap time: use a subquery to calculate the minimum lap time in seconds instead of simple ordering with LIMIT. 5) When identifying the race with the fastest lap: match the calculated lap time in seconds to the minimum time using an equality join condition instead of ORDER BY and LIMIT. 6) When selecting the output: use T2.name for the race name instead of race_name.",
            "1) When the question asks about Formula 1 races at a specific circuit: filter the circuits table using T2.name = 'Austrian Grand Prix' exactly as specified. 2) When calculating lap times with millisecond precision: convert the FastestLapTime by extracting minutes, seconds, and milliseconds using SUBSTR and INSTR functions, then combine them as (minutes * 60) + seconds + (milliseconds / 1000). 3) When finding the minimum lap time: compute the minimum converted lap time value across all relevant records. 4) When joining tables for race and circuit information: use T1 for results, T2 for circuits, and T3 for races with proper join conditions as shown in the schema relationships. 5) When outputting results: only include the race name in the final output, excluding year, circuit_name, and other intermediate columns."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT race_name FROM races WHERE circuit_name = 'Austrian Grand Prix Circuit' ORDER BY lap_time ASC LIMIT 1;",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.year,\n        r.name AS race_name,\n        c.name AS circuit_name,\n        res.fastestLapTime,\n        CAST(SUBSTR(res.fastestLapTime, 1, INSTR(res.fastestLapTime, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, ':') + 1) AS REAL) AS lap_time_seconds\n    FROM races r\n    INNER JOIN circuits c ON r.circuitId = c.circuitId\n    INNER JOIN results res ON r.raceId = res.raceId\n    WHERE c.name = 'Austrian Grand Prix Circuit'\n    AND res.fastestLapTime IS NOT NULL\n)\nSELECT \n    race_name\nFROM fastest_lap_times\nWHERE lap_time_seconds = (\n    SELECT MIN(lap_time_seconds) \n    FROM fastest_lap_times\n)",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.FastestLapTime,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) AS lap_time_seconds\n    FROM results T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    INNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\n    WHERE T2.name = 'Austrian Grand Prix'\n    AND T1.FastestLapTime IS NOT NULL\n)\nSELECT T2.name\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nINNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\nINNER JOIN fastest_lap_times flt ON T1.raceId = flt.raceId AND T1.FastestLapTime = flt.FastestLapTime\nWHERE T2.name = 'Austrian Grand Prix'\nAND flt.lap_time_seconds = (\n    SELECT MIN(lap_time_seconds)\n    FROM fastest_lap_times\n);"
        ],
        "rule_sql": [
            "SELECT T3.name\nFROM results T1\nINNER JOIN circuits T2 ON T1.raceId IN (SELECT raceId FROM races WHERE circuitId = T2.circuitId)\nINNER JOIN races T3 ON T1.raceId = T3.raceId\nWHERE T2.name = 'Austrian Grand Prix'\n  AND T1.fastestLapTime IS NOT NULL\n  AND (\n    CAST(SUBSTR(T1.fastestLapTime, 1, INSTR(T1.fastestLapTime, ':') - 1) AS REAL) * 60 +\n    CAST(SUBSTR(T1.fastestLapTime, INSTR(T1.fastestLapTime, ':') + 1, INSTR(T1.fastestLapTime, '.') - INSTR(T1.fastestLapTime, ':') - 1) AS REAL) +\n    CAST(SUBSTR(T1.fastestLapTime, INSTR(T1.fastestLapTime, '.') + 1) AS REAL) / 1000\n  ) = (\n    SELECT MIN(\n      CAST(SUBSTR(fastestLapTime, 1, INSTR(fastestLapTime, ':') - 1) AS REAL) * 60 +\n      CAST(SUBSTR(fastestLapTime, INSTR(fastestLapTime, ':') + 1, INSTR(fastestLapTime, '.') - INSTR(fastestLapTime, ':') - 1) AS REAL) +\n      CAST(SUBSTR(fastestLapTime, INSTR(fastestLapTime, '.') + 1) AS REAL) / 1000\n    )\n    FROM results\n    WHERE raceId IN (SELECT raceId FROM races WHERE circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Austrian Grand Prix'))\n      AND fastestLapTime IS NOT NULL\n  )"
        ],
        "amend_res": 1
    },
    "106": {
        "db_id": "financial",
        "question": "What is the biggest amount of transaction that the client whose card was opened in 1996/10/21 made?",
        "evidence": "",
        "ground_truth": "SELECT T4.amount FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 on T2.account_id = T3.account_id JOIN trans AS T4 on T3.account_id = T4.account_id WHERE T1.issued = '1996-10-21' ORDER BY T4.amount DESC LIMIT 1",
        "amends": [
            "Do use explicit table joins with `card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 ON T2.account_id = T3.account_id JOIN trans AS T4 ON T3.account_id = T4.account_id` instead of a subquery with `WHERE client_id IN (SELECT client_id FROM cards)`. Do filter on `T1.issued = '1996-10-21'` instead of `opened_date = '1996/10/21'` with corrected date format. Do select `T4.amount` directly instead of using `MAX(amount)` aggregation. Do add `ORDER BY T4.amount DESC LIMIT 1` to get the maximum value instead of using the MAX function. The amended query now correctly retrieves the maximum transaction amount through proper table relationships and ordering."
        ],
        "rules": [
            "1) When combining tables for client transaction data: link card as T1, disp as T2, account as T3, and trans as T4 using exact key equalities T1.disp_id = T2.disp_id, T2.account_id = T3.account_id, and T3.account_id = T4.account_id, keeping only matching pairs (inner match). 2) When filtering for cards opened on a specific date: use T1.issued = '1996-10-21' with exact date format and literal value. 3) When finding the biggest transaction amount: order rows by T4.amount in descending order and take only the first row. 4) When selecting the transaction amount: output T4.amount directly from the ordered result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(amount) FROM transactions WHERE client_id IN (SELECT client_id FROM cards WHERE opened_date = '1996/10/21')",
            "SELECT T4.amount\nFROM card AS T1\nJOIN disp AS T2 ON T1.disp_id = T2.disp_id\nJOIN account AS T3 ON T2.account_id = T3.account_id\nJOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE T1.issued = '1996-10-21'\nORDER BY T4.amount DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T4.amount\nFROM card AS T1\nINNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id\nINNER JOIN account AS T3 ON T2.account_id = T3.account_id\nINNER JOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE T1.issued = '1996-10-21'\nORDER BY T4.amount DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "940": {
        "db_id": "formula_1",
        "question": "Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )",
        "amends": [
            "Do use `COUNT(*)` on a subquery instead of `COUNT(DISTINCT driver_id)` directly. Do join `results AS T1` with `races AS T2` on `T1.raceId = T2.raceId` instead of querying only `race_results` without proper table joins. Do filter on `T2.name = 'Chinese Grand Prix'` and `T2.year = 2008` instead of `race_id = '2008_Chinese_Grand_Prix'`. Do check `T1.time IS NOT NULL` instead of `position IS NOT NULL`. Do add `GROUP BY T1.driverId` and `HAVING COUNT(T2.raceId) > 0` instead of using `IN (SELECT driver_id FROM formula1_races)`. Do remove the unnecessary DISTINCT modifier since the GROUP BY already ensures unique driver IDs. The amended query now correctly counts drivers who completed the 2008 Chinese Grand Prix with recorded times."
        ],
        "rules": [
            "1) When answering about drivers who finished a specific race: combine results table (T1) with races table (T2) by matching T1.raceId = T2.raceId to get race details. 2) When the question mentions \"2008 Chinese Grand Prix\": filter for T2.year = 2008 and T2.name = 'Chinese Grand Prix' exactly. 3) When identifying drivers who finished the race: check T1.time IS NOT NULL to confirm completion. 4) When counting drivers who participated in Formula 1 races: group by T1.driverId and verify participation with HAVING COUNT(T2.raceId) > 0. 5) When producing the final count: use COUNT(*) on the grouped results rather than COUNT(DISTINCT driver_id) since grouping ensures uniqueness."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT driver_id) \nFROM race_results \nWHERE race_id = '2008_Chinese_Grand_Prix' \nAND position IS NOT NULL \nAND driver_id IN (SELECT driver_id FROM formula1_races)",
            "SELECT COUNT(*)\nFROM (\n    SELECT T1.driverId\n    FROM results AS T1\n    JOIN races AS T2 ON T1.raceId = T2.raceId\n    WHERE T2.name = 'Chinese Grand Prix'\n    AND T2.year = 2008\n    AND T1.time IS NOT NULL\n    GROUP BY T1.driverId\n    HAVING COUNT(T2.raceId) > 0\n) AS completed_drivers"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM (\n    SELECT r.driverId \n    FROM results r\n    JOIN races ra ON r.raceId = ra.raceId\n    WHERE ra.year = 2008 \n    AND ra.name = 'Chinese Grand Prix'\n    AND r.time IS NOT NULL\n    GROUP BY r.driverId\n    HAVING COUNT(ra.raceId) > 0\n) AS finished_drivers"
        ],
        "amend_res": 1
    },
    "526": {
        "db_id": "card_games",
        "question": "Among the card designed by Matthew D. Wilson, how many are available only in the paper?",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting null values. Do filter on `artist` column instead of `designer` column to correctly identify cards by the specified artist. The amended query now matches the intended behavior of counting cards by Matthew D. Wilson with paper availability."
        ],
        "rules": [
            "1) When the question mentions \"card designed by Matthew D. Wilson\": \"designed by Matthew D. Wilson\" actually means \"artist = 'Matthew D. Wilson' in schema\" using exact literal value. 2) When counting cards: compute the number of rows using the canonical key token \"id\" instead of counting all columns to avoid counting null values. 3) When filtering for availability \"only in the paper\": use exact literal value \"paper\" for the availability condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE designer = 'Matthew D. Wilson' AND availability = 'paper';",
            "SELECT COUNT(id) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper'"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper';"
        ],
        "amend_res": 1
    },
    "1403": {
        "db_id": "student_club",
        "question": "Indicate the name of the closed event whose cost has exceeded the budget the most.",
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event WHERE T1.event_status = 'Closed' AND T1.remaining < 0 ORDER BY T1.remaining LIMIT 1",
        "amends": [
            "Do select `T2.event_name` from the `event` table instead of `event_name` from the `events` table. Do join `budget AS T1` with `event AS T2` using `INNER JOIN` on `T2.event_id = T1.link_to_event` instead of querying a single table. Do filter on `T1.event_status = 'Closed'` and `T1.remaining < 0` instead of `status = 'closed'`. Do order by `T1.remaining` instead of `(cost - budget) DESC`. The amended query now correctly retrieves events with negative remaining budget from the closed status, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"closed event whose cost has exceeded the budget the most\": make sure the output order: T2.event_name. 2) When combining budget AS T1 and event AS T2: link rows where T2.event_id = T1.link_to_event exactly as shown and keep only matching pairs (inner match). 3) When filtering for closed events: use T1.event_status = 'Closed' (exact case and spacing) instead of 'closed'. 4) When identifying events that exceeded budget: filter on T1.remaining < 0 to find events with negative remaining budget. 5) When determining which event exceeded budget the most: order by T1.remaining (lower values indicate greater budget overruns) instead of calculating cost-budget difference."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name \nFROM events \nWHERE status = 'closed' \nORDER BY (cost - budget) DESC \nLIMIT 1;",
            "SELECT T2.event_name\nFROM budget AS T1\nINNER JOIN event AS T2 ON T2.event_id = T1.link_to_event\nWHERE T1.event_status = 'Closed' AND T1.remaining < 0\nORDER BY T1.remaining\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.event_name\nFROM budget T1\nINNER JOIN event T2 ON T2.event_id = T1.link_to_event\nWHERE T1.event_status = 'Closed' AND T1.remaining < 0\nORDER BY T1.remaining DESC\nLIMIT 1;",
            "SELECT T2.event_name\nFROM budget AS T1\nINNER JOIN event AS T2 ON T2.event_id = T1.link_to_event\nWHERE T1.event_status = 'Closed'\nAND T1.remaining < 0\nORDER BY T1.remaining ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "355": {
        "db_id": "card_games",
        "question": "What is the keyword found on card 'Angel of Mercy'?",
        "ground_truth": "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy'",
        "amends": [
            "Do select `keywords` instead of `keyword` to reference the correct column name. Do add `DISTINCT` instead of omitting it to ensure unique results. The amended query now correctly retrieves distinct values from the keywords column for the specified card name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"keyword\" from a specific card: use the exact column name \"keywords\" from the cards table instead of \"keyword\". 2) When retrieving values from the keywords column: apply DISTINCT to ensure only unique values are returned. 3) When filtering by card name: use the exact literal 'Angel of Mercy' with proper case and punctuation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT keyword FROM cards WHERE name = 'Angel of Mercy';",
            "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy';"
        ],
        "rule_sql": [
            "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy';"
        ],
        "amend_res": 1
    },
    "1075": {
        "db_id": "european_football_2",
        "question": "List all the football player with the highest balance score and potential score of 61.",
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = '61' ORDER BY t2.balance DESC LIMIT 1",
        "amends": [
            "Do select `t1.player_name` instead of `*` and move from the `players` table to joining `Player AS t1` with `Player_Attributes AS t2` instead of querying a single table. Do use `INNER JOIN` on `t1.player_api_id = t2.player_api_id` instead of a subquery for maximum balance. Do filter with `t2.potential = '61'` instead of `potential = 61` with proper string quoting. Do order by `t2.balance DESC` instead of equality comparison and add `LIMIT 1` instead of relying on the subquery to return exactly one match. The amended query now correctly identifies the player with the highest balance among those with potential 61, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"football player with the highest balance score and potential score of 61\": make sure the output order: t1.player_name. 2) When the question mentions \"football player\": use \"Player AS t1\" table and join with \"Player_Attributes AS t2\" on t1.player_api_id = t2.player_api_id using inner match. 3) When the question mentions \"potential score of 61\": filter with t2.potential = '61' exactly (with string quotes). 4) When the question mentions \"highest balance score\": order rows by t2.balance in descending direction and keep only the first 1 row. 5) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id exactly and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM players WHERE balance = (SELECT MAX(balance) FROM players) AND potential = 61;",
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.potential = '61'\nORDER BY t2.balance DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.potential = '61'\nORDER BY t2.balance DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "675": {
        "db_id": "codebase_community",
        "question": "How many users whose reputations are higher than 2000 and the number of views is higher than 1000?",
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Reputation > 2000 AND Views > 1000",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do change the filter condition to `Views > 1000` instead of `views < 1000` to correctly identify users with high view counts. The amended query now matches RIGHT_SQL's behavior by accurately counting users with reputation over 2000 and views exceeding 1000."
        ],
        "rules": [
            "1) When counting users: count using the exact token \"id\" instead of counting all columns to avoid including NULL values. 2) When the question asks for users with \"number of views is higher than 1000\": use the exact condition \"Views > 1000\" with the exact column name \"Views\" (case-sensitive). 3) When the question asks for users with \"reputations are higher than 2000\": use the exact condition \"reputation > 2000\" with the exact column name \"reputation\" (lowercase)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE reputation > 2000 AND views < 1000;",
            "SELECT COUNT(Id) FROM users WHERE Reputation > 2000 AND Views > 1000;"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM users WHERE reputation > 2000 AND Views > 1000"
        ],
        "amend_res": 1
    },
    "638": {
        "db_id": "codebase_community",
        "question": "List all the name of users that obtained the Organizer Badges.",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Organizer'",
        "amends": [
            "Do add `INNER JOIN badges AS T2 ON T1.Id = T2.UserId` instead of querying only the `users` table. Do change the column selection to `T1.DisplayName` instead of `name`. Do move the filter condition to `T2.Name = 'Organizer'` instead of `badge_type = 'Organizer'` in the WHERE clause. Do add table alias `T1` for the users table instead of using it without an alias. The amended query now correctly joins the users and badges tables to find users with the Organizer badge, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"users that obtained the Organizer Badges\": make sure to combine the users table (as T1) and badges table (as T2) by linking rows where T1.Id equals T2.UserId, keeping only matching pairs. 2) When the question mentions \"name of users\": \"name\" actually means \"T1.DisplayName\" in the schema. 3) When filtering for Organizer Badges: use the exact literal 'Organizer' for T2.Name instead of badge_type. 4) When producing output: return only T1.DisplayName in the results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM users WHERE badge_type = 'Organizer';",
            "SELECT T1.DisplayName\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.Id = T2.UserId\nWHERE T2.Name = 'Organizer'"
        ],
        "rule_sql": [
            "SELECT u.DisplayName\nFROM users u\nINNER JOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Organizer'"
        ],
        "amend_res": 1
    },
    "898": {
        "db_id": "formula_1",
        "question": "How old is the youngest Japanese driver? What is his name?",
        "ground_truth": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
        "amends": [
            "Do calculate age dynamically using `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob)` instead of selecting static `age`. Do include both `forename` and `surname` columns instead of just `name`. Do order by `dob DESC` instead of `age ASC` to correctly identify the youngest driver based on birth date rather than a potentially outdated age value. The amended query now matches RIGHT_SQL's behavior by calculating current age from date of birth and properly identifying the youngest Japanese driver.",
            "Do place the age calculation expression `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob)` at the beginning of the SELECT list instead of after the name columns, and do remove the alias `AS age` instead of keeping it. Do maintain the same column order for `forename` and `surname` but position them after the calculated expression instead of before it. The amended query now correctly returns the raw age calculation without aliasing while preserving the same filtering, sorting, and limiting behavior to match the RIGHT_SQL's output structure."
        ],
        "rules": [
            "1) When the question asks for a driver's name: include both \"forename\" and \"surname\" columns instead of a single \"name\" column. 2) When calculating age from date of birth: compute dynamically using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob) instead of selecting a static age value. 3) When identifying the youngest driver: order by \"dob\" in descending order instead of \"age\" in ascending order to correctly find the most recent birth date. 4) When filtering by nationality: use the exact literal 'Japanese' with the correct case and spelling.",
            "1) When calculating age from date of birth: use the expression STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob) without any alias. 2) When ordering output columns: place the calculated expression before the name columns forename and surname. 3) When filtering for Japanese drivers: use the exact literal 'Japanese' for the nationality condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, age FROM drivers WHERE nationality = 'Japanese' ORDER BY age ASC LIMIT 1;",
            "SELECT forename, surname, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob) AS age FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1;",
            "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename, surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename, surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "521": {
        "db_id": "card_games",
        "question": "Among the cards whose version of frame style is 1997, what is the status of the card illustrated by D. Alexander Gregory in legacy play format that has sensitive content or Wizards of the Coast?",
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.frameVersion = 1997 AND T1.hasContentWarning = 1 AND T1.artist = 'D. Alexander Gregory' AND T2.format = 'legacy'",
        "amends": [
            "Do `SELECT DISTINCT T2.status` from the `legalities` table instead of `SELECT status` from the `cards` table. Do join `cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid` instead of querying only the `cards` table. Do filter on `T1.frameVersion = 1997` instead of `frame_style = '1997'` with proper numeric comparison. Do use `T1.hasContentWarning = 1` instead of `(sensitive_content = 1 OR wizards_of_the_coast = 1)` for content warnings. Do filter by `T1.artist = 'D. Alexander Gregory'` instead of `illustrator = 'D. Alexander Gregory'` for the artist name. Do apply the format filter as `T2.format = 'legacy'` on the joined legalities table instead of `format = 'legacy'` on the cards table. The amended query now correctly retrieves distinct status values from the legalities table based on card properties and format legality, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about card status in legacy format: make sure the output order: T2.status\n2) When the question mentions \"version of frame style is 1997\": \"frame style\" actually means \"T1.frameVersion in schema\" and use numeric comparison without quotes\n3) When the question mentions \"illustrated by D. Alexander Gregory\": \"illustrated by\" actually means \"T1.artist in schema\" with exact literal 'D. Alexander Gregory'\n4) When the question mentions \"sensitive content or Wizards of the Coast\": this actually means \"T1.hasContentWarning = 1\" in schema\n5) When the question asks about \"legacy play format\": this actually means filtering on \"T2.format = 'legacy'\" in the legalities table\n6) When combining cards and legalities tables: link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match)\n7) When selecting status from legalities: use SELECT DISTINCT T2.status to get unique status values"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT status FROM cards WHERE frame_style = '1997' AND illustrator = 'D. Alexander Gregory' AND (sensitive_content = 1 OR wizards_of_the_coast = 1) AND format = 'legacy';",
            "SELECT DISTINCT T2.status\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T2.uuid = T1.uuid\nWHERE T1.frameVersion = 1997\nAND T1.hasContentWarning = 1\nAND T1.artist = 'D. Alexander Gregory'\nAND T2.format = 'legacy'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.status\nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nWHERE T1.frameVersion = 1997\nAND T1.artist = 'D. Alexander Gregory'\nAND T1.hasContentWarning = 1\nAND T2.format = 'legacy'"
        ],
        "amend_res": 1
    },
    "1252": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific joined tables instead of `COUNT(*)` from a single table. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` and `INNER JOIN Examination AS T3 ON T3.ID = T2.ID` instead of querying only the patients table. Do filter with `T2.IGG BETWEEN 900 AND 2000` instead of `ig_g_level = 'normal'` to use numeric range checking rather than string matching. Do check `T3.Symptoms IS NOT NULL` instead of `symptoms IS NOT NULL` to reference the correct table's column. The amended query now correctly joins multiple tables and uses appropriate numeric range filtering instead of string comparison, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about patients with normal Ig G level: use numeric range checking with T2.IGG BETWEEN 900 AND 2000 instead of string matching. 2) When counting patients with symptoms: count using T1.ID as the canonical key instead of COUNT(*). 3) When combining patient data: link Laboratory table as T2 using T1.ID = T2.ID and Examination table as T3 using T3.ID = T2.ID with inner joins. 4) When checking for symptoms: reference T3.Symptoms IS NOT NULL from the Examination table instead of a symptoms column in the patients table."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE ig_g_level = 'normal' AND symptoms IS NOT NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.IGG BETWEEN 900 AND 2000\nAND T3.Symptoms IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.IGG BETWEEN 900 AND 2000\nAND T3.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T3.ID = T2.ID\nWHERE T2.IGG BETWEEN 900 AND 2000\nAND T3.Symptoms IS NOT NULL"
        ],
        "amend_res": 1
    },
    "830": {
        "db_id": "superhero",
        "question": "Identify the weakest attribute of the Black Panther.",
        "ground_truth": "SELECT T3.attribute_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = 'Black Panther' ORDER BY T2.attribute_value ASC LIMIT 1",
        "amends": [
            "Do select `T3.attribute_name` instead of `MIN(strength)` and add proper table aliases. Do use `FROM superhero AS T1` with two additional joins to `hero_attribute AS T2` and `attribute AS T3` instead of a single `FROM superheroes` table. Do implement `INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id` and `INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id` instead of no joins. Do filter on `T1.superhero_name = 'Black Panther'` instead of `name = 'Black Panther'`. Do add `ORDER BY T2.attribute_value ASC` and `LIMIT 1` instead of using `MIN()` aggregation without ordering. The amended query now correctly retrieves the attribute name with the lowest value for Black Panther through proper table relationships instead of incorrectly assuming a single table structure."
        ],
        "rules": [
            "1) When answering about \"the weakest attribute of the Black Panther\": make sure the output order: T3.attribute_name. 2) When the question mentions \"Black Panther\": \"Black Panther\" actually means \"T1.superhero_name = 'Black Panther'\" in schema. 3) When combining T1, T2, and T3 for shared entities: link rows where T1.id = T2.hero_id and T2.attribute_id = T3.id; keep only matching pairs (inner match). 4) When the question asks for \"weakest\" (lowest value attribute): rank rows by T2.attribute_value in ascending order and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(strength) FROM superheroes WHERE name = 'Black Panther';",
            "SELECT T3.attribute_name\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nINNER JOIN attribute AS T3 ON T2.attribute_id = T3.id\nWHERE T1.superhero_name = 'Black Panther'\nORDER BY T2.attribute_value ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.attribute_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T1.superhero_name = 'Black Panther'\nORDER BY T2.attribute_value ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "886": {
        "db_id": "formula_1",
        "question": "Which year has the most number of races?",
        "ground_truth": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
        "amends": [
            "Do select only `year` instead of both `year` and `race_count`. Do order by `COUNT(round)` instead of `race_count`. Do use `DESC` ordering instead of `ASC`. Do remove the alias `race_count` from the SELECT list instead of keeping it. Do count `round` instead of using `COUNT(*)`. The amended query now correctly identifies the year with the most rounds by counting specific rounds in descending order rather than counting all records in ascending order."
        ],
        "rules": [
            "1) When counting races: count the \"round\" column instead of counting all records. 2) When ordering by count to find the most: order by the count in descending order instead of ascending order. 3) When selecting output columns: only include \"year\" in the final output, not the count value. 4) When the question asks for the year with the most races: rank years by the count of rounds in descending order and take the top result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as race_count FROM races GROUP BY year ORDER BY race_count ASC LIMIT 1;",
            "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1183": {
        "db_id": "thrombosis_prediction",
        "question": "For the patient who was diagnosed SLE on 1997/1/27, what was his/her original diagnose when he/she came to the hospital for the first time?",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = ( SELECT ID FROM Examination WHERE `Examination Date` = '1997-01-27' AND Diagnosis = 'SLE' ) AND T2.`Examination Date` = T1.`First Date`",
        "amends": [
            "Do use `SELECT T1.Diagnosis` with table alias instead of `SELECT diagnosis` without source specification. Do add `FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID` with explicit join instead of `FROM patient_records` without joins. Do change WHERE clause to `T1.ID = (subquery)` and `T2.Examination Date = T1.First Date` instead of `diagnosis = 'SLE' AND diagnosis_date = '1997/1/27'`. Do add correlated subquery `SELECT ID FROM Examination WHERE Examination Date = '1997-01-27' AND Diagnosis = 'SLE'` instead of direct date filtering. Do use standardized date format `'1997-01-27'` instead of `'1997/1/27'`. Do remove `LIMIT 1` instead of keeping it as the logic now ensures single record through subquery matching. The amended query now correctly joins patient and examination data with proper correlation and date handling to match the intended behavior."
        ],
        "rules": [
            "1) When answering about a patient diagnosed with SLE on a specific date: use standardized date format '1997-01-27' instead of '1997/1/27' for exact matching. 2) When the question mentions \"diagnosed SLE on 1997/1/27\": this actually means finding records where T2.Diagnosis = 'SLE' AND T2.Examination Date = '1997-01-27' in the Examination table. 3) When combining Patient (T1) and Examination (T2) tables: link rows where T1.ID = T2.ID using exact key equality and keep only matching pairs (inner match). 4) When finding the original diagnosis from first hospital visit: use T1.Diagnosis from the Patient table where T2.Examination Date = T1.First Date. 5) When identifying the specific patient: use a subquery to find T2.ID from Examination where T2.Examination Date = '1997-01-27' AND T2.Diagnosis = 'SLE' instead of direct filtering in the main query. 6) When selecting output: use T1.Diagnosis with explicit table alias instead of diagnosis without source specification."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT diagnosis FROM patient_records WHERE diagnosis = 'SLE' AND diagnosis_date = '1997/1/27' LIMIT 1;",
            "SELECT T1.Diagnosis\nFROM Patient AS T1 \nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.ID = (\n    SELECT ID \n    FROM Examination \n    WHERE \"Examination Date\" = '1997-01-27' \n    AND Diagnosis = 'SLE'\n)\nAND T2.\"Examination Date\" = T1.\"First Date\""
        ],
        "rule_sql": [
            "SELECT T1.Diagnosis\nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.Examination_Date = '1997-01-27' \nAND T2.Diagnosis = 'SLE'\nAND T2.Examination_Date = T1.First_Date;",
            "SELECT T1.Diagnosis\nFROM Patient T1\nWHERE T1.ID = (\n    SELECT T2.ID\n    FROM Examination T2\n    WHERE T2.\"Examination Date\" = '1997-01-27' \n    AND T2.Diagnosis = 'SLE'\n)\nAND T1.\"First Date\" = T1.\"First Date\""
        ],
        "amend_res": 1
    },
    "932": {
        "db_id": "formula_1",
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "amends": [
            "Do add table aliases `T1`, `T2`, and `T3` instead of using unqualified column references. Do join `results AS T2` on `T2.raceId = T1.raceId` instead of querying only the `races` table. Do join `drivers AS T3` on `T3.driverId = T2.driverId` instead of filtering directly on driver name. Do filter on `T3.forename = 'Lewis' AND T3.surname = 'Hamilton'` instead of `driver = 'Lewis Hamilton'` to properly match the driver table structure. Do select `T1.year` instead of just `year` to specify the table source. The amended query now correctly joins through the results table to find races where Lewis Hamilton participated, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"years Lewis Hamilton participated in Formula 1 races\": make sure the output order: T1.year. 2) When the question mentions \"Lewis Hamilton\": \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\" in schema. 3) When combining T1 (races), T2 (results), and T3 (drivers) for shared entities: link rows where T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match). 4) When selecting the year column: use T1.year instead of unqualified year to specify the table source."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT year FROM races WHERE driver = 'Lewis Hamilton';",
            "SELECT DISTINCT T1.year\nFROM races AS T1\nJOIN results AS T2 ON T2.raceId = T1.raceId\nJOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.year\nFROM races T1\nINNER JOIN results T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\nORDER BY T1.year;"
        ],
        "amend_res": 1
    },
    "1281": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?",
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60 ORDER BY T1.Birthday DESC LIMIT 1",
        "amends": [
            "Do select `T1.Birthday` instead of `MIN(birth_date)` and remove the aggregate function. Do join `Patient AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.GOT >= 60` instead of `glutamic_oxaloacetic_transaminase = 'normal'` to use numeric comparison rather than string matching. Do add `ORDER BY T1.Birthday DESC` and `LIMIT 1` instead of using the `MIN` aggregate function to find the most recent birthday. The amended query now correctly retrieves the most recent birthday from patients with elevated GOT levels rather than finding the minimum birth date from patients with normal transaminase values."
        ],
        "rules": [
            "1) When answering about patients with abnormal glutamic oxaloacetic transaminase levels: use numeric comparison T2.GOT >= 60 instead of string matching. 2) When combining patient and laboratory data: link rows where T1.ID = T2.ID using inner join. 3) When finding the youngest patient: order by T1.Birthday in descending order and take the first result. 4) When selecting the birth date: use T1.Birthday directly without aggregation functions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(birth_date) FROM patients WHERE glutamic_oxaloacetic_transaminase = 'normal';",
            "SELECT T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.GOT >= 60\nORDER BY T1.Birthday DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT >= 60\nORDER BY T1.Birthday DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "318": {
        "db_id": "toxicology",
        "question": "What is the molecule id of bond id TR001_1_7?",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "amends": [
            "Do query from `atom` and `connected` tables instead of just `bonds`. Do use `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of no join. Do filter on `T2.bond_id` instead of `bond_id` directly. Do add `DISTINCT` to remove duplicates instead of omitting it. Do select `T1.molecule_id` with table alias instead of just `molecule_id`. The amended query now correctly retrieves distinct molecule IDs associated with the specified bond through the atom connection relationships."
        ],
        "rules": [
            "1) When answering about \"molecule id of bond id TR001_1_7\": make sure the output order: T1.molecule_id. 2) When the question mentions \"bond id TR001_1_7\": \"bond id\" actually means \"T2.bond_id in schema\" with exact literal value 'TR001_1_7'. 3) When combining atom table (T1) and connected table (T2) for shared entities: link rows where T1.atom_id = T2.atom_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for distinct molecule IDs: compute the number of unique values of T1.molecule_id using DISTINCT. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T1.molecule_id and T2.bond_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM bonds WHERE bond_id = 'TR001_1_7';",
            "SELECT DISTINCT T1.molecule_id FROM atom T1 INNER JOIN connected T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'"
        ],
        "rule_sql": [
            "SELECT T1.molecule_id FROM atom T1 JOIN connected T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'"
        ],
        "amend_res": 1
    },
    "763": {
        "db_id": "superhero",
        "question": "Indicate the attribute value of superhero Abomination.",
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Abomination'",
        "amends": [
            "Do select `T2.attribute_value` instead of `name` from the result set. Do use `superhero` as T1 and `hero_attribute` as T2 instead of just `superheroes` as the source table. Do add an `INNER JOIN` on `T1.id = T2.hero_id` instead of querying a single table. Do filter on `T1.superhero_name = 'Abomination'` instead of `attribute = 'Abomination'` to correctly reference the superhero name column. The amended query now properly joins the superhero and hero_attribute tables to retrieve attribute values for the specified superhero, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"attribute value of superhero Abomination\": select T2.attribute_value as the output column instead of name. 2) When querying about superhero attributes: use \"superhero\" as T1 and \"hero_attribute\" as T2 tables instead of a single \"superheroes\" table. 3) When combining superhero and hero_attribute tables: link rows where T1.id = T2.hero_id using an inner match. 4) When filtering for a specific superhero: use T1.superhero_name = 'Abomination' to reference the superhero name column exactly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE attribute = 'Abomination';",
            "SELECT T2.attribute_value\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Abomination'"
        ],
        "rule_sql": [
            "SELECT T2.attribute_value \nFROM superhero AS T1 \nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id \nWHERE T1.superhero_name = 'Abomination'"
        ],
        "amend_res": 1
    },
    "487": {
        "db_id": "card_games",
        "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE set_name = 'Coldsnap')` for the percentage calculation. Do join `sets AS T2` with `INNER JOIN` on `T2.code = T1.setCode` instead of querying only the `cards` table. Do filter on `T2.name = 'Coldsnap'` instead of `set_name = 'Coldsnap' AND power > 9000`. Do remove the unnecessary subquery and power filter instead of keeping them. The amended query now correctly calculates the percentage of cards with both cardKingdomFoilId and cardKingdomId present for the Coldsnap set, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating percentage of cards with both cardKingdomFoilId and cardKingdomId: use CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) instead of simple count ratios. 2) When querying for cards from a specific set: join sets AS T2 with INNER JOIN on T2.code = T1.setCode instead of filtering directly on set_name. 3) When filtering for the Coldsnap set: use T2.name = 'Coldsnap' instead of set_name = 'Coldsnap'. 4) When the question asks about incredibly powerful cards: this actually means cards where both cardKingdomFoilId and cardKingdomId are present (not power > 9000)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE set_name = 'Coldsnap')) AS percentage\nFROM cards \nWHERE set_name = 'Coldsnap' AND power > 9000;",
            "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM cards AS T1\nINNER JOIN sets AS T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Coldsnap'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM cards AS T1\nINNER JOIN sets AS T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Coldsnap';"
        ],
        "amend_res": 1
    },
    "672": {
        "db_id": "codebase_community",
        "question": "Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4",
        "amends": [
            "Do use `COUNT(T1.Id)` instead of `COUNT(*)` to count specific non-null values. Do reference the `users` table as `T1` instead of `u` and `posts` as `T2` instead of `p`. Do use `INNER JOIN` with `T1.Id = T2.OwnerUserId` instead of a correlated subquery with `p.user_id = u.user_id`. Do filter directly on `T2.FavoriteCount >= 4` in the WHERE clause instead of using a subquery with `SUM(favorite_count) >= 4`. Do reference the location column as `T1.Location` instead of `u.location`. The amended query now correctly joins the tables and filters on individual post favorite counts instead of incorrectly summing them across all posts per user."
        ],
        "rules": [
            "1) When counting users: use COUNT(T1.Id) instead of COUNT(*) to count specific non-null values. 2) When referencing tables: use T1 for users table and T2 for posts table. 3) When combining users and posts tables: link rows where T1.Id = T2.OwnerUserId using an inner join. 4) When filtering by location: use T1.Location = 'United Kingdom' exactly as specified. 5) When filtering by favorite count: use T2.FavoriteCount >= 4 to filter individual posts with 4 or more favorites."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM users u \nWHERE u.location = 'United Kingdom' \nAND (SELECT SUM(favorite_count) FROM posts p WHERE p.user_id = u.user_id) >= 4",
            "SELECT COUNT(T1.Id) \nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.Location = 'United Kingdom' \nAND T2.FavoriteCount >= 4"
        ],
        "amend_res": 1
    },
    "720": {
        "db_id": "superhero",
        "question": "Please list the full names of all the superheroes with over 15 super powers.",
        "ground_truth": "SELECT DISTINCT T1.full_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.full_name HAVING COUNT(T2.power_id) > 15",
        "amends": [
            "Do use `DISTINCT T1.full_name` instead of `name` without distinct. Do join `superhero AS T1` with `hero_power AS T2` on `T1.id = T2.hero_id` instead of querying a single table. Do add `GROUP BY T1.full_name` instead of omitting grouping. Do move the count filter to `HAVING COUNT(T2.power_id) > 15` instead of using `WHERE super_powers > 15` on a non-aggregated column. The amended query now correctly counts powers per hero and filters based on the aggregate count rather than a direct column comparison, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"superheroes with over 15 super powers\": make sure the output order: T1.full_name. 2) When the question mentions \"superheroes\": \"superheroes\" actually means \"superhero AS T1\" in schema. 3) When the question mentions \"super powers\": \"super powers\" actually means \"hero_power AS T2\" with power_id in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.id = T2.hero_id exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"count of super powers per hero\": compute the number of rows using T2.power_id per T1.full_name group. 6) When filtering for heroes with over 15 super powers: apply the condition COUNT(T2.power_id) > 15 after grouping instead of before aggregation. 7) When producing distinct hero names: use DISTINCT T1.full_name to avoid duplicate entries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE super_powers > 15;",
            "SELECT DISTINCT T1.full_name\nFROM superhero AS T1\nJOIN hero_power AS T2 ON T1.id = T2.hero_id\nGROUP BY T1.full_name\nHAVING COUNT(T2.power_id) > 15"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.full_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nGROUP BY T1.full_name\nHAVING COUNT(T2.power_id) > 15\nORDER BY T1.full_name"
        ],
        "amend_res": 1
    },
    "1059": {
        "db_id": "european_football_2",
        "question": "Please list player names which are higher than 180.",
        "ground_truth": "SELECT player_name FROM Player WHERE height > 180",
        "amends": [
            "Do reference the `player_name` column instead of `name` and use the correct table name `Player` instead of `players` while maintaining the same `height > 180` filter condition. The amended query now correctly accesses the intended column and table structure to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for player names: use the exact column token \"player_name\" from table \"Player\" instead of \"name\". 2) When filtering by height greater than 180: apply the condition \"height > 180\" to the \"Player\" table. 3) When selecting from the player table: use the exact table name \"Player\" instead of \"players\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE height > 180;",
            "SELECT player_name FROM Player WHERE height > 180;"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player WHERE height > 180;"
        ],
        "amend_res": 1
    },
    "656": {
        "db_id": "codebase_community",
        "question": "Describe the display name of the parent ID for child post with the highest score.",
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts WHERE ParentId IS NOT NULL ORDER BY Score DESC LIMIT 1 )",
        "amends": [
            "Do select `DisplayName` from the `users` table instead of selecting `parent_id` and `display_name` from the `posts` table. Do use a subquery that selects `OwnerUserId` from `posts` with `ParentId IS NOT NULL` instead of selecting `MAX(score)` from all posts. Do add `ORDER BY Score DESC LIMIT 1` to get the highest-scoring post instead of using equality comparison with maximum score. Do filter by `Id =` the subquery result instead of filtering by `score =` and `parent_id IS NOT NULL` in the main query. Do remove the `parent_id IS NOT NULL` condition from the main WHERE clause since it's now handled in the subquery. The amended query now correctly retrieves the display name of the user who owns the highest-scoring post that has a parent, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the display name of a user: select \"DisplayName\" from the \"users\" table. 2) When finding the highest-scoring child post: use ORDER BY Score DESC LIMIT 1 instead of equality comparison with maximum score. 3) When identifying the owner of a post: use the \"OwnerUserId\" column from the \"posts\" table to link to the \"users\" table. 4) When filtering for child posts: use ParentId IS NOT NULL condition to identify posts that are replies. 5) When joining user information for a post owner: filter the \"users\" table where \"Id\" equals the \"OwnerUserId\" from the subquery result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT parent_id, display_name FROM posts WHERE score = (SELECT MAX(score) FROM posts) AND parent_id IS NOT NULL",
            "SELECT u.DisplayName \nFROM users u\nWHERE u.Id = (\n    SELECT p.OwnerUserId \n    FROM posts p \n    WHERE p.ParentId IS NOT NULL \n    ORDER BY p.Score DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT u.DisplayName\nFROM users u\nWHERE u.Id = (\n    SELECT p.OwnerUserId\n    FROM posts p\n    WHERE p.ParentId IS NOT NULL\n    ORDER BY p.Score DESC\n    LIMIT 1\n)"
        ],
        "amend_res": 1
    },
    "1139": {
        "db_id": "european_football_2",
        "question": "What was the final score for the match on September 24, 2008, in the Belgian Jupiler League between the home team and the away team?",
        "ground_truth": "SELECT t2.home_team_goal, t2.away_team_goal FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND t2.`date` LIKE '2008-09-24%'",
        "amends": [
            "Do reference columns `t2.home_team_goal` and `t2.away_team_goal` instead of `home_team_score` and `away_team_score`. Do join `League AS t1` with `Match AS t2` on `t1.id = t2.league_id` instead of querying a single table. Do filter on `t1.name = 'Belgium Jupiler League'` instead of `league = 'Belgian Jupiler League'` to correctly reference the league name. Do use `t2.date LIKE '2008-09-24%'` instead of `match_date = '2008-09-24'` to handle potential timestamp values. The amended query now correctly joins the league and match tables with proper column references and filtering conditions."
        ],
        "rules": [
            "1) When answering about match scores: use columns \"t2\".\"home_team_goal\" and \"t2\".\"away_team_goal\" for the final score instead of home_team_score and away_team_score. 2) When combining league and match information: join \"League\" as \"t1\" with \"Match\" as \"t2\" where \"t1\".\"id\" equals \"t2\".\"league_id\" and keep only matching pairs. 3) When filtering for Belgian Jupiler League: use condition \"t1\".\"name\" = 'Belgium Jupiler League' instead of league = 'Belgian Jupiler League'. 4) When filtering for September 24, 2008: use \"t2\".\"date\" LIKE '2008-09-24%' to handle potential timestamp values instead of exact date equality."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT home_team_score, away_team_score FROM matches WHERE match_date = '2008-09-24' AND league = 'Belgian Jupiler League';",
            "SELECT t2.home_team_goal, t2.away_team_goal \nFROM Match AS t2 \nJOIN League AS t1 ON t1.id = t2.league_id \nWHERE t1.name = 'Belgium Jupiler League' \nAND t2.date LIKE '2008-09-24%'"
        ],
        "rule_sql": [
            "SELECT t2.home_team_goal, t2.away_team_goal \nFROM Match AS t2\nJOIN League AS t1 ON t1.id = t2.league_id\nWHERE t1.name = 'Belgium Jupiler League'\nAND t2.date LIKE '2008-09-24%'"
        ],
        "amend_res": 1
    },
    "799": {
        "db_id": "superhero",
        "question": "How many superheroes didn't have any publisher?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.id = 1",
        "amends": [
            "Do select `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null identifiers. Do join `superhero AS T1 INNER JOIN publisher AS T2` instead of querying only `superheroes` to properly relate the tables. Do use join condition `T1.publisher_id = T2.id` instead of checking `publisher IS NULL` to correctly establish the relationship. Do filter with `T2.id = 1` instead of null checking to target a specific publisher. The amended query now correctly counts superheroes belonging to publisher ID 1 by properly joining the tables and using the appropriate filter condition."
        ],
        "rules": [
            "1) When counting superheroes: use COUNT(T1.id) instead of COUNT(*) to count specific non-null identifiers. 2) When relating superheroes to publishers: join superhero AS T1 INNER JOIN publisher AS T2 using the condition T1.publisher_id = T2.id instead of querying only the superheroes table. 3) When filtering for a specific publisher: use T2.id = 1 instead of checking for null values to target the specific publisher. 4) When answering about superheroes without a publisher: the question actually means superheroes that do not have a publisher relationship established through the join condition."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE publisher IS NULL;",
            "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.id = 1"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero AS T1 \nWHERE T1.publisher_id NOT IN (SELECT id FROM publisher)",
            "SELECT COUNT(T1.id) \nFROM superhero AS T1 \nLEFT JOIN publisher AS T2 ON T1.publisher_id = T2.id \nWHERE T2.id IS NULL"
        ],
        "amend_res": 1
    },
    "1168": {
        "db_id": "thrombosis_prediction",
        "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
        "ground_truth": "SELECT T1.Date, STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday),T2.Birthday FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL ORDER BY T2.Birthday ASC LIMIT 1",
        "amends": [
            "Do select `T1.Date`, `STRFTIME('%Y', T2.\"First Date\") - STRFTIME('%Y', T2.Birthday)`, and `T2.Birthday` instead of `MAX(age)` and `MIN(arrival_date)`. Do use `FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID` instead of `FROM patients`. Do add filter `T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL` instead of only `diagnosis = 'SJS'`. Do order by `T2.Birthday ASC` instead of `arrival_date DESC`. The amended query now correctly calculates age from date differences and joins laboratory with patient data while ensuring valid birthday values."
        ],
        "rules": [
            "1) When answering about the oldest SJS patient's medical laboratory work: make sure the output order: T1.Date, calculated age from date differences, and T2.Birthday. 2) When the question mentions \"oldest\": rank patients by T2.Birthday in ascending order and keep the first 1 row. 3) When combining Laboratory and Patient tables: link rows where T1.ID = T2.ID exactly and keep only matching pairs (inner match). 4) When filtering for SJS patients: use T2.Diagnosis = 'SJS' exactly as specified. 5) When calculating patient age: compute STRFTIME('%Y', T2.\"First Date\") - STRFTIME('%Y', T2.Birthday) to get age at initial arrival. 6) When handling date values: ensure T2.Birthday IS NOT NULL to avoid invalid age calculations."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(age) as patient_age, MIN(arrival_date) as initial_arrival_date \nFROM patients \nWHERE diagnosis = 'SJS' \nORDER BY arrival_date DESC \nLIMIT 1;",
            "SELECT \n    T1.Date, \n    STRFTIME('%Y', T2.\"First Date\") - STRFTIME('%Y', T2.Birthday) AS age_at_arrival,\n    T2.Birthday\nFROM \n    Laboratory AS T1 \nINNER JOIN \n    Patient AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.Diagnosis = 'SJS' \n    AND T2.Birthday IS NOT NULL\nORDER BY \n    T2.Birthday ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT \n    T1.Date, \n    (STRFTIME('%Y', T2.\"First Date\") - STRFTIME('%Y', T2.Birthday)) AS Age,\n    T2.Birthday\nFROM \n    Laboratory T1\nINNER JOIN \n    Patient T2 ON T1.ID = T2.ID\nWHERE \n    T2.Diagnosis = 'SJS' \n    AND T2.Birthday IS NOT NULL\nORDER BY \n    T2.Birthday ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "999": {
        "db_id": "formula_1",
        "question": "In terms of the fastest lap time, what is the name of the race which recorded the fastest lap speed by a racer?",
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "amends": [
            "Do select `T1.name` from the `races` table instead of `race_name` from `races` alone. Do add an `INNER JOIN` with `results AS T2` on `T1.raceId = T2.raceId` instead of querying only the `races` table. Do add a `WHERE` filter for `T2.fastestLapTime IS NOT NULL` instead of omitting null value handling. Do order by `T2.fastestLapTime ASC` for ascending order instead of `fastest_lap_time DESC` for descending order. The amended query now correctly identifies races with valid lap times by joining with results data and sorting to find the fastest lap time."
        ],
        "rules": [
            "1) When answering about \"fastest lap time\": make sure the output order: T1.name 2) When the question mentions \"race name\": \"race name\" actually means \"T1.name in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.raceId = T2.raceId exactly as shown in the amends; keep only matching pairs (inner match). 4) When handling fastest lap time data: filter for T2.fastestLapTime IS NOT NULL instead of omitting null value handling. 5) When the question asks for \"fastest\" lap time: order by T2.fastestLapTime ASC for ascending order instead of descending order to find the minimum time."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name FROM races ORDER BY fastest_lap_time DESC LIMIT 1;",
            "SELECT T1.name \nFROM races AS T1\nINNER JOIN results AS T2 ON T1.raceId = T2.raceId\nWHERE T2.fastestLapTime IS NOT NULL\nORDER BY T2.fastestLapTime ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM races T1\nJOIN results T2 ON T1.raceId = T2.raceId\nWHERE T2.fastestLapTime IS NOT NULL\nORDER BY T2.fastestLapTime ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "986": {
        "db_id": "formula_1",
        "question": "In which race did the fastest 1st lap time was recorded? Please indicate the time in milliseconds.",
        "ground_truth": "SELECT T1.milliseconds FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.lap = 1 ORDER BY T1.time LIMIT 1",
        "amends": [
            "Do select `milliseconds` instead of `race_name` and `MIN(lap_time)`. Do use `lapTimes` and `races` tables with `INNER JOIN` on `T1.raceId = T2.raceId` instead of a single table. Do add filter `WHERE T1.lap = 1` instead of omitting it. Do order by `T1.time` instead of `lap_time`. The amended query now correctly retrieves the fastest first lap time by joining race and lap time data with proper filtering.",
            "Do remove `T2.name AS race_name` from the SELECT list instead of including it. Do remove the `ASC` keyword from the ORDER BY clause instead of specifying it explicitly. The amended query now matches RIGHT_SQL's behavior by selecting only the milliseconds column and ordering by time without direction specification."
        ],
        "rules": [
            "1) When answering about fastest 1st lap time: use milliseconds column instead of race_name and MIN(lap_time) for output. 2) When combining lapTimes and races tables: link rows where T1.raceId = T2.raceId using inner join and keep only matching pairs. 3) When filtering for first lap: add condition WHERE T1.lap = 1 to select only lap 1 data. 4) When ordering by lap time: order by T1.time column in ascending direction to find fastest time. 5) When retrieving the fastest time: take only the first row after ordering to get the single fastest result.",
            "1) When answering about \"fastest 1st lap time\": make sure the output order includes only the milliseconds column. 2) When the question asks for the fastest time: order by the time column in ascending order (lowest value first) without specifying direction explicitly. 3) When filtering for first lap records: include only rows where lap equals 1 using the exact literal value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name, MIN(lap_time) as fastest_lap FROM races ORDER BY lap_time ASC LIMIT 1;",
            "SELECT T1.milliseconds, T2.name AS race_name\nFROM lapTimes T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T1.lap = 1\nORDER BY T1.time ASC\nLIMIT 1;",
            "SELECT T1.milliseconds \nFROM lapTimes T1 \nINNER JOIN races T2 ON T1.raceId = T2.raceId \nWHERE T1.lap = 1 \nORDER BY T1.time \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT lt.milliseconds \nFROM lapTimes lt\nINNER JOIN races r ON lt.raceId = r.raceId\nWHERE lt.lap = 1\nORDER BY lt.time ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "936": {
        "db_id": "formula_1",
        "question": "Which was the fastest lap for Lewis Hamilton in the 2008 Australian Grand Prix?",
        "evidence": "",
        "ground_truth": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008 AND T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "amends": [
            "Do use `T1.fastestLap` instead of `MIN(lap_time)` for the fastest lap value. Do join `results AS T1` instead of querying `lap_times` directly. Do add `races AS T2` with join condition `T1.raceId = T2.raceId` instead of filtering by race name alone. Do add `drivers AS T3` with join condition `T1.driverId = T3.driverId` instead of filtering by driver name alone. Do filter with `T2.name = 'Australian Grand Prix' AND T2.year = 2008` instead of `race = '2008 Australian Grand Prix'` to properly separate year and race name. Do filter with `T3.forename = 'Lewis' AND T3.surname = 'Hamilton'` instead of `driver = 'Lewis Hamilton'` to match the normalized driver name structure. The amended query now correctly retrieves the fastest lap time using proper table relationships and normalized data structure.",
            "Do select `fastestLap` instead of `fastestLapTime` in the SELECT list. Do use explicit `INNER JOIN` syntax instead of implicit JOIN for both table joins. The amended query now correctly retrieves the fastest lap data instead of fastest lap time, using proper explicit join syntax while maintaining the same filtering logic for the 2008 Australian Grand Prix and Lewis Hamilton."
        ],
        "rules": [
            "1) When answering about the fastest lap for a driver in a specific race: use T1.fastestLapTime instead of MIN(lap_time) for the fastest lap value. 2) When querying lap time data: join results AS T1 instead of querying lap_times directly. 3) When filtering by race: join races AS T2 with condition T1.raceId = T2.raceId and filter with T2.name = 'Australian Grand Prix' AND T2.year = 2008 instead of race = '2008 Australian Grand Prix'. 4) When filtering by driver: join drivers AS T3 with condition T1.driverId = T3.driverId and filter with T3.forename = 'Lewis' AND T3.surname = 'Hamilton' instead of driver = 'Lewis Hamilton'.",
            "1) When the question asks for \"fastest lap\" data: use the exact column token \"fastestLap\" from table results (T1) instead of \"fastestLapTime\". 2) When joining tables results, races, and drivers: use explicit INNER JOIN syntax to link T1.raceId = T2.raceId and T1.driverId = T3.driverId. 3) When filtering for Lewis Hamilton in the 2008 Australian Grand Prix: match T2.name exactly to 'Australian Grand Prix', T2.year exactly to 2008, T3.forename exactly to 'Lewis', and T3.surname exactly to 'Hamilton'."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(lap_time) FROM lap_times WHERE driver = 'Lewis Hamilton' AND race = '2008 Australian Grand Prix';",
            "SELECT T1.fastestLapTime\nFROM results AS T1\nJOIN races AS T2 ON T1.raceId = T2.raceId\nJOIN drivers AS T3 ON T1.driverId = T3.driverId\nWHERE T2.name = 'Australian Grand Prix' \nAND T2.year = 2008\nAND T3.forename = 'Lewis' \nAND T3.surname = 'Hamilton';",
            "SELECT T1.fastestLap \nFROM results AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nINNER JOIN drivers AS T3 ON T1.driverId = T3.driverId\nWHERE T2.name = 'Australian Grand Prix' \nAND T2.year = 2008\nAND T3.forename = 'Lewis' \nAND T3.surname = 'Hamilton'"
        ],
        "rule_sql": [
            "SELECT T1.fastestLapTime \nFROM results AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nINNER JOIN drivers AS T3 ON T1.driverId = T3.driverId\nWHERE T2.name = 'Australian Grand Prix' \nAND T2.year = 2008\nAND T3.forename = 'Lewis' \nAND T3.surname = 'Hamilton';"
        ],
        "amend_res": 1
    },
    "1286": {
        "db_id": "thrombosis_prediction",
        "question": "For the patient with an abnormal alkaliphophatase level, how many of them are admitted to the hospital?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP >= 300 AND T1.Admission = '+'",
        "amends": [
            "Do join `Patient` and `Laboratory` tables with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.ALP >= 300` instead of `alkaliphophatase_level = 'abnormal'` and on `T1.Admission = '+'` instead of `admission_status = 'admitted'`. Do count `T1.ID` specifically instead of using `COUNT(*)`. The amended query now correctly joins the necessary tables and uses proper column references and comparison logic to match the intended behavior.",
            "Do remove `DISTINCT` from the count aggregation instead of keeping it, as the join condition already ensures unique patient IDs are counted. Do maintain the same `INNER JOIN` on `T1.ID = T2.ID` and preserve both `T2.ALP >= 300` and `T1.Admission = '+'` filters in the WHERE clause. The amended query now correctly counts all matching patient records without unnecessary deduplication, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about patients with abnormal alkaline phosphatase levels: join the Patient table (T1) and Laboratory table (T2) using an inner match where T1.ID equals T2.ID. 2) When filtering for abnormal alkaline phosphatase levels: use the condition T2.ALP >= 300 instead of text comparisons. 3) When filtering for hospital admission status: use the condition T1.Admission = '+' instead of text values like 'admitted'. 4) When counting patients: count the specific column T1.ID instead of using a generic count of all rows.",
            "1) When counting patients with abnormal alkaline phosphatase levels who are admitted: count all patient IDs from T1 without deduplication since the join condition already ensures uniqueness. 2) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID using an inner match to ensure only patients with lab results are included. 3) When filtering for abnormal alkaline phosphatase levels: include only rows where T2.ALP >= 300. 4) When filtering for admitted patients: include only rows where T1.Admission = '+' exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE alkaliphophatase_level = 'abnormal' AND admission_status = 'admitted';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP >= 300 AND T1.Admission = '+'",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP >= 300 AND T1.Admission = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP >= 300 \nAND T1.Admission = '+';"
        ],
        "amend_res": 1
    },
    "436": {
        "db_id": "card_games",
        "question": "How many cards have frame effect as extendedart? List out the id of those cards.",
        "ground_truth": "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id",
        "amends": [
            "Do select `id` instead of `COUNT(*)` to return individual identifiers rather than an aggregate count. Do add `GROUP BY id` instead of omitting it to ensure proper grouping of results. Do reference column `frameEffects` instead of `frame_effect` to match the correct column name in the schema. The amended query now correctly returns distinct card IDs with the extended art frame effect instead of providing a count."
        ],
        "rules": [
            "1) When the question asks for \"id of those cards\": select the exact column \"id\" from table \"cards\" instead of using COUNT(*). 2) When the question mentions \"frame effect as extendedart\": the exact literal value to match is 'extendedart' and the correct column name is \"frameEffects\" (not \"frame_effect\"). 3) When returning individual identifiers for cards with specific frame effects: ensure proper grouping by including GROUP BY \"id\" to return distinct card IDs."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE frame_effect = 'extendedart';",
            "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id;"
        ],
        "amend_res": 1
    },
    "1430": {
        "db_id": "student_club",
        "question": "What is the last name and position of the student that bought pizza on 09/10/2019?",
        "ground_truth": "SELECT T1.last_name, T1.position FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.expense_date = '2019-09-10' AND T2.expense_description = 'Pizza'",
        "amends": [
            "Do select `T1.last_name` and `T1.position` from the `member` table instead of `last_name` and `position` from `students`. Do join `expense AS T2` with `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of querying a single table. Do filter on `T2.expense_date = '2019-09-10'` instead of `purchase_date = '09/10/2019'` with proper date format. Do filter on `T2.expense_description = 'Pizza'` instead of `item = 'pizza'` with proper case. Do remove `ORDER BY purchase_date DESC` and `LIMIT 1` instead of keeping them as they are unnecessary for the corrected logic. The amended query now correctly retrieves member details for pizza expenses on the specified date."
        ],
        "rules": [
            "1) When answering about student purchases: use the member table (T1) for student details like last_name and position instead of a students table. 2) When the question mentions \"bought pizza\": filter on T2.expense_description = 'Pizza' with exact case matching. 3) When the question mentions \"on 09/10/2019\": filter on T2.expense_date = '2019-09-10' with proper date format conversion. 4) When combining member and expense tables: link rows where T1.member_id = T2.link_to_member using an inner join to find matching pairs. 5) When retrieving results for this specific query: do not apply ordering or limit clauses as they are unnecessary for finding the exact match."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name, position FROM students WHERE purchase_date = '09/10/2019' AND item = 'pizza' ORDER BY purchase_date DESC LIMIT 1;",
            "SELECT T1.last_name, T1.position \nFROM member AS T1\nINNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member\nWHERE T2.expense_date = '2019-09-10' \nAND T2.expense_description = 'Pizza'"
        ],
        "rule_sql": [
            "SELECT m.last_name, m.position FROM member m INNER JOIN expense e ON m.member_id = e.link_to_member WHERE e.expense_description = 'Pizza' AND e.expense_date = '2019-09-10'"
        ],
        "amend_res": 1
    },
    "416": {
        "db_id": "card_games",
        "question": "What percentage of cards without power are in French?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power = '*'",
        "amends": [
            "Do use `INNER JOIN` with `foreign_data AS T2` on `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do change the WHERE condition to `T1.power IS NULL OR T1.power = '*'` instead of `power IS NULL AND language = 'French'`. Do calculate the percentage using `CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)` instead of `(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE language = 'French'))`. Do reference `T1.id` for counting instead of using `COUNT(*)`. The amended query now correctly handles the join between cards and foreign_data tables and properly calculates the percentage of French cards with null or asterisk power values."
        ],
        "rules": [
            "1) When combining cards and foreign_data tables: link rows where T1.uuid = T2.uuid using an inner join to keep only matching pairs. 2) When identifying cards without power: use the condition T1.power IS NULL OR T1.power = '*' instead of just checking for null values. 3) When calculating percentage of French cards: compute (number of French cards without power) divided by (total number of cards) using CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id). 4) When counting cards: use T1.id as the counting key instead of counting all rows with COUNT(*). 5) When handling French language cards: use the exact literal 'French' for T2.language comparisons."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE language = 'French')) AS percentage\nFROM cards \nWHERE power IS NULL AND language = 'French';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM \n    cards AS T1\nINNER JOIN \n    foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE \n    T1.power IS NULL OR T1.power = '*';"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN fd.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(c.id) AS percentage\nFROM \n    cards c\nINNER JOIN \n    foreign_data fd ON c.uuid = fd.uuid\nWHERE \n    c.power IS NULL OR c.power = '*';"
        ],
        "amend_res": 1
    },
    "1220": {
        "db_id": "thrombosis_prediction",
        "question": "Provide all ID, sex and birthday of patients whose urea nitrogen (UN) just within the borderline of passing?",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN = 29",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do reference columns as `T1.ID`, `T1.SEX`, and `T1.Birthday` instead of `patient_id`, `sex`, and `birthday` with different casing. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the `patients` table to incorporate laboratory data. Do filter on `T2.UN = 29` instead of `urea_nitrogen = 'borderline'` to use a numeric comparison rather than a string literal. Do use table alias `T1` for the `Patient` table instead of directly referencing `patients`. The amended query now correctly joins patient and laboratory data to find patients with specific urea nitrogen values."
        ],
        "rules": [
            "1) When answering about \"patients whose urea nitrogen (UN) just within the borderline of passing\": make sure the output order: T1.ID, T1.SEX, T1.Birthday. 2) When the question mentions \"urea nitrogen (UN)\": \"urea nitrogen (UN)\" actually means \"T2.UN in schema\" and requires a numeric value of 29. 3) When combining Patient table as T1 and Laboratory table as T2: link rows where T1.ID = T2.ID exactly and keep only matching pairs (inner match). 4) When selecting patient information: use DISTINCT to eliminate duplicate rows. 5) When referring to patient identifiers: use exact column names T1.ID, T1.SEX, and T1.Birthday with the specified casing."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, sex, birthday FROM patients WHERE urea_nitrogen = 'borderline';",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.UN = 29"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.UN = 29\nORDER BY T1.ID, T1.SEX, T1.Birthday"
        ],
        "amend_res": 1
    },
    "910": {
        "db_id": "formula_1",
        "question": "What's the location coordinates of Silverstone Circuit?",
        "ground_truth": "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit'",
        "amends": [
            "Do select `lat` and `lng` instead of `latitude` and `longitude` to use the correct column names from the circuits table. The amended query now matches the right SQL's behavior by properly referencing the actual column names in the database schema."
        ],
        "rules": [
            "1) When the question asks for location coordinates: use the exact column names \"lat\" and \"lng\" from the circuits table instead of \"latitude\" and \"longitude\". 2) When filtering for a specific circuit name: use the exact literal value 'Silverstone Circuit' with proper case and spacing as shown in the question."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT latitude, longitude FROM circuits WHERE name = 'Silverstone Circuit';",
            "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit';"
        ],
        "rule_sql": [
            "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit';"
        ],
        "amend_res": 1
    },
    "510": {
        "db_id": "card_games",
        "question": "Among the cards that doesn't have multiple faces on the same card, who is the illustrator of the card art that has the highest cost of converted mana?",
        "ground_truth": "SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1",
        "amends": [
            "Do select `artist` instead of `illustrator` in the SELECT list. Do filter on `side IS NULL` instead of `faces = 1` in the WHERE clause. Do reference `convertedManaCost` instead of `converted_mana_cost` in the ORDER BY clause. The amended query now correctly retrieves the artist from cards where side is null, ordered by converted mana cost in descending order with a limit of 1, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"illustrator\": use the exact column token \"artist\" from the cards table instead. 2) When filtering for cards that don't have multiple faces on the same card: use the condition \"side IS NULL\" instead of \"faces = 1\". 3) When ordering by converted mana cost: use the exact column token \"convertedManaCost\" with descending order. 4) When finding the highest cost: take only the top 1 result after ordering by \"convertedManaCost\" in descending order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT illustrator FROM cards WHERE faces = 1 ORDER BY converted_mana_cost DESC LIMIT 1;",
            "SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "2": {
        "db_id": "california_schools",
        "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
        "ground_truth": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
        "amends": [
            "Do select `T2.Zip` instead of `zip_code`. Do use `FROM frpm AS T1 INNER JOIN schools AS T2` instead of `FROM schools` alone. Do add join condition `ON T1.CDSCode = T2.CDSCode` instead of omitting it. Do filter on `T1.District Name = 'Fresno County Office of Education'` instead of `county = 'Fresno County Office of Education'`. Do filter on `T1.Charter School (Y/N) = 1` instead of `type = 'charter'`. The amended query now correctly joins the frpm table to access district information and charter status, matching the RIGHT_SQL's behavior.",
            "Do use backticks around `District Name` instead of unquoted spaces in the WHERE clause. Do use backticks around `Charter School (Y/N)` instead of unquoted parentheses and slashes in the WHERE clause. The amended query now correctly handles column names with special characters and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about charter schools in Fresno County Office of Education: use \"T2.Zip\" instead of \"zip_code\" for the zip code output. 2) When combining frpm and schools tables: link rows where \"T1.CDSCode = T2.CDSCode\" and keep only matching pairs (inner match). 3) When filtering for Fresno County Office of Education: use \"T1.District Name = 'Fresno County Office of Education'\" instead of county filtering. 4) When identifying charter schools: use \"T1.Charter School (Y/N) = 1\" instead of type = 'charter'.",
            "1) When the question asks for charter schools in a specific county office of education: filter rows where \"District Name\" exactly matches the specified county office name like 'Fresno County Office of Education'. 2) When identifying charter schools: filter rows where \"Charter School (Y/N)\" equals 1 to select only charter schools. 3) When column names contain spaces or special characters: use backticks around identifiers like `District Name` and `Charter School (Y/N)` to handle special characters properly. 4) When combining frpm and schools tables: link rows where T1.CDSCode = T2.CDSCode using an inner match to find corresponding records. 5) When the question asks for zip codes: select the \"Zip\" column from the schools table (T2.Zip) as the output."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM schools WHERE county = 'Fresno County Office of Education' AND type = 'charter';",
            "SELECT T2.Zip\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.District Name = 'Fresno County Office of Education'\nAND T1.Charter School (Y/N) = 1;",
            "SELECT T2.Zip\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`District Name` = 'Fresno County Office of Education'\nAND T1.`Charter School (Y/N)` = 1"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Zip\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`District Name` = 'Fresno County Office of Education'\nAND T1.`Charter School (Y/N)` = 1"
        ],
        "amend_res": 1
    },
    "501": {
        "db_id": "card_games",
        "question": "Which card name in the set 'Journey into Nyx Hero's Path' has the highest converted mana cost.",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Journey into Nyx Hero''s Path' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "amends": [
            "Do join `sets AS T2` instead of querying only the `cards` table. Do use `INNER JOIN` on `T2.code = T1.setCode` instead of filtering directly on `set_name`. Do select `T1.name` instead of `card_name`. Do reference `T1.convertedManaCost` instead of `converted_mana_cost` in the ORDER BY clause. Do filter on `T2.name` instead of `set_name` to properly match the set name through the join relationship. The amended query now correctly joins the sets table to filter by set name and returns the appropriate card name with proper column references."
        ],
        "rules": [
            "1) When answering about card names in a specific set: join the sets table (T2) with the cards table (T1) using an inner match where T2.code equals T1.setCode. 2) When filtering by set name 'Journey into Nyx Hero's Path': apply the filter condition to T2.name with the exact literal 'Journey into Nyx Hero's Path'. 3) When selecting the card name: use T1.name instead of card_name. 4) When ordering by converted mana cost: use T1.convertedManaCost instead of converted_mana_cost and sort in descending order. 5) When finding the highest value: take only the top 1 row after descending ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_name FROM cards WHERE set_name = 'Journey into Nyx Hero''s Path' ORDER BY converted_mana_cost DESC LIMIT 1;",
            "SELECT T1.name\nFROM cards AS T1\nINNER JOIN sets AS T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Journey into Nyx Hero''s Path'\nORDER BY T1.convertedManaCost DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.name FROM cards T1 INNER JOIN sets T2 ON T2.code = T1.setCode WHERE T2.name = 'Journey into Nyx Hero''s Path' ORDER BY T1.convertedManaCost DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1493": {
        "db_id": "debit_card_specializing",
        "question": "In February 2012, what percentage of customers consumed more than 528.3?",
        "ground_truth": "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'",
        "amends": [
            "Do use `SUM(IIF(Consumption > 528.3, 1, 0))` instead of `COUNT(CASE WHEN consumption > 528.3 THEN 1 END)` for conditional counting. Do cast the result as `FLOAT` with `CAST(... AS FLOAT)` instead of using decimal multiplication. Do reference table `yearmonth` instead of `customers` as the data source. Do filter with `Date = '201202'` instead of `strftime('%Y-%m', date) = '2012-02'` for direct date comparison. Do use `COUNT(CustomerID)` instead of `COUNT(*)` for counting specific non-null values. The amended query now correctly calculates the percentage of customers with consumption exceeding the threshold for the specified date period."
        ],
        "rules": [
            "1) When answering about percentage of customers consuming more than a threshold: use SUM(IIF(Consumption > 528.3, 1, 0)) for conditional counting instead of COUNT(CASE WHEN consumption > 528.3 THEN 1 END). 2) When casting numerical results: use CAST(... AS FLOAT) instead of decimal multiplication for percentage calculation. 3) When referencing data source: use table yearmonth instead of customers as the primary data source. 4) When filtering by date: use Date = '201202' for direct date comparison instead of strftime('%Y-%m', date) = '2012-02'. 5) When counting customers: use COUNT(CustomerID) instead of COUNT(*) to count specific non-null values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN consumption > 528.3 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM customers\nWHERE strftime('%Y-%m', date) = '2012-02';",
            "SELECT \n    (CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) / COUNT(CustomerID)) * 100 AS percentage\nFROM \n    yearmonth\nWHERE \n    Date = '201202';"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) / COUNT(CustomerID) * 100 AS Percentage\nFROM \n    yearmonth\nWHERE \n    Date = '201202';"
        ],
        "amend_res": 1
    },
    "1109": {
        "db_id": "european_football_2",
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "ground_truth": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "amends": [
            "Do select `t2.buildUpPlayDribblingClass` instead of `*` from all columns. Do use `Team AS t1 INNER JOIN Team_Attributes AS t2` instead of single table `build_up_play_dribbling`. Do join on `t1.team_api_id = t2.team_api_id` instead of no join condition. Do filter on `t1.team_short_name = 'LEI'` instead of `team = 'LEI'`. Do use `SUBSTR(t2.date, 1, 10) = '2015-09-10'` with proper date format instead of `date = '2015/9/10'`. The amended query now correctly retrieves specific attributes from related tables with proper join conditions and date handling."
        ],
        "rules": [
            "1) When answering about build up play dribbling class: select only t2.buildUpPlayDribblingClass instead of all columns. 2) When combining Team and Team_Attributes tables: link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match). 3) When filtering for team \"LEI\": use t1.team_short_name = 'LEI' as the filter condition. 4) When filtering for date \"2015/9/10\": convert to proper date format using SUBSTR(t2.date, 1, 10) = '2015-09-10' with exact literal '2015-09-10'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM build_up_play_dribbling WHERE team = 'LEI' AND date = '2015/9/10';",
            "SELECT t2.buildUpPlayDribblingClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_short_name = 'LEI' \nAND SUBSTR(t2.date, 1, 10) = '2015-09-10'"
        ],
        "rule_sql": [
            "SELECT t2.buildUpPlayDribblingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_short_name = 'LEI' \nAND SUBSTR(t2.date, 1, 10) = '2015-09-10'"
        ],
        "amend_res": 1
    },
    "421": {
        "db_id": "card_games",
        "question": "Please list top three unknown power cards that have promotional types for arena league in alphabetical order.",
        "ground_truth": "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3",
        "amends": [
            "Do query the `cards` table instead of `power_cards`. Do use the condition `(power IS NULL OR power LIKE '%*%')` instead of `promotional_type = 'arena league' AND known = 0`. Do reference `promoTypes = 'arenaleague'` instead of `promotional_type = 'arena league'`. The amended query now correctly filters for arena league promotional cards with null or asterisk-containing power values, matching the intended behavior.",
            "Do remove `power` and `promoTypes` from the SELECT list instead of including them, keeping only `name`. Do maintain the same WHERE filter conditions but reorder them to `(power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague'` instead of `promoTypes = 'arenaleague' AND (power IS NULL OR power LIKE '%*%')`. Do remove the explicit `ASC` from ORDER BY instead of specifying it, as ascending is the default. The amended query now correctly returns only the name column while maintaining the same filtering logic and result ordering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"top three unknown power cards that have promotional types for arena league\": make sure the output order: \"name\" in alphabetical order. 2) When the question mentions \"unknown power cards\": \"unknown power\" actually means \"(power IS NULL OR power LIKE '%*%')\" in schema. 3) When the question mentions \"promotional types for arena league\": \"arena league\" actually means \"promoTypes = 'arenaleague'\" in schema. 4) When the question asks for \"top three\": rank rows by alphabetical order of \"name\" and keep the first 3 rows. 5) When querying the database: use the \"cards\" table instead of \"power_cards\" table.",
            "1) When answering about \"top three unknown power cards that have promotional types for arena league in alphabetical order\": make sure the output order: name only. 2) When filtering for unknown power: use condition (power IS NULL OR power LIKE '%*%') to identify cards with unknown power values. 3) When filtering for arena league promotional types: use condition promoTypes = 'arenaleague' exactly as specified. 4) When combining filtering conditions: apply both (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' in that order. 5) When ordering results alphabetically: sort by name in ascending order (default, no need to specify ASC). 6) When limiting to top three results: take the first 3 rows after sorting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM power_cards WHERE promotional_type = 'arena league' AND known = 0 ORDER BY name LIMIT 3;",
            "SELECT name, power, promoTypes \nFROM cards \nWHERE promoTypes = 'arenaleague' \nAND (power IS NULL OR power LIKE '%*%') \nORDER BY name ASC \nLIMIT 3;",
            "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3"
        ],
        "rule_sql": [
            "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3"
        ],
        "amend_res": 1
    },
    "88": {
        "db_id": "california_schools",
        "question": "What is the administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500?Provide the name of the school.",
        "evidence": "",
        "ground_truth": "SELECT T2.AdmEmail1, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [
            "Do select `T2.AdmEmail1` and `T2.School` instead of `school_name` and `administrator_email`. Do use `INNER JOIN` between `satscores AS T1` and `schools AS T2` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table. Do order by `T1.NumGE1500 DESC` instead of filtering with `WHERE sat_score >= 1500` and `WHERE test_takers_count = (SELECT MAX(test_takers_count) FROM schools)`. Do remove the `WHERE` clause entirely instead of keeping those filters. Do add `ORDER BY` with `DESC` ordering instead of omitting it. The amended query now correctly joins the two tables and selects the school with the highest number of SAT scores above 1500, matching the RIGHT_SQL's behavior.",
            "Do reverse the column order in the SELECT list to `AdmEmail1, School` instead of `School, AdmEmail1`. End with confirmation that the amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about the highest number of test takers with SAT scores \u22651500: rank schools by T1.NumGE1500 in descending order and keep the first row. 2) When combining SAT scores and schools data: link rows where T1.cds = T2.CDSCode exactly and keep only matching pairs (inner match). 3) When selecting output columns: return T2.AdmEmail1 and T2.School instead of school_name and administrator_email. 4) When ordering results: use T1.NumGE1500 DESC instead of filtering by sat_score >= 1500 or maximum test takers count.",
            "1) When answering about \"administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500\": make sure the output order: AdmEmail1, School\n2) When the question asks for the school with the highest number of test takers who received SAT scores of at least 1500: rank rows by T1.NumGE1500 in descending order and keep the first 1 row.\n3) When combining satscores (T1) and schools (T2) for shared entities: link rows where T1.cds = T2.CDSCode exactly as shown; keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, administrator_email \nFROM schools \nWHERE test_takers_count = (SELECT MAX(test_takers_count) FROM schools) \nAND sat_score >= 1500 \nLIMIT 1;",
            "SELECT T2.School, T2.AdmEmail1 \nFROM satscores AS T1 \nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode \nORDER BY T1.NumGE1500 DESC \nLIMIT 1;",
            "SELECT T2.AdmEmail1, T2.School\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.AdmEmail1, T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1451": {
        "db_id": "student_club",
        "question": "Among the members who incurred expenses in more than one event, who paid the most amount?",
        "ground_truth": "SELECT T2.member_id FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY T2.member_id HAVING COUNT(DISTINCT T4.event_id) > 1 ORDER BY SUM(T1.cost) DESC LIMIT 1",
        "amends": [
            "Do select `T2.member_id` instead of `member_name` and `SUM(amount)`. Do use `expense AS T1` instead of `expenses` and add joins to `member AS T2` on `T1.link_to_member = T2.member_id`, `budget AS T3` on `T1.link_to_budget = T3.budget_id`, and `event AS T4` on `T3.link_to_event = T4.event_id` instead of a single table. Do group by `T2.member_id` instead of `member_name`. Do keep `HAVING COUNT(DISTINCT event_id) > 1` but reference `T4.event_id` instead. Do order by `SUM(T1.cost)` descending instead of `total_paid` descending. Do keep `LIMIT 1` unchanged. The amended query now correctly joins through the proper table relationships to identify members who contributed to multiple events through the budget-event linkage.",
            "Do remove `SUM(T1.cost)` from the SELECT list instead of including it, as only `T2.member_id` is needed for the final result. Do change the implicit `JOIN` to explicit `INNER JOIN` for clarity instead of using the shorthand syntax. The amended query now correctly returns only member IDs who have expenses across multiple events, matching the RIGHT_SQL's behavior by focusing on the member identification rather than including unnecessary cost aggregation in the output."
        ],
        "rules": [
            "1) When answering about members who incurred expenses in more than one event: use expense as T1, member as T2, budget as T3, and event as T4 with the exact aliases shown in the amends. 2) When combining tables for shared entities: link T1 to T2 where T1.link_to_member = T2.member_id, link T1 to T3 where T1.link_to_budget = T3.budget_id, and link T3 to T4 where T3.link_to_event = T4.event_id, keeping only matching pairs (inner match). 3) When grouping by member: group by T2.member_id instead of member_name. 4) When counting distinct events per member: use COUNT(DISTINCT T4.event_id) > 1 to identify members with expenses in more than one event. 5) When summing expenses: use SUM(T1.cost) instead of SUM(amount) to calculate the total amount paid. 6) When ordering results to find who paid the most: order by SUM(T1.cost) descending. 7) When selecting the top payer: use LIMIT 1 to return only the member who paid the highest amount.",
            "1) When answering about members who incurred expenses in more than one event: only include T2.member_id in the final output columns, not SUM(T1.cost). 2) When combining tables for this question: use explicit INNER JOIN syntax instead of implicit JOIN syntax for clarity. 3) When filtering for members with expenses in multiple events: use HAVING COUNT(DISTINCT T4.event_id) > 1 to identify members with expenses in more than one distinct event."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT member_name, SUM(amount) as total_paid\nFROM expenses\nGROUP BY member_name\nHAVING COUNT(DISTINCT event_id) > 1\nORDER BY total_paid DESC\nLIMIT 1;",
            "SELECT T2.member_id, SUM(T1.cost) \nFROM expense AS T1\nJOIN member AS T2 ON T1.link_to_member = T2.member_id\nJOIN budget AS T3 ON T1.link_to_budget = T3.budget_id\nJOIN event AS T4 ON T3.link_to_event = T4.event_id\nGROUP BY T2.member_id\nHAVING COUNT(DISTINCT T4.event_id) > 1\nORDER BY SUM(T1.cost) DESC\nLIMIT 1",
            "SELECT T2.member_id\nFROM expense AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nINNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id\nINNER JOIN event AS T4 ON T3.link_to_event = T4.event_id\nGROUP BY T2.member_id\nHAVING COUNT(DISTINCT T4.event_id) > 1\nORDER BY SUM(T1.cost) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.member_id\nFROM expense AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nINNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id\nINNER JOIN event AS T4 ON T3.link_to_event = T4.event_id\nGROUP BY T2.member_id\nHAVING COUNT(DISTINCT T4.event_id) > 1\nORDER BY SUM(T1.cost) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "698": {
        "db_id": "codebase_community",
        "question": "How many comments and answers were left by the users on the post with the title 'Clustering 1D data'?",
        "evidence": "",
        "ground_truth": "SELECT CommentCount, AnswerCount FROM posts WHERE Title = 'Clustering 1D data'",
        "amends": [
            "Do select specific columns `CommentCount` and `AnswerCount` instead of using `COUNT(*)` aggregate. Do query from only the `posts` table instead of joining `comments` and `answers` tables. Do remove the JOIN conditions `c.user_id = a.user_id` and `c.post_id = p.post_id` instead of including unnecessary table relationships. Do use column name `Title` instead of `title` for the filter condition. The amended query now correctly retrieves the pre-calculated comment and answer counts directly from the posts table without performing unnecessary joins and aggregation."
        ],
        "rules": [
            "1) When the question asks for comment and answer counts for a specific post: select the exact columns \"CommentCount\" and \"AnswerCount\" from the posts table instead of performing aggregation. 2) When filtering for a post with a specific title: use the exact column name \"Title\" with the exact literal value 'Clustering 1D data' for the filter condition. 3) When retrieving pre-calculated counts from the posts table: query directly from the posts table without joining to comments or answers tables, as the counts are already stored as columns. 4) When the question asks about comments and answers left by users on a post: recognize that the posts table contains pre-calculated \"CommentCount\" and \"AnswerCount\" columns that directly provide this information without needing to join to other tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments c JOIN answers a ON c.user_id = a.user_id JOIN posts p ON c.post_id = p.post_id WHERE p.title = 'Clustering 1D data';",
            "SELECT CommentCount, AnswerCount FROM posts WHERE Title = 'Clustering 1D data';"
        ],
        "rule_sql": [
            "SELECT CommentCount, AnswerCount FROM posts WHERE Title = 'Clustering 1D data';"
        ],
        "amend_res": 1
    },
    "401": {
        "db_id": "card_games",
        "question": "What percentage of legendary frame effect cards that are only available in online game variations?",
        "ground_truth": "SELECT SUM(CASE WHEN isOnlineOnly = 1 THEN 1.0 ELSE 0 END) / COUNT(id) * 100 FROM cards WHERE frameEffects = 'legendary'",
        "amends": [
            "Do use `SUM(CASE WHEN isOnlineOnly = 1 THEN 1.0 ELSE 0 END) / COUNT(id) * 100` instead of `(COUNT(CASE WHEN frame_effect = 'legendary' AND games LIKE '%online%' AND games NOT LIKE '%paper%' THEN 1 END) * 100.0 / COUNT(CASE WHEN frame_effect = 'legendary' THEN 1 END))` for the percentage calculation. Do reference column `isOnlineOnly` with boolean logic instead of parsing `games` with `LIKE` patterns. Do use `COUNT(id)` instead of `COUNT(CASE WHEN frame_effect = 'legendary' THEN 1 END)` for the denominator. Do filter with `WHERE frameEffects = 'legendary'` instead of `WHERE frame_effect = 'legendary'` using the correct column name. The amended query now correctly calculates the percentage of online-only legendary cards using proper boolean flags instead of string parsing, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for percentage of legendary frame effect cards that are only available in online game variations: use SUM(CASE WHEN isOnlineOnly = 1 THEN 1.0 ELSE 0 END) / COUNT(id) * 100 for the percentage calculation. 2) When determining if a card is online-only: reference column isOnlineOnly with boolean logic instead of parsing games with LIKE patterns. 3) When counting total legendary cards for the denominator: use COUNT(id) instead of conditional counting based on frame effect. 4) When filtering for legendary frame effect cards: use WHERE frameEffects = 'legendary' with the exact column name 'frameEffects' and literal value 'legendary'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN frame_effect = 'legendary' AND games LIKE '%online%' AND games NOT LIKE '%paper%' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN frame_effect = 'legendary' THEN 1 END)) AS percentage\nFROM cards\nWHERE frame_effect = 'legendary';",
            "SELECT \n    (SUM(CASE WHEN isOnlineOnly = 1 THEN 1.0 ELSE 0 END) / COUNT(id) * 100) AS percentage\nFROM \n    cards\nWHERE \n    frameEffects = 'legendary';"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN isOnlineOnly = 1 THEN 1.0 ELSE 0 END) / COUNT(id) * 100 AS percentage\nFROM cards\nWHERE frameEffects = 'legendary';"
        ],
        "amend_res": 1
    },
    "1443": {
        "db_id": "student_club",
        "question": "Give the event ID, location, and status of events conducted from November 2019 to March 2020.",
        "ground_truth": "SELECT event_id, location, status FROM event WHERE date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-11-01' AND '2020-03-31'",
        "amends": [
            "Do reference table `event` instead of `events` in the FROM clause. Do apply `date(SUBSTR(event_date, 1, 10))` to the event_date column instead of using the raw `event_date` field directly in the WHERE filter, which properly extracts and converts the date portion from what appears to be a datetime/timestamp string format. The amended query now correctly filters events based on the date range by handling the date conversion appropriately."
        ],
        "rules": [
            "1) When the question asks about events: use table \"event\" instead of \"events\" as the data source. 2) When filtering by date range on the \"event_date\" column: apply date(SUBSTR(event_date, 1, 10)) to extract and convert the date portion from the datetime/timestamp string format before comparison. 3) When selecting output columns: return event_id, location, and status in that order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_id, location, status FROM events WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';",
            "SELECT event_id, location, status FROM event WHERE date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-11-01' AND '2020-03-31';"
        ],
        "rule_sql": [
            "SELECT event_id, location, status FROM event WHERE date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-11-01' AND '2020-03-31';"
        ],
        "amend_res": 1
    },
    "1274": {
        "db_id": "thrombosis_prediction",
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do join `Examination AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.SSB = 'negative' OR '0'` instead of `anti_ssb = 'normal'` to check for negative or zero SSB values rather than normal anti-SSB. Do keep `T1.Symptoms IS NOT NULL` instead of `symptoms IS NOT NULL` but now referencing the joined Examination table. The amended query now correctly counts distinct patients with specific laboratory results and symptoms from the appropriate joined tables.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean literal. The amended query now correctly groups the OR condition to properly filter for SSB values of either 'negative' or '0' while maintaining the Symptoms filter, matching the right SQL's intended behavior.",
            "Do use proper parentheses grouping for the `WHERE` clause with `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would cause a logical error by comparing the literal string '0' as a boolean condition. The amended query now correctly filters for SSB values that are either 'negative' or '0' while maintaining the Symptoms filter, matching the RIGHT_SQL's intended behavior.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query now correctly groups the OR conditions to properly filter for SSB values that are either 'negative' or '0' while maintaining the Symptoms filter, matching the RIGHT_SQL's intended behavior.",
            "Do use proper parentheses grouping for the `WHERE` clause with `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would cause a logical error by comparing the string literal '0' as a boolean condition. The amended query correctly groups the OR conditions together to properly filter for SSB values of either 'negative' or '0' while maintaining the Symptoms filter, ensuring accurate counting of distinct IDs from the joined Examination and Laboratory tables.",
            "Do use proper parentheses grouping for the `WHERE` clause with `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would evaluate the string literal '0' as a boolean condition. The amended query now correctly filters for SSB values that are either 'negative' or '0' while maintaining the Symptoms filter, matching the RIGHT_SQL's intended behavior.",
            "Do use proper parentheses grouping for the `WHERE` clause with `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value, ensuring the condition properly checks for either SSB value being 'negative' or '0' while maintaining the Symptoms filter. The amended query now correctly implements the intended logic to match RIGHT_SQL's behavior.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the conditions, specifically do `WHERE T2.SSB = 'negative' OR '0'` instead of `WHERE (T2.SSB = 'negative' OR T2.SSB = '0')` to properly evaluate the OR condition before the AND condition. The amended query now correctly matches the RIGHT_SQL's behavior by fixing the predicate logic.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of omitting them, which changes the logical evaluation of the WHERE clause. The amended query properly groups the OR condition to ensure correct filtering logic where either `T2.SSB = 'negative'` or `T2.SSB = '0'` must be true, while also requiring `T1.Symptoms IS NOT NULL`, matching the intended behavior of the RIGHT_SQL.",
            "Do use proper parentheses grouping for the `WHERE` clause with `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value, ensuring the logical OR operation correctly compares against both string values rather than creating an unintended boolean expression. The amended query now matches RIGHT_SQL's behavior.",
            "Do use proper parentheses grouping for the OR condition with `T2.SSB = 'negative' OR T2.SSB = '0'` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query now correctly filters for SSB values that are either 'negative' or '0' while maintaining the Symptoms IS NOT NULL condition, matching the right SQL's intended behavior.",
            "Do use proper parentheses grouping for the `WHERE` clause with `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would evaluate the string literal '0' as a boolean condition. The amended query now correctly groups the OR conditions together to properly filter for SSB values of either 'negative' or '0' while maintaining the Symptoms IS NOT NULL filter, matching the right SQL's intended behavior.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the conditions, specifically do `WHERE T2.SSB = 'negative' OR '0'` instead of `WHERE (T2.SSB = 'negative' OR T2.SSB = '0')` to properly evaluate the OR condition before the AND condition. The amended query now correctly filters for records where either T2.SSB equals 'negative' or the literal '0' is true (which is always true), combined with T1.Symptoms being not null, matching the RIGHT_SQL's behavior.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the conditions, specifically do `WHERE T2.SSB = 'negative' OR '0'` instead of `WHERE (T2.SSB = 'negative' OR T2.SSB = '0')` to properly handle the OR logic with the AND condition. The amended query now correctly evaluates the filter conditions and matches the RIGHT_SQL's behavior.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the conditions, specifically changing the WHERE clause to `T2.SSB = 'negative' OR '0'` instead of `(T2.SSB = 'negative' OR T2.SSB = '0')` to properly handle the OR logic with the subsequent AND condition. The amended query now correctly evaluates the OR condition before the AND condition, matching the RIGHT_SQL's behavior.",
            "Do use proper parentheses grouping for the OR condition in the WHERE clause with `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query now correctly filters for SSB values that are either 'negative' or '0' while maintaining the Symptoms IS NOT NULL condition, matching the right SQL's intended behavior.",
            "Do use proper parentheses grouping for the OR condition in the WHERE clause by placing `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would cause a logical error by comparing '0' as a boolean expression rather than as a value for SSB. The amended query now correctly matches the RIGHT_SQL's behavior with proper conditional logic.",
            "Do use proper parentheses grouping for the `WHERE` clause with `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value, ensuring the logical condition correctly filters for SSB values that are either 'negative' or '0' while maintaining the Symptoms filter. The amended query now matches RIGHT_SQL's behavior with proper boolean logic.",
            "Do use proper parentheses grouping for the WHERE clause with `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value, ensuring the condition properly checks for both string values rather than creating a logical error. The amended query now correctly filters for SSB values of either 'negative' or '0' while maintaining the Symptoms IS NOT NULL check, matching the intended behavior.",
            "Do use proper parentheses grouping for the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query now correctly filters for SSB values that are either 'negative' or '0' while maintaining the Symptoms IS NOT NULL condition, matching the RIGHT_SQL's intended behavior."
        ],
        "rules": [
            "anti-SSB are normal refers to SSB IN ('negative', '0'); have other symptoms refers to Symptoms IS NOT NULL; Should compute the number of distinct ones"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE anti_ssb = 'normal' AND symptoms IS NOT NULL;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "1292": {
        "db_id": "thrombosis_prediction",
        "question": "What is the anti Cardiolipin antibody concentration of the female patient with the highest uric acid level in the normal range?",
        "ground_truth": "SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T1.SEX = 'F' AND T2.UA > 6.5 ORDER BY T2.UA DESC LIMIT 1",
        "amends": [
            "Do select `T3.aCL IgG`, `T3.aCL IgM`, and `T3.aCL IgA` instead of just `anti_Cardiolipin_antibody_concentration`. Do use `INNER JOIN` with `Patient AS T1`, `Laboratory AS T2`, and `Examination AS T3` instead of querying only the `patients` table. Do join `T1.ID = T2.ID` and `T3.ID = T2.ID` instead of no joins. Do filter with `T1.SEX = 'F'` instead of `gender = 'female'`. Do use `T2.UA > 6.5` instead of a subquery finding maximum uric acid level between 0 and 100. Do order by `T2.UA DESC` instead of `uric_acid_level DESC`. The amended query now correctly joins multiple tables, uses proper column references, and applies a direct threshold filter instead of a subquery maximum calculation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about anti Cardiolipin antibody concentration: make sure the output includes T3.\"aCL IgG\", T3.\"aCL IgM\", and T3.\"aCL IgA\" columns. 2) When combining patient, laboratory, and examination data: link rows where T1.ID = T2.ID and T3.ID = T2.ID, keeping only matching pairs (inner match). 3) When the question mentions \"female patient\": use T1.SEX = 'F' as the exact filter condition. 4) When the question mentions \"highest uric acid level in the normal range\": use T2.UA > 6.5 as the direct threshold filter instead of finding maximum values. 5) When ordering results by uric acid level: order by T2.UA DESC to get the highest values first. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for columns like T3.\"aCL IgG\". 7) When handling text literals: do not change case, spacing, or punctuation for values like 'F'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT anti_Cardiolipin_antibody_concentration \nFROM patients \nWHERE gender = 'female' \nAND uric_acid_level = (SELECT MAX(uric_acid_level) FROM patients WHERE uric_acid_level BETWEEN 0 AND 100) \nORDER BY uric_acid_level DESC \nLIMIT 1;",
            "SELECT T3.\"aCL IgG\", T3.\"aCL IgM\", T3.\"aCL IgA\"\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T1.SEX = 'F' AND T2.UA > 6.5\nORDER BY T2.UA DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.\"aCL IgG\", T3.\"aCL IgM\", T3.\"aCL IgA\"\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T2.ID = T3.ID\nWHERE T1.SEX = 'F' AND T2.UA > 6.5\nORDER BY T2.UA DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1355": {
        "db_id": "student_club",
        "question": "Where is the hometown state for \"Sacha Harrison\"?",
        "ground_truth": "SELECT T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
        "amends": [
            "Do select `T2.state` from the `zip_code` table instead of `state` from the `hometowns` table. Do use `INNER JOIN` between `member` and `zip_code` tables on `T1.zip = T2.zip_code` instead of querying a single table. Do filter on `T1.first_name = 'Sacha'` and `T1.last_name = 'Harrison'` instead of `name = 'Sacha Harrison'`. Do remove the direct table access to `hometowns` and instead join through the member's zip code relationship. The amended query now correctly retrieves the state by joining member information with zip code data instead of relying on a potentially incorrect hometowns table."
        ],
        "rules": [
            "1) When the question asks for hometown state of a person: use the zip_code table's state column (T2.state) instead of a hometowns table. 2) When joining member and zip_code tables: link rows where T1.zip = T2.zip_code using an inner match. 3) When filtering for a person named 'Sacha Harrison': use separate conditions T1.first_name = 'Sacha' and T1.last_name = 'Harrison' instead of a combined name field. 4) When selecting output: return only the state column from the zip_code table (T2.state)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT state FROM hometowns WHERE name = 'Sacha Harrison';",
            "SELECT T2.state \nFROM member T1\nINNER JOIN zip_code T2 ON T1.zip = T2.zip_code\nWHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'"
        ],
        "rule_sql": [
            "SELECT T2.state FROM member T1 JOIN zip_code T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'"
        ],
        "amend_res": 1
    },
    "233": {
        "db_id": "toxicology",
        "question": "Please list top two bonds that happened with the molecule TR006 in alphabetical order.",
        "ground_truth": "SELECT DISTINCT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.molecule_id = 'TR006' ORDER BY T2.bond_id LIMIT 2",
        "amends": [
            "Do select `DISTINCT T2.bond_id` instead of `bond_name` from the SELECT list. Do change the FROM source to `atom AS T1 INNER JOIN connected AS T2` instead of just `bonds`. Do add the join condition `ON T1.atom_id = T2.atom_id` instead of no join. Do change the WHERE filter to `T1.molecule_id = 'TR006'` instead of `molecule = 'TR006'`. Do change the ORDER BY to `T2.bond_id` instead of `bond_name ASC`. The amended query now correctly retrieves distinct bond IDs from the connected table through proper table joins and filtering."
        ],
        "rules": [
            "1) When answering about \"bonds that happened with the molecule TR006\": make sure the output order: T2.bond_id in alphabetical order. 2) When the question mentions \"bonds\": \"bonds\" actually means \"T2.bond_id in schema\" from the connected table. 3) When the question mentions \"molecule TR006\": \"TR006\" actually means \"T1.molecule_id = 'TR006'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.atom_id = T2.atom_id exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"top two\": rank rows by T2.bond_id in alphabetical order and keep the first 2 rows. 6) When the question asks for \"distinct bonds\": compute the number of unique values of T2.bond_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_name FROM bonds WHERE molecule = 'TR006' ORDER BY bond_name ASC LIMIT 2;",
            "SELECT DISTINCT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.molecule_id = 'TR006'\nORDER BY T2.bond_id\nLIMIT 2"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.bond_id\nFROM connected T1\nJOIN connected T2 ON T1.atom_id = T2.atom_id\nJOIN atom a ON T1.atom_id = a.atom_id\nWHERE a.molecule_id = 'TR006'\nORDER BY T2.bond_id ASC\nLIMIT 2"
        ],
        "amend_res": 1
    },
    "30": {
        "db_id": "california_schools",
        "question": "Which cities have the top 5 lowest enrollment number for students in grades 1 through 12?",
        "ground_truth": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode GROUP BY T2.City ORDER BY SUM(T1.`Enrollment (K-12)`) ASC LIMIT 5",
        "amends": [
            "Do use `T2.City` in the SELECT list instead of `city` and remove the alias `total_enrollment` instead of keeping it. Do join `frpm AS T1` and `schools AS T2` with `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do remove the `WHERE grade BETWEEN 1 AND 12` filter instead of including it. Do aggregate by `T2.City` instead of `city` and use `SUM(T1.`Enrollment (K-12)`)` for ordering instead of `SUM(enrollment)`. Do order by the aggregate expression directly instead of using an alias and maintain `ASC` ordering with `LIMIT 5`. The amended query now correctly joins the required tables and calculates enrollment from the appropriate source.",
            "Do remove `SUM(T1.\"Enrollment (K-12)\")` from the SELECT list instead of including it, as the aggregation is only needed for ordering purposes. Do keep the `GROUP BY T2.City` clause to maintain the grouping structure. Do retain the `ORDER BY SUM(T1.\"Enrollment (K-12)\") ASC` clause to sort by the enrollment sum. Do preserve the `LIMIT 5` to return the top 5 results. The amended query now correctly returns only the city names while still ordering by the enrollment sum, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about cities with lowest enrollment: use T2.City in the SELECT list without any alias for the city column. 2) When calculating enrollment for grades 1 through 12: use SUM(T1.\"Enrollment (K-12)\") as the enrollment measure instead of any other enrollment column. 3) When combining frpm and schools tables: perform an INNER JOIN where T1.CDSCode = T2.CDSCode to link related records. 4) When ordering results for top 5 lowest enrollment: order by the SUM(T1.\"Enrollment (K-12)\") expression directly in ASCending order and limit to 5 rows. 5) When grouping results: group by T2.City to organize enrollment data by city.",
            "1) When answering about \"cities with top 5 lowest enrollment number for students in grades 1 through 12\": make sure the output order includes only \"T2.City\" without the enrollment sum column. 2) When the question mentions \"enrollment number for students in grades 1 through 12\": \"enrollment\" actually means \"T1.\\\"Enrollment (K-12)\\\"\" in schema. 3) When the question asks for \"top 5 lowest enrollment\": rank rows by SUM(T1.\\\"Enrollment (K-12)\\\") in ascending order and keep the first 5 rows. 4) When the question says \"by cities\"/\"per city\": organize results by T2.City and compute enrollment sum per group. 5) When combining T1 and T2 for shared entities: link rows where T1.CDSCode = T2.CDSCode exactly as shown; keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, SUM(enrollment) as total_enrollment \nFROM schools \nWHERE grade BETWEEN 1 AND 12 \nGROUP BY city \nORDER BY total_enrollment ASC \nLIMIT 5;",
            "SELECT T2.City, SUM(T1.\"Enrollment (K-12)\") \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nGROUP BY T2.City \nORDER BY SUM(T1.\"Enrollment (K-12)\") ASC \nLIMIT 5",
            "SELECT T2.City\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nGROUP BY T2.City\nORDER BY SUM(T1.\"Enrollment (K-12)\") ASC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT T2.City\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nGROUP BY T2.City\nORDER BY SUM(T1.\"Enrollment (K-12)\") ASC\nLIMIT 5"
        ],
        "amend_res": 1
    },
    "7": {
        "db_id": "california_schools",
        "question": "What is the phone number of the school that has the highest number of test takers with an SAT score of over 1500?",
        "evidence": "",
        "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [
            "Do select `T2.Phone` from the `schools` table instead of `phone_number` from `schools`. Do use `satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode` as the data source instead of just the `schools` table with a correlated subquery. Do order by `T1.NumGE1500 DESC` instead of ordering by the result of a subquery that counts test takers with `sat_score > 1500`. Do remove the correlated subquery entirely instead of using it for ordering. The amended query now correctly joins the satscores and schools tables using the appropriate join condition and leverages the pre-calculated count of high scorers (NumGE1500) for efficient sorting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about phone number of a school: select \"T2.Phone\" from the schools table instead of phone_number. 2) When combining satscores and schools tables: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match). 3) When the question asks for the school with highest number of test takers with SAT score over 1500: order by T1.NumGE1500 in descending direction and keep the first row. 4) When handling the count of high scorers: use the pre-calculated T1.NumGE1500 column instead of counting with a subquery."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM schools ORDER BY (SELECT COUNT(*) FROM test_takers WHERE test_takers.school_id = schools.id AND sat_score > 1500) DESC LIMIT 1;",
            "SELECT T2.Phone\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Phone \nFROM satscores T1 \nINNER JOIN schools T2 ON T1.cds = T2.CDSCode \nORDER BY T1.NumGE1500 DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "704": {
        "db_id": "codebase_community",
        "question": "What is the excerpt post ID and wiki post ID of the tag named sample?",
        "ground_truth": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'",
        "amends": [
            "Do use column names `ExcerptPostId` and `WikiPostId` instead of `excerpt_post_id` and `wiki_post_id` in the SELECT list. Do filter on column `TagName` instead of `name` in the WHERE clause. The amended query now correctly references the proper column names and matches the intended behavior."
        ],
        "rules": [
            "1) When selecting columns from the tags table: use exact column names \"ExcerptPostId\" and \"WikiPostId\" instead of lowercase versions. 2) When filtering by tag name: use the exact column name \"TagName\" instead of \"name\" and match the literal value 'sample' exactly as specified in the question. 3) When answering about excerpt post ID and wiki post ID of a specific tag: ensure the output order is \"ExcerptPostId\" first, then \"WikiPostId\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT excerpt_post_id, wiki_post_id FROM tags WHERE name = 'sample';",
            "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample';"
        ],
        "rule_sql": [
            "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample';"
        ],
        "amend_res": 1
    },
    "1399": {
        "db_id": "student_club",
        "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
        "ground_truth": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
        "amends": [
            "Do use a `CASE` expression returning 'YES' instead of selecting all columns with `*`. Do join three tables (`member`, `attendance`, and `event`) with `INNER JOIN` instead of querying a single `athletes` table. Do join `member` to `attendance` on `member_id = link_to_member` and `attendance` to `event` on `link_to_event = event_id` instead of no joins. Do filter on separate `first_name = 'Maya'` and `last_name = 'Mclean'` conditions instead of a single `name = 'Maya Mclean'` filter. Do add a filter for `event_name = 'Women's Soccer'` instead of `event = 'Women's Soccer'`. The amended query now correctly checks attendance records through proper table relationships instead of assuming a denormalized athletes table.",
            "Do use `CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END` instead of `CASE WHEN COUNT(*) > 0 THEN 'YES' ELSE 'NO' END` to directly check the event condition rather than counting rows. Do remove the `ELSE 'NO'` clause instead of including it since the query should only return 'YES' when the specific event is found. Do place the `event_name` filter in the `SELECT` clause instead of the `WHERE` clause to preserve all matching records while only marking the specific event. Do alias tables as `T1`, `T2`, and `T3` instead of `m`, `a`, and `e` for consistency. Do rename the result column to `result` instead of `attended` for clarity. The amended query now correctly identifies attendance at the specific Women's Soccer event while preserving the original join logic and member filters."
        ],
        "rules": [
            "1) When answering about whether someone attended an event: use a CASE expression returning 'YES' instead of selecting all columns. 2) When checking attendance records: join three tables (member, attendance, and event) with INNER JOIN instead of using a single table. 3) When linking member to attendance: join on member_id = link_to_member. 4) When linking attendance to event: join on link_to_event = event_id. 5) When filtering for a person's name: use separate conditions first_name = 'Maya' and last_name = 'Mclean' instead of a single name filter. 6) When filtering for an event: use event_name = 'Women's Soccer' instead of event = 'Women's Soccer'.",
            "1) When answering about attendance at a specific event: use CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END to directly check the event condition rather than counting rows. 2) When handling conditional results: do not include an ELSE 'NO' clause when the query should only return 'YES' when the specific event is found. 3) When filtering for specific events: place the event_name condition in the SELECT clause instead of the WHERE clause to preserve all matching records while only marking the specific event. 4) When using table aliases: use T1 for member table, T2 for attendance table, and T3 for event table for consistency. 5) When naming result columns: rename the output column to result instead of attended for clarity. 6) When combining tables for attendance records: link rows where T1.member_id = T2.link_to_member and T2.link_to_event = T3.event_id to find member attendance at events."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM athletes WHERE name = 'Maya Mclean' AND event = 'Women\\'s Soccer';",
            "SELECT CASE WHEN COUNT(*) > 0 THEN 'YES' ELSE 'NO' END AS attended\nFROM member m\nINNER JOIN attendance a ON m.member_id = a.link_to_member\nINNER JOIN event e ON a.link_to_event = e.event_id\nWHERE m.first_name = 'Maya' \nAND m.last_name = 'Mclean'\nAND e.event_name = 'Women''s Soccer';",
            "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result\nFROM member T1\nINNER JOIN attendance T2 ON T1.member_id = T2.link_to_member\nINNER JOIN event T3 ON T2.link_to_event = T3.event_id\nWHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'"
        ],
        "rule_sql": [
            "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result\nFROM member T1\nINNER JOIN attendance T2 ON T1.member_id = T2.link_to_member\nINNER JOIN event T3 ON T2.link_to_event = T3.event_id\nWHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'"
        ],
        "amend_res": 1
    },
    "1077": {
        "db_id": "european_football_2",
        "question": "What's the long name for the team GEN?",
        "ground_truth": "SELECT team_long_name FROM Team WHERE team_short_name = 'GEN'",
        "amends": [
            "Do select `team_long_name` instead of `team_name` from the table `Team` instead of `teams` where `team_short_name` instead of `team_abbreviation` equals 'GEN'. The amended query now correctly retrieves the team's long name from the appropriate table using the correct column name for the team abbreviation filter."
        ],
        "rules": [
            "1) When the question asks for \"long name\" of a team: select \"team_long_name\" from table \"Team\". 2) When filtering by team abbreviation mentioned in the question: use column \"team_short_name\" with exact literal value 'GEN' (case-sensitive). 3) When referring to the teams table: use exact table name \"Team\" (case-sensitive) instead of any other table name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name FROM teams WHERE team_abbreviation = 'GEN';",
            "SELECT team_long_name FROM Team WHERE team_short_name = 'GEN';"
        ],
        "rule_sql": [
            "SELECT team_long_name FROM Team WHERE team_short_name = 'GEN';"
        ],
        "amend_res": 1
    },
    "412": {
        "db_id": "card_games",
        "question": "What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?",
        "ground_truth": "SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'",
        "amends": [
            "Do select `name` from the `foreign_data` table instead of `foreign_name` from the `cards` table. Do use a subquery to filter `uuid` values from the `cards` table with conditions on `types`, `layout`, `borderColor`, and `artist` instead of applying these filters directly in the main query. Do reference `types` instead of `type` and `borderColor` instead of `border_color` in the subquery predicates. Do move the `language` filter to the main query on `foreign_data` instead of keeping it in the `cards` table filter. The amended query now correctly retrieves localized names by joining through the uuid relationship between cards and foreign_data tables.",
            "Do use `types = 'Creature'` instead of `types LIKE '%Creature%'` to match exact values rather than partial string matches. Do place the `language = 'French'` filter at the end of the WHERE clause instead of at the beginning for consistent query structure. Do remove the table alias `fd` from the SELECT clause and WHERE conditions instead of keeping it for cleaner syntax. The amended query now correctly filters for exact 'Creature' type matches and maintains the same logical behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"foreign name of the card in French\": select \"name\" from the \"foreign_data\" table instead of \"foreign_name\" from the \"cards\" table. 2) When filtering cards by type, layout, border color, and artist: use a subquery to filter \"uuid\" values from the \"cards\" table with conditions on \"types\", \"layout\", \"borderColor\", and \"artist\". 3) When referencing card attributes: use \"types\" instead of \"type\" and \"borderColor\" instead of \"border_color\" in the subquery predicates. 4) When filtering for French language: apply the \"language\" filter to the main query on \"foreign_data\" table instead of the \"cards\" table. 5) When joining cards and foreign_data tables: link rows where the canonical keys match through the \"uuid\" relationship between the tables.",
            "1) When the question asks for \"type Creature\": use exact equality comparison with 'Creature' instead of partial string matching. 2) When ordering WHERE clause conditions: place language filters like 'language = \\\"French\\\"' at the end of the WHERE clause for consistent structure. 3) When selecting columns: do not use table aliases in the SELECT clause for cleaner syntax."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT foreign_name FROM cards WHERE type = 'Creature' AND layout = 'normal' AND border_color = 'black' AND artist = 'Matthew D. Wilson' AND language = 'French';",
            "SELECT fd.name \nFROM foreign_data fd\nWHERE fd.language = 'French'\nAND fd.uuid IN (\n    SELECT c.uuid \n    FROM cards c \n    WHERE c.types LIKE '%Creature%' \n    AND c.layout = 'normal' \n    AND c.borderColor = 'black' \n    AND c.artist = 'Matthew D. Wilson'\n)",
            "SELECT fd.name \nFROM foreign_data fd\nWHERE fd.language = 'French'\nAND fd.uuid IN (\n    SELECT uuid \n    FROM cards \n    WHERE types = 'Creature' \n    AND layout = 'normal' \n    AND borderColor = 'black' \n    AND artist = 'Matthew D. Wilson'\n)"
        ],
        "rule_sql": [
            "SELECT fd.name\nFROM foreign_data fd\nWHERE fd.language = \"French\"\nAND fd.uuid IN (\n    SELECT c.uuid\n    FROM cards c\n    WHERE c.types = 'Creature'\n    AND c.layout = 'normal'\n    AND c.borderColor = 'black'\n    AND c.artist = 'Matthew D. Wilson'\n)"
        ],
        "amend_res": 1
    },
    "204": {
        "db_id": "toxicology",
        "question": "Of the first 100 molecules in number order, how many are carcinogenic?",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'",
        "amends": [
            "Do count `T.molecule_id` instead of `*` and use table alias `T` instead of no alias. Do specify `BETWEEN 'TR000' AND 'TR099'` range filtering instead of `molecule_id <= 100` numeric comparison. Do filter on `T.label = '+'` instead of `carcinogenic = 'yes'` and reference the table through alias `T` instead of directly. Do query from `molecule AS T` instead of `molecules` table name. The amended query now correctly counts specific molecule IDs within the designated TR range that have positive labels."
        ],
        "rules": [
            "1) When the question asks about \"first 100 molecules in number order\": filter molecules where \"molecule_id\" is between 'TR000' and 'TR099' inclusive. 2) When the question asks about \"carcinogenic\" molecules: filter for rows where \"label\" equals '+' exactly. 3) When counting molecules: count using the exact token \"T\".\"molecule_id\" as the counting key. 4) When referring to the molecules table: use the exact table name \"molecule\" with alias \"T\". 5) When producing output: return a single count value of the matching molecules."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE molecule_id <= 100 AND carcinogenic = 'yes';",
            "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'"
        ],
        "amend_res": 1
    },
    "1309": {
        "db_id": "thrombosis_prediction",
        "question": "Please list a patient's platelet level if it is within the normal range and if he or she is diagnosed with MCTD.",
        "ground_truth": "SELECT T2.PLT FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'MCTD' AND T2.PLT BETWEEN 100 AND 400",
        "amends": [
            "Do select `T2.PLT` from the `Laboratory` table instead of `platelet_level` from the `patients` table. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter on `T1.Diagnosis = 'MCTD'` instead of `diagnosis = 'MCTD'`. Do use `BETWEEN 100 AND 400` for the platelet range instead of `> 150 AND < 450`. The amended query now correctly retrieves laboratory data from the proper table with appropriate join conditions and inclusive range filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about platelet levels: select \"T2\".\"PLT\" from the \"Laboratory\" table instead of platelet_level from the patients table. 2) When combining patient and laboratory data: link rows where \"T1\".\"ID\" = \"T2\".\"ID\" using an inner join and keep only matching pairs. 3) When filtering for MCTD diagnosis: use \"T1\".\"Diagnosis\" = 'MCTD' exactly as specified. 4) When checking for normal platelet range: use BETWEEN 100 AND 400 for inclusive range filtering instead of > 150 AND < 450."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT platelet_level FROM patients WHERE diagnosis = 'MCTD' AND platelet_level > 150 AND platelet_level < 450",
            "SELECT T2.PLT \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'MCTD' \nAND T2.PLT BETWEEN 100 AND 400"
        ],
        "rule_sql": [
            "SELECT T2.PLT\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'MCTD'\nAND T2.PLT BETWEEN 100 AND 400"
        ],
        "amend_res": 1
    },
    "480": {
        "db_id": "card_games",
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "ground_truth": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "amends": [
            "Do select `T2.flavorText` from the `foreign_data` table instead of `flavor_text` from the `cards` table. Do join `cards AS T1` with `foreign_data AS T2` using `INNER JOIN` on `T2.uuid = T1.uuid` instead of querying only the `cards` table without any join. Do filter on `T1.name = 'Ancestor''s Chosen'` instead of `name = 'Ancestor\\'s Chosen'` to use the properly escaped string literal. Do filter on `T2.language = 'Italian'` instead of `language = 'Italian'` to reference the correct table's column. The amended query now correctly retrieves flavor text from the foreign_data table joined with cards using UUID matching, ensuring accurate language-specific results."
        ],
        "rules": [
            "1) When answering about \"Italian flavor text of the card 'Ancestor's Chosen'\": make sure the output order: T2.flavorText. 2) When the question mentions \"flavor text\": \"flavor text\" actually means \"T2.flavorText in schema\". 3) When combining T1 and T2 for shared entities: link rows where T2.uuid = T1.uuid exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for the specific card name: use T1.name = 'Ancestor''s Chosen' with the exact string literal and proper escaping. 5) When filtering for Italian language: use T2.language = 'Italian' with the exact string literal."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT flavor_text FROM cards WHERE name = 'Ancestor\\'s Chosen' AND language = 'Italian';",
            "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'"
        ],
        "rule_sql": [
            "SELECT T2.flavorText \nFROM cards T1 \nINNER JOIN foreign_data T2 ON T2.uuid = T1.uuid \nWHERE T1.name = 'Ancestor''s Chosen' \nAND T2.language = 'Italian'"
        ],
        "amend_res": 1
    },
    "710": {
        "db_id": "codebase_community",
        "question": "In posts with 1 comment, how many of the comments have 0 score?",
        "ground_truth": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific column values. Do add table aliases `AS T1` and `AS T2` instead of omitting them for clarity. Do change from a subquery to an `INNER JOIN` on `T1.PostId = T2.Id` instead of using `INNER JOIN` on `T1.PostId = T2.Id` instead of the subquery approach. Do move the `score = 0` filter from the comments table to the posts table as `T2.Score = 0` instead of applying it to comments. Do change the filter from `comment_count = 1` to `CommentCount = 1` with proper case sensitivity. The amended query now correctly counts comments from posts with exactly one comment and a score of zero, matching the intended behavior.",
            "Do reference `T1.id` in lowercase instead of `T1.Id` in uppercase for the column name. Do filter on `T2.Score = 0` instead of `T1.Score = 0` to correctly check the post's score rather than the comment's score. The amended query now matches RIGHT_SQL's behavior by properly counting comments on posts with exactly one comment and zero score."
        ],
        "rules": [
            "1) When counting comments: use COUNT(T1.id) instead of COUNT(*) to count specific column values. 2) When combining posts and comments tables: use INNER JOIN on T1.PostId = T2.Id instead of subqueries. 3) When filtering for posts with exactly one comment: use T2.CommentCount = 1 with exact case sensitivity. 4) When filtering for comments with zero score: apply T1.Score = 0 filter to the comments table (T1) instead of the posts table. 5) When answering about comments from posts with 1 comment having 0 score: ensure the query counts comments that meet both conditions through proper table joining and filtering.",
            "1) When the question asks about \"posts with 1 comment\": filter posts where \"CommentCount\" equals 1 exactly. 2) When the question asks about \"comments have 0 score\": filter posts where \"Score\" equals 0 exactly. 3) When counting comments on qualifying posts: count using the exact identifier \"T1.id\" in lowercase. 4) When combining comments and posts tables: link rows where \"T1.PostId\" equals \"T2.Id\" exactly and keep only matching pairs (inner match)."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE score = 0 AND post_id IN (SELECT post_id FROM posts WHERE comment_count = 1);",
            "SELECT COUNT(T1.Id) \nFROM comments AS T1\nINNER JOIN posts AS T2 ON T1.PostId = T2.Id\nWHERE T2.CommentCount = 1 AND T1.Score = 0",
            "SELECT COUNT(T1.id) \nFROM comments AS T1\nINNER JOIN posts AS T2 ON T1.PostId = T2.Id\nWHERE T2.CommentCount = 1 AND T2.Score = 0"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.CommentCount = 1 \nAND T1.Score = 0"
        ],
        "amend_res": 1
    },
    "1129": {
        "db_id": "european_football_2",
        "question": "List down the long name for slow speed class team.",
        "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Slow'",
        "amends": [
            "Do use `DISTINCT t1.team_long_name` instead of `team_name` without distinct. Do change the FROM clause to `INNER JOIN Team_Attributes AS t2` instead of a single table `teams`. Do add the join condition `ON t1.team_api_id = t2.team_api_id` instead of no join. Do change the WHERE filter to `t2.buildUpPlaySpeedClass = 'Slow'` instead of `speed_class = 'fast'`. The amended query now correctly joins tables and filters on the appropriate speed class attribute."
        ],
        "rules": [
            "1) When answering about \"long name for slow speed class team\": make sure the output order: t1.team_long_name\n2) When the question mentions \"slow speed class\": \"slow speed class\" actually means \"t2.buildUpPlaySpeedClass = 'Slow'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.team_api_id = t2.team_api_id); keep only matching pairs (inner match)\n4) When the question asks for \"long name\": use t1.team_long_name instead of team_name\n5) When the question asks for distinct values: use DISTINCT t1.team_long_name to avoid duplicate entries"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name FROM teams WHERE speed_class = 'fast';",
            "SELECT DISTINCT t1.team_long_name\nFROM Team AS t1\nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.buildUpPlaySpeedClass = 'Slow'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.team_long_name\nFROM Team t1\nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.buildUpPlaySpeedClass = 'Slow'"
        ],
        "amend_res": 1
    },
    "1386": {
        "db_id": "student_club",
        "question": "What is the total expense for the Yearly Kickoff?",
        "ground_truth": "SELECT SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'Yearly Kickoff'",
        "amends": [
            "Do join tables `event`, `budget`, and `expense` with proper relationships instead of querying a single `expenses` table. Do use `T3.cost` as the aggregation column instead of `amount`. Do specify `INNER JOIN` between `event` and `budget` on `T1.event_id = T2.link_to_event` instead of missing this relationship. Do add another `INNER JOIN` between `budget` and `expense` on `T2.budget_id = T3.link_to_budget` instead of omitting this connection. Do filter on `T1.event_name = 'Yearly Kickoff'` instead of filtering directly on an expenses table. The amended query now correctly aggregates costs from the expense table through proper table relationships to match the intended behavior."
        ],
        "rules": [
            "1) When answering about total expense for an event: join tables event (T1), budget (T2), and expense (T3) using proper relationships instead of querying a single table. 2) When combining T1 and T2: link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match). 3) When combining T2 and T3: link rows where T2.budget_id = T3.link_to_budget and keep only matching pairs (inner match). 4) When filtering for a specific event name: use T1.event_name = 'Yearly Kickoff' instead of filtering directly on expense tables. 5) When aggregating total expense: use SUM(T3.cost) as the aggregation column instead of amount."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM expenses WHERE event_name = 'Yearly Kickoff';",
            "SELECT SUM(T3.cost) AS total_expense\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'Yearly Kickoff'"
        ],
        "rule_sql": [
            "SELECT SUM(T3.cost) AS total_expense\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'Yearly Kickoff'"
        ],
        "amend_res": 1
    },
    "379": {
        "db_id": "card_games",
        "question": "What are the cards belong to duel deck a? List the ID.",
        "ground_truth": "SELECT id FROM cards WHERE duelDeck = 'a'",
        "amends": [
            "Do select `id` instead of `card_id` in the SELECT list. Do use column name `duelDeck` instead of `duel_deck` in the WHERE filter. The amended query now correctly retrieves the id column using the proper column name for the duel deck filter, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"cards belong to duel deck a\": filter rows where \"duelDeck\" equals 'a' exactly. 2) When the question asks for \"ID\" of cards: select the \"id\" column from the cards table. 3) When choosing column names: use exact column name \"duelDeck\" (not \"duel_deck\") for filtering and \"id\" (not \"card_id\") for selection."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_id FROM cards WHERE duel_deck = 'a';",
            "SELECT id FROM cards WHERE duelDeck = 'a';"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE duelDeck = 'a'"
        ],
        "amend_res": 1
    },
    "1383": {
        "db_id": "student_club",
        "question": "State the name of students from Georgetown, South Carolina.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Georgetown' AND T2.state = 'South Carolina'",
        "amends": [
            "Do select `first_name` and `last_name` from the `member` table instead of `name` from `students`. Do join `zip_code` on `zip=zip_code` instead of querying a single table. Do filter on `city` and `state` from the joined `zip_code` table instead of from the main table. Do use explicit table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves member names based on geographic data from the zip code reference table."
        ],
        "rules": [
            "1) When the question asks for student names from Georgetown, South Carolina: select both \"first_name\" and \"last_name\" from table \"member\" (T1) instead of a single \"name\" column. 2) When combining geographic data with member information: join table \"zip_code\" (T2) to \"member\" (T1) where T1.\"zip\" equals T2.\"zip_code\" using an inner match. 3) When filtering by location: apply the city filter using T2.\"city\" = 'Georgetown' and state filter using T2.\"state\" = 'South Carolina' instead of filtering on the main table. 4) When using table aliases: consistently use T1 for \"member\" table and T2 for \"zip_code\" table as specified in the amends."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE city = 'Georgetown' AND state = 'South Carolina';",
            "SELECT T1.first_name, T1.last_name FROM member T1 JOIN zip_code T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Georgetown' AND T2.state = 'South Carolina'"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM member T1\nINNER JOIN zip_code T2 ON T1.zip = T2.zip_code\nWHERE T2.city = 'Georgetown' AND T2.state = 'South Carolina'"
        ],
        "amend_res": 1
    },
    "1251": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients with an Ig G higher than normal?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
        "amends": [
            "Do `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` and `INNER JOIN Examination AS T3 ON T3.ID = T2.ID` instead of querying only the `patients` table to incorporate laboratory and examination data. Do `T2.IGG >= 2000` instead of `ig_g > normal` to use the correct column name with a specific numeric threshold rather than an undefined reference. The amended query now correctly counts distinct patients with elevated IgG levels from laboratory results, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows. 2) When answering about patients with IgG levels: incorporate data from Laboratory table as T2 and Examination table as T3 using INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID and INNER JOIN Examination AS T3 ON T3.ID = T2.ID. 3) When checking for IgG higher than normal: use T2.IGG >= 2000 with the specific numeric threshold of 2000 instead of undefined references. 4) When combining patient, laboratory, and examination data: link rows where T1.ID = T2.ID and T3.ID = T2.ID to keep only matching patient records across all three tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE ig_g > normal",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.IGG >= 2000"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.IGG >= 2000"
        ],
        "amend_res": 1
    },
    "59": {
        "db_id": "california_schools",
        "question": "What is the website for the schools under the administrations of Mike Larson and Dante Alvarez?",
        "evidence": "",
        "ground_truth": "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez')",
        "amends": [
            "Do reference columns `Website`, `AdmFName1`, and `AdmLName1` instead of `website` and `administrator`. Do use compound conditions `(AdmFName1 = 'Mike' AND AdmLName1 = 'Larson')` instead of single column matching `administrator = 'Mike Larson'`. Do maintain the same OR logic structure but with proper first and last name separation instead of concatenated values. The amended query now correctly matches the RIGHT_SQL's behavior by properly filtering on separate first and last name columns."
        ],
        "rules": [
            "1) When the question asks for website information from schools: use the exact column name \"Website\" from table \"schools\" (T1). 2) When the question mentions administrator names like \"Mike Larson\" and \"Dante Alvarez\": split these into separate first and last name components using columns \"AdmFName1\" and \"AdmLName1\". 3) When matching \"Mike Larson\": use the compound condition (\"AdmFName1\" = 'Mike' AND \"AdmLName1\" = 'Larson'). 4) When matching \"Dante Alvarez\": use the compound condition (\"AdmFName1\" = 'Dante' AND \"AdmLName1\" = 'Alvarez'). 5) When combining multiple administrator conditions: use OR logic to include schools matching either administrator pair."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT website FROM schools WHERE administrator = 'Mike Larson' OR administrator = 'Dante Alvarez';",
            "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez')"
        ],
        "rule_sql": [
            "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez')"
        ],
        "amend_res": 1
    },
    "1420": {
        "db_id": "student_club",
        "question": "State the name of major that Vice President has joined.",
        "ground_truth": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Vice President'",
        "amends": [
            "Do select `T1.major_name` from the `major` table instead of `major` from the `students` table. Do join `major AS T1` with `member AS T2` using `INNER JOIN` on `T1.major_id = T2.link_to_major` instead of querying a single table. Do filter on `T2.position = 'Vice President'` instead of filtering on a non-existent `position` column in the original table. The amended query now correctly retrieves major names by joining the appropriate tables and filtering on the member position, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"major that Vice President has joined\": make sure the output order: T1.major_name. 2) When the question mentions \"Vice President\": \"Vice President\" actually means T2.position = 'Vice President' in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.major_id = T2.link_to_major exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation for 'Vice President'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT major FROM students WHERE position = 'Vice President';",
            "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Vice President'"
        ],
        "rule_sql": [
            "SELECT T1.major_name\nFROM major T1\nINNER JOIN member T2 ON T1.major_id = T2.link_to_major\nWHERE T2.position = 'Vice President'"
        ],
        "amend_res": 1
    },
    "377": {
        "db_id": "card_games",
        "question": "How many cards with original type of \"Summon - Angel\" have subtype other than \"Angel\"?",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'",
        "amends": [
            "Do use `COUNT(id)` instead of `COUNT(*)` to count specific non-null values. Do reference column `originalType` instead of `original_type` to match the correct column name. Do use inequality filter `subtypes != 'Angel'` instead of equality filter `subtype = 'Angel'` to exclude Angel subtypes rather than include them. Do reference column `subtypes` instead of `subtype` to match the correct column name. The amended query now correctly counts cards with originalType 'Summon - Angel' that do not have Angel subtypes."
        ],
        "rules": [
            "1) When counting cards: use COUNT(id) instead of COUNT(*) to count specific non-null values. 2) When the question mentions \"original type\": \"original type\" actually means \"originalType\" in schema. 3) When the question mentions \"subtype\": \"subtype\" actually means \"subtypes\" in schema. 4) When filtering for cards with original type of \"Summon - Angel\": use originalType = 'Summon - Angel' exactly as specified. 5) When excluding Angel subtypes: use subtypes != 'Angel' instead of equality to exclude rather than include Angel subtypes."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE original_type = 'Summon - Angel' AND subtype = 'Angel';",
            "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'"
        ],
        "amend_res": 1
    },
    "880": {
        "db_id": "formula_1",
        "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
        "ground_truth": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
        "amends": [
            "Do use `SUM(IIF())` conditional aggregation instead of direct column subtraction. Do join `drivers` and `results` tables instead of self-joining `races`. Do filter on `forename = 'Paul' AND surname = 'di Resta'` instead of `driver_name = 'Paul di Resta'`. Do calculate percentage using `(sum_853 - sum_854) * 100 / sum_853` instead of `(r1.speed - r2.speed) / r2.speed * 100`. Do reference `raceId` columns 853 and 854 instead of `race_number`. The amended query now correctly calculates the percentage difference in fastest lap speeds between two specific races for the specified driver."
        ],
        "rules": [
            "1) When answering about percentage difference in fastest lap speeds between two specific races for a driver: use conditional aggregation with SUM(IIF()) instead of direct column subtraction. 2) When combining driver and race information: join \"drivers\" and \"results\" tables instead of self-joining a single table. 3) When filtering for driver 'Paul di Resta': use exact conditions forename = 'Paul' AND surname = 'di Resta' instead of a combined driver_name field. 4) When calculating percentage difference: use formula (sum_853 - sum_854) * 100 / sum_853 instead of (r1.speed - r2.speed) / r2.speed * 100. 5) When referencing specific races: use exact column \"raceId\" with values 853 and 854 instead of race_number."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (r1.fastest_lap_speed - r2.fastest_lap_speed) / r2.fastest_lap_speed * 100 AS percent_faster\nFROM \n    races r1\nJOIN \n    races r2 ON r1.driver_id = r2.driver_id\nWHERE \n    r1.race_number = 853\n    AND r2.race_number = 854\n    AND r1.driver_name = 'Paul di Resta';",
            "SELECT \n    (SUM(IIF(r1.raceId = 853, CAST(r1.fastestLapSpeed AS REAL), 0)) - \n     SUM(IIF(r1.raceId = 854, CAST(r1.fastestLapSpeed AS REAL), 0))) * 100.0 / \n    SUM(IIF(r1.raceId = 853, CAST(r1.fastestLapSpeed AS REAL), 0)) AS percentage_faster\nFROM results r1\nJOIN drivers d ON r1.driverId = d.driverId\nWHERE d.forename = 'Paul' \n  AND d.surname = 'di Resta'\n  AND r1.raceId IN (853, 854)"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(r.raceId = 853, CAST(r.fastestLapSpeed AS REAL), 0)) - \n     SUM(IIF(r.raceId = 854, CAST(r.fastestLapSpeed AS REAL), 0))) * 100.0 / \n    SUM(IIF(r.raceId = 853, CAST(r.fastestLapSpeed AS REAL), 0)) AS percentage_faster\nFROM \n    results r\nJOIN \n    drivers d ON r.driverId = d.driverId\nWHERE \n    d.forename = 'Paul' \n    AND d.surname = 'di Resta'\n    AND r.raceId IN (853, 854)"
        ],
        "amend_res": 1
    },
    "1132": {
        "db_id": "european_football_2",
        "question": "Please provide the names of top three football players who are over 180 cm tall in alphabetical order.",
        "ground_truth": "SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name LIMIT 3",
        "amends": [
            "Do reference the `player_name` column instead of `name` and use the correct table name `Player` instead of `football_players`. Do remove the explicit `ASC` direction in the `ORDER BY` clause instead of keeping it, as ascending order is the default. The amended query now correctly selects from the appropriate table with the proper column name while maintaining the same filtering, sorting, and limiting behavior."
        ],
        "rules": [
            "1) When the question asks for \"football players\": use the table \"Player\" instead of \"football_players\". 2) When the question asks for \"names\": use the column \"player_name\" instead of \"name\". 3) When ordering alphabetically: use ascending order without specifying direction explicitly as it is the default. 4) When filtering for players over 180 cm tall: use the condition height > 180. 5) When asking for top three results: limit the output to 3 rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM football_players WHERE height > 180 ORDER BY name ASC LIMIT 3;",
            "SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name LIMIT 3;"
        ],
        "amend_res": 1
    },
    "410": {
        "db_id": "card_games",
        "question": "Is there any card from Erica Yang artist in pauper format and available in paper? If so, indicate its ID.",
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper'",
        "amends": [
            "Do select `T1.id` instead of `card_id` and add table alias `T1` for the cards table. Do add `INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid` instead of querying only the cards table. Do reference `T2.format` instead of `format` to specify the legality table as the source for the format condition. Do keep the artist filter on `T1.artist` and availability filter on `T1.availability` but now properly scoped to their respective tables. The amended query now correctly joins the cards and legalities tables to ensure format legality is validated from the appropriate source, matching the intended behavior.",
            "Do use equality comparison `availability = 'paper'` instead of the pattern matching `availability LIKE '%paper%'` to ensure exact matching of the availability value rather than partial string matching. The amended query now matches RIGHT_SQL's behavior with precise filtering conditions."
        ],
        "rules": [
            "1) When answering about cards from a specific artist: use T1.artist with the exact literal 'Erica Yang' to filter cards. 2) When checking format legality: join cards table T1 with legalities table T2 using T1.uuid = T2.uuid to ensure inner matching. 3) When specifying format condition: use T2.format with the exact literal 'pauper' instead of the cards table format. 4) When checking availability: use T1.availability with the exact literal 'paper' from the cards table. 5) When selecting the card identifier: output T1.id instead of card_id as the result column.",
            "1) When the question asks about cards from artist 'Erica Yang': filter rows where T1.artist equals 'Erica Yang' exactly. 2) When the question specifies 'pauper format': filter rows where T2.format equals 'pauper' exactly. 3) When the question asks about cards 'available in paper': filter rows where T1.availability equals 'paper' exactly (not pattern matching). 4) When combining cards and legalities tables: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match). 5) When the question asks for card IDs: output T1.id as the result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_id FROM cards WHERE artist = 'Erica Yang' AND format = 'pauper' AND availability = 'paper';",
            "SELECT T1.id\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Erica Yang'\nAND T2.format = 'pauper'\nAND T1.availability LIKE '%paper%';",
            "SELECT T1.id\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Erica Yang'\nAND T2.format = 'pauper'\nAND T1.availability = 'paper'"
        ],
        "rule_sql": [
            "SELECT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Erica Yang'\nAND T2.format = 'pauper'\nAND T1.availability = 'paper'"
        ],
        "amend_res": 1
    },
    "661": {
        "db_id": "codebase_community",
        "question": "How old is the most influential user?",
        "ground_truth": "SELECT Age FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "amends": [
            "Do select `Age` instead of `MIN(age)` to return the actual age value rather than the minimum age. Do filter by `Reputation` instead of `influence_score` to use the correct column name for reputation-based filtering. Do reference `Reputation` in the subquery instead of `influence_score` to maintain consistency with the main query's filter condition. The amended query now correctly identifies and returns the age of the user with the maximum reputation score."
        ],
        "rules": [
            "1) When the question asks about \"most influential user\": use the column \"Reputation\" instead of \"influence_score\" to identify the user with maximum influence. 2) When returning the age of the most influential user: select the actual \"Age\" value rather than using MIN(age) aggregation. 3) When filtering for the user with maximum reputation: use the exact column name \"Reputation\" in both the main query and subquery for consistency."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(age) FROM users WHERE influence_score = (SELECT MAX(influence_score) FROM users);",
            "SELECT Age FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "rule_sql": [
            "SELECT Age FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users)"
        ],
        "amend_res": 1
    },
    "166": {
        "db_id": "financial",
        "question": "How many of the accounts are from Jesenik district?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A2 = 'Jesenik'",
        "amends": [
            "Do join `district AS T1` with `account AS T2` on `T1.district_id = T2.district_id` instead of querying `accounts` table alone. Do filter on `T1.A2 = 'Jesenik'` instead of `district = 'Jesenik'`. Do count `T2.account_id` instead of `COUNT(*)` to ensure accurate counting of account records. The amended query now correctly joins the district and account tables to count accounts from the specific district, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"accounts from Jesenik district\": join table \"district\" as T1 with table \"account\" as T2 on T1.district_id = T2.district_id to link district information with account records. 2) When filtering for \"Jesenik district\": use T1.A2 = 'Jesenik' to identify the correct district by name. 3) When counting accounts: count T2.account_id instead of all rows to ensure accurate counting of account records. 4) When combining tables for shared entities: perform an inner match where T1.district_id = T2.district_id to keep only accounts that have matching district information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE district = 'Jesenik';",
            "SELECT COUNT(T2.account_id) \nFROM district AS T1 \nJOIN account AS T2 ON T1.district_id = T2.district_id \nWHERE T1.A2 = 'Jesenik'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.account_id) \nFROM district AS T1 \nINNER JOIN account AS T2 ON T1.district_id = T2.district_id \nWHERE T1.A2 = 'Jesenik'"
        ],
        "amend_res": 1
    },
    "274": {
        "db_id": "toxicology",
        "question": "List the toxicology elements associated with molecule TR001.",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR001'",
        "amends": [
            "Do select `T.element` instead of `*` to return only the element column rather than all columns. Do specify the source table as `atom AS T` instead of `toxicology_elements` to query from the correct table. Do add `DISTINCT` instead of omitting it to eliminate duplicate element values. Do keep the filter `T.molecule_id = 'TR001'` in the WHERE clause with the correct table alias. The amended query now correctly returns distinct element values from the atom table for the specified molecule_id."
        ],
        "rules": [
            "1) When answering about \"toxicology elements associated with molecule TR001\": make sure the output order: T.element 2) When the question mentions \"toxicology elements\": \"toxicology elements\" actually means \"element in schema\" from table atom AS T 3) When the question asks for \"distinct toxicology elements\": compute the number of unique values of the exact token for T.element 4) When filtering for molecule TR001: use the exact literal 'TR001' with the condition T.molecule_id = 'TR001'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM toxicology_elements WHERE molecule_id = 'TR001';",
            "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR001'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR001' ORDER BY T.element"
        ],
        "amend_res": 1
    },
    "271": {
        "db_id": "toxicology",
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "ground_truth": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "amends": [
            "Do completely restructure the query to use a `SELECT` list with explicit columns `bond_id`, `atom_id2`, and `flag_have_CaCl` instead of a single `CASE` expression returning 'Yes'/'No'. Do use a `FROM` clause with `atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id` instead of multiple subqueries on `bond_elements`. Do move the filtering to a `WHERE` clause with `T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')` instead of checking for 'chlorine' and 'carbon' counts in subqueries. Do remove the `CASE` logic and aggregation entirely instead of keeping conditional logic based on subquery counts. The amended query now correctly joins atom and connected tables to find specific elements for the given bond_id, matching the RIGHT_SQL's behavior.",
            "Do select `T2.bond_id`, `T2.atom_id2`, and `T1.element AS flag_have_CaCl` instead of `bond_id`, `atom_id2`, and a complex CASE expression with COUNT. Do remove the entire `GROUP BY bond_id, atom_id2` clause instead of keeping it, as the aggregation is no longer needed. The amended query now correctly returns individual rows with element values rather than attempting to aggregate and flag combinations, matching the RIGHT_SQL's behavior of showing each qualifying atom's element directly."
        ],
        "rules": [
            "1) When answering about whether bond id TR001_1_8 has both chlorine and carbon elements: make sure the output order includes bond_id, atom_id2, and flag_have_CaCl. 2) When combining tables atom as T1 and connected as T2: link rows where T2.atom_id = T1.atom_id and keep only matching pairs (inner match). 3) When filtering for bond id TR001_1_8: use T2.bond_id = 'TR001_1_8' exactly as specified. 4) When checking for chlorine and carbon elements: use T1.element = 'c1' OR T1.element = 'c' instead of 'chlorine' and 'carbon' literals. 5) When handling element identifiers: do not use 'chlorine' and 'carbon' literals, use 'c1' and 'c' as shown in the schema mapping.",
            "1) When answering about bond id TR001_1_8 having both chlorine and carbon elements: select T2.bond_id, T2.atom_id2, and T1.element AS flag_have_CaCl instead of using aggregation with CASE and COUNT. 2) When the question asks about specific bond id TR001_1_8: filter using T2.bond_id = 'TR001_1_8' exactly as specified. 3) When checking for chlorine and carbon elements: use the exact element values from the schema without aggregation, returning individual rows with element values. 4) When combining tables atom and connected: link rows where T2.atom_id = T1.atom_id as shown in the schema foreign key relationship. 5) When the question mentions \"element of chlorine and carbon\": do not use GROUP BY clause as aggregation is not needed for this type of element existence check."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN (SELECT COUNT(*) FROM bond_elements WHERE bond_id = 'TR001_1_8' AND element = 'chlorine') > 0\n        AND (SELECT COUNT(*) FROM bond_elements WHERE bond_id = 'TR001_1_8' AND element = 'carbon') > 0\n        THEN 'Yes' \n        ELSE 'No' \n    END AS has_both_elements;",
            "SELECT bond_id, atom_id2, \n       CASE \n           WHEN COUNT(DISTINCT CASE WHEN element = 'c1' OR element = 'c' THEN element END) = 2 \n           THEN 'Yes' \n           ELSE 'No' \n       END AS flag_have_CaCl\nFROM atom AS T1 \nINNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id\nWHERE T2.bond_id = 'TR001_1_8' \n  AND (T1.element = 'c1' OR T1.element = 'c')\nGROUP BY bond_id, atom_id2",
            "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl\nFROM atom AS T1 \nINNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id\nWHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')"
        ],
        "rule_sql": [
            "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl\nFROM connected T2\nINNER JOIN atom T1 ON T2.atom_id = T1.atom_id\nWHERE T2.bond_id = 'TR001_1_8'\nAND (T1.element = 'c1' OR T1.element = 'c')"
        ],
        "amend_res": 1
    },
    "175": {
        "db_id": "financial",
        "question": "How many accounts have an owner disposition and request for a statement to be generated upon a transaction?",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK PO OBRATU'",
        "amends": [
            "Do select `COUNT(T1.account_id)` instead of `COUNT(*)` to count specific non-null values. Do join `disp AS T2` with `account AS T1` using `INNER JOIN` on `T1.account_id = T2.account_id` instead of querying only the `accounts` table. Do filter on `T2.type = 'OWNER'` instead of `disposition = 'owner'` to use the correct column and case. Do add `T1.frequency = 'POPLATEK PO OBRATU'` instead of omitting this condition. Do remove `statement_request = 'transaction'` instead of keeping this incorrect filter. The amended query now correctly counts account owners with the specified frequency by properly joining the account and disposition tables."
        ],
        "rules": [
            "1) When counting accounts: use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values. 2) When the question mentions \"owner disposition\": join disp AS T2 with account AS T1 using INNER JOIN on T1.account_id = T2.account_id to access disposition information. 3) When filtering for owner disposition: use T2.type = 'OWNER' with exact case instead of disposition = 'owner'. 4) When the question mentions \"request for a statement to be generated upon a transaction\": this corresponds to T1.frequency = 'POPLATEK PO OBRATU' in the schema. 5) When combining account and disposition tables: only keep rows where T1.account_id = T2.account_id (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE disposition = 'owner' AND statement_request = 'transaction';",
            "SELECT COUNT(T1.account_id) \nFROM account AS T1\nINNER JOIN disp AS T2 ON T1.account_id = T2.account_id\nWHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK PO OBRATU'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM account AS T1\nINNER JOIN disp AS T2 ON T1.account_id = T2.account_id\nWHERE T2.type = 'OWNER' \nAND T1.frequency = 'POPLATEK PO OBRATU'"
        ],
        "amend_res": 1
    },
    "1532": {
        "db_id": "debit_card_specializing",
        "question": "Which country had the gas station that sold the most expensive product id No.2 for one unit?",
        "evidence": "",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.ProductID = 2 ORDER BY T1.Price DESC LIMIT 1",
        "amends": [
            "Do join `gasstations` as `T2` instead of querying `gas_stations` alone. Do reference `T2.Country` instead of `country`. Do use `INNER JOIN` on `T1.GasStationID = T2.GasStationID` instead of no join condition. Do filter on `T1.ProductID = 2` instead of `product_id = 2`. Do order by `T1.Price DESC` instead of `price_per_unit DESC`. The amended query now correctly joins transaction and gas station data to find the country with the highest price for product 2, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"which country had the gas station that sold the most expensive product id No.2\": make sure the output order: T2.Country. 2) When the question mentions \"gas station\": \"gas station\" actually means \"T2\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.GasStationID = T2.GasStationID; keep only matching pairs (inner match). 4) When the question mentions \"product id No.2\": \"product id No.2\" actually means \"T1.ProductID = 2\" in schema. 5) When the question mentions \"most expensive\": rank rows by T1.Price in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM gas_stations WHERE product_id = 2 ORDER BY price_per_unit DESC LIMIT 1;",
            "SELECT T2.Country\nFROM transactions_1k T1\nINNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.ProductID = 2\nORDER BY T1.Price DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Country\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.ProductID = 2\nORDER BY T1.Price DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1369": {
        "db_id": "student_club",
        "question": "Which event has the highest budget amount?",
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id ORDER BY T1.amount DESC LIMIT 1",
        "amends": [
            "Do select `T2.event_name` from the `event` table instead of `event_name` from the `events` table. Do join `budget AS T1` with `event AS T2` using `INNER JOIN` on `T1.link_to_event = T2.event_id` instead of querying a single table. Do order by `T1.amount DESC` instead of `budget_amount DESC` to reference the correct column from the joined budget table. The amended query now correctly retrieves event names by joining budget and event tables and ordering by the actual budget amount."
        ],
        "rules": [
            "1) When answering about \"which event has the highest budget amount\": make sure the output order: T2.event_name. 2) When the question mentions \"event\": \"event\" actually means \"event AS T2\" in schema. 3) When the question mentions \"highest budget amount\": \"budget amount\" actually means \"T1.amount\" from budget table. 4) When combining budget AS T1 and event AS T2 for shared entities: link rows where T1.link_to_event = T2.event_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"highest\": rank rows by T1.amount in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name FROM events ORDER BY budget_amount DESC LIMIT 1;",
            "SELECT T2.event_name \nFROM budget AS T1 \nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id \nORDER BY T1.amount DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.event_name\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nORDER BY T1.amount DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1250": {
        "db_id": "thrombosis_prediction",
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "amends": [
            "Do select `DISTINCT T1.ID` instead of `patient_id` without distinct. Do use `INNER JOIN` on `Laboratory AS T2` with `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.U-PRO > 0 AND T2.U-PRO < 30` instead of `proteinuria_level = 'normal'`. Do keep `T1.Diagnosis = 'SLE'` but reference it through the joined table alias instead of directly from the base table. The amended query now correctly identifies SLE patients with specific proteinuria laboratory values rather than relying on a categorical 'normal' designation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about patients with normal proteinuria level and SLE diagnosis: select DISTINCT T1.ID instead of patient_id without distinct. 2) When combining patient and laboratory data: use INNER JOIN on Laboratory AS T2 with T1.ID = T2.ID instead of querying only the patients table. 3) When filtering for normal proteinuria level: use T2.U-PRO > 0 AND T2.U-PRO < 30 instead of proteinuria_level = 'normal'. 4) When filtering for SLE diagnosis: keep T1.Diagnosis = 'SLE' but reference it through the joined table alias instead of directly from the base table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE proteinuria_level = 'normal' AND diagnosis = 'SLE';",
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.\"U-PRO\" > 0 AND T2.\"U-PRO\" < 30\nAND T1.Diagnosis = 'SLE'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.\"U-PRO\" > 0 AND T2.\"U-PRO\" < 30\nAND T1.Diagnosis = 'SLE'"
        ],
        "amend_res": 1
    },
    "1279": {
        "db_id": "thrombosis_prediction",
        "question": "What is the percentage of patient who has a abnormal level of glutamic oxaloacetic transaminase level, yet he or she is diagnosed with SLE?",
        "ground_truth": "SELECT COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`GOT` >= 60",
        "amends": [
            "Do use `COUNT(T1.ID)` in both numerator and denominator instead of `COUNT(CASE WHEN diagnosis = 'SLE' THEN 1 END)` for the denominator. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the patients table. Do add `WHERE T2.\"GOT\" >= 60` filter instead of checking `glutamic_oxaloacetic_transaminase_level != 'normal'`. Do change the diagnosis condition to `T1.Diagnosis LIKE '%SLE%'` instead of exact match `diagnosis = 'SLE'`. Do remove the percentage calculation `* 100.0` and use simple division instead. Do reference tables with aliases `T1` and `T2` instead of direct column references. The amended query now correctly calculates the proportion of SLE patients with elevated GOT levels by joining laboratory data and using precise numeric threshold comparison.",
            "Do move the `T1.Diagnosis LIKE '%SLE%'` filter from the WHERE clause to the CASE expression in the SELECT list instead of keeping it in WHERE. Do move the `T2.GOT >= 60` filter from the CASE expression to the WHERE clause instead of having it in SELECT. Do change the COUNT expression to count `T1.ID` with conditional logic instead of using a CASE that returns 1. Do remove the multiplication by 1.0 for floating-point conversion instead of keeping explicit type casting. The amended query now correctly calculates the proportion of SLE patients with elevated GOT levels by properly placing the diagnosis filter in the conditional counting and the lab value filter in the WHERE clause, matching the RIGHT_SQL's behavior.",
            "Do use `ELSE 0` in the CASE expression instead of omitting it, which ensures proper counting when the condition is not met. Do remove the multiplication by `1.0` for floating-point division instead of keeping it, as standard division between integers already produces the correct decimal result. Do use backticks around `GOT` column name instead of unquoted syntax to handle potential reserved keyword conflicts. The amended query now correctly calculates the proportion of SLE diagnoses among patients with elevated GOT levels, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating percentages for patient conditions: use simple division instead of multiplying by 100.0. 2) When joining patient and laboratory data: use INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to combine tables. 3) When counting patients: use COUNT(T1.ID) as the counting key instead of CASE statements. 4) When filtering for SLE diagnosis: use T1.Diagnosis LIKE '%SLE%' instead of exact match 'SLE'. 5) When identifying abnormal glutamic oxaloacetic transaminase levels: use T2.\"GOT\" >= 60 instead of checking for 'normal' values. 6) When referencing columns across joined tables: use table aliases T1 and T2 instead of direct column references.",
            "1) When the question asks for percentage of patients with abnormal GOT levels who are diagnosed with SLE: use conditional counting where T1.Diagnosis contains 'SLE' and T2.\"GOT\" >= 60. 2) When filtering for abnormal glutamic oxaloacetic transaminase levels: use T2.\"GOT\" >= 60 as the threshold condition. 3) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 4) When calculating percentage: compute (count of patients meeting both conditions) divided by (count of all SLE patients) without explicit type casting. 5) When handling SLE diagnosis: use T1.Diagnosis LIKE '%SLE%' as the diagnostic condition.",
            "1) When the question asks for percentage of patients with abnormal GOT levels diagnosed with SLE: calculate the ratio of patients with SLE diagnosis among those with GOT \u2265 60 using exact column names and literals. 2) When counting patients with specific conditions: use CASE expressions with ELSE 0 to ensure proper counting when conditions are not met. 3) When performing division between counts: use standard integer division without multiplication by 1.0 to get correct decimal results. 4) When referencing the GOT column: use backticks around `GOT` to handle potential reserved keyword conflicts. 5) When determining abnormal glutamic oxaloacetic transaminase levels: use the threshold value of 60 for the `GOT` column as specified in the condition."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN diagnosis = 'SLE' AND glutamic_oxaloacetic_transaminase_level != 'normal' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN diagnosis = 'SLE' THEN 1 END)) AS percentage\nFROM patients;",
            "SELECT \n    COUNT(CASE WHEN T2.\"GOT\" >= 60 THEN 1 END) * 1.0 / COUNT(T1.ID) \nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T1.Diagnosis LIKE '%SLE%'",
            "SELECT \n    COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID END) * 1.0 / COUNT(T1.ID)\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.GOT >= 60",
            "SELECT \n    COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN 1 ELSE 0 END) * 1.0 / COUNT(T1.ID)\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.\"GOT\" >= 60"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN T2.GOT >= 60 THEN T1.ID END) * 1.0 / COUNT(T1.ID)) \nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T1.Diagnosis LIKE '%SLE%'"
        ],
        "amend_res": 1
    },
    "1379": {
        "db_id": "student_club",
        "question": "How many meeting events were held in 2020?",
        "ground_truth": "SELECT COUNT(event_id) FROM event WHERE type = 'Meeting' AND SUBSTR(event_date, 1, 4) = '2020'",
        "amends": [
            "Do count `event_id` instead of `*` to exclude null values. Do reference table `event` instead of `events` to use the correct table name. Do filter on `type = 'Meeting'` instead of `event_type = 'meeting'` to match the correct column name and case-sensitive value. Do use `SUBSTR(event_date, 1, 4) = '2020'` instead of `year = 2020` to extract the year from a date string column rather than using a separate year column. The amended query now correctly counts non-null event IDs from the event table for meetings occurring in 2020."
        ],
        "rules": [
            "1) When counting events: count non-null values of \"event_id\" instead of all rows to exclude null values. 2) When referencing the events table: use table name \"event\" instead of \"events\" to match the correct schema. 3) When filtering by event type: use column \"type\" with exact literal value 'Meeting' (case-sensitive) instead of \"event_type\" with 'meeting'. 4) When filtering by year 2020: extract year from \"event_date\" column using SUBSTR(\"event_date\", 1, 4) = '2020' instead of using a separate \"year\" column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE event_type = 'meeting' AND year = 2020;",
            "SELECT COUNT(event_id) FROM event WHERE type = 'Meeting' AND SUBSTR(event_date, 1, 4) = '2020';"
        ],
        "rule_sql": [
            "SELECT COUNT(event_id) FROM event WHERE type = 'Meeting' AND SUBSTR(event_date, 1, 4) = '2020';"
        ],
        "amend_res": 1
    },
    "1181": {
        "db_id": "thrombosis_prediction",
        "question": "For the patient who got the laboratory test of uric acid level as 8.4 on 1991-10-21, how old was he/she at that time?",
        "ground_truth": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UA = 8.4 AND T2.Date = '1991-10-21'",
        "amends": [
            "Do calculate age using `STRFTIME('%Y', Date) - STRFTIME('%Y', Birthday)` instead of `1991 - YEAR(birth_date)` to properly handle year differences. Do use table aliases `T1` and `T2` instead of `p` and `lt` for consistency. Do join on `T1.ID = T2.ID` instead of `p.patient_id = lt.patient_id` to use the correct join condition. Do filter on `T2.UA = 8.4` instead of `lt.test_name = 'uric acid' AND lt.test_value = 8.4` to directly reference the uric acid value column. Do keep the date filter `T2.Date = '1991-10-21'` instead of `lt.test_date = '1991-10-21'` with the correct column name. The amended query now correctly calculates age differences and uses proper column references to match the intended behavior."
        ],
        "rules": [
            "1) When calculating age from birth date and test date: use STRFTIME('%Y', Date) - STRFTIME('%Y', Birthday) instead of simple year subtraction to properly handle year differences. 2) When joining patients and laboratory_tests tables: use T1.ID = T2.ID as the join condition instead of patient_id columns. 3) When filtering for uric acid test with value 8.4: use T2.UA = 8.4 instead of filtering by test_name and test_value separately. 4) When filtering for test date 1991-10-21: use T2.Date = '1991-10-21' with exact date format. 5) When using table aliases: use T1 for patients table and T2 for laboratory_tests table consistently."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (1991 - YEAR(birth_date)) AS age_at_test FROM patients p JOIN laboratory_tests lt ON p.patient_id = lt.patient_id WHERE lt.test_name = 'uric acid' AND lt.test_value = 8.4 AND lt.test_date = '1991-10-21';",
            "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) AS age\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.UA = 8.4 AND T2.Date = '1991-10-21'"
        ],
        "rule_sql": [
            "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) AS Age\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.UA = 8.4 AND T2.Date = '1991-10-21'"
        ],
        "amend_res": 1
    },
    "176": {
        "db_id": "financial",
        "question": "What is the amount of debt that client number 992 has, and how is this client doing with payments?",
        "evidence": "",
        "ground_truth": "SELECT T4.amount, T4.status FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 on T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 992",
        "amends": [
            "Do select `T4.amount` and `T4.status` instead of aggregating `SUM(amount)` and `COUNT(*)`. Do join from `client AS T1` instead of querying only `payments`. Do add `INNER JOIN disp AS T2` on `T1.client_id = T2.client_id` instead of omitting this table. Do add `INNER JOIN account AS T3` on `T2.account_id = T3.account_id` instead of omitting this table. Do add `INNER JOIN loan AS T4` on `T3.account_id = T4.account_id` instead of omitting this table. Do filter on `T1.client_id = 992` instead of `client_id = 992` to reference the joined table. Do remove the aggregation functions and aliases `total_debt` and `payment_count` instead of keeping them. The amended query now correctly retrieves individual loan details through proper table relationships instead of attempting to aggregate payments data."
        ],
        "rules": [
            "1) When answering about client debt and payment status: select T4.amount and T4.status instead of aggregating with SUM and COUNT functions. 2) When querying for client number 992: filter using T1.client_id = 992 instead of just client_id = 992 to reference the correct joined table. 3) When combining client and related tables: link T1 (client) to T2 (disp) using T1.client_id = T2.client_id. 4) When combining disp and account tables: link T2 to T3 (account) using T2.account_id = T3.account_id. 5) When combining account and loan tables: link T3 to T4 (loan) using T3.account_id = T4.account_id. 6) When retrieving loan details: use inner joins for all table combinations to ensure only matching pairs are included."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) AS total_debt, COUNT(*) AS payment_count FROM payments WHERE client_id = 992",
            "SELECT T4.amount, T4.status\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN account AS T3 ON T2.account_id = T3.account_id\nINNER JOIN loan AS T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 992"
        ],
        "rule_sql": [
            "SELECT T4.amount, T4.status\nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN account T3 ON T2.account_id = T3.account_id\nINNER JOIN loan T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 992;"
        ],
        "amend_res": 1
    },
    "358": {
        "db_id": "card_games",
        "question": "What is the border color of card \"Ancestor's Chosen\"?",
        "ground_truth": "SELECT DISTINCT borderColor FROM cards WHERE name = 'Ancestor''s Chosen'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do reference column `borderColor` instead of `border_color` to match the correct column name. Do use double single quotes `''` instead of backslash escaping `\\'` for proper SQL string literal escaping. The amended query now correctly returns unique border colors for the specified card name."
        ],
        "rules": [
            "1) When the question asks for \"border color\" of a specific card: use the exact column name \"borderColor\" from the cards table. 2) When filtering by card name with value \"Ancestor's Chosen\": use the exact literal 'Ancestor''s Chosen' with double single quotes for proper SQL string escaping. 3) When selecting from the cards table: use DISTINCT to eliminate duplicate rows and return unique values only."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT border_color FROM cards WHERE name = 'Ancestor\\'s Chosen';",
            "SELECT DISTINCT borderColor FROM cards WHERE name = 'Ancestor''s Chosen';"
        ],
        "rule_sql": [
            "SELECT DISTINCT borderColor FROM cards WHERE name = ''Ancestor''s Chosen'';",
            "SELECT DISTINCT borderColor FROM cards WHERE name = 'Ancestor''s Chosen';"
        ],
        "amend_res": 1
    },
    "908": {
        "db_id": "formula_1",
        "question": "What is the most laps f1 races had? Name the race, year and circuit location where the races with most laps was hosted.",
        "evidence": "",
        "ground_truth": "SELECT T3.lap, T2.name, T2.year, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId INNER JOIN lapTimes AS T3 ON T3.raceId = T2.raceId ORDER BY T3.lap DESC LIMIT 1",
        "amends": [
            "Do select `T3.lap`, `T2.name`, `T2.year`, `T1.location` instead of `race_name`, `year`, `circuit_location`, `MAX(laps)`. Do use `circuits AS T1` joined to `races AS T2` on `T1.circuitId = T2.circuitId` instead of only `f1_races`. Do add `lapTimes AS T3` joined on `T3.raceId = T2.raceId` instead of omitting it. Do remove `GROUP BY` and aggregation instead of keeping them. Do order by `T3.lap DESC` instead of `max_laps DESC`. The amended query now correctly retrieves the maximum lap from detailed race data instead of aggregating laps per race."
        ],
        "rules": [
            "1) When answering about \"most laps f1 races had\": make sure the output order: T3.lap, T2.name, T2.year, T1.location\n2) When the question mentions \"race\": \"race\" actually means \"T2.name in schema\"\n3) When the question mentions \"year\": \"year\" actually means \"T2.year in schema\"\n4) When the question mentions \"circuit location\": \"circuit location\" actually means \"T1.location in schema\"\n5) When combining circuits AS T1 and races AS T2: link rows where T1.circuitId = T2.circuitId and keep only matching pairs (inner match)\n6) When combining races AS T2 and lapTimes AS T3: link rows where T3.raceId = T2.raceId and keep only matching pairs (inner match)\n7) When the question asks for \"most laps\": rank rows by T3.lap in descending order and keep the first 1 row\n8) When handling the maximum lap value: do not use GROUP BY or aggregation functions, instead retrieve the actual T3.lap value directly from the detailed data"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name, year, circuit_location, MAX(laps) as max_laps \nFROM f1_races \nGROUP BY race_name, year, circuit_location \nORDER BY max_laps DESC \nLIMIT 1;",
            "SELECT T3.lap, T2.name, T2.year, T1.location \nFROM circuits AS T1 \nJOIN races AS T2 ON T1.circuitId = T2.circuitId \nJOIN lapTimes AS T3 ON T3.raceId = T2.raceId \nORDER BY T3.lap DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.lap, T2.name, T2.year, T1.location\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T1.circuitId = T2.circuitId\nINNER JOIN lapTimes AS T3 ON T3.raceId = T2.raceId\nORDER BY T3.lap DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "172": {
        "db_id": "financial",
        "question": "How many owner and disponent dispositions are there from account number 1 to account number 10?",
        "evidence": "",
        "ground_truth": "SELECT SUM(type = 'OWNER') , SUM(type = 'DISPONENT') FROM disp WHERE account_id BETWEEN 1 AND 10",
        "amends": [
            "Do use `SUM(type = 'OWNER')` and `SUM(type = 'DISPONENT')` instead of `COUNT(*)` to count specific disposition types separately. Do reference table `disp` instead of `dispositions` as the source table. Do use `account_id BETWEEN 1 AND 10` instead of `account_id = 1 AND to_account_id = 10` to filter accounts within a range rather than using multiple conditions. Do remove the `IN ('OWNER', 'DISPONENT')` filter since the SUM conditions handle the type filtering implicitly. The amended query now correctly counts OWNER and DISPONENT types separately for accounts in the specified range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting specific disposition types 'OWNER' and 'DISPONENT': use SUM(type = 'OWNER') and SUM(type = 'DISPONENT') to count each type separately instead of COUNT(*). 2) When referencing the dispositions table: use table name \"disp\" instead of \"dispositions\". 3) When filtering account numbers from 1 to 10: use account_id BETWEEN 1 AND 10 to include all accounts in the range rather than multiple equality conditions. 4) When handling disposition type filtering: remove explicit IN ('OWNER', 'DISPONENT') filter since the SUM conditions handle type filtering implicitly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dispositions WHERE account_id = 1 AND disposition_type IN ('OWNER', 'DISPONENT') AND to_account_id = 10;",
            "SELECT \n    SUM(type = 'OWNER') AS owner_count,\n    SUM(type = 'DISPONENT') AS disponent_count\nFROM disp\nWHERE account_id BETWEEN 1 AND 10"
        ],
        "rule_sql": [
            "SELECT \n    SUM(type = 'OWNER') AS owner_count,\n    SUM(type = 'DISPONENT') AS disponent_count\nFROM \n    disp\nWHERE \n    account_id BETWEEN 1 AND 10;"
        ],
        "amend_res": 1
    },
    "630": {
        "db_id": "codebase_community",
        "question": "What is the name of tags used by John Salvatier's?",
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'John Salvatier'",
        "amends": [
            "Do use `INNER JOIN` to connect `users`, `postHistory`, and `posts` tables instead of querying only the `tags` table with a subquery. Do select `T3.Tags` from the joined posts table instead of `tag_name` from the isolated tags table. Do join on `T1.Id = T2.UserId` and `T2.PostId = T3.Id` instead of using a subquery with `user_id = (SELECT id FROM users WHERE name = 'John Salvatier')`. Do filter on `T1.DisplayName = 'John Salvatier'` instead of the name field in the subquery. The amended query now correctly retrieves tags from posts created by the user through their post history instead of attempting to directly query a tags table that may not contain the relevant user association, matching the RIGHT_SQL's behavior.",
            "Do remove `DISTINCT` instead of keeping it and do remove `T3.Tags IS NOT NULL` filter instead of including it, while maintaining the same `SELECT T3.Tags` column selection, `INNER JOIN` structures with `T1.Id = T2.UserId` and `T2.PostId = T3.Id` conditions, and `T1.DisplayName = 'John Salvatier'` WHERE filter. The amended query now matches RIGHT_SQL's behavior by eliminating unnecessary distinct filtering and the redundant null check on Tags."
        ],
        "rules": [
            "1) When answering about \"tags used by John Salvatier's\": make sure the output order: T3.Tags\n2) When the question mentions \"John Salvatier's\": \"John Salvatier's\" actually means \"T1.DisplayName = 'John Salvatier'\" in schema\n3) When combining T1 (users), T2 (postHistory), and T3 (posts) for shared entities: link rows where T1.Id = T2.UserId and T2.PostId = T3.Id; keep only matching pairs (inner match)\n4) When selecting tags: use T3.Tags from the posts table instead of tag_name from a tags table",
            "1) When answering about \"tags used by John Salvatier's\": make sure the output order: T3.Tags\n2) When the question mentions \"John Salvatier's\": \"John Salvatier's\" actually means \"T1.DisplayName = 'John Salvatier'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.UserId exactly as shown in the amends; keep only matching pairs (inner match)\n4) When combining T2 and T3 for shared entities: link rows where T2.PostId = T3.Id exactly as shown in the amends; keep only matching pairs (inner match)\n5) When selecting tags from posts: do not include DISTINCT filtering as it is unnecessary for this query\n6) When checking for tags: do not include T3.Tags IS NOT NULL filter as it is redundant for this query"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT tag_name FROM tags WHERE user_id = (SELECT id FROM users WHERE name = 'John Salvatier')",
            "SELECT DISTINCT T3.Tags \nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nWHERE T1.DisplayName = 'John Salvatier' AND T3.Tags IS NOT NULL",
            "SELECT T3.Tags\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nWHERE T1.DisplayName = 'John Salvatier'"
        ],
        "rule_sql": [
            "SELECT T3.Tags \nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nWHERE T1.DisplayName = 'John Salvatier'"
        ],
        "amend_res": 1
    },
    "51": {
        "db_id": "california_schools",
        "question": "In which mailing street address can you find the school that has the lowest average score in reading? Also give the school's name.",
        "evidence": "",
        "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "amends": [
            "Do select `T2.MailStreet` and `T2.School` instead of `mailing_street_address` and `school_name`. Do use `satscores AS T1 INNER JOIN schools AS T2` instead of only `FROM schools`. Do add join condition `ON T1.cds = T2.CDSCode` instead of omitting it. Do add WHERE filter `T1.AvgScrRead IS NOT NULL` instead of omitting it. Do order by `T1.AvgScrRead ASC` instead of `reading_score ASC`. The amended query now correctly joins the tables, filters out null reading scores, and uses the proper column names and ordering to match the intended behavior."
        ],
        "rules": [
            "1) When answering about school addresses and reading scores: combine tables satscores as T1 and schools as T2 using inner match where T1.cds equals T2.CDSCode. 2) When filtering for valid reading scores: include only rows where T1.AvgScrRead is not null. 3) When ordering by reading performance: sort rows by T1.AvgScrRead in ascending order to find the lowest score. 4) When selecting output columns: return T2.MailStreet for mailing street address and T2.School for school name. 5) When limiting results: return only the first row after ordering to get the single school with the lowest average reading score."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT mailing_street_address, school_name FROM schools ORDER BY reading_score ASC LIMIT 1;",
            "SELECT T2.MailStreet, T2.School\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.MailStreet, T2.School\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "451": {
        "db_id": "card_games",
        "question": "How many cards available in paper have a positive starting maximum hand size?",
        "ground_truth": "SELECT SUM(CASE WHEN availability = 'paper' AND hAND = '3' THEN 1 ELSE 0 END) FROM cards",
        "amends": [
            "Do use `SUM(CASE WHEN availability = 'paper' AND hand = '3' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to conditionally count only specific records. Do add the condition `hand = '3'` instead of omitting it, and do remove the filter `starting_max_hand_size > 0` instead of keeping it. The amended query now correctly counts only cards where availability is 'paper' and hand equals '3', matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cards with availability 'paper': use the exact literal 'paper' with lowercase letters and no quotes in the condition. 2) When the question mentions \"positive starting maximum hand size\": this actually means hand = '3' in the schema. 3) When counting cards that meet specific conditions: use SUM(CASE WHEN availability = 'paper' AND hand = '3' THEN 1 ELSE 0 END) to conditionally count only records matching both criteria. 4) When handling the hand condition: use the exact literal '3' with single quotes as shown in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE starting_max_hand_size > 0 AND availability = 'paper';",
            "SELECT SUM(CASE WHEN availability = 'paper' AND hand = '3' THEN 1 ELSE 0 END) AS count FROM cards;"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN availability = 'paper' AND hand = '3' THEN 1 ELSE 0 END) AS count_cards FROM cards;"
        ],
        "amend_res": 1
    },
    "966": {
        "db_id": "formula_1",
        "question": "How many driver participated in race ID number 18?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18",
        "amends": [
            "Do select `COUNT(driverId)` from the `driverStandings` table instead of `COUNT(*)` from the `drivers` table. Do use the correct column name `raceId` instead of `race_id` to filter the results. The amended query now correctly counts distinct drivers from the driver standings table for race 18, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many drivers participated in race ID number 18\": make sure the output order: COUNT(driverId) from driverStandings table. 2) When the question mentions \"race ID number 18\": \"race ID number 18\" actually means \"raceId = 18\" in schema. 3) When counting drivers: use driverId as the counting key from driverStandings table, not COUNT(*) from drivers table. 4) When filtering by race: use the exact column name raceId with value 18, not race_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE race_id = 18;",
            "SELECT COUNT(DISTINCT driverId) FROM driverStandings WHERE raceId = 18"
        ],
        "rule_sql": [
            "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18;"
        ],
        "amend_res": 1
    },
    "482": {
        "db_id": "card_games",
        "question": "What's the German type of the card \"Ancestor's Chosen\"?",
        "ground_truth": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German'",
        "amends": [
            "Do select `T1.type` instead of `german_type` and add `DISTINCT` instead of omitting it. Do join `foreign_data AS T2` with `INNER JOIN` on `T2.uuid = T1.uuid` instead of querying only the `cards` table. Do add filter `T2.language = 'German'` instead of omitting it, while keeping the `T1.name` filter instead of the original `name` condition. The amended query now correctly retrieves distinct German card types by joining with the language-specific foreign data table."
        ],
        "rules": [
            "1) When the question asks about German card types: join the cards table (T1) with the foreign_data table (T2) using an inner match where T2.uuid = T1.uuid. 2) When filtering for German language data: add condition T2.language = 'German' exactly as specified. 3) When selecting card type information for a specific card name: use T1.type instead of german_type and apply DISTINCT to eliminate duplicates. 4) When filtering by card name: use T1.name = 'Ancestor\\'s Chosen' with exact spelling and punctuation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT german_type FROM cards WHERE name = 'Ancestor\\'s Chosen';",
            "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.type FROM cards T1 INNER JOIN foreign_data T2 ON T2.uuid = T1.uuid WHERE T2.language = 'German' AND T1.name = 'Ancestor''s Chosen'"
        ],
        "amend_res": 1
    },
    "74": {
        "db_id": "california_schools",
        "question": "What is the lowest grade for the District Special Education Consortia School with National Center for Educational Statistics school district identification number of 0613360?",
        "ground_truth": "SELECT MIN(T1.`Low Grade`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.NCESDist = '0613360' AND T2.EdOpsCode = 'SPECON'",
        "amends": [
            "Do use `MIN(T1.`Low Grade`)` instead of `MAX(grade)` for the aggregate function and column selection. Do join `frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do filter on `T2.NCESDist = '0613360'` instead of `district_id = '0613360'` for the district identifier. Do use `T2.EdOpsCode = 'SPECON'` instead of `name = 'District Special Education Consortia School'` for the school type condition. The amended query now correctly joins the appropriate tables and uses the proper identifiers and filters to match the intended behavior."
        ],
        "rules": [
            "1) When answering about the lowest grade for a specific school type and district: use MIN(T1.\"Low Grade\") instead of MAX(grade) for the aggregate function and column selection. 2) When combining school data with FRPM data: join frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode to access the required information. 3) When filtering by National Center for Educational Statistics school district identification number: use T2.NCESDist = '0613360' instead of district_id = '0613360'. 4) When identifying District Special Education Consortia School type: use T2.EdOpsCode = 'SPECON' instead of name = 'District Special Education Consortia School'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(grade) FROM schools WHERE district_id = '0613360' AND name = 'District Special Education Consortia School';",
            "SELECT MIN(T1.\"Low Grade\") \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.NCESDist = '0613360' \nAND T2.EdOpsCode = 'SPECON'"
        ],
        "rule_sql": [
            "SELECT MIN(T1.\"Low Grade\") \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.NCESDist = '0613360' \nAND T2.EdOpsCode = 'SPECON'"
        ],
        "amend_res": 1
    },
    "1297": {
        "db_id": "thrombosis_prediction",
        "question": "For the patients whose total cholesterol is higher than normal, how many of them have a negative measure of degree of coagulation?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-CHO` >= 250 AND T3.KCT = '-'",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific columns instead of `COUNT(*)` from all rows. Do add `INNER JOIN Laboratory AS T2` and `INNER JOIN Examination AS T3` with proper join conditions `ON T1.ID = T2.ID` and `ON T1.ID = T3.ID` instead of querying only the `patients` table. Do change the filter to `T2.\"T-CHO\" >= 250` instead of `total_cholesterol > 200` and add `T3.KCT = '-'` instead of `coagulation_degree < 0`. Do use proper table aliases `T1`, `T2`, and `T3` instead of direct table references. The amended query now correctly joins multiple tables and uses the appropriate column names and filter conditions to match the intended behavior."
        ],
        "rules": [
            "1) When answering about patients with high total cholesterol: use \"T2.\\\"T-CHO\\\" >= 250\" instead of \"total_cholesterol > 200\" to identify patients with higher than normal cholesterol levels. 2) When answering about negative coagulation measures: use \"T3.KCT = '-'\" instead of \"coagulation_degree < 0\" to identify patients with negative coagulation results. 3) When combining patient data with laboratory and examination information: perform inner joins where \"T1.ID = T2.ID\" to link patients with laboratory results and \"T1.ID = T3.ID\" to link patients with examination results. 4) When counting patients: use \"COUNT(T1.ID)\" instead of \"COUNT(*)\" to count distinct patient IDs. 5) When referencing tables: use aliases T1 for patients table, T2 for Laboratory table, and T3 for Examination table as specified in the schema relationships."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients \nWHERE total_cholesterol > 200 \nAND coagulation_degree < 0;",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.\"T-CHO\" >= 250 \nAND T3.KCT = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-CHO\" >= 250 \nAND T3.KCT = '-'"
        ],
        "amend_res": 1
    },
    "450": {
        "db_id": "card_games",
        "question": "Of all the cards that are designed by Aaron Miller, how many of them are incredibly powerful?",
        "ground_truth": "SELECT SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) FROM cards",
        "amends": [
            "Do use `SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count specific conditions rather than all rows. Do filter on `artist = 'Aaron Miller'` instead of `designer = 'Aaron Miller'` to reference the correct column. Do add `cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL` conditions instead of omitting them to ensure both ID fields are present. Do remove the `power_level = 'incredibly powerful'` filter instead of keeping it as it's not part of the intended logic. The amended query now correctly counts cards by Aaron Miller that have both cardKingdomFoilId and cardKingdomId values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"designed by Aaron Miller\": \"designed by\" actually means \"artist = 'Aaron Miller'\" in the schema. 2) When counting cards that meet specific conditions: use SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) instead of COUNT(*) to count only rows satisfying all specified conditions. 3) When checking for card availability: ensure both cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL conditions are included to verify both ID fields are present. 4) When the question asks about \"incredibly powerful\" cards: do not include power_level = 'incredibly powerful' filter as this condition is not part of the intended logic."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE designer = 'Aaron Miller' AND power_level = 'incredibly powerful';",
            "SELECT SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS count_incredibly_powerful_cards FROM cards;"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS count_incredibly_powerful_cards FROM cards;"
        ],
        "amend_res": 1
    },
    "500": {
        "db_id": "card_games",
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "ground_truth": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "amends": [
            "Do select `T2.translation` instead of `japanese_name` from the result set. Do join `cards AS T1` and `set_translations AS T2` with an `INNER JOIN` on `T2.setCode = T1.setCode` instead of querying only the `sets` table. Do add filter conditions `T1.name = 'Fellwar Stone'`, `T2.language = 'Japanese'`, and `T2.translation IS NOT NULL` instead of only filtering by `card_name = 'Fellwar Stone'`. The amended query now correctly retrieves Japanese translations from the appropriate translation table with proper join conditions and filtering."
        ],
        "rules": [
            "1) When answering about \"Japanese name of the set containing card 'Fellwar Stone'\": make sure the output order: T2.translation. 2) When the question mentions \"Japanese name\": \"Japanese name\" actually means \"T2.translation in schema where T2.language = 'Japanese'\". 3) When combining T1 and T2 for shared entities: link rows where T2.setCode = T1.setCode exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for card \"Fellwar Stone\": use exact literal T1.name = 'Fellwar Stone' with case and spacing preserved. 5) When retrieving translations: ensure T2.translation IS NOT NULL to exclude missing translations."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT japanese_name FROM sets WHERE card_name = 'Fellwar Stone';",
            "SELECT T2.translation\nFROM cards AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode\nWHERE T1.name = 'Fellwar Stone'\nAND T2.language = 'Japanese'\nAND T2.translation IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT T2.translation\nFROM cards T1\nJOIN set_translations T2 ON T1.setCode = T2.setCode\nWHERE T1.name = 'Fellwar Stone'\nAND T2.language = 'Japanese'\nAND T2.translation IS NOT NULL"
        ],
        "amend_res": 1
    },
    "333": {
        "db_id": "toxicology",
        "question": "In the molecule TR008, how many carbons are present?",
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR008' AND T.element = 'c'",
        "amends": [
            "Do use the table alias `T` consistently instead of omitting it. Do reference the specific column `T.atom_id` in the COUNT function instead of using `COUNT(*)`. Do use the correct table name `atom` instead of `atoms`. Do use the lowercase value `'c'` for the element filter instead of `'carbon'`. The amended query now correctly counts only non-null atom_id values for the specified molecule and element, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many carbons are present in molecule TR008\": use the table alias T consistently for the atom table. 2) When counting atoms: count using the canonical key T.atom_id instead of counting all columns. 3) When filtering by molecule: use the exact literal 'TR008' for T.molecule_id. 4) When filtering by element type: use the exact lowercase literal 'c' for T.element instead of 'carbon'. 5) When referring to the table: use the exact table name atom instead of atoms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM atoms WHERE molecule_id = 'TR008' AND element = 'carbon';",
            "SELECT COUNT(T.atom_id) FROM atom T WHERE T.molecule_id = 'TR008' AND T.element = 'c'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.atom_id) FROM atom T WHERE T.molecule_id = 'TR008' AND T.element = 'c'"
        ],
        "amend_res": 1
    },
    "39": {
        "db_id": "california_schools",
        "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
        "ground_truth": "SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T2.County = 'Fresno'",
        "amends": [
            "Do select `AVG(T1.NumTstTakr)` from the `satscores` table instead of `AVG(test_takers)` from the `schools` table. Do join `satscores AS T1` with `schools AS T2` using `INNER JOIN` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table. Do filter with `T2.County = 'Fresno'` instead of `city = 'Fresno'` and use `strftime('%Y', T2.OpenDate) = '1980'` for year extraction instead of `opened_date BETWEEN '1980-01-01' AND '1980-12-31'`. The amended query now correctly joins the relevant tables and uses proper date handling to match the intended behavior."
        ],
        "rules": [
            "1) When answering about average number of test takers: use AVG(T1.NumTstTakr) from the satscores table instead of AVG(test_takers) from schools table. 2) When combining satscores and schools tables: link rows where T1.cds = T2.CDSCode using inner join and keep only matching pairs. 3) When filtering for Fresno schools: use T2.County = 'Fresno' instead of city = 'Fresno'. 4) When filtering for schools opened in 1980: use strftime('%Y', T2.OpenDate) = '1980' instead of opened_date BETWEEN '1980-01-01' AND '1980-12-31'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(test_takers) FROM schools WHERE city = 'Fresno' AND opened_date BETWEEN '1980-01-01' AND '1980-12-31';",
            "SELECT AVG(T1.NumTstTakr) \nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nWHERE T2.County = 'Fresno' \nAND strftime('%Y', T2.OpenDate) = '1980';"
        ],
        "rule_sql": [
            "SELECT AVG(T1.NumTstTakr) \nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.County = 'Fresno' \nAND strftime('%Y', T2.OpenDate) = '1980'"
        ],
        "amend_res": 1
    },
    "541": {
        "db_id": "codebase_community",
        "question": "What is the display name of the user who is the owner of the most valuable post?",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.FavoriteCount DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` between `posts` and `users` on `T1.OwnerUserId = T2.Id` instead of a subquery with `user_id = (SELECT owner_user_id FROM posts)`. Do select `T2.DisplayName` instead of `display_name`. Do order by `T1.FavoriteCount DESC` instead of `score DESC`. Do add `LIMIT 1` at the query level instead of only in the subquery. The amended query now correctly joins the tables and sorts by FavoriteCount to match the intended behavior."
        ],
        "rules": [
            "1) When combining posts and users tables: link rows where T1.OwnerUserId = T2.Id and keep only matching pairs (inner match). 2) When the question asks for the \"most valuable post\": rank posts by T1.FavoriteCount in descending order and keep the first 1 row. 3) When the question asks for \"display name of the user\": select T2.DisplayName as the output column. 4) When producing output: return only the single row with the highest T1.FavoriteCount value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users WHERE user_id = (SELECT owner_user_id FROM posts ORDER BY score DESC LIMIT 1);",
            "SELECT u.DisplayName \nFROM posts p\nINNER JOIN users u ON p.OwnerUserId = u.Id\nORDER BY p.FavoriteCount DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT u.DisplayName\nFROM posts p\nINNER JOIN users u ON p.OwnerUserId = u.Id\nORDER BY p.FavoriteCount DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1426": {
        "db_id": "student_club",
        "question": "List the last name of members with a major in environmental engineering and include its department and college name.",
        "ground_truth": "SELECT T2.last_name, T1.department, T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'",
        "amends": [
            "Do select `T2.last_name`, `T1.department`, and `T1.college` instead of `m.last_name`, `d.department_name`, and `c.college_name`. Do join `major AS T1` and `member AS T2` instead of `members m`, `departments d`, and `colleges c`. Do use `INNER JOIN` with `T1.major_id = T2.link_to_major` instead of joining on `m.major_id = d.department_id` and `d.college_id = c.college_id`. Do filter with `T2.position = 'Member'` and `T1.major_name = 'Environmental Engineering'` instead of `m.major = 'Computer Science'`. The amended query now correctly retrieves member information filtered by position and major name rather than department-based relationships."
        ],
        "rules": [
            "1) When the question asks for last name, department, and college name: select T2.last_name, T1.department, and T1.college as output columns. 2) When combining member and major information: use INNER JOIN between major AS T1 and member AS T2 where T1.major_id = T2.link_to_major. 3) When filtering for members with a specific major: apply T2.position = 'Member' and T1.major_name = 'Environmental Engineering' as filter conditions. 4) When the question mentions \"environmental engineering\": use the exact literal 'Environmental Engineering' for filtering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.last_name, d.department_name, c.college_name\nFROM members m\nJOIN departments d ON m.major_id = d.department_id\nJOIN colleges c ON d.college_id = c.college_id\nWHERE m.major = 'Computer Science';",
            "SELECT T2.last_name, T1.department, T1.college \nFROM member AS T2 \nINNER JOIN major AS T1 ON T1.major_id = T2.link_to_major \nWHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'"
        ],
        "rule_sql": [
            "SELECT T2.last_name, T1.department, T1.college\nFROM major AS T1\nINNER JOIN member AS T2 ON T1.major_id = T2.link_to_major\nWHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'"
        ],
        "amend_res": 1
    },
    "1388": {
        "db_id": "student_club",
        "question": "Which students manage to generate the highest income. State his/her full name along with the income source.",
        "ground_truth": "SELECT T1.first_name, T1.last_name, T2.source FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.first_name, T1.last_name, T2.source ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `s` and `i`. Do reference `member` table instead of `students` table. Do use `INNER JOIN` instead of `JOIN` with the join condition `T1.member_id = T2.link_to_member` instead of `s.student_id = i.student_id`. Do select only `T1.first_name`, `T1.last_name`, and `T2.source` instead of including `MAX(i.amount)` in the SELECT list. Do group by `T1.first_name`, `T1.last_name`, and `T2.source` instead of grouping only by `s.student_id`. Do order by `SUM(T2.amount) DESC` instead of `MAX(i.amount) DESC`. The amended query now correctly aggregates total income per member and source combination rather than finding the single maximum income amount across all records."
        ],
        "rules": [
            "1) When the question asks about students: use the \"member\" table instead of \"students\" table with alias T1. 2) When joining income information: use INNER JOIN with the \"income\" table as T2 and link using T1.member_id = T2.link_to_member instead of student_id. 3) When selecting output columns: include only T1.first_name, T1.last_name, and T2.source, not the aggregate amount. 4) When grouping for highest income: group by T1.first_name, T1.last_name, and T2.source combination instead of by member_id. 5) When ordering for highest income: order by SUM(T2.amount) DESC instead of MAX(amount) to find total income per source. 6) When the question asks for \"highest income\": compute the sum of T2.amount per member and source combination rather than the maximum single amount."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.first_name, s.last_name, i.source, MAX(i.amount) \nFROM students s \nJOIN income i ON s.student_id = i.student_id \nGROUP BY s.student_id \nORDER BY MAX(i.amount) DESC \nLIMIT 1;",
            "SELECT T1.first_name, T1.last_name, T2.source\nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nGROUP BY T1.first_name, T1.last_name, T2.source\nORDER BY SUM(T2.amount) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T2.source\nFROM member AS T1\nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member\nGROUP BY T1.first_name, T1.last_name, T2.source\nORDER BY SUM(T2.amount) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "237": {
        "db_id": "toxicology",
        "question": "Which molecule does the atom TR001_10 belong to? Please state whether this molecule is carcinogenic or not.",
        "ground_truth": "SELECT T2.molecule_id , IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'",
        "amends": [
            "Do select `T2.molecule_id` and `IIF(T2.label='+','YES','NO') AS flag_carcinogenic` instead of `molecule_name` and `carcinogenic`. Do join from `atom AS T1 INNER JOIN molecule AS T2` instead of querying only `atoms`. Do use join condition `ON T1.molecule_id = T2.molecule_id` instead of no join. Do filter on `T1.atom_id = 'TR001_10'` instead of `atom_id = 'TR001_10'` to specify the table alias. The amended query now correctly retrieves molecule information through proper table joins and conditional logic."
        ],
        "rules": [
            "1) When answering about which molecule an atom belongs to: join atom table T1 with molecule table T2 using T1.molecule_id = T2.molecule_id to link atom to its molecule. 2) When filtering for a specific atom_id: use T1.atom_id = 'TR001_10' with exact literal value 'TR001_10'. 3) When selecting molecule identification: output T2.molecule_id instead of molecule_name. 4) When determining carcinogenic status: use IIF(T2.label='+','YES','NO') AS flag_carcinogenic to convert label '+' to 'YES' and other values to 'NO' for carcinogenic flag."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_name, carcinogenic FROM atoms WHERE atom_id = 'TR001_10';",
            "SELECT T2.molecule_id, IIF(T2.label='+','YES','NO') AS flag_carcinogenic\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.atom_id = 'TR001_10'"
        ],
        "rule_sql": [
            "SELECT T2.molecule_id, IIF(T2.label='+','YES','NO') AS flag_carcinogenic FROM atom T1 JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'"
        ],
        "amend_res": 1
    },
    "1122": {
        "db_id": "european_football_2",
        "question": "State the name of the most strongest player.",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)",
        "amends": [
            "Do select `t1.player_name` with `DISTINCT` instead of `name` without distinct. Do add `FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of the single table `FROM players`. Do add `WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)` instead of the simple `ORDER BY strength ASC LIMIT 1` approach. Do remove the explicit `ORDER BY` and `LIMIT` clauses instead of keeping them, as the subquery now handles finding the maximum rating. The amended query now correctly identifies players with the highest overall rating instead of just the weakest player by strength, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"most strongest player\": use the exact column token \"t2.overall_rating\" to determine player strength instead of \"strength\". 2) When combining player data with attributes: link rows where \"t1.player_api_id = t2.player_api_id\" exactly as shown and keep only matching pairs (inner match). 3) When finding the maximum rating: use the exact condition \"t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)\" instead of ordering and limiting. 4) When selecting player names: use the exact column token \"t1.player_name\" with DISTINCT instead of \"name\" without distinct. 5) When answering about \"most strongest player\": make sure the output order includes only \"t1.player_name\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY strength ASC LIMIT 1;",
            "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.player_name FROM Player t1 INNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)"
        ],
        "amend_res": 1
    },
    "556": {
        "db_id": "codebase_community",
        "question": "What is the average number of badges obtained by a user with over 200 views?",
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Views > 200",
        "amends": [
            "Do use `CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName)` instead of `AVG(badge_count)` for the average calculation. Do add `FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id` instead of the single table `FROM users`. Do change the filter to `WHERE T2.Views > 200` instead of `WHERE views > 200` to reference the joined table. Do remove the incorrect `badge_count` column reference and instead count badges from the badges table while calculating distinct users. The amended query now correctly calculates the average badges per user with views over 200 by joining the badges and users tables."
        ],
        "rules": [
            "1) When calculating average badges per user: use the formula (number of badges) divided by (number of distinct users) with CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName). 2) When combining badges and users tables: link rows where T1.UserId = T2.Id using an inner join to keep only matching pairs. 3) When filtering users by view count: apply the condition T2.Views > 200 to select users with more than 200 views. 4) When counting badges: use T1.Id from the badges table as the counting key. 5) When counting distinct users: use T2.DisplayName from the users table as the distinct identifier."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(badge_count) FROM users WHERE views > 200;",
            "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName) AS average_badges\nFROM badges AS T1\nINNER JOIN users AS T2 ON T1.UserId = T2.Id\nWHERE T2.Views > 200"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(badges.Id) AS REAL) / COUNT(DISTINCT users.DisplayName) AS average_badges_per_user\nFROM badges\nINNER JOIN users ON badges.UserId = users.Id\nWHERE users.Views > 200"
        ],
        "amend_res": 1
    },
    "153": {
        "db_id": "financial",
        "question": "How many 'classic' cards are eligible for loan?",
        "ground_truth": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'classic' AND T2.type = 'OWNER'",
        "amends": [
            "Do specify `COUNT(T1.card_id)` instead of `COUNT(*)` to count specific non-null values. Do change the table reference to `card AS T1` instead of `cards` with proper aliasing. Do add `INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id` instead of querying a single table to incorporate the relationship between card and disposition tables. Do replace the filter `loan_eligible = 'yes'` with `T2.type = 'OWNER'` to check for owner disposition type instead of loan eligibility status. Do maintain the `WHERE T1.type = 'classic'` filter as in the original query. The amended query now correctly counts classic cards associated with owner dispositions, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many 'classic' cards are eligible for loan\": make sure the output order: COUNT(T1.card_id). 2) When the question mentions \"cards\": \"cards\" actually means \"card AS T1\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.disp_id = T2.disp_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for 'classic' cards: use T1.type = 'classic' with exact literal 'classic'. 5) When checking for loan eligibility: use T2.type = 'OWNER' instead of loan_eligible = 'yes', with exact literal 'OWNER'. 6) When counting cards: compute the number of rows using the canonical key token T1.card_id instead of COUNT(*)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE type = 'classic' AND loan_eligible = 'yes';",
            "SELECT COUNT(T1.card_id) \nFROM card AS T1\nINNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id\nWHERE T1.type = 'classic' AND T2.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.card_id) \nFROM card AS T1\nINNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id\nWHERE T1.type = 'classic' AND T2.type = 'OWNER'"
        ],
        "amend_res": 1
    },
    "1262": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients with a normal level of complement 3 have a P pattern observed in the sheet of ANA examination?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C3 > 35 AND T1.`ANA Pattern` = 'P'",
        "amends": [
            "Do `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count distinct patient IDs rather than all examination records. Do `INNER JOIN Laboratory AS T2` instead of `JOIN ana_examination a` to join with the Laboratory table rather than ana_examination. Do `ON T1.ID = T2.ID` instead of `ON p.patient_id = a.patient_id` to join on ID columns between Examination and Laboratory tables. Do `T2.C3 > 35` instead of `p.complement_3 = 'normal'` to filter for C3 values greater than 35 rather than checking for 'normal' text values. Do `T1.ANA Pattern = 'P'` instead of `a.ana_pattern = 'P'` to filter the ANA Pattern from the Examination table rather than the examination table. The amended query now correctly counts distinct patients with specific laboratory and examination criteria."
        ],
        "rules": [
            "1) When counting patients: count distinct T1.ID values instead of all records to ensure each patient is counted only once. 2) When joining with laboratory data: use INNER JOIN with Laboratory table as T2 instead of ana_examination table. 3) When linking patient records: match rows where T1.ID = T2.ID to connect Examination and Laboratory tables. 4) When filtering for normal complement 3 levels: use T2.C3 > 35 instead of checking for 'normal' text values. 5) When filtering for P pattern in ANA examination: use T1.\"ANA Pattern\" = 'P' from the Examination table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients p JOIN ana_examination a ON p.patient_id = a.patient_id WHERE p.complement_3 = 'normal' AND a.ana_pattern = 'P';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.C3 > 35 \nAND T1.\"ANA Pattern\" = 'P'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.C3 > 35 \nAND T1.\"ANA Pattern\" = 'P'"
        ],
        "amend_res": 1
    },
    "1029": {
        "db_id": "european_football_2",
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "ground_truth": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4",
        "amends": [
            "Do select `t1.buildUpPlaySpeed` instead of `team_name, build_up_play_speed` and remove the team_name column. Do use `Team_Attributes AS t1` joined with `Team AS t2` instead of just `teams` table. Do perform `INNER JOIN` on `t1.team_api_id = t2.team_api_id` instead of no join condition. Do order by `t1.buildUpPlaySpeed ASC` instead of `build_up_play_speed DESC` with reversed sort direction. The amended query now correctly joins the Team_Attributes and Team tables to access buildUpPlaySpeed data and returns the four lowest values in ascending order instead of the highest values in descending order."
        ],
        "rules": [
            "1) When answering about \"speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed\": make sure the output order: t1.buildUpPlaySpeed\n2) When the question mentions \"top 4 teams with the highest build Up Play Speed\": actually means \"the four lowest values of buildUpPlaySpeed in ascending order\" in schema\n3) When combining Team_Attributes as t1 and Team as t2: link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match)\n4) When producing output: include only t1.buildUpPlaySpeed column, not team_name\n5) When ordering results: sort by t1.buildUpPlaySpeed in ascending order instead of descending order"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name, build_up_play_speed FROM teams ORDER BY build_up_play_speed DESC LIMIT 4;",
            "SELECT t1.buildUpPlaySpeed \nFROM Team_Attributes AS t1 \nINNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id \nORDER BY t1.buildUpPlaySpeed ASC \nLIMIT 4"
        ],
        "rule_sql": [
            "SELECT t1.buildUpPlaySpeed \nFROM Team_Attributes t1 \nINNER JOIN Team t2 ON t1.team_api_id = t2.team_api_id \nORDER BY t1.buildUpPlaySpeed ASC \nLIMIT 4"
        ],
        "amend_res": 1
    },
    "797": {
        "db_id": "superhero",
        "question": "Which superheroes have blue eyes with brown hair?",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'",
        "amends": [
            "Do reference `T1.superhero_name` instead of `name` and use proper table aliases. Do join `colour AS T2` on `T1.eye_colour_id = T2.id` instead of directly filtering `eye_color = 'blue'`, and join `colour AS T3` on `T1.hair_colour_id = T3.id` instead of directly filtering `hair_color = 'blonde'`. Do filter on `T2.colour = 'Blue'` instead of `eye_color = 'blue'` and `T3.colour = 'Brown'` instead of `hair_color = 'blonde'`, using proper color values from the joined tables. The amended query now correctly joins through the color reference tables and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about superheroes with specific eye and hair colors: use T1.\"superhero_name\" as the output column instead of \"name\". 2) When filtering by eye color: join \"colour AS T2\" on T1.\"eye_colour_id\" = T2.\"id\" and filter where T2.\"colour\" = 'Blue' instead of directly filtering eye_color. 3) When filtering by hair color: join \"colour AS T3\" on T1.\"hair_colour_id\" = T3.\"id\" and filter where T3.\"colour\" = 'Brown' instead of directly filtering hair_color. 4) When combining tables for color matching: perform inner joins using the exact key relationships T1.\"eye_colour_id\" = T2.\"id\" and T1.\"hair_colour_id\" = T3.\"id\" to ensure only matching pairs are kept."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE eye_color = 'blue' AND hair_color = 'blonde';",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nJOIN colour AS T2 ON T1.eye_colour_id = T2.id\nJOIN colour AS T3 ON T1.hair_colour_id = T3.id\nWHERE T2.colour = 'Blue' AND T3.colour = 'Brown'"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nINNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id\nWHERE T2.colour = 'Blue' AND T3.colour = 'Brown'"
        ],
        "amend_res": 1
    },
    "338": {
        "db_id": "toxicology",
        "question": "What is the atom ID of double bonded carbon in TR012 molecule?",
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T2.molecule_id = 'TR012' AND T3.bond_type = '=' AND T1.element = 'c'",
        "amends": [
            "Do add `INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id` and `INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id` instead of querying only the `atoms` table. Do change the table reference from `atoms` to `atom AS T1` instead of using the original table name. Do use `T1.element = 'c'` instead of `element = 'C'` with lowercase comparison. Do use `T3.bond_type = '='` instead of `bond_type = 'double'` with equals sign syntax. Do remove `LIMIT 1` instead of keeping the row limitation. The amended query now correctly joins the necessary tables and uses proper comparison syntax to match the intended behavior.",
            "Do filter on `T2.molecule_id = 'TR012'` instead of `T2.label = 'TR012'` to correctly identify the molecule. Do remove the `INNER JOIN` on `connected AS T4` and its associated join condition `T1.atom_id = T4.atom_id AND T3.bond_id = T4.bond_id` instead of including unnecessary table joins. The amended query now correctly filters by molecule_id rather than label and eliminates the superfluous connected table join, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"atom ID of double bonded carbon in TR012 molecule\": make sure the output order: T1.atom_id. 2) When the question mentions \"TR012 molecule\": \"TR012\" actually means \"T2.molecule_id = 'TR012'\" in schema. 3) When the question mentions \"carbon\": \"carbon\" actually means \"T1.element = 'c'\" in schema with lowercase comparison. 4) When the question mentions \"double bonded\": \"double bonded\" actually means \"T3.bond_type = '='\" in schema with equals sign syntax. 5) When combining tables for shared entities: link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match). 6) When the question asks for atom ID: return all matching rows instead of limiting to one result.",
            "1) When the question asks about a specific molecule by name like 'TR012': use the exact literal 'TR012' with the molecule_id column instead of label column to filter molecules. 2) When joining tables atom, molecule, and bond: do not include unnecessary joins to the connected table if the relationship can be established through direct foreign key relationships between the core tables. 3) When filtering for carbon atoms: use the exact literal 'c' (lowercase) for the element column to match carbon atoms. 4) When filtering for double bonds: use the exact literal '=' for the bond_type column to identify double bonds."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_id FROM atoms WHERE molecule_id = 'TR012' AND element = 'C' AND bond_type = 'double' LIMIT 1;",
            "SELECT T1.atom_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nINNER JOIN connected AS T4 ON T1.atom_id = T4.atom_id AND T3.bond_id = T4.bond_id\nWHERE T2.label = 'TR012'\nAND T1.element = 'c'\nAND T3.bond_type = '='",
            "SELECT T1.atom_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T2.molecule_id = 'TR012'\nAND T1.element = 'c'\nAND T3.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT T1.atom_id\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nJOIN bond T3 ON T2.molecule_id = T3.molecule_id\nWHERE T2.molecule_id = 'TR012'\nAND T1.element = 'c'\nAND T3.bond_type = '='"
        ],
        "amend_res": 1
    },
    "858": {
        "db_id": "formula_1",
        "question": "Which country is the constructor which got 1 point in the race No. 24 from?",
        "ground_truth": "SELECT T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 24 AND T1.points = 1",
        "amends": [
            "Do select `T2.nationality` instead of `country` from the `constructors` table. Do join `constructorResults AS T1` and `constructors AS T2` instead of querying only the `constructors` table. Do use `INNER JOIN` with `T2.constructorId = T1.constructorId` instead of no join condition. Do filter on `T1.raceId = 24` and `T1.points = 1` instead of filtering directly on the `constructors` table's `race_id` and `points` columns. The amended query now correctly retrieves nationality from constructors based on race results data through proper table joining and filtering."
        ],
        "rules": [
            "1) When the question asks about a constructor's country in a specific race: use the \"nationality\" column from the \"constructors\" table (T2) instead of \"country\". 2) When combining race results and constructor information: join \"constructorResults\" as T1 with \"constructors\" as T2 using T2.constructorId = T1.constructorId with an inner match. 3) When filtering for race number 24: use T1.raceId = 24 instead of race_id. 4) When filtering for 1 point: use T1.points = 1 instead of filtering on the constructors table's points column. 5) When selecting output: return T2.nationality as the country information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM constructors WHERE points = 1 AND race_id = 24;",
            "SELECT T2.nationality \nFROM constructorResults AS T1 \nINNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId \nWHERE T1.raceId = 24 AND T1.points = 1"
        ],
        "rule_sql": [
            "SELECT T2.nationality \nFROM constructorResults T1 \nINNER JOIN constructors T2 ON T2.constructorId = T1.constructorId \nWHERE T1.raceId = 24 AND T1.points = 1"
        ],
        "amend_res": 1
    },
    "1071": {
        "db_id": "european_football_2",
        "question": "List the football team that has a build up play speed of 31, build up plan dribbling of 53, and build up play passing of 32. Only indicate the short name of the team.",
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeed = 31 AND t2.buildUpPlayDribbling = 53 AND t2.buildUpPlayPassing = 32",
        "amends": [
            "Do select `t1.team_short_name` with `DISTINCT` instead of `team_name` without distinct. Do use `FROM Team AS t1 INNER JOIN Team_Attributes AS t2` instead of `FROM football_teams` alone. Do join on `t1.team_api_id = t2.team_api_id` instead of no join condition. Do filter on `t2.buildUpPlaySpeed = 31` instead of `build_up_play_speed = 31`, on `t2.buildUpPlayDribbling = 53` instead of `build_up_play_dribbling = 53`, and on `t2.buildUpPlayPassing = 32` instead of `build_up_play_passing = 32`, moving all filters to the joined table attributes. The amended query now correctly joins the Team and Team_Attributes tables and returns distinct short names matching the specified build-up play attributes."
        ],
        "rules": [
            "1) When answering about football teams with specific build-up play attributes: use Team table as T1 and Team_Attributes table as T2 with an inner join on T1.team_api_id = T2.team_api_id. 2) When the question asks for \"short name of the team\": select T1.team_short_name with DISTINCT instead of team_name. 3) When filtering for build up play speed of 31: use T2.buildUpPlaySpeed = 31 with exact case and no underscores. 4) When filtering for build up play dribbling of 53: use T2.buildUpPlayDribbling = 53 with exact case and no underscores. 5) When filtering for build up play passing of 32: use T2.buildUpPlayPassing = 32 with exact case and no underscores. 6) When combining Team and Team_Attributes tables: perform an inner match where T1.team_api_id equals T2.team_api_id and keep only matching pairs."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name FROM football_teams WHERE build_up_play_speed = 31 AND build_up_play_dribbling = 53 AND build_up_play_passing = 32;",
            "SELECT DISTINCT t1.team_short_name\nFROM Team AS t1\nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.buildUpPlaySpeed = 31\nAND t2.buildUpPlayDribbling = 53\nAND t2.buildUpPlayPassing = 32;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.team_short_name\nFROM Team AS T1\nINNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id\nWHERE T2.buildUpPlaySpeed = 31\nAND T2.buildUpPlayDribbling = 53\nAND T2.buildUpPlayPassing = 32;"
        ],
        "amend_res": 1
    },
    "947": {
        "db_id": "formula_1",
        "question": "How many British drivers were born after 1980?",
        "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) > '1980'",
        "amends": [
            "Do use `COUNT(driverId)` instead of `COUNT(*)` to count specific driver identifiers rather than all rows. Do reference the column `dob` instead of `date_of_birth` for the date of birth field. Do apply `STRFTIME('%Y', dob) > '1980'` instead of `date_of_birth < '1980-01-01'` to filter for drivers born after 1980 by extracting the year component rather than using a date comparison, which correctly identifies drivers born in years greater than 1980. The amended query now matches the intended behavior of counting British drivers born after 1980."
        ],
        "rules": [
            "1) When counting drivers: use COUNT(driverId) to count specific driver identifiers rather than all rows. 2) When filtering by date of birth: reference the column dob instead of date_of_birth. 3) When filtering for drivers born after 1980: apply STRFTIME('%Y', dob) > '1980' to extract the year component and correctly identify drivers born in years greater than 1980 rather than using date comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND date_of_birth < '1980-01-01';",
            "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) > '1980'"
        ],
        "rule_sql": [
            "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) > '1980'"
        ],
        "amend_res": 1
    },
    "257": {
        "db_id": "toxicology",
        "question": "List down atom id2 for atoms with element sulfur.",
        "ground_truth": "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'",
        "amends": [
            "Do use `DISTINCT T2.atom_id2` instead of `atom_id` without distinct. Do add `INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id` instead of querying only the atoms table. Do reference `T1.element = 's'` instead of `element = 'sulfur'` with the correct table alias and value. Do remove the direct table query and instead join through the connected table to get related atom IDs. The amended query now correctly retrieves distinct connected atom IDs for sulfur elements instead of directly querying atom IDs from a single table."
        ],
        "rules": [
            "1) When the question asks for \"atom id2\": use the exact column token \"T2.atom_id2\" with the T2 alias. 2) When the question mentions \"atoms with element sulfur\": the element condition should be \"T1.element = 's'\" using the exact literal 's' instead of 'sulfur'. 3) When combining data about atoms and their connections: perform an inner join between atoms table as T1 and connected table as T2 using the exact key equality \"T1.atom_id = T2.atom_id\". 4) When retrieving connected atom IDs: ensure the results are distinct to avoid duplicate atom_id2 values. 5) When querying for specific elements: always use the correct table alias T1 for the atoms table when filtering by element."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_id FROM atoms WHERE element = 'sulfur';",
            "SELECT DISTINCT T2.atom_id2 \nFROM atom AS T1 \nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id \nWHERE T1.element = 's'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'"
        ],
        "amend_res": 1
    },
    "635": {
        "db_id": "codebase_community",
        "question": "How many posts by Matt Parker have more than 4 votes?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id INNER JOIN votes AS T4 ON T4.PostId = T3.Id WHERE T1.DisplayName = 'Matt Parker' GROUP BY T2.PostId, T4.Id HAVING COUNT(T4.Id) > 4",
        "amends": [
            "Do add joins to `users`, `postHistory`, and `votes` tables instead of querying only the `posts` table. Do use `T1.DisplayName = 'Matt Parker'` instead of `author = 'Matt Parker'` to filter by user display name. Do count `T1.Id` instead of using `COUNT(*)` for more precise counting. Do add `GROUP BY T2.PostId, T4.Id` instead of omitting grouping. Do move the vote count filter to `HAVING COUNT(T4.Id) > 4` instead of using `votes > 4` in the WHERE clause. The amended query now correctly counts posts by Matt Parker with more than 4 votes by properly joining across the user, post history, and votes tables.",
            "Do select `COUNT(T1.Id)` instead of `COUNT(DISTINCT T2.PostId)`. Do add `posts AS T3` to the FROM clause instead of omitting it. Do change the join condition to `INNER JOIN posts AS T3 ON T2.PostId = T3.Id` instead of directly joining votes to postHistory. Do update the votes join to `INNER JOIN votes AS T4 ON T4.PostId = T3.Id` instead of `ON T2.PostId = T4.PostId`. Do expand the GROUP BY to include `T2.PostId, T4.Id` instead of just `T2.PostId`. The amended query now correctly handles the relationship between posts and votes through the posts table and produces the intended count behavior."
        ],
        "rules": [
            "1) When answering about \"posts by Matt Parker\": make sure to join tables users (T1), posts (T2), postHistory (T3), and votes (T4) using the relationships implied by the schema. 2) When the question mentions \"Matt Parker\": use T1.DisplayName = 'Matt Parker' exactly to filter by user display name. 3) When counting posts: count using T1.Id (the user's canonical key) instead of counting all rows. 4) When filtering for posts with more than 4 votes: use HAVING COUNT(T4.Id) > 4 instead of a WHERE clause condition on votes. 5) When grouping results: use GROUP BY T2.PostId, T4.Id to organize the count properly by post and vote identifiers.",
            "1) When answering about \"posts by Matt Parker\": make sure to include the posts table (T3) in the FROM clause and join it between postHistory and votes tables. 2) When joining tables: link postHistory (T2) to posts (T3) using T2.PostId = T3.Id, and link votes (T4) to posts (T3) using T4.PostId = T3.Id. 3) When counting posts with more than 4 votes: use COUNT(T1.Id) instead of COUNT(DISTINCT T2.PostId) to count the correct entities. 4) When grouping for the HAVING condition: include both T2.PostId and T4.Id in the GROUP BY clause instead of just T2.PostId. 5) When filtering for Matt Parker's posts: use T1.DisplayName = 'Matt Parker' exactly as specified with the exact case and spacing."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE author = 'Matt Parker' AND votes > 4;",
            "SELECT COUNT(DISTINCT T2.PostId) \nFROM users T1\nJOIN postHistory T2 ON T1.Id = T2.UserId\nJOIN votes T4 ON T2.PostId = T4.PostId\nWHERE T1.DisplayName = 'Matt Parker'\nGROUP BY T2.PostId\nHAVING COUNT(T4.Id) > 4",
            "SELECT COUNT(T1.Id) \nFROM users AS T1\nINNER JOIN postHistory AS T2 ON T1.Id = T2.UserId\nINNER JOIN posts AS T3 ON T2.PostId = T3.Id\nINNER JOIN votes AS T4 ON T4.PostId = T3.Id\nWHERE T1.DisplayName = 'Matt Parker'\nGROUP BY T2.PostId, T4.Id\nHAVING COUNT(T4.Id) > 4"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.Id) \nFROM users T1\nJOIN posts T2 ON T1.Id = T2.OwnerUserId\nJOIN votes T4 ON T2.Id = T4.PostId\nWHERE T1.DisplayName = 'Matt Parker'\nGROUP BY T2.Id\nHAVING COUNT(T4.Id) > 4"
        ],
        "amend_res": 1
    },
    "1469": {
        "db_id": "student_club",
        "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
        "ground_truth": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do select from `member AS T1` instead of `students`. Do add `INNER JOIN zip_code AS T2` instead of omitting the join. Do use join condition `T2.zip_code = T1.zip` instead of no join condition. Do change filter to `T2.city = 'Lincolnton'` instead of `hometown = 'Lincolnton'`. Do add `T2.state = 'North Carolina'` instead of omitting it. Do change zip filter to `T2.zip_code = 28092` (numeric) instead of `zip_code = '28092'` (string). Do reference columns with table aliases `T1.first_name`, `T1.last_name`, `T1.position` instead of bare column names. The amended query now correctly joins member and zip_code tables to filter by city and state while handling zip code as numeric."
        ],
        "rules": [
            "1) When answering about students with hometown information: select from \"member\" AS T1 instead of \"students\" table. 2) When the question mentions \"hometown of Lincolnton, North Carolina\": use T2.city = 'Lincolnton' and T2.state = 'North Carolina' instead of hometown filtering. 3) When the question mentions \"zip code of 28092\": use T2.zip_code = 28092 (numeric value) instead of string comparison. 4) When combining member and zip_code information: link rows where T2.zip_code = T1.zip using INNER JOIN and keep only matching pairs. 5) When selecting output columns: use T1.first_name, T1.last_name, and T1.position with exact table aliases. 6) When handling zip code values: treat zip_code as numeric type, not string type."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, position FROM students WHERE hometown = 'Lincolnton' AND zip_code = '28092';",
            "SELECT T1.first_name, T1.last_name, T1.position \nFROM member AS T1 \nINNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip \nWHERE T2.city = 'Lincolnton' \nAND T2.state = 'North Carolina' \nAND T2.zip_code = 28092"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T1.position \nFROM member AS T1 \nINNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip \nWHERE T2.city = 'Lincolnton' \nAND T2.state = 'North Carolina' \nAND T2.zip_code = 28092"
        ],
        "amend_res": 1
    },
    "733": {
        "db_id": "superhero",
        "question": "How many gold-eyed superheroes did Marvel Comics publish?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.colour = 'Gold'",
        "amends": [
            "Do join `publisher` and `colour` tables instead of querying `superheroes` directly. Do use `T1.publisher_id = T2.id` and `T1.eye_colour_id = T3.id` join conditions instead of direct column references. Do filter on `T2.publisher_name = 'Marvel Comics'` instead of `publisher = 'Marvel Comics'`. Do filter on `T3.colour = 'Gold'` with proper capitalization instead of `eye_color = 'gold'`. Do count `T1.id` specifically instead of `COUNT(*)` for more precise results. The amended query now correctly uses normalized table relationships and proper case-sensitive filtering to match the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"gold-eyed superheroes\": \"gold-eyed\" actually means \"T3.colour = 'Gold'\" in schema with exact capitalization. 2) When the question mentions \"Marvel Comics\": \"Marvel Comics\" actually means \"T2.publisher_name = 'Marvel Comics'\" in schema. 3) When combining tables for superhero information: link rows where T1.publisher_id = T2.id and T1.eye_colour_id = T3.id; keep only matching pairs (inner match). 4) When counting superheroes: compute the number of rows using the canonical key token T1.id instead of counting all columns. 5) When handling text literals: do not change case, spacing, or punctuation for 'Marvel Comics' and 'Gold'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE eye_color = 'gold' AND publisher = 'Marvel Comics';",
            "SELECT COUNT(T1.id) \nFROM superhero T1\nJOIN publisher T2 ON T1.publisher_id = T2.id\nJOIN colour T3 ON T1.eye_colour_id = T3.id\nWHERE T2.publisher_name = 'Marvel Comics' AND T3.colour = 'Gold'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nINNER JOIN colour T3 ON T1.eye_colour_id = T3.id\nWHERE T2.publisher_name = 'Marvel Comics' AND T3.colour = 'Gold'"
        ],
        "amend_res": 1
    },
    "770": {
        "db_id": "superhero",
        "question": "What is the eyes colour of Abraham Sapien?",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Abraham Sapien'",
        "amends": [
            "Do select `T2.colour` from the `colour` table instead of `eye_color` directly from the `characters` table. Do join `superhero` as `T1` with `colour` as `T2` on `T1.eye_colour_id = T2.id` instead of querying a single table without joins. Do filter on `T1.full_name = 'Abraham Sapien'` instead of `name = 'Abraham Lincoln'` to reference the correct character identifier. The amended query now properly joins tables to retrieve eye color through a relationship instead of assuming the color is stored directly, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about eye color: retrieve the \"colour\" column from table \"colour\" (aliased as T2) instead of \"eye_color\" from the \"characters\" table. 2) When combining superhero and colour tables: link rows where T1.eye_colour_id equals T2.id and keep only matching pairs (inner join). 3) When filtering for a specific character: use T1.full_name = 'Abraham Sapien' instead of name = 'Abraham Lincoln' to reference the correct character identifier."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eye_color FROM characters WHERE name = 'Abraham Lincoln';",
            "SELECT T2.colour \nFROM superhero T1\nJOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T1.full_name = 'Abraham Sapien'"
        ],
        "rule_sql": [
            "SELECT T2.colour \nFROM superhero T1 \nINNER JOIN colour T2 ON T1.eye_colour_id = T2.id \nWHERE T1.full_name = 'Abraham Sapien'"
        ],
        "amend_res": 1
    },
    "167": {
        "db_id": "financial",
        "question": "List all the clients' IDs whose junior credit cards were issued after 1996.",
        "ground_truth": "SELECT T2.client_id FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'junior' AND T1.issued >= '1997-01-01'",
        "amends": [
            "Do select `T2.client_id` from the `disp` table instead of `client_id` from the `credit_cards` table. Do join `card AS T1` with `disp AS T2` using `INNER JOIN` on `T1.disp_id = T2.disp_id` instead of querying a single `credit_cards` table. Do filter on `T1.type = 'junior'` instead of `card_type = 'junior'`. Do use date comparison `T1.issued >= '1997-01-01'` with proper date format instead of numeric year comparison `issue_year > 1996`. The amended query now correctly joins the card and disposition tables to retrieve client IDs associated with junior cards issued from 1997 onward, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"clients' IDs whose junior credit cards were issued after 1996\": make sure the output order: T2.client_id. 2) When the question mentions \"junior credit cards\": \"junior\" actually means \"T1.type = 'junior'\" in schema. 3) When the question mentions \"issued after 1996\": use date comparison T1.issued >= '1997-01-01' to represent cards issued from 1997 onward. 4) When combining card table as T1 and disp table as T2: link rows where T1.disp_id = T2.disp_id and keep only matching pairs (inner match). 5) When selecting client IDs: use T2.client_id from the disp table instead of client_id from the card table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT client_id FROM credit_cards WHERE card_type = 'junior' AND issue_year > 1996;",
            "SELECT T2.client_id\nFROM card AS T1\nINNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id\nWHERE T1.type = 'junior'\nAND T1.issued >= '1997-01-01'"
        ],
        "rule_sql": [
            "SELECT T2.client_id\nFROM card AS T1\nINNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id\nWHERE T1.type = 'junior' AND T1.issued >= '1997-01-01'\nORDER BY T2.client_id;"
        ],
        "amend_res": 1
    },
    "516": {
        "db_id": "card_games",
        "question": "How many cards did Volkan Ba\u00c7\u00b5a illustrated whose foreign language is in French?",
        "ground_truth": "SELECT COUNT(T3.id) FROM ( SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Ba\u01f5a' AND T2.language = 'French' GROUP BY T1.id ) AS T3",
        "amends": [
            "Do select `COUNT(T3.id)` instead of `COUNT(*)` to count distinct card IDs. Do use a subquery `T3` instead of direct joins to properly group distinct cards. Do join `cards AS T1` with `foreign_data AS T2` on `T2.uuid = T1.uuid` instead of joining with `illustrators` and `languages` tables. Do filter on `T1.artist = 'Volkan Ba\u01f5a'` instead of `i.name = 'Volkan Ba\u00c7\u00b5a'` to use the correct artist column and character encoding. Do filter on `T2.language = 'French'` instead of `l.name = 'French'` to use the language column from foreign_data. Do add `GROUP BY T1.id` instead of omitting grouping to ensure distinct card counting. The amended query now correctly counts French language cards by Volkan Ba\u01f5a using the proper table relationships and character encoding."
        ],
        "rules": [
            "1) When counting cards: use COUNT(T3.id) to count distinct card IDs instead of COUNT(*) 2) When joining cards and foreign_data tables: link rows where T2.uuid = T1.uuid using an inner match 3) When filtering for artist Volkan Ba\u01f5a: use T1.artist = 'Volkan Ba\u01f5a' with the correct character encoding 4) When filtering for French language: use T2.language = 'French' from the foreign_data table 5) When ensuring distinct card counting: add GROUP BY T1.id to group by card IDs"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards c JOIN illustrators i ON c.illustrator_id = i.illustrator_id JOIN languages l ON c.language_id = l.language_id WHERE i.name = 'Volkan Ba\u00c7\u00b5a' AND l.name = 'French';",
            "SELECT COUNT(T3.id) \nFROM (\n    SELECT T1.id \n    FROM cards AS T1 \n    JOIN foreign_data AS T2 ON T2.uuid = T1.uuid \n    WHERE T1.artist = 'Volkan Ba\u01f5a' \n    AND T2.language = 'French' \n    GROUP BY T1.id\n) AS T3"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM cards T1 \nINNER JOIN foreign_data T2 ON T2.uuid = T1.uuid \nWHERE T1.artist = 'Volkan Ba\u01f5a' \nAND T2.language = 'French' \nGROUP BY T1.id",
            "SELECT COUNT(T1.id) \nFROM cards T1 \nINNER JOIN foreign_data T2 ON T2.uuid = T1.uuid \nWHERE T1.artist = 'Volkan Ba\u01f5a' \nAND T2.language = 'French' \nGROUP BY T1.id"
        ],
        "amend_res": 1
    },
    "94": {
        "db_id": "financial",
        "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
        "ground_truth": "SELECT T1.account_id , ( SELECT MAX(A11) - MIN(A11) FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "amends": [
            "Do use `account_id` instead of `account_number` in the SELECT list and remove the salary aggregates instead of keeping them. Do add a subquery `(SELECT MAX(A11) - MIN(A11) FROM district)` instead of calculating salary gap directly. Do change FROM sources to join `account AS T1`, `district AS T2`, `disp AS T3`, and `client AS T4` instead of just `accounts` and `clients`. Do use `INNER JOIN` on `T1.district_id = T2.district_id` and `T1.account_id = T3.account_id` and `T3.client_id = T4.client_id` instead of a single join on `a.client_id = c.client_id`. Do change WHERE filter to `T2.district_id = (subquery)` instead of `c.gender = 'Female'`. Do add a subquery `(SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1)` instead of direct gender filtering. Do change ORDER BY to `T2.A11 DESC` instead of `c.age DESC`. The amended query now correctly matches the intended behavior by properly joining multiple tables and using subqueries for district-based filtering and calculation.",
            "Do remove the alias `salary_gap` from the subquery expression instead of keeping it. Do add `LIMIT 1` to the outer query instead of omitting it, which ensures only the single highest A11 value record is returned. The amended query now correctly returns one account with the district salary range calculation without the unnecessary alias and with proper result limiting."
        ],
        "rules": [
            "1) When answering about account numbers: use \"account_id\" instead of \"account_number\" in the output. 2) When the question mentions \"female clients\": filter using \"gender = 'F'\" instead of \"gender = 'Female'\". 3) When the question asks for \"oldest\": order by \"birth_date ASC\" to find the earliest birth date. 4) When combining tables: link T1 (account) and T2 (district) using \"T1.district_id = T2.district_id\", link T1 and T3 (disp) using \"T1.account_id = T3.account_id\", and link T3 and T4 (client) using \"T3.client_id = T4.client_id\". 5) When filtering for district: use \"T2.district_id = (subquery)\" where the subquery finds the district_id from client where gender = 'F' ordered by birth_date ASC with LIMIT 1. 6) When calculating salary gap: use \"(SELECT MAX(A11) - MIN(A11) FROM district)\" instead of direct column calculations. 7) When ordering results: use \"T2.A11 DESC\" instead of age-based ordering.",
            "1) When answering about \"female clients who are oldest and has lowest average salary\": make sure to filter for gender = 'F' exactly as specified. 2) When the question asks for \"account numbers\": use the exact identifier \"account_id\" from the account table. 3) When the question mentions \"oldest\": order by birth_date in ascending order to find the earliest birth date. 4) When the question asks for \"lowest average salary\": use the exact column \"A11\" from the district table and find the minimum value. 5) When the question asks to \"calculate the gap between this lowest average salary with the highest average salary\": compute MAX(A11) - MIN(A11) from the district table. 6) When combining tables for this analysis: link account to district using district_id equality and account to disp using account_id equality, then disp to client using client_id equality. 7) When limiting results to the single oldest female client with lowest salary: use LIMIT 1 on the outer query to return only one record."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    a.account_number,\n    MIN(c.avg_salary) as lowest_avg_salary,\n    MAX(c.avg_salary) as highest_avg_salary,\n    MAX(c.avg_salary) - MIN(c.avg_salary) as salary_gap\nFROM accounts a\nJOIN clients c ON a.client_id = c.client_id\nWHERE c.gender = 'Female'\nORDER BY c.age DESC\nLIMIT 1;",
            "SELECT T1.account_id, (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3 ON T1.account_id = T3.account_id\nINNER JOIN client AS T4 ON T3.client_id = T4.client_id\nWHERE T2.district_id = (\n    SELECT district_id \n    FROM client \n    WHERE gender = 'F' \n    ORDER BY birth_date ASC \n    LIMIT 1\n)\nORDER BY T2.A11 DESC;",
            "SELECT T1.account_id, (SELECT MAX(A11) - MIN(A11) FROM district) \nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3 ON T1.account_id = T3.account_id\nINNER JOIN client AS T4 ON T3.client_id = T4.client_id\nWHERE T2.district_id = (SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1)\nORDER BY T2.A11 DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT \n    T1.account_id,\n    (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM \n    account T1\nJOIN \n    district T2 ON T1.district_id = T2.district_id\nJOIN \n    disp T3 ON T1.account_id = T3.account_id\nJOIN \n    client T4 ON T3.client_id = T4.client_id\nWHERE \n    T4.gender = 'F'\n    AND T2.district_id = (\n        SELECT district_id \n        FROM client \n        WHERE gender = 'F' \n        ORDER BY birth_date ASC \n        LIMIT 1\n    )\nORDER BY \n    T2.A11 ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "345": {
        "db_id": "card_games",
        "question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.",
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL",
        "amends": [
            "Do select `T2.status` from the `legalities` table instead of `legalities` from the `cards` table. Do join `cards AS T1` with `legalities AS T2` on `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do filter with `T1.type = 'Artifact'` instead of `type LIKE '%Artifact%'` for exact matching. Do add `T2.format = 'vintage'` instead of `legalities LIKE '%vintage%'` for precise format filtering. Do add `T1.side IS NULL` instead of `faces = 1` for proper side condition checking. Do use `DISTINCT` on the result set instead of returning potential duplicates. The amended query now correctly retrieves distinct legality statuses for Artifact cards in the vintage format from the proper table relationship."
        ],
        "rules": [
            "1) When selecting legalities status: use T2.status from the legalities table instead of legalities from the cards table. 2) When combining cards and legalities tables: join T1 (cards) with T2 (legalities) on T1.uuid = T2.uuid using inner match. 3) When filtering for artifact type: use exact matching with T1.type = 'Artifact' instead of pattern matching. 4) When filtering for vintage format: use T2.format = 'vintage' for precise format filtering. 5) When checking for cards without multiple faces: use T1.side IS NULL instead of faces = 1 for proper side condition checking. 6) When returning results: use DISTINCT to eliminate duplicate status values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT legalities FROM cards WHERE type LIKE '%Artifact%' AND faces = 1 AND legalities LIKE '%vintage%';",
            "SELECT DISTINCT T2.status\nFROM cards AS T1\nJOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T1.type = 'Artifact'\nAND T2.format = 'vintage'\nAND T1.side IS NULL"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.status \nFROM cards T1 \nINNER JOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T1.type = 'Artifact' \nAND T2.format = 'vintage' \nAND T1.side IS NULL"
        ],
        "amend_res": 1
    },
    "114": {
        "db_id": "financial",
        "question": "For the first client who opened his/her account in Prague, what is his/her account ID?",
        "ground_truth": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'Prague' ORDER BY T1.date ASC LIMIT 1",
        "amends": [
            "Do add `INNER JOIN district AS T2 ON T1.district_id = T2.district_id` instead of querying only the accounts table. Do change the WHERE filter to `T2.A3 = 'Prague'` instead of `city = 'Prague'` to reference the correct table and column. Do add `ORDER BY T1.date ASC` instead of `ORDER BY account_id` to sort by date rather than account ID. Do use table aliases `T1.account_id` instead of just `account_id` for explicit table reference. The amended query now correctly joins the district table to filter by city name from the appropriate source and orders by date to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about the first client who opened an account in Prague: make sure the output order includes T1.account_id. 2) When the question mentions \"Prague\": \"Prague\" actually means T2.A3 = 'Prague' in the schema. 3) When the question asks for the \"first\" client by account opening date: rank rows by T1.date in ascending order and keep the first 1 row. 4) When combining T1 (accounts) and T2 (district) for shared entities: link rows where T1.district_id = T2.district_id exactly as shown; keep only matching pairs (inner match). 5) When referring to table roles: use T1 for accounts table and T2 for district table as established in the amends."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id FROM accounts WHERE city = 'Prague' ORDER BY account_id LIMIT 1;",
            "SELECT T1.account_id\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.A3 = 'Prague'\nORDER BY T1.date ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.account_id\nFROM account T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T2.A3 = 'Prague'\nORDER BY T1.date ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1362": {
        "db_id": "student_club",
        "question": "How many cities are there in Orange County, Virginia?",
        "ground_truth": "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia'",
        "amends": [
            "Do select `COUNT(city)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do query from `zip_code` table instead of `cities` table to access the correct data source. Do filter for `county = 'Orange County'` instead of `county = 'Orange'` to match the full county name format. The amended query now correctly counts cities in Orange County, Virginia from the appropriate zip_code table."
        ],
        "rules": [
            "1) When the question asks for count of cities: count the number of non-null values in the \"city\" column instead of counting all rows. 2) When querying about cities and counties: use the \"zip_code\" table instead of a \"cities\" table to access the correct data source. 3) When filtering for Orange County, Virginia: use the exact literal 'Orange County' for the county filter instead of 'Orange' to match the full county name format."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE county = 'Orange' AND state = 'Virginia';",
            "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia';"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia' AND city IS NOT NULL"
        ],
        "amend_res": 1
    },
    "1311": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients with severe thrombosis have a normal prothrombin time?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.PT < 14 AND T3.Thrombosis < 3 AND T3.Thrombosis > 0",
        "amends": [
            "Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` and `Examination AS T3` on `T1.ID = T3.ID` instead of querying only the `patients` table. Do filter on `T2.PT < 14` instead of `prothrombin_time = 'normal'` and on `T3.Thrombosis < 3 AND T3.Thrombosis > 0` instead of `thrombosis_severity = 'severe'`. Do count `T1.ID` instead of `COUNT(*)` to ensure accurate patient counting across joined tables. The amended query now correctly joins multiple tables and uses proper numerical comparisons instead of string-based severity classifications, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"patients with severe thrombosis and normal prothrombin time\": join Patient as T1 with Laboratory as T2 on T1.ID = T2.ID and Examination as T3 on T1.ID = T3.ID to access all required data. 2) When filtering for severe thrombosis: use T3.Thrombosis < 3 AND T3.Thrombosis > 0 instead of string-based severity classifications. 3) When filtering for normal prothrombin time: use T2.PT < 14 instead of string-based values. 4) When counting patients across joined tables: count T1.ID instead of all rows to ensure accurate patient counting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE thrombosis_severity = 'severe' AND prothrombin_time = 'normal';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nJOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.PT < 14 \nAND T3.Thrombosis < 3 \nAND T3.Thrombosis > 0"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nJOIN Examination T3 ON T1.ID = T3.ID\nWHERE T3.Thrombosis < 3 AND T3.Thrombosis > 0\nAND T2.PT < 14"
        ],
        "amend_res": 1
    },
    "1317": {
        "db_id": "student_club",
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `sc`, `ea`, and `e`. Do reference `T1.event_id` in the COUNT instead of `*`. Do join `event AS T1` instead of `Student_Club sc`. Do join `attendance AS T2` instead of `Event_Attendance ea`. Do use join condition `T1.event_id = T2.link_to_event` instead of `sc.Student_ID = ea.Student_ID`. Do join `member AS T3` instead of omitting it. Do use join condition `T2.link_to_member = T3.member_id` instead of omitting this relationship. Do filter on `T3.t_shirt_size = 'Medium'` instead of `sc.T_Shirt_Size = 'Medium'` to correctly reference the member table. The amended query now correctly counts events for members with medium t-shirts attending Women's Soccer events."
        ],
        "rules": [
            "1) When joining tables for event attendance analysis: combine event AS T1, attendance AS T2, and member AS T3 using the exact join conditions T1.event_id = T2.link_to_event and T2.link_to_member = T3.member_id, keeping only matching pairs (inner match). 2) When filtering for the \"Women's Soccer\" event: use T1.event_name = 'Women''s Soccer' exactly as specified. 3) When filtering for medium T-shirt size: use T3.t_shirt_size = 'Medium' exactly as specified. 4) When counting students from the Student_Club who attended the event: count using T1.event_id as the canonical counting key instead of counting all columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM Student_Club sc\nJOIN Event_Attendance ea ON sc.Student_ID = ea.Student_ID\nJOIN Events e ON ea.Event_ID = e.Event_ID\nWHERE e.Event_Name = 'Women''s Soccer'\nAND sc.T_Shirt_Size = 'Medium';",
            "SELECT COUNT(T1.event_id) \nFROM event AS T1\nJOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nJOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = 'Women''s Soccer' \nAND T3.t_shirt_size = 'Medium'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.event_id) \nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = 'Women''s Soccer' \nAND T3.t_shirt_size = 'Medium'"
        ],
        "amend_res": 1
    },
    "212": {
        "db_id": "toxicology",
        "question": "Which element is the least numerous in non-carcinogenic molecules?",
        "ground_truth": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
        "amends": [
            "Do select only `T.element` instead of `element, COUNT(*) as count`. Do use a subquery instead of querying directly from the molecules table. Do join `atom AS T1` with `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying only the molecules table. Do filter with `T2.label = '-'` instead of `carcinogenic = 0`. Do aggregate with `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(*)`. Do order by `COUNT(DISTINCT T1.molecule_id) ASC` instead of `count DESC`. Do maintain the `LIMIT 1` but within the subquery instead of at the outer level. The amended query now correctly identifies elements from atoms in specific molecules rather than counting carcinogenic status directly."
        ],
        "rules": [
            "1) When answering about \"least numerous element in non-carcinogenic molecules\": make sure the output order: T.element only. 2) When combining atom as T1 and molecule as T2: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match). 3) When filtering for non-carcinogenic molecules: use T2.label = '-' exactly as specified. 4) When counting distinct molecules per element: compute the number of unique T1.molecule_id values per T.element. 5) When ranking for \"least numerous\": order by the count of distinct molecules in ascending order and keep only the first 1 row. 6) When handling text literals: do not change the '-' value for T2.label."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element, COUNT(*) as count FROM molecules WHERE carcinogenic = 0 GROUP BY element ORDER BY count DESC LIMIT 1;",
            "SELECT T.element\nFROM (\n    SELECT T1.element, COUNT(DISTINCT T1.molecule_id) as count\n    FROM atom AS T1\n    JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T2.label = '-'\n    GROUP BY T1.element\n    ORDER BY COUNT(DISTINCT T1.molecule_id) ASC\n    LIMIT 1\n) AS T"
        ],
        "rule_sql": [
            "SELECT T.element\nFROM (\n    SELECT a.element, COUNT(DISTINCT a.molecule_id) as molecule_count\n    FROM atom a\n    INNER JOIN molecule m ON a.molecule_id = m.molecule_id\n    WHERE m.label = '-'\n    GROUP BY a.element\n    ORDER BY molecule_count ASC\n    LIMIT 1\n) T"
        ],
        "amend_res": 1
    },
    "1503": {
        "db_id": "debit_card_specializing",
        "question": "Please list the product description of the products bought in transactions in euro.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T1.ProductID, T3.Description FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Currency = 'EUR'",
        "amends": [
            "Do select `DISTINCT T1.ProductID, T3.Description` instead of `product_description` alone. Do join `transactions_1k AS T1` with `customers AS T2` on `T1.CustomerID = T2.CustomerID` instead of querying only the products table. Do add an additional `INNER JOIN` with `products AS T3` on `T1.ProductID = T3.ProductID` instead of no join. Do filter on `T2.Currency = 'EUR'` instead of `currency = 'euro'` to use the correct table reference and currency code format. The amended query now correctly joins multiple tables and filters based on customer currency rather than product currency, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"products bought in transactions in euro\": make sure the output order: T1.ProductID, T3.Description. 2) When the question mentions \"products bought in transactions\": join transactions_1k AS T1 with customers AS T2 on T1.CustomerID = T2.CustomerID and with products AS T3 on T1.ProductID = T3.ProductID. 3) When the question mentions \"in euro\": filter on T2.Currency = 'EUR' instead of 'euro' to use the correct currency code format. 4) When selecting product descriptions: use DISTINCT T1.ProductID, T3.Description to show unique product information rather than product_description alone."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_description FROM products WHERE currency = 'euro';",
            "SELECT DISTINCT T1.ProductID, T3.Description\nFROM transactions_1k AS T1\nINNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN products AS T3 ON T1.ProductID = T3.ProductID\nWHERE T2.Currency = 'EUR'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ProductID, T3.Description\nFROM transactions_1k AS T1\nJOIN customers AS T2 ON T1.CustomerID = T2.CustomerID\nJOIN products AS T3 ON T1.ProductID = T3.ProductID\nWHERE T2.Currency = 'EUR'\nORDER BY T1.ProductID, T3.Description;"
        ],
        "amend_res": 1
    },
    "36": {
        "db_id": "california_schools",
        "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
        "ground_truth": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [
            "Do select specific administrator name columns `T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3` instead of the generic `administrator_name`. Do join `satscores AS T1` with `schools AS T2` using `INNER JOIN` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table without any join. Do order by `T1.NumGE1500 DESC` instead of `student_count DESC` to prioritize schools with more students scoring 1500+ on SAT. Do remove the `WHERE sat_score >= 1500` filter entirely instead of keeping it, as the join condition and ordering now handle the SAT score logic through the `NumGE1500` column. The amended query now correctly retrieves administrator names from the school with the highest number of students scoring 1500+ on SAT, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about administrator names for schools: select the exact columns T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 instead of a generic administrator_name field. 2) When combining SAT score data with school information: link tables satscores AS T1 and schools AS T2 where T1.cds = T2.CDSCode and keep only matching pairs (inner match). 3) When finding the school with the highest number of students scoring 1500+ on SAT: order results by T1.NumGE1500 in descending direction and keep only the first row. 4) When the question asks about SAT scores of 1500 or more: use the T1.NumGE1500 column which already represents this count, rather than filtering individual SAT scores."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT administrator_name FROM schools WHERE sat_score >= 1500 ORDER BY student_count DESC LIMIT 1;",
            "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "903": {
        "db_id": "formula_1",
        "question": "How many times did Michael Schumacher won from races hosted in Sepang International Circuit?",
        "ground_truth": "SELECT SUM(T2.wins) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId INNER JOIN circuits AS T4 ON T4.circuitId = T3.circuitId WHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher' AND T4.name = 'Sepang International Circuit'",
        "amends": [
            "Do use `SUM(T2.wins)` instead of `COUNT(*)` to calculate total wins instead of counting rows. Do join `drivers AS T1` instead of omitting it, adding proper driver identification. Do join `driverStandings AS T2` on `T2.driverId = T1.driverId` instead of missing this relationship entirely. Do join `races AS T3` on `T3.raceId = T2.raceId` instead of directly querying races without proper standings linkage. Do join `circuits AS T4` on `T4.circuitId = T3.circuitId` instead of using `circuit_name` directly from races. Do filter on `T1.forename = 'Michael' AND T1.surname = 'Schumacher'` instead of just `winner = 'Michael Schumacher'` for accurate driver identification. Do filter on `T4.name = 'Sepang International Circuit'` instead of `circuit_name` to use the proper circuit table column. Do remove the incorrect direct count from races and instead aggregate wins from driver standings through proper table relationships. The amended query now correctly calculates Michael Schumacher's total wins at Sepang International Circuit by properly joining driver, standings, race, and circuit tables."
        ],
        "rules": [
            "1) When answering about \"How many times did Michael Schumacher won from races hosted in Sepang International Circuit\": make sure the output order: SUM(T2.wins) as the count of wins. 2) When the question mentions \"Michael Schumacher\": \"Michael Schumacher\" actually means \"T1.forename = 'Michael' AND T1.surname = 'Schumacher'\" in schema. 3) When the question mentions \"Sepang International Circuit\": \"Sepang International Circuit\" actually means \"T4.name = 'Sepang International Circuit'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T2.driverId = T1.driverId exactly as shown in the amends; keep only matching pairs (inner match). 5) When combining T2 and T3 for shared entities: link rows where T3.raceId = T2.raceId exactly as shown in the amends; keep only matching pairs (inner match). 6) When combining T3 and T4 for shared entities: link rows where T4.circuitId = T3.circuitId exactly as shown in the amends; keep only matching pairs (inner match). 7) When calculating total wins: use SUM(T2.wins) instead of COUNT(*) to calculate total wins from driver standings rather than counting rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM races WHERE circuit_name = 'Sepang International Circuit' AND winner = 'Michael Schumacher';",
            "SELECT SUM(T2.wins) AS total_wins\nFROM drivers AS T1\nJOIN driverStandings AS T2 ON T2.driverId = T1.driverId\nJOIN races AS T3 ON T3.raceId = T2.raceId\nJOIN circuits AS T4 ON T4.circuitId = T3.circuitId\nWHERE T1.forename = 'Michael' \nAND T1.surname = 'Schumacher'\nAND T4.name = 'Sepang International Circuit'"
        ],
        "rule_sql": [
            "SELECT SUM(T2.wins) AS win_count\nFROM drivers T1\nINNER JOIN driverStandings T2 ON T2.driverId = T1.driverId\nINNER JOIN races T3 ON T3.raceId = T2.raceId\nINNER JOIN circuits T4 ON T4.circuitId = T3.circuitId\nWHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher'\nAND T4.name = 'Sepang International Circuit'"
        ],
        "amend_res": 1
    },
    "749": {
        "db_id": "superhero",
        "question": "Provide the superpowers of the superhero called Deathlok.",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Deathlok'",
        "amends": [
            "Do select `T3.power_name` instead of `superpower` and use proper table aliases. Do join `superhero AS T1` instead of querying a single table, adding `INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id` and `INNER JOIN superpower AS T3 ON T2.power_id = T3.id` instead of omitting these necessary joins. Do filter on `T1.superhero_name = 'Deathlok'` instead of `name = 'Deathlok'` to use the correct column name from the proper table. The amended query now correctly retrieves power names through proper table relationships instead of attempting to access them directly from the wrong table."
        ],
        "rules": [
            "1) When answering about \"superpowers of the superhero called Deathlok\": make sure the output order: T3.power_name\n2) When the question mentions \"superhero called Deathlok\": \"Deathlok\" actually means \"T1.superhero_name = 'Deathlok'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T1.id = T2.hero_id and keep only matching pairs (inner match)\n4) When combining T2 and T3 for shared entities: link rows where T2.power_id = T3.id and keep only matching pairs (inner match)\n5) When selecting superpowers: use T3.power_name instead of superpower from the original table"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT superpower FROM superheroes WHERE name = 'Deathlok';",
            "SELECT T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T1.superhero_name = 'Deathlok'"
        ],
        "rule_sql": [
            "SELECT T3.power_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nWHERE T1.superhero_name = 'Deathlok'\nORDER BY T3.power_name"
        ],
        "amend_res": 1
    },
    "405": {
        "db_id": "card_games",
        "question": "How many Brazilian Portuguese translated sets are inside the Commander block?",
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'",
        "amends": [
            "Do select `COUNT(T1.id)` instead of `COUNT(*)` to count specific records. Do add `INNER JOIN set_translations AS T2 ON T1.code = T2.setCode` instead of querying only the `sets` table to incorporate translation data. Do use `T2.language = 'Portuguese (Brazil)'` instead of `language = 'Brazilian Portuguese'` to match the correct language designation in the translations table. Do reference `T1.block` instead of just `block` to properly qualify the column from the joined table. The amended query now correctly counts Commander sets with Brazilian Portuguese translations by joining the necessary tables and using the appropriate language identifier."
        ],
        "rules": [
            "1) When counting translated sets: use COUNT(T1.id) instead of COUNT(*) to count specific records. 2) When the question mentions \"Brazilian Portuguese\": this actually means \"Portuguese (Brazil)\" in the schema, so use T2.language = 'Portuguese (Brazil)' exactly. 3) When combining sets and set_translations tables: link rows where T1.code = T2.setCode and keep only matching pairs (inner match). 4) When referencing the block column: use T1.block to properly qualify the column from the joined table. 5) When answering about \"Commander block\": use T1.block = 'Commander' exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM sets WHERE language = 'Brazilian Portuguese' AND block = 'Commander';",
            "SELECT COUNT(T1.id) \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T1.code = T2.setCode \nWHERE T1.block = 'Commander' \nAND T2.language = 'Portuguese (Brazil)'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.id) \nFROM sets T1 \nINNER JOIN set_translations T2 ON T1.code = T2.setCode \nWHERE T1.block = 'Commander' \nAND T2.language = 'Portuguese (Brazil)'"
        ],
        "amend_res": 1
    },
    "1202": {
        "db_id": "thrombosis_prediction",
        "question": "How many male patients who underwent testing between 1995 and 1997 and were subsequently diagnosed with Behcet disease did not stay in the hospital for treatment?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'Behcet' AND T1.SEX = 'M' AND STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1995' AND '1997' AND T1.Admission = '-'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(*)` to count specific non-null values. Do reference `Patient AS T1` and `Examination AS T2` instead of `patients p`, `tests t`, and `diagnoses d` tables. Do use `INNER JOIN` on `T1.ID = T2.ID` instead of separate joins on patient_id. Do filter with `T2.Diagnosis = 'Behcet'` instead of `d.diagnosis = 'Behcet disease'`. Do use `T1.SEX = 'M'` instead of `p.gender = 'Male'`. Do extract year with `STRFTIME('%Y', T2.\"Examination Date\") BETWEEN '1995' AND '1997'` instead of date range filtering on test_date. Do filter with `T1.Admission = '-'` instead of `p.hospital_stay_duration > 0`. The amended query now correctly counts patients with Behcet diagnosis examinations between 1995-1997 using the proper table structure and filtering conditions."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific non-null values. 2) When referring to tables: use Patient AS T1 and Examination AS T2 instead of patients, tests, and diagnoses tables. 3) When combining Patient and Examination tables: use INNER JOIN on T1.ID = T2.ID instead of separate joins on patient_id. 4) When filtering for Behcet disease: use T2.Diagnosis = 'Behcet' instead of 'Behcet disease'. 5) When filtering for male patients: use T1.SEX = 'M' instead of gender = 'Male'. 6) When filtering for examination years 1995-1997: use STRFTIME('%Y', T2.\"Examination Date\") BETWEEN '1995' AND '1997' instead of date range filtering on test_date. 7) When filtering for patients who did not stay in hospital: use T1.Admission = '-' instead of hospital_stay_duration > 0."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN tests t ON p.patient_id = t.patient_id\nJOIN diagnoses d ON p.patient_id = d.patient_id\nWHERE p.gender = 'Male'\nAND t.test_date BETWEEN '1995-01-01' AND '1997-12-31'\nAND d.diagnosis = 'Behcet disease'\nAND p.hospital_stay_duration > 0",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND STRFTIME('%Y', T2.\"Examination Date\") BETWEEN '1995' AND '1997'\nAND T2.Diagnosis = 'Behcet'\nAND T1.Admission = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND STRFTIME('%Y', T2.\"Examination Date\") BETWEEN '1995' AND '1997'\nAND T2.Diagnosis = 'Behcet'\nAND T1.Admission = '-'"
        ],
        "amend_res": 1
    },
    "1227": {
        "db_id": "thrombosis_prediction",
        "question": "What is the average age of the male patient with high cholesterol?",
        "ground_truth": "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-CHO` >= 250 AND T1.SEX = 'M'",
        "amends": [
            "Do calculate age using `STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)` instead of using a simple `age` column. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only a `patients` table. Do filter for `T2.\"T-CHO\" >= 250` instead of `cholesterol = 'high'` to use a numeric threshold. Do filter for `T1.SEX = 'M'` instead of `gender = 'female'` to target male patients. The amended query now correctly calculates age from birthdate, joins necessary tables for laboratory data, uses precise numeric cholesterol criteria, and matches the target demographic."
        ],
        "rules": [
            "1) When calculating patient age: compute age using STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday) instead of using a simple age column. 2) When combining patient and laboratory data: join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using inner match. 3) When identifying high cholesterol: filter for T2.\"T-CHO\" >= 250 instead of cholesterol = 'high' to use the numeric threshold. 4) When targeting male patients: filter for T1.SEX = 'M' instead of gender = 'female'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM patients WHERE gender = 'female' AND cholesterol = 'high';",
            "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) AS average_age\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.\"T-CHO\" >= 250"
        ],
        "rule_sql": [
            "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) AS average_age\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.\"T-CHO\" >= 250"
        ],
        "amend_res": 1
    },
    "459": {
        "db_id": "card_games",
        "question": "Which card costs more converted mana, \"Serra Angel\" or \"Shrine Keeper\"?",
        "ground_truth": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1",
        "amends": [
            "Do select only `name` instead of selecting multiple columns with aliases like `card1`, `card2`, `cost1`, and `cost2`. Do use a single table source with an `IN` filter instead of a cross join between two instances of the same table. Do filter with `name IN ('Serra Angel', 'Shrine Keeper')` instead of separate equality conditions on different table aliases. Do order by `convertedManaCost` instead of ordering by multiple cost columns from different table instances. Do return a single row with `LIMIT 1` instead of potentially multiple rows from the cross join. The amended query now correctly retrieves card names from the specified list ordered by mana cost, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about specific card names like \"Serra Angel\" and \"Shrine Keeper\": filter the cards table using name IN ('Serra Angel', 'Shrine Keeper') with exact case and spacing. 2) When comparing converted mana costs between cards: order the results by convertedManaCost in descending order to find the highest cost card. 3) When the question asks which card costs more: return only the top result using LIMIT 1 to get the single highest cost card. 4) When selecting output columns: only include the name column instead of multiple columns with aliases like card1, card2, cost1, and cost2."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    c1.name AS card1, \n    c2.name AS card2,\n    c1.converted_mana_cost AS cost1,\n    c2.converted_mana_cost AS cost2\nFROM \n    cards c1,\n    cards c2\nWHERE \n    c1.name = 'Serra Angel' \n    AND c2.name = 'Shrine Keeper'\nORDER BY \n    c1.converted_mana_cost DESC, \n    c2.converted_mana_cost DESC\nLIMIT 1;",
            "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1096": {
        "db_id": "european_football_2",
        "question": "Calculate the average overall rating of Pietro Marino.",
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Pietro Marino'",
        "amends": [
            "Do use `CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id)` instead of `AVG(overall_rating)` to calculate the average with proper casting. Do join `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only the `players` table to access the ratings data. Do filter on `t1.player_name = 'Pietro Marino'` instead of separate `first_name` and `last_name` conditions to match the combined name field. The amended query now correctly calculates the average rating by joining the necessary tables and handles the data type conversion properly."
        ],
        "rules": [
            "1) When calculating an average rating: use CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) instead of AVG(overall_rating) to handle proper data type conversion. 2) When accessing player rating data: join Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id to combine player information with ratings. 3) When filtering for a player by name: use t1.player_name = 'Pietro Marino' to match the combined name field exactly. 4) When counting entities for average calculation: use COUNT(t2.id) as the counting key for Player_Attributes table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(overall_rating) FROM players WHERE first_name = 'Pietro' AND last_name = 'Marino';",
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Pietro Marino'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Pietro Marino';"
        ],
        "amend_res": 1
    },
    "455": {
        "db_id": "card_games",
        "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "amends": [
            "Do use `DISTINCT` for the name selection instead of omitting it. Do filter on `isPromo = 1` instead of `type = 'promotional painting'`. Do filter on `side IS NOT NULL` instead of `face_count > 1`. The amended query now correctly identifies promotional cards with non-null sides using the appropriate boolean flag and null check instead of string matching and numeric comparison."
        ],
        "rules": [
            "1) When the question asks for cards that are promotional: filter using \"isPromo = 1\" instead of string matching on type. 2) When the question asks for cards with multiple faces: filter using \"side IS NOT NULL\" instead of numeric comparison on face_count. 3) When listing card names: use DISTINCT to ensure each name appears only once in the results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE type = 'promotional painting' AND face_count > 1;",
            "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "159": {
        "db_id": "financial",
        "question": "List all the withdrawals in cash transactions that the client with the id 3356 makes.",
        "ground_truth": "SELECT T4.trans_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 3356 AND T4.operation = 'VYBER'",
        "amends": [
            "Do use explicit column selection `T4.trans_id` instead of `SELECT *`. Do join tables `client AS T1`, `disp AS T2`, `account AS T3`, and `trans AS T4` through proper relationships instead of querying only `transactions`. Do use `INNER JOIN` on `T1.client_id = T2.client_id` instead of no join condition. Do use `INNER JOIN` on `T2.account_id = T3.account_id` instead of no join condition. Do use `INNER JOIN` on `T3.account_id = T4.account_id` instead of no join condition. Do filter on `T1.client_id = 3356` instead of `client_id = 3356`. Do filter on `T4.operation = 'VYBER'` instead of `transaction_type = 'withdrawal' AND payment_method = 'cash'`. The amended query now correctly retrieves transaction IDs by properly navigating the client-account-transaction relationship structure."
        ],
        "rules": [
            "1) When answering about \"withdrawals in cash transactions for client with id 3356\": make sure the output order: T4.trans_id. 2) When the question mentions \"client with the id 3356\": \"client_id\" actually means \"T1.client_id = 3356\" in schema. 3) When the question mentions \"withdrawals in cash transactions\": \"withdrawal\" and \"cash\" actually mean \"T4.operation = 'VYBER'\" in schema. 4) When combining T1, T2, T3, and T4 for shared entities: link rows where T1.client_id = T2.client_id, T2.account_id = T3.account_id, and T3.account_id = T4.account_id; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 6) When handling text literals: do not change case, spacing, or punctuation for 'VYBER'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM transactions WHERE client_id = 3356 AND transaction_type = 'withdrawal' AND payment_method = 'cash';",
            "SELECT T4.trans_id\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN account AS T3 ON T2.account_id = T3.account_id\nINNER JOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 3356\nAND T4.operation = 'VYBER'"
        ],
        "rule_sql": [
            "SELECT T4.trans_id\nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN account T3 ON T2.account_id = T3.account_id\nINNER JOIN trans T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 3356\nAND T4.operation = 'VYBER'\nORDER BY T4.trans_id"
        ],
        "amend_res": 1
    },
    "535": {
        "db_id": "codebase_community",
        "question": "Among the users who have more than 100 upvotes, how many of them have more then 1 downvotes?",
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Upvotes > 100 AND Downvotes > 1",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE upvotes > 100 AND downvotes > 1;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM users \nWHERE UpVotes > 100 AND DownVotes > 1"
        ],
        "amend_res": 1
    },
    "1017": {
        "db_id": "formula_1",
        "question": "Please list the location coordinates of the circuits whose lap record is 1:29.488.",
        "ground_truth": "SELECT T3.lat, T3.lng FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T1.time = '1:29.488'",
        "amends": [
            "Do select `T3.lat` and `T3.lng` instead of `latitude` and `longitude`. Do join `lapTimes AS T1` and `races AS T2` with `INNER JOIN` on `T1.raceId = T2.raceId` instead of querying only the `circuits` table. Do add another `INNER JOIN` to `circuits AS T3` on `T2.circuitId = T3.circuitId` instead of directly selecting from circuits. Do filter on `T1.time = '1:29.488'` instead of `lap_record = '1:29.488'` to properly reference the lap time field. The amended query now correctly joins through the necessary tables to find circuit coordinates based on lap time records and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for location coordinates of circuits: select \"T3.lat\" and \"T3.lng\" instead of latitude and longitude. 2) When finding circuits by lap record time: join \"lapTimes AS T1\" and \"races AS T2\" using inner match where \"T1.raceId = T2.raceId\". 3) When connecting to circuit coordinates: join \"circuits AS T3\" using inner match where \"T2.circuitId = T3.circuitId\". 4) When filtering for lap record time '1:29.488': use the exact condition \"T1.time = '1:29.488'\" instead of lap_record."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT latitude, longitude FROM circuits WHERE lap_record = '1:29.488';",
            "SELECT T3.lat, T3.lng\nFROM lapTimes AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nINNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId\nWHERE T1.time = '1:29.488';"
        ],
        "rule_sql": [
            "SELECT T3.lat, T3.lng\nFROM lapTimes AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nINNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId\nWHERE T1.time = '1:29.488'"
        ],
        "amend_res": 1
    },
    "359": {
        "db_id": "card_games",
        "question": "What is the type of the card \"Ancestor's Chosen\" as originally printed?",
        "ground_truth": "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL",
        "amends": [
            "Do select `originalType` instead of `card_type` and do add `AND originalType IS NOT NULL` instead of omitting it, while also using `name` instead of `card_name` for the filter condition. The amended query now matches RIGHT_SQL's behavior by correctly selecting from the appropriate column with proper null handling."
        ],
        "rules": [
            "1) When the question asks for \"type of the card\" as originally printed: select \"originalType\" instead of \"card_type\" from the cards table. 2) When filtering by card name \"Ancestor's Chosen\": use \"name\" = 'Ancestor\\'s Chosen' as the filter condition. 3) When selecting original type information: include the condition \"originalType\" IS NOT NULL to exclude null values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_type FROM cards WHERE card_name = 'Ancestor\\'s Chosen';",
            "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "1037": {
        "db_id": "european_football_2",
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "amends": [
            "Do join `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only `players` table. Do use `SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'` for year extraction instead of `birth_year BETWEEN 1987 AND 1992`. Do reference `t2.preferred_foot` instead of `preferred_foot` alone. Do use `t1.id` for counting instead of `*` and handle NULL with `ELSE NULL`. Do add explicit `CAST(... AS REAL)` for floating-point division instead of implicit conversion. Do rename the result column to `percent` instead of `percentage_left_foot`. The amended query now correctly joins player attributes and handles year extraction from date strings."
        ],
        "rules": [
            "1) When answering about percentage of players who prefer left foot: join Player as T1 with Player_Attributes as T2 using T1.player_api_id = T2.player_api_id to access preferred_foot information. 2) When filtering players born between 1987 and 1992: extract year from T1.birthday using SUBSTR(T1.birthday, 1, 4) and check if it's between '1987' AND '1992'. 3) When counting players who prefer left foot: use COUNT(CASE WHEN T2.preferred_foot = 'left' THEN T1.id ELSE NULL END) to count only left-footed players. 4) When calculating the percentage: compute (left-footed count * 100.0 / total count) with CAST(... AS REAL) for floating-point division. 5) When naming the result column: use percent as the output column name instead of percentage_left_foot. 6) When counting total players: use T1.id as the counting key instead of counting all rows with *."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN preferred_foot = 'left' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_left_foot\nFROM players\nWHERE birth_year BETWEEN 1987 AND 1992;",
            "SELECT \n    CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) / COUNT(t1.id) * 100 AS percent\nFROM \n    Player AS t1 \nINNER JOIN \n    Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(COUNT(CASE WHEN T2.preferred_foot = 'left' THEN T1.id ELSE NULL END) * 100.0 / COUNT(T1.id) AS REAL) AS percent\nFROM \n    Player AS T1\nJOIN \n    Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\nWHERE \n    SUBSTR(T1.birthday, 1, 4) BETWEEN '1987' AND '1992';"
        ],
        "amend_res": 1
    },
    "1003": {
        "db_id": "formula_1",
        "question": "How many accidents did the driver who had the highest number accidents in the Canadian Grand Prix have?",
        "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN status AS T3 on T1.statusId = T3.statusId WHERE T3.statusId = 3 AND T2.name = 'Canadian Grand Prix' GROUP BY T1.driverId ORDER BY COUNT(T1.driverId) DESC LIMIT 1",
        "amends": [
            "Do use `results` and `races` tables with proper joins instead of querying only the `accidents` table. Do join `results` with `races` on `raceId` instead of missing this relationship. Do join `results` with `status` on `statusId` instead of omitting status filtering. Do filter with `statusId = 3` instead of missing this accident condition. Do filter with `name = 'Canadian Grand Prix'` instead of incorrect `race` column. Do aggregate `COUNT(T1.driverId)` with `GROUP BY T1.driverId` instead of incorrect subquery approach. Do order by `COUNT(T1.driverId) DESC` instead of ordering a subquery result. The amended query now correctly counts accidents by driver for the Canadian Grand Prix using proper table relationships and status filtering."
        ],
        "rules": [
            "1) When answering about accidents in the Canadian Grand Prix: use tables \"results\" as T1, \"races\" as T2, and \"status\" as T3 with proper joins instead of querying only one table. 2) When combining T1 and T2 for shared race information: link rows where T1.\"raceId\" = T2.\"raceId\" exactly and keep only matching pairs (inner match). 3) When combining T1 and T3 for status information: link rows where T1.\"statusId\" = T3.\"statusId\" exactly and keep only matching pairs (inner match). 4) When filtering for accident status: use T1.\"statusId\" = 3 instead of missing this condition. 5) When filtering for Canadian Grand Prix: use T2.\"name\" = 'Canadian Grand Prix' instead of incorrect column references. 6) When counting accidents by driver: compute COUNT(T1.\"driverId\") with GROUP BY T1.\"driverId\" instead of incorrect subquery approaches. 7) When finding the driver with highest number of accidents: order by COUNT(T1.\"driverId\") DESC and take the first row. 8) When the question asks for count of accidents for the top driver: return the maximum COUNT(T1.\"driverId\") value from the ordered results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accidents WHERE driver_id = (SELECT driver_id FROM accidents WHERE race = 'Canadian Grand Prix' GROUP BY driver_id ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT COUNT(*) as accident_count\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.name = 'Canadian Grand Prix'\nAND r.statusId = 3\nGROUP BY r.driverId\nORDER BY accident_count DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.driverId) AS accident_count\nFROM results AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nINNER JOIN status AS T3 ON T1.statusId = T3.statusId\nWHERE T2.name = 'Canadian Grand Prix'\nAND T1.statusId = 3\nGROUP BY T1.driverId\nORDER BY accident_count DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "437": {
        "db_id": "card_games",
        "question": "Among black card borders, which card has full artwork?",
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1",
        "amends": [
            "Do select `id` instead of `*` in the SELECT list. Do use column name `borderColor` instead of `border_color` in the WHERE filter. Do use column name `isFullArt` with value `1` instead of `artwork` with value `'full'` in the WHERE filter. The amended query now correctly selects only the id column and uses the proper column names and boolean value syntax to match the intended behavior."
        ],
        "rules": [
            "1) When selecting columns from the cards table: choose only the \"id\" column instead of all columns. 2) When filtering for black border cards: use the exact column name \"borderColor\" with literal value 'black'. 3) When filtering for full artwork cards: use the exact column name \"isFullArt\" with integer value 1 instead of text value 'full'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE border_color = 'black' AND artwork = 'full';",
            "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1;"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1;"
        ],
        "amend_res": 1
    },
    "337": {
        "db_id": "toxicology",
        "question": "List the element and bond type included in the molecule with molecule ID of TR002.",
        "ground_truth": "SELECT DISTINCT T1.element, T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR002'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the FROM clause to use `atom AS T1 INNER JOIN bond AS T2` instead of a single table `molecules`. Do add the join condition `ON T1.molecule_id = T2.molecule_id` instead of no join. Do change the WHERE filter to reference `T1.molecule_id` instead of `molecule_id` from a single table. The amended query now correctly joins atom and bond tables to retrieve distinct element and bond_type combinations for the specified molecule, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"element and bond type included in the molecule\": make sure the output order: element, bond_type. 2) When the question mentions \"molecule with molecule ID of TR002\": \"TR002\" actually means T1.molecule_id = 'TR002' in schema. 3) When combining T1 (atom) and T2 (bond) for shared molecules: link rows where T1.molecule_id = T2.molecule_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When retrieving element and bond_type combinations: use DISTINCT to return only unique combinations of these two columns. 5) When handling text literals: do not change case, spacing, or punctuation - use exact value 'TR002'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element, bond_type FROM molecules WHERE molecule_id = 'TR002';",
            "SELECT DISTINCT T1.element, T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR002'"
        ],
        "rule_sql": [
            "SELECT DISTINCT a.element, b.bond_type\nFROM atom a\nINNER JOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.molecule_id = 'TR002'\nORDER BY a.element, b.bond_type;"
        ],
        "amend_res": 1
    },
    "862": {
        "db_id": "formula_1",
        "question": "For the Bahrain Grand Prix in 2007, how many drivers not finished the game?",
        "ground_truth": "SELECT COUNT(T3.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2007 AND T1.name = 'Bahrain Grand Prix' AND T2.time IS NULL",
        "amends": [
            "Do join `races AS T1` and `results AS T2` on `T2.raceId = T1.raceId` instead of querying `drivers` directly without proper race context. Do join `drivers AS T3` on `T3.driverId = T2.driverId` instead of missing the relationship between drivers and race results. Do filter on `T1.year = 2007` and `T1.name = 'Bahrain Grand Prix'` instead of using `grand_prix = 'Bahrain'` which lacks the full event name. Do check `T2.time IS NULL` instead of `finished = 'No'` to properly identify drivers who did not finish. Do count `T3.driverId` instead of `COUNT(*)` to ensure accurate driver counting. The amended query now correctly identifies drivers who did not finish the 2007 Bahrain Grand Prix by leveraging proper table relationships and null time values."
        ],
        "rules": [
            "1) When answering about drivers not finishing a specific Grand Prix: combine races table as T1, results table as T2, and drivers table as T3 using the exact join conditions T2.raceId = T1.raceId and T3.driverId = T2.driverId. 2) When filtering for the Bahrain Grand Prix in 2007: use T1.year = 2007 and T1.name = 'Bahrain Grand Prix' exactly as specified. 3) When identifying drivers who did not finish: check T2.time IS NULL instead of using a 'No' value. 4) When counting drivers: count T3.driverId to ensure accurate driver counting rather than counting all rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE grand_prix = 'Bahrain' AND year = 2007 AND finished = 'No';",
            "SELECT COUNT(DISTINCT T3.driverId) \nFROM races AS T1 \nJOIN results AS T2 ON T2.raceId = T1.raceId \nJOIN drivers AS T3 ON T3.driverId = T2.driverId \nWHERE T1.year = 2007 \nAND T1.name = 'Bahrain Grand Prix' \nAND T2.time IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T3.driverId) \nFROM races AS T1\nJOIN results AS T2 ON T2.raceId = T1.raceId\nJOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T1.year = 2007 \nAND T1.name = 'Bahrain Grand Prix'\nAND T2.time IS NULL"
        ],
        "amend_res": 1
    },
    "295": {
        "db_id": "toxicology",
        "question": "How many atoms belong to the molecule that element is hydrogen and labeled with carcinogenic compound?",
        "ground_truth": "SELECT COUNT(T1.atom_id) AS atomnums_h FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'h'",
        "amends": [
            "Do use `COUNT(T1.atom_id)` with alias `atomnums_h` instead of `COUNT(*)` without an alias. Do specify `atom AS T1` and `molecule AS T2` with table aliases instead of referencing tables without aliases. Do use `INNER JOIN` with explicit `ON T1.molecule_id = T2.molecule_id` instead of a subquery with `IN` condition. Do move the molecule filter to the `WHERE` clause as `T2.label = '+'` instead of the subquery condition `label = 'carcinogenic compound'`. Do keep the element filter as `T1.element = 'h'` instead of `element = 'hydrogen'`. The amended query now correctly joins the tables and counts specific atom IDs with proper filtering conditions.",
            "Do change the WHERE filter to `T2.label = '+'` instead of `T2.label = 'carcinogenic compound'` while keeping the `T1.element = 'h'` condition. The amended query now correctly filters for molecules labeled with '+' and hydrogen atoms, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"atoms belonging to molecules\": use INNER JOIN between atom AS T1 and molecule AS T2 where T1.molecule_id = T2.molecule_id to combine tables and keep only matching pairs. 2) When counting atoms: use COUNT(T1.atom_id) with alias atomnums_h instead of generic COUNT(*). 3) When filtering for hydrogen element: use T1.element = 'h' instead of 'hydrogen'. 4) When filtering for carcinogenic compound label: use T2.label = '+' instead of 'carcinogenic compound'.",
            "1) When the question mentions \"labeled with carcinogenic compound\": the exact literal value in the schema is '+' not 'carcinogenic compound'. 2) When filtering for hydrogen atoms: use the exact literal 'h' for the element condition. 3) When counting atoms: count using the atom_id column from the atom table (T1.atom_id). 4) When combining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM atoms WHERE element = 'hydrogen' AND molecule_id IN (SELECT molecule_id FROM molecules WHERE label = 'carcinogenic compound')",
            "SELECT COUNT(T1.atom_id) AS atomnums_h\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'h' AND T2.label = 'carcinogenic compound'",
            "SELECT COUNT(T1.atom_id) AS atomnums_h\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'h' AND T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.atom_id) AS atomnums_h FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' AND T2.label = '+'"
        ],
        "amend_res": 1
    },
    "427": {
        "db_id": "card_games",
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "amends": [
            "Do join `sets AS T1` and `set_translations AS T2` instead of querying only `cards` table. Do use `INNER JOIN` on `T1.code = T2.setCode` instead of no join condition. Do select `T2.language` instead of `language` without table qualification. Do filter on `T1.mcmName = 'Archenemy'` instead of `set_name = 'Archenemy'`. Do keep `T2.setCode = 'ARC'` filter but with table qualification instead of unqualified `set_code = 'ARC'`. Do remove `DISTINCT` instead of keeping it since the join and filters ensure uniqueness. The amended query now correctly retrieves language information from the proper translation tables instead of assuming it exists in the cards table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about languages available in a set: use the set_translations table (T2) to access language information instead of the cards table. 2) When combining set information with translations: join sets AS T1 and set_translations AS T2 using T1.code = T2.setCode with an inner match. 3) When filtering for the set known as Archenemy on the magic card market: use T1.mcmName = 'Archenemy' instead of set_name = 'Archenemy'. 4) When filtering for set code 'ARC': use T2.setCode = 'ARC' with proper table qualification. 5) When selecting languages: use T2.language instead of unqualified language. 6) When the join and filters ensure uniqueness: do not use DISTINCT as it is redundant."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT language FROM cards WHERE set_name = 'Archenemy' AND set_code = 'ARC';",
            "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'"
        ],
        "rule_sql": [
            "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'"
        ],
        "amend_res": 1
    },
    "759": {
        "db_id": "superhero",
        "question": "What is the eye clolour of the heaviest superhero?",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id ORDER BY T1.weight_kg DESC LIMIT 1",
        "amends": [
            "Do join `superhero` table with `colour` table via `INNER JOIN` on `T1.eye_colour_id = T2.id` instead of querying only the `superheroes` table. Do select `T2.colour` from the joined table instead of directly selecting `eye_color` from a single table. Do reference `T1.weight_kg` for ordering instead of `weight`. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves eye color information from the related colour table through proper join relationships instead of assuming the color value exists directly in the superhero table."
        ],
        "rules": [
            "1) When the question asks about eye color: join the superhero table (T1) with the colour table (T2) using T1.eye_colour_id = T2.id to get the actual color value from T2.colour instead of using T1.eye_color directly. 2) When determining the heaviest superhero: use T1.weight_kg for ordering by weight in descending order instead of weight. 3) When selecting the eye color of the heaviest superhero: after joining tables and ordering by T1.weight_kg DESC, take only the first row to get the single heaviest superhero's eye color from T2.colour."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eye_color FROM superheroes ORDER BY weight DESC LIMIT 1;",
            "SELECT T2.colour \nFROM superhero T1\nINNER JOIN colour T2 ON T1.eye_colour_id = T2.id\nORDER BY T1.weight_kg DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.colour \nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nORDER BY s.weight_kg DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "851": {
        "db_id": "formula_1",
        "question": "Please list the positions of the circuits built by the constructor Renault.",
        "ground_truth": "SELECT DISTINCT T1.position FROM constructorStandings AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T2.name = 'Renault'",
        "amends": [
            "Do use `DISTINCT T1.position` instead of just `position` to eliminate duplicate results. Do join `constructorStandings AS T1` and `constructors AS T2` instead of querying only `circuits` table. Do use `INNER JOIN` with `T2.constructorId = T1.constructorId` instead of no join condition. Do filter on `T2.name = 'Renault'` instead of `constructor = 'Renault'` to correctly reference the constructor name field. The amended query now properly retrieves distinct positions from the constructor standings for the Renault constructor, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"positions of circuits built by constructor Renault\": make sure the output order: T1.position. 2) When the question mentions \"circuits built by constructor Renault\": this actually means \"positions from constructorStandings table (T1) joined with constructors table (T2) where T2.name = 'Renault'\". 3) When combining T1 (constructorStandings) and T2 (constructors) for shared entities: link rows where T2.constructorId = T1.constructorId and keep only matching pairs (inner match). 4) When filtering for constructor Renault: use exact literal value 'Renault' for T2.name. 5) When retrieving positions: use DISTINCT T1.position to eliminate duplicate results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT position FROM circuits WHERE constructor = 'Renault';",
            "SELECT DISTINCT T1.position FROM constructorStandings AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T2.name = 'Renault'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.position\nFROM constructorStandings T1\nINNER JOIN constructors T2 ON T2.constructorId = T1.constructorId\nWHERE T2.name = 'Renault'\nORDER BY T1.position"
        ],
        "amend_res": 1
    },
    "323": {
        "db_id": "toxicology",
        "question": "Is molecule TR000 is carcinogenic or not?",
        "ground_truth": "SELECT label FROM molecule AS T WHERE T.molecule_id = 'TR000'",
        "amends": [
            "Do select `label` instead of `carcinogenic` from the table. Do use table alias `T` instead of omitting it in the FROM clause. Do reference the column as `T.molecule_id` instead of just `molecule_id` in the WHERE condition. The amended query now correctly retrieves the label column from the molecule table using proper table aliasing."
        ],
        "rules": [
            "1) When answering about whether molecule TR000 is carcinogenic: make sure the output order: label from table molecule. 2) When the question mentions \"carcinogenic\": \"carcinogenic\" actually means \"label in schema\" with values like '+' and '-'. 3) When filtering for a specific molecule_id: use exact literal 'TR000' with exact column token T.molecule_id. 4) When selecting from table molecule: use table alias T as shown in the amends."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT carcinogenic FROM molecules WHERE molecule_id = 'TR000';",
            "SELECT label FROM molecule T WHERE T.molecule_id = 'TR000'"
        ],
        "rule_sql": [
            "SELECT T.label FROM molecule T WHERE T.molecule_id = 'TR000'"
        ],
        "amend_res": 1
    },
    "973": {
        "db_id": "formula_1",
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "ground_truth": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "amends": [
            "Do select only `T2.driverId` instead of all columns with `*`. Do join `pitStops AS T1` with `drivers AS T2` using `INNER JOIN` on `T1.driverId = T2.driverId` instead of querying only `drivers` table. Do filter by `T2.nationality = 'Spanish'` instead of `nationality = 'Spanish'` with proper table qualification. Do use `STRFTIME('%Y', T2.dob) < '1982'` for year comparison instead of direct date comparison `dob < '1982-01-01'`. Do order by `T1.time DESC` instead of `lap_time ASC`. The amended query now correctly retrieves Spanish drivers born before 1982 with their pit stop times in descending order."
        ],
        "rules": [
            "1) When answering about \"top 10 Spanish drivers who were born before 1982 and have the latest lap time\": make sure the output order: T2.driverId. 2) When combining pitStops and drivers tables: link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match). 3) When the question mentions \"Spanish\": \"Spanish\" actually means T2.nationality = 'Spanish' in schema. 4) When the question mentions \"born before 1982\": use STRFTIME('%Y', T2.dob) < '1982' for year comparison. 5) When the question mentions \"latest lap time\": \"latest lap time\" actually means T1.time in descending order. 6) When the question mentions \"top 10\": rank rows by T1.time in descending direction and keep the first 10 rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM drivers WHERE nationality = 'Spanish' AND dob < '1982-01-01' ORDER BY lap_time ASC LIMIT 10;",
            "SELECT T2.driverId\nFROM pitStops AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982'\nORDER BY T1.time DESC\nLIMIT 10;"
        ],
        "rule_sql": [
            "SELECT T2.driverId\nFROM pitStops T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'Spanish'\nAND STRFTIME('%Y', T2.dob) < '1982'\nORDER BY T1.time DESC\nLIMIT 10"
        ],
        "amend_res": 1
    },
    "872": {
        "db_id": "formula_1",
        "question": "In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?",
        "ground_truth": "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'",
        "amends": [
            "Do select `T2.code` from the `drivers` table instead of `code` from the `drivers` table directly. Do join `qualifying AS T1` with `drivers AS T2` using `INNER JOIN` on `T2.driverId = T1.driverId` instead of querying only the `drivers` table. Do filter on `T1.raceId = 45` instead of `race_id = 45`. Do use `T1.q3 LIKE '1:33%'` for pattern matching instead of exact equality `q3_time = '0:01:33'`. The amended query now correctly joins the qualifying and drivers tables to find drivers with qualifying times starting with '1:33' for race ID 45, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about driver codes for qualifying times: make sure the output order: T2.code 2) When the question mentions \"race No. 45\": \"race No. 45\" actually means \"T1.raceId = 45\" in schema 3) When the question mentions \"Q3 time as 0:01:33\": \"Q3 time as 0:01:33\" actually means \"T1.q3 LIKE '1:33%'\" for pattern matching 4) When combining qualifying and drivers tables: link rows where T2.driverId = T1.driverId exactly as shown; keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM drivers WHERE race_id = 45 AND q3_time = '0:01:33';",
            "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'"
        ],
        "rule_sql": [
            "SELECT T2.code FROM qualifying T1 JOIN drivers T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'"
        ],
        "amend_res": 1
    },
    "699": {
        "db_id": "codebase_community",
        "question": "When did the user known as 'IrishStat' create his or her account?",
        "ground_truth": "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat'",
        "amends": [
            "Do reference `CreationDate` column instead of `created_at` in the SELECT list. Do filter on `DisplayName` column with value 'IrishStat' instead of `username` column in the WHERE clause. The amended query now correctly retrieves the creation date using the appropriate column names that match the actual database schema."
        ],
        "rules": [
            "1) When the question asks about account creation date: use the \"CreationDate\" column from the users table instead of \"created_at\". 2) When filtering for a specific username: use the \"DisplayName\" column with exact literal value 'IrishStat' instead of the \"username\" column. 3) When retrieving creation date information: ensure the output column is \"CreationDate\" from the users table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT created_at FROM users WHERE username = 'IrishStat';",
            "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat'"
        ],
        "rule_sql": [
            "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat';"
        ],
        "amend_res": 1
    },
    "162": {
        "db_id": "financial",
        "question": "What is the region of the client with the id 3541 from?",
        "ground_truth": "SELECT T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
        "amends": [
            "Do select `T1.A3` from the `district` table instead of `region` from the `clients` table. Do join `district AS T1` with `client AS T2` using `INNER JOIN` on `T1.district_id = T2.district_id` instead of querying only the `clients` table. Do filter on `T2.client_id = 3541` instead of `client_id = 3541` to properly reference the joined table. The amended query now correctly retrieves region data from the district table through proper table relationships instead of directly from a potentially incorrect source, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"region of the client with id 3541\": select T1.A3 from the district table instead of region from the clients table. 2) When combining district and client tables: link rows where T1.district_id = T2.district_id using an inner join to keep only matching pairs. 3) When filtering for client with id 3541: use T2.client_id = 3541 to properly reference the joined table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT region FROM clients WHERE client_id = 3541;",
            "SELECT T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541"
        ],
        "rule_sql": [
            "SELECT T1.A3 FROM district T1 INNER JOIN client T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541"
        ],
        "amend_res": 1
    },
    "1083": {
        "db_id": "european_football_2",
        "question": "Which player has the strongest overall strength?",
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
        "amends": [
            "Do select `t1.player_name` from the `Player` table instead of `name` from the `players` table. Do add an `INNER JOIN` with `Player_Attributes AS t2` on `t1.player_api_id = t2.player_api_id` instead of querying only a single table. Do order by `t2.overall_rating DESC` instead of `strength DESC` to use the correct rating attribute. The amended query now correctly joins the player and attributes tables to find the player with the highest overall rating."
        ],
        "rules": [
            "1) When the question asks about \"player\": use \"t1.player_name\" from the \"Player\" table instead of \"name\" from \"players\". 2) When combining player information with attributes: perform an inner join between \"Player\" as t1 and \"Player_Attributes\" as t2 using \"t1.player_api_id = t2.player_api_id\". 3) When determining \"strongest overall strength\": order by \"t2.overall_rating DESC\" instead of \"strength DESC\". 4) When selecting the top result: keep only the first row after ordering by the rating."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY strength DESC LIMIT 1;",
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t2.overall_rating DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t2.overall_rating DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "249": {
        "db_id": "toxicology",
        "question": "What are the elements of the atoms of TR144_8_19?",
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'",
        "amends": [
            "Do select only `T2.element` instead of all columns with `*`. Do query from `connected AS T1` instead of `atoms`. Do add `INNER JOIN atom AS T2` instead of omitting it. Do use join condition `T1.atom_id = T2.atom_id` instead of no join. Do filter on `T1.bond_id = 'TR144_8_19'` instead of `element = 'TR144_8_19'`. The amended query now correctly retrieves elements from atoms connected to the specified bond ID instead of incorrectly searching for an element name matching a bond ID pattern."
        ],
        "rules": [
            "1) When querying about elements of atoms connected to a specific bond: select only the element column from the atom table (T2.element) instead of all columns. 2) When the question mentions \"TR144_8_19\": this refers to a bond_id value, not an element value, so filter on T1.bond_id = 'TR144_8_19'. 3) When combining connected and atom tables: link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner join). 4) When answering about elements of atoms: query from the connected table (T1) as the base table instead of directly from atoms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM atoms WHERE element = 'TR144_8_19';",
            "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'"
        ],
        "rule_sql": [
            "SELECT T2.element FROM connected T1 INNER JOIN atom T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'"
        ],
        "amend_res": 1
    },
    "56": {
        "db_id": "california_schools",
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin city?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "amends": [
            "Do count `CDSCode` instead of `*` to count only non-null values. Do filter on `MailState = 'CA'` instead of `mailing_state = 'California'` to use the correct state abbreviation. Do add `StatusType = 'Active'` instead of omitting it to filter for active schools only. Do use proper column case `City` and `MailState` instead of lowercase versions. The amended query now correctly counts active schools in San Joaquin, California using proper state codes and column names."
        ],
        "rules": [
            "1) When counting schools: count using the canonical key \"CDSCode\" instead of counting all rows to ensure only non-null values are counted. 2) When filtering for California mailing addresses: use \"MailState = 'CA'\" instead of \"mailing_state = 'California'\" to match the correct state abbreviation format. 3) When filtering for active schools: include the condition \"StatusType = 'Active'\" to only count schools with active status. 4) When referring to column names: use exact case-sensitive identifiers \"City\" and \"MailState\" instead of lowercase versions. 5) When the question asks about schools in San Joaquin city: filter using \"City = 'San Joaquin'\" with exact case and spelling."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE mailing_state = 'California' AND city = 'San Joaquin';",
            "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND City = 'San Joaquin' AND StatusType = 'Active'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT CDSCode) \nFROM schools \nWHERE MailState = 'CA' \nAND StatusType = 'Active' \nAND City = 'San Joaquin'"
        ],
        "amend_res": 1
    },
    "674": {
        "db_id": "codebase_community",
        "question": "Who has the highest reputation? Please give the display name.",
        "ground_truth": "SELECT DisplayName FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "amends": [
            "Do use `DisplayName` instead of `display_name` for the column selection. Do add a `WHERE` filter with a subquery that finds `MAX(Reputation)` instead of ordering by `reputation ASC` and limiting to one row. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them, as the subquery approach directly identifies the maximum reputation value. The amended query now correctly identifies users with the highest reputation rather than just the first user by ascending reputation order."
        ],
        "rules": [
            "1) When the question asks for \"display name\": use the exact column token \"DisplayName\" from the users table. 2) When the question asks for the \"highest reputation\": find the maximum value of the \"Reputation\" column using MAX(Reputation) instead of ordering and limiting. 3) When identifying users with the highest reputation: use a WHERE filter with a subquery that matches users whose Reputation equals the maximum Reputation value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users ORDER BY reputation ASC LIMIT 1;",
            "SELECT DisplayName FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "rule_sql": [
            "SELECT DisplayName FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "amend_res": 1
    },
    "178": {
        "db_id": "financial",
        "question": "Which kind of credit card does client number 9 possess?",
        "evidence": "",
        "ground_truth": "SELECT T3.type FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.client_id = 9",
        "amends": [
            "Do select `T3.type` from the `card` table instead of `card_type` from `credit_cards`. Do join through the relationship chain using `INNER JOIN disp AS T2 ON T1.client_id = T2.client_id` and `INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id` instead of querying `credit_cards` directly. Do filter on `T1.client_id = 9` through the client table instead of filtering `client_id = 9` directly on the credit cards table. The amended query now correctly follows the relational path from client to disposition to card to retrieve the card type, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"which kind of credit card client number 9 possess\": make sure the output order: T3.type. 2) When the question mentions \"client number 9\": \"client number 9\" actually means \"T1.client_id = 9\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.client_id = T2.client_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T2 and T3 for shared entities: link rows where T2.disp_id = T3.disp_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_type FROM credit_cards WHERE client_id = 9;",
            "SELECT T3.type \nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN card AS T3 ON T2.disp_id = T3.disp_id\nWHERE T1.client_id = 9"
        ],
        "rule_sql": [
            "SELECT T3.type\nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN card T3 ON T2.disp_id = T3.disp_id\nWHERE T1.client_id = 9"
        ],
        "amend_res": 1
    },
    "1323": {
        "db_id": "student_club",
        "question": "List all the names of events that had an attendance of over 20 students but were not fundraisers.",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id HAVING COUNT(T2.link_to_event) > 20 EXCEPT SELECT T1.event_name FROM event AS T1  WHERE T1.type = 'Fundraiser'",
        "amends": [
            "Do select `T1.event_name` instead of `name` and use a `GROUP BY T1.event_id` with `HAVING COUNT(T2.link_to_event) > 20` instead of filtering `attendance > 20` in WHERE. Do join `event AS T1` with `attendance AS T2` using `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying a single table. Do add an EXCEPT clause to exclude events where `T1.type = 'Fundraiser'` instead of including them with `type = 'fundraiser'` in WHERE. The amended query now correctly calculates attendance counts through aggregation and properly excludes fundraiser events as specified."
        ],
        "rules": [
            "1) When answering about \"events with attendance over 20 students but not fundraisers\": make sure the output order: T1.event_name. 2) When the question mentions \"names of events\": \"names\" actually means \"T1.event_name in schema\". 3) When the question mentions \"attendance of over 20 students\": calculate attendance by counting T2.link_to_event per event group and require COUNT(T2.link_to_event) > 20. 4) When the question mentions \"not fundraisers\": exclude events where T1.type = 'Fundraiser' (note exact case and spelling). 5) When combining T1 (event) and T2 (attendance) for shared entities: link rows where T1.event_id = T2.link_to_event; keep only matching pairs (inner match). 6) When grouping by event: organize results by T1.event_id and compute requested aggregates per group."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM events WHERE attendance > 20 AND type = 'fundraiser';",
            "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_id\nHAVING COUNT(T2.link_to_event) > 20\nEXCEPT\nSELECT T1.event_name\nFROM event AS T1\nWHERE T1.type = 'Fundraiser'"
        ],
        "rule_sql": [
            "SELECT T1.event_name\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nWHERE T1.type != 'Fundraiser'\nGROUP BY T1.event_id\nHAVING COUNT(T2.link_to_event) > 20\nORDER BY T1.event_name;"
        ],
        "amend_res": 1
    },
    "621": {
        "db_id": "codebase_community",
        "question": "What are the name of badges that users who have the lowest reputation obtained?",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
        "amends": [
            "Do use `T2.Name` instead of `b.name` for the SELECT list. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use `T1.Id = T2.UserId` as the join condition instead of `b.user_id = u.id`. Do reference `T1.Reputation` instead of `u.reputation` in the WHERE clause. Do use table aliases `T1` for users and `T2` for badges instead of `u` and `b`. The amended query now correctly joins users to badges and selects badge names for users with minimum reputation, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting badge names: use T2.Name as the output column. 2) When joining users and badges tables: use INNER JOIN with the condition T1.Id = T2.UserId. 3) When filtering for users with minimum reputation: use T1.Reputation = (SELECT MIN(T1.Reputation) FROM T1). 4) When referring to table aliases: use T1 for users table and T2 for badges table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.name \nFROM badges b \nJOIN users u ON b.user_id = u.id \nWHERE u.reputation = (SELECT MIN(reputation) FROM users);",
            "SELECT T2.Name \nFROM users T1 \nINNER JOIN badges T2 ON T1.Id = T2.UserId \nWHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM users T1 \nINNER JOIN badges T2 ON T1.Id = T2.UserId \nWHERE T1.Reputation = (SELECT MIN(T1.Reputation) FROM users T1)"
        ],
        "amend_res": 1
    },
    "173": {
        "db_id": "financial",
        "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
        "ground_truth": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
        "amends": [
            "Do completely rewrite the query structure instead of using separate COUNT and SUM queries. Do use `SELECT T1.frequency, T2.k_symbol` instead of `SELECT COUNT(*)` and `SELECT SUM(amount)`. Do add `FROM account AS T1 INNER JOIN` with a subquery instead of querying `account_statements` and `transactions` tables separately. Do use a subquery that calculates `SUM(amount) AS total_amount` from the `order` table with `GROUP BY account_id, k_symbol` instead of filtering transactions by type and amount. Do join on `T1.account_id = T2.account_id` instead of filtering by account_id in WHERE clauses. Do add filter `T2.total_amount = 3539` instead of filtering individual transaction amounts. Do completely restructure the query to analyze account frequency and k_symbol patterns based on aggregated order amounts rather than counting statements and summing specific transactions. The amended query now correctly joins account information with aggregated order data to find specific patterns matching the total amount criteria."
        ],
        "rules": [
            "1) When answering about account statement release frequency and transaction purpose: make sure the output order: T1.frequency, T2.k_symbol\n2) When the question mentions \"account number 3\": \"account number 3\" actually means T1.account_id = 3 in schema\n3) When the question asks for \"how often\" account statements are released: use T1.frequency column instead of counting statement releases\n4) When the question asks for \"aim of debiting 3539 in total\": use T2.k_symbol column to show the purpose instead of summing transaction amounts\n5) When combining account and order data: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match)\n6) When filtering for total amount of 3539: apply filter T2.total_amount = 3539 instead of filtering individual transaction amounts\n7) When aggregating order data: calculate SUM(amount) AS total_amount from the order table with GROUP BY account_id, k_symbol instead of filtering transactions by type and amount"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM account_statements WHERE account_id = 3 AND statement_type = 'release'; SELECT SUM(amount) FROM transactions WHERE account_id = 3 AND transaction_type = 'debit' AND amount = 3539;",
            "SELECT T1.frequency, T2.k_symbol\nFROM account AS T1\nINNER JOIN (\n    SELECT account_id, k_symbol, SUM(amount) AS total_amount\n    FROM `order`\n    GROUP BY account_id, k_symbol\n) AS T2 ON T1.account_id = T2.account_id\nWHERE T1.account_id = 3 AND T2.total_amount = 3539"
        ],
        "rule_sql": [
            "SELECT \n    a.frequency, \n    o.k_symbol\nFROM \n    account a\nJOIN \n    `order` o ON a.account_id = o.account_id\nWHERE \n    a.account_id = 3\n    AND (\n        SELECT SUM(amount) \n        FROM `order` o2 \n        WHERE o2.account_id = a.account_id \n        AND o2.k_symbol = o.k_symbol\n    ) = 3539\nGROUP BY \n    a.frequency, o.k_symbol"
        ],
        "amend_res": 1
    },
    "1340": {
        "db_id": "student_club",
        "question": "Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.",
        "ground_truth": "SELECT SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS num FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
        "amends": [
            "Do use a single query with conditional aggregation using `CASE WHEN SUBSTR(T1.event_date, 1, 4)` instead of separate subqueries with `strftime('%Y', date)`. Do join `event AS T1` with `budget AS T2` using `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying a single `events` table without joins. Do reference `T2.spent` instead of `amount` for the calculation. Do use `SUBSTR` for year extraction instead of `strftime`. Do calculate the difference between conditional sums of `spent` amounts instead of subtracting separate subquery results. The amended query now correctly joins the event and budget tables to access the spent amounts and uses proper conditional aggregation to compute the year-over-year difference in a single pass."
        ],
        "rules": [
            "1) When calculating total amount spent by Student_Club: use T2.spent from the budget table instead of amount from events table. 2) When extracting year from event dates: use SUBSTR(T1.event_date, 1, 4) instead of strftime('%Y', date). 3) When combining event and budget tables: perform an INNER JOIN where T1.event_id = T2.link_to_event to access spent amounts. 4) When filtering for Student_Club events: use T1.organizer = 'Student_Club' exactly as specified. 5) When calculating year-over-year difference: use conditional aggregation with CASE WHEN statements for years 2019 and 2020 in a single query instead of separate subqueries."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT SUM(amount) FROM events WHERE organizer = 'Student_Club' AND strftime('%Y', date) = '2019') - \n    (SELECT SUM(amount) FROM events WHERE organizer = 'Student_Club' AND strftime('%Y', date) = '2020') \nAS amount_difference;",
            "SELECT \n    SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) -\n    SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS year_difference\nFROM \n    event AS T1\nINNER JOIN \n    budget AS T2 ON T1.event_id = T2.link_to_event;"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - \n    SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS year_difference\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.organizer = 'Student_Club'",
            "SELECT \n    SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - \n    SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS year_difference\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nWHERE T1.organizer = 'Student_Club'"
        ],
        "amend_res": 1
    },
    "415": {
        "db_id": "card_games",
        "question": "What percentage of cards with format commander and legal status do not have a content warning?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN content_warning IS NULL THEN 1 END)` to properly count boolean flags. Do join `cards AS T1` with `legalities AS T2` on `T1.uuid = T2.uuid` instead of querying only the cards table. Do move the format filter to `T2.format = 'commander'` instead of the cards table and use `T2.status = 'Legal'` instead of `legal_status = 'legal'` to reference the correct table and column. Do add explicit `CAST` to `REAL` instead of implicit decimal conversion for proper percentage calculation. Do reference `T1.id` for counting instead of `COUNT(*)` to ensure accurate row counting. The amended query now correctly joins with the legalities table and properly calculates the percentage of cards without content warnings in the commander format."
        ],
        "rules": [
            "1) When the question asks about cards with format 'commander' and legal status: join cards table as T1 with legalities table as T2 using T1.uuid = T2.uuid to combine card and legality information. 2) When filtering for commander format: use T2.format = 'commander' instead of filtering on the cards table. 3) When filtering for legal status: use T2.status = 'Legal' (with exact case) instead of legal_status = 'legal'. 4) When counting cards without content warnings: use SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) to properly handle boolean flags instead of checking for NULL values. 5) When calculating percentages: use CAST to REAL for proper decimal conversion instead of implicit conversion. 6) When counting total cards: use T1.id as the counting key instead of COUNT(*) to ensure accurate row counting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN content_warning IS NULL THEN 1 END) * 100.0 / COUNT(*)) AS percentage_without_warning\nFROM cards\nWHERE format = 'commander' AND legal_status = 'legal';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.id) * 100.0 AS percentage\nFROM \n    cards AS T1\nJOIN \n    legalities AS T2 ON T1.uuid = T2.uuid\nWHERE \n    T2.format = 'commander' \n    AND T2.status = 'Legal'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.id) * 100 AS percentage\nFROM \n    cards T1\nJOIN \n    legalities T2 ON T1.uuid = T2.uuid\nWHERE \n    T2.format = 'commander' \n    AND T2.status = 'Legal';"
        ],
        "amend_res": 1
    },
    "843": {
        "db_id": "superhero",
        "question": "List the hero ID of superheroes have intellegence as their power.",
        "ground_truth": "SELECT T1.hero_id FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Intelligence'",
        "amends": [
            "Do reference `hero_power AS T1` instead of `superheroes`, and add `INNER JOIN superpower AS T2` instead of omitting it. Do join on `T1.power_id = T2.id` instead of filtering directly on `power = 'intelligence'`. Do filter on `T2.power_name = 'Intelligence'` instead of `power = 'intelligence'` to properly reference the normalized table structure. Do select `T1.hero_id` instead of `hero_id` to explicitly specify the table alias. The amended query now correctly joins the normalized tables and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about superheroes with intelligence as their power: use table \"hero_power\" as T1 and table \"superpower\" as T2 instead of just \"superheroes\". 2) When combining hero_power and superpower tables: link rows where T1.power_id = T2.id and keep only matching pairs (inner match). 3) When filtering for intelligence power: use T2.power_name = 'Intelligence' instead of filtering directly on a power column in the hero_power table. 4) When selecting hero IDs: use T1.hero_id to explicitly specify the table alias. 5) When the question mentions \"intelligence\" as a power: \"intelligence\" actually means \"Intelligence\" in the superpower table's power_name column (note the capital 'I')."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT hero_id FROM superheroes WHERE power = 'intelligence';",
            "SELECT T1.hero_id FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Intelligence'"
        ],
        "rule_sql": [
            "SELECT T1.hero_id FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Intelligence'"
        ],
        "amend_res": 1
    },
    "1046": {
        "db_id": "european_football_2",
        "question": "What is the ADO Den Haag team freedom of movement in the 1st two thirds of the pitch?",
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPositioningClass FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_fifa_api_id = t2.team_fifa_api_id WHERE t1.team_long_name = 'ADO Den Haag'",
        "amends": [
            "Do select `t2.buildUpPlayPositioningClass` instead of `freedom_of_movement`. Do use `DISTINCT` instead of omitting it. Do join `Team AS t1 INNER JOIN Team_attributes AS t2` on `t1.team_fifa_api_id = t2.team_fifa_api_id` instead of querying only `team_stats`. Do filter on `t1.team_long_name = 'ADO Den Haag'` instead of `team_name = 'ADO Den Haag' AND pitch_zone = 'first_two_thirds'`. The amended query now correctly retrieves the positioning class from the proper tables with appropriate joins and filtering."
        ],
        "rules": [
            "1) When answering about ADO Den Haag team freedom of movement: select \"t2\".\"buildUpPlayPositioningClass\" instead of \"freedom_of_movement\". 2) When retrieving data about team attributes: use DISTINCT to ensure unique values. 3) When combining team information with team attributes: join \"Team\" AS \"t1\" INNER JOIN \"Team_attributes\" AS \"t2\" on \"t1\".\"team_fifa_api_id\" = \"t2\".\"team_fifa_api_id\" instead of querying only \"team_stats\". 4) When filtering for ADO Den Haag team: use \"t1\".\"team_long_name\" = 'ADO Den Haag' instead of filtering on \"team_name\" and \"pitch_zone\" conditions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT freedom_of_movement FROM team_stats WHERE team_name = 'ADO Den Haag' AND pitch_zone = 'first_two_thirds';",
            "SELECT DISTINCT t2.buildUpPlayPositioningClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_fifa_api_id = t2.team_fifa_api_id \nWHERE t1.team_long_name = 'ADO Den Haag'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t2.buildUpPlayPositioningClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_fifa_api_id = t2.team_fifa_api_id \nWHERE t1.team_long_name = 'ADO Den Haag'"
        ],
        "amend_res": 1
    },
    "941": {
        "db_id": "formula_1",
        "question": "How many points did Lewis Hamilton get in total in all the Formula_1 races he participated?",
        "evidence": "",
        "ground_truth": "SELECT SUM(T2.points) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'",
        "amends": [
            "Do join `drivers AS T1` and `results AS T2` on `T1.driverId = T2.driverId` instead of querying only `Formula_1_races`. Do filter on `T1.forename = 'Lewis'` and `T1.surname = 'Hamilton'` instead of `driver = 'Lewis Hamilton'`. Do select `SUM(T2.points)` from the joined results table instead of summing points directly from a single table. The amended query now correctly aggregates race points by joining driver information with race results and using proper name filtering."
        ],
        "rules": [
            "1) When answering about \"points Lewis Hamilton got in Formula 1 races\": join tables \"drivers AS T1\" and \"results AS T2\" where T1.driverId equals T2.driverId to link driver information with race results. 2) When filtering for Lewis Hamilton: use T1.forename = 'Lewis' and T1.surname = 'Hamilton' instead of a single driver field. 3) When calculating total points: sum T2.points from the results table after joining with the filtered driver information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(points) FROM Formula_1_races WHERE driver = 'Lewis Hamilton';",
            "SELECT SUM(T2.points) \nFROM drivers AS T1 \nJOIN results AS T2 ON T1.driverId = T2.driverId \nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'"
        ],
        "rule_sql": [
            "SELECT SUM(T2.points) AS total_points\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'"
        ],
        "amend_res": 1
    },
    "1339": {
        "db_id": "student_club",
        "question": "Calculate the total average cost that Elijah Allen spent in the events on September and October.",
        "ground_truth": "SELECT AVG(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.last_name = 'Allen' AND T1.first_name = 'Elijah' AND (SUBSTR(T2.expense_date, 6, 2) = '09' OR SUBSTR(T2.expense_date, 6, 2) = '10')",
        "amends": [
            "Do use `AVG(T2.cost)` with explicit table alias instead of `AVG(cost)` without qualification. Do join `member AS T1` and `expense AS T2` with `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of querying only `events` table. Do filter by `T1.last_name = 'Allen'` and `T1.first_name = 'Elijah'` instead of `participant_name = 'Elijah Allen'`. Do use `SUBSTR(T2.expense_date, 6, 2)` to extract month numbers '09' and '10' instead of string month names 'September' and 'October'. The amended query now correctly joins member and expense tables, uses proper month extraction from date fields, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about average cost spent by Elijah Allen: use AVG(T2.cost) with explicit table alias qualification. 2) When combining member and expense tables: link rows where T1.member_id = T2.link_to_member using an inner join to keep only matching pairs. 3) When filtering for Elijah Allen: use T1.last_name = 'Allen' and T1.first_name = 'Elijah' instead of a single participant_name field. 4) When filtering for September and October months: extract month numbers using SUBSTR(T2.expense_date, 6, 2) and compare to '09' and '10' instead of using month names 'September' and 'October'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(cost) FROM events WHERE participant_name = 'Elijah Allen' AND (month = 'September' OR month = 'October');",
            "SELECT AVG(T2.cost) AS average_cost\nFROM member AS T1\nINNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member\nWHERE T1.first_name = 'Elijah' \nAND T1.last_name = 'Allen'\nAND SUBSTR(T2.expense_date, 6, 2) IN ('09', '10');"
        ],
        "rule_sql": [
            "SELECT AVG(T2.cost) AS average_cost\nFROM member T1\nINNER JOIN expense T2 ON T1.member_id = T2.link_to_member\nWHERE T1.last_name = 'Allen' \nAND T1.first_name = 'Elijah'\nAND (SUBSTR(T2.expense_date, 6, 2) = '09' OR SUBSTR(T2.expense_date, 6, 2) = '10');"
        ],
        "amend_res": 1
    },
    "110": {
        "db_id": "financial",
        "question": "What is the disposition id of the client who made 5100 USD transaction in 1998/9/2?",
        "evidence": "",
        "ground_truth": "SELECT T1.disp_id FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.date='1997-08-20' AND T3.amount = 5100",
        "amends": [
            "Do select `T1.disp_id` from the `disp` table instead of `disposition_id` from the `transactions` table. Do join `account AS T2` on `T1.account_id = T2.account_id` and `trans AS T3` on `T2.account_id = T3.account_id` instead of querying a single table. Do filter on `T3.date='1997-08-20'` instead of `'1998/9/2'` and maintain the `T3.amount = 5100` condition. The amended query now correctly joins multiple tables to retrieve the disposition ID associated with the specified transaction amount and date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about disposition id for a transaction: select T1.disp_id from the disp table instead of disposition_id from the transactions table. 2) When combining account and trans tables: join account AS T2 on T1.account_id = T2.account_id and trans AS T3 on T2.account_id = T3.account_id using exact key equality. 3) When filtering by transaction amount: use T3.amount = 5100 condition. 4) When filtering by transaction date: use T3.date = '1997-08-20' instead of '1998/9/2' with exact date format and literal value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT disposition_id FROM transactions WHERE amount = 5100 AND date = '1998/9/2';",
            "SELECT T1.disp_id \nFROM disp AS T1\nJOIN account AS T2 ON T1.account_id = T2.account_id\nJOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T3.date = '1997-08-20' AND T3.amount = 5100"
        ],
        "rule_sql": [
            "SELECT T1.disp_id \nFROM disp AS T1\nJOIN account AS T2 ON T1.account_id = T2.account_id\nJOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T3.amount = 5100 \nAND T3.date = '1997-08-20'"
        ],
        "amend_res": 1
    },
    "1487": {
        "db_id": "debit_card_specializing",
        "question": "Which LAM customer used the Euro as their currency and had the highest consumption in October 2013?",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date = '201310' AND T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do select `T1.CustomerID` instead of `customer_name` and `MAX(consumption)`. Do use `INNER JOIN` with `yearmonth AS T2` on `T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do filter with `T1.Segment = 'LAM'` instead of `region = 'LAM'`, `T2.Date = '201310'` instead of separate `year = 2013` and `month = 10` conditions, and `T1.Currency = 'EUR'` instead of `currency = 'Euro'`. Do group by `T1.CustomerID` instead of `customer_name`. Do order by `SUM(T2.Consumption)` descending instead of `consumption` descending. The amended query now correctly joins customer and consumption data, uses proper date filtering, aggregates total consumption per customer, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"LAM customer with highest consumption\": make sure the output order: T1.CustomerID, SUM(T2.Consumption). 2) When the question mentions \"LAM customer\": \"LAM\" actually means \"T1.Segment = 'LAM'\" in schema. 3) When the question mentions \"Euro as their currency\": \"Euro\" actually means \"T1.Currency = 'EUR'\" in schema. 4) When the question mentions \"October 2013\": this actually means \"T2.Date = '201310'\" in schema. 5) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match). 6) When the question asks for \"highest consumption\": rank rows by SUM(T2.Consumption) in descending order and keep the first 1 row. 7) When the question asks for consumption in a specific period: compute SUM(T2.Consumption) per customer for the filtered date range."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name, MAX(consumption) \nFROM customers \nWHERE currency = 'Euro' \nAND region = 'LAM' \nAND year = 2013 \nAND month = 10 \nGROUP BY customer_name \nORDER BY consumption DESC \nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM'\nAND T2.Date = '201310'\nAND T1.Currency = 'EUR'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID, SUM(T2.Consumption) \nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' \nAND T1.Currency = 'EUR' \nAND T2.Date = '201310'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "896": {
        "db_id": "formula_1",
        "question": "Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.surname = 'Hamilton' AND T1.year >= 2010",
        "amends": [
            "Do use `CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId)` instead of `(COUNT(CASE WHEN position != 1 THEN 1 END) * 100.0 / COUNT(*))` for proper type casting and accurate column references. Do join `races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId` instead of querying only `f1_results` to properly relate race and driver data through the correct join structure. Do filter on `T3.surname = 'Hamilton'` instead of `driver = 'Hamilton'` to use the correct driver identification column. Do remove the incorrect `track_position = 1` filter instead of keeping it, as this condition was improperly limiting the result set. The amended query now correctly calculates the percentage of races where Hamilton did not finish first by properly joining the necessary tables and using accurate column references."
        ],
        "rules": [
            "1) When calculating percentages with division: use CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) for proper type casting and accurate column references instead of generic COUNT(*). 2) When querying about F1 race results: join races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId to properly relate race and driver data through the correct join structure. 3) When filtering for driver 'Hamilton': use T3.surname = 'Hamilton' instead of driver = 'Hamilton' to use the correct driver identification column. 4) When calculating percentage of races where Hamilton was not first: remove any track_position = 1 filter as this condition improperly limits the result set."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN position != 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_not_first\nFROM f1_results\nWHERE driver = 'Hamilton'\nAND year >= 2010\nAND track_position = 1;",
            "SELECT \n    CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) AS percentage_not_first\nFROM \n    races AS T1 \n    INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId \n    INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE \n    T3.surname = 'Hamilton' \n    AND T1.year >= 2010"
        ],
        "rule_sql": [
            "SELECT \n    CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) AS percentage_not_first\nFROM \n    races AS T1 \n    INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId \n    INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE \n    T3.surname = 'Hamilton' \n    AND T1.year >= 2010"
        ],
        "amend_res": 1
    },
    "534": {
        "db_id": "codebase_community",
        "question": "What is the display name of the user who has the most number of views?",
        "ground_truth": "SELECT DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "amends": [
            "Do use `DisplayName` instead of `display_name` for the column alias. Do add a `WHERE` filter comparing `Views` to a subquery instead of ordering and limiting. Do use a correlated subquery `SELECT MAX(Views) FROM users` instead of `ORDER BY views DESC LIMIT 1` to find the maximum value. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly identifies the user with the maximum views by comparing against the calculated maximum rather than relying on sorting and limiting which may not handle ties properly."
        ],
        "rules": [
            "1) When answering about \"the user who has the most number of views\": use the exact column token \"DisplayName\" from the users table to return the display name. 2) When finding the user with maximum views: compare each user's \"Views\" value against the maximum value calculated from the entire users table using a subquery. 3) When handling ties for maximum views: use a correlated subquery approach that will return all users who have the maximum views value rather than limiting to just one row. 4) When selecting output columns: ensure the output order contains only \"DisplayName\" as specified in the question."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users ORDER BY views DESC LIMIT 1;",
            "SELECT DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users);"
        ],
        "rule_sql": [
            "SELECT DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users);"
        ],
        "amend_res": 1
    },
    "691": {
        "db_id": "codebase_community",
        "question": "Identify the number of adult users who have cast over 5000 upvotes.",
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE age >= 18 AND upvotes > 5000;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM users \nWHERE Age >= 18 \nAND UpVotes > 5000"
        ],
        "amend_res": 1
    },
    "631": {
        "db_id": "codebase_community",
        "question": "How many posts were created by Daniel Vassallo?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "amends": [
            "Do select `COUNT(T1.Id)` from the `users` table instead of `COUNT(*)` from the `posts` table. Do join `postHistory AS T2` with `INNER JOIN` on `T1.Id = T2.UserId` instead of querying only the `posts` table. Do filter on `T1.DisplayName = 'Daniel Vassallo'` instead of `author = 'Daniel Vassallo'`. Do reference the `users` table as `T1` instead of omitting this table entirely. The amended query now correctly counts posts by joining users with their post history and filtering by display name instead of relying on an author field that may not exist or be consistent."
        ],
        "rules": [
            "1) When counting posts created by a specific user: count using T1.Id from the users table instead of counting all rows from the posts table. 2) When the question mentions \"Daniel Vassallo\": this refers to T1.DisplayName = 'Daniel Vassallo' exactly as written. 3) When combining user information with post history: link rows where T1.Id = T2.UserId using an inner join between users table (T1) and postHistory table (T2). 4) When answering about posts created by a user: make sure to join the users table with postHistory table to correctly associate users with their posts."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE author = 'Daniel Vassallo';",
            "SELECT COUNT(T2.Id) \nFROM users AS T1 \nINNER JOIN postHistory AS T2 ON T1.Id = T2.UserId \nWHERE T1.DisplayName = 'Daniel Vassallo'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nWHERE T1.DisplayName = 'Daniel Vassallo'"
        ],
        "amend_res": 1
    },
    "1450": {
        "db_id": "student_club",
        "question": "In the events with more than forty incomes, list the city and country in which the event is happening.",
        "ground_truth": "SELECT DISTINCT T3.city, T3.county FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip WHERE T1.amount > 40",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the SELECT list from `city, country` to `T3.city, T3.county` instead of the original columns. Do replace the single table `events` with a three-table join structure using `INCOME AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip` instead of the simple table reference. Do change the filter from `income > 40` to `T1.amount > 40` instead of the original column reference. The amended query now correctly joins across multiple tables to retrieve location data based on income criteria and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about events with more than forty incomes: use a three-table join structure with INCOME as T1, member as T2, and zip_code as T3. 2) When combining tables for shared entities: link T1 to T2 where T1.link_to_member = T2.member_id, and link T2 to T3 where T3.zip_code = T2.zip, keeping only matching pairs (inner match). 3) When filtering for incomes greater than forty: use T1.amount > 40 instead of income > 40. 4) When selecting location data: output T3.city and T3.county instead of city and country. 5) When retrieving distinct results: ensure the output includes DISTINCT to avoid duplicate rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, country FROM events WHERE income > 40",
            "SELECT DISTINCT T3.city, T3.county\nFROM income AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nINNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip\nWHERE T1.amount > 40"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.city, T3.county\nFROM income AS T1\nJOIN member AS T2 ON T1.link_to_member = T2.member_id\nJOIN zip_code AS T3 ON T3.zip_code = T2.zip\nWHERE T1.amount > 40;"
        ],
        "amend_res": 1
    },
    "1022": {
        "db_id": "european_football_2",
        "question": "What is the preferred foot when attacking of the player with the lowest potential?",
        "ground_truth": "SELECT preferred_foot FROM Player_Attributes WHERE potential IS NOT NULL ORDER BY potential ASC LIMIT 1",
        "amends": [
            "Do query the `Player_Attributes` table instead of the `players` table. Do add `IS NOT NULL` filter for `potential` instead of omitting null handling. Do change the subquery approach to `ORDER BY potential ASC LIMIT 1` instead of using a subquery with `MAX(potential)`. Do add explicit `ORDER BY` and `LIMIT` clauses instead of relying on implicit behavior. The amended query now correctly handles null values and returns the preferred_foot from the appropriate table with proper ordering and limiting to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"preferred foot when attacking\": query the \"Player_Attributes\" table instead of the \"players\" table. 2) When filtering for \"potential\" values: add \"IS NOT NULL\" filter to exclude null values. 3) When finding the player with the \"lowest potential\": use \"ORDER BY potential ASC LIMIT 1\" instead of a subquery with MAX(potential). 4) When handling ordering and limiting: add explicit \"ORDER BY\" and \"LIMIT\" clauses instead of relying on implicit behavior."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT preferred_foot FROM players WHERE potential = (SELECT MAX(potential) FROM players);",
            "SELECT preferred_foot FROM Player_Attributes WHERE potential IS NOT NULL ORDER BY potential ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT preferred_foot FROM Player_Attributes WHERE potential IS NOT NULL ORDER BY potential ASC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "169": {
        "db_id": "financial",
        "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
        "amends": [
            "Do add `CAST` to `REAL` for the numerator subtraction instead of omitting it, and change the division order to multiply by 100 after division instead of before. Do change table aliases to `T1`, `T2`, `T3`, `T4` instead of `l`, `a`, `c`. Do add an additional `INNER JOIN` on `disp AS T3` with condition `T3.account_id = T2.account_id` instead of omitting this table. Do change the client join to use `T4.client_id = T3.client_id` instead of `c.client_id = a.client_id`. Do change the gender filter to `T4.gender = 'M'` instead of `c.gender = 'male'`. Do add a filter `T3.type = 'OWNER'` instead of omitting it. Do remove the explicit `strftime` year filter in the `WHERE` clause instead of keeping it, as the year filtering is already handled in the `CASE` statements. Do remove the column alias `growth_rate` instead of keeping it. The amended query now correctly calculates the growth rate for male account owners with proper table relationships and filtering.",
            "Do place the multiplication by 100 after the CAST operation instead of before it, and do remove the parentheses around the entire division expression instead of keeping them. Do maintain the same SELECT list structure with identical CASE expressions for year filtering instead of changing them. Do preserve all FROM sources with the same INNER JOIN conditions on `T1.account_id=T2.account_id`, `T3.account_id=T2.account_id`, and `T4.client_id=T3.client_id` instead of altering them. Do keep the WHERE filters for `T4.gender='M'` and `T3.type='OWNER'` unchanged instead of modifying them. The amended query now correctly calculates the percentage difference by applying the multiplication after casting to REAL, matching the RIGHT_SQL's behavior.",
            "Do place the entire numerator expression within `CAST(... AS REAL)` instead of casting only the difference of sums, and do multiply by 100 after division instead of before it, while keeping the same `SELECT` list structure, `FROM` sources with identical `INNER JOIN` chains on `T1.account_id=T2.account_id`, `T3.account_id=T2.account_id`, and `T4.client_id=T3.client_id`, and maintaining the same `WHERE` filters for `T4.gender='M'` and `T3.type='OWNER'` without any changes to grouping, window functions, subqueries, ordering, or distinct operations. The amended query now correctly calculates the percentage change by casting the precise difference before multiplication and division, matching the RIGHT_SQL's behavior.",
            "Do place the multiplication by 100 after the cast instead of before the division in the SELECT expression. Do maintain the same FROM sources with `loan AS T1`, `account AS T2`, `disp AS T3`, and `client AS T4` with identical INNER JOIN conditions on `T1.account_id = T2.account_id`, `T3.account_id = T2.account_id`, and `T4.client_id = T3.client_id`. Do keep the WHERE filters on `T4.gender = 'M'` and `T3.type = 'OWNER'` unchanged. The amended query now correctly calculates the percentage change by applying the multiplication after casting to avoid integer division issues, matching the RIGHT_SQL's behavior.",
            "Do place the multiplication by 100 after the cast instead of wrapping the entire expression including division in parentheses before multiplying. Do maintain the same SELECT list structure with identical column references, FROM clause with the same INNER JOIN conditions on `T1.account_id=T2.account_id`, `T3.account_id=T2.account_id`, and `T4.client_id=T3.client_id`, and WHERE filters on `T4.gender='M'` and `T3.type='OWNER'` without any changes. The amended query now correctly calculates the percentage difference by applying the multiplication after the cast operation, matching the RIGHT_SQL's behavior.",
            "Do place the multiplication by 100 after the cast instead of before the division in the SELECT expression. Do maintain the same FROM sources with INNER JOIN on `T1.account_id=T2.account_id`, `T3.account_id=T2.account_id`, and `T4.client_id=T3.client_id` instead of changing any join conditions. Do keep the WHERE filters on `T4.gender='M'` and `T3.type='OWNER'` instead of modifying them. The amended query now correctly calculates the percentage change by applying the multiplication after casting to REAL, matching the RIGHT_SQL's behavior.",
            "Do place the multiplication by 100 after the cast instead of before the division in the SELECT expression. Do maintain the same FROM sources with INNER JOIN on `T1.account_id=T2.account_id`, `T3.account_id=T2.account_id`, and `T4.client_id=T3.client_id`. Do keep the WHERE filters on `T4.gender='M'` and `T3.type='OWNER'` unchanged. The amended query now correctly calculates the percentage change by applying the multiplication after casting to REAL, matching the RIGHT_SQL's behavior.",
            "Do place the CAST function around only the difference calculation `(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END))` instead of casting the entire expression including division, and do multiply by 100 before dividing by the 1996 sum instead of after the division, which changes the mathematical order of operations to correctly calculate the percentage change. The FROM clause with `INNER JOIN` on `T1.account_id = T2.account_id`, `T3.account_id = T2.account_id`, and `T4.client_id = T3.client_id` remains unchanged, as do the WHERE filters for `T4.gender = 'M'` and `T3.type = 'OWNER'`. The amended query now correctly computes the percentage growth from 1996 to 1997 by properly handling the mathematical operations and casting."
        ],
        "rules": [
            "1) When calculating growth rate between two years: cast the numerator subtraction to REAL before division, then multiply by 100 after division instead of before. 2) When joining tables for client loan analysis: use T1 for loans, T2 for accounts, T3 for disp, and T4 for clients instead of custom aliases. 3) When connecting accounts to clients: add an INNER JOIN on disp table T3 with condition T3.account_id = T2.account_id. 4) When joining clients to accounts: use T4.client_id = T3.client_id instead of direct client-account linking. 5) When filtering for male clients: use T4.gender = 'M' instead of 'male'. 6) When identifying account owners: add filter T3.type = 'OWNER' to ensure only owner relationships are considered. 7) When handling year filtering: remove explicit year filters from WHERE clause since year filtering is already handled in CASE statements. 8) When producing output: remove column aliases from the final result.",
            "1) When calculating growth rate percentages: apply multiplication by 100 after casting the division result to REAL instead of before casting. 2) When computing year-over-year loan amount differences: use identical CASE expressions for filtering years 1996 and 1997 without changing the structure. 3) When combining loan, account, disp, and client tables: maintain INNER JOIN conditions exactly as T1.account_id=T2.account_id, T3.account_id=T2.account_id, and T4.client_id=T3.client_id. 4) When filtering for male clients who are account owners: preserve WHERE conditions T4.gender='M' and T3.type='OWNER' unchanged.",
            "1) When calculating growth rate percentage between two years: cast the entire numerator (difference between sums) as REAL before division, then multiply by 100 after the division operation. 2) When joining loan, account, disp, and client tables: use inner joins with T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id. 3) When filtering for male clients: use T4.gender = 'M' with exact case and quotes. 4) When filtering for account owners: use T3.type = 'OWNER' with exact case and quotes. 5) When calculating loan amounts by year: use strftime('%Y', T1.date) to extract year from date column and compare with exact string literals '1996' and '1997'.",
            "1) When calculating growth rate percentage: apply multiplication by 100 after casting to REAL to avoid integer division issues. 2) When combining loan, account, disp, and client tables: link rows using exact key equalities T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id with inner matches only. 3) When filtering for male clients: use exact literal 'M' for T4.gender. 4) When filtering for account owners: use exact literal 'OWNER' for T3.type. 5) When computing loan amounts by year: use strftime('%Y', T1.date) to extract year from date and compare with exact literals '1996' and '1997'.",
            "1) When calculating growth rate percentages: apply multiplication by 100 after casting the division result to REAL type, not before. 2) When filtering for male clients: use the exact literal 'M' for the gender condition. 3) When identifying account owners: use the exact literal 'OWNER' for the disp type condition. 4) When joining loan, account, disp, and client tables: link rows using the exact key equalities T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id. 5) When computing loan amounts by year: extract the year from the date column using strftime('%Y', T1.date) and compare to exact literals '1996' and '1997'. 6) When calculating growth rate: compute (1997 total amount - 1996 total amount) divided by 1996 total amount, then multiply by 100 after casting to REAL.",
            "1) When calculating percentage growth rate: perform the subtraction between 1997 and 1996 amounts before casting to REAL, then multiply by 100 after the division operation instead of before. 2) When combining loan, account, disp, and client tables: use inner joins with exact conditions T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id. 3) When filtering for male clients who are account owners: apply WHERE conditions T4.gender = 'M' and T3.type = 'OWNER' exactly as specified.",
            "1) When calculating growth rate percentages: apply multiplication by 100 after casting the division result to REAL type, not before the division. 2) When joining loan, account, disp, and client tables: use inner joins exactly as specified with T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id. 3) When filtering for male clients: use exact condition T4.gender = 'M' with literal 'M'. 4) When filtering for account owners: use exact condition T3.type = 'OWNER' with literal 'OWNER'.",
            "1) When calculating percentage growth rate between two years: compute (sum for later year minus sum for earlier year) divided by sum for earlier year, then multiply by 100 to get percentage. 2) When the question specifies a male client: filter where T4.gender equals exactly 'M'. 3) When the question involves account ownership: filter where T3.type equals exactly 'OWNER'. 4) When combining loan, account, disp, and client tables: link rows where T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id using inner matches only. 5) When extracting year from date fields: use strftime('%Y', T1.date) to get the 4-digit year. 6) When handling mathematical operations for growth rate: cast only the difference calculation to REAL before division, not the entire expression."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN strftime('%Y', l.date) = '1997' THEN l.amount ELSE 0 END) - \n     SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END)) / \n    SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END) * 100 AS growth_rate\nFROM loans l\nJOIN accounts a ON l.account_id = a.account_id\nJOIN clients c ON a.client_id = c.client_id\nWHERE c.gender = 'male'\nAND strftime('%Y', l.date) IN ('1996', '1997');",
            "SELECT \n    (CAST(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) / \n    SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100\nFROM \n    loan AS T1\nINNER JOIN \n    account AS T2 ON T1.account_id = T2.account_id\nINNER JOIN \n    disp AS T3 ON T3.account_id = T2.account_id\nINNER JOIN \n    client AS T4 ON T4.client_id = T3.client_id\nWHERE \n    T4.gender = 'M' AND T3.type = 'OWNER'",
            "SELECT (CAST(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
            "SELECT \n    (CAST(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) \n     / SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100\nFROM \n    loan AS T1\n    INNER JOIN account AS T2 ON T1.account_id = T2.account_id\n    INNER JOIN disp AS T3 ON T3.account_id = T2.account_id\n    INNER JOIN client AS T4 ON T4.client_id = T3.client_id\nWHERE \n    T4.gender = 'M' \n    AND T3.type = 'OWNER'",
            "SELECT \n    (CAST(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) \n    / SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100\nFROM \n    loan AS T1\n    INNER JOIN account AS T2 ON T1.account_id = T2.account_id\n    INNER JOIN disp AS T3 ON T3.account_id = T2.account_id\n    INNER JOIN client AS T4 ON T4.client_id = T3.client_id\nWHERE \n    T4.gender = 'M' \n    AND T3.type = 'OWNER'",
            "SELECT \n    (CAST(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) \n    / SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100\nFROM \n    loan AS T1\n    INNER JOIN account AS T2 ON T1.account_id = T2.account_id\n    INNER JOIN disp AS T3 ON T3.account_id = T2.account_id\n    INNER JOIN client AS T4 ON T4.client_id = T3.client_id\nWHERE \n    T4.gender = 'M' \n    AND T3.type = 'OWNER'",
            "SELECT \n    (CAST(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) / \n    SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100\nFROM \n    loan AS T1\n    INNER JOIN account AS T2 ON T1.account_id = T2.account_id\n    INNER JOIN disp AS T3 ON T3.account_id = T2.account_id\n    INNER JOIN client AS T4 ON T4.client_id = T3.client_id\nWHERE \n    T4.gender = 'M' AND T3.type = 'OWNER'",
            "SELECT (CAST(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nINNER JOIN disp AS T3 ON T3.account_id = T2.account_id\nINNER JOIN client AS T4 ON T4.client_id = T3.client_id\nWHERE T4.gender = 'M' AND T3.type = 'OWNER'",
            "SELECT \n    (CAST(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) * 100) / \n    SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)\nFROM \n    loan AS T1\n    INNER JOIN account AS T2 ON T1.account_id = T2.account_id\n    INNER JOIN disp AS T3 ON T3.account_id = T2.account_id\n    INNER JOIN client AS T4 ON T4.client_id = T3.client_id\nWHERE \n    T4.gender = 'M' AND T3.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) / \n     SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100\nFROM \n    loan T1\n    INNER JOIN account T2 ON T1.account_id = T2.account_id\n    INNER JOIN disp T3 ON T3.account_id = T2.account_id\n    INNER JOIN client T4 ON T4.client_id = T3.client_id\nWHERE \n    T4.gender = 'M' AND T3.type = 'OWNER'"
        ],
        "amend_res": 1
    },
    "588": {
        "db_id": "codebase_community",
        "question": "Give the total number of comments posted by user ID 13.",
        "evidence": "",
        "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13",
        "amends": [
            "Do use `COUNT(Id)` instead of `COUNT(*)` to count only non-null values in the Id column. Do reference `UserId` instead of `user_id` to match the correct column name casing. The amended query now correctly counts non-null comment IDs for user 13, matching the intended behavior."
        ],
        "rules": [
            "1) When counting comments: use COUNT(\"Id\") instead of COUNT(*) to count only non-null values in the Id column. 2) When referencing user ID columns: use exact column name \"UserId\" with proper casing instead of \"user_id\". 3) When filtering by user ID 13: use the exact literal value 13 without quotes for numeric comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE user_id = 13;",
            "SELECT COUNT(Id) FROM comments WHERE UserId = 13;"
        ],
        "rule_sql": [
            "SELECT COUNT(\"Id\") FROM comments WHERE UserId = 13;"
        ],
        "amend_res": 1
    },
    "1058": {
        "db_id": "european_football_2",
        "question": "Who has the highest average finishing rate between the highest and shortest football player?",
        "ground_truth": "SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM Player ) UNION SELECT AVG(finishing) result, 'Min' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM Player ) ) ORDER BY result DESC LIMIT 1",
        "amends": [
            "Do use `AVG(finishing)` instead of `AVG(finishing_rate)` and calculate separate averages for max and min height players instead of grouping by player names. Do restructure with a UNION subquery that returns two rows labeled 'Max' and 'Min' instead of a single JOIN with OR conditions. Do join on `player_api_id` instead of `player_id` and use tables `Player` and `Player_Attributes` instead of `players` and `stats`. Do remove the GROUP BY clause entirely instead of grouping by player names. Do order by the calculated `result` column instead of the alias `avg_finishing_rate`. Do select only the label column `A` in the outer query instead of player names. The amended query now correctly calculates and compares the average finishing rates for players with maximum height versus minimum height, returning the better performing group."
        ],
        "rules": [
            "1) When the question asks for average finishing rate: use AVG(finishing) instead of AVG(finishing_rate) 2) When comparing highest and shortest football players: calculate separate averages for maximum height players and minimum height players instead of grouping by player names 3) When structuring the query for two height groups: use a UNION subquery that returns two rows labeled 'Max' and 'Min' instead of a single JOIN with OR conditions 4) When joining Player and Player_Attributes tables: use player_api_id as the join key instead of player_id 5) When selecting output: only select the label column A in the outer query instead of player names 6) When ordering results: order by the calculated result column instead of the alias avg_finishing_rate"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    p.player_name,\n    AVG(s.finishing_rate) as avg_finishing_rate\nFROM players p\nJOIN stats s ON p.player_id = s.player_id\nWHERE p.height = (SELECT MAX(height) FROM players) \n   OR p.height = (SELECT MIN(height) FROM players)\nGROUP BY p.player_name\nORDER BY avg_finishing_rate DESC\nLIMIT 1;",
            "SELECT \n    A\nFROM (\n    SELECT \n        'Max' AS A,\n        AVG(pa.finishing) AS result\n    FROM \n        Player p\n    JOIN \n        Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE \n        p.height = (SELECT MAX(height) FROM Player)\n    \n    UNION ALL\n    \n    SELECT \n        'Min' AS A,\n        AVG(pa.finishing) AS result\n    FROM \n        Player p\n    JOIN \n        Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE \n        p.height = (SELECT MIN(height) FROM Player)\n) \nORDER BY \n    result DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT A FROM (\n    SELECT 'Max' AS A, AVG(pa.finishing) AS avg_finishing\n    FROM Player p\n    JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE p.height = (SELECT MAX(height) FROM Player)\n    \n    UNION ALL\n    \n    SELECT 'Min' AS A, AVG(pa.finishing) AS avg_finishing\n    FROM Player p\n    JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE p.height = (SELECT MIN(height) FROM Player)\n) \nORDER BY avg_finishing DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "734": {
        "db_id": "superhero",
        "question": "What is the publisher's name of Blue Beetle II?",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Blue Beetle II'",
        "amends": [
            "Do select `T2.publisher_name` from the `publisher` table instead of `publisher_name` from the `comics` table. Do join `superhero AS T1` with `publisher AS T2` on `T1.publisher_id = T2.id` instead of querying only the `comics` table. Do filter on `T1.superhero_name = 'Blue Beetle II'` instead of `title = 'Blue Beetle II'`. The amended query now correctly retrieves publisher information by joining the superhero and publisher tables through their relationship, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for publisher information about a superhero: join superhero table as T1 with publisher table as T2 using T1.publisher_id = T2.id to connect the related entities. 2) When filtering for a specific superhero name: use T1.superhero_name = 'Blue Beetle II' with exact case and spacing as specified. 3) When selecting publisher information: use T2.publisher_name from the publisher table rather than any publisher_name column from other tables. 4) When combining tables for superhero-publisher relationships: perform an inner match where T1.publisher_id equals T2.id to ensure only valid publisher associations are returned."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT publisher_name FROM comics WHERE title = 'Blue Beetle II';",
            "SELECT T2.publisher_name \nFROM superhero AS T1 \nJOIN publisher AS T2 ON T1.publisher_id = T2.id \nWHERE T1.superhero_name = 'Blue Beetle II'"
        ],
        "rule_sql": [
            "SELECT T2.publisher_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.superhero_name = 'Blue Beetle II';"
        ],
        "amend_res": 1
    },
    "16": {
        "db_id": "california_schools",
        "question": "How many schools in merged Alameda have number of test takers less than 100?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T1.CDSCode) FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Merged' AND T2.NumTstTakr < 100 AND T1.County = 'Lake'",
        "amends": [
            "Do select `COUNT(T1.CDSCode)` instead of `COUNT(*)`. Do add `FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds` instead of `FROM schools` alone. Do change filter to `T1.StatusType = 'Merged'` instead of omitting it. Do change filter to `T2.NumTstTakr < 100` instead of `test_takers < 100`. Do change filter to `T1.County = 'Lake'` instead of `county = 'Alameda'`. The amended query now correctly counts merged schools in Lake County with fewer than 100 SAT test takers by joining the schools and satscores tables on CDSCode."
        ],
        "rules": [
            "1) When answering about \"schools in merged Alameda\": make sure the output order: COUNT(T1.CDSCode). 2) When the question mentions \"schools\": use \"schools AS T1\" as the base table. 3) When the question mentions \"number of test takers\": \"number of test takers\" actually means \"T2.NumTstTakr in schema\". 4) When combining T1 and T2 for shared entities: link rows where T1.CDSCode = T2.cds exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"count of schools\": compute the number of rows using T1.CDSCode as the counting key. 6) When filtering for \"merged\" schools: use T1.StatusType = 'Merged' exactly. 7) When filtering for \"Alameda\" county: use T1.County = 'Alameda' exactly (not 'Lake'). 8) When filtering for \"less than 100 test takers\": use T2.NumTstTakr < 100 exactly."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE county = 'Alameda' AND test_takers < 100;",
            "SELECT COUNT(T1.CDSCode) \nFROM schools AS T1 \nINNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds \nWHERE T1.StatusType = 'Merged' \nAND T2.NumTstTakr < 100 \nAND T1.County = 'Lake'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.CDSCode) \nFROM schools AS T1 \nINNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds \nWHERE T1.StatusType = 'Merged' \nAND T1.County = 'Alameda' \nAND T2.NumTstTakr < 100"
        ],
        "amend_res": 1
    },
    "170": {
        "db_id": "financial",
        "question": "How many credit card withdrawals were recorded after 1995?",
        "ground_truth": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
        "amends": [
            "Do count `account_id` instead of `*` to exclude null values. Do reference table `trans` instead of `transactions` to match the correct schema. Do filter on `operation = 'VYBER KARTOU'` instead of `transaction_type = 'credit_card'` to use the proper column name and value. Do extract year from `date` column using `STRFTIME('%Y', date) > '1995'` instead of filtering on a `year` column to properly handle date-based filtering. The amended query now correctly counts non-null account IDs for card withdrawal operations after 1995."
        ],
        "rules": [
            "1) When counting credit card withdrawals: count non-null account_id values instead of all rows to exclude null values. 2) When referencing the transactions table: use table name \"trans\" instead of \"transactions\" to match the correct schema. 3) When filtering for credit card withdrawals: use condition operation = 'VYBER KARTOU' instead of transaction_type = 'credit_card' to use the proper column name and value. 4) When filtering for transactions after 1995: extract year from date column using STRFTIME('%Y', date) > '1995' instead of filtering on a year column to properly handle date-based filtering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM transactions WHERE transaction_type = 'credit_card' AND year > 1995;",
            "SELECT COUNT(account_id) FROM trans WHERE operation = 'VYBER KARTOU' AND STRFTIME('%Y', date) > '1995'"
        ],
        "rule_sql": [
            "SELECT COUNT(account_id) FROM trans WHERE operation = 'VYBER KARTOU' AND STRFTIME('%Y', date) > '1995';"
        ],
        "amend_res": 1
    },
    "1325": {
        "db_id": "student_club",
        "question": "What is the most expensive item that was spent in support of club events?",
        "ground_truth": "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1",
        "amends": [
            "Do select `expense_description` instead of `MAX(amount)` and change the source table to `expense` instead of `expenses`. Do remove the `WHERE category = 'club events'` filter instead of keeping it. Do add `ORDER BY cost DESC LIMIT 1` instead of omitting these clauses, which changes the query from finding the maximum amount to retrieving the description of the single most expensive item. The amended query now matches RIGHT_SQL's behavior of returning the top expense description rather than just the maximum amount value."
        ],
        "rules": [
            "1) When answering about \"the most expensive item\": select \"expense_description\" from table \"expense\" instead of MAX(amount) from \"expenses\". 2) When the question mentions \"spent in support of club events\": do not apply any category filter as the question does not specify a category constraint. 3) When finding the single most expensive item: order rows by \"cost\" in descending order and keep only the first row (top 1)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(amount) FROM expenses WHERE category = 'club events';",
            "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "344": {
        "db_id": "card_games",
        "question": "List all the mythic rarity print cards banned in gladiator format.",
        "ground_truth": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "amends": [
            "Do select only `T1.id` with `DISTINCT` instead of all columns with `*`. Do join `cards AS T1` with `legalities AS T2` on `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do filter on `T2.format = 'gladiator'` and `T2.status = 'Banned'` instead of using `banned_in LIKE '%gladiator%'`. Do keep the `T1.rarity = 'mythic'` filter but apply it to the joined table structure instead of the original single table. The amended query now correctly identifies mythic rare cards banned in the gladiator format by joining with the legalities table and checking the specific banned status."
        ],
        "rules": [
            "1) When answering about \"mythic rarity print cards banned in gladiator format\": make sure the output order: T1.id\n2) When the question mentions \"banned in gladiator format\": \"banned\" actually means \"status = 'Banned'\" in schema and \"gladiator format\" actually means \"format = 'gladiator'\" in schema\n3) When combining T1 (cards) and T2 (legalities) for shared entities: link rows where T1.uuid = T2.uuid exactly as shown in the amends; keep only matching pairs (inner match)\n4) When filtering for mythic rarity: use T1.rarity = 'mythic' with exact literal 'mythic'\n5) When selecting distinct cards: use DISTINCT T1.id to get unique card identifiers instead of all columns"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE rarity = 'mythic' AND banned_in LIKE '%gladiator%';",
            "SELECT DISTINCT T1.id FROM cards AS T1 JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'mythic'\nAND T2.format = 'gladiator'\nAND T2.status = 'Banned'"
        ],
        "amend_res": 1
    },
    "1295": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients whose total bilirubin is over the normal range, how many of them have a peripheral pattern observed in the sheet of ANA examination?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` >= 2 AND T3.`ANA Pattern` LIKE '%P%'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(*)` to count specific non-null values. Do reference tables as `Patient AS T1`, `Laboratory AS T2`, and `Examination AS T3` instead of `patients p`, `lab_results lr`, and `ana_examination ae`. Do use `INNER JOIN` on `T1.ID = T2.ID` and `T1.ID = T3.ID` instead of joining on `patient_id` columns with different table aliases. Do filter with `T2.\"T-BIL\" >= 2` instead of `lr.bilirubin > 1.2` to use the correct column name and inclusive threshold. Do use `T3.\"ANA Pattern\" LIKE '%P%'` instead of `ae.pattern = 'peripheral'` to perform pattern matching rather than exact string comparison. The amended query now correctly matches the intended logic and behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific non-null patient identifiers. 2) When referencing tables: use Patient AS T1, Laboratory AS T2, and Examination AS T3 as the canonical table aliases. 3) When joining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner match. 4) When joining Patient and Examination tables: link rows where T1.ID = T3.ID using an inner match. 5) When filtering for elevated total bilirubin: use T2.\"T-BIL\" >= 2 instead of bilirubin > 1.2 to use the correct column name and inclusive threshold. 6) When filtering for peripheral ANA pattern: use T3.\"ANA Pattern\" LIKE '%P%' instead of exact string comparison to perform pattern matching for peripheral patterns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN lab_results lr ON p.patient_id = lr.patient_id\nJOIN ana_examination ae ON p.patient_id = ae.patient_id\nWHERE lr.bilirubin > 1.2 \nAND ae.pattern = 'peripheral';",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" >= 2 \nAND T3.\"ANA Pattern\" LIKE '%P%'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" >= 2 \nAND T3.\"ANA Pattern\" LIKE '%P%'"
        ],
        "amend_res": 1
    },
    "860": {
        "db_id": "formula_1",
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "amends": [
            "Do select `T2.nationality` with `DISTINCT` instead of `nationality` without distinct. Do join `qualifying AS T1` and `drivers AS T2` with `INNER JOIN` on `T2.driverId = T1.driverId` instead of querying only the `drivers` table. Do filter on `T1.raceId = 355` instead of `race_number = 355`. Do use `T1.q2 LIKE '1:40%'` for time matching instead of exact equality `qualifying_time = '0:01:40'`. Do remove the `quarter = 'Q2'` filter since the quarter is already implied by querying the q2 column. The amended query now correctly identifies drivers by their qualifying time pattern in the specific quarter and race, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about a driver's nationality: make sure the output order: T2.nationality with DISTINCT to avoid duplicates. 2) When combining qualifying and drivers tables: link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match). 3) When filtering by race number: use T1.raceId = 355 instead of race_number. 4) When matching qualifying time pattern for Q2: use T1.q2 LIKE '1:40%' instead of exact equality with '0:01:40'. 5) When the question specifies Q2 time: do not add an explicit quarter = 'Q2' filter since the quarter is already implied by querying the q2 column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality FROM drivers WHERE qualifying_time = '0:01:40' AND race_number = 355 AND quarter = 'Q2';",
            "SELECT DISTINCT T2.nationality\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 355\nAND T1.q2 LIKE '1:40%';"
        ],
        "rule_sql": [
            "SELECT DISTINCT d.nationality\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 355\nAND q.q2 LIKE '1:40%';"
        ],
        "amend_res": 1
    },
    "663": {
        "db_id": "codebase_community",
        "question": "What is the id of the youngest user?",
        "ground_truth": "SELECT Id FROM users WHERE Age = ( SELECT MIN(Age) FROM users )",
        "amends": [
            "Do add a `WHERE` filter with a subquery `Age = (SELECT MIN(Age) FROM users)` instead of using `ORDER BY age ASC LIMIT 1` to find the minimum age. Do reference the column as `Id` instead of `id` to match the correct case sensitivity. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them, as the subquery approach directly identifies records with the minimum age value. The amended query now correctly returns all users with the minimum age rather than just one arbitrary user with that age, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the youngest user: use the minimum value of the \"Age\" column to identify users with the minimum age. 2) When finding users with a specific age value: use a WHERE filter with a subquery condition \"Age = (SELECT MIN(Age) FROM users)\" instead of ordering and limiting. 3) When referencing the user identifier column: use the exact case-sensitive column name \"Id\" instead of \"id\". 4) When the question asks for all users sharing the minimum age: return all matching records rather than just one arbitrary record with that age value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM users ORDER BY age ASC LIMIT 1;",
            "SELECT Id FROM users WHERE Age = (SELECT MIN(Age) FROM users)"
        ],
        "rule_sql": [
            "SELECT Id FROM users WHERE Age = (SELECT MIN(Age) FROM users)"
        ],
        "amend_res": 1
    },
    "1045": {
        "db_id": "european_football_2",
        "question": "What is the attacking work rate of the football playerr Franco Zennaro?",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Franco Zennaro'",
        "amends": [
            "Do select `t2.attacking_work_rate` instead of `defending_work_rate`. Do add `DISTINCT` instead of omitting it. Do change the FROM source to `Player AS t1 INNER JOIN Player_Attributes AS t2` instead of just `players`. Do add the join condition `ON t1.player_api_id = t2.player_api_id` instead of having no join. Do change the WHERE filter to `t1.player_name = 'Franco Zennaro'` instead of `name = 'Franco Zennaro'`. The amended query now correctly retrieves the attacking work rate from the joined tables with proper distinct filtering."
        ],
        "rules": [
            "1) When answering about \"attacking work rate of Franco Zennaro\": make sure the output order: t2.attacking_work_rate\n2) When the question mentions \"Franco Zennaro\": \"Franco Zennaro\" actually means \"t1.player_name = 'Franco Zennaro'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.player_api_id = t2.player_api_id); keep only matching pairs (inner match)\n4) When the question asks for distinct values: compute the number of unique values of the exact token for t2.attacking_work_rate\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n6) When handling text literals: do not change case, spacing, or punctuation of 'Franco Zennaro'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT defending_work_rate FROM players WHERE name = 'Franco Zennaro';",
            "SELECT DISTINCT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Franco Zennaro'"
        ],
        "rule_sql": [
            "SELECT t2.attacking_work_rate\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Franco Zennaro'"
        ],
        "amend_res": 1
    },
    "152": {
        "db_id": "financial",
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "ground_truth": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "amends": [
            "Do select `AVG(T1.A15)` from the `district` table instead of `AVG(crimes)` from `crime_data`. Do use `INNER JOIN` with `account` table on `T1.district_id = T2.district_id` instead of a subquery with `region_id IN`. Do filter with `STRFTIME('%Y', T2.date) >= '1997'` for account opening year instead of `year = 1995 AND region_id IN` subquery. Do apply the `T1.A15 > 4000` filter directly instead of `crimes > 4000`. The amended query now correctly joins district and account tables with proper date handling and filtering to match the intended behavior."
        ],
        "rules": [
            "1) When answering about average number of crimes: use AVG(T1.A15) from the district table instead of AVG(crimes) from crime_data. 2) When combining district and account tables: perform an INNER JOIN where T1.district_id = T2.district_id to link matching rows. 3) When filtering for account opening year starting from 1997: use STRFTIME('%Y', T2.date) >= '1997' instead of year-based filtering. 4) When filtering for crimes exceeding 4000: apply T1.A15 > 4000 directly as a condition. 5) When handling date comparisons: use STRFTIME function with format '%Y' to extract year from T2.date column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(crimes) FROM crime_data WHERE year = 1995 AND crimes > 4000 AND region_id IN (SELECT region_id FROM accounts WHERE open_year >= 1997);",
            "SELECT AVG(T1.A15) \nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nWHERE T1.A15 > 4000\nAND STRFTIME('%Y', T2.date) >= '1997'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.A15) AS average_crimes\nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nWHERE T1.A15 > 4000\nAND STRFTIME('%Y', T2.date) >= '1997';"
        ],
        "amend_res": 1
    },
    "1349": {
        "db_id": "student_club",
        "question": "Provide the total number of the budget amount for \"September Speaker\" event.",
        "ground_truth": "SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'September Speaker'",
        "amends": [
            "Do select `SUM(T1.amount)` from the `budget` table instead of `SUM(budget)` from the `events` table. Do join `budget AS T1` with `event AS T2` using `INNER JOIN` on `T1.link_to_event = T2.event_id` instead of querying only the `events` table. Do filter on `T2.event_name = 'September Speaker'` through the joined event table instead of directly on the events table. The amended query now correctly aggregates budget amounts from the budget table linked to specific events, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"total number of the budget amount\": make sure the output order: SUM(T1.amount). 2) When the question mentions \"budget amount\": \"budget amount\" actually means \"T1.amount in schema\". 3) When the question mentions \"September Speaker\" event: filter using T2.event_name = 'September Speaker' exactly as written. 4) When combining T1 (budget) and T2 (event) for shared entities: link rows where T1.link_to_event = T2.event_id; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(budget) FROM events WHERE event_name = 'September Speaker';",
            "SELECT SUM(T1.amount) \nFROM budget AS T1 \nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id \nWHERE T2.event_name = 'September Speaker'"
        ],
        "rule_sql": [
            "SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'September Speaker'"
        ],
        "amend_res": 1
    },
    "1201": {
        "db_id": "thrombosis_prediction",
        "question": "What percentage of patients who were born in 1980 and were diagnosed with RA are women?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE Diagnosis = 'RA' AND STRFTIME('%Y', Birthday) = '1980'",
        "amends": [
            "Do use `SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN p.gender = 'F' THEN 1 END)` for accurate female counting. Do reference `SEX` instead of `gender` and `ID` instead of `patient_id` to match the schema. Do move the `Diagnosis = 'RA'` filter to the `WHERE` clause instead of joining a separate diagnoses table. Do use `STRFTIME('%Y', Birthday) = '1980'` for year extraction instead of `birth_year = 1980`. Do remove the explicit table join and instead filter directly on `Diagnosis` within the main query. Do cast the sum to `REAL` instead of using `100.0` for proper floating-point division. The amended query now correctly calculates the percentage of female patients with RA diagnosis born in 1980 without requiring a table join."
        ],
        "rules": [
            "1) When the question asks for percentage of patients who are women: use SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN p.gender = 'F' THEN 1 END) for accurate female counting. 2) When referring to gender in the schema: use the exact column token SEX instead of gender. 3) When referring to patient identifier in the schema: use the exact column token ID instead of patient_id. 4) When filtering for patients diagnosed with RA: use Diagnosis = 'RA' directly in the WHERE clause instead of joining a separate diagnoses table. 5) When extracting birth year from date: use STRFTIME('%Y', Birthday) = '1980' instead of birth_year = 1980. 6) When performing division for percentage calculation: cast the sum to REAL instead of using 100.0 for proper floating-point division."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN p.gender = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_women\nFROM patients p\nJOIN diagnoses d ON p.patient_id = d.patient_id\nWHERE p.birth_year = 1980 \nAND d.diagnosis = 'RA';",
            "SELECT \n    (SUM(CASE WHEN p.SEX = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_female\nFROM \n    Patient p\nWHERE \n    STRFTIME('%Y', p.Birthday) = '1980' \n    AND p.Diagnosis = 'RA';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN p.SEX = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_women\nFROM \n    Patient p\nWHERE \n    STRFTIME('%Y', p.Birthday) = '1980' \n    AND p.Diagnosis = 'RA';"
        ],
        "amend_res": 1
    },
    "1154": {
        "db_id": "thrombosis_prediction",
        "question": "State the sex and birthday of patient ID '163109'. When was the examination taken and what symptom does the patient had.",
        "ground_truth": "SELECT T1.SEX, T1.Birthday, T2.`Examination Date`, T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = 163109",
        "amends": [
            "Do specify table aliases `T1` and `T2` instead of omitting them. Do use `T1.SEX` and `T1.Birthday` instead of `sex` and `birthday` without table qualification. Do use `T2.`Examination Date`` and `T2.Symptoms` instead of `examination_date` and `symptom`. Do add `INNER JOIN Examination AS T2 ON T1.ID = T2.ID` instead of querying only the patients table. Do use numeric comparison `T1.ID = 163109` instead of string comparison `patient_id = '163109'`. Do reference `T1.ID` instead of `patient_id` as the filter column. The amended query now correctly joins patient and examination data using proper table relationships and data types."
        ],
        "rules": [
            "1) When answering about patient information: make sure the output order: T1.SEX, T1.Birthday, T2.\"Examination Date\", T2.Symptoms\n2) When the question mentions \"patient ID '163109'\": use numeric comparison T1.ID = 163109 instead of string comparison\n3) When combining patient and examination data: link rows where T1.ID = T2.ID and keep only matching pairs (inner match)\n4) When selecting columns from multiple tables: qualify all columns with their table aliases (T1.SEX, T1.Birthday, T2.\"Examination Date\", T2.Symptoms)\n5) When referring to the examination date column: use the exact identifier T2.\"Examination Date\" with double quotes and proper case\n6) When referring to the symptoms column: use the exact identifier T2.Symptoms with proper case"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT sex, birthday, examination_date, symptom FROM patients WHERE patient_id = '163109';",
            "SELECT T1.SEX, T1.Birthday, T2.\"Examination Date\", T2.Symptoms \nFROM Patient AS T1 \nINNER JOIN Examination AS T2 ON T1.ID = T2.ID \nWHERE T1.ID = 163109"
        ],
        "rule_sql": [
            "SELECT T1.SEX, T1.Birthday, T2.\"Examination Date\", T2.Symptoms\nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T1.ID = 163109"
        ],
        "amend_res": 1
    },
    "1524": {
        "db_id": "debit_card_specializing",
        "question": "What's the nationality of the customer who spent 548.4 in 2012/8/24?",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Price = 548.4",
        "amends": [
            "Do select `T2.Country` instead of `nationality` from the result set. Do use `transactions_1k AS T1` and `gasstations AS T2` as source tables instead of `customers`. Do perform an `INNER JOIN` on `T1.GasStationID = T2.GasStationID` instead of querying a single table. Do filter with `T1.Date = '2012-08-24'` instead of `date = '2012/8/24'` using proper date format. Do filter with `T1.Price = 548.4` instead of `amount_spent = 548.4` using the correct column name. The amended query now correctly joins transaction and gas station data to retrieve the country information for the specified transaction."
        ],
        "rules": [
            "1) When answering about customer nationality for a specific transaction: use T2.Country instead of nationality from the result set. 2) When combining transaction and gas station data: link rows where T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match). 3) When filtering by date: use T1.Date = '2012-08-24' with the exact date format shown. 4) When filtering by transaction amount: use T1.Price = 548.4 instead of amount_spent. 5) When the question mentions \"customer who spent\": this actually means transaction data in T1 with Price column and gas station country in T2.Country."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality FROM customers WHERE amount_spent = 548.4 AND date = '2012/8/24';",
            "SELECT T2.Country \nFROM transactions_1k AS T1 \nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID \nWHERE T1.Date = '2012-08-24' AND T1.Price = 548.4"
        ],
        "rule_sql": [
            "SELECT T2.Country \nFROM transactions_1k T1 \nINNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID \nWHERE T1.Date = '2012-08-24' AND T1.Price = 548.4"
        ],
        "amend_res": 1
    },
    "1208": {
        "db_id": "thrombosis_prediction",
        "question": "Provide IDs for male patients with ALT glutamic pylvic transaminase (GPT) that have history of ALT glutamic pylvic transaminase (GPT) exceed the normal range.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.GPT >= 60",
        "amends": [
            "Do `SELECT DISTINCT T1.ID` instead of `SELECT patient_id` to return unique patient identifiers. Do `FROM Patient AS T1 INNER JOIN Laboratory AS T2` instead of `FROM patients` to join the Patient and Laboratory tables. Do `ON T1.ID = T2.ID` instead of no join condition to properly relate the tables. Do `WHERE T1.SEX = 'M'` instead of `WHERE gender = 'male'` to use the correct column name and value format. Do `AND T2.GPT >= 60` instead of `AND alt_gpt > 100 AND alt_gpt_history = 'normal'` to use the appropriate laboratory value threshold and remove the unnecessary history condition. The amended query now correctly identifies male patients with elevated GPT levels from the joined laboratory data."
        ],
        "rules": [
            "1) When selecting patient identifiers: use DISTINCT T1.ID to return unique patient IDs. 2) When combining Patient and Laboratory data: join T1 (Patient) and T2 (Laboratory) using T1.ID = T2.ID with an inner match. 3) When filtering for male patients: use T1.SEX = 'M' with exact case and quotes. 4) When checking for elevated GPT levels: use T2.GPT >= 60 with the exact column name and inclusive threshold. 5) When the question asks about ALT glutamic pylvic transaminase (GPT): this corresponds to the GPT column in the Laboratory table (T2.GPT)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE gender = 'male' AND alt_gpt > 100 AND alt_gpt_history = 'normal';",
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.GPT >= 60"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.GPT >= 60"
        ],
        "amend_res": 1
    },
    "524": {
        "db_id": "card_games",
        "question": "List the artists who illustrated cards with black borders which are available only in arena.",
        "ground_truth": "SELECT DISTINCT artist FROM cards WHERE availability = 'arena' AND BorderColor = 'black'",
        "amends": [
            "Do select `artist` instead of `a.name` from the `artists` table. Do remove the join to `artists` and `sets` tables instead of keeping them. Do filter on `availability = 'arena'` instead of `s.arena_only = 1`. Do filter on `BorderColor = 'black'` instead of `c.border = 'black'`. Do query only the `cards` table instead of multiple joined tables. The amended query now correctly identifies arena-only cards with black borders by directly accessing the relevant columns in the cards table."
        ],
        "rules": [
            "1) When the question asks for artists who illustrated cards: select the exact column \"artist\" from the \"cards\" table instead of joining to an \"artists\" table. 2) When filtering for black border cards: use the exact condition \"BorderColor = 'black'\" with the literal value 'black' exactly as specified. 3) When filtering for arena-only availability: use the exact condition \"availability = 'arena'\" with the literal value 'arena' exactly as specified. 4) When answering about card illustrations: query only the \"cards\" table directly instead of joining to other tables like \"artists\" or \"sets\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.name \nFROM artists a\nJOIN cards c ON a.id = c.artist_id\nJOIN sets s ON c.set_id = s.id\nWHERE c.border = 'black' \nAND s.arena_only = 1;",
            "SELECT DISTINCT artist FROM cards WHERE availability = 'arena' AND borderColor = 'black' AND artist IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT DISTINCT artist FROM cards WHERE borderColor = 'black' AND availability = 'arena' AND artist IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "1264": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients have blood clots in veins, how many of them have a normal level of complement 4?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C4 > 10 AND T1.Diagnosis = 'APS'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patients. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.C4 > 10` instead of `complement_4 = 'normal'` for numeric comparison. Do add `T1.Diagnosis = 'APS'` condition instead of omitting it. Do remove the `blood_clots_in_veins = 'yes'` filter instead of keeping it. The amended query now correctly counts distinct APS patients with elevated C4 levels from joined patient and laboratory data."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patients. 2) When combining patient and laboratory data: join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using inner match. 3) When filtering for complement 4 level: use T2.C4 > 10 for numeric comparison instead of text-based 'normal' value. 4) When identifying APS patients: include condition T1.Diagnosis = 'APS' to filter for antiphospholipid syndrome patients. 5) When the question mentions \"blood clots in veins\": this condition is already implied by T1.Diagnosis = 'APS' and should not be added as a separate filter."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients \nWHERE blood_clots_in_veins = 'yes' \nAND complement_4 = 'normal';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nJOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'APS' \nAND T2.C4 > 10"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'APS' \nAND T2.C4 > 10"
        ],
        "amend_res": 1
    },
    "440": {
        "db_id": "card_games",
        "question": "Which foreign language used by \"A Pedra Fellwar\"?",
        "ground_truth": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'",
        "amends": [
            "Do query the `foreign_data` table instead of the `artists` table. Do add `DISTINCT` to return unique language values instead of potentially returning duplicates. Do keep the filter `name = 'A Pedra Fellwar'` unchanged as it correctly identifies the specific record. The amended query now correctly retrieves distinct language values from the appropriate data source, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about foreign language usage by a specific artist: query the \"foreign_data\" table instead of the \"artists\" table. 2) When retrieving language values for a specific artist: use DISTINCT to return only unique language values and avoid duplicates. 3) When filtering for a specific artist name: use the exact literal 'A Pedra Fellwar' with the condition name = 'A Pedra Fellwar' to identify the correct record."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM artists WHERE name = 'A Pedra Fellwar';",
            "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar';"
        ],
        "rule_sql": [
            "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar';"
        ],
        "amend_res": 1
    },
    "957": {
        "db_id": "formula_1",
        "question": "How many Italian drivers haven't finished the race?",
        "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Italian' AND T1.time IS NULL",
        "amends": [
            "Do select `COUNT(T1.driverId)` instead of `COUNT(*)` to count specific driver IDs rather than all rows. Do use `results AS T1` and `drivers AS T2` as FROM sources instead of only `drivers` to join the two tables. Do add `INNER JOIN` on `T1.driverId = T2.driverId` instead of omitting the join condition to properly relate results to drivers. Do change the nationality filter to `T2.nationality = 'Italian'` instead of applying it directly to the drivers table without proper context. Do replace `position = 'DNF'` with `T1.time IS NULL` instead of using an incorrect position filter, as NULL time indicates a Did Not Finish status. The amended query now correctly counts Italian drivers who did not finish races by joining results and drivers tables and checking for NULL time values."
        ],
        "rules": [
            "1) When answering about \"Italian drivers who haven't finished the race\": make sure the output order: COUNT(T1.driverId). 2) When the question mentions \"Italian drivers\": \"Italian\" actually means \"T2.nationality = 'Italian'\" in schema. 3) When the question mentions \"haven't finished the race\": this actually means \"T1.time IS NULL\" in schema. 4) When combining T1 (results) and T2 (drivers) for shared entities: link rows where T1.driverId = T2.driverId exactly as shown in the amends; keep only matching pairs (inner match). 5) When counting drivers: compute the number of rows using the canonical key token T1.driverId rather than counting all rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'Italian' AND position = 'DNF';",
            "SELECT COUNT(T1.driverId) \nFROM results AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T2.nationality = 'Italian' AND T1.time IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.driverId) \nFROM results T1 \nINNER JOIN drivers T2 ON T1.driverId = T2.driverId \nWHERE T2.nationality = 'Italian' AND T1.time IS NULL"
        ],
        "amend_res": 1
    },
    "1414": {
        "db_id": "student_club",
        "question": "State the name of major that Phillip Cullen has joined.",
        "ground_truth": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "amends": [
            "Do select `T1.major_name` from the `major` table instead of `major_name` from the `students` table. Do add `INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major` instead of querying the `students` table directly. Do apply the filters `T2.first_name = 'Phillip'` and `T2.last_name = 'Cullen'` on the joined `member` table instead of filtering a non-existent `students` table. The amended query now correctly joins the major and member tables to retrieve the major name for the specified person, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about a person's major: use the \"major\" table as T1 and the \"member\" table as T2 instead of a \"students\" table. 2) When joining T1 and T2: link rows where T1.major_id = T2.link_to_major using an inner match. 3) When filtering for a specific person named \"Phillip Cullen\": apply T2.first_name = 'Phillip' and T2.last_name = 'Cullen' exactly as specified. 4) When selecting the major name: output T1.major_name from the major table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT major_name FROM students WHERE first_name = 'Phillip' AND last_name = 'Cullen'",
            "SELECT T1.major_name \nFROM major AS T1 \nINNER JOIN member AS T2 ON T1.major_id = T2.link_to_major \nWHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'"
        ],
        "rule_sql": [
            "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'"
        ],
        "amend_res": 1
    },
    "738": {
        "db_id": "superhero",
        "question": "Which superheroes have a durability attribute value of less than 50?",
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "amends": [
            "Do reference `superhero_name` from table `superhero` instead of `name` from `superheroes`. Do use an EXISTS subquery with joined tables `hero_attribute` and `attribute` instead of a simple WHERE filter. Do check for `attribute_name = 'Durability'` and `attribute_value < 50` instead of directly comparing `durability > 50`. Do add the correlation condition `T1.id = T2.hero_id` to link the subquery to the main table instead of omitting table relationships. The amended query now correctly identifies superheroes with durability below 50 by properly joining attribute tables and using the correct comparison logic."
        ],
        "rules": [
            "1) When the question asks about superheroes: use the exact column \"superhero_name\" from table \"superhero\" instead of \"name\" from \"superheroes\". 2) When checking for durability attribute values: use an EXISTS subquery with joined tables \"hero_attribute\" and \"attribute\" instead of a simple WHERE filter. 3) When filtering for durability: check for \"attribute_name = 'Durability'\" and \"attribute_value < 50\" instead of directly comparing \"durability > 50\". 4) When linking the subquery to the main table: add the correlation condition \"T1.id = T2.hero_id\" to properly connect the tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE durability > 50;",
            "SELECT superhero_name \nFROM superhero \nWHERE EXISTS (\n    SELECT 1 \n    FROM hero_attribute \n    JOIN attribute ON hero_attribute.attribute_id = attribute.id \n    WHERE hero_attribute.hero_id = superhero.id \n    AND attribute.attribute_name = 'Durability' \n    AND hero_attribute.attribute_value < 50\n)"
        ],
        "rule_sql": [
            "SELECT superhero_name \nFROM superhero T1\nWHERE EXISTS (\n    SELECT 1 \n    FROM hero_attribute T2\n    JOIN attribute T3 ON T2.attribute_id = T3.id\n    WHERE T3.attribute_name = 'Durability' \n    AND T2.attribute_value < 50\n    AND T1.id = T2.hero_id\n)"
        ],
        "amend_res": 1
    },
    "694": {
        "db_id": "codebase_community",
        "question": "Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.",
        "ground_truth": "SELECT T3.Text, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T2.Title = 'Analysing wind data with R' ORDER BY T1.CreationDate DESC LIMIT 10",
        "amends": [
            "Do join `users` to `posts` on `users.Id = posts.OwnerUserId` instead of joining `comments` directly to `users` on `comments.UserId = users.Id`. Do then join `comments` to `posts` on `posts.Id = comments.PostId` instead of joining `comments` to `posts` on `comments.PostId = posts.Id`. Do select `comments.Text` and `users.DisplayName` instead of selecting `comments.Text` and `users.DisplayName` with different table aliases. Do order by `users.CreationDate DESC` instead of `comments.CreationDate ASC`. The amended query now correctly retrieves comments on posts with the specified title while ordering by user creation date in descending order."
        ],
        "rules": [
            "1) When the question asks for comments to a post with specific title 'Analysing wind data with R': join posts to users on users.Id = posts.OwnerUserId to connect post owners. 2) When retrieving comments for posts: join comments to posts on posts.Id = comments.PostId to link comments to their respective posts. 3) When selecting output columns: include comments.Text and users.DisplayName exactly as specified. 4) When ordering results for \"latest\" comments: sort by users.CreationDate in descending order instead of comments.CreationDate. 5) When limiting to the latest 10 results: take the first 10 rows after ordering by user creation date descending."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.Text, u.DisplayName \nFROM Comments c \nJOIN Users u ON c.UserId = u.Id \nJOIN Posts p ON c.PostId = p.Id \nWHERE p.Title = 'Analysing wind data with R' \nORDER BY c.CreationDate ASC \nLIMIT 10;",
            "SELECT comments.Text, users.DisplayName\nFROM posts\nJOIN users ON users.Id = posts.OwnerUserId\nJOIN comments ON posts.Id = comments.PostId\nWHERE posts.Title = 'Analysing wind data with R'\nORDER BY users.CreationDate DESC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT comments.Text, users.DisplayName\nFROM comments\nJOIN posts ON posts.Id = comments.PostId\nJOIN users ON users.Id = comments.UserId\nWHERE posts.Title = 'Analysing wind data with R'\nORDER BY users.CreationDate DESC\nLIMIT 10"
        ],
        "amend_res": 1
    },
    "443": {
        "db_id": "card_games",
        "question": "Give the code of sets have expansion type of 'expansion'?",
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'expansion' GROUP BY T2.setCode",
        "amends": [
            "Do select `T2.setCode` instead of `code`. Do add `INNER JOIN set_translations AS T2` instead of omitting it, with join condition `T2.setCode = T1.code` instead of no join. Do use table alias `T1` for sets instead of no alias. Do filter on `T1.type = 'expansion'` instead of `expansion_type = 'expansion'`. Do add `GROUP BY T2.setCode` instead of omitting grouping. The amended query now correctly joins translation data and groups by set code instead of returning individual set records."
        ],
        "rules": [
            "1) When the question asks for \"code of sets\": use \"T2.setCode\" instead of \"code\" from the sets table. 2) When combining sets and set_translations tables: link rows where \"T2.setCode = T1.code\" and keep only matching pairs (inner match). 3) When filtering for expansion type: use \"T1.type = 'expansion'\" instead of \"expansion_type = 'expansion'\". 4) When grouping results: organize by \"T2.setCode\" to return unique set codes instead of individual records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM sets WHERE expansion_type = 'expansion';",
            "SELECT T2.setCode\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code\nWHERE T1.type = 'expansion'\nGROUP BY T2.setCode"
        ],
        "rule_sql": [
            "SELECT T2.setCode\nFROM sets T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.code\nWHERE T1.type = 'expansion'\nGROUP BY T2.setCode"
        ],
        "amend_res": 1
    },
    "472": {
        "db_id": "card_games",
        "question": "Among the sets in the block \"Ice Age\", how many of them have an Italian translation?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block = 'Ice Age' AND T2.language = 'Italian' AND T2.translation IS NOT NULL",
        "amends": [
            "Do `COUNT(DISTINCT T1.id)` instead of `COUNT(*)` to count distinct set IDs rather than all rows. Do `INNER JOIN set_translations AS T2` instead of `JOIN translations` with the correct table name and alias. Do join on `T2.setCode = T1.code` instead of `s.set_id = t.set_id` with the proper join condition. Do filter on `T1.block = 'Ice Age'` instead of `s.theme = 'Ice Age'` with the correct column name. Do add `AND T2.translation IS NOT NULL` instead of omitting this null check to exclude untranslated records. The amended query now correctly counts distinct Ice Age sets with Italian translations while ensuring translations exist."
        ],
        "rules": [
            "1) When answering about \"sets in the block 'Ice Age' with Italian translation\": make sure the output order: count of distinct sets\n2) When the question mentions \"sets in the block 'Ice Age'\": \"block\" actually means \"T1.block in schema\" and use literal 'Ice Age'\n3) When the question mentions \"Italian translation\": \"Italian\" actually means \"T2.language = 'Italian' in schema\"\n4) When combining T1 and T2 for shared entities: link rows where T2.setCode = T1.code exactly as shown in the amends; keep only matching pairs (inner match)\n5) When counting sets: compute the number of distinct values using T1.id as the counting key\n6) When handling translations: include only rows where T2.translation IS NOT NULL to exclude untranslated records\n7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n8) When handling text literals: do not change case, spacing, or punctuation of 'Ice Age' or 'Italian'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM sets s JOIN translations t ON s.set_id = t.set_id WHERE s.theme = 'Ice Age' AND t.language = 'Italian';",
            "SELECT COUNT(DISTINCT T1.id) \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code \nWHERE T1.block = 'Ice Age' \nAND T2.language = 'Italian' \nAND T2.translation IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT s.id) \nFROM \"sets\" s\nINNER JOIN \"set_translations\" st ON s.code = st.setCode\nWHERE s.block = 'Ice Age' \nAND st.language = 'Italian' \nAND st.translation IS NOT NULL"
        ],
        "amend_res": 1
    },
    "1260": {
        "db_id": "thrombosis_prediction",
        "question": "Please list the ID of the patient whose RF is normal and who is older than 60.",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60",
        "amends": [
            "Do select `T1.ID` instead of `patient_id`. Do join `Patient AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.RF < 20` instead of `rf = 'normal'`. Do calculate age using `STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60` instead of using a simple `age > 60` column. The amended query now correctly joins patient and laboratory data, uses proper numeric comparison for RF values, and calculates age dynamically from birthdate rather than relying on a static age column."
        ],
        "rules": [
            "1) When selecting patient identification: use \"T1.ID\" instead of \"patient_id\" as the output column. 2) When combining patient and laboratory data: link rows where \"T1.ID = T2.ID\" using an inner match between Patient table (T1) and Laboratory table (T2). 3) When filtering for normal RF values: use numeric comparison \"T2.RF < 20\" instead of string comparison with 'normal'. 4) When calculating age for patients older than 60: compute age dynamically using \"STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60\" instead of relying on a static age column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE rf = 'normal' AND age > 60;",
            "SELECT T1.ID \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.RF < 20 \nAND (STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday)) > 60"
        ],
        "rule_sql": [
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.RF < 20\nAND (STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday)) > 60\nGROUP BY T1.ID;"
        ],
        "amend_res": 1
    },
    "142": {
        "db_id": "financial",
        "question": "Which accounts placed orders for household payment in Pisek?",
        "ground_truth": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.k_symbol = 'SIPO' AND T3.A2 = 'Pisek'",
        "amends": [
            "Do select only `T2.account_id` with `DISTINCT` instead of all columns with `*`. Do join `trans AS T1` and `account AS T2` on `T1.account_id = T2.account_id` instead of querying only `accounts`. Do add `district AS T3` joined on `T2.district_id = T3.district_id` instead of omitting it. Do filter with `T1.k_symbol = 'SIPO'` instead of `payment_type = 'household'`. Do filter with `T3.A2 = 'Pisek'` on district name instead of `city = 'Pisek'` on account table. The amended query now correctly identifies accounts with SIPO payments in the Pisek district instead of incorrectly filtering by city and payment_type columns that may not exist or have the intended semantics."
        ],
        "rules": [
            "1) When answering about accounts placing orders for household payment in Pisek: make sure the output order: T2.account_id with DISTINCT. 2) When the question mentions \"household payment\": \"household payment\" actually means \"T1.k_symbol = 'SIPO'\" in schema. 3) When the question mentions \"Pisek\": \"Pisek\" actually means \"T3.A2 = 'Pisek'\" in schema (district name, not account city). 4) When combining T1 (trans) and T2 (account) for shared entities: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match). 5) When combining T2 (account) and T3 (district) for shared entities: link rows where T2.district_id = T3.district_id and keep only matching pairs (inner match). 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 7) When handling text literals: do not change case, spacing, or punctuation for 'SIPO' or 'Pisek'."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM accounts WHERE city = 'Pisek' AND payment_type = 'household';",
            "SELECT DISTINCT T2.account_id\nFROM trans AS T1\nJOIN account AS T2 ON T1.account_id = T2.account_id\nJOIN district AS T3 ON T2.district_id = T3.district_id\nWHERE T1.k_symbol = 'SIPO'\nAND T3.A2 = 'Pisek'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.account_id\nFROM \"order\" T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN district T3 ON T2.district_id = T3.district_id\nWHERE T1.k_symbol = 'SIPO'\nAND T3.A2 = 'Pisek'"
        ],
        "amend_res": 1
    },
    "614": {
        "db_id": "codebase_community",
        "question": "Among the users who obtained the \"Teacher\" badge, calculate their percentage of users",
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) * 100 / (SELECT COUNT(Id) FROM users) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Teacher'",
        "amends": [],
        "rules": [],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users) AS percentage FROM badges WHERE name = 'Teacher';"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(DISTINCT b.UserId) * 100.0 / (SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Teacher')) AS percentage\nFROM \n    badges b\nWHERE \n    b.Name = 'Teacher';",
            "SELECT \n    (COUNT(DISTINCT b.UserId) * 100.0 / (SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Teacher')) AS percentage\nFROM badges b\nWHERE b.Name = 'Teacher';"
        ],
        "amend_res": 1
    },
    "815": {
        "db_id": "superhero",
        "question": "Count the good female superheroes.",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Good' AND T3.gender = 'Female'",
        "amends": [
            "Do use explicit table joins with `INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id` and `INNER JOIN gender AS T3 ON T1.gender_id = T3.id` instead of direct column references. Do filter on `T2.alignment = 'Good'` and `T3.gender = 'Female'` instead of `gender = 'male' AND alignment = 'good'`. Do count specific column `T1.id` instead of `COUNT(*)`. Do use proper case sensitivity with `'Good'` and `'Female'` instead of lowercase values. The amended query now correctly joins related tables and filters based on the normalized database structure."
        ],
        "rules": [
            "1) When counting superheroes: use the canonical key T1.id instead of counting all columns. 2) When filtering by alignment: join table \"alignment\" as T2 using T1.alignment_id = T2.id and filter where T2.alignment = 'Good' (case-sensitive). 3) When filtering by gender: join table \"gender\" as T3 using T1.gender_id = T3.id and filter where T3.gender = 'Female' (case-sensitive). 4) When combining tables for filtering: perform inner matches only, keeping only superheroes that have both alignment and gender records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE gender = 'male' AND alignment = 'good';",
            "SELECT COUNT(T1.id) \nFROM superhero AS T1\nINNER JOIN alignment AS T2 ON T1.alignment_id = T2.id\nINNER JOIN gender AS T3 ON T1.gender_id = T3.id\nWHERE T2.alignment = 'Good' AND T3.gender = 'Female'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero T1\nINNER JOIN alignment T2 ON T1.alignment_id = T2.id\nINNER JOIN gender T3 ON T1.gender_id = T3.id\nWHERE T2.alignment = 'Good' AND T3.gender = 'Female'"
        ],
        "amend_res": 1
    },
    "823": {
        "db_id": "superhero",
        "question": "How many female superheroes are in Marvel Comics?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.gender = 'Female'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `publisher AS T2` on `T1.publisher_id = T2.id` instead of filtering directly on `publisher`. Do join `gender AS T3` on `T1.gender_id = T3.id` instead of filtering directly on `gender`. Do filter on `T2.publisher_name = 'Marvel Comics'` instead of `publisher = 'Marvel Comics'`. Do filter on `T3.gender = 'Female'` instead of `gender = 'Male'`. Do count `T1.id` instead of `COUNT(*)` for more precise counting. The amended query now correctly uses proper join relationships and filters through normalized tables instead of direct column references."
        ],
        "rules": [
            "1) When answering about \"female superheroes in Marvel Comics\": make sure the output order: count of superheroes\n2) When the question mentions \"female\": \"female\" actually means \"T3.gender = 'Female'\" in schema\n3) When the question mentions \"Marvel Comics\": \"Marvel Comics\" actually means \"T2.publisher_name = 'Marvel Comics'\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T1.publisher_id = T2.id; keep only matching pairs (inner match)\n5) When combining T1 and T3 for shared entities: link rows where T1.gender_id = T3.id; keep only matching pairs (inner match)\n6) When the question asks for \"count of superheroes\": compute the number of rows using the canonical key token T1.id\n7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n8) When handling text literals: do not change case, spacing, or punctuation - use exactly 'Female' and 'Marvel Comics'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE gender = 'Male' AND publisher = 'Marvel Comics';",
            "SELECT COUNT(T1.id) \nFROM superhero AS T1\nJOIN publisher AS T2 ON T1.publisher_id = T2.id\nJOIN gender AS T3 ON T1.gender_id = T3.id\nWHERE T2.publisher_name = 'Marvel Comics' AND T3.gender = 'Female'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nINNER JOIN gender T3 ON T1.gender_id = T3.id\nWHERE T3.gender = 'Female' AND T2.publisher_name = 'Marvel Comics'"
        ],
        "amend_res": 1
    },
    "80": {
        "db_id": "california_schools",
        "question": "What is the school type of the school with the highest latitude? Indicate the name of the school as well as the latitude coordinates.",
        "evidence": "",
        "ground_truth": "SELECT T1.`School Type`, T1.`School Name`, T2.Latitude FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.Latitude DESC LIMIT 1",
        "amends": [
            "Do select `School Type`, `School Name`, and `Latitude` instead of `school_name`, `latitude`, and `school_type`. Do use `INNER JOIN` between `frpm` and `schools` tables on `CDSCode` instead of querying only the `schools` table. Do order by `Latitude DESC` instead of `latitude ASC`. The amended query now correctly joins the required tables and returns the highest latitude school with proper column selection and ordering."
        ],
        "rules": [
            "1) When selecting columns for school information: use \"School Type\" from table frpm, \"School Name\" from table frpm, and \"Latitude\" from table schools instead of school_name, latitude, and school_type. 2) When combining school data from multiple tables: perform an inner join between frpm table (as T1) and schools table (as T2) using the exact key equality T1.CDSCode = T2.CDSCode. 3) When finding the school with the highest latitude: order results by \"Latitude\" in descending order (DESC) instead of ascending order (ASC). 4) When answering about the school with highest latitude: make sure the output order is \"School Name\", \"Latitude\", and \"School Type\"."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name, latitude, school_type FROM schools ORDER BY latitude ASC LIMIT 1;",
            "SELECT f.\"School Type\", f.\"School Name\", s.Latitude\nFROM frpm f\nINNER JOIN schools s ON f.CDSCode = s.CDSCode\nORDER BY s.Latitude DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.\"School Name\", T2.Latitude, T1.\"School Type\" \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nORDER BY T2.Latitude DESC \nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "219": {
        "db_id": "toxicology",
        "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
        "amends": [
            "Do use `COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END)` instead of `COUNT(CASE WHEN is_carcinogenic = 1 THEN 1 END)` for counting distinct carcinogenic molecules. Do change the data source from `molecules` table to joining `atom AS T1`, `molecule AS T2`, and `bond AS T3` instead of a single table. Do use `INNER JOIN` between `T1` and `T2` on `T1.molecule_id = T2.molecule_id` and between `T2` and `T3` on `T2.molecule_id = T3.molecule_id` instead of no joins. Do change the WHERE filter to `T3.bond_type = '#'` instead of `bond_type = 'triple'`. Do add explicit `CAST` to `REAL` instead of implicit conversion. Do calculate percentage using distinct molecule counts instead of total row counts. The amended query now correctly calculates the percentage of carcinogenic molecules with triple bonds by properly joining related tables and using distinct counts."
        ],
        "rules": [
            "1) When answering about percentage of carcinogenic molecules in triple type bonds: make sure the output order: percentage_carcinogenic\n2) When the question mentions \"carcinogenic molecules\": \"carcinogenic\" actually means T2.label = '+' in schema\n3) When the question mentions \"triple type bonds\": \"triple\" actually means T3.bond_type = '#' in schema\n4) When combining T1, T2, and T3 for shared entities: link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match)\n5) When counting carcinogenic molecules: compute the number of distinct T2.molecule_id where T2.label = '+'\n6) When calculating percentage: compute (distinct carcinogenic molecules) divided by (total distinct molecules with triple bonds), guarding division by zero\n7) When handling numeric conversion: explicitly cast the result to REAL type instead of implicit conversion"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN is_carcinogenic = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_carcinogenic\nFROM molecules\nWHERE bond_type = 'triple';",
            "SELECT \n    CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100.0 / \n    COUNT(DISTINCT T2.molecule_id) AS percentage\nFROM \n    atom AS T1\nINNER JOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN \n    bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE \n    T3.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT \n    CASE \n        WHEN COUNT(DISTINCT T3.molecule_id) = 0 THEN 0.0\n        ELSE CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id END) AS REAL) / COUNT(DISTINCT T3.molecule_id) \n    END * 100.0 AS percentage_carcinogenic\nFROM \n    bond T3\nINNER JOIN \n    molecule T2 ON T3.molecule_id = T2.molecule_id\nWHERE \n    T3.bond_type = '#'"
        ],
        "amend_res": 1
    },
    "296": {
        "db_id": "toxicology",
        "question": "Indicate the molecule id is belonging to the TR000_1_2 bond that has the first atom named TR000_1.",
        "evidence": "",
        "ground_truth": "SELECT T2.molecule_id, T2.bond_id, T1.atom_id FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'",
        "amends": [
            "Do select `T2.molecule_id, T2.bond_id, T1.atom_id` instead of just `molecule_id`. Do use `FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id` instead of `FROM bonds`. Do add filter `T1.atom_id = 'TR000_1'` instead of `atom1_name = 'TR000_1'`. Do use `T2.bond_id = 'TR000_1_2'` instead of `bond_name = 'TR000_1_2'`. The amended query now correctly joins the connected and bond tables to retrieve the complete relationship information."
        ],
        "rules": [
            "1) When answering about molecule id belonging to a bond: select T2.molecule_id, T2.bond_id, and T1.atom_id instead of just molecule_id. 2) When joining tables for bond relationships: use connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id instead of querying a single bonds table. 3) When filtering for atom named TR000_1: use T1.atom_id = 'TR000_1' instead of atom1_name = 'TR000_1'. 4) When filtering for bond TR000_1_2: use T2.bond_id = 'TR000_1_2' instead of bond_name = 'TR000_1_2'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM bonds WHERE bond_name = 'TR000_1_2' AND atom1_name = 'TR000_1';",
            "SELECT T2.molecule_id, T2.bond_id, T1.atom_id \nFROM connected AS T1 \nINNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id \nWHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'"
        ],
        "rule_sql": [
            "SELECT T2.molecule_id, T2.bond_id, T1.atom_id\nFROM connected AS T1\nINNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id\nWHERE T2.bond_id = 'TR000_1_2' AND T1.atom_id = 'TR000_1'"
        ],
        "amend_res": 1
    },
    "1459": {
        "db_id": "student_club",
        "question": "What is the major of Garrett Gerke and which department does it belong to?",
        "ground_truth": "SELECT T2.major_name, T2.department FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'",
        "amends": [
            "Do select `T2.major_name` and `T2.department` instead of `major` and `department`. Do use `FROM member AS T1 INNER JOIN major AS T2` instead of `FROM students`. Do add join condition `ON T2.major_id = T1.link_to_major` instead of omitting it. Do change filter to `T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'` instead of `name = 'Garrett Gerke'`. The amended query now correctly joins member and major tables to retrieve major information based on the proper relationship and name filtering."
        ],
        "rules": [
            "1) When the question asks about a person's major and department: select T2.major_name and T2.department as output columns. 2) When querying for information about a person: use FROM member AS T1 INNER JOIN major AS T2 instead of a single table. 3) When joining member and major tables: link rows where T2.major_id = T1.link_to_major to establish the proper relationship. 4) When filtering by a person's name: use T1.first_name = 'Garrett' AND T1.last_name = 'Gerke' instead of a single name field, matching the exact case and spacing of the literal values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT major, department FROM students WHERE name = 'Garrett Gerke';",
            "SELECT T2.major_name, T2.department FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'"
        ],
        "rule_sql": [
            "SELECT T2.major_name, T2.department FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'"
        ],
        "amend_res": 1
    },
    "490": {
        "db_id": "card_games",
        "question": "For the set which had 'SS2' as the code, what is its magic card market id?",
        "ground_truth": "SELECT mcmId FROM sets WHERE code = 'SS2'",
        "amends": [
            "Do use column alias `mcmId` instead of `magic_card_market_id` in the SELECT list. Do filter for code value `'SS2'` instead of `'SS1'` in the WHERE clause. The amended query now correctly retrieves the mcmId for the SS2 set code instead of the SS1 set code."
        ],
        "rules": [
            "1) When the question asks for 'magic card market id': use the exact column name \"mcmId\" from the sets table. 2) When filtering for sets with code 'SS2': use the exact literal value 'SS2' in the WHERE clause condition. 3) When selecting from the sets table: only retrieve the \"mcmId\" column as output."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT magic_card_market_id FROM sets WHERE code = 'SS1';",
            "SELECT mcmId FROM sets WHERE code = 'SS2';"
        ],
        "rule_sql": [
            "SELECT mcmId FROM sets WHERE code = 'SS2';"
        ],
        "amend_res": 1
    },
    "1039": {
        "db_id": "european_football_2",
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "ground_truth": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
        "amends": [
            "Do use `SUM(t2.long_shots)` and `COUNT(t2.date)` with a division instead of `AVG(long_shot)` to calculate the average manually. Do add `INNER JOIN` on `t1.player_api_id = t2.player_api_id` instead of querying a single table. Do reference `t2.long_shots` from the joined table instead of `long_shot` from the main table. Do use `t1.player_name` filter instead of `name` to correctly identify the player. Do add `CAST` to `REAL` for the division instead of relying on implicit casting. Do include both `Player` and `Player_Attributes` tables instead of only one table. The amended query now correctly calculates the average long shots per game date for the specified player by joining the necessary tables and handling the division with proper casting."
        ],
        "rules": [
            "1) When answering about \"average number of long-shot done by Ahmed Samir Farag\": make sure the output order: calculate average manually using SUM(t2.long_shots) divided by COUNT(t2.date) with CAST to REAL instead of using AVG function. 2) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id exactly and keep only matching pairs (inner match). 3) When the question mentions \"long-shot\": \"long-shot\" actually means \"t2.long_shots\" in schema from the Player_Attributes table. 4) When the question mentions \"Ahmed Samir Farag\": \"Ahmed Samir Farag\" actually means filtering by t1.player_name = 'Ahmed Samir Farag' exactly as written. 5) When handling division operations: always use CAST to REAL for the division to ensure proper numeric casting instead of relying on implicit casting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(long_shot) FROM players WHERE name = 'Ahmed Samir Farag';",
            "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.date) AS average_long_shots\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Ahmed Samir Farag'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(t2.long_shots) AS REAL) / CAST(COUNT(t2.date) AS REAL) AS average_long_shots\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Ahmed Samir Farag';"
        ],
        "amend_res": 1
    },
    "1007": {
        "db_id": "formula_1",
        "question": "What was the longest time that Lewis Hamilton had spent at a pit stop?",
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.duration DESC LIMIT 1",
        "amends": [
            "Do use an explicit `INNER JOIN` between `pitStops` and `drivers` on `driverId` instead of a subquery for driver lookup. Do select the actual `duration` column instead of using `MAX(pit_stop_duration)` which incorrectly assumes aggregation. Do add `ORDER BY duration DESC LIMIT 1` to get the maximum value instead of using an aggregate function. Do reference tables with aliases `T1` and `T2` instead of using bare table names. Do use proper column names `driverId`, `forename`, and `surname` instead of potentially incorrect column references. The amended query now correctly retrieves the maximum pit stop duration by sorting and limiting rather than using inappropriate aggregation.",
            "Do remove `T2.forename` and `T2.surname` from the SELECT list instead of including them, as these columns are only needed for filtering in the WHERE clause but not for the final output. Do keep the same `INNER JOIN` on `T1.driverId = T2.driverId` instead of changing the join logic. Do maintain the same WHERE filter on `T2.forename = 'Lewis'` and `T2.surname = 'Hamilton'` instead of altering the filtering conditions. Do preserve the same ORDER BY `T1.duration DESC` and LIMIT 1 instead of modifying the sorting and limiting behavior. The amended query now correctly returns only the pit stop duration for Lewis Hamilton's longest pit stop instead of including unnecessary driver name columns in the output."
        ],
        "rules": [
            "1) When answering about \"longest time spent at a pit stop\": make sure the output order: duration DESC LIMIT 1. 2) When combining T1 (pitStops) and T2 (drivers) for shared entities: link rows where T1.driverId = T2.driverId; keep only matching pairs (inner match). 3) When the question mentions \"Lewis Hamilton\": \"Lewis Hamilton\" actually means \"T2.forename = 'Lewis' AND T2.surname = 'Hamilton' in schema\". 4) When selecting the duration value: use T1.duration instead of MAX(pit_stop_duration) since we need the actual duration value, not an aggregate function.",
            "1) When the question asks for the longest time spent at a pit stop for Lewis Hamilton: return only the duration value instead of including driver name columns in the output. 2) When filtering for Lewis Hamilton: use exact literal values 'Lewis' for forename and 'Hamilton' for surname. 3) When finding the longest duration: sort by duration in descending order and take only the top result. 4) When joining pitStops and drivers tables: link rows where T1.driverId equals T2.driverId using an inner match."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(pit_stop_duration) FROM pit_stops WHERE driver_id = (SELECT driver_id FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton');",
            "SELECT T2.forename, T2.surname, T1.duration \nFROM pitStops T1 \nINNER JOIN drivers T2 ON T1.driverId = T2.driverId \nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' \nORDER BY T1.duration DESC \nLIMIT 1",
            "SELECT T1.duration\nFROM pitStops T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'\nORDER BY T1.duration DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT p.duration \nFROM pitStops p\nINNER JOIN drivers d ON p.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nORDER BY p.duration DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "134": {
        "db_id": "financial",
        "question": "In the branch where the largest number of crimes were committed in 1996, how many accounts were opened?",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY T1.A16 ORDER BY T1.A16 DESC LIMIT 1",
        "amends": [
            "Do select `COUNT(T2.account_id)` instead of `COUNT(*)` to count specific account records rather than all rows. Do use `FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id` instead of `FROM accounts` with a subquery to properly join the district and account tables. Do add `GROUP BY T1.A16` instead of omitting grouping to aggregate counts by district attribute. Do add `ORDER BY T1.A16 DESC LIMIT 1` instead of ordering by crime count to get the district with the highest account count. Do remove the subquery filtering by `branch_id` and `year = 1996` instead of keeping the incorrect crime-based filtering logic. The amended query now correctly counts accounts per district and returns the district with the highest account count, matching the intended behavior."
        ],
        "rules": [
            "1) When counting accounts: use COUNT(T2.account_id) instead of COUNT(*) to count specific account records. 2) When combining district and account tables: link rows where T1.district_id = T2.district_id using an inner match. 3) When organizing results by district: group by T1.A16 to aggregate counts per district. 4) When finding the district with the highest account count: order by T1.A16 DESC and keep only the first row (LIMIT 1). 5) When the question mentions crimes in 1996: do not include crime-based filtering logic as it is incorrect for this query."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE branch_id = (SELECT branch_id FROM crimes WHERE year = 1996 GROUP BY branch_id ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT COUNT(T2.account_id) \nFROM district AS T1 \nINNER JOIN account AS T2 ON T1.district_id = T2.district_id \nGROUP BY T1.A16 \nORDER BY COUNT(T2.account_id) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.account_id) AS account_count\nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nGROUP BY T1.A16\nORDER BY T1.A16 DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "243": {
        "db_id": "toxicology",
        "question": "What are the bonds that have phosphorus and nitrogen as their atom elements?",
        "ground_truth": "SELECT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id IN ( SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p' ) AND T1.element = 'n'",
        "amends": [
            "Do select only `T2.bond_id` instead of all columns with `*`. Do join `atom AS T1` with `connected AS T2` using `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of querying `bonds` table directly. Do add a subquery to find bonds connected to phosphorus atoms with `T2.bond_id IN (SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p')` instead of simple OR conditions. Do filter for nitrogen atoms with `T1.element = 'n'` instead of `atom_element = 'nitrogen'`. Do use proper element symbols `'p'` and `'n'` instead of full element names. The amended query now correctly finds bonds connecting nitrogen atoms to phosphorus atoms by using proper joins and subqueries instead of the incorrect direct table query with OR conditions."
        ],
        "rules": [
            "1) When answering about bonds with phosphorus and nitrogen as atom elements: make sure the output order: T2.bond_id\n2) When combining atom and connected tables: link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner match)\n3) When filtering for nitrogen atoms: use T1.element = 'n' with exact literal 'n'\n4) When finding bonds connected to phosphorus atoms: use a subquery with connected AS T3 and atom AS T4 linked by T3.atom_id = T4.atom_id where T4.element = 'p' with exact literal 'p'\n5) When selecting bonds: use T2.bond_id IN (subquery for phosphorus bonds) instead of OR conditions\n6) When handling element symbols: use exact symbols 'p' and 'n' instead of full element names like 'phosphorus' or 'nitrogen'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM bonds WHERE atom_element = 'phosphorus' OR atom_element = 'nitrogen';",
            "SELECT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'n'\nAND T2.bond_id IN (\n    SELECT T3.bond_id\n    FROM connected AS T3\n    INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id\n    WHERE T4.element = 'p'\n)"
        ],
        "rule_sql": [
            "SELECT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'n'\nAND T2.bond_id IN (\n    SELECT T3.bond_id\n    FROM connected AS T3\n    INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id\n    WHERE T4.element = 'p'\n)"
        ],
        "amend_res": 1
    },
    "1259": {
        "db_id": "thrombosis_prediction",
        "question": "Please list the diseases of the patients born after 1985-1-1 and have a normal Rhuematoid Factor.",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > '1985-01-01'",
        "amends": [
            "Do select `T1.Diagnosis` instead of `disease` and use table aliases `T1` and `T2` instead of single table reference. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the patients table. Do change the filter to `(T2.RA = '-' OR T2.RA = '+-')` instead of `rheumatoid_factor = 'normal'` and move the date condition to filter patients born after 1985. The amended query now correctly joins patient and laboratory data to identify specific rheumatoid arthritis conditions instead of relying on a single normal rheumatoid factor value."
        ],
        "rules": [
            "1) When answering about \"diseases of patients\": make sure the output column is T1.Diagnosis instead of disease. 2) When combining patient and laboratory data: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for patients born after 1985-1-1: apply the condition T1.birth_date > '1985-01-01'. 4) When filtering for normal Rheumatoid Factor: use the condition (T2.RA = '-' OR T2.RA = '+-') instead of rheumatoid_factor = 'normal'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT disease FROM patients WHERE birth_date > '1985-01-01' AND rheumatoid_factor = 'normal';",
            "SELECT T1.Diagnosis \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Birthday > '1985-01-01' \nAND (T2.RA = '-' OR T2.RA = '+-')"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Diagnosis \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T1.Birthday > '1985-01-01' \nAND (T2.RA = '-' OR T2.RA = '+-')"
        ],
        "amend_res": 1
    },
    "92": {
        "db_id": "financial",
        "question": "List out the no. of districts that have female average salary is more than 6000 but less than 10000?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.district_id)  FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A11 BETWEEN 6000 AND 10000",
        "amends": [
            "Do select `COUNT(DISTINCT T2.district_id)` instead of `COUNT(*)` to count unique districts. Do change the FROM clause to use `client AS T1 INNER JOIN district AS T2` instead of just `districts` to join the tables. Do add the join condition `ON T1.district_id = T2.district_id` instead of omitting it. Do move the salary filter to `T2.A11 BETWEEN 6000 AND 10000` instead of `female_avg_salary > 6000 AND female_avg_salary < 10000` and use the correct column name. Do add the gender filter `T1.gender = 'F'` instead of omitting it to specifically count female clients. The amended query now correctly counts distinct districts with female clients having salaries between the specified range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting districts: count distinct T2.district_id instead of counting all rows. 2) When combining client and district tables: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match). 3) When filtering for female clients: use T1.gender = 'F' to specifically select female records. 4) When filtering for salary range between 6000 and 10000: use T2.A11 BETWEEN 6000 AND 10000 instead of separate greater than and less than conditions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM districts WHERE female_avg_salary > 6000 AND female_avg_salary < 10000",
            "SELECT COUNT(DISTINCT T2.district_id) \nFROM client AS T1 \nINNER JOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE T1.gender = 'F' AND T2.A11 BETWEEN 6000 AND 10000"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.district_id) \nFROM client T1 \nINNER JOIN district T2 ON T1.district_id = T2.district_id \nWHERE T1.gender = 'F' \nAND T2.A11 BETWEEN 6000 AND 10000"
        ],
        "amend_res": 1
    },
    "266": {
        "db_id": "toxicology",
        "question": "Calculate the total carcinogenic molecules for molecule id from TR000 to TR030.",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.molecule_id BETWEEN 'TR000' AND 'TR030' AND T.label = '+'",
        "amends": [
            "Do `COUNT(T.molecule_id)` instead of `SUM(carcinogenic)` in the SELECT list. Do add `T.label = '+'` filter instead of omitting it in the WHERE clause. Do specify `molecule AS T` instead of just `molecules` in the FROM clause. The amended query now correctly counts molecules with positive labels within the specified ID range instead of summing carcinogenic values."
        ],
        "rules": [
            "1) When counting molecules with carcinogenic labels: use COUNT(T.molecule_id) instead of SUM(carcinogenic) to count the number of molecules rather than summing values. 2) When filtering for carcinogenic molecules: include the condition T.label = '+' to only count molecules with positive carcinogenic labels. 3) When referring to the molecules table: use the alias T for the molecule table as specified in the schema. 4) When querying molecule IDs in a range: use BETWEEN 'TR000' AND 'TR030' to include all molecule IDs from TR000 through TR030 inclusive."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(carcinogenic) FROM molecules WHERE molecule_id BETWEEN 'TR000' AND 'TR030';",
            "SELECT COUNT(T.molecule_id) \nFROM molecule AS T \nWHERE T.molecule_id BETWEEN 'TR000' AND 'TR030' \nAND T.label = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.molecule_id) \nFROM molecule T \nWHERE T.molecule_id BETWEEN 'TR000' AND 'TR030' \nAND T.label = '+'"
        ],
        "amend_res": 1
    },
    "649": {
        "db_id": "codebase_community",
        "question": "Describe the post history counts and last edit date of the post title \"What is the best introductory Bayesian statistics textbook?\"",
        "evidence": "",
        "ground_truth": "SELECT T1.Id, T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'",
        "amends": [
            "Do select specific columns `T1.Id` and `T2.LastEditDate` instead of using aggregates `COUNT(*)` and `MAX(creation_date)`. Do join tables with `INNER JOIN posts AS T2 ON T1.PostId = T2.Id` instead of querying a single table. Do reference the correct table alias `T2.Title` in the WHERE filter instead of directly using `title`. Do remove the aggregation and grouping entirely instead of using count and max functions. The amended query now correctly retrieves individual post history records with their last edit dates for the specified title, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about post history counts and last edit date: make sure the output order: post history ID and last edit date. 2) When the question mentions \"post title\": \"post title\" actually means \"T2.Title in schema\". 3) When filtering for the specific post title \"What is the best introductory Bayesian statistics textbook?\": use the exact literal 'What is the best introductory Bayesian statistics textbook?' with T2.Title. 4) When combining post history and posts tables: link rows where T1.PostId = T2.Id and keep only matching pairs (inner match). 5) When selecting columns: use T1.Id for post history identification and T2.LastEditDate for the last edit date instead of using aggregate functions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS post_count, MAX(creation_date) AS last_edit_date FROM posts WHERE title = 'What is the best introductory Bayesian statistics textbook?'",
            "SELECT T1.Id, T2.LastEditDate \nFROM postHistory AS T1 \nINNER JOIN posts AS T2 ON T1.PostId = T2.Id \nWHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'"
        ],
        "rule_sql": [
            "SELECT T1.Id, T2.LastEditDate\nFROM postHistory T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'"
        ],
        "amend_res": 1
    },
    "972": {
        "db_id": "formula_1",
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "ground_truth": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "amends": [
            "Do use `STRFTIME('%Y', T2.dob) = '1971'` for precise year extraction instead of `LIKE '1971%'` which could match unintended patterns. Do add `AND T1.fastestLapTime IS NOT NULL` to filter out null lap times instead of omitting this necessary condition. Do remove `ORDER BY r.fastestLapTime ASC LIMIT 1` which incorrectly attempted to find a single fastest lap instead of returning all qualifying drivers. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do alias tables as `T1` and `T2` instead of single letters for better readability. The amended query now correctly returns all drivers born in 1971 with valid fastest lap times, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When extracting year from date of birth: use STRFTIME('%Y', T2.dob) = '1971' for precise year matching instead of pattern matching. 2) When filtering for valid fastest lap times: add condition T1.fastestLapTime IS NOT NULL to exclude null values. 3) When the question asks for all qualifying drivers: do not use ORDER BY and LIMIT 1, return all matching rows instead of just the single fastest. 4) When joining tables: use explicit INNER JOIN syntax for clarity. 5) When assigning table aliases: use T1 for the results table and T2 for the drivers table consistently."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverId, d.code \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nWHERE d.dob LIKE '1971%' \nORDER BY r.fastestLapTime ASC \nLIMIT 1;",
            "SELECT T2.driverId, T2.code\nFROM results T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE STRFTIME('%Y', T2.dob) = '1971'\nAND T1.fastestLapTime IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT T2.driverId, T2.code\nFROM results T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE STRFTIME('%Y', T2.dob) = '1971'\nAND T1.fastestLapTime IS NOT NULL"
        ],
        "amend_res": 1
    },
    "241": {
        "db_id": "toxicology",
        "question": "How many of the molecules are not carcinogenic?",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '-'",
        "amends": [
            "Do select `COUNT(T.molecule_id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do reference table with alias `T` instead of using the bare table name `molecules`. Do filter on `T.label = '-'` instead of `carcinogenic = 'yes'` to apply the correct condition. Do use table name `molecule` instead of `molecules` to reference the correct database object. The amended query now correctly counts molecules with the specified label rather than carcinogenic status."
        ],
        "rules": [
            "1) When counting molecules: use COUNT(T.molecule_id) instead of COUNT(*) to count specific non-null values of the canonical key. 2) When referencing the molecule table: use alias T instead of the bare table name. 3) When filtering for non-carcinogenic molecules: use T.label = '-' instead of carcinogenic = 'yes' to apply the correct condition. 4) When referencing the database table: use table name molecule instead of molecules to reference the correct database object."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE carcinogenic = 'yes';",
            "SELECT COUNT(T.molecule_id) FROM molecule T WHERE T.label = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.molecule_id) FROM molecule T WHERE T.label = '-'"
        ],
        "amend_res": 1
    },
    "65": {
        "db_id": "california_schools",
        "question": "What is the ratio in percentage of Santa Clara County schools that are locally funded compared to all other types of charter school funding?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END) FROM schools WHERE County = 'Santa Clara' AND Charter = 1",
        "amends": [
            "Do use `SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN funding_type = 'locally funded' THEN 1 END)` to properly count occurrences with explicit ELSE 0. Do cast the numerator to `REAL` instead of using decimal literal `100.0` for proper floating-point division. Do reference `FundingType` instead of `funding_type` and `County` instead of `county` to match the correct column names. Do filter with `Charter = 1` instead of `school_type = 'charter'` to use the correct boolean column and value. Do remove the alias `ratio_percentage` instead of keeping it since the right query returns an unaliased result. The amended query now correctly calculates the percentage ratio using proper counting logic and matches the right SQL's behavior.",
            "Do cast the sum as `REAL` instead of omitting explicit casting. Do divide by `SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to calculate the percentage of locally funded schools relative to non-locally funded schools rather than all schools. Do remove the table alias `s` from column references instead of keeping them for consistency with the simplified query structure. Do maintain the same `WHERE` filters on `County = 'Santa Clara'` and `Charter = 1` instead of changing them. The amended query now correctly calculates the percentage of locally funded schools among non-locally funded schools in Santa Clara charter schools, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"Santa Clara County\": \"County\" actually means \"County\" in schema and must exactly match the literal 'Santa Clara'. 2) When the question asks about charter schools: use \"Charter = 1\" instead of text comparisons to match the boolean column format. 3) When counting occurrences of \"locally funded\" schools: use SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) with explicit ELSE 0 instead of COUNT with conditional. 4) When calculating percentage ratios: cast the numerator to REAL type instead of using decimal literals for proper floating-point division. 5) When referencing column names: use exact identifiers \"FundingType\" and \"County\" instead of lowercase versions. 6) When the query returns a single calculated value: do not use any alias for the result column.",
            "1) When the question asks for a ratio in percentage of schools with specific funding type compared to other funding types: compute (count of rows where \"FundingType\" = 'Locally funded') divided by (count of rows where \"FundingType\" != 'Locally funded') and multiply by 100.0. 2) When filtering for Santa Clara County schools: include only rows where \"County\" = 'Santa Clara'. 3) When filtering for charter schools: include only rows where \"Charter\" = 1. 4) When casting numeric results: explicitly cast the sum as REAL type for proper division. 5) When referencing columns: use the exact column names without table aliases for consistency with simplified query structure."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN funding_type = 'locally funded' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN funding_type != 'locally funded' THEN 1 END)) AS ratio_percentage\nFROM schools\nWHERE county = 'Santa Clara' AND school_type = 'charter';",
            "SELECT \n    (SUM(CASE WHEN s.FundingType = 'Locally funded' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) \nFROM \n    schools s\nWHERE \n    s.County = 'Santa Clara' \n    AND s.Charter = 1",
            "SELECT (SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) * 100.0) / SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END) FROM schools WHERE County = 'Santa Clara' AND Charter = 1;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) AS REAL) / \n     CAST(SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END) AS REAL)) * 100.0\nFROM schools\nWHERE County = 'Santa Clara' AND Charter = 1"
        ],
        "amend_res": 1
    },
    "1315": {
        "db_id": "student_club",
        "question": "How many students of the Student_Club have attended the event \"Women's Soccer\"?",
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
        "amends": [
            "Do count `T1.event_id` from the `event` table instead of counting all rows from `Student_Club`. Do join `attendance AS T2` with `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying only the `Student_Club` table. Do filter on `T1.event_name = 'Women''s Soccer'` instead of filtering directly on the non-existent `event_name` column in the original table. The amended query now correctly counts attendance records for the specified event by properly joining the event and attendance tables."
        ],
        "rules": [
            "1) When counting students who attended an event: count using T1.event_id from the event table instead of counting all rows from Student_Club. 2) When joining attendance records with events: use INNER JOIN between attendance AS T2 and event tables on T1.event_id = T2.link_to_event. 3) When filtering for a specific event name: use T1.event_name = 'Women''s Soccer' with exact punctuation and spacing as specified. 4) When the question mentions \"students of the Student_Club have attended\": this refers to attendance records linked to events through the attendance table's link_to_event column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM Student_Club WHERE event_name = 'Women\\'s Soccer';",
            "SELECT COUNT(*) \nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.event_name = 'Women''s Soccer'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.event_name = 'Women''s Soccer'"
        ],
        "amend_res": 1
    },
    "1271": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients with a normal anti-SSA came to the hospital before 2000?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '2000'",
        "amends": [
            "Do `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the patients table to incorporate laboratory test results. Do filter on `T2.SSA IN ('negative', '0')` instead of `anti_ssa = 'normal'` to correctly identify negative SSA test results using appropriate values. Do use `STRFTIME('%Y', T2.Date) < '2000'` instead of `visit_date < '2000-01-01'` to filter by year component rather than full date comparison. The amended query now correctly counts distinct patients with negative SSA laboratory results before the year 2000, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: count distinct T1.ID values instead of all rows to get unique patient counts. 2) When the question mentions \"normal anti-SSA\": this actually means T2.SSA IN ('negative', '0') in the laboratory test results. 3) When combining patient and laboratory data: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 4) When filtering by year before 2000: use STRFTIME('%Y', T2.Date) < '2000' to extract the year component from the date field."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE anti_ssa = 'normal' AND visit_date < '2000-01-01';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.SSA IN ('negative', '0')\nAND STRFTIME('%Y', T2.Date) < '2000'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.SSA IN ('negative', '0')\nAND STRFTIME('%Y', T2.Date) < '2000'"
        ],
        "amend_res": 1
    },
    "1321": {
        "db_id": "student_club",
        "question": "How many events of the Student_Club did Sacha Harrison attend in 2019?",
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Sacha' AND T3.last_name = 'Harrison' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of querying a single table. Do join `event AS T1` with `attendance AS T2` on `T1.event_id = T2.link_to_event` instead of missing these table relationships. Do add a second join to `member AS T3` on `T2.link_to_member = T3.member_id` instead of omitting the member table connection. Do filter on `T3.first_name = 'Sacha'` and `T3.last_name = 'Harrison'` instead of using a combined `attendee_name` field. Do use `SUBSTR(T1.event_date, 1, 4) = '2019'` for year extraction instead of a direct `year` column. Do count specific `T1.event_id` instead of using `COUNT(*)`. The amended query now correctly joins the necessary tables and uses proper field relationships to match the intended logic."
        ],
        "rules": [
            "1) When answering about \"events of the Student_Club\": make sure to filter on T1.club_name = 'Student_Club'. 2) When the question mentions \"Sacha Harrison\": this actually means T3.first_name = 'Sacha' and T3.last_name = 'Harrison' in the member table. 3) When the question mentions \"in 2019\": use SUBSTR(T1.event_date, 1, 4) = '2019' for year extraction from the event date. 4) When combining event (T1), attendance (T2), and member (T3) tables: link rows where T1.event_id = T2.link_to_event and T2.link_to_member = T3.member_id; keep only matching pairs (inner match). 5) When counting events: compute the number of rows using the canonical key T1.event_id instead of counting all columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE club_name = 'Student_Club' AND attendee_name = 'Sacha Harrison' AND year = 2019;",
            "SELECT COUNT(T1.event_id) \nFROM event AS T1\nJOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nJOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T3.first_name = 'Sacha' \nAND T3.last_name = 'Harrison'\nAND SUBSTR(T1.event_date, 1, 4) = '2019'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.event_id) \nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member T3 ON T2.link_to_member = T3.member_id\nWHERE T3.first_name = 'Sacha' AND T3.last_name = 'Harrison'\nAND SUBSTR(T1.event_date, 1, 4) = '2019'"
        ],
        "amend_res": 1
    },
    "44": {
        "db_id": "california_schools",
        "question": "What is the average writing score of the school who has the highest number of test takers whose total SAT sscores are greater or equal to 1500? Indicate the city to where the school is situated.",
        "evidence": "",
        "ground_truth": "SELECT T1.AvgScrWrite, T2.City FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [
            "Do select `T1.AvgScrWrite` and `T2.City` instead of `AVG(writing_score)` as `avg_writing` and `city`. Do use `FROM satscores AS T1 INNER JOIN schools AS T2` instead of `FROM schools` alone. Do join on `T1.cds = T2.CDSCode` instead of grouping by `school_id`. Do order by `T1.NumGE1500 DESC` instead of `COUNT(*) DESC`. Do remove the `WHERE total_sat_score >= 1500` filter and `GROUP BY` clause entirely instead of keeping them. The amended query now correctly joins the satscores and schools tables using the proper key relationship and orders by the pre-calculated count of high SAT scores rather than attempting to aggregate and filter within a single query."
        ],
        "rules": [
            "1) When answering about average writing score: use T1.AvgScrWrite instead of AVG(writing_score). 2) When answering about city location: use T2.City instead of city. 3) When combining SAT scores and schools data: join T1 (satscores) and T2 (schools) using T1.cds = T2.CDSCode with inner match. 4) When the question asks for the school with highest number of test takers with SAT scores >= 1500: order by T1.NumGE1500 DESC instead of counting and filtering manually. 5) When selecting the top result: take only the first row after ordering by T1.NumGE1500 DESC. 6) When handling pre-calculated counts: do not use WHERE total_sat_score >= 1500 filter or GROUP BY clause since T1.NumGE1500 already represents the count of test takers with scores >= 1500."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(writing_score) as avg_writing, city \nFROM schools \nWHERE total_sat_score >= 1500 \nGROUP BY school_id \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT T1.AvgScrWrite, T2.City\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.AvgScrWrite, T2.City\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "368": {
        "db_id": "card_games",
        "question": "What is the percentage of borderless cards?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "amends": [
            "Do use `SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END)` instead of `COUNT(*)` with a `WHERE border = 'borderless'` filter to properly calculate the percentage of borderless cards. Do reference `borderColor` column instead of `border` column to use the correct field name. Do cast the sum to `REAL` instead of relying on integer division to ensure accurate percentage calculation. Do divide by `COUNT(id)` instead of a subquery `(SELECT COUNT(*) FROM cards)` for simpler and more efficient counting. Do remove the `AS percentage` alias instead of keeping it since the right query omits explicit column naming. The amended query now correctly calculates the percentage of borderless cards using proper column references and floating-point arithmetic."
        ],
        "rules": [
            "1) When the question asks for percentage of borderless cards: use the exact literal 'borderless' to identify borderless cards. 2) When calculating percentage of borderless cards: use SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) instead of COUNT(*) with a WHERE filter. 3) When referencing the border status column: use borderColor instead of border as the correct column name. 4) When performing division for percentage calculation: cast the sum to REAL instead of relying on integer division. 5) When counting total cards for denominator: use COUNT(id) instead of a subquery (SELECT COUNT(*) FROM cards). 6) When formatting output: omit explicit column naming (remove AS percentage alias)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM cards) AS percentage FROM cards WHERE border = 'borderless';",
            "SELECT 100.0 * SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) / COUNT(id) FROM cards;"
        ],
        "rule_sql": [
            "SELECT (SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) * 100.0 / COUNT(id)) FROM cards;"
        ],
        "amend_res": 1
    },
    "577": {
        "db_id": "codebase_community",
        "question": "Write all comments made by user 'A Lion.'",
        "ground_truth": "SELECT T2.Text FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'A Lion'",
        "amends": [
            "Do select `T2.Text` instead of `*` to return only the comment text rather than all columns. Do join `users AS T1` with `comments AS T2` on `T1.Id = T2.UserId` instead of querying only the `comments` table to properly relate users to their comments. Do filter on `T1.DisplayName = 'A Lion'` instead of `user = 'A Lion'` to use the correct display name field from the users table rather than a non-existent user column in comments. The amended query now correctly retrieves comments specifically for the user with display name 'A Lion' by properly joining the users and comments tables."
        ],
        "rules": [
            "1) When the question asks for comments made by a specific user: join users AS T1 with comments AS T2 on T1.Id = T2.UserId to properly relate users to their comments. 2) When filtering for user 'A Lion': use T1.DisplayName = 'A Lion' to match the exact display name field from the users table. 3) When selecting comment text: return only T2.Text instead of all columns to show only the comment content."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM comments WHERE user = 'A Lion'",
            "SELECT T2.Text FROM users AS T1 JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'A Lion'"
        ],
        "rule_sql": [
            "SELECT T2.Text FROM users AS T1 JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'A Lion.'"
        ],
        "amend_res": 1
    },
    "328": {
        "db_id": "toxicology",
        "question": "List all the elements with double bond, consisted in molecule TR024.",
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='",
        "amends": [
            "Do select `T1.element` instead of `*` from all columns. Do change the FROM clause to use `atom AS T1 INNER JOIN bond AS T2` instead of just `molecules`. Do use the join condition `ON T1.molecule_id = T2.molecule_id` instead of no join. Do change the WHERE filter to use `T1.molecule_id = 'TR024'` instead of `name = 'TR024'` and `T2.bond_type = '='` instead of `bond_type = 'double'`. The amended query now correctly joins atom and bond tables to find elements in molecules with specific bond types, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"elements with double bond in molecule TR024\": make sure the output order: T1.element\n2) When combining T1 and T2 for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match).\n3) When the question mentions \"molecule TR024\": \"TR024\" actually means T1.molecule_id = 'TR024' in schema\n4) When the question mentions \"double bond\": \"double bond\" actually means T2.bond_type = '=' in schema"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM molecules WHERE name = 'TR024' AND bond_type = 'double';",
            "SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.element\nFROM atom T1\nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='"
        ],
        "amend_res": 1
    },
    "567": {
        "db_id": "codebase_community",
        "question": "For the user with the display name of \"Tiago Pasqualini\", how many posts did he/she own?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Tiago Pasqualini'",
        "amends": [
            "Do join `users AS T1` with `posts AS T2` on `T1.Id = T2.OwnerUserId` instead of querying only the `posts` table without any user relationship. Do count `T1.Id` instead of counting all rows with `COUNT(*)`. Do filter on `T1.DisplayName` instead of filtering on a non-existent `display_name` column in the posts table. The amended query now correctly counts posts by joining users to posts and filtering by the user's display name, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about posts owned by a user with a specific display name: join users AS T1 with posts AS T2 on T1.Id = T2.OwnerUserId to link user records with their owned posts. 2) When filtering for a user with display name \"Tiago Pasqualini\": use T1.DisplayName = 'Tiago Pasqualini' exactly as specified. 3) When counting posts owned by a user: count using the canonical key T1.Id instead of counting all rows with COUNT(*)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE display_name = 'Tiago Pasqualini'",
            "SELECT COUNT(T2.Id) \nFROM users AS T1 \nJOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE T1.DisplayName = 'Tiago Pasqualini'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nJOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE T1.DisplayName = 'Tiago Pasqualini'"
        ],
        "amend_res": 1
    },
    "537": {
        "db_id": "codebase_community",
        "question": "How many posts does the user csgillespie own?",
        "ground_truth": "SELECT COUNT(T1.id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do add `INNER JOIN users AS T2` instead of querying only the posts table. Do use join condition `ON T1.OwnerUserId = T2.Id` instead of filtering by username directly. Do filter with `WHERE T2.DisplayName = 'csgillespie'` instead of `WHERE username = 'csgillespie'` to properly reference the joined users table. The amended query now correctly joins tables and counts posts by matching user display name rather than relying on a potentially incorrect username field."
        ],
        "rules": [
            "1) When counting posts: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values. 2) When answering about posts owned by a user: add INNER JOIN users AS T2 to combine the posts and users tables. 3) When combining posts and users tables: link rows where T1.OwnerUserId = T2.Id exactly and keep only matching pairs (inner match). 4) When filtering by username 'csgillespie': use WHERE T2.DisplayName = 'csgillespie' to properly reference the joined users table instead of filtering by username directly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE username = 'csgillespie';",
            "SELECT COUNT(T1.Id) \nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id\nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM posts AS T1 \nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "amend_res": 1
    },
    "859": {
        "db_id": "formula_1",
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "amends": [
            "Do select `q1` instead of `q1_result` and use table alias `T1` instead of the full table name. Do join `drivers AS T2` instead of omitting it, using `INNER JOIN` on `T2.driverId = T1.driverId` instead of filtering directly by driver name. Do filter on `T1.raceId = 354` instead of `race_id = 354` and use separate `T2.forename = 'Bruno'` and `T2.surname = 'Senna'` conditions instead of a single `driver_name = 'Bruno Senna'` filter. The amended query now correctly joins the qualifying and drivers tables to match the driver by ID rather than name, ensuring accurate results when multiple drivers might share similar names."
        ],
        "rules": [
            "1) When answering about qualifying results: select the exact column \"q1\" from table \"qualifying\" (aliased as T1) instead of \"q1_result\". 2) When the question mentions a driver by name \"Bruno Senna\": use separate conditions \"T2.forename = 'Bruno'\" and \"T2.surname = 'Senna'\" instead of a single driver_name filter. 3) When combining qualifying and drivers tables: link rows where \"T2.driverId = T1.driverId\" using an inner join to ensure accurate driver matching. 4) When filtering by race number: use \"T1.raceId = 354\" instead of \"race_id = 354\" to match the exact column name. 5) When referring to table roles: use T1 for the qualifying table and T2 for the drivers table as established in the join pattern."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT q1_result FROM qualifying WHERE driver_name = 'Bruno Senna' AND race_id = 354;",
            "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'"
        ],
        "rule_sql": [
            "SELECT T1.q1 \nFROM qualifying T1\nINNER JOIN drivers T2 ON T2.driverId = T1.driverId\nWHERE T2.forename = 'Bruno' \nAND T2.surname = 'Senna'\nAND T1.raceId = 354"
        ],
        "amend_res": 1
    },
    "17": {
        "db_id": "california_schools",
        "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
        "ground_truth": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
        "amends": [
            "Do select `CharterNum`, `AvgScrWrite`, and `RANK() OVER (ORDER BY AvgScrWrite DESC)` instead of `charter_number` and `AVG(writing_score)`. Do join `schools AS T1` with `satscores AS T2` on `T1.CDSCode = T2.cds` instead of querying only the `schools` table. Do filter with `T2.AvgScrWrite > 499 AND CharterNum is not null` instead of `writing_score > 499`. Do add window function ranking instead of simple ordering. Do remove the explicit `ORDER BY` clause since the window function handles ordering. The amended query now correctly joins the necessary tables, uses the proper column names from the joined data source, implements ranking functionality, and ensures null values are excluded, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about ranking schools by average writing score: use the exact column name \"AvgScrWrite\" from table satscores instead of \"writing_score\". 2) When the question mentions \"charter numbers\": use the exact column name \"CharterNum\" from table schools instead of \"charter_number\". 3) When combining schools and satscores tables: link rows where T1.CDSCode = T2.cds and keep only matching pairs (inner match). 4) When filtering for scores greater than 499: apply the condition T2.AvgScrWrite > 499 AND CharterNum is not null to exclude null charter numbers. 5) When ranking schools: use RANK() OVER (ORDER BY AvgScrWrite DESC) to assign ranks based on average writing score in descending order. 6) When producing output: show CharterNum, AvgScrWrite, and the rank value in that order without an explicit ORDER BY clause since the window function handles ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT charter_number, AVG(writing_score) as avg_writing \nFROM schools \nWHERE writing_score > 499 \nORDER BY avg_writing DESC;",
            "SELECT \n    T1.CharterNum,\n    T2.AvgScrWrite,\n    RANK() OVER (ORDER BY T2.AvgScrWrite DESC) as rank\nFROM \n    schools AS T1\nJOIN \n    satscores AS T2 ON T1.CDSCode = T2.cds\nWHERE \n    T2.AvgScrWrite > 499 \n    AND T1.CharterNum IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT \n    s.CharterNum,\n    sat.AvgScrWrite,\n    RANK() OVER (ORDER BY sat.AvgScrWrite DESC) as rank\nFROM \n    schools s\nINNER JOIN \n    satscores sat ON s.CDSCode = sat.cds\nWHERE \n    sat.AvgScrWrite > 499 \n    AND s.CharterNum IS NOT NULL"
        ],
        "amend_res": 1
    },
    "1010": {
        "db_id": "formula_1",
        "question": "What is the lap record set by Lewis Hamilton in a Formula_1 race?",
        "ground_truth": "SELECT T1.time FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of direct table names. Do select `T1.time` instead of `lap_time`. Do join `lapTimes AS T1` with `drivers AS T2` on `T1.driverId = T2.driverId` instead of querying a single table. Do filter with `T2.forename = 'Lewis' AND T2.surname = 'Hamilton'` instead of `driver_name = 'Lewis Hamilton'`. Do remove `ORDER BY lap_time ASC LIMIT 1` instead of keeping it, as the query logic now correctly identifies the driver through proper table relationships. The amended query now matches RIGHT_SQL's behavior by properly joining normalized tables and filtering on separate first and last name fields."
        ],
        "rules": [
            "1) When answering about lap records: use table aliases T1 for lapTimes and T2 for drivers instead of direct table names. 2) When selecting lap time information: select T1.time instead of lap_time. 3) When combining driver and lap time information: join lapTimes AS T1 with drivers AS T2 on T1.driverId = T2.driverId using an inner match. 4) When filtering for Lewis Hamilton: use T2.forename = 'Lewis' AND T2.surname = 'Hamilton' instead of a single driver_name field. 5) When the question asks for a lap record: do not use ORDER BY and LIMIT as the query logic should correctly identify the minimum time through proper table relationships."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT lap_time FROM Formula1_Laps WHERE driver_name = 'Lewis Hamilton' ORDER BY lap_time ASC LIMIT 1;",
            "SELECT T1.time FROM lapTimes AS T1 JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'"
        ],
        "rule_sql": [
            "SELECT T1.time \nFROM lapTimes AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' \nORDER BY T1.milliseconds ASC \nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1224": {
        "db_id": "thrombosis_prediction",
        "question": "What is the highest total bilirubin level recorded? List out the patient details with ID, sex and birthday with that index.",
        "ground_truth": "SELECT T2.`T-BIL`, T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-BIL` DESC LIMIT 1",
        "amends": [
            "Do select `T2.T-BIL`, `T1.ID`, `T1.SEX`, `T1.Birthday` instead of `patient_id`, `sex`, `birthday`, `MAX(bilirubin)` with alias. Do use `INNER JOIN` on `T1.ID = T2.ID` instead of `JOIN` on `patients.id = lab_results.patient_id`. Do remove the WHERE clause with subquery instead of keeping it. Do add `ORDER BY T2.T-BIL DESC LIMIT 1` instead of omitting ordering and limiting. Do change table names to `Patient AS T1` and `Laboratory AS T2` instead of `patients` and `lab_results`. The amended query now correctly retrieves the single record with the highest bilirubin value using proper ordering and limiting instead of attempting to match maximum values through subqueries."
        ],
        "rules": [
            "1) When the question asks for the highest total bilirubin level: rank rows by T2.\"T-BIL\" in descending order and keep only the first 1 row. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID exactly and keep only matching pairs (inner match). 3) When answering about patient details with ID, sex and birthday: make sure the output order includes T2.\"T-BIL\", T1.ID, T1.SEX, T1.Birthday. 4) When handling identifier delimiters: do not replace double quotes around \"T-BIL\" with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, sex, birthday, MAX(bilirubin) as highest_bilirubin FROM patients JOIN lab_results ON patients.id = lab_results.patient_id WHERE bilirubin = (SELECT MAX(bilirubin) FROM lab_results)",
            "SELECT T2.\"T-BIL\", T1.ID, T1.SEX, T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.\"T-BIL\", T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "431": {
        "db_id": "card_games",
        "question": "Which set is not available outside of the United States and has foil cards with Japanese writing on them? Please include the set ID in your response.",
        "ground_truth": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Japanese' AND T1.isFoilOnly = 1 AND T1.isForeignOnly = 0",
        "amends": [
            "Do select `T1.name` and `T1.id` instead of only `set_id`. Do join `sets AS T1` with `set_translations AS T2` on `T1.code = T2.setCode` instead of querying only the `sets` table. Do filter on `T2.language = 'Japanese'` instead of `country = 'Japan'`. Do filter on `T1.isFoilOnly = 1` instead of `foil_cards = 'Japanese writing'`. Do filter on `T1.isForeignOnly = 0` instead of `available_outside_us = 'yes'`. The amended query now correctly identifies Japanese foil sets using proper table relationships and boolean flags instead of string-based country and availability checks."
        ],
        "rules": [
            "1) When answering about sets not available outside the United States with Japanese foil cards: make sure the output order includes both T1.name and T1.id. 2) When the question mentions \"foil cards with Japanese writing\": \"foil cards\" actually means \"T1.isFoilOnly = 1\" in schema and \"Japanese writing\" actually means \"T2.language = 'Japanese'\" in schema. 3) When the question mentions \"not available outside of the United States\": this actually means \"T1.isForeignOnly = 0\" in schema. 4) When combining T1 (sets) and T2 (set_translations) for shared entities: link rows where T1.code = T2.setCode exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT set_id FROM sets WHERE country = 'Japan' AND foil_cards = 'Japanese writing' AND available_outside_us = 'yes';",
            "SELECT T1.name, T1.id\nFROM sets AS T1\nJOIN set_translations AS T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Japanese'\nAND T1.isFoilOnly = 1\nAND T1.isForeignOnly = 0;"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.code as id\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.isFoilOnly = 1\nAND T2.language = 'Japanese'\nAND T1.isForeignOnly = 0"
        ],
        "amend_res": 1
    },
    "317": {
        "db_id": "toxicology",
        "question": "Calculate the percentage of carcinogenic molecules which contain the Chlorine element.",
        "ground_truth": "SELECT COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "amends": [
            "Do use tables `atom AS T1` and `molecule AS T2` with an `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of querying only the `molecules` table. Do reference columns `T2.label` for carcinogenic status and `T1.element` for chlorine detection instead of `carcinogenic` and `element LIKE '%Chlorine%'`. Do count `T2.molecule_id` in both numerator and denominator instead of counting case results. Do use exact string comparison `T1.element = 'cl'` instead of pattern matching with `LIKE '%Chlorine%'`. Do use integer division without decimal points instead of floating-point division with `100.0`. The amended query now correctly calculates the percentage of chlorine-containing molecules among carcinogenic molecules by properly joining the atom and molecule tables.",
            "Do use `COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END)` instead of `COUNT(DISTINCT CASE WHEN T1.element = 'cl' THEN T2.molecule_id END)` to count specific molecule occurrences rather than distinct values. Do remove the `DISTINCT` modifier from the denominator `COUNT(T2.molecule_id)` instead of keeping `COUNT(DISTINCT T2.molecule_id)` to count all molecule instances rather than unique ones. Do change the filter condition to `T2.label = '+'` within the CASE expression instead of using `WHERE T2.label = 'carcinogenic'` to include all molecules in the calculation while only counting those with the specific label. Do remove the explicit WHERE clause entirely instead of filtering rows before aggregation, allowing the CASE logic to handle the conditional counting. The amended query now correctly calculates the percentage of molecules with '+' label that contain chlorine atoms, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about carcinogenic molecules containing Chlorine element: use tables \"atom AS T1\" and \"molecule AS T2\" with an inner join on T1.molecule_id = T2.molecule_id. 2) When detecting carcinogenic status: use T2.label instead of carcinogenic. 3) When detecting chlorine element: use exact string comparison T1.element = 'cl' instead of pattern matching. 4) When counting molecules: count T2.molecule_id in both numerator and denominator instead of case results. 5) When calculating percentage: use integer division without decimal points instead of floating-point division.",
            "1) When the question asks for percentage of carcinogenic molecules containing Chlorine: use 'T2.label = '+' to identify carcinogenic molecules instead of 'carcinogenic'. 2) When counting molecules containing Chlorine element: use T1.element = 'cl' to identify Chlorine atoms (exact lowercase 'cl'). 3) When calculating percentage: count specific molecule occurrences using COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) rather than distinct values. 4) When calculating the denominator: use COUNT(T2.molecule_id) to count all molecule instances rather than unique ones. 5) When combining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id to associate atoms with their molecules. 6) When handling conditional counting: include all molecules in the calculation and let CASE logic handle the conditional counting instead of pre-filtering with WHERE clause."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN carcinogenic = 1 AND element LIKE '%Chlorine%' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN carcinogenic = 1 THEN 1 END)) AS percentage\nFROM molecules;",
            "SELECT \n    (COUNT(DISTINCT CASE WHEN T1.element = 'cl' THEN T2.molecule_id END) * 100 / COUNT(DISTINCT T2.molecule_id)) AS percentage\nFROM \n    atom AS T1\nINNER JOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T2.label = 'carcinogenic'",
            "SELECT \n    (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id)) AS percentage\nFROM \n    atom AS T1\nINNER JOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id;"
        ],
        "rule_sql": [
            "SELECT (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id)) AS percentage\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id;"
        ],
        "amend_res": 1
    },
    "264": {
        "db_id": "toxicology",
        "question": "What are the labels for TR000, TR001 and TR002?",
        "ground_truth": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
        "amends": [
            "Do select specific columns `molecule_id` and `T.label` instead of using `SELECT *`. Do query from table `molecule` with alias `T` instead of table `labels`. Do filter on column `T.molecule_id` instead of `id`. The amended query now correctly retrieves molecule data from the appropriate table with proper column selection and filtering."
        ],
        "rules": [
            "1) When the question asks for labels of specific molecule IDs: select the exact columns \"molecule_id\" and \"label\" from table \"molecule\" with alias \"T\". 2) When filtering for specific molecule IDs like 'TR000', 'TR001', and 'TR002': use the exact column \"T.molecule_id\" with the exact string literals 'TR000', 'TR001', and 'TR002'. 3) When the question mentions \"labels\": this refers to the \"label\" column in the \"molecule\" table, not a table called \"labels\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM labels WHERE id IN ('TR000', 'TR001', 'TR002');",
            "SELECT molecule_id, label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')"
        ],
        "rule_sql": [
            "SELECT T.molecule_id, T.label FROM molecule T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')"
        ],
        "amend_res": 1
    },
    "205": {
        "db_id": "toxicology",
        "question": "Identify by their ID the molecules in which there is carbon.",
        "ground_truth": "SELECT T.molecule_id FROM atom AS T WHERE T.element = 'c'",
        "amends": [
            "Do reference the `atom` table with alias `T` instead of the `molecules` table. Do use the column `T.molecule_id` instead of just `molecule_id`. Do filter for element value `'c'` instead of `'carbon'`. The amended query now correctly selects molecule IDs from the atom table where the element is carbon, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about molecules containing carbon: reference the \"atom\" table with alias \"T\" instead of the \"molecules\" table. 2) When selecting molecule IDs: use the column \"T.molecule_id\" instead of just \"molecule_id\". 3) When filtering for carbon element: use the literal value 'c' instead of 'carbon'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM molecules WHERE element = 'carbon';",
            "SELECT DISTINCT T.molecule_id FROM atom T WHERE T.element = 'c'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.molecule_id FROM atom T WHERE T.element = 'c'"
        ],
        "amend_res": 1
    },
    "930": {
        "db_id": "formula_1",
        "question": "In which Formula_1 race did Lewis Hamilton rank the highest?",
        "ground_truth": "SELECT name FROM races WHERE raceId IN ( SELECT raceId FROM results WHERE rank = 1 AND driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) )",
        "amends": [
            "Do select `name` instead of `race_name` from the `races` table. Do use a subquery with `raceId IN` instead of directly filtering by `driver_name`. Do reference the `results` table to find races where `rank = 1` instead of ordering by `position ASC LIMIT 1`. Do join through `driverId` from the `drivers` table with conditions `forename = 'Lewis' AND surname = 'Hamilton'` instead of the direct `driver_name` filter. Do remove the `ORDER BY position ASC LIMIT 1` clause instead of keeping it, as the subquery approach correctly identifies winning races. The amended query now matches the intended behavior of finding race names where Lewis Hamilton achieved first place."
        ],
        "rules": [
            "1) When the question asks about Formula_1 races: use the \"name\" column from the \"races\" table to identify race names. 2) When the question mentions \"Lewis Hamilton\": this corresponds to filtering drivers where forename = 'Lewis' AND surname = 'Hamilton' in the \"drivers\" table. 3) When finding races where a driver ranked highest: use the \"rank\" column from the \"results\" table with value 1 to identify winning positions. 4) When combining driver and race information: link tables through driverId and raceId keys, matching rows where results.driverId = drivers.driverId and results.raceId = races.raceId, keeping only matching pairs (inner match). 5) When selecting race names for specific driver achievements: use a subquery approach with raceId IN to find races where the driver achieved the specified rank condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name FROM races WHERE driver_name = 'Lewis Hamilton' ORDER BY position ASC LIMIT 1;",
            "SELECT r.name \nFROM races r \nWHERE r.raceId IN (\n    SELECT res.raceId \n    FROM results res \n    JOIN drivers d ON res.driverId = d.driverId \n    WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' AND res.rank = 1\n)"
        ],
        "rule_sql": [
            "SELECT r.name \nFROM races r\nWHERE r.raceId IN (\n    SELECT res.raceId\n    FROM results res\n    JOIN drivers d ON res.driverId = d.driverId\n    WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\n    AND res.rank = 1\n)"
        ],
        "amend_res": 1
    },
    "895": {
        "db_id": "formula_1",
        "question": "What is the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix?",
        "ground_truth": "SELECT AVG(T2.milliseconds) FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.year = 2009 AND T1.name = 'Malaysian Grand Prix'",
        "amends": [
            "Do join `races AS T1` and `drivers AS T3` instead of querying `lap_times` alone. Do use `T2.milliseconds` instead of `lap_time` for the average calculation. Do join `lapTimes AS T2` to `races AS T1` on `T2.raceId = T1.raceId` instead of filtering by race attributes directly. Do join `drivers AS T3` to `lapTimes AS T2` on `T3.driverId = T2.driverId` instead of filtering by driver name directly. Do filter by `T3.forename = 'Lewis' AND T3.surname = 'Hamilton'` instead of `driver_name = 'Lewis Hamilton'`. Do filter by `T1.year = 2009` instead of `race_year = 2009`. Do filter by `T1.name = 'Malaysian Grand Prix'` instead of `race_name = 'Malaysian Grand Prix'`. The amended query now correctly joins the necessary tables and uses proper foreign key relationships to match the intended behavior."
        ],
        "rules": [
            "1) When answering about average lap time: use T2.milliseconds for the average calculation instead of lap_time. 2) When the question mentions \"Lewis Hamilton\": filter by T3.forename = 'Lewis' AND T3.surname = 'Hamilton' instead of driver_name = 'Lewis Hamilton'. 3) When the question mentions \"2009 Malaysian Grand Prix\": filter by T1.year = 2009 AND T1.name = 'Malaysian Grand Prix' instead of race_year = 2009 AND race_name = 'Malaysian Grand Prix'. 4) When combining races and lapTimes tables: link rows where T2.raceId = T1.raceId and keep only matching pairs (inner match). 5) When combining drivers and lapTimes tables: link rows where T3.driverId = T2.driverId and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(lap_time) FROM lap_times WHERE driver_name = 'Lewis Hamilton' AND race_year = 2009 AND race_name = 'Malaysian Grand Prix';",
            "SELECT AVG(T2.milliseconds) AS average_lap_time_milliseconds\nFROM lapTimes AS T2\nJOIN races AS T1 ON T2.raceId = T1.raceId\nJOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Lewis' \nAND T3.surname = 'Hamilton'\nAND T1.year = 2009\nAND T1.name = 'Malaysian Grand Prix'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.milliseconds) AS average_lap_time\nFROM races T1\nINNER JOIN lapTimes T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers T3 ON T3.driverId = T2.driverId\nWHERE T1.year = 2009 \nAND T1.name = 'Malaysian Grand Prix'\nAND T3.forename = 'Lewis' \nAND T3.surname = 'Hamilton';"
        ],
        "amend_res": 1
    },
    "804": {
        "db_id": "superhero",
        "question": "Provide the name of superhero with superhero ID 294.",
        "ground_truth": "SELECT superhero_name FROM superhero WHERE id = 294",
        "amends": [
            "Do reference the correct table name `superhero` instead of `superheroes`. Do use the correct column name `superhero_name` instead of `name` for the SELECT list. Do use the correct column name `id` instead of `superhero_id` for the WHERE filter. Do use integer literal `294` without quotes instead of string literal `'294'` for proper numeric comparison. The amended query now correctly retrieves data from the proper table structure with appropriate data type handling."
        ],
        "rules": [
            "1) When the question asks for superhero information: use table \"superhero\" instead of \"superheroes\". 2) When selecting the superhero name: use column \"superhero_name\" instead of \"name\". 3) When filtering by superhero ID: use column \"id\" instead of \"superhero_id\". 4) When comparing numeric ID values: use integer literal 294 without quotes instead of string literal '294'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE superhero_id = '294';",
            "SELECT superhero_name FROM superhero WHERE id = 294"
        ],
        "rule_sql": [
            "SELECT superhero_name FROM superhero WHERE id = 294;"
        ],
        "amend_res": 1
    },
    "116": {
        "db_id": "financial",
        "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
        "ground_truth": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
        "amends": [
            "Do use `SUM(IIF())` conditional aggregation instead of direct column subtraction, and do cast the result as `REAL` instead of implicit integer division. Do join `account` on `account_id` instead of `client_id`, and do add `trans` table with `account_id` join instead of joining `accounts` twice. Do filter on `T1.date` for loan approval instead of `l.approval_date`, and do remove the explicit `ORDER BY` and `LIMIT` instead of keeping them since the aggregation returns a single row. Do calculate percentage increase using proper numerator/denominator order instead of potentially dividing by zero, and do handle the case where dates might not exist through conditional sums instead of requiring exact matches in join conditions. The amended query now correctly aggregates transaction balances for the specified dates while properly handling the loan-account relationship through appropriate joins.",
            "Do use a single `trans` table alias `T3` instead of separate `t1` and `t2` aliases for different dates. Do remove the unnecessary joins to `disp` and `client` tables instead of including them. Do change from `LEFT JOIN` to `INNER JOIN` for the `trans` table instead of using separate left joins. Do remove the `status = 'A'` filter from the `WHERE` clause instead of keeping it. Do remove the `ORDER BY` and `LIMIT` clauses instead of including them. Do add explicit `CAST` to `REAL` for the subtraction operation instead of omitting it. Do use `IIF` function instead of `CASE` expressions. Do remove the `NULLIF` function and handle division directly instead of using null protection. The amended query now correctly calculates the percentage increase using a single transaction table join and proper casting.",
            "Do use explicit `INNER JOIN` instead of implicit `JOIN` for clarity. Do move the division operation to after the multiplication by 100 instead of before it to ensure correct mathematical order of operations. Do remove the redundant `IN` filter condition on `T3.date` since the IIF expressions already handle the specific date filtering. Do use table aliases `T1`, `T2`, and `T3` consistently instead of mixing `l`, `a`, and `T3`. Do remove the column alias `increase_rate` since the RIGHT_SQL omits it. The amended query now correctly calculates the percentage increase by performing subtraction, casting to REAL, multiplying by 100, and then dividing, ensuring accurate mathematical results."
        ],
        "rules": [
            "1) When calculating percentage increase rate: use conditional aggregation with SUM(IIF()) instead of direct column subtraction, and cast the result as REAL instead of implicit integer division. 2) When joining account and loan tables: join on account_id instead of client_id. 3) When handling transaction data: add the trans table with account_id join instead of joining accounts twice. 4) When filtering for loan approval date: filter on T1.date instead of l.approval_date. 5) When the query returns a single aggregated result: remove explicit ORDER BY and LIMIT clauses. 6) When calculating percentage increase: use proper numerator/denominator order and handle potential division by zero cases. 7) When handling dates that might not exist: use conditional sums through aggregation instead of requiring exact matches in join conditions.",
            "1) When answering about the client whose loan was approved first on a specific date: identify the earliest approved loan on that date using the exact date literal '1993-07-05' and find the corresponding account. 2) When calculating balance increase rate between two dates: use a single transaction table with alias T3 instead of separate table aliases for different dates. 3) When combining loan and transaction tables: link rows where loan.account_id equals T3.account_id using inner join instead of left join. 4) When filtering transactions for specific dates: use the exact date literals '1993-03-22' and '1998-12-27' with proper date format. 5) When computing percentage increase: calculate (balance on '1998-12-27' minus balance on '1993-03-22') divided by balance on '1993-03-22' multiplied by 100, with explicit casting to REAL for the subtraction operation. 6) When handling division: perform direct division without NULLIF protection instead of using null protection functions. 7) When using conditional expressions: use IIF function instead of CASE expressions for date comparisons. 8) When the question involves temporal comparisons: ensure proper date handling with exact date format 'YYYY-MM-DD' as shown in the literals.",
            "1) When combining tables for this question: use INNER JOIN instead of implicit JOIN for clarity. 2) When calculating percentage increase: perform subtraction, cast to REAL, multiply by 100, and then divide to ensure correct mathematical order of operations. 3) When filtering for specific dates: do not use redundant IN conditions since IIF expressions already handle the specific date filtering. 4) When using table aliases: use T1, T2, and T3 consistently instead of mixing different alias patterns. 5) When producing output: do not include column aliases like increase_rate when the correct query omits them."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (a2.balance - a1.balance) / a1.balance * 100 AS increase_rate\nFROM \n    loans l\nJOIN \n    accounts a1 ON l.client_id = a1.client_id\nJOIN \n    accounts a2 ON l.client_id = a2.client_id\nWHERE \n    l.approval_date = '1993-07-05'\n    AND a1.date = '1993-03-22'\n    AND a2.date = '1998-12-27'\nORDER BY \n    l.approval_date ASC\nLIMIT 1;",
            "SELECT \n    (SUM(CASE WHEN t2.date = '1998-12-27' THEN t2.balance ELSE 0 END) - \n     SUM(CASE WHEN t1.date = '1993-03-22' THEN t1.balance ELSE 0 END)) * 100.0 / \n    NULLIF(SUM(CASE WHEN t1.date = '1993-03-22' THEN t1.balance ELSE 0 END), 0) AS increase_rate\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nLEFT JOIN trans t1 ON a.account_id = t1.account_id AND t1.date = '1993-03-22'\nLEFT JOIN trans t2 ON a.account_id = t2.account_id AND t2.date = '1998-12-27'\nWHERE l.date = '1993-07-05' \nAND l.status = 'A'\nORDER BY l.date\nLIMIT 1;",
            "SELECT \n    CAST(SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) AS REAL) / \n    SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) * 100 AS increase_rate\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN trans T3 ON a.account_id = T3.account_id\nWHERE l.date = '1993-07-05'\nAND T3.date IN ('1993-03-22', '1998-12-27')",
            "SELECT \n    (CAST(SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) AS REAL) * 100.0) / \n    SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) \nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T1.date = '1993-07-05'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) * 100.0 / \n    SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) AS increase_rate\nFROM loan T1\nINNER JOIN trans T3 ON T1.account_id = T3.account_id\nWHERE T1.date = '1993-07-05'\nAND T1.status = 'A'\nAND T3.date IN ('1993-03-22', '1998-12-27')\nGROUP BY T1.account_id\nORDER BY T1.date\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "791": {
        "db_id": "superhero",
        "question": "Calculate the average height for each superhero.",
        "ground_truth": "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero",
        "amends": [
            "Do use `SUM(height_cm)` and `COUNT(id)` instead of `AVG(weight)` for calculating the average height. Do cast the result as `REAL` instead of omitting the cast. Do reference the correct table name `superhero` instead of `superheroes`. Do remove the `GROUP BY name` clause and the `name` column from the SELECT list instead of including them, as the query now calculates an overall average rather than per-name averages. Do remove the alias `average_height` instead of keeping it. The amended query now correctly calculates the average height across all superheroes using the proper height column and casting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating average height for superheroes: use SUM(\"height_cm\") divided by COUNT(\"id\") instead of AVG(\"weight\"). 2) When casting the result: cast the average as REAL data type. 3) When referencing the superhero table: use the exact table name \"superhero\" instead of \"superheroes\". 4) When calculating an overall average across all superheroes: remove GROUP BY \"name\" clause and do not include \"name\" column in the output. 5) When naming the result column: remove the alias \"average_height\" instead of keeping it."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, AVG(weight) as average_height FROM superheroes GROUP BY name;",
            "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero;"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero;"
        ],
        "amend_res": 1
    },
    "1005": {
        "db_id": "formula_1",
        "question": "What was the longest time a driver had ever spent at a pit stop?",
        "ground_truth": "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1",
        "amends": [
            "Do select `duration` instead of `MAX(pit_stop_duration)` and remove the aggregate function. Do query from `pitStops` instead of `pit_stops` and eliminate the WHERE clause with its subquery that filtered by `driver_id`. Do use `ORDER BY duration DESC LIMIT 1` instead of the subquery approach to find the maximum duration, removing the need for driver table correlation. The amended query now directly retrieves the single highest duration value from the pit stops table, matching the right SQL's behavior of returning the maximum duration without driver-specific filtering."
        ],
        "rules": [
            "1) When answering about \"the longest time a driver had ever spent at a pit stop\": make sure the output order: duration. 2) When the question mentions \"longest time\": \"longest time\" actually means \"duration in schema\". 3) When the question asks for the maximum duration value: use ORDER BY duration DESC LIMIT 1 to find the single highest duration value. 4) When querying from the pit stops table: use table name \"pitStops\" exactly as shown in the schema, not \"pit_stops\". 5) When selecting the duration value: use column name \"duration\" without aggregate functions like MAX(). 6) When finding the maximum duration: do not filter by driver_id or use subqueries that reference driver tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(pit_stop_duration) FROM pit_stops WHERE driver_id = (SELECT driver_id FROM drivers ORDER BY driver_name LIMIT 1);",
            "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1232": {
        "db_id": "thrombosis_prediction",
        "question": "Provide ID, sex and age of patient who has blood glucose (GLU) not within normal range but with total cholesterol(T-CHO) within normal range.",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX , STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU >= 180 AND T2.`T-CHO` < 250",
        "amends": [
            "Do select `T1.ID`, `T1.SEX`, and calculated age using `STRFTIME` instead of `patient_id`, `sex`, and `age`. Do use `DISTINCT` instead of omitting it. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.GLU >= 180` and `T2.T-CHO < 250` instead of `GLU BETWEEN 70 AND 140` and `T_CHO BETWEEN 120 AND 240`. The amended query now correctly identifies patients with elevated glucose and cholesterol levels by joining laboratory data with patient information and calculating age from birthdate.",
            "Do use `CURRENT_TIMESTAMP` instead of `'now'` for the current date calculation. Do remove the complex age calculation logic `- (STRFTIME('%m-%d', 'now') < STRFTIME('%m-%d', T1.Birthday))` instead of keeping it. Do use backticks for the column name `T-CHO` instead of double quotes. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly calculates age without the unnecessary birthday comparison logic and uses proper column quoting."
        ],
        "rules": [
            "1) When answering about patient information: use T1.ID, T1.SEX, and calculate age using STRFTIME instead of patient_id, sex, and age directly. 2) When combining patient and laboratory data: join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using inner match. 3) When filtering for abnormal blood glucose: use T2.GLU >= 180 instead of GLU BETWEEN 70 AND 140. 4) When filtering for normal total cholesterol: use T2.T-CHO < 250 instead of T_CHO BETWEEN 120 AND 240. 5) When selecting patient records: use DISTINCT to ensure each patient appears only once in results.",
            "1) When calculating patient age from birthday: use CURRENT_TIMESTAMP instead of 'now' for current date reference. 2) When handling column names with hyphens like \"T-CHO\": use backticks for quoting instead of double quotes. 3) When joining Patient and Laboratory tables: explicitly specify INNER JOIN instead of just JOIN. 4) When calculating age from birthday: remove the complex birthday comparison logic that checks if current month-day is before birth month-day."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT patient_id, sex, age FROM patients WHERE GLU BETWEEN 70 AND 140 AND T_CHO BETWEEN 120 AND 240;",
            "SELECT DISTINCT \n    T1.ID, \n    T1.SEX, \n    STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday) - (STRFTIME('%m-%d', 'now') < STRFTIME('%m-%d', T1.Birthday)) AS age\nFROM \n    Patient AS T1\nJOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.GLU >= 180 \n    AND T2.\"T-CHO\" < 250",
            "SELECT DISTINCT \n    T1.ID, \n    T1.SEX, \n    (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) AS age\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.GLU >= 180 \n    AND T2.`T-CHO` < 250"
        ],
        "rule_sql": [
            "SELECT DISTINCT \n    T1.ID, \n    T1.SEX, \n    (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) - \n    (CASE WHEN STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', T1.Birthday) THEN 1 ELSE 0 END) AS Age\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.GLU >= 180 \n    AND T2.`T-CHO` < 250"
        ],
        "amend_res": 1
    },
    "1198": {
        "db_id": "thrombosis_prediction",
        "question": "How many female patients were given an APS diagnosis?",
        "ground_truth": "SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS'",
        "amends": [
            "Do reference table `Patient` instead of `patients` and use column `SEX` with value `'F'` instead of `gender` with value `'male'`. Do use column `ID` in the count instead of `*` and maintain the same filter on `Diagnosis = 'APS'` instead of `diagnosis = 'APS'`. The amended query now correctly counts female patients with APS diagnosis as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question mentions \"patients\": use table \"Patient\" instead of \"patients\". 2) When the question mentions \"female\": use column \"SEX\" with value 'F' instead of \"gender\" with value 'male'. 3) When counting patients: use column \"ID\" as the counting key instead of counting all columns. 4) When filtering for APS diagnosis: use column \"Diagnosis\" with value 'APS' instead of \"diagnosis\" with value 'APS'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND diagnosis = 'APS';",
            "SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS'"
        ],
        "amend_res": 1
    },
    "1145": {
        "db_id": "european_football_2",
        "question": "Which top 4 leagues had the most games in the 2015-2016 season?",
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' GROUP BY t1.name ORDER BY COUNT(t2.id) DESC LIMIT 4",
        "amends": [
            "Do select `t1.name` instead of `league_name` and `game_count`. Do join `League AS t1` with `Match AS t2` using `INNER JOIN` on `t1.id = t2.league_id` instead of querying only the `games` table. Do filter on `t2.season = '2015/2016'` instead of `season = '2015-2016'`. Do group by `t1.name` instead of `league_name`. Do order by `COUNT(t2.id)` descending instead of `game_count` descending. The amended query now correctly counts matches per league for the specified season and matches the RIGHT_SQL's behavior.",
            "Do remove `COUNT(t2.id) AS game_count` from the SELECT list instead of including it, as the RIGHT_SQL only selects `t1.name`. Do keep all other elements unchanged including the `INNER JOIN` on `t1.id = t2.league_id`, the `WHERE t2.season = '2015/2016'` filter, the `GROUP BY t1.name` grouping, the `ORDER BY COUNT(t2.id) DESC` ordering, and the `LIMIT 4` restriction. The amended query now matches RIGHT_SQL's behavior by focusing solely on league names without the count aggregation."
        ],
        "rules": [
            "1) When answering about \"top 4 leagues had the most games\": rank leagues by match count in descending order and keep the first 4 rows. 2) When the question mentions \"leagues\": use \"t1.name\" from the League table to represent league names. 3) When the question mentions \"games\": this actually means \"matches\" in the schema, so count using \"t2.id\" from the Match table. 4) When combining League and Match tables: link rows where \"t1.id = t2.league_id\" and keep only matching pairs (inner match). 5) When filtering for the 2015-2016 season: use the exact literal value '2015/2016' for the Match.season column. 6) When counting matches per league: compute the number of rows using the canonical key \"t2.id\" from the Match table. 7) When producing output: make sure the output order is \"t1.name\" followed by the match count.",
            "1) When answering about \"top 4 leagues had the most games\": rank leagues by game count in descending order and keep the first 4 rows. 2) When the question asks for \"most games\": count the number of matches using the canonical key t2.id. 3) When the question mentions \"2015-2016 season\": filter matches where t2.season equals exactly '2015/2016'. 4) When combining League and Match tables: link rows where t1.id equals t2.league_id and keep only matching pairs (inner match). 5) When grouping by league: organize results by t1.name and compute aggregates per league. 6) When producing output: only include t1.name in the final results, not the count aggregation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT league_name, COUNT(*) as game_count \nFROM games \nWHERE season = '2015-2016' \nGROUP BY league_name \nORDER BY game_count DESC \nLIMIT 4;",
            "SELECT t1.name, COUNT(t2.id) AS game_count\nFROM League AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2015/2016'\nGROUP BY t1.name\nORDER BY COUNT(t2.id) DESC\nLIMIT 4",
            "SELECT t1.name\nFROM League AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2015/2016'\nGROUP BY t1.name\nORDER BY COUNT(t2.id) DESC\nLIMIT 4"
        ],
        "rule_sql": [
            "SELECT t1.name\nFROM League AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2015/2016'\nGROUP BY t1.name\nORDER BY COUNT(t2.id) DESC\nLIMIT 4"
        ],
        "amend_res": 1
    },
    "1063": {
        "db_id": "european_football_2",
        "question": "What is Aaron Doran's potential score?",
        "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
        "amends": [
            "Do select `t2.potential` from the joined table instead of `potential` from a single table. Do use `INNER JOIN` with `Player_Attributes AS t2` on `t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do filter by `t1.player_name = 'Aaron Doran'` as a combined field instead of separate `first_name = 'Aaron' AND last_name = 'Doran'` conditions. The amended query now correctly joins the player attributes table to access the potential field and uses the proper player identification through player_api_id, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about a player's potential score: select the \"potential\" column from the Player_Attributes table (aliased as t2). 2) When joining player information with player attributes: use an inner join between the players table (t1) and Player_Attributes table (t2) where t1.player_api_id = t2.player_api_id. 3) When filtering for a specific player by name: use the combined player_name field with exact literal 'Aaron Doran' instead of separate first and last name fields. 4) When the question asks for Aaron Doran's potential score: ensure the output column is t2.potential from the joined Player_Attributes table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT potential FROM players WHERE first_name = 'Aaron' AND last_name = 'Doran';",
            "SELECT t2.potential \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Aaron Doran'"
        ],
        "rule_sql": [
            "SELECT t2.potential \nFROM Player t1 \nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Aaron Doran'"
        ],
        "amend_res": 1
    },
    "642": {
        "db_id": "codebase_community",
        "question": "How many posts were created on 21st July, 2010?",
        "ground_truth": "SELECT COUNT(id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'",
        "amends": [
            "Do reference table `postHistory` instead of `posts` and use column `CreationDate` instead of `created_at`. Do apply the `date()` function to `CreationDate` instead of directly comparing the timestamp column. Do count `id` instead of using `COUNT(*)` for more precise counting. Do use the correct date format '2010-07-21' consistently. The amended query now correctly counts posts from the postHistory table created on the specified date."
        ],
        "rules": [
            "1) When the question asks about posts created on a specific date: use table \"postHistory\" instead of \"posts\" and column \"CreationDate\" instead of \"created_at\". 2) When comparing date values from timestamp columns: apply the date() function to \"CreationDate\" to extract the date portion before comparison. 3) When counting posts: count the \"id\" column for precise counting instead of using COUNT(*). 4) When specifying date literals: use the exact format '2010-07-21' with dashes and no time component. 5) When the question asks about posts created on July 21st, 2010: filter where date(\"CreationDate\") equals '2010-07-21'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE created_at = '2010-07-21';",
            "SELECT COUNT(Id) FROM postHistory WHERE date(CreationDate) = '2010-07-21';"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'"
        ],
        "amend_res": 1
    },
    "1024": {
        "db_id": "european_football_2",
        "question": "Who are the top 5 players who perform better in crossing actions? Indicate their player id.",
        "ground_truth": "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5",
        "amends": [
            "Do select `id` instead of `player_id` and `crossing_count`. Do use `Player_Attributes` table instead of `player_actions`. Do remove the `WHERE action_type = 'crossing'` filter instead of keeping it. Do order by `crossing` column instead of `crossing_count` aggregate. Do remove the `GROUP BY player_id` and `COUNT(*)` aggregation instead of including them. The amended query now correctly retrieves player IDs ordered by crossing attribute values rather than counting crossing actions from an events table.",
            "Do select `id` instead of `player_api_id` from the Player_Attributes table, maintaining the same ordering by `crossing DESC` and `LIMIT 5` clause, which corrects the column reference to match the intended identifier field. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"top 5 players who perform better in crossing actions\": rank players by their crossing attribute in descending order and keep the first 5 rows. 2) When the question asks for player id: use the exact column \"id\" from the Player_Attributes table instead of \"player_id\". 3) When ordering by crossing performance: use the exact column \"crossing\" from the Player_Attributes table instead of counting crossing actions. 4) When retrieving data about player attributes: use the Player_Attributes table instead of player_actions table. 5) When selecting output columns: include only the \"id\" column to indicate player id.",
            "1) When the question asks for \"top 5 players who perform better in crossing actions\": rank players by their crossing attribute in descending order and keep the first 5 rows. 2) When the question asks for \"player id\" from Player_Attributes table: select the \"id\" column instead of \"player_api_id\" column. 3) When ordering by crossing performance: use the \"crossing\" column from Player_Attributes table with DESC direction to get highest values first."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_id, COUNT(*) as crossing_count \nFROM player_actions \nWHERE action_type = 'crossing' \nGROUP BY player_id \nORDER BY crossing_count DESC \nLIMIT 5;",
            "SELECT player_api_id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5",
            "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5"
        ],
        "amend_res": 1
    },
    "627": {
        "db_id": "codebase_community",
        "question": "How many users were adult?",
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "amends": [
            "Do `COUNT(id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do `BETWEEN 19 AND 65` instead of `< 18` to filter for adult working age range instead of minors. The amended query now correctly counts adult users within the specified age range rather than counting all underage users."
        ],
        "rules": [
            "1) When counting users: use COUNT(\"id\") to count specific non-null values rather than all rows. 2) When filtering for adult users: use age BETWEEN 19 AND 65 to filter for adult working age range instead of minors."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE age < 18;",
            "SELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65;"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM users WHERE age BETWEEN 19 AND 65"
        ],
        "amend_res": 1
    },
    "475": {
        "db_id": "card_games",
        "question": "How many cards in the set Coldsnap have a black border color?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only black-bordered cards. Do add `INNER JOIN sets AS T2 ON T2.code = T1.setCode` instead of querying only the cards table. Do reference `T2.name = 'Coldsnap'` instead of `set_name = 'Coldsnap'` to filter by set name through the joined sets table. Do use `T1.borderColor` instead of `border_color` to reference the correct column name. The amended query now correctly joins tables and counts only specific border colors, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about cards in a specific set: combine the cards table (T1) and sets table (T2) by linking rows where T2.code equals T1.setCode, keeping only matching pairs. 2) When filtering by set name 'Coldsnap': use T2.name = 'Coldsnap' exactly as written. 3) When counting cards with black border color: use SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END) to count only rows where T1.borderColor equals 'black' exactly. 4) When referencing border color column: use T1.borderColor instead of border_color to match the exact column name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE set_name = 'Coldsnap' AND border_color = 'black';",
            "SELECT SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END) AS black_bordered_cards_count\nFROM cards AS T1\nINNER JOIN sets AS T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Coldsnap';"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END) AS count_black_border_cards\nFROM cards T1\nJOIN sets T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Coldsnap';"
        ],
        "amend_res": 1
    },
    "1527": {
        "db_id": "debit_card_specializing",
        "question": "Which gas station has the highest amount of revenue?",
        "evidence": "",
        "ground_truth": "SELECT GasStationID FROM transactions_1k GROUP BY GasStationID ORDER BY SUM(Price) DESC LIMIT 1",
        "amends": [
            "Do select `GasStationID` instead of `name, MAX(revenue)` and do add `GROUP BY GasStationID` instead of omitting it. Do change the aggregation to `SUM(Price)` instead of `MAX(revenue)` and do add `ORDER BY SUM(Price) DESC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limiting and do change the table source to `transactions_1k` instead of `gas_stations`. The amended query now correctly identifies the gas station with the highest total revenue by summing transaction prices rather than finding maximum individual revenue values.",
            "Do order by `SUM(Price)` directly instead of ordering by the alias `TotalRevenue` in the SELECT clause. Do remove the `SUM(Price) AS TotalRevenue` column from the SELECT list instead of including it, as only the GasStationID is needed. The amended query now correctly identifies the top gas station by revenue without including unnecessary aggregated data in the output, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which gas station has the highest amount of revenue\": make sure the output order: GasStationID. 2) When the question mentions \"revenue\": \"revenue\" actually means \"SUM(Price) in schema\". 3) When the question mentions \"highest\": rank rows by SUM(Price) in descending direction and keep the first 1 row. 4) When the question asks for \"which gas station\": organize results by GasStationID and compute requested aggregates per group. 5) When combining data for gas stations: use the table transactions_1k instead of gas_stations.",
            "1) When answering about \"which gas station has the highest amount of revenue\": make sure the output order: GasStationID only. 2) When computing the highest revenue: rank rows by SUM(Price) in descending order and keep the first 1 row. 3) When grouping by GasStationID: organize results by GasStationID and compute SUM(Price) per group. 4) When producing output: do not include the SUM(Price) column in the final results, only include GasStationID."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, MAX(revenue) FROM gas_stations;",
            "SELECT GasStationID, SUM(Price) AS TotalRevenue FROM transactions_1k GROUP BY GasStationID ORDER BY TotalRevenue DESC LIMIT 1;",
            "SELECT GasStationID FROM transactions_1k GROUP BY GasStationID ORDER BY SUM(Price) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT GasStationID\nFROM transactions_1k\nGROUP BY GasStationID\nORDER BY SUM(Price) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "866": {
        "db_id": "formula_1",
        "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
        "ground_truth": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
        "amends": [
            "Do select `T2.forename`, `T2.surname`, and `T2.url` instead of `introduction_website`. Do use `DISTINCT` instead of omitting it. Do join `lapTimes AS T1` with `drivers AS T2` using `INNER JOIN` on `T2.driverId = T1.driverId` instead of querying only the `players` table. Do filter with `T1.raceId = 161` instead of `race_id = 161`. Do use `T1.time LIKE '1:27%'` for pattern matching instead of exact match `lap_time = '0:01:27'`. The amended query now correctly retrieves driver information based on lap time patterns and race ID from the appropriate tables."
        ],
        "rules": [
            "1) When answering about lap times and driver information: join lapTimes table as T1 with drivers table as T2 using T2.driverId = T1.driverId to link driver details with lap time records. 2) When filtering by race number 161: use T1.raceId = 161 to match the exact race identifier. 3) When searching for lap time 0:01:27: use T1.time LIKE '1:27%' for pattern matching instead of exact string comparison. 4) When selecting driver information: output T2.forename, T2.surname, and T2.url instead of introduction_website. 5) When retrieving results: use DISTINCT to ensure unique driver records are returned."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT introduction_website FROM players WHERE lap_time = '0:01:27' AND race_id = 161;",
            "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes T1 JOIN drivers T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%';"
        ],
        "amend_res": 1
    },
    "1047": {
        "db_id": "european_football_2",
        "question": "What is the football player Francois Affolter header's finishing rate on 18/09/2014?",
        "ground_truth": "SELECT t2.heading_accuracy FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Francois Affolter' AND SUBSTR(t2.`date`, 1, 10) = '2014-09-18'",
        "amends": [
            "Do use `t2.heading_accuracy` instead of calculating `(goals_scored / headers_attempted) * 100` as `finishing_rate`. Do join `Player AS t1` and `Player_Attributes AS t2` on `t1.player_api_id = t2.player_api_id` instead of querying a single `player_stats` table. Do filter with `SUBSTR(t2.date, 1, 10) = '2014-09-18'` instead of `match_date = '2014-09-18'` to handle date string extraction. The amended query now correctly retrieves heading accuracy data from the proper tables using the appropriate join condition and date filtering."
        ],
        "rules": [
            "1) When answering about football player finishing rate: use \"t2.heading_accuracy\" as the finishing rate instead of calculating (goals_scored / headers_attempted) * 100. 2) When combining player and player attributes data: link rows where \"t1.player_api_id = t2.player_api_id\" and keep only matching pairs (inner match). 3) When filtering by date '2014-09-18': use \"SUBSTR(t2.date, 1, 10) = '2014-09-18'\" to handle date string extraction instead of direct date comparison. 4) When the question mentions \"Francois Affolter\": use \"player_name = 'Francois Affolter'\" as the filter condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (goals_scored / headers_attempted) * 100 AS finishing_rate FROM player_stats WHERE player_name = 'Francois Affolter' AND match_date = '2014-09-18';",
            "SELECT t2.heading_accuracy AS finishing_rate\nFROM Player AS t1\nJOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Francois Affolter'\nAND SUBSTR(t2.date, 1, 10) = '2014-09-18';"
        ],
        "rule_sql": [
            "SELECT t2.heading_accuracy AS finishing_rate\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Francois Affolter'\nAND SUBSTR(t2.date, 1, 10) = '2014-09-18'"
        ],
        "amend_res": 1
    },
    "1377": {
        "db_id": "student_club",
        "question": "How many student have the position of president?",
        "ground_truth": "SELECT COUNT(member_id) FROM member WHERE position = 'President'",
        "amends": [
            "Do count `member_id` instead of `*` to exclude null values. Do reference table `member` instead of `students` to query the correct data source. Do filter for `'President'` with proper capitalization instead of `'president'` to match the exact string values in the database. The amended query now correctly counts non-null member IDs from the member table where position is exactly 'President', matching the intended behavior."
        ],
        "rules": [
            "1) When counting students with a specific position: count non-null values of \"member_id\" instead of all rows to exclude null values. 2) When the question mentions \"students\": this actually means the \"member\" table in the schema. 3) When filtering for position values: use exact capitalization 'President' instead of 'president' to match database values exactly. 4) When answering about \"how many students have the position of president\": make sure the output order: count of \"member_id\" from \"member\" table where \"position\" equals 'President'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE position = 'president';",
            "SELECT COUNT(member_id) FROM member WHERE position = 'President';"
        ],
        "rule_sql": [
            "SELECT COUNT(member_id) FROM member WHERE position = 'President';"
        ],
        "amend_res": 1
    },
    "814": {
        "db_id": "superhero",
        "question": "List the skin colour of the superheroes with 100 attribute value.",
        "ground_truth": "SELECT DISTINCT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id WHERE T3.attribute_value = 100",
        "amends": [
            "Do use `DISTINCT T2.colour` instead of `skin_color` to select unique color values from the joined table. Do add joins to `colour AS T2` on `T1.skin_colour_id = T2.id` and `hero_attribute AS T3` on `T1.id = T3.hero_id` instead of querying a single table. Do change the filter to `T3.attribute_value = 100` instead of `attribute = 100` to reference the correct table and column. Do remove the direct column reference `skin_color` and instead join through proper relational tables to access the color information. The amended query now correctly retrieves distinct color values by joining multiple tables and filtering on the appropriate attribute value column."
        ],
        "rules": [
            "1) When the question asks for \"skin colour of the superheroes\": use \"T2.colour\" from the colour table instead of direct column references. 2) When filtering for superheroes with 100 attribute value: use \"T3.attribute_value = 100\" from the hero_attribute table. 3) When combining tables for superhero information: link rows where \"T1.skin_colour_id = T2.id\" and \"T1.id = T3.hero_id\" using inner matches. 4) When selecting color values: use \"DISTINCT T2.colour\" to get unique color values. 5) When answering about superhero attributes: make sure to join through proper relational tables (superheroes as T1, colour as T2, hero_attribute as T3) instead of querying a single table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT skin_color FROM superheroes WHERE attribute = 100;",
            "SELECT DISTINCT T2.colour\nFROM superhero AS T1\nJOIN colour AS T2 ON T1.skin_colour_id = T2.id\nJOIN hero_attribute AS T3 ON T1.id = T3.hero_id\nWHERE T3.attribute_value = 100"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.colour\nFROM superhero T1\nINNER JOIN colour T2 ON T1.skin_colour_id = T2.id\nINNER JOIN hero_attribute T3 ON T1.id = T3.hero_id\nWHERE T3.attribute_value = 100"
        ],
        "amend_res": 1
    },
    "1125": {
        "db_id": "european_football_2",
        "question": "Among the players with finishing rate of 1, pick the eldest player and state the player's name.",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.finishing = 1 ORDER BY t1.birthday ASC LIMIT 1",
        "amends": [
            "Do select `t1.player_name` with `DISTINCT` instead of `name` without distinct. Do use `FROM Player AS t1 INNER JOIN Player_Attributes AS t2` instead of `FROM players` alone. Do join on `t1.player_api_id = t2.player_api_id` instead of no join condition. Do filter with `t2.finishing = 1` instead of `finishing_rate = 1`. Do order by `t1.birthday ASC` instead of `age ASC`. The amended query now correctly joins the Player and Player_Attributes tables to filter on the finishing attribute and returns distinct player names ordered by birthday."
        ],
        "rules": [
            "1) When the question asks for \"player's name\": use the exact column token \"t1.player_name\" instead of \"name\". 2) When selecting player names: ensure distinct values are returned to avoid duplicates. 3) When filtering for players with finishing rate of 1: use the exact condition \"t2.finishing = 1\" with the literal value 1. 4) When determining the eldest player: order by \"t1.birthday ASC\" (ascending order of birth dates) instead of age. 5) When combining Player and Player_Attributes tables: perform an inner join using the exact condition \"t1.player_api_id = t2.player_api_id\" to link related records. 6) When answering about the eldest player among those with finishing rate of 1: return only the first result after ordering by birthday in ascending order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE finishing_rate = 1 ORDER BY age ASC LIMIT 1;",
            "SELECT DISTINCT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.finishing = 1\nORDER BY t1.birthday ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.finishing = 1\nORDER BY t1.birthday ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "192": {
        "db_id": "financial",
        "question": "What is the average amount of loan which are still on running contract with statement issuance after each transaction?",
        "ground_truth": "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'",
        "amends": [
            "Do use `AVG(T2.amount)` with explicit table alias instead of `AVG(amount)` without qualification. Do join `account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id` instead of querying only the `loans` table. Do filter with `T2.status IN ('C', 'D')` instead of `status = 'running'` and add `T1.frequency = 'POPLATEK PO OBRATU'` instead of `statement_issuance = 'after_transaction'`. The amended query now correctly joins account and loan tables with proper status codes and frequency filter, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about average loan amount: use AVG(T2.amount) with explicit table alias instead of unqualified AVG(amount). 2) When combining account and loan tables: join account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id instead of querying only the loans table. 3) When filtering for loans still on running contract: use T2.status IN ('C', 'D') instead of status = 'running'. 4) When filtering for statement issuance after each transaction: use T1.frequency = 'POPLATEK PO OBRATU' instead of statement_issuance = 'after_transaction'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(amount) FROM loans WHERE status = 'running' AND statement_issuance = 'after_transaction';",
            "SELECT AVG(T2.amount) AS average_loan_amount\nFROM account AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nWHERE T2.status IN ('C', 'D')\nAND T1.frequency = 'POPLATEK PO OBRATU';"
        ],
        "rule_sql": [
            "SELECT AVG(T2.amount) AS average_loan_amount\nFROM account AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nWHERE T2.status IN ('C', 'D')\nAND T1.frequency = 'POPLATEK PO OBRATU';"
        ],
        "amend_res": 1
    },
    "53": {
        "db_id": "california_schools",
        "question": "How many test takers are there at the school/s whose mailing city address is in Fresno?",
        "evidence": "",
        "ground_truth": "SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'",
        "amends": [
            "Do select `T1.NumTstTakr` instead of `COUNT(*)` and change the source to `satscores AS T1` instead of `test_takers`. Do add `INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode` instead of omitting the join. Do use filter `T2.MailCity = 'Fresno'` instead of `city = 'Fresno'` and remove the aggregate function instead of keeping it. The amended query now correctly joins the satscores and schools tables to count test takers from Fresno based on the proper relationship between CDS codes."
        ],
        "rules": [
            "1) When answering about \"test takers at schools in Fresno\": make sure the output order: T1.NumTstTakr\n2) When the question mentions \"test takers\": \"test takers\" actually means \"T1.NumTstTakr in schema\"\n3) When the question mentions \"mailing city address is in Fresno\": \"mailing city address\" actually means \"T2.MailCity in schema\" and use exact literal 'Fresno'\n4) When combining T1 and T2 for shared entities: link rows where T1.cds = T2.CDSCode exactly as shown; keep only matching pairs (inner match)\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n6) When handling text literals: do not change case, spacing, or punctuation of 'Fresno'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM test_takers WHERE city = 'Fresno';",
            "SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'"
        ],
        "rule_sql": [
            "SELECT T1.NumTstTakr\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.MailCity = 'Fresno'"
        ],
        "amend_res": 1
    },
    "1506": {
        "db_id": "debit_card_specializing",
        "question": "Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.",
        "ground_truth": "SELECT DISTINCT T3.Description FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Country = 'CZE'",
        "amends": [
            "Do join `transactions_1k AS T1` instead of querying `transactions` alone. Do add `INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID` instead of filtering directly on location_type. Do add `INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID` instead of selecting product_description directly. Do select `T3.Description` instead of `product_description`. Do filter on `T2.Country = 'CZE'` instead of `country = 'Czech Republic'`. Do add `DISTINCT` instead of omitting it. Do remove the `location_type = 'gas station'` filter instead of keeping it since the gasstations table inherently provides this context."
        ],
        "rules": [
            "1) When answering about product descriptions from transactions at gas stations in Czech Republic: make sure the output order: T3.Description. 2) When the question mentions \"Czech Republic\": \"Czech Republic\" actually means \"T2.Country = 'CZE'\" in schema. 3) When combining T1 (transactions_1k) and T2 (gasstations) for shared entities: link rows where T1.GasStationID = T2.GasStationID; keep only matching pairs (inner match). 4) When combining T1 (transactions_1k) and T3 (products) for shared entities: link rows where T1.ProductID = T3.ProductID; keep only matching pairs (inner match). 5) When selecting product descriptions: use T3.Description instead of product_description directly from transactions. 6) When listing distinct product descriptions: use DISTINCT to return only unique values of T3.Description. 7) When filtering for gas stations: do not use location_type filter since the gasstations table inherently provides this context through the join."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_description FROM transactions WHERE country = 'Czech Republic' AND location_type = 'gas station';",
            "SELECT DISTINCT T3.Description \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN products AS T3 ON T1.ProductID = T3.ProductID\nWHERE T2.Country = 'CZE'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.Description\nFROM transactions_1k T1\nINNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN products T3 ON T1.ProductID = T3.ProductID\nWHERE T2.Country = 'CZE'\nORDER BY T3.Description;"
        ],
        "amend_res": 1
    },
    "10": {
        "db_id": "california_schools",
        "question": "For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?",
        "evidence": "",
        "ground_truth": "SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1",
        "amends": [
            "Do specify the full column reference `T2.`FRPM Count (Ages 5-17)` instead of the incorrect `FRPM_5_17`. Do use the correct table alias `T2` from the joined `frpm` table instead of the non-existent source. Do add the required `INNER JOIN` on `T1.cds = T2.CDSCode` to properly link the tables instead of querying a single table. Do reference the correct sorting column `T1.AvgScrRead` instead of the non-existent `Reading`. Do use the proper table aliases `satscores AS T1` and `frpm AS T2` instead of the incorrect table names. The amended query now correctly joins the datasets and returns the appropriate FRPM count based on reading score ordering."
        ],
        "rules": [
            "1) When answering about \"school with the highest average score in Reading\": rank schools by T1.AvgScrRead in descending order and keep the first 1 row. 2) When combining T1 and T2 for shared entities: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match). 3) When the question asks for \"FRPM count for students aged 5-17\": use the exact column T2.\"FRPM Count (Ages 5-17)\" instead of FRPM_5_17. 4) When producing output: make sure the output order includes only T2.\"FRPM Count (Ages 5-17)\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT FRPM_5_17 FROM sat_scores ORDER BY Reading DESC LIMIT 1;",
            "SELECT T2.\"FRPM Count (Ages 5-17)\"\nFROM satscores AS T1\nINNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrRead DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.\"FRPM Count (Ages 5-17)\"\nFROM satscores T1\nINNER JOIN frpm T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrRead DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "605": {
        "db_id": "codebase_community",
        "question": "How many users obtained the \"Announcer\" badge?",
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE Name = 'Announcer'",
        "amends": [
            "Do select `COUNT(id)` from the `badges` table instead of `COUNT(*)` from the `users` table. Do filter on `Name = 'Announcer'` instead of `badge_name = 'Announcer'` to correctly query the badges table. The amended query now matches the intended behavior of counting Announcer badges rather than users with a badge_name field."
        ],
        "rules": [
            "1) When counting entities from the badges table: use COUNT(\"id\") instead of COUNT(*) to count the canonical key. 2) When filtering for the \"Announcer\" badge: use the exact condition Name = 'Announcer' with the exact literal 'Announcer' (case-sensitive). 3) When answering about badge counts: query the badges table directly instead of the users table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE badge_name = 'Announcer';",
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Announcer'"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Announcer';"
        ],
        "amend_res": 1
    },
    "149": {
        "db_id": "financial",
        "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
        "ground_truth": "SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
        "amends": [
            "Do select `T3.type` instead of `a.account_type`. Do join `district AS T1` and `account AS T2` with `T1.district_id = T2.district_id` instead of `accounts a JOIN districts d ON a.district_id = d.district_id`. Do add `disp AS T3` with `INNER JOIN` on `T2.account_id = T3.account_id` instead of omitting this table. Do use filter `T3.type != 'OWNER'` instead of `a.account_type NOT IN` subquery. Do change income filter to `T1.A11 BETWEEN 8000 AND 9000` instead of `d.average_income > 8000 AND d.average_income <= 9000`. Do remove `DISTINCT` instead of keeping it. The amended query now correctly filters account types by disp type rather than excluding loan account types and uses proper table relationships."
        ],
        "rules": [
            "1) When combining district and account tables: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match). 2) When combining account and disp tables: link rows where T2.account_id = T3.account_id and keep only matching pairs (inner match). 3) When filtering by average income: use T1.A11 BETWEEN 8000 AND 9000 (inclusive range) instead of separate greater than and less than or equal to conditions. 4) When identifying account types that are not eligible for loans: use T3.type != 'OWNER' instead of excluding loan account types through a subquery. 5) When selecting account types: use T3.type instead of a.account_type. 6) When the question asks for distinct account types: do not use DISTINCT in the selection."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.account_type\nFROM accounts a\nJOIN districts d ON a.district_id = d.district_id\nWHERE d.average_income > 8000 AND d.average_income <= 9000\nAND a.account_type NOT IN (SELECT DISTINCT account_type FROM loans);",
            "SELECT T3.type\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3 ON T2.account_id = T3.account_id\nWHERE T1.A11 BETWEEN 8000 AND 9000\nAND T3.type != 'OWNER'"
        ],
        "rule_sql": [
            "SELECT T3.type\nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nINNER JOIN disp T3 ON T2.account_id = T3.account_id\nWHERE T1.A11 BETWEEN 8000 AND 9000\nAND T3.type != 'OWNER'"
        ],
        "amend_res": 1
    },
    "1479": {
        "db_id": "debit_card_specializing",
        "question": "Which year recorded the most consumption of gas paid in CZK?",
        "ground_truth": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do select `SUBSTR(T2.Date, 1, 4)` instead of `year`. Do join `customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID` instead of querying `gas_consumption` alone. Do filter on `T1.Currency = 'CZK'` instead of `currency = 'CZK'`. Do add `GROUP BY SUBSTR(T2.Date, 1, 4)` instead of omitting grouping. Do order by `SUM(T2.Consumption) DESC` instead of `consumption DESC`. The amended query now correctly aggregates consumption by year and returns the year with highest total consumption for CZK currency customers.",
            "Do remove the alias `Year` from the `SELECT` list instead of keeping it. Do remove the alias `TotalConsumption` from the aggregate expression `SUM(T2.Consumption)` instead of keeping it. The amended query now matches RIGHT_SQL's behavior by returning only the year values without column aliases."
        ],
        "rules": [
            "1) When answering about \"year with most consumption of gas paid in CZK\": extract year from T2.Date using SUBSTR(T2.Date, 1, 4) instead of using a year column directly. 2) When combining customer and consumption data: join customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID to link customer currency information with consumption records. 3) When filtering for CZK currency: use T1.Currency = 'CZK' exactly as specified. 4) When grouping by year: use GROUP BY SUBSTR(T2.Date, 1, 4) to aggregate consumption data annually. 5) When ordering by highest consumption: order by SUM(T2.Consumption) DESC to rank years by total consumption. 6) When selecting the top result: return only the first row after ordering to get the year with maximum consumption.",
            "1) When answering about \"which year recorded the most consumption of gas paid in CZK\": make sure the output order: year only without column aliases. 2) When the question mentions \"consumption of gas paid in CZK\": \"CZK\" actually means \"Currency = 'CZK'\" in the customers table. 3) When the question asks for \"most consumption\": rank rows by total consumption in descending order and keep the first 1 row. 4) When the question asks for \"year\": extract year from the Date column using SUBSTR(T2.Date, 1, 4). 5) When combining customers as T1 and yearmonth as T2: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match). 6) When grouping by year: organize results by the extracted year value and compute SUM(T2.Consumption) per group."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT year FROM gas_consumption WHERE currency = 'CZK' ORDER BY consumption DESC LIMIT 1;",
            "SELECT SUBSTR(T2.Date, 1, 4) AS Year, SUM(T2.Consumption) AS TotalConsumption\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK'\nGROUP BY SUBSTR(T2.Date, 1, 4)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
            "SELECT SUBSTR(T2.Date, 1, 4) \nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Currency = 'CZK' \nGROUP BY SUBSTR(T2.Date, 1, 4) \nORDER BY SUM(T2.Consumption) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT SUBSTR(T2.Date, 1, 4) \nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Currency = 'CZK' \nGROUP BY SUBSTR(T2.Date, 1, 4) \nORDER BY SUM(T2.Consumption) DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "788": {
        "db_id": "superhero",
        "question": "How many percent of female heroes were published by Marvel Comics?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T3.gender = 'Female'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `publisher AS T2` on `T1.publisher_id = T2.id` and `gender AS T3` on `T1.gender_id = T3.id` instead of querying a single table. Do filter on `T3.gender = 'Female'` in the WHERE clause instead of using a subquery. Do calculate the percentage using `COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END)` divided by `COUNT(T1.id)` instead of counting all rows. Do cast the result to `REAL` instead of using integer division. The amended query now correctly calculates the percentage of female Marvel Comics heroes by properly joining related tables and using appropriate aggregation."
        ],
        "rules": [
            "1) When answering about percentage of female heroes published by Marvel Comics: make sure the output order: percentage\n2) When the question mentions \"female heroes\": \"female\" actually means \"T3.gender = 'Female'\" in schema\n3) When the question mentions \"Marvel Comics\": \"Marvel Comics\" actually means \"T2.publisher_name = 'Marvel Comics'\" in schema\n4) When combining T1, T2, and T3 for shared entities: link rows where T1.publisher_id = T2.id and T1.gender_id = T3.id; keep only matching pairs (inner match)\n5) When calculating percentage of female Marvel Comics heroes: compute (COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END)) divided by (COUNT(T1.id)), guarding division by zero; cast the result to REAL instead of using integer division\n6) When counting heroes: use T1.id as the canonical counting key for heroes"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100 / (SELECT COUNT(*) FROM heroes WHERE gender = 'Female')) AS percentage\nFROM heroes \nWHERE publisher = 'Marvel Comics'",
            "SELECT \n    (COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    superhero AS T1\nJOIN \n    publisher AS T2 ON T1.publisher_id = T2.id\nJOIN \n    gender AS T3 ON T1.gender_id = T3.id\nWHERE \n    T3.gender = 'Female';"
        ],
        "rule_sql": [
            "SELECT \n    CAST(COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100.0 / \n    NULLIF(COUNT(s.id), 0) AS percentage\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    gender g ON s.gender_id = g.id\nWHERE \n    g.gender = 'Female'"
        ],
        "amend_res": 1
    },
    "1161": {
        "db_id": "thrombosis_prediction",
        "question": "For in-patient age 50 and above, what is their average anti-cardiolipin antibody (IgG) concentration?",
        "ground_truth": "SELECT AVG(T2.`aCL IgG`) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 AND T1.Admission = '+'",
        "amends": [
            "Do reference `T2.`aCL IgG`` instead of `anti_cardiolipin_antibody_igg` in the SELECT list. Do join `Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID` instead of querying only the `patients` table. Do calculate age using `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50` instead of a simple `age >= 50` column. Do filter with `T1.Admission = '+'` instead of `patient_type = 'outpatient'`. The amended query now correctly calculates age from birthdate and uses proper table joins to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about average anti-cardiolipin antibody (IgG) concentration: use T2.\"aCL IgG\" as the exact column name for the measurement. 2) When calculating age for patients: compute age using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 instead of a simple age column. 3) When filtering for in-patient status: use T1.Admission = '+' instead of patient_type = 'outpatient'. 4) When combining patient and examination data: join Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID to link patient records with their examination results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(anti_cardiolipin_antibody_igg) FROM patients WHERE age >= 50 AND patient_type = 'outpatient';",
            "SELECT AVG(T2.`aCL IgG`) AS average_anti_cardiolipin_igg\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) >= 50\nAND T1.Admission = '+';"
        ],
        "rule_sql": [
            "SELECT AVG(T2.\"aCL IgG\") AS average_acl_igg\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) >= 50\nAND T1.Admission = '+';"
        ],
        "amend_res": 1
    },
    "171": {
        "db_id": "financial",
        "question": "What was the difference in the number of crimes committed in East and North Bohemia in 1996?",
        "ground_truth": "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district",
        "amends": [
            "Do use `SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0))` instead of subtracting two separate `COUNT(*)` subqueries. Do query from the `district` table instead of the `crimes` table. Do reference columns `A3` for region names and `A16` for count values instead of filtering on `region` and `year` columns. Do use case-insensitive region comparisons `'east Bohemia'` and `'north Bohemia'` instead of exact case matches. Do remove the explicit `year = 1996` filter since the right query appears to work with aggregated data that already represents the specific year. The amended query now correctly calculates the crime difference using proper aggregation from the district table."
        ],
        "rules": [
            "1) When the question asks about crime counts in specific regions: use the district table instead of a crimes table, with column A3 for region names and A16 for count values. 2) When calculating the difference between counts for 'East Bohemia' and 'North Bohemia': use SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) instead of subtracting separate COUNT(*) subqueries. 3) When comparing region names: use case-insensitive comparisons with 'east Bohemia' and 'north Bohemia' instead of exact case matches. 4) When working with aggregated crime data: do not filter by year since the data already represents the specific year 1996 in aggregated form."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM crimes WHERE region = 'East Bohemia' AND year = 1996) - \n    (SELECT COUNT(*) FROM crimes WHERE region = 'North Bohemia' AND year = 1996) AS crime_difference;",
            "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) AS crime_difference FROM district;"
        ],
        "rule_sql": [
            "SELECT SUM(IIF(LOWER(A3) = 'east bohemia', A16, 0)) - SUM(IIF(LOWER(A3) = 'north bohemia', A16, 0)) AS crime_difference FROM district;"
        ],
        "amend_res": 1
    },
    "1080": {
        "db_id": "european_football_2",
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "ground_truth": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "amends": [
            "Do count `player_api_id` instead of `*` to count specific non-null values. Do query from `Player_Attributes` table instead of `players` table to access the correct data source. Do filter on `attacking_work_rate = 'low'` instead of `position = 'attacker'` to use the appropriate attribute filter available in the target table. The amended query now correctly counts left-footed players with low attacking work rate from the Player_Attributes table.",
            "Do remove `DISTINCT` from the count aggregation instead of keeping it, as the query should count all players matching the criteria rather than counting distinct player IDs. Do maintain the same `WHERE` clause with filters on `preferred_foot = 'left'` and `attacking_work_rate = 'low'` instead of changing them. The amended query now correctly counts all players with left preferred foot and low attacking work rate, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When counting players: use \"player_api_id\" as the counting key instead of counting all columns. 2) When accessing player attributes data: query from the \"Player_Attributes\" table instead of the \"players\" table. 3) When filtering for players who remain in position when attacking: use \"attacking_work_rate = 'low'\" instead of position-based filters. 4) When filtering for left-footed players: use \"preferred_foot = 'left'\" as specified in the question.",
            "1) When counting players: count all rows matching the criteria instead of counting distinct player IDs. 2) When filtering for players with left preferred foot: use the exact literal 'left' for the preferred_foot column. 3) When filtering for players with low attacking work rate: use the exact literal 'low' for the attacking_work_rate column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM players \nWHERE preferred_foot = 'left' \nAND position = 'attacker';",
            "SELECT COUNT(DISTINCT player_api_id) \nFROM Player_Attributes \nWHERE preferred_foot = 'left' \nAND attacking_work_rate = 'low';",
            "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'"
        ],
        "rule_sql": [
            "SELECT COUNT(player_api_id) \nFROM Player_Attributes \nWHERE preferred_foot = 'left' \nAND attacking_work_rate = 'low'"
        ],
        "amend_res": 1
    },
    "1293": {
        "db_id": "thrombosis_prediction",
        "question": "What is the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level?",
        "ground_truth": "SELECT T2.ANA FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 ORDER BY T2.ANA DESC LIMIT 1",
        "amends": [
            "Do select `T2.ANA` instead of `MAX(antibody_concentration)` and remove the aggregate function. Do join `Patient AS T1`, `Examination AS T2`, and `Laboratory AS T3` with `INNER JOIN` conditions `T1.ID = T2.ID` and `T1.ID = T3.ID` instead of querying only the `patients` table. Do filter with `T3.CRE < 1.5` instead of `creatinine_level = 'normal'` to use a numeric comparison rather than a string literal. Do add `ORDER BY T2.ANA DESC` and `LIMIT 1` instead of using `MAX()` aggregation to retrieve the highest value. The amended query now correctly joins multiple tables, uses proper numeric filtering for creatinine levels, and returns the maximum ANA value through ordering and limiting rather than aggregation."
        ],
        "rules": [
            "1) When answering about \"highest anti-nucleus antibody concentration level\": make sure the output order: T2.ANA DESC and take only the first row. 2) When the question mentions \"patient with a normal creatinine level\": \"normal creatinine level\" actually means T3.CRE < 1.5 in schema. 3) When combining Patient AS T1, Examination AS T2, and Laboratory AS T3: link rows where T1.ID = T2.ID and T1.ID = T3.ID; keep only matching pairs (inner match). 4) When selecting the antibody concentration level: use T2.ANA instead of MAX(antibody_concentration) and do not use aggregate functions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(antibody_concentration) FROM patients WHERE creatinine_level = 'normal';",
            "SELECT T2.ANA\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nINNER JOIN Laboratory AS T3 ON T1.ID = T3.ID\nWHERE T3.CRE < 1.5\nORDER BY T2.ANA DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.ANA\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nINNER JOIN Laboratory AS T3 ON T1.ID = T3.ID\nWHERE T3.CRE < 1.5\nORDER BY T2.ANA DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1150": {
        "db_id": "thrombosis_prediction",
        "question": "What is the percentage of female patient were born after 1930?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'",
        "amends": [
            "Do use `CAST` and `SUM` with a `CASE` expression to count patients born after 1930 instead of using `COUNT(*)` with a simple `WHERE` filter. Do reference `Birthday` column with `STRFTIME` for year extraction instead of using `year_of_birth` column directly. Do calculate percentage as `SUM(CASE...END) * 100 / COUNT(*)` instead of using a subquery for total count. Do use table name `Patient` instead of `patients` and column name `SEX` instead of `gender`. Do remove the subquery for total female count and instead perform the calculation directly in the main query using the same dataset. The amended query now correctly handles the percentage calculation using proper type casting and conditional aggregation.",
            "Do remove the `SEX = 'F'` filter from the CASE expression and instead move it to the WHERE clause instead of keeping it in the CASE. Do add explicit `CAST` to `REAL` for the SUM result instead of relying on implicit casting. Do remove the column alias `percentage` instead of keeping it. Do change the division operation to use integer division instead of floating-point division with `100.0`. The amended query now correctly calculates the percentage of female patients born after 1930 by first filtering for female patients in the WHERE clause and then calculating the percentage among that filtered set."
        ],
        "rules": [
            "1) When the question asks for percentage of female patients born after 1930: use the exact table name \"Patient\" and column name \"SEX\" instead of 'patients' and 'gender'. 2) When calculating year of birth: extract the year from the \"Birthday\" column using STRFTIME instead of using a direct year_of_birth column. 3) When counting female patients born after 1930: use SUM with a CASE expression instead of COUNT(*) with a WHERE filter. 4) When calculating the percentage: compute as (SUM(CASE...END) * 100 / COUNT(*)) with proper type casting instead of using a subquery for total count. 5) When filtering for female patients: use the exact literal value 'F' for the \"SEX\" column.",
            "1) When the question asks for percentage of female patients: filter rows where \"SEX\" equals 'F' in the WHERE clause instead of using conditional logic in the CASE expression. 2) When calculating percentage: use integer division instead of floating-point division with 100.0. 3) When performing calculations: explicitly cast the SUM result to REAL instead of relying on implicit casting. 4) When the question asks for percentage: remove column aliases like \"percentage\" from the output. 5) When filtering by birth year after 1930: use the exact literal '1930' and compare using greater than operator for year extraction from \"Birthday\" column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM patients WHERE gender = 'F')) AS percentage FROM patients WHERE gender = 'F' AND year_of_birth > 1930",
            "SELECT \n    (SUM(CASE WHEN SEX = 'F' AND STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient\nWHERE \n    Birthday IS NOT NULL;",
            "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(*) FROM Patient WHERE SEX = 'F';"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F';"
        ],
        "amend_res": 1
    },
    "411": {
        "db_id": "card_games",
        "question": "To which artist does the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\" belong?",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
        "amends": [
            "Do use `DISTINCT T1.artist` instead of `artist_name` to select unique artist values from the correct table. Do join `foreign_data AS T2` using `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying only the `cards` table without any join. Do filter with `T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'` instead of exact match `card_text = 'Das perfekte Gegenmittel zu einer dichten Formation'` to perform a case-insensitive partial string search. The amended query now correctly matches the intended behavior by joining the appropriate tables and using pattern matching for flavor text search."
        ],
        "rules": [
            "1) When the question asks about artist for a card with specific text: use DISTINCT T1.artist to select unique artist values from the main table. 2) When combining card information with foreign data: perform an inner join between the main table and foreign_data AS T2 using T1.uuid = T2.uuid to link matching rows. 3) When searching for flavor text containing specific German text: use T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%' to perform a case-insensitive partial string match instead of exact equality."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_name FROM cards WHERE card_text = 'Das perfekte Gegenmittel zu einer dichten Formation';",
            "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%Das perfekte Gegenmittel zu einer dichten Formation%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%Das perfekte Gegenmittel zu einer dichten Formation%'"
        ],
        "amend_res": 1
    },
    "779": {
        "db_id": "superhero",
        "question": "How many powers does Amazo hero have?",
        "ground_truth": "SELECT COUNT(T1.power_id) FROM hero_power AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.superhero_name = 'Amazo'",
        "amends": [
            "Do select `COUNT(T1.power_id)` from the `hero_power` table instead of `COUNT(*)` from the `powers` table. Do join `hero_power AS T1` with `superhero AS T2` on `T1.hero_id = T2.id` instead of querying the `powers` table directly. Do filter on `T2.superhero_name = 'Amazo'` instead of `hero_name = 'Amazo'` to correctly reference the superhero name column. The amended query now properly counts power associations for the specified superhero by joining the appropriate tables and using the correct column references."
        ],
        "rules": [
            "1) When counting powers for a specific superhero: use COUNT(T1.power_id) from the hero_power table instead of COUNT(*) from the powers table. 2) When joining hero_power and superhero tables: link rows where T1.hero_id = T2.id to properly associate powers with superheroes. 3) When filtering by superhero name: use T2.superhero_name = 'Amazo' instead of hero_name = 'Amazo' to reference the correct column in the superhero table. 4) When answering about \"how many powers does Amazo hero have\": make sure to join hero_power AS T1 with superhero AS T2 on T1.hero_id = T2.id and filter for T2.superhero_name = 'Amazo' before counting T1.power_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM powers WHERE hero_name = 'Amazo';",
            "SELECT COUNT(T1.power_id) \nFROM hero_power AS T1\nJOIN superhero AS T2 ON T1.hero_id = T2.id\nWHERE T2.superhero_name = 'Amazo'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.power_id) \nFROM hero_power AS T1 \nJOIN superhero AS T2 ON T1.hero_id = T2.id \nWHERE T2.superhero_name = 'Amazo'"
        ],
        "amend_res": 1
    },
    "1212": {
        "db_id": "thrombosis_prediction",
        "question": "For patients with alkaliphophatase (ALP) within normal range, were they treated as inpatient or outpatient?",
        "ground_truth": "SELECT T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300",
        "amends": [
            "Do select `Admission` from table `Patient` instead of `treatment_type` from table `patients`. Do join `Laboratory` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter with `ALP < 300` instead of `alp BETWEEN 44 AND 147`. Do remove the `treatment_type = 'inpatient'` filter instead of keeping it. The amended query now correctly joins patient and laboratory data to find admissions where ALP levels are below 300, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about treatment type for patients with ALP within normal range: use column \"Admission\" from table \"Patient\" instead of \"treatment_type\" from table \"patients\". 2) When combining patient and laboratory data: join tables using INNER JOIN on T1.ID = T2.ID to link matching patient and laboratory records. 3) When filtering for ALP within normal range: use condition ALP < 300 instead of alp BETWEEN 44 AND 147. 4) When the question asks about treatment type without specifying inpatient or outpatient: do not filter by specific admission types like 'inpatient'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT treatment_type FROM patients WHERE alp BETWEEN 44 AND 147 AND treatment_type = 'inpatient';",
            "SELECT DISTINCT p.Admission\nFROM Patient p\nINNER JOIN Laboratory l ON p.ID = l.ID\nWHERE l.ALP < 300"
        ],
        "rule_sql": [
            "SELECT p.Admission\nFROM Patient p\nINNER JOIN Laboratory l ON p.ID = l.ID\nWHERE l.ALP < 300"
        ],
        "amend_res": 1
    },
    "921": {
        "db_id": "formula_1",
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "amends": [
            "Do select `T1.url` instead of `*` and add `DISTINCT` instead of omitting it. Do join `circuits AS T1` instead of querying only `races` and use `INNER JOIN races AS T2` instead of single table access. Do filter on `T1.name = 'Silverstone Circuit'` instead of `circuit_name = 'Silverstone'` and remove the `year < 2000` condition instead of keeping it. Do add the join predicate `T2.circuitID = T1.circuitId` instead of omitting any join condition. The amended query now correctly retrieves distinct circuit URLs for Silverstone Circuit by properly joining the circuits and races tables with appropriate filtering."
        ],
        "rules": [
            "1) When answering about Formula_1 races that used the Silverstone Circuit: make sure the output order: T1.url 2) When the question mentions \"Silverstone Circuit\": \"Silverstone Circuit\" actually means \"T1.name = 'Silverstone Circuit'\" in schema 3) When combining circuits as T1 and races as T2: link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match) 4) When selecting circuit URLs: compute distinct values of T1.url instead of all columns 5) When filtering conditions: do not include year < 2000 condition as it was removed in the amends"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM races WHERE circuit_name = 'Silverstone' AND year < 2000;",
            "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Silverstone Circuit'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.url\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Silverstone Circuit'"
        ],
        "amend_res": 1
    },
    "1374": {
        "db_id": "student_club",
        "question": "How many events did the member with the phone number \"954-555-6240\" attend?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T2.link_to_event) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member WHERE T1.phone = '954-555-6240'",
        "amends": [
            "Do select `COUNT(T2.link_to_event)` instead of `COUNT(*)` to count specific attendance records rather than all events. Do join tables using `INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member` instead of querying a single events table, establishing the relationship between members and their attendance. Do filter on `T1.phone = '954-555-6240'` instead of `phone_number` to use the correct column name from the member table rather than the events table. Do add the member table as `member AS T1` instead of omitting it, as the phone number is stored in the member table rather than the events table. The amended query now correctly counts attendance records for the specified phone number by properly joining member and attendance tables."
        ],
        "rules": [
            "1) When the question asks about events attended by a member with a specific phone number: use the member table as T1 and the attendance table as T2. 2) When filtering by phone number \"954-555-6240\": use T1.phone = '954-555-6240' as the filter condition. 3) When combining member and attendance tables: link rows where T1.member_id = T2.link_to_member using an inner join. 4) When counting attendance events: count T2.link_to_event instead of counting all rows. 5) When answering about event attendance: make sure the output order is the count of attendance records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE phone_number = '954-555-6240';",
            "SELECT COUNT(T2.link_to_event) \nFROM member AS T1 \nINNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member \nWHERE T1.phone = '954-555-6240'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.link_to_event) \nFROM member AS T1 \nINNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member \nWHERE T1.phone = '954-555-6240'"
        ],
        "amend_res": 1
    },
    "1488": {
        "db_id": "debit_card_specializing",
        "question": "Who among KAM's customers consumed the most? How much did it consume?",
        "evidence": "",
        "ground_truth": "SELECT T2.CustomerID, SUM(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' GROUP BY T2.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do select `T2.CustomerID` and `SUM(T2.Consumption)` instead of `customer_name` and `MAX(consumption)`. Do add `INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do change the filter to `T1.Segment = 'KAM'` instead of `company = 'KAM'`. Do add `GROUP BY T2.CustomerID` instead of omitting grouping. Do add `ORDER BY SUM(T2.Consumption) DESC LIMIT 1` instead of selecting a single maximum value without ordering. The amended query now correctly aggregates consumption by customer for the KAM segment and returns the highest consumer."
        ],
        "rules": [
            "1) When answering about \"customers who consumed the most\": rank customers by total consumption in descending order and keep only the top 1 row. 2) When the question mentions \"KAM's customers\": \"KAM\" actually means \"T1.Segment = 'KAM'\" in the schema. 3) When combining T1 (customers) and T2 (yearmonth) for shared entities: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match). 4) When computing consumption per customer: organize results by T2.CustomerID and compute SUM(T2.Consumption) per group. 5) When selecting output columns: return T2.CustomerID and SUM(T2.Consumption) in that order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name, MAX(consumption) FROM customers WHERE company = 'KAM'",
            "SELECT T2.CustomerID, SUM(T2.Consumption) \nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Segment = 'KAM' \nGROUP BY T2.CustomerID \nORDER BY SUM(T2.Consumption) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.CustomerID, SUM(T2.Consumption) AS TotalConsumption\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'KAM'\nGROUP BY T2.CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1149": {
        "db_id": "thrombosis_prediction",
        "question": "Are there more in-patient or outpatient who were male? What is the deviation in percentage?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE SEX = 'M'",
        "amends": [
            "Do use `SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)` and `SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)` instead of counting `visit_type` conditions with separate `COUNT` functions. Do reference `Admission` column with `+` and `-` values instead of `visit_type` with 'In-patient' and 'Outpatient' values. Do calculate percentage directly as `SUM(+) * 100 / SUM(-)` instead of computing absolute deviation between counts. Do use table `Patient` instead of `patients` and reference `SEX = 'M'` instead of `gender = 'Male'`. Do remove the complex `CASE` comparison logic and `ABS` function, instead performing a simple percentage calculation. Do eliminate the `JOIN` to `visits` table entirely, instead working with a single table. The amended query now correctly calculates the percentage of positive admissions among male patients as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks about in-patient vs outpatient counts: use the \"Admission\" column with values '+' for in-patient and '-' for outpatient instead of a \"visit_type\" column. 2) When counting patients by admission type: use SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) for in-patient count and SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) for outpatient count instead of separate COUNT functions. 3) When calculating percentage deviation: compute (in-patient count * 100 / outpatient count) instead of absolute deviation between counts. 4) When filtering for male patients: use SEX = 'M' instead of gender = 'Male'. 5) When working with patient data: use the \"Patient\" table instead of \"patients\" table and do not join with any other tables. 6) When the question asks about deviation in percentage: output the simple percentage calculation directly without complex CASE comparison logic or ABS function."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN COUNT(CASE WHEN p.gender = 'Male' AND v.visit_type = 'In-patient' THEN 1 END) > COUNT(CASE WHEN p.gender = 'Male' AND v.visit_type = 'Outpatient' THEN 1 END) \n        THEN 'More In-patient males' \n        ELSE 'More Outpatient males' \n    END as comparison,\n    ABS(\n        (COUNT(CASE WHEN p.gender = 'Male' AND v.visit_type = 'In-patient' THEN 1 END) - \n         COUNT(CASE WHEN p.gender = 'Male' AND v.visit_type = 'Outpatient' THEN 1 END)) * 100.0 / \n        COUNT(CASE WHEN p.gender = 'Male' THEN 1 END)\n    ) as percentage_deviation\nFROM patients p\nJOIN visits v ON p.patient_id = v.patient_id\nWHERE p.gender = 'Male';",
            "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100.0 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS percentage_deviation\nFROM Patient\nWHERE SEX = 'M'"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS in_patient_count,\n    SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS outpatient_count,\n    (SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100.0 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)) AS percentage_deviation\nFROM Patient\nWHERE SEX = 'M'"
        ],
        "amend_res": 1
    },
    "1477": {
        "db_id": "debit_card_specializing",
        "question": "Which year recorded the most gas use paid in EUR?",
        "evidence": "",
        "ground_truth": "SELECT SUBSTRING(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY SUBSTRING(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do use `SUBSTRING(T2.Date, 1, 4)` as the selected column instead of `year, MAX(gas_use_eur)`. Do add `FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID` instead of the single table `FROM energy_data`. Do add `WHERE T1.Currency = 'EUR'` filter instead of omitting it. Do add `GROUP BY SUBSTRING(T2.Date, 1, 4)` instead of no grouping. Do add `ORDER BY SUM(T2.Consumption) DESC` instead of no ordering. Do add `LIMIT 1` instead of omitting it. The amended query now correctly identifies the year with highest consumption for EUR customers through proper table joins, filtering, aggregation, and ranking."
        ],
        "rules": [
            "1) When answering about \"year with most gas use paid in EUR\": make sure the output order: year column first. 2) When the question mentions \"year\": \"year\" actually means \"SUBSTRING(T2.Date, 1, 4)\" in schema. 3) When the question mentions \"most gas use\": \"gas use\" actually means \"SUM(T2.Consumption)\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match). 5) When the question mentions \"paid in EUR\": add filter WHERE T1.Currency = 'EUR' using exact literal 'EUR'. 6) When the question asks for \"most\" (highest): rank rows by SUM(T2.Consumption) in descending order and keep the first 1 row. 7) When the question asks for results \"by year\": organize results by SUBSTRING(T2.Date, 1, 4) and compute SUM(T2.Consumption) per group."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, MAX(gas_use_eur) FROM energy_data;",
            "SELECT SUBSTR(T2.Date, 1, 4) AS Year\nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY SUBSTR(T2.Date, 1, 4)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT \n    SUBSTRING(T2.Date, 1, 4) AS year,\n    SUM(T2.Consumption) AS total_gas_use\nFROM \n    customers T1\nINNER JOIN \n    yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Currency = 'EUR'\nGROUP BY \n    SUBSTRING(T2.Date, 1, 4)\nORDER BY \n    total_gas_use DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "321": {
        "db_id": "toxicology",
        "question": "What is the molecule of atom id \"TR000_2\" and atom id 2 \"TR000_4\"?",
        "evidence": "",
        "ground_truth": "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'",
        "amends": [
            "Do query from `bond AS T1` and `connected AS T2` with an `INNER JOIN` on `T1.bond_id = T2.bond_id` instead of querying only from `molecules`. Do filter on `T2.atom_id = 'TR000_2'` and `T2.atom_id2 = 'TR000_4'` instead of filtering on the same column `atom_id` with conflicting values. Do select only `T1.molecule_id` instead of selecting all columns with `*`. The amended query now correctly identifies molecules containing both specified atoms through their bond connections rather than attempting to find a single atom with two different IDs."
        ],
        "rules": [
            "1) When answering about molecules containing specific atoms: query from bond table as T1 and connected table as T2 with an inner join on T1.bond_id = T2.bond_id instead of querying only from molecules table. 2) When filtering for atom id \"TR000_2\" and atom id 2 \"TR000_4\": filter on T2.atom_id = 'TR000_2' and T2.atom_id2 = 'TR000_4' instead of filtering on the same column with conflicting values. 3) When selecting output columns: select only T1.molecule_id instead of selecting all columns with *."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM molecules WHERE atom_id = 'TR000_2' AND atom_id = 'TR000_4';",
            "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'"
        ],
        "rule_sql": [
            "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'"
        ],
        "amend_res": 1
    },
    "309": {
        "db_id": "toxicology",
        "question": "List out the atom id that belongs to the TR346 molecule and how many bond type can be created by this molecule?",
        "evidence": "",
        "ground_truth": "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type),T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR000' GROUP BY T1.atom_id, T2.bond_type",
        "amends": [
            "Do specify table aliases `T1.atom_id` instead of just `atom_id`, and do add `T1.molecule_id` to the SELECT list instead of omitting it. Do change the FROM clause to use `atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id` instead of just `atoms` with no join. Do change the WHERE filter to `T1.molecule_id = 'TR000'` instead of `molecule_name = 'TR346'`. Do add `DISTINCT` to `COUNT(DISTINCT T2.bond_type)` instead of counting all bond types, and do expand GROUP BY to include `T1.atom_id, T2.bond_type` instead of just `atom_id`. The amended query now correctly joins the atom and bond tables, counts distinct bond types per atom, and filters by molecule_id instead of molecule_name, matching the RIGHT_SQL's behavior.",
            "Do place `T1.molecule_id` at the end of the SELECT list instead of at the beginning. Do change the WHERE filter value to `'TR000'` instead of `'TR346'`. Do group by `T2.bond_type` instead of `T1.molecule_id` to properly support the COUNT(DISTINCT T2.bond_type) aggregation. The amended query now correctly counts distinct bond types per atom while filtering for molecule 'TR000' and grouping by the appropriate columns.",
            "Do filter with `T1.molecule_id = 'TR000'` instead of `T1.molecule_id = 'TR346'` in the WHERE clause to query the correct molecule identifier. The amended query now matches RIGHT_SQL's behavior by fixing the molecule filter condition."
        ],
        "rules": [
            "1) When answering about atoms and bonds: combine tables atom as T1 and bond as T2 using inner match where T1.molecule_id = T2.molecule_id. 2) When filtering by molecule: use T1.molecule_id = 'TR000' instead of molecule_name. 3) When counting bond types: count distinct T2.bond_type values. 4) When grouping results: group by both T1.atom_id and T2.bond_type. 5) When selecting output columns: include T1.atom_id and T1.molecule_id in the results. 6) When using identifiers: specify table aliases explicitly as T1.atom_id instead of just atom_id.",
            "1) When the question asks for atoms belonging to molecule 'TR346': use the exact literal value 'TR000' instead of 'TR346' in the filter condition. 2) When counting distinct bond types created by a molecule: group by T2.bond_type instead of T1.molecule_id to properly support the COUNT(DISTINCT T2.bond_type) aggregation. 3) When selecting output columns for atom information: place T1.molecule_id at the end of the SELECT list instead of at the beginning.",
            "1) When filtering for a specific molecule identifier: use the exact literal value 'TR000' instead of 'TR346' for the molecule_id condition. 2) When counting distinct bond types for a molecule: ensure the molecule filter condition uses the correct literal value specified in the question requirements."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_id, COUNT(bond_type) FROM atoms WHERE molecule_name = 'TR346' GROUP BY atom_id;",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) AS bond_type_count\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR346'\nGROUP BY T1.atom_id, T1.molecule_id",
            "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type), T1.molecule_id\nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR346'\nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type), T1.molecule_id\nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR000'\nGROUP BY T1.atom_id, T2.bond_type"
        ],
        "rule_sql": [
            "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type), T1.molecule_id \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type"
        ],
        "amend_res": 1
    },
    "803": {
        "db_id": "superhero",
        "question": "What is the power ID of cryokinesis?",
        "ground_truth": "SELECT id FROM superpower WHERE power_name = 'Cryokinesis'",
        "amends": [
            "Do select `id` instead of `power_name` from the column list. Do reference table `superpower` instead of `powers` as the FROM source. Do filter on `power_name = 'Cryokinesis'` instead of `power_id = 'cryokinesis'` in the WHERE clause, correcting both the column reference and case sensitivity. The amended query now correctly retrieves the ID for the specified power name rather than the power name itself, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"power ID\" of a specific power: select the \"id\" column from the \"superpower\" table instead of \"power_name\". 2) When filtering by power name in the \"superpower\" table: use the exact literal 'Cryokinesis' (case-sensitive) with the \"power_name\" column instead of using 'cryokinesis' or filtering on \"power_id\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT power_name FROM powers WHERE power_id = 'cryokinesis';",
            "SELECT id FROM superpower WHERE power_name = 'Cryokinesis';"
        ],
        "rule_sql": [
            "SELECT id FROM superpower WHERE power_name = 'Cryokinesis';"
        ],
        "amend_res": 1
    },
    "948": {
        "db_id": "formula_1",
        "question": "What are the maximum points of British constructors?",
        "ground_truth": "SELECT MAX(T1.points) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T2.nationality = 'British'",
        "amends": [
            "Do join `constructorStandings AS T1` and `constructors AS T2` on `T1.constructorId = T2.constructorId` instead of querying only the `constructors` table. Do filter on `T2.nationality = 'British'` instead of filtering directly on the base table. Do select `MAX(T1.points)` from the joined standings table instead of `MAX(points)` from the constructors table, as points data resides in constructorStandings rather than constructors. The amended query now correctly retrieves maximum points for British constructors by joining the appropriate tables containing the relationship and points data."
        ],
        "rules": [
            "1) When answering about maximum points of British constructors: make sure to join constructorStandings as T1 and constructors as T2 on T1.constructorId = T2.constructorId to link constructor standings with their constructor details. 2) When filtering for British constructors: use T2.nationality = 'British' exactly as specified, with the literal 'British' matching case and spelling. 3) When calculating maximum points: select MAX(T1.points) from the constructorStandings table (T1) rather than from the constructors table, as points data resides in constructorStandings. 4) When combining tables for this query: perform an inner match where T1.constructorId = T2.constructorId to keep only matching pairs of constructor standings and constructor details."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(points) FROM constructors WHERE nationality = 'British';",
            "SELECT MAX(T1.points) \nFROM constructorStandings AS T1 \nJOIN constructors AS T2 ON T1.constructorId = T2.constructorId \nWHERE T2.nationality = 'British'"
        ],
        "rule_sql": [
            "SELECT MAX(T1.points) \nFROM constructorStandings T1 \nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId \nWHERE T2.nationality = 'British'"
        ],
        "amend_res": 1
    },
    "906": {
        "db_id": "formula_1",
        "question": "Which was Lewis Hamilton first race? What was his points recorded for his first race event?",
        "ground_truth": "SELECT T1.name, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year ASC LIMIT 1",
        "amends": [
            "Do select `T1.name` and `T2.points` instead of `race_name` and `points`. Do join `races AS T1` with `driverStandings AS T2` on `T2.raceId = T1.raceId` instead of querying a single table. Do add an additional `INNER JOIN` with `drivers AS T3` on `T3.driverId = T2.driverId` instead of omitting this table. Do filter with `T3.forename = 'Lewis' AND T3.surname = 'Hamilton'` instead of `driver = 'Lewis Hamilton'`. Do order by `T1.year ASC` instead of `race_date ASC`. The amended query now correctly joins multiple tables to retrieve driver standings data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"Lewis Hamilton's first race\": make sure the output order: T1.name, T2.points. 2) When the question mentions \"Lewis Hamilton\": \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\" in schema. 3) When combining T1 (races) and T2 (driverStandings) for shared entities: link rows where T2.raceId = T1.raceId and keep only matching pairs (inner match). 4) When combining T2 (driverStandings) and T3 (drivers) for shared entities: link rows where T3.driverId = T2.driverId and keep only matching pairs (inner match). 5) When determining the first race: order by T1.year ASC and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name, points FROM races WHERE driver = 'Lewis Hamilton' ORDER BY race_date ASC LIMIT 1;",
            "SELECT T1.name, T2.points \nFROM races AS T1 \nINNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId \nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId \nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' \nORDER BY T1.year ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT r.name, ds.points\nFROM races r\nINNER JOIN driverStandings ds ON r.raceId = ds.raceId\nINNER JOIN drivers d ON d.driverId = ds.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nORDER BY r.year ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "678": {
        "db_id": "codebase_community",
        "question": "Which post by Harvey Motulsky has the most views? Please give the id and title of this post.",
        "ground_truth": "SELECT T2.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Harvey Motulsky' ORDER BY T2.ViewCount DESC LIMIT 1",
        "amends": [
            "Do join `users AS T1` with `posts AS T2` on `T1.Id = T2.OwnerUserId` instead of querying `posts` alone without any join. Do filter on `T1.DisplayName = 'Harvey Motulsky'` instead of directly filtering `posts.author`. Do select `T2.Id` and `T2.Title` instead of `id` and `title` without table qualification. Do order by `T2.ViewCount DESC` instead of `views ASC` with opposite direction. The amended query now correctly identifies posts by the user's display name through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"posts by Harvey Motulsky\": join users AS T1 with posts AS T2 on T1.Id = T2.OwnerUserId to establish the relationship between users and their posts. 2) When filtering for posts by Harvey Motulsky: use T1.DisplayName = 'Harvey Motulsky' instead of filtering directly on posts.author. 3) When selecting post information: use T2.Id and T2.Title instead of unqualified id and title. 4) When finding the post with most views: order by T2.ViewCount DESC instead of views ASC to get the highest value first. 5) When limiting to the top result: keep only the first row after descending ordering by view count."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, title FROM posts WHERE author = 'Harvey Motulsky' ORDER BY views ASC LIMIT 1;",
            "SELECT T2.Id, T2.Title FROM users AS T1 JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Harvey Motulsky' ORDER BY T2.ViewCount DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Id, T2.Title FROM users AS T1 JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Harvey Motulsky' ORDER BY T2.ViewCount DESC LIMIT 1"
        ],
        "amend_res": 1
    },
    "977": {
        "db_id": "formula_1",
        "question": "From race no. 50 to 100, how many finishers have been disqualified?",
        "ground_truth": "SELECT SUM(IIF(time IS NOT NULL, 1, 0)) FROM results WHERE statusId = 2 AND raceID < 100 AND raceId > 50",
        "amends": [
            "Do use `SUM(IIF(time IS NOT NULL, 1, 0))` instead of `COUNT(*)` to count only non-null time values. Do query from `results` table instead of `finishers` table. Do filter with `statusId = 2` instead of `disqualified = 'yes'`. Do use `raceID < 100 AND raceId > 50` instead of `race_no BETWEEN 50 AND 100` for the race ID range condition. The amended query now correctly counts finishers with valid completion times from the results table where they have a specific status and fall within the specified race ID range."
        ],
        "rules": [
            "1) When counting finishers: use SUM(IIF(time IS NOT NULL, 1, 0)) to count only non-null time values instead of COUNT(*). 2) When querying about finishers: use the \"results\" table instead of the \"finishers\" table. 3) When identifying disqualified finishers: use statusId = 2 instead of disqualified = 'yes'. 4) When filtering by race range from 50 to 100: use raceID < 100 AND raceId > 50 instead of race_no BETWEEN 50 AND 100."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM finishers WHERE race_no BETWEEN 50 AND 100 AND disqualified = 'yes';",
            "SELECT SUM(IIF(time IS NOT NULL, 1, 0)) AS disqualified_finishers\nFROM results\nWHERE statusId = 2\nAND raceId > 50\nAND raceId < 100;"
        ],
        "rule_sql": [
            "SELECT SUM(IIF(time IS NOT NULL, 1, 0)) AS disqualified_finishers\nFROM results\nWHERE raceId > 50 AND raceId < 100 AND statusId = 2;"
        ],
        "amend_res": 1
    },
    "1366": {
        "db_id": "student_club",
        "question": "List all the members who attended the event \"October Meeting\".",
        "ground_truth": "SELECT DISTINCT T3.member_id FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'October Meeting'",
        "amends": [
            "Do select only `T3.member_id` with `DISTINCT` instead of selecting all columns with `*`. Do join from `event AS T1` instead of querying only `members`. Do add `INNER JOIN attendance AS T2` on `T1.event_id = T2.link_to_event` instead of omitting this table and join condition. Do add `INNER JOIN member AS T3` on `T2.link_to_member = T3.member_id` instead of querying members directly. Do filter on `T1.event_name = 'October Meeting'` instead of filtering on a non-existent `event_name` column in the members table. The amended query now correctly retrieves distinct member IDs who attended the October Meeting by properly joining through the attendance relationship table."
        ],
        "rules": [
            "1) When answering about members who attended an event: use the exact table alias plan where T1 = event, T2 = attendance, T3 = member. 2) When the question mentions \"attended the event\": this requires joining through the attendance table (T2) that links events to members. 3) When combining T1 (event) and T2 (attendance): link rows where T1.event_id = T2.link_to_event exactly and keep only matching pairs (inner match). 4) When combining T2 (attendance) and T3 (member): link rows where T2.link_to_member = T3.member_id exactly and keep only matching pairs (inner match). 5) When filtering for event \"October Meeting\": use T1.event_name = 'October Meeting' exactly (case-sensitive with single quotes). 6) When selecting member identifiers: use DISTINCT T3.member_id to avoid duplicates. 7) When the question asks to \"list all members\": the output should contain only member_id values from T3, not all columns from any table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM members WHERE event_name = 'October Meeting';",
            "SELECT DISTINCT T3.member_id\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = 'October Meeting'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.member_id\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = 'October Meeting'"
        ],
        "amend_res": 1
    },
    "1456": {
        "db_id": "student_club",
        "question": "List the full name of the top five members who spend the most money in the descending order of spending.",
        "ground_truth": "SELECT T3.first_name, T3.last_name FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id ORDER BY T2.spent DESC LIMIT 5",
        "amends": [
            "Do select `T3.first_name` and `T3.last_name` from the `member` table instead of selecting `first_name` and `last_name` directly from a `members` table. Do join `expense AS T1` and `budget AS T2` with an `INNER JOIN` on `T1.link_to_budget = T2.budget_id` instead of missing these table sources entirely. Do add an `INNER JOIN` to `member AS T3` on `T1.link_to_member = T3.member_id` instead of omitting this relationship. Do order by `T2.spent DESC` instead of ordering by `spending DESC` from an unspecified source. The amended query now correctly joins the expense, budget, and member tables to retrieve member names ordered by actual spent amounts from the budget table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"top five members who spend the most money\": make sure the output order: T3.first_name, T3.last_name. 2) When the question mentions \"members\": \"members\" actually means \"member table as T3\" in schema. 3) When the question mentions \"top\", \"highest\", or \"most money\": rank rows by T2.spent in descending order and keep the first 5 rows. 4) When combining expense, budget, and member tables: link rows where T1.link_to_budget = T2.budget_id and T1.link_to_member = T3.member_id; keep only matching pairs (inner match). 5) When selecting member information: use T3.first_name and T3.last_name from the member table instead of direct columns from unspecified sources."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM members ORDER BY spending DESC LIMIT 5;",
            "SELECT T3.first_name, T3.last_name\nFROM expense AS T1\nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\nINNER JOIN member AS T3 ON T1.link_to_member = T3.member_id\nORDER BY T2.spent DESC\nLIMIT 5;"
        ],
        "rule_sql": [
            "SELECT T3.first_name, T3.last_name\nFROM expense T1\nINNER JOIN budget T2 ON T1.link_to_budget = T2.budget_id\nINNER JOIN member T3 ON T1.link_to_member = T3.member_id\nGROUP BY T3.member_id\nORDER BY SUM(T2.spent) DESC\nLIMIT 5"
        ],
        "amend_res": 1
    },
    "224": {
        "db_id": "toxicology",
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "ground_truth": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "amends": [
            "Do reference table `connected` with alias `T` instead of table `bonds` without alias. Do select column `T.bond_id` with explicit table qualification instead of unqualified `bond_id`. Do use filter condition `T.atom_id2 = 'TR000_2'` instead of `atom_id = 2 AND molecule_id = 'TR000_2'`. The amended query now correctly retrieves bond IDs from the connected table based on the specified atom identifier."
        ],
        "rules": [
            "1) When answering about \"bond IDs that have the same atom ID 2 of TR000_2\": make sure the output order: T.bond_id. 2) When the question mentions \"bond IDs\": \"bond IDs\" actually means \"T.bond_id in schema\". 3) When the question mentions \"atom ID 2 of TR000_2\": this actually means filtering where T.atom_id2 = 'TR000_2'. 4) When selecting from the connected table: always use explicit table qualification T.bond_id instead of unqualified bond_id. 5) When filtering for specific atom identifier: use exact literal 'TR000_2' with correct case and no spaces."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_id FROM bonds WHERE atom_id = 2 AND molecule_id = 'TR000_2';",
            "SELECT T.bond_id FROM connected T WHERE T.atom_id2 = 'TR000_2'"
        ],
        "rule_sql": [
            "SELECT T.bond_id FROM connected T WHERE T.atom_id2 = 'TR000_2'"
        ],
        "amend_res": 1
    },
    "1312": {
        "db_id": "student_club",
        "question": "What's Angela Sanders's major?",
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "amends": [
            "Do select `T2.major_name` from the `major` table instead of `major` from the `students` table. Do use `member AS T1 INNER JOIN major AS T2` with join condition `T1.link_to_major = T2.major_id` instead of querying a single `students` table. Do filter with `T1.first_name = 'Angela' AND T1.last_name = 'Sanders'` instead of `name = 'Angela Sanders'` to properly match separate first and last name fields. The amended query now correctly joins member and major tables to retrieve the major name using proper relationship keys and name filtering."
        ],
        "rules": [
            "1) When the question asks about a person's major: select \"T2.major_name\" from the \"major\" table instead of \"major\" from a single table. 2) When combining member and major tables: link rows where \"T1.link_to_major\" equals \"T2.major_id\" using an inner join. 3) When filtering for a person named Angela Sanders: use separate conditions \"T1.first_name = 'Angela'\" AND \"T1.last_name = 'Sanders'\" instead of a single name field. 4) When answering about Angela Sanders's major: make sure the output order: \"T2.major_name\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT major FROM students WHERE name = 'Angela Sanders';",
            "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'"
        ],
        "rule_sql": [
            "SELECT T2.major_name FROM member T1 INNER JOIN major T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'"
        ],
        "amend_res": 1
    },
    "607": {
        "db_id": "codebase_community",
        "question": "How many positive comments are there on the list?",
        "ground_truth": "SELECT COUNT(id) FROM comments WHERE score > 60",
        "amends": [
            "Do count `id` instead of `*` to exclude null values. Do filter on `score > 60` instead of `comment_text LIKE '%positive%'` to use a numeric threshold rather than text pattern matching. The amended query now correctly counts non-null comment IDs where the score exceeds 60, matching the intended behavior."
        ],
        "rules": [
            "1) When counting comments: count the \"id\" column instead of all columns to exclude null values. 2) When filtering for positive comments: use the condition \"score > 60\" instead of text pattern matching on comment_text. 3) When the question asks for \"positive comments\": this means comments where the score exceeds 60."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE comment_text LIKE '%positive%';",
            "SELECT COUNT(Id) FROM comments WHERE Score > 60;"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM comments WHERE Score > 60"
        ],
        "amend_res": 1
    },
    "1411": {
        "db_id": "student_club",
        "question": "State what kind of expenses that Sacha Harrison incurred?",
        "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
        "amends": [
            "Do select `T2.expense_description` instead of `expense_type` from a different table. Do use `member AS T1` and `expense AS T2` as source tables instead of just `expenses`. Do add an `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of having no join condition. Do filter on `T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'` instead of `name = 'Sacha Harrison'` to properly match by first and last name separately. The amended query now correctly retrieves expense descriptions by joining member and expense tables with proper name filtering."
        ],
        "rules": [
            "1) When the question asks about expenses for a person: use the exact column \"T2.expense_description\" instead of \"expense_type\" to represent expense types. 2) When retrieving data about members and expenses: use \"member AS T1\" and \"expense AS T2\" as the source tables instead of a single \"expenses\" table. 3) When combining member and expense tables: link rows where \"T1.member_id = T2.link_to_member\" using an inner join to ensure only matching pairs are kept. 4) When filtering by a person's name: use separate conditions \"T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'\" instead of a single name field to properly match first and last names individually."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT expense_type FROM expenses WHERE name = 'Sacha Harrison';",
            "SELECT T2.expense_description \nFROM member AS T1 \nINNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member \nWHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'"
        ],
        "rule_sql": [
            "SELECT T2.expense_description \nFROM member AS T1 \nINNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member \nWHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'"
        ],
        "amend_res": 1
    },
    "610": {
        "db_id": "codebase_community",
        "question": "What are the name of badge that users who have the highest reputation obtained?",
        "ground_truth": "SELECT T2.name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1",
        "amends": [
            "Do `INNER JOIN` on `T1.Id = T2.UserId` instead of `JOIN` on `b.user_id = u.id`. Do add `ORDER BY T1.Reputation DESC` instead of using a subquery with `WHERE u.reputation = (SELECT MAX(reputation) FROM users)`. Do select `T2.name` from `badges AS T2` instead of `b.name` from `badges b`. Do remove the subquery filter and instead use ordering with `LIMIT 1` to get the highest reputation user's badge. The amended query now correctly retrieves the badge name from the user with the highest reputation by joining and ordering instead of using an equality subquery."
        ],
        "rules": [
            "1) When joining users and badges tables: link rows where T1.Id equals T2.UserId exactly as shown in the amends (T1.Id = T2.UserId) and keep only matching pairs (inner match). 2) When the question asks for the highest reputation user's badge: rank users by T1.Reputation in descending order and keep the first 1 row. 3) When selecting badge name: output T2.name from the badges table (using the exact token T2.name as shown in the amends). 4) When handling ordering ties: break ties using the canonical key T1.Id if needed, though the amends specify only LIMIT 1 without explicit tie-breaking."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.name \nFROM badges b \nJOIN users u ON b.user_id = u.id \nWHERE u.reputation = (SELECT MAX(reputation) FROM users) \nLIMIT 1;",
            "SELECT T2.Name \nFROM users AS T1 \nINNER JOIN badges AS T2 ON T1.Id = T2.UserId \nORDER BY T1.Reputation DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM users T1 \nINNER JOIN badges T2 ON T1.Id = T2.UserId \nORDER BY T1.Reputation DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "282": {
        "db_id": "toxicology",
        "question": "What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.",
        "ground_truth": "WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label",
        "amends": [
            "Do use a CTE with `SubQuery` instead of querying `molecule_elements` directly. Do add `DISTINCT` selection of `atom_id`, `element`, `molecule_id`, and `label` instead of omitting these columns. Do join `atom AS T1` with `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of filtering a single table. Do filter on `T2.molecule_id = 'TR006'` instead of `molecule_id = 'TR006' AND element = 'Hydrogen'`. Do calculate a ratio using `CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / COUNT(atom_id)` instead of selecting a precomputed `ratio`. Do add `GROUP BY label` instead of omitting grouping. Do include `label` in the SELECT list instead of only `element` and `ratio`. The amended query now correctly calculates hydrogen ratios per molecule label rather than retrieving a static value from a denormalized table.",
            "Do use table aliases `T1` and `T2` instead of `a` and `m` for consistency. Do add explicit `INNER JOIN` instead of implicit `JOIN` for clarity. Do modify the ratio calculation to handle division by zero by adding `(CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END)` instead of simple `COUNT(atom_id)` to prevent runtime errors. Do reorder the SELECT list to place `ratio` before `label` instead of `label` before `ratio` to match the output structure. The amended query now correctly handles potential division by zero cases while maintaining the same logical behavior for non-zero counts."
        ],
        "rules": [
            "1) When answering about the ratio of Hydrogen elements in a specific molecule: use a CTE with SubQuery instead of querying molecule_elements directly. 2) When selecting from atom and molecule tables: join atom AS T1 with molecule AS T2 on T1.molecule_id = T2.molecule_id using inner match. 3) When filtering for molecule ID TR006: use T2.molecule_id = 'TR006' exactly as specified. 4) When calculating hydrogen ratio: compute CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / COUNT(atom_id) instead of selecting a precomputed ratio. 5) When grouping results: use GROUP BY label to organize by molecule label. 6) When selecting output columns: include label in the SELECT list along with the calculated ratio. 7) When counting atoms: use atom_id as the counting key for both total atoms and hydrogen atoms. 8) When handling hydrogen identification: use element = 'h' (lowercase) to identify hydrogen atoms.",
            "1) When answering about \"ratio of Hydrogen elements in molecule ID TR006\": make sure the output order: ratio, label\n2) When the question mentions \"Hydrogen elements\": \"Hydrogen\" actually means \"element = 'h'\" in schema\n3) When the question asks for a ratio \"Hydrogen elements to all elements\": compute (rows satisfying element = 'h') divided by (rows satisfying all elements), guarding division by zero by checking if denominator is zero before division\n4) When combining T1 (atom) and T2 (molecule) for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)\n5) When filtering for molecule ID TR006: use T2.molecule_id = 'TR006' with exact literal value\n6) When counting atoms: use T1.atom_id as the counting key for both numerator and denominator\n7) When handling text literals: preserve exact case and value 'h' for Hydrogen element identification"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element, ratio FROM molecule_elements WHERE molecule_id = 'TR006' AND element = 'Hydrogen';",
            "WITH SubQuery AS (\n    SELECT DISTINCT \n        a.atom_id, \n        a.element, \n        a.molecule_id, \n        m.label\n    FROM \n        atom AS a\n    JOIN \n        molecule AS m ON a.molecule_id = m.molecule_id\n    WHERE \n        m.molecule_id = 'TR006'\n)\nSELECT \n    label,\n    CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / COUNT(atom_id) AS ratio\nFROM \n    SubQuery\nGROUP BY \n    label;",
            "WITH SubQuery AS (\n    SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label\n    FROM atom AS T1\n    INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T2.molecule_id = 'TR006'\n)\nSELECT \n    CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / \n    (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio,\n    label\nFROM SubQuery\nGROUP BY label"
        ],
        "rule_sql": [
            "WITH hydrogen_ratio AS (\n  SELECT \n    T2.label,\n    CAST(COUNT(CASE WHEN T1.element = 'h' THEN T1.atom_id ELSE NULL END) AS REAL) / COUNT(T1.atom_id) AS ratio\n  FROM \n    atom AS T1\n  INNER JOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id\n  WHERE \n    T2.molecule_id = 'TR006'\n  GROUP BY \n    T2.label\n)\nSELECT \n  ratio, \n  label\nFROM \n  hydrogen_ratio"
        ],
        "amend_res": 1
    },
    "682": {
        "db_id": "codebase_community",
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "ground_truth": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "amends": [
            "Do select `T2.OwnerUserId` and `T1.DisplayName` instead of `p.id` and `u.display_name`. Do join `users AS T1` with `posts AS T2` on `T1.Id = T2.OwnerUserId` instead of joining `posts p` with `users u` on `p.owner_user_id = u.id`. Do filter on `STRFTIME('%Y', T1.CreationDate) = '2010'` instead of `strftime('%Y', p.creation_date) = '2010'`. Do order by `T2.FavoriteCount DESC` instead of `p.score DESC`. The amended query now correctly filters by user creation year and orders by favorite count to match the intended behavior.",
            "Do select `T2.OwnerUserId` instead of `T2.Id` in the SELECT list. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` while keeping the same join condition `T1.Id = T2.OwnerUserId`. The amended query now correctly retrieves the post owner's user ID rather than the post ID while maintaining the same join logic and filtering behavior for 2010 user accounts ordered by favorite count."
        ],
        "rules": [
            "1) When joining users and posts tables: link rows where T1.Id equals T2.OwnerUserId and keep only matching pairs (inner match). 2) When filtering by year 2010: use STRFTIME('%Y', T1.CreationDate) = '2010' exactly as specified. 3) When ordering by value to find the most valuable post: sort by T2.FavoriteCount in descending order. 4) When selecting output columns: return T2.OwnerUserId and T1.DisplayName in that order. 5) When limiting to the top result: keep only the first row after ordering.",
            "1) When answering about \"most valuable post in 2010\": make sure the output order: T2.OwnerUserId, T1.DisplayName 2) When combining users as T1 and posts as T2: link rows where T1.Id = T2.OwnerUserId exactly and keep only matching pairs (inner match) 3) When filtering for year 2010: use STRFTIME('%Y', T1.CreationDate) = '2010' with exact literal '2010' 4) When determining \"most valuable\" by favorite count: rank rows by T2.FavoriteCount in descending order and keep the first 1 row 5) When selecting the post owner's display name: use T1.DisplayName for the owner's display name 6) When selecting the post identifier: use T2.OwnerUserId for the post owner's user ID rather than the post ID"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.id, u.display_name \nFROM posts p \nJOIN users u ON p.owner_user_id = u.id \nWHERE strftime('%Y', p.creation_date) = '2010' \nORDER BY p.score DESC \nLIMIT 1;",
            "SELECT T2.Id, T1.DisplayName \nFROM users AS T1 \nJOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T1.CreationDate) = '2010' \nORDER BY T2.FavoriteCount DESC \nLIMIT 1;",
            "SELECT T2.OwnerUserId, T1.DisplayName \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T1.CreationDate) = '2010' \nORDER BY T2.FavoriteCount DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.OwnerUserId, T1.DisplayName\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE STRFTIME('%Y', T1.CreationDate) = '2010'\nORDER BY T2.FavoriteCount DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1004": {
        "db_id": "formula_1",
        "question": "How many wins was achieved by the oldest racer? Indicate his/her full name.",
        "ground_truth": "SELECT SUM(T1.wins),T2.forename, T2.surname FROM driverStandings AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId ORDER BY T2.dob ASC LIMIT 1",
        "amends": [
            "Do use `SUM(T1.wins)` instead of `COUNT(*) as wins` to sum actual win counts rather than counting rows. Do join `driverStandings AS T1` and `drivers AS T2` with `INNER JOIN` on `T1.driverId = T2.driverId` instead of querying a single `races` table with a subquery for maximum age. Do select `T2.forename` and `T2.surname` instead of just `racer_name` to get both name components. Do remove the `WHERE racer_age = (SELECT MAX(racer_age) FROM races)` filter and `GROUP BY racer_name` clause instead of keeping them, as the logic now focuses on driver standings rather than age-based filtering. Do add `ORDER BY T2.dob ASC LIMIT 1` instead of omitting ordering and limiting, to get the oldest driver by date of birth. The amended query now correctly retrieves win totals from driver standings joined with driver details and returns the oldest driver based on date of birth, matching the intended behavior.",
            "Do place the `SUM(T1.wins)` aggregate at the beginning of the SELECT list instead of after the driver names. Do remove the `GROUP BY T1.driverId` clause instead of keeping it since we're using an aggregate without grouping by non-aggregated columns. Do remove the alias `total_wins` from the aggregate instead of keeping it as the query only returns one row due to the LIMIT 1. The amended query now correctly returns the driver with the earliest date of birth along with their total wins without unnecessary grouping."
        ],
        "rules": [
            "1) When answering about \"how many wins was achieved by the oldest racer\": make sure to sum actual win counts using SUM(T1.wins) instead of counting rows. 2) When combining driver standings and drivers tables: link rows where T1.driverId = T2.driverId using an inner match and keep only matching pairs. 3) When the question asks for the oldest racer: order by T2.dob in ascending order and take only the first row. 4) When the question asks for the racer's full name: select both T2.forename and T2.surname to get complete name components.",
            "1) When answering about \"How many wins was achieved by the oldest racer\": make sure the output order: SUM(T1.wins) first, then T2.forename, then T2.surname. 2) When the question asks for the oldest racer: use the earliest date of birth (T2.dob) in ascending order and take only the first result. 3) When combining driverStandings as T1 and drivers as T2: link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match). 4) When computing total wins: use SUM(T1.wins) without grouping by driverId since we only need one result. 5) When returning a single result: do not use column aliases for aggregates as only one row is returned."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) as wins, racer_name FROM races WHERE racer_age = (SELECT MAX(racer_age) FROM races) GROUP BY racer_name;",
            "SELECT T2.forename, T2.surname, SUM(T1.wins) as total_wins\nFROM driverStandings AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nGROUP BY T1.driverId\nORDER BY T2.dob ASC\nLIMIT 1;",
            "SELECT SUM(T1.wins), T2.forename, T2.surname\nFROM driverStandings AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nORDER BY T2.dob ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT SUM(T1.wins), T2.forename, T2.surname\nFROM driverStandings T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nORDER BY T2.dob ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "250": {
        "db_id": "toxicology",
        "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do select `T.molecule_id` instead of `name` and `bond_count`. Do use a subquery instead of querying directly from the `molecules` table. Do join `bond AS T1` with `molecule AS T3` on `T1.molecule_id = T3.molecule_id` instead of querying a single table. Do add filters for `T3.label = '+'` and `T1.bond_type = '='` instead of `carcinogenic = 'yes'`. Do count `T1.bond_type` instead of `double_bonds`. Do group by `T3.molecule_id` instead of `name`. Do order by `COUNT(T1.bond_type)` instead of `bond_count`. The amended query now correctly identifies molecules with '+' label that have the most '=' bonds instead of counting double bonds in carcinogenic molecules."
        ],
        "rules": [
            "1) When the question asks about \"carcinogenic molecules\": \"carcinogenic\" actually means \"T3.label = '+'\" in the schema. 2) When the question asks about \"double bonds\": \"double bonds\" actually means \"T1.bond_type = '='\" in the schema. 3) When combining bond table T1 and molecule table T3: link rows where T1.molecule_id = T3.molecule_id and keep only matching pairs (inner match). 4) When counting double bonds: count T1.bond_type occurrences where T1.bond_type = '='. 5) When grouping by molecule: group by T3.molecule_id instead of name. 6) When finding the molecule with the most double bonds: rank molecules by count of T1.bond_type in descending order and keep the first 1 row. 7) When selecting output: include T3.molecule_id instead of name and the count value instead of bond_count alias."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(double_bonds) as bond_count FROM molecules WHERE carcinogenic = 'yes' GROUP BY name ORDER BY bond_count DESC LIMIT 1;",
            "SELECT T3.molecule_id\nFROM bond AS T1\nJOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id\nWHERE T3.label = '+' AND T1.bond_type = '='\nGROUP BY T3.molecule_id\nORDER BY COUNT(T1.bond_type) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T3.molecule_id, COUNT(T1.bond_type) \nFROM bond T1\nINNER JOIN molecule T3 ON T1.molecule_id = T3.molecule_id\nWHERE T3.label = '+' AND T1.bond_type = '='\nGROUP BY T3.molecule_id\nORDER BY COUNT(T1.bond_type) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "643": {
        "db_id": "codebase_community",
        "question": "What are the display names and ages of user who got the highest in views?",
        "ground_truth": "SELECT DisplayName, Age FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "amends": [
            "Do select `DisplayName` and `Age` instead of `display_name` and `age`. Do add a `WHERE` filter comparing `Views` to a subquery `SELECT MAX(Views) FROM users` instead of omitting filtering. Do remove the `ORDER BY views DESC LIMIT 1` clause instead of keeping it. The amended query now correctly identifies the user with maximum views using a subquery comparison rather than relying on ordering and limiting to one result."
        ],
        "rules": [
            "1) When the question asks for \"display names and ages\": select \"DisplayName\" and \"Age\" from table users. 2) When the question asks for users with the \"highest in views\": filter rows where \"Views\" equals the maximum value of \"Views\" from the same table. 3) When computing maximum views: calculate the maximum value of \"Views\" column from all rows in the users table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name, age FROM users ORDER BY views DESC LIMIT 1;",
            "SELECT DisplayName, Age FROM users WHERE Views = (SELECT MAX(Views) FROM users)"
        ],
        "rule_sql": [
            "SELECT DisplayName, Age FROM users WHERE Views = (SELECT MAX(Views) FROM users)"
        ],
        "amend_res": 1
    },
    "899": {
        "db_id": "formula_1",
        "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
        "ground_truth": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
        "amends": [
            "Do use `DISTINCT T1.name` with table alias instead of `circuit_name` without aliasing. Do join `circuits AS T1` with `races AS T2` on `T2.circuitID = T1.circuitId` instead of querying circuits table alone. Do filter by `STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000'` on race dates instead of a non-existent `year` column. Do add `GROUP BY T1.name` and `HAVING COUNT(T2.raceId) = 4` to count actual races hosted instead of using a static `races_hosted = 4` filter. The amended query now correctly identifies circuits that hosted exactly 4 races between 1990-2000 by joining with the races table and counting actual race occurrences."
        ],
        "rules": [
            "1) When answering about circuits hosting races: join table \"circuits\" as T1 with table \"races\" as T2 using the exact key equality T2.circuitID = T1.circuitId and keep only matching pairs (inner match). 2) When filtering by year range 1990 to 2000: use STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' on race dates instead of a non-existent year column. 3) When counting races hosted per circuit: group by T1.name and count using T2.raceId as the counting key. 4) When the question asks for circuits hosting exactly 4 races: use HAVING COUNT(T2.raceId) = 4 to filter groups. 5) When selecting circuit names: use DISTINCT T1.name with the table alias instead of circuit_name without aliasing."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT circuit_name FROM circuits WHERE races_hosted = 4 AND year BETWEEN 1990 AND 2000;",
            "SELECT DISTINCT T1.name\nFROM circuits AS T1\nJOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000'\nGROUP BY T1.name\nHAVING COUNT(T2.raceId) = 4"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000'\nGROUP BY T1.name\nHAVING COUNT(T2.raceId) = 4"
        ],
        "amend_res": 1
    },
    "453": {
        "db_id": "card_games",
        "question": "What's the unconverted mana cost of the card \"Ancestor's Chosen\"?",
        "ground_truth": "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
        "amends": [
            "Do use column name `manaCost` instead of `mana_cost` to match the actual schema. Do add `DISTINCT` to eliminate duplicate results instead of omitting it. Do use proper escaped quotes `''` in the string literal instead of incorrect single quotes for the name condition. The amended query now correctly retrieves unique mana cost values for the specified card with proper syntax and escaping."
        ],
        "rules": [
            "1) When the question asks for mana cost of a specific card: use column \"manaCost\" from table \"cards\" instead of \"mana_cost\". 2) When retrieving values for a specific card name: use exact string literal 'Ancestor''s Chosen' with proper escaped quotes. 3) When querying for card information: ensure results are distinct to eliminate duplicate entries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT mana_cost FROM cards WHERE name = 'Ancestor's Chosen';",
            "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen';"
        ],
        "rule_sql": [
            "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen';"
        ],
        "amend_res": 1
    },
    "1244": {
        "db_id": "thrombosis_prediction",
        "question": "List all patients who first came to the hospital after year 1992 with prothrombin time (PT) level that are normal.",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) > '1992' AND T2.PT < 14",
        "amends": [
            "Do select only `T1.ID` instead of all columns with `*`. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter by year using `STRFTIME('%Y', T1.\"First Date\") > '1992'` instead of `admission_year > 1992`. Do filter prothrombin time with `T2.PT < 14` instead of `prothrombin_time = 'normal'`. The amended query now correctly joins patient and laboratory data, uses proper date extraction, and applies the appropriate numerical threshold for prothrombin time values."
        ],
        "rules": [
            "1) When answering about patients with laboratory results: join \"Patient\" AS T1 with \"Laboratory\" AS T2 using T1.ID = T2.ID and keep only matching pairs (inner match). 2) When the question asks for patients who first came after year 1992: filter using STRFTIME('%Y', T1.\"First Date\") > '1992' to extract year from the date field. 3) When the question mentions \"prothrombin time (PT) level that are normal\": use T2.PT < 14 as the numerical threshold for normal values. 4) When listing patients: select only T1.ID instead of all columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM patients WHERE admission_year > 1992 AND prothrombin_time = 'normal';",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.\"First Date\") > '1992'\nAND T2.PT < 14;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.\"First Date\") > '1992'\nAND T2.PT < 14"
        ],
        "amend_res": 1
    },
    "1194": {
        "db_id": "thrombosis_prediction",
        "question": "What sex is the patient who in a medical examination was diagnosed with PSS and in a laboratory examination had a blood level of C-reactive protein de 2+, createnine 1 and LDH 123?",
        "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T3.ID = T2.ID WHERE T2.Diagnosis = 'PSS' AND T3.CRP = '2+' AND T3.CRE = 1.0 AND T3.LDH = 123",
        "amends": [
            "Do use explicit table aliases `T1.SEX` instead of bare column `sex`. Do add `INNER JOIN` on `Examination AS T2` with predicate `T1.ID = T2.ID` instead of omitting this table. Do add `INNER JOIN` on `Laboratory AS T3` with predicate `T3.ID = T2.ID` instead of omitting this table. Do reference `T2.Diagnosis` instead of bare `diagnosis`. Do use `T3.CRP = '2+'` instead of `blood_test = 'C-reactive protein 2+'` for the blood test condition. Do use `T3.CRE = 1.0` with decimal precision instead of `createnine = 1` with integer value. Do use `T3.LDH = 123` with proper table reference instead of bare `LDH = 123`. The amended query now correctly joins the necessary tables and references the appropriate columns with proper table qualifications."
        ],
        "rules": [
            "1) When answering about patient sex with specific medical conditions: make sure the output order: T1.SEX\n2) When the question mentions \"diagnosed with PSS\": \"PSS\" actually means T2.Diagnosis = 'PSS' in schema\n3) When the question mentions \"blood level of C-reactive protein de 2+\": \"C-reactive protein 2+\" actually means T3.CRP = '2+' in schema\n4) When the question mentions \"createnine 1\": \"createnine 1\" actually means T3.CRE = 1.0 with decimal precision in schema\n5) When the question mentions \"LDH 123\": \"LDH 123\" actually means T3.LDH = 123 in schema\n6) When combining T1 (patients), T2 (Examination), and T3 (Laboratory) for shared entities: link rows where T1.ID = T2.ID and T3.ID = T2.ID; keep only matching pairs (inner match)\n7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table and column names\n8) When handling text literals: do not change case, spacing, or punctuation for values like 'PSS' and '2+'\n9) When referring to table roles: do not rename or swap the aliases T1 for patients, T2 for Examination, T3 for Laboratory once set for this schema"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT sex FROM patients WHERE diagnosis = 'PSS' AND blood_test = 'C-reactive protein 2+' AND createnine = 1 AND LDH = 123;",
            "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T3.ID = T2.ID WHERE T2.Diagnosis = 'PSS' AND T3.CRP = '2+' AND T3.CRE = 1.0 AND T3.LDH = 123"
        ],
        "rule_sql": [
            "SELECT T1.SEX\nFROM Patient T1\nJOIN Examination T2 ON T1.ID = T2.ID\nJOIN Laboratory T3 ON T1.ID = T3.ID\nWHERE T2.Diagnosis = 'PSS'\nAND T3.CRP = '2+'\nAND T3.CRE = 1.0\nAND T3.LDH = 123"
        ],
        "amend_res": 1
    },
    "1012": {
        "db_id": "formula_1",
        "question": "What was the position of the circuits during Lewis Hamilton's fastest lap in a Formula_1 race?",
        "ground_truth": "SELECT T1.position FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.time ASC LIMIT 1",
        "amends": [
            "Do join `lapTimes AS T1` with `drivers AS T2` on `T1.driverId = T2.driverId` instead of querying a single `circuits` table. Do filter on `T2.forename = 'Lewis'` and `T2.surname = 'Hamilton'` instead of `driver = 'Lewis Hamilton'`. Do use `ORDER BY T1.time ASC LIMIT 1` to find the fastest lap instead of a subquery with `MIN(lap_time)`. Do select `T1.position` instead of just `position`. The amended query now correctly joins normalized tables and efficiently finds the fastest lap position using ordering and limiting instead of a correlated subquery."
        ],
        "rules": [
            "1) When the question asks about Lewis Hamilton's fastest lap: join table \"lapTimes\" as T1 with table \"drivers\" as T2 on T1.driverId = T2.driverId using an inner match. 2) When filtering for Lewis Hamilton: use T2.forename = 'Lewis' and T2.surname = 'Hamilton' as exact literal conditions. 3) When finding the fastest lap: order rows by T1.time in ascending order and keep only the first row. 4) When selecting the position: output T1.position as the result column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT position FROM circuits WHERE driver = 'Lewis Hamilton' AND lap_time = (SELECT MIN(lap_time) FROM circuits WHERE driver = 'Lewis Hamilton');",
            "SELECT T1.position \nFROM lapTimes AS T1 \nJOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' \nORDER BY T1.time ASC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.position \nFROM lapTimes T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'\nORDER BY T1.time ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "996": {
        "db_id": "formula_1",
        "question": "What is the annual average number of races held during the first 10 years of the 21st century?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 FROM races WHERE date BETWEEN '2000-01-01' AND '2010-12-31'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10` instead of `AVG(COUNT(raceId))` for calculating the average count per year. Do change the WHERE filter to `date BETWEEN '2000-01-01' AND '2010-12-31'` instead of `year BETWEEN 2000 AND 2009` to include the full date range. Do remove the `GROUP BY year` clause instead of keeping it since the aggregation is now handled differently. The amended query now correctly calculates the average number of races per year over the 2000-2010 decade using proper date filtering and casting to handle decimal division."
        ],
        "rules": [
            "1) When calculating the annual average number of races over a decade: use CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 instead of AVG(COUNT(raceId)) for proper decade averaging. 2) When filtering for the first 10 years of the 21st century: use date BETWEEN '2000-01-01' AND '2010-12-31' instead of year BETWEEN 2000 AND 2009 to include the complete decade range. 3) When computing a single average value across multiple years: remove GROUP BY year clause since the aggregation handles the calculation without per-year grouping."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(COUNT(raceId)) FROM races WHERE year BETWEEN 2000 AND 2009 GROUP BY year;",
            "SELECT CAST(SUM(CASE WHEN date BETWEEN '2000-01-01' AND '2010-12-31' THEN 1 ELSE 0 END) AS REAL) / 10 AS average_races_per_year FROM races;"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN date BETWEEN '2000-01-01' AND '2010-12-31' THEN 1 ELSE 0 END) AS REAL) / 10 AS annual_average_races FROM races;"
        ],
        "amend_res": 1
    },
    "1218": {
        "db_id": "thrombosis_prediction",
        "question": "What is the percentage of the female patient whose uric acid (UA) beyond the normal range?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN gender = 'F' AND (ua < 2.5 OR ua > 7.2) THEN 1 END)` for the numerator calculation. Do join `Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `WHERE T1.SEX = 'F'` instead of `WHERE gender = 'F'`. Do calculate the percentage using `CAST(... AS REAL) * 100 / COUNT(T1.ID)` instead of multiplying by `100.0` and dividing by a separate count. Do reference columns `T2.UA`, `T1.SEX`, and `T1.ID` instead of `ua` and `gender`. The amended query now correctly calculates the percentage of female patients with UA values above 6.5 by properly joining the Patient and Laboratory tables and using appropriate aggregation logic."
        ],
        "rules": [
            "1) When answering about percentage of female patients with UA beyond normal range: join Patient table as T1 and Laboratory table as T2 using T1.ID = T2.ID to combine patient and lab data. 2) When filtering for female patients: use T1.SEX = 'F' exactly as specified. 3) When calculating UA values beyond normal range: use T2.UA > 6.5 as the threshold condition. 4) When counting patients with abnormal UA: use SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) for the numerator. 5) When calculating the total female patient count: use COUNT(T1.ID) as the denominator. 6) When computing the percentage: use CAST(numerator AS REAL) * 100 / denominator to ensure proper decimal calculation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gender = 'F' AND (ua < 2.5 OR ua > 7.2) THEN 1 END) * 100.0 / COUNT(CASE WHEN gender = 'F' THEN 1 END)) AS percentage\nFROM patients\nWHERE gender = 'F';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID) AS percentage\nFROM \n    Patient AS T1 \nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID) AS percentage\nFROM \n    Patient AS T1\nJOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'"
        ],
        "amend_res": 1
    },
    "626": {
        "db_id": "codebase_community",
        "question": "How many votes were made in 2010?",
        "ground_truth": "SELECT COUNT(id) FROM votes WHERE STRFTIME('%Y', CreationDate) = '2010'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do filter by `STRFTIME('%Y', CreationDate) = '2010'` instead of `year = 2010` to properly extract the year from the CreationDate timestamp field rather than relying on a potentially non-existent year column. The amended query now correctly counts non-null vote IDs from the year 2010 by parsing the CreationDate field."
        ],
        "rules": [
            "1) When counting votes: count the \"id\" column instead of all columns to avoid counting NULL values. 2) When filtering by year 2010: use STRFTIME('%Y', \"CreationDate\") = '2010' to extract the year from the timestamp field rather than using a non-existent \"year\" column. 3) When answering about votes in 2010: make sure the output order: count of vote \"id\" values from records where the year portion of \"CreationDate\" equals '2010'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE year = 2010;",
            "SELECT COUNT(Id) FROM votes WHERE STRFTIME('%Y', CreationDate) = '2010';"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM votes WHERE STRFTIME('%Y', CreationDate) = '2010';"
        ],
        "amend_res": 1
    },
    "131": {
        "db_id": "financial",
        "question": "Which district has highest active loan?",
        "ground_truth": "SELECT T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.status IN ('C', 'D') GROUP BY T2.A3 ORDER BY SUM(T3.amount) DESC LIMIT 1",
        "amends": [
            "Do select `T2.A3` instead of `district_id, COUNT(*) as active_loans`. Do join `account AS T1` and `district AS T2` with `INNER JOIN` on `T1.district_id = T2.district_id` instead of missing these tables. Do add `INNER JOIN loan AS T3` on `T1.account_id = T3.account_id` instead of omitting the loan table. Do change the WHERE filter to `T3.status IN ('C', 'D')` instead of `status = 'active'`. Do change the GROUP BY to `T2.A3` instead of `district_id`. Do change the ORDER BY to `SUM(T3.amount) DESC` instead of `active_loans DESC`. The amended query now correctly identifies districts with the highest total loan amounts for completed or defaulted loans instead of counting active loans by district."
        ],
        "rules": [
            "1) When answering about \"which district has highest active loan\": make sure the output order: T2.A3. 2) When the question mentions \"district\": \"district\" actually means \"T2.A3\" in schema. 3) When combining account (T1) and district (T2) for shared entities: link rows where T1.district_id = T2.district_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining account (T1) and loan (T3) for shared entities: link rows where T1.account_id = T3.account_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When filtering loan status: use T3.status IN ('C', 'D') instead of 'active' as shown in the amends. 6) When grouping by district: use T2.A3 as the grouping key instead of district_id. 7) When the question mentions \"highest\": rank rows by SUM(T3.amount) in descending order and keep the first 1 row. 8) When computing the highest loan amount: use SUM(T3.amount) instead of counting active loans."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district_id, COUNT(*) as active_loans FROM loans WHERE status = 'active' GROUP BY district_id ORDER BY active_loans DESC LIMIT 1;",
            "SELECT T2.A3\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.status IN ('C', 'D')\nGROUP BY T2.A3\nORDER BY SUM(T3.amount) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.A3\nFROM account T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nINNER JOIN loan T3 ON T1.account_id = T3.account_id\nWHERE T3.status IN ('C', 'D')\nGROUP BY T2.A3\nORDER BY SUM(T3.amount) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "706": {
        "db_id": "codebase_community",
        "question": "Give the texts commented on the post about linear regression.",
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title LIKE '%linear regression%'",
        "amends": [
            "Do use `INNER JOIN` on `T1.PostId = T2.Id` instead of a subquery with equality comparison. Do change the filter to `LIKE '%linear regression%'` instead of exact match `= 'linear regression'`. Do add table aliases `T1` and `T2` instead of omitting them. Do reference `T1.Text` with alias qualification instead of bare `text`. The amended query now correctly handles partial title matches and uses proper join syntax instead of a correlated subquery."
        ],
        "rules": [
            "1) When the question asks for texts commented on a post about \"linear regression\": use a partial match condition with LIKE '%linear regression%' instead of exact equality match. 2) When combining comments and posts tables: link rows using INNER JOIN where T1.PostId = T2.Id to find matching pairs. 3) When selecting the text column from comments: reference it as T1.Text with proper table alias qualification. 4) When filtering post titles: use the pattern '%linear regression%' to match titles containing the phrase \"linear regression\" anywhere in the text."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT text FROM comments WHERE post_id = (SELECT id FROM posts WHERE title = 'linear regression')",
            "SELECT T1.Text \nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Title LIKE '%linear regression%'"
        ],
        "rule_sql": [
            "SELECT c.Text \nFROM comments c\nINNER JOIN posts p ON c.PostId = p.Id\nWHERE p.Title LIKE '%linear regression%'"
        ],
        "amend_res": 1
    },
    "650": {
        "db_id": "codebase_community",
        "question": "Describe the last accessed date and location of the users who received the outliers badge.",
        "ground_truth": "SELECT T1.LastAccessDate, T1.Location FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'outliers'",
        "amends": [
            "Do use `T1.LastAccessDate` and `T1.Location` instead of `u.last_access_date` and `u.location` for column aliases. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do join on `T1.Id = T2.UserId` instead of `u.user_id = b.user_id` using the correct column names. Do filter on `T2.Name = 'outliers'` instead of `b.badge_name = 'outliers'` to match the actual column name. Do remove `ORDER BY u.last_access_date DESC LIMIT 1` instead of keeping it since the right query doesn't require ordering or limiting. The amended query now correctly retrieves user details for those with the 'outliers' badge without unnecessary result set restrictions."
        ],
        "rules": [
            "1) When the question asks about \"last accessed date\" and \"location\" of users: use columns \"T1.LastAccessDate\" and \"T1.Location\" exactly as specified in the schema. 2) When combining user and badge information: perform an inner join where \"T1.Id = T2.UserId\" to match users with their badges. 3) When filtering for users who received the 'outliers' badge: use the exact literal 'outliers' and filter on \"T2.Name = 'outliers'\". 4) When the question describes user details without ordering or limiting: do not apply any ORDER BY or LIMIT clauses to the results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.last_access_date, u.location FROM users u JOIN badges b ON u.user_id = b.user_id WHERE b.badge_name = 'outliers' ORDER BY u.last_access_date DESC LIMIT 1;",
            "SELECT T1.LastAccessDate, T1.Location\nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T2.Name = 'outliers'"
        ],
        "rule_sql": [
            "SELECT T1.LastAccessDate, T1.Location\nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T2.Name = 'outliers'"
        ],
        "amend_res": 1
    },
    "735": {
        "db_id": "superhero",
        "question": "How many superheroes with blonde hair are there?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id WHERE T2.colour = 'Blond'",
        "amends": [
            "Do reference the `superhero` table instead of `superheroes`, and join with `colour` table via `hair_colour_id` instead of directly filtering on `hair_color`. Do use `COUNT(T1.id)` instead of `COUNT(*)` for more precise counting. Do filter on `T2.colour = 'Blond'` instead of `hair_color = 'blonde'` to properly utilize the normalized color reference table. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly counts superheroes with blond hair by joining through the normalized color reference table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting superheroes: use COUNT(T1.id) instead of COUNT(*) for precise counting. 2) When the question mentions \"blonde hair\": this corresponds to T2.colour = 'Blond' in the schema (note exact capitalization). 3) When combining superhero and colour tables: link rows where T1.hair_colour_id = T2.id (inner match). 4) When answering about superhero counts: reference the \"superhero\" table (not \"superheroes\"). 5) When filtering by hair color: use the normalized color reference table through T2.colour instead of direct filtering on hair_color."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE hair_color = 'blonde';",
            "SELECT COUNT(T1.id) \nFROM superhero T1\nJOIN colour T2 ON T1.hair_colour_id = T2.id\nWHERE T2.colour = 'Blond'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero T1\nINNER JOIN colour T2 ON T1.hair_colour_id = T2.id\nWHERE T2.colour = 'Blond'"
        ],
        "amend_res": 1
    },
    "564": {
        "db_id": "codebase_community",
        "question": "Give the only one comment text of the post with parent id 107829.",
        "ground_truth": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "amends": [
            "Do select `T2.Text` from the `comments` table instead of `comment_text` from the `comments` table. Do join `posts AS T1` with `comments AS T2` using `INNER JOIN` on `T1.Id = T2.PostId` instead of querying only the `comments` table without any joins. Do add filter conditions `T1.ParentId = 107829` and `T1.CommentCount = 1` instead of filtering only by `parent_id = 107829`. Do remove the `LIMIT 1` clause instead of keeping it, as the `CommentCount = 1` condition ensures only one result. The amended query now correctly retrieves comment text from posts with the specified parent ID and exactly one comment, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"comment text of the post with parent id 107829\": make sure the output order: T2.Text\n2) When the question mentions \"comment text\": \"comment text\" actually means \"Text in schema\" from table comments as T2\n3) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.PostId exactly as shown in the amends; keep only matching pairs (inner match)\n4) When filtering for posts with parent id 107829: use exact literal value 107829 for T1.ParentId\n5) When ensuring only one comment exists: use exact condition T1.CommentCount = 1 to filter for posts with exactly one comment\n6) When the question asks for \"the only one comment text\": do not use LIMIT 1 clause as the CommentCount = 1 condition ensures only one result"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT comment_text FROM comments WHERE parent_id = 107829 LIMIT 1;",
            "SELECT T2.Text \nFROM posts AS T1 \nINNER JOIN comments AS T2 ON T1.Id = T2.PostId \nWHERE T1.ParentId = 107829 AND T1.CommentCount = 1"
        ],
        "rule_sql": [
            "SELECT T2.Text \nFROM posts AS T1 \nINNER JOIN comments AS T2 ON T1.Id = T2.PostId \nWHERE T1.ParentId = 107829 \nAND T1.CommentCount = 1"
        ],
        "amend_res": 1
    },
    "606": {
        "db_id": "codebase_community",
        "question": "List out the name of badges that users obtained on 7/19/2010 7:39:08 PM.",
        "ground_truth": "SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0'",
        "amends": [
            "Do use column `Name` instead of `badge_name` in the SELECT list. Do use column `Date` instead of `obtained_date` in the WHERE filter. Do use the ISO 8601 formatted timestamp '2010-07-19 19:39:08.0' instead of the localized format '7/19/2010 7:39:08 PM' for proper date comparison. The amended query now correctly matches the RIGHT_SQL's behavior with proper column references and standardized timestamp formatting."
        ],
        "rules": [
            "1) When the question asks for badge names: use the exact column \"Name\" from the badges table in the SELECT list. 2) When filtering by date obtained: use the exact column \"Date\" from the badges table in the WHERE condition. 3) When comparing against the timestamp '7/19/2010 7:39:08 PM': convert it to the ISO 8601 format '2010-07-19 19:39:08.0' for proper date comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT badge_name FROM badges WHERE obtained_date = '7/19/2010 7:39:08 PM';",
            "SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0';"
        ],
        "rule_sql": [
            "SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0';"
        ],
        "amend_res": 1
    },
    "1347": {
        "db_id": "student_club",
        "question": "Tell the hometown county for \"Adela O'Gallagher\".",
        "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'",
        "amends": [
            "Do select `T2.county` from the joined table instead of `county` directly from the source table. Do use `INNER JOIN` between `member AS T1` and `zip_code AS T2` on `T1.zip = T2.zip_code` instead of querying a single table. Do filter with `T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'` instead of a single `name` column filter. Do properly escape the apostrophe in the last name with double quotes instead of single quotes. The amended query now correctly joins member and zip code tables to retrieve the county based on first and last name instead of assuming county is directly available in a people table."
        ],
        "rules": [
            "1) When the question asks for hometown county for a person: join member table as T1 with zip_code table as T2 using T1.zip = T2.zip_code to get the county information. 2) When filtering for a person by name: use separate first_name and last_name columns with exact literals 'Adela' and 'O''Gallagher' instead of a single name column. 3) When retrieving county information: select T2.county from the joined zip_code table rather than from the member table directly. 4) When handling apostrophes in string literals: properly escape them with double quotes as shown in O''Gallagher."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT county FROM people WHERE name = \"Adela O'Gallagher\";",
            "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'"
        ],
        "rule_sql": [
            "SELECT T2.county FROM member AS T1 JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'"
        ],
        "amend_res": 1
    },
    "1334": {
        "db_id": "student_club",
        "question": "List the full name of the Student_Club members that grew up in Illinois state.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'",
        "amends": [
            "Do reference columns with table aliases `T1.first_name` and `T1.last_name` instead of unqualified column names. Do add `INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code` instead of querying only the Student_Club table. Do filter on `T2.state = 'Illinois'` instead of filtering on a non-existent state column in the Student_Club table. Do use table alias `member AS T1` instead of the original table name Student_Club. The amended query now correctly joins member and zip_code tables to filter by state and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"Student_Club members that grew up in Illinois state\": make sure the output order: T1.first_name, T1.last_name. 2) When the question mentions \"Student_Club members\": \"Student_Club\" actually means \"member table as T1\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.zip = T2.zip_code exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering by state: use T2.state = 'Illinois' exactly as specified, preserving the exact case and spelling of 'Illinois'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM Student_Club WHERE state = 'Illinois';",
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T2.state = 'Illinois'"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T2.state = 'Illinois'\nORDER BY T1.first_name, T1.last_name"
        ],
        "amend_res": 1
    },
    "403": {
        "db_id": "card_games",
        "question": "Calculate the percentage of cards in Spanish. List them by name.",
        "ground_truth": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
        "amends": [
            "Do use `foreign_data` table instead of `cards` table. Do calculate percentage using `SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100 / COUNT(*)` instead of `COUNT(*) * 100 / (SELECT COUNT(*) FROM cards)`. Do add `CAST(... AS REAL)` for proper division instead of integer division. Do move the percentage calculation to a scalar subquery in the SELECT list instead of using a correlated subquery in the expression. Do remove `GROUP BY name` and instead include `name` directly in the SELECT list. Do keep the `WHERE language = 'Spanish'` filter but apply it to the main query instead of using it in a conditional aggregate. The amended query now correctly calculates the percentage of Spanish records while preserving individual name values and matches the RIGHT_SQL's behavior.",
            "Do place the subquery calculation in the SELECT list before `name` instead of after it. Do calculate the percentage as `SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100 / COUNT(*)` instead of `SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)` by removing the decimal point. Do cast only the SUM result as REAL instead of casting the entire percentage expression. The amended query now correctly calculates the percentage of Spanish records while maintaining the same filtering logic."
        ],
        "rules": [
            "1) When answering about percentage of cards in Spanish: use the \"foreign_data\" table instead of the \"cards\" table. 2) When calculating percentage: use SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100 / COUNT(*) instead of COUNT(*) * 100 / subquery. 3) When performing division: cast the result as REAL to avoid integer division. 4) When including name in results: place \"name\" directly in the SELECT list without GROUP BY. 5) When filtering for Spanish language: apply WHERE language = 'Spanish' to the main query instead of using conditional aggregates.",
            "1) When calculating percentages for a specific language condition: compute SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100 / COUNT(*) without decimal points in the multiplier. 2) When casting percentage results: cast only the SUM result as REAL instead of the entire percentage expression. 3) When ordering output columns: place the percentage calculation before the name column in the SELECT list. 4) When filtering for Spanish language records: use the exact literal 'Spanish' with proper case and spelling."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, (COUNT(*) * 100 / (SELECT COUNT(*) FROM cards)) AS percentage FROM cards WHERE language = 'Spanish' GROUP BY name;",
            "SELECT name, \n       (SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS REAL) \n        FROM foreign_data) AS percentage\nFROM foreign_data \nWHERE language = 'Spanish'",
            "SELECT \n    (SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data) AS percentage,\n    name \nFROM foreign_data \nWHERE language = 'Spanish'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS percentage,\n    name\nFROM \n    foreign_data\nWHERE \n    language = 'Spanish'\nGROUP BY \n    name\nORDER BY \n    percentage DESC, name;"
        ],
        "amend_res": 1
    },
    "1164": {
        "db_id": "thrombosis_prediction",
        "question": "How many of the patients with the most serious thrombosis cases examined in 1997 are women?",
        "ground_truth": "SELECT  COUNT(*) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND STRFTIME('%Y', T2.`Examination Date`) = '1997' AND T2.Thrombosis = 1",
        "amends": [
            "Do use `INNER JOIN` on `T1.ID = T2.ID` instead of `JOIN` on `p.patient_id = e.patient_id`. Do reference `T1.SEX = 'F'` instead of `p.gender = 'Female'`. Do filter by `STRFTIME('%Y', T2.\"Examination Date\") = '1997'` instead of `e.year = 1997`. Do use `T2.Thrombosis = 1` instead of `e.thrombosis_severity = 'Most Serious'`. Do remove `GROUP BY p.gender` instead of keeping it. The amended query now correctly matches the intended behavior by using proper table aliases, date extraction, and boolean flag comparison while eliminating unnecessary grouping."
        ],
        "rules": [
            "1) When combining patients (T1) and examinations (T2) tables: link rows where T1.ID = T2.ID using inner join and keep only matching pairs. 2) When filtering by year 1997: extract year from T2.\"Examination Date\" using STRFTIME('%Y', T2.\"Examination Date\") = '1997'. 3) When identifying female patients: use T1.SEX = 'F' instead of 'Female'. 4) When identifying most serious thrombosis cases: use T2.Thrombosis = 1 instead of text values. 5) When counting patients: count all rows without grouping by gender. 6) When the question asks for count of patients with specific conditions: compute the total number of rows satisfying all specified filters without grouping."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN examinations e ON p.patient_id = e.patient_id\nWHERE e.year = 1997 \nAND p.gender = 'Female'\nAND e.thrombosis_severity = 'Most Serious'\nGROUP BY p.gender;",
            "SELECT COUNT(*) \nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'\nAND STRFTIME('%Y', T2.\"Examination Date\") = '1997'\nAND T2.Thrombosis = 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T2.\"Examination Date\") = '1997'\nAND T2.Thrombosis = 1\nAND T1.SEX = 'F'"
        ],
        "amend_res": 1
    },
    "873": {
        "db_id": "formula_1",
        "question": "What is the actual finish time for Bruce McLaren in the race No.743?",
        "ground_truth": "SELECT T2.time FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 743 AND T1.forename = 'Bruce' AND T1.surname = 'McLaren'",
        "amends": [
            "Do select `T2.time` from the `results` table instead of `finish_time` from the `races` table. Do join `drivers AS T1` with `results AS T2` using `INNER JOIN` on `T2.driverId = T1.driverId` instead of querying only the `races` table. Do filter by `T2.raceId = 743` instead of `race_id = 743`. Do use separate forename and surname conditions `T1.forename = 'Bruce' AND T1.surname = 'McLaren'` instead of a single `driver_name = 'Bruce McLaren'` filter. The amended query now correctly retrieves race results by joining driver information with race results and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about actual finish time for a driver in a specific race: select T2.time from the results table instead of finish_time from races table. 2) When combining driver and result information: join drivers AS T1 with results AS T2 using inner join where T2.driverId = T1.driverId. 3) When filtering by race number 743: use T2.raceId = 743 instead of race_id = 743. 4) When filtering for driver Bruce McLaren: use separate conditions T1.forename = 'Bruce' AND T1.surname = 'McLaren' instead of a single driver_name filter."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT finish_time FROM races WHERE driver_name = 'Bruce McLaren' AND race_id = 743;",
            "SELECT T2.time \nFROM results AS T2\nINNER JOIN drivers AS T1 ON T2.driverId = T1.driverId\nWHERE T2.raceId = 743 \nAND T1.forename = 'Bruce' \nAND T1.surname = 'McLaren'"
        ],
        "rule_sql": [
            "SELECT T2.time \nFROM drivers AS T1 \nINNER JOIN results AS T2 ON T2.driverId = T1.driverId \nWHERE T2.raceId = 743 \nAND T1.forename = 'Bruce' \nAND T1.surname = 'McLaren'"
        ],
        "amend_res": 1
    },
    "1001": {
        "db_id": "formula_1",
        "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
        "ground_truth": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
        "amends": [
            "Do select `T2.forename` and `T2.surname` instead of `racer_name`. Do join `qualifying AS T1` and `drivers AS T2` on `T1.driverId = T2.driverId` instead of querying only `races`. Do add an additional `INNER JOIN` with `races AS T3` on `T1.raceid = T3.raceid` instead of missing these table relationships. Do filter with `q3 IS NOT NULL` instead of omitting this qualification check. Do use `T3.year = 2008` instead of `year = 2008`. Do replace direct `circuit` filter with a subquery `T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')` instead of hardcoding the circuit name. Do add `ORDER BY` with complex time conversion logic using `CAST`, `SUBSTR`, and `INSTR` functions to sort by qualifying time instead of ordering by position. Do add `LIMIT 1` instead of omitting row limitation. The amended query now correctly identifies the fastest qualifier rather than race winners and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about racer names: select both T2.forename and T2.surname instead of a single racer_name field. 2) When the question involves qualifying races: join qualifying AS T1 and drivers AS T2 on T1.driverId = T2.driverId instead of querying only races. 3) When combining qualifying and race information: add an INNER JOIN with races AS T3 on T1.raceid = T3.raceid to access race details. 4) When filtering for valid qualifying results: include q3 IS NOT NULL to ensure the racer completed the third qualifying session. 5) When filtering by year: use T3.year = 2008 instead of a generic year filter. 6) When filtering by circuit name 'Marina Bay Street Circuit': use T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit') instead of direct circuit name matching. 7) When ranking qualifiers by position: use complex time conversion logic with CAST, SUBSTR, and INSTR functions to sort by qualifying time instead of position number. 8) When selecting the top-ranked qualifier: add LIMIT 1 to return only the fastest racer."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT racer_name FROM races WHERE position = 1 AND race_number = 3 AND circuit = 'Marina Bay Street Circuit' AND year = 2008",
            "SELECT T2.forename, T2.surname\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T1.raceId = T3.raceId\nWHERE T3.year = 2008\nAND T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')\nAND T1.q3 IS NOT NULL\nORDER BY \n    CAST(SUBSTR(T1.q3, 1, INSTR(T1.q3, ':') - 1) AS INTEGER) * 60000 +\n    CAST(SUBSTR(T1.q3, INSTR(T1.q3, ':') + 1, INSTR(T1.q3, '.') - INSTR(T1.q3, ':') - 1) AS INTEGER) * 1000 +\n    CAST(SUBSTR(T1.q3, INSTR(T1.q3, '.') + 1) AS INTEGER)\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.forename, T2.surname\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T1.raceId = T3.raceId\nWHERE T3.year = 2008\nAND T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')\nAND T1.q3 IS NOT NULL\nORDER BY CAST(SUBSTR(T1.q3, 1, INSTR(T1.q3, '.') - 1) AS INTEGER) * 1000 + \n         CAST(SUBSTR(T1.q3, INSTR(T1.q3, '.') + 1) AS INTEGER)\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1289": {
        "db_id": "thrombosis_prediction",
        "question": "For the patients who are diagnosed with SJS, how many of them have a normal level of total protein?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SJS' AND T2.TP > 6.0 AND T2.TP < 8.5",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific column instead of `COUNT(*)` from all rows. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T1.Diagnosis = 'SJS'` instead of `diagnosis = 'SJS'` and use numeric range checks `T2.TP > 6.0 AND T2.TP < 8.5` for protein values instead of string comparison `total_protein = 'normal'`. The amended query now correctly counts patients with SJS diagnosis who have total protein levels within the normal clinical range of 6.0 to 8.5, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about patients diagnosed with SJS: join Patient table as T1 with Laboratory table as T2 using inner join where T1.ID = T2.ID. 2) When filtering for SJS diagnosis: use exact condition T1.Diagnosis = 'SJS' with exact literal 'SJS'. 3) When checking for normal total protein levels: use numeric range checks T2.TP > 6.0 AND T2.TP < 8.5 instead of string comparison. 4) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers. 5) When handling identifier delimiters: do not replace double quotes with backticks or unquoted forms for any identifiers."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE diagnosis = 'SJS' AND total_protein = 'normal';",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SJS' \nAND T2.TP > 6.0 AND T2.TP < 8.5"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SJS' \nAND T2.TP > 6.0 AND T2.TP < 8.5"
        ],
        "amend_res": 1
    },
    "1512": {
        "db_id": "debit_card_specializing",
        "question": "Which customer paid the most in 2012/8/25?",
        "ground_truth": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "amends": [
            "Do select `CustomerID` instead of `customer_id, SUM(amount) as total_paid`. Do use table `transactions_1k` instead of `payments`. Do filter on `Date` instead of `payment_date`. Do group by `CustomerID` instead of `customer_id`. Do order by `SUM(Price)` descending instead of `total_paid` descending. Do remove the explicit column alias `total_paid` instead of keeping it. The amended query now correctly identifies customers with the highest total transaction value on the specified date.",
            "Do use date format `'2012-08-25'` instead of `'2012/8/25'` to ensure proper date parsing and comparison. The amended query now correctly filters transactions for August 25, 2012, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which customer paid the most\": make sure the output order: CustomerID, SUM(Price) 2) When the question mentions \"customer\": \"customer\" actually means \"CustomerID in schema\" 3) When the question mentions \"paid the most\": rank rows by SUM(Price) in descending direction and keep the first 1 row 4) When the question asks about date \"2012/8/25\": filter rows where Date equals '2012-08-25' exactly 5) When grouping by customer: organize results by CustomerID and compute SUM(Price) per group 6) When using table transactions_1k: do not use payments table 7) When selecting columns: use CustomerID instead of customer_id 8) When ordering results: order by SUM(Price) descending instead of any aliased column",
            "1) When filtering by date '2012/8/25' from the question: use the exact date format '2012-08-25' instead of '2012/8/25' to ensure proper date parsing and comparison."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, SUM(amount) as total_paid \nFROM payments \nWHERE payment_date = '2012-08-25' \nGROUP BY customer_id \nORDER BY total_paid DESC \nLIMIT 1;",
            "SELECT CustomerID\nFROM transactions_1k\nWHERE Date = '2012/8/25'\nGROUP BY CustomerID\nORDER BY SUM(Price) DESC\nLIMIT 1;",
            "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT CustomerID, SUM(Price) \nFROM transactions_1k \nWHERE Date = '2012-08-25' \nGROUP BY CustomerID \nORDER BY SUM(Price) DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "293": {
        "db_id": "toxicology",
        "question": "How many atoms belong to the molecule labeled with carcinogenic compounds?",
        "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [
            "Do use explicit column `T1.atom_id` in `COUNT` instead of `COUNT(*)` to count specific non-null values. Do reference table `atom AS T1` instead of `atoms` and join with `molecule AS T2` instead of using a subquery. Do use `INNER JOIN` with `ON T1.molecule_id = T2.molecule_id` instead of the `IN` subquery predicate. Do filter with `WHERE T2.label = '+'` instead of `WHERE label = 'carcinogenic'` to match the correct label value. The amended query now correctly joins tables and filters for the specified label condition."
        ],
        "rules": [
            "1) When counting atoms: use COUNT(T1.atom_id) instead of COUNT(*) to count specific non-null values. 2) When joining atom and molecule tables: use INNER JOIN with ON T1.molecule_id = T2.molecule_id to link matching rows. 3) When filtering for carcinogenic compounds: use WHERE T2.label = '+' instead of 'carcinogenic' to match the correct label value. 4) When referencing tables: use atom AS T1 and molecule AS T2 as the canonical aliases."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM atoms WHERE molecule_id IN (SELECT molecule_id FROM molecules WHERE label = 'carcinogenic');",
            "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+';"
        ],
        "amend_res": 1
    },
    "324": {
        "db_id": "toxicology",
        "question": "Find the percentage of atoms with single bond.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond t",
        "amends": [
            "Do use `COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END)` instead of `COUNT(*)` to count only specific bond types. Do reference table `bond` with alias `T` instead of `atoms` to use the correct data source. Do filter with `CASE WHEN` logic instead of `WHERE bond_type = 'single'` to properly handle conditional counting within aggregates. Do cast the result to `REAL` instead of using `100.0` for explicit type conversion. Do calculate percentage using `COUNT(T.bond_id)` as denominator instead of a subquery `(SELECT COUNT(*) FROM atoms)` to use the same table context. Do remove the unnecessary alias `percentage` instead of keeping it. The amended query now correctly calculates the percentage of bonds with type '-' relative to all bonds in the bond table."
        ],
        "rules": [
            "1) When answering about percentage of atoms with single bond: use table \"bond\" with alias T instead of \"atoms\" to access the correct data source. 2) When counting bonds with specific type: use COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END) to count only bonds where bond_type equals '-' exactly. 3) When calculating percentage: use COUNT(T.bond_id) as the denominator to count all bonds in the same table context. 4) When handling type conversion: cast the result to REAL instead of using 100.0 for explicit type conversion. 5) When producing output: remove unnecessary column aliases and return only the calculated percentage value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM atoms)) AS percentage FROM atoms WHERE bond_type = 'single';",
            "SELECT CAST(COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END) AS REAL) / COUNT(T.bond_id) * 100 FROM bond T;"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END) AS REAL) / COUNT(T.bond_id) * 100 FROM bond T"
        ],
        "amend_res": 1
    },
    "1128": {
        "db_id": "european_football_2",
        "question": "Which country's players have the heaviest average weights?",
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id GROUP BY t1.name ORDER BY AVG(t3.weight) DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` instead of `country` and `avg_weight`. Do use `FROM Country AS t1` instead of `FROM players`. Do add `INNER JOIN Match AS t2 ON t1.id = t2.country_id` and `INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id` instead of a single table. Do group by `t1.name` instead of `country`. Do order by `AVG(t3.weight)` instead of the alias `avg_weight`. Do remove the explicit alias `avg_weight` instead of keeping it. The amended query now correctly joins multiple tables to calculate average player weight per country and returns the country name with the highest average weight, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"country's players have the heaviest average weights\": make sure the output order: t1.name, AVG(t3.weight) 2) When the question mentions \"country\": \"country\" actually means \"t1.name in schema\" 3) When the question mentions \"heaviest average weights\": rank rows by AVG(t3.weight) in descending direction and keep the first 1 row 4) When combining Country as t1 and Match as t2 for shared entities: link rows where t1.id = t2.country_id exactly as shown; keep only matching pairs (inner match) 5) When combining Match as t2 and Player as t3 for shared entities: link rows where t2.home_player_1 = t3.player_api_id exactly as shown; keep only matching pairs (inner match) 6) When the question asks for \"average weights per country\": organize results by t1.name and compute AVG(t3.weight) per group 7) When producing output: do not include explicit aliases like avg_weight in the final result columns"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, AVG(weight) as avg_weight FROM players GROUP BY country ORDER BY avg_weight DESC LIMIT 1;",
            "SELECT t1.name\nFROM Country AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.country_id\nINNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id\nGROUP BY t1.name\nORDER BY AVG(t3.weight) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.name, AVG(t3.weight)\nFROM Country AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.country_id\nINNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id\nGROUP BY t1.name\nORDER BY AVG(t3.weight) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "435": {
        "db_id": "card_games",
        "question": "How many card border with black color ? List out the card id.",
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id",
        "amends": [
            "Do select `id` instead of `card_id` as the column to return from the cards table. Do use the correct column name `borderColor` instead of `border_color` in the WHERE filter condition. Do add a `GROUP BY id` clause instead of omitting it, which ensures proper aggregation when needed. The amended query now correctly selects the id column using the proper borderColor filter and includes appropriate grouping to match the intended behavior."
        ],
        "rules": [
            "1) When selecting card identifiers from the cards table: use the exact column name \"id\" instead of \"card_id\". 2) When filtering cards by border color: use the exact column name \"borderColor\" instead of \"border_color\". 3) When the question asks for card border with black color: use the exact literal value 'black' for the borderColor filter condition. 4) When grouping results from the cards table: include a grouping by the \"id\" column to ensure proper aggregation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_id FROM cards WHERE border_color = 'black';",
            "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id;"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id"
        ],
        "amend_res": 1
    },
    "406": {
        "db_id": "card_games",
        "question": "Lists by ID all Creature-type cards with legal status.",
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
        "amends": [
            "Do add `INNER JOIN rulings` on `T1.uuid = T2.uuid` and `INNER JOIN legalities` on `T1.uuid = T3.uuid` instead of querying only the `cards` table. Do change the column reference from `card_id` to `T1.id` instead of using the original column name. Do modify the filter condition from `legal_status = 'legal'` to `T3.status = 'Legal'` instead of checking the wrong table and column. Do adjust the type filter from `type = 'Creature'` to `T1.types = 'Creature'` instead of using the incorrect column name. The amended query now correctly joins related tables and uses proper column references to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"Creature-type cards with legal status\": make sure the output order: T1.id 2) When the question mentions \"Creature-type cards\": \"Creature\" actually means \"T1.types = 'Creature'\" in schema 3) When the question mentions \"legal status\": \"legal\" actually means \"T3.status = 'Legal'\" in schema 4) When combining T1 (cards) and T2 (rulings) for shared entities: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match) 5) When combining T1 (cards) and T3 (legalities) for shared entities: link rows where T1.uuid = T3.uuid and keep only matching pairs (inner match) 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 7) When handling text literals: do not change case, spacing, or punctuation (e.g., use 'Legal' not 'legal')"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT card_id FROM cards WHERE type = 'Creature' AND legal_status = 'legal';",
            "SELECT T1.id\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nINNER JOIN legalities T3 ON T1.uuid = T3.uuid\nWHERE T1.types = 'Creature' AND T3.status = 'Legal'"
        ],
        "rule_sql": [
            "SELECT T1.id\nFROM cards T1\nINNER JOIN legalities T3 ON T1.uuid = T3.uuid\nWHERE T1.types = 'Creature' AND T3.status = 'Legal'\nORDER BY T1.id"
        ],
        "amend_res": 1
    },
    "1301": {
        "db_id": "thrombosis_prediction",
        "question": "Please list the IDs of the patients with no thrombosis and an abnormal level of creatinine phosphokinase.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 0 AND T1.CPK < 250",
        "amends": [
            "Do select `DISTINCT T1.ID` instead of `patient_id` without distinct. Do use `Laboratory AS T1` and `Examination AS T2` tables instead of a single `patients` table. Do perform an `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter with `T2.Thrombosis = 0` instead of `thrombosis = 'no'` using numeric comparison rather than string. Do filter with `T1.CPK < 250` instead of `creatinine_phosphokinase = 'normal'` using a numeric threshold instead of string value. The amended query now correctly joins laboratory and examination data while using proper numeric comparisons for medical thresholds."
        ],
        "rules": [
            "1) When answering about \"patients with no thrombosis and abnormal creatinine phosphokinase\": make sure the output order: T1.ID 2) When the question mentions \"patient IDs\": use \"T1.ID\" from the Laboratory table as the exact identifier 3) When combining Laboratory (T1) and Examination (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match) 4) When the question mentions \"no thrombosis\": use T2.Thrombosis = 0 with numeric comparison instead of string 'no' 5) When the question mentions \"abnormal level of creatinine phosphokinase\": use T1.CPK < 250 with numeric threshold instead of string 'normal' 6) When selecting patient IDs: use DISTINCT T1.ID to avoid duplicate patient records"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE thrombosis = 'no' AND creatinine_phosphokinase = 'normal';",
            "SELECT DISTINCT T1.ID\nFROM Laboratory AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T2.Thrombosis = 0 AND T1.CPK < 250"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Laboratory T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.Thrombosis = 0 AND T1.CPK < 250"
        ],
        "amend_res": 1
    },
    "892": {
        "db_id": "formula_1",
        "question": "State the driver with the most points scored. Find his full name with that points.",
        "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
        "amends": [
            "Do add tables `races AS T1`, `driverStandings AS T2`, and `drivers AS T3` instead of querying only `drivers`. Do use `INNER JOIN` on `T2.raceId = T1.raceId` and `T3.driverId = T2.driverId` instead of no joins. Do select `T3.forename` and `T3.surname` instead of `first_name` and `last_name`. Do select `T2.points` from `driverStandings` instead of `points` from `drivers`. Do order by `T2.points DESC` instead of `points DESC`. The amended query now correctly retrieves the driver with the highest points from the driver standings table joined with races and drivers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"driver with the most points scored\": make sure the output order: T3.forename, T3.surname, T2.points\n2) When the question mentions \"points\": \"points\" actually means \"T2.points in driverStandings table\" not points from drivers table\n3) When the question mentions \"full name\": \"full name\" actually means \"T3.forename and T3.surname from drivers table\"\n4) When combining tables races, driverStandings, and drivers: link rows where T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match)\n5) When the question asks for \"driver with the most points\": rank rows by T2.points in descending order and keep the first 1 row\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for any table or column names"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, points FROM drivers ORDER BY points DESC LIMIT 1;",
            "SELECT T3.forename, T3.surname, T2.points \nFROM races AS T1 \nINNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId \nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId \nORDER BY T2.points DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.forename, T3.surname, T2.points\nFROM races T1\nINNER JOIN driverStandings T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers T3 ON T3.driverId = T2.driverId\nORDER BY T2.points DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1175": {
        "db_id": "thrombosis_prediction",
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "ground_truth": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "amends": [
            "Do calculate age using `STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)` instead of selecting raw `age`. Do select `T1.Diagnosis` with table alias instead of just `diagnosis`. Do add `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the `patients` table. Do order by `T2.HGB DESC` with table alias instead of `hemoglobin DESC`. The amended query now correctly calculates patient age from birthdate and lab date while joining the necessary tables to access both demographic and laboratory data."
        ],
        "rules": [
            "1) When answering about patient age: calculate age using STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) instead of selecting raw age. 2) When selecting diagnosis information: select T1.Diagnosis with table alias instead of just diagnosis. 3) When combining patient and laboratory data: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 4) When ordering by hemoglobin count: order by T2.HGB DESC with table alias instead of hemoglobin DESC. 5) When finding the highest hemoglobin count: take the first row after ordering by T2.HGB DESC."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT age, diagnosis FROM patients ORDER BY hemoglobin DESC LIMIT 1;",
            "SELECT \n    STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) AS age,\n    T1.Diagnosis\nFROM \n    Patient AS T1 \nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nORDER BY \n    T2.HGB DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \n    STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) AS Age,\n    T1.Diagnosis\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nORDER BY \n    T2.HGB DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1498": {
        "db_id": "debit_card_specializing",
        "question": "What is the highest monthly consumption in the year 2012?",
        "ground_truth": "SELECT SUM(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1",
        "amends": [
            "Do use `SUM(Consumption)` instead of `MAX(consumption)` for aggregation. Do query from `yearmonth` table instead of `monthly_data`. Do filter with `SUBSTR(Date, 1, 4) = '2012'` instead of `year = 2012`. Do add `GROUP BY SUBSTR(Date, 5, 2)` to group by month instead of omitting grouping. Do add `ORDER BY SUM(Consumption) DESC` to sort by total consumption instead of omitting ordering. Do add `LIMIT 1` to return only the highest month instead of omitting limiting. The amended query now correctly calculates the maximum monthly consumption sum for 2012 rather than finding the single highest consumption value across all months.",
            "Do remove the `SUBSTR(Date, 5, 2) AS Month` column from the SELECT list instead of including it, and do remove the explicit alias `TotalConsumption` from the aggregate function instead of keeping it. The GROUP BY clause remains unchanged with `SUBSTR(Date, 5, 2)` grouping, and the WHERE filter on `SUBSTR(Date, 1, 4) = '2012'` is preserved. The ORDER BY with `SUM(Consumption) DESC` and LIMIT 1 are maintained. The amended query now correctly returns only the maximum total consumption value for 2012 without the month column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"highest monthly consumption\": make sure to sum the \"Consumption\" values instead of taking the maximum single value. 2) When the question mentions \"monthly consumption\": group results by month using SUBSTR(Date, 5, 2) to extract the month part. 3) When filtering for the year 2012: use SUBSTR(Date, 1, 4) = '2012' to extract the year part from the Date field instead of a direct year column. 4) When the question asks for \"highest\": order the results by SUM(Consumption) in descending order and limit to the top 1 result. 5) When querying consumption data: use the \"yearmonth\" table instead of \"monthly_data\" table.",
            "1) When answering about \"highest monthly consumption in the year 2012\": make sure the output order: only the maximum total consumption value without the month column. 2) When the question asks for \"highest monthly consumption\": rank rows by SUM(Consumption) in descending order and keep the first 1 row. 3) When filtering for the year 2012: use WHERE SUBSTR(Date, 1, 4) = '2012' exactly as specified. 4) When grouping by month: use GROUP BY SUBSTR(Date, 5, 2) to organize results by month. 5) When producing output: do not include the month column or alias the aggregate function."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(consumption) FROM monthly_data WHERE year = 2012;",
            "SELECT SUBSTR(Date, 5, 2) AS Month, SUM(Consumption) AS TotalConsumption\nFROM yearmonth\nWHERE SUBSTR(Date, 1, 4) = '2012'\nGROUP BY SUBSTR(Date, 5, 2)\nORDER BY SUM(Consumption) DESC\nLIMIT 1;",
            "SELECT SUM(Consumption) \nFROM yearmonth \nWHERE SUBSTR(Date, 1, 4) = '2012' \nGROUP BY SUBSTR(Date, 5, 2) \nORDER BY SUM(Consumption) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT SUM(Consumption) AS HighestMonthlyConsumption \nFROM yearmonth \nWHERE SUBSTR(Date, 1, 4) = '2012' \nGROUP BY SUBSTR(Date, 5, 2) \nORDER BY SUM(Consumption) DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1360": {
        "db_id": "student_club",
        "question": "What percentage was the budget for Parking to the total budget for the \"November Speaker\"?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Speaker'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END)` instead of direct column reference `Parking_budget`. Do calculate percentage as `* 100 / SUM(T1.amount)` instead of `/ total_budget * 100`. Do join `budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id` instead of querying single table `budget_table`. Do filter on `T2.event_name = 'November Speaker'` instead of `month = 'November Speaker'`. Do add explicit `CAST(... AS REAL)` for floating-point division instead of implicit casting. The amended query now correctly calculates the percentage of parking budget for the specified event by joining related tables and using proper aggregation."
        ],
        "rules": [
            "1) When answering about percentage of budget for a specific category to total budget: calculate the ratio as (sum of amounts for the specific category) * 100 divided by (sum of all amounts). 2) When the question mentions \"Parking\": use exact literal 'Parking' for the category filter. 3) When the question mentions \"November Speaker\": use exact literal 'November Speaker' for the event_name filter. 4) When combining budget and event tables: link rows where T1.link_to_event = T2.event_id and keep only matching pairs (inner join). 5) When performing division for percentage calculation: ensure floating-point arithmetic by casting to REAL to avoid integer division. 6) When calculating category-specific amounts: use SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) to isolate the parking budget."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (Parking_budget / total_budget) * 100 AS percentage FROM budget_table WHERE month = 'November Speaker';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) * 100.0 / SUM(T1.amount) AS REAL) AS percentage\nFROM \n    budget AS T1 \nINNER JOIN \n    event AS T2 ON T1.link_to_event = T2.event_id\nWHERE \n    T2.event_name = 'November Speaker';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN b.category = 'Parking' THEN b.amount ELSE 0 END) * 100.0) / SUM(b.amount) AS percentage\nFROM \n    budget b\nINNER JOIN \n    event e ON b.link_to_event = e.event_id\nWHERE \n    e.event_name = 'November Speaker';"
        ],
        "amend_res": 1
    },
    "555": {
        "db_id": "codebase_community",
        "question": "What is the average score of the posts owned by the user csgillespie?",
        "ground_truth": "SELECT AVG(T1.Score) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [
            "Do use an `INNER JOIN` between `posts` and `users` on `OwnerUserId = Id` instead of a subquery with `owner_user_id = id`. Do reference the joined table `T2` in the `WHERE` clause with `DisplayName = 'csgillespie'` instead of filtering through a correlated subquery. Do use table aliases `T1` and `T2` for clarity instead of no aliases. Do capitalize column names consistently as `Score` and `DisplayName` instead of lowercase `score` and `display_name`. The amended query now correctly joins the tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining posts and users tables: link rows where T1.OwnerUserId = T2.Id using an inner join and keep only matching pairs. 2) When the question mentions \"user csgillespie\": \"csgillespie\" actually means T2.DisplayName = 'csgillespie' in the schema. 3) When answering about \"average score of the posts\": compute the average of T1.Score for rows that match the specified user condition. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like Score and DisplayName. 5) When handling text literals: do not change case, spacing, or punctuation for the value 'csgillespie'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(score) FROM posts WHERE owner_user_id = (SELECT id FROM users WHERE display_name = 'csgillespie');",
            "SELECT AVG(T1.Score) AS average_score\nFROM posts T1\nINNER JOIN users T2 ON T1.OwnerUserId = T2.Id\nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "rule_sql": [
            "SELECT AVG(p.Score) AS average_score\nFROM posts p\nINNER JOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie'"
        ],
        "amend_res": 1
    },
    "1480": {
        "db_id": "debit_card_specializing",
        "question": "What was the gas consumption peak month for SME customers in 2013?",
        "ground_truth": "SELECT SUBSTR(T2.Date, 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME' GROUP BY SUBSTR(T2.Date, 5, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do use `SUBSTR(T2.Date, 5, 2)` for month extraction instead of `month` column. Do join `customers AS T1` with `yearmonth AS T2` on `T1.CustomerID = T2.CustomerID` instead of querying a single table. Do filter with `SUBSTR(T2.Date, 1, 4) = '2013'` for year instead of `year = 2013` and `T1.Segment = 'SME'` for customer type instead of `customer_type = 'SME'`. Do aggregate with `SUM(T2.Consumption)` instead of `MAX(gas_consumption)` and order by this sum instead of `peak_consumption`. The amended query now correctly calculates monthly consumption totals for SME customers in 2013 and returns the month with highest consumption.",
            "Do remove the alias `Month` from the SELECT list instead of keeping it. Do move the `SUM(T2.Consumption)` aggregate function to the ORDER BY clause instead of including it in the SELECT list. Do change the JOIN to explicitly specify `INNER JOIN` instead of the implicit JOIN syntax. Do reorder the WHERE clause predicates to place `SUBSTR(T2.Date, 1, 4) = '2013'` before `T1.Segment = 'SME'` instead of the original order. The amended query now correctly orders by the sum of consumption while selecting only the month portion, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When extracting month from date: use SUBSTR(T2.Date, 5, 2) to get the month part from the Date column instead of a direct month column. 2) When combining customer and consumption data: join customers AS T1 with yearmonth AS T2 on T1.CustomerID = T2.CustomerID using an inner match. 3) When filtering for year 2013: use SUBSTR(T2.Date, 1, 4) = '2013' to extract the year from the Date column instead of a direct year column. 4) When filtering for SME customers: use T1.Segment = 'SME' instead of customer_type = 'SME'. 5) When calculating gas consumption: use SUM(T2.Consumption) to aggregate monthly totals instead of MAX(gas_consumption). 6) When ordering results: sort by the sum of consumption in descending order to find the peak month. 7) When answering about the gas consumption peak month: make sure the output order includes the month and the total consumption value.",
            "1) When answering about gas consumption peak month: make sure the output order includes only the month portion without an alias. 2) When the question asks for peak consumption: order results by the sum of consumption in descending direction and keep only the first row. 3) When combining customers and yearmonth tables: link rows where T1.CustomerID = T2.CustomerID using an inner match. 4) When filtering for SME customers and year 2013: apply both conditions with T1.Segment = 'SME' and SUBSTR(T2.Date, 1, 4) = '2013' exactly as specified. 5) When grouping by month: group by the month portion extracted from T2.Date using SUBSTR(T2.Date, 5, 2)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT month, MAX(gas_consumption) as peak_consumption\nFROM customer_data\nWHERE customer_type = 'SME' AND year = 2013\nGROUP BY month\nORDER BY peak_consumption DESC\nLIMIT 1;",
            "SELECT SUBSTR(T2.Date, 5, 2) AS Month, SUM(T2.Consumption) AS TotalConsumption\nFROM customers AS T1\nJOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND SUBSTR(T2.Date, 1, 4) = '2013'\nGROUP BY SUBSTR(T2.Date, 5, 2)\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "SELECT SUBSTR(T2.Date, 5, 2) \nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE SUBSTR(T2.Date, 1, 4) = '2013' \nAND T1.Segment = 'SME' \nGROUP BY SUBSTR(T2.Date, 5, 2) \nORDER BY SUM(T2.Consumption) DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT SUBSTR(T2.Date, 5, 2) AS Month\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' \nAND SUBSTR(T2.Date, 1, 4) = '2013'\nGROUP BY SUBSTR(T2.Date, 5, 2)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "9": {
        "db_id": "california_schools",
        "question": "Among the schools with the average score in Math over 560 in the SAT test, how many schools are directly charter-funded?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T2.`School Code`) FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath > 560 AND T2.`Charter Funding Type` = 'Directly funded'",
        "amends": [
            "Do select `COUNT(T2.School Code)` instead of `COUNT(*)` to count specific school codes rather than all rows. Do use `satscores AS T1 INNER JOIN frpm AS T2` instead of `FROM schools` to join two tables rather than querying a single table. Do join on `T1.cds = T2.CDSCode` instead of no join condition to properly relate the tables. Do filter on `T1.AvgScrMath > 560` instead of `math_score > 560` to use the correct column name from the joined table. Do filter on `T2.Charter Funding Type = 'Directly funded'` instead of `funding_type = 'charter'` to use the appropriate column and value for charter funding classification. The amended query now correctly joins assessment and funding data to count charter schools with specific math performance, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about schools with average math scores over 560: use T1.AvgScrMath > 560 as the filter condition instead of math_score > 560. 2) When counting schools: use COUNT(T2.\"School Code\") instead of COUNT(*) to count specific school codes. 3) When combining SAT scores and funding data: join T1 (satscores) and T2 (frpm) using T1.cds = T2.CDSCode with an inner match. 4) When identifying charter-funded schools: use T2.\"Charter Funding Type\" = 'Directly funded' instead of funding_type = 'charter' to match the exact column name and literal value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE math_score > 560 AND funding_type = 'charter';",
            "SELECT COUNT(T2.\"School Code\") \nFROM satscores AS T1 \nINNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath > 560 \nAND T2.\"Charter Funding Type\" = 'Directly funded'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.\"School Code\") \nFROM satscores T1\nINNER JOIN frpm T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath > 560 \nAND T2.\"Charter Funding Type\" = 'Directly funded'"
        ],
        "amend_res": 1
    },
    "1392": {
        "db_id": "student_club",
        "question": "Indicate the top source of funds received in September 2019 based on their amount.",
        "ground_truth": "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' and '2019-09-30' ORDER BY source DESC LIMIT 1",
        "amends": [
            "Do select only `source` instead of `source, SUM(amount) as total_amount`. Do query from `income` table instead of `funds` table. Do use `date_received BETWEEN '2019-09-01' and '2019-09-30'` filter instead of `strftime('%Y-%m', date) = '2019-09'`. Do remove `GROUP BY source` and aggregation instead of keeping them. Do order by `source DESC` instead of `total_amount ASC`. The amended query now matches the intended behavior of selecting a single source from income records within September 2019."
        ],
        "rules": [
            "1) When answering about \"top source of funds received in September 2019\": make sure the output order: source. 2) When the question mentions \"September 2019\": use date_received BETWEEN '2019-09-01' and '2019-09-30' filter. 3) When the question asks for \"top source based on their amount\": order by source DESC and keep the first 1 row. 4) When querying from the database: use the income table instead of funds table. 5) When selecting columns: select only source instead of source, SUM(amount) as total_amount. 6) When filtering by date: do not use strftime('%Y-%m', date) = '2019-09' function. 7) When processing the query: remove GROUP BY source and aggregation instead of keeping them."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT source, SUM(amount) as total_amount FROM funds WHERE strftime('%Y-%m', date) = '2019-09' GROUP BY source ORDER BY total_amount ASC LIMIT 1;",
            "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' ORDER BY source DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' ORDER BY source DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1025": {
        "db_id": "european_football_2",
        "question": "Give the name of the league had the most goals in the 2016 season?",
        "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' GROUP BY t2.name ORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` instead of `league_name` and `SUM(t1.home_team_goal + t1.away_team_goal)` instead of `SUM(goals)`. Do use `FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id` instead of `FROM matches` without proper table joins. Do filter with `t1.season = '2015/2016'` instead of `season = '2016'` to match the correct season format. Do group by `t2.name` instead of `league_name` to ensure proper aggregation. Do order by `SUM(t1.home_team_goal + t1.away_team_goal) DESC` instead of `total_goals DESC` to reference the actual calculated sum. The amended query now correctly joins the Match and League tables, calculates total goals from home and away columns, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most goals in the 2016 season\": use the exact season format '2015/2016' instead of '2016' to match the correct season format. 2) When calculating total goals: compute SUM(t1.home_team_goal + t1.away_team_goal) instead of using a simple goals column. 3) When joining Match and League tables: use INNER JOIN with the condition t1.league_id = t2.id to properly link the tables. 4) When selecting league names: use t2.name instead of league_name to reference the correct column from the joined table. 5) When grouping results: group by t2.name instead of league_name to ensure proper aggregation by league. 6) When ordering by total goals: order by SUM(t1.home_team_goal + t1.away_team_goal) DESC instead of total_goals DESC to reference the actual calculated sum."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT league_name, SUM(goals) as total_goals \nFROM matches \nWHERE season = '2016' \nGROUP BY league_name \nORDER BY total_goals DESC \nLIMIT 1;",
            "SELECT t2.name \nFROM Match AS t1 \nINNER JOIN League AS t2 ON t1.league_id = t2.id \nWHERE t1.season = '2015/2016' \nGROUP BY t2.name \nORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.name \nFROM Match t1\nINNER JOIN League t2 ON t1.league_id = t2.id\nWHERE t1.season = '2015/2016'\nGROUP BY t2.name\nORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "798": {
        "db_id": "superhero",
        "question": "What is the publisher for Hawkman, Karate Kid and Speedy?",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')",
        "amends": [
            "Do select `T2.publisher_name` instead of `publisher` from the SELECT list. Do use `superhero AS T1 INNER JOIN publisher AS T2` instead of the single table `comics` as the FROM source. Do add the join condition `ON T1.publisher_id = T2.id` instead of omitting any join. Do filter on `T1.superhero_name` instead of `character_name` in the WHERE clause. The amended query now correctly joins the superhero and publisher tables to retrieve publisher names for the specified superheroes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about publisher names for specific superheroes: select T2.publisher_name instead of publisher from the SELECT list. 2) When combining superhero and publisher tables: use superhero AS T1 INNER JOIN publisher AS T2 with join condition T1.publisher_id = T2.id. 3) When filtering by superhero names: use T1.superhero_name instead of character_name in the WHERE clause with exact literals 'Hawkman', 'Karate Kid', and 'Speedy'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT publisher FROM comics WHERE character_name IN ('Hawkman', 'Karate Kid', 'Speedy');",
            "SELECT T2.publisher_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')"
        ],
        "rule_sql": [
            "SELECT T2.publisher_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');"
        ],
        "amend_res": 1
    },
    "37": {
        "db_id": "california_schools",
        "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
        "ground_truth": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
        "amends": [
            "Do join `satscores AS T1` with `schools AS T2` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table. Do select columns `T2.Street`, `T2.City`, `T2.State`, and `T2.Zip` with explicit table aliases instead of selecting `Street`, `City`, `Zip`, and `State` without table qualification. Do order by the calculated ratio `CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr` in ascending order instead of ordering by `excellence_rate` in descending order. The amended query now correctly joins the necessary tables and calculates the proper ordering metric to match the intended behavior.",
            "Do specify `INNER JOIN` instead of just `JOIN` to make the join type explicit. Do reorder the column sequence in the SELECT list to `Street, City, State, Zip` instead of `Street, City, Zip, State`. The amended query now correctly matches the intended behavior with explicit join semantics and proper column ordering."
        ],
        "rules": [
            "1) When answering about school addresses with lowest excellence rate: make sure the output order: Street, City, Zip, State from the schools table. 2) When the question mentions \"excellence rate\": \"excellence rate\" actually means \"calculated ratio CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr in schema\". 3) When the question asks for the school with the lowest excellence rate: rank rows by the calculated ratio CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr in ascending order and keep the first 1 row. 4) When combining satscores and schools tables: link rows where T1.cds = T2.CDSCode exactly as shown; keep only matching pairs (inner match). 5) When selecting address columns: use explicit table aliases T2.Street, T2.City, T2.State, and T2.Zip instead of unqualified column names.",
            "1) When combining SAT scores and schools data: use INNER JOIN to link rows where T1.cds = T2.CDSCode and keep only matching pairs. 2) When ordering by excellence rate: compute CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr and sort in ascending order to find the lowest rate. 3) When selecting address information: output columns in the order Street, City, State, Zip. 4) When finding the single school with the lowest excellence rate: take only the first result after ordering."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT Street, City, Zip, State FROM schools ORDER BY excellence_rate DESC LIMIT 1;",
            "SELECT T2.Street, T2.City, T2.Zip, T2.State\nFROM satscores AS T1\nJOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC\nLIMIT 1;",
            "SELECT T2.Street, T2.City, T2.State, T2.Zip\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Street, T2.City, T2.Zip, T2.State\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.NumTstTakr > 0\nORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "905": {
        "db_id": "formula_1",
        "question": "What is Eddie Irvine's average points scored in year 2000?",
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine' AND T3.year = 2000",
        "amends": [
            "Do join `drivers AS T1` and `driverStandings AS T2` with `T2.driverId = T1.driverId` instead of querying a single table. Do join `races AS T3` with `T3.raceId = T2.raceId` instead of omitting race information. Do filter on `T1.forename = 'Eddie'` and `T1.surname = 'Irvine'` instead of `driver_name = 'Eddie Irvine'`. Do filter on `T3.year = 2000` instead of a simple `year` column. Do select `AVG(T2.points)` from the joined table instead of directly from a results table. The amended query now correctly calculates average points by properly joining driver and race data with accurate filtering."
        ],
        "rules": [
            "1) When the question asks about a driver's performance: join drivers table as T1 with driverStandings table as T2 using T2.driverId = T1.driverId to get driver results. 2) When the question involves race year information: join races table as T3 with T3.raceId = T2.raceId to access year data. 3) When filtering for driver name \"Eddie Irvine\": use T1.forename = 'Eddie' and T1.surname = 'Irvine' instead of a single driver_name column. 4) When filtering for year 2000: use T3.year = 2000 instead of a simple year column. 5) When calculating average points scored: compute AVG(T2.points) from the joined tables instead of directly from a results table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(points) FROM driver_results WHERE driver_name = 'Eddie Irvine' AND year = 2000;",
            "SELECT AVG(T2.points) \nFROM drivers AS T1 \nJOIN driverStandings AS T2 ON T2.driverId = T1.driverId \nJOIN races AS T3 ON T3.raceId = T2.raceId \nWHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine' AND T3.year = 2000"
        ],
        "rule_sql": [
            "SELECT AVG(T2.points) AS average_points\nFROM drivers AS T1\nJOIN driverStandings AS T2 ON T2.driverId = T1.driverId\nJOIN races AS T3 ON T3.raceId = T2.raceId\nWHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine'\nAND T3.year = 2000;"
        ],
        "amend_res": 1
    },
    "652": {
        "db_id": "codebase_community",
        "question": "List the post IDs and badge names of the user Samuel in 2013.",
        "ground_truth": "SELECT T1.PostId, T2.Name FROM postHistory AS T1 INNER JOIN badges AS T2 ON T1.UserId = T2.UserId WHERE T1.UserDisplayName = 'Samuel' AND STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'",
        "amends": [
            "Do reference `T1.PostId` and `T2.Name` instead of `post_id` and `badge_name`. Do join `postHistory AS T1` instead of `posts` and use `INNER JOIN` instead of `JOIN`. Do use `T1.UserId = T2.UserId` instead of `posts.user_id = badges.user_id`. Do filter on `T1.UserDisplayName = 'Samuel'` instead of `username = 'Samuel'`. Do add `STRFTIME('%Y', T1.CreationDate) = '2013'` to filter by year from post history creation date instead of a simple `year = 2013`. Do add `STRFTIME('%Y', T2.Date) = '2013'` to filter by year from badges date instead of omitting it. The amended query now correctly filters both tables by their respective date fields and uses proper table aliases and column references."
        ],
        "rules": [
            "1) When answering about \"post IDs and badge names of the user Samuel in 2013\": make sure the output order: T1.PostId, T2.Name\n2) When the question mentions \"post IDs\": \"post IDs\" actually means \"T1.PostId in schema\"\n3) When the question mentions \"badge names\": \"badge names\" actually means \"T2.Name in schema\"\n4) When the question mentions \"user Samuel\": \"Samuel\" actually means \"T1.UserDisplayName = 'Samuel'\" with exact literal 'Samuel'\n5) When the question mentions \"in 2013\": filter both T1 and T2 by their respective date fields using STRFTIME('%Y', T1.CreationDate) = '2013' and STRFTIME('%Y', T2.Date) = '2013'\n6) When combining postHistory AS T1 and badges AS T2: link rows where T1.UserId = T2.UserId and keep only matching pairs (inner match)\n7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T1.PostId, T2.Name, T1.UserId, T2.UserId, T1.UserDisplayName, T1.CreationDate, T2.Date"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT post_id, badge_name FROM posts JOIN badges ON posts.user_id = badges.user_id WHERE username = 'Samuel' AND year = 2013;",
            "SELECT T1.PostId, T2.Name\nFROM postHistory AS T1\nINNER JOIN badges AS T2 ON T1.UserId = T2.UserId\nWHERE T1.UserDisplayName = 'Samuel'\nAND STRFTIME('%Y', T1.CreationDate) = '2013'\nAND STRFTIME('%Y', T2.Date) = '2013'"
        ],
        "rule_sql": [
            "SELECT T1.PostId, T2.Name\nFROM postHistory AS T1\nINNER JOIN badges AS T2 ON T1.UserId = T2.UserId\nWHERE T1.UserDisplayName = 'Samuel'\nAND STRFTIME('%Y', T1.CreationDate) = '2013'\nAND STRFTIME('%Y', T2.Date) = '2013'"
        ],
        "amend_res": 1
    },
    "1331": {
        "db_id": "student_club",
        "question": "What is the amount of the funds that the Vice President received?",
        "ground_truth": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "amends": [
            "Do select `T2.amount` as individual column instead of `SUM(amount)` aggregate. Do join `member AS T1` and `income AS T2` with `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of querying only `funds` table. Do filter on `T1.position = 'Vice President'` instead of `recipient = 'President'`. Do remove the aggregation entirely instead of using `SUM`. The amended query now correctly retrieves individual income amounts for Vice Presidents through proper table relationships instead of incorrectly aggregating funds for Presidents."
        ],
        "rules": [
            "1) When answering about funds received by the Vice President: make sure the output order: T2.amount 2) When the question mentions \"Vice President\": \"Vice President\" actually means \"T1.position = 'Vice President'\" in schema 3) When combining member AS T1 and income AS T2 for shared entities: link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for individual amounts: do not aggregate and return individual T2.amount values instead of using SUM"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM funds WHERE recipient = 'President';",
            "SELECT T2.amount\nFROM member AS T1\nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member\nWHERE T1.position = 'Vice President'"
        ],
        "rule_sql": [
            "SELECT T2.amount\nFROM member AS T1\nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member\nWHERE T1.position = 'Vice President'\nORDER BY T2.amount"
        ],
        "amend_res": 1
    },
    "145": {
        "db_id": "financial",
        "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
        "ground_truth": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
        "amends": [
            "Do select `account_id` from `trans` instead of `account_holder_id` from `credit_card_transactions`. Do use `INNER JOIN` with `account` on `T1.account_id = T2.account_id` instead of querying a single table. Do filter by `STRFTIME('%Y', T1.date) = '1998'` instead of `YEAR(transaction_date) = 1998`. Do add `T1.operation = 'VYBER KARTOU'` instead of omitting this operation filter. Do use `amount <` instead of `amount >` for the comparison with the subquery average. Do modify the subquery to filter by `STRFTIME('%Y', date) = '1998'` instead of calculating the overall average without date filtering. The amended query now correctly filters for 1998 transactions with the specific operation type and identifies accounts with below-average transaction amounts for that year.",
            "Do remove `DISTINCT` instead of keeping it. Do use table alias `T1` instead of `t` and `T2` instead of `a`. Do remove the redundant `operation = 'VYBER KARTOU'` condition from the subquery instead of including it, since the subquery already filters by year and the operation filter is unnecessary for calculating the average amount. Do maintain the same `INNER JOIN` on `account_id` between tables. Do preserve the `WHERE` filters for year `1998` and operation `VYBER KARTOU` on the main table. The amended query now matches RIGHT_SQL's behavior by correctly calculating the average amount without the redundant operation filter in the subquery."
        ],
        "rules": [
            "1) When answering about account holder identification numbers: use \"account_id\" from table \"trans\" instead of \"account_holder_id\" from \"credit_card_transactions\". 2) When combining account and transaction information: link rows where T1.account_id = T2.account_id using an inner join between \"trans\" and \"account\" tables. 3) When filtering for transactions in 1998: use STRFTIME('%Y', T1.date) = '1998' to extract the year from the date column. 4) When filtering for credit card operations: include T1.operation = 'VYBER KARTOU' to select only credit card withdrawal transactions. 5) When comparing transaction amounts to the average: use amount < (subquery average) instead of amount > to find amounts less than average. 6) When calculating the average amount for comparison: filter the subquery by STRFTIME('%Y', date) = '1998' to compute the average only for 1998 transactions rather than the overall average.",
            "1) When answering about account holder identification numbers: use column \"account_id\" from table T1. 2) When the question mentions \"transactions on the credit card\": filter for operation = 'VYBER KARTOU'. 3) When the question specifies year 1998: filter for transactions where the year part of date equals '1998'. 4) When comparing transaction amounts to the average: calculate the average amount from all transactions in 1998 without additional operation filters. 5) When combining trans and account tables: link rows where T1.account_id = T2.account_id using inner match. 6) When selecting account identification numbers: do not use DISTINCT to remove duplicates."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_holder_id \nFROM credit_card_transactions \nWHERE amount > (SELECT AVG(amount) FROM credit_card_transactions) \nAND YEAR(transaction_date) = 1998;",
            "SELECT DISTINCT t.account_id\nFROM trans t\nINNER JOIN account a ON t.account_id = a.account_id\nWHERE STRFTIME('%Y', t.date) = '1998'\nAND t.operation = 'VYBER KARTOU'\nAND t.amount < (\n    SELECT AVG(amount)\n    FROM trans\n    WHERE STRFTIME('%Y', date) = '1998'\n    AND operation = 'VYBER KARTOU'\n)",
            "SELECT T1.account_id\nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1998'\nAND T1.operation = 'VYBER KARTOU'\nAND T1.amount < (\n    SELECT AVG(amount)\n    FROM trans\n    WHERE STRFTIME('%Y', date) = '1998'\n)"
        ],
        "rule_sql": [
            "SELECT T1.account_id\nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE T1.operation = 'VYBER KARTOU'\nAND STRFTIME('%Y', T1.date) = '1998'\nAND T1.amount < (\n    SELECT AVG(amount)\n    FROM trans\n    WHERE STRFTIME('%Y', date) = '1998'\n)"
        ],
        "amend_res": 1
    },
    "1412": {
        "db_id": "student_club",
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "amends": [
            "Do select `T2.expense_description` instead of `expense_type` from the wrong table. Do use `member AS T1` and `expense AS T2` as table sources instead of just `members`. Do add `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of querying a single table. Do change the filter to `T1.t_shirt_size = 'X-Large'` instead of `tee_shirt_size` to reference the correct table and column name. The amended query now correctly joins the member and expense tables to retrieve expense descriptions for members with X-Large t-shirt sizes, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"expenses incurred by members\": make sure the output order: T2.expense_description 2) When the question mentions \"expense_type\": \"expense_type\" actually means \"T2.expense_description\" in schema 3) When the question mentions \"members who have X-Large in size of tee shirt\": use T1.t_shirt_size = 'X-Large' as the filter condition 4) When combining T1 and T2 for shared entities: link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 6) When handling text literals: do not change case, spacing, or punctuation of 'X-Large'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT expense_type FROM members WHERE tee_shirt_size = 'X-Large';",
            "SELECT T2.expense_description \nFROM member AS T1 \nINNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member \nWHERE T1.t_shirt_size = 'X-Large'"
        ],
        "rule_sql": [
            "SELECT T2.expense_description \nFROM member T1\nINNER JOIN expense T2 ON T1.member_id = T2.link_to_member\nWHERE T1.t_shirt_size = 'X-Large'\nORDER BY T2.expense_description"
        ],
        "amend_res": 1
    },
    "1070": {
        "db_id": "european_football_2",
        "question": "Which country is the league Italy Serie A from?",
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Italy Serie A'",
        "amends": [
            "Do select `t1.name` from the `Country` table instead of `country` from the `leagues` table. Do join `Country AS t1` with `League AS t2` using `INNER JOIN` on `t1.id = t2.country_id` instead of querying only the `leagues` table. Do filter on `t2.name = 'Italy Serie A'` in the WHERE clause instead of filtering directly on the `leagues.name` column. The amended query now correctly retrieves the country name by joining the Country and League tables through their relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which country is the league Italy Serie A from\": make sure the output order: t1.name 2) When the question mentions \"country\": \"country\" actually means \"t1.name in schema\" from the Country table 3) When the question mentions \"league Italy Serie A\": filter using t2.name = 'Italy Serie A' exactly as specified 4) When combining Country table as T1 and League table as T2: link rows where t1.id = t2.country_id and keep only matching pairs (inner match)"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM leagues WHERE name = 'Italy Serie A';",
            "SELECT t1.name \nFROM Country AS t1 \nINNER JOIN League AS t2 ON t1.id = t2.country_id \nWHERE t2.name = 'Italy Serie A'"
        ],
        "rule_sql": [
            "SELECT t1.name \nFROM Country t1 \nINNER JOIN League t2 ON t1.id = t2.country_id \nWHERE t2.name = 'Italy Serie A'"
        ],
        "amend_res": 1
    },
    "201": {
        "db_id": "toxicology",
        "question": "What is the percentage of carbon in double-bond molecules?",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
        "amends": [
            "Do use `CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id)` instead of `(carbon_atoms / total_atoms) * 100` to properly calculate the percentage of carbon atoms. Do join `atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id` instead of querying only the `molecules` table to access both atom and bond data. Do filter on `T2.bond_type = '='` instead of `bond_type = 'double'` to use the correct bond type syntax. Do remove the `AS carbon_percentage` alias instead of keeping it since the calculation is now more complex. The amended query now correctly calculates the percentage of carbon atoms in molecules with double bonds by properly joining the necessary tables and using accurate counting logic."
        ],
        "rules": [
            "1) When calculating percentage of carbon atoms in molecules: use CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) instead of simple division to properly handle distinct atom counting. 2) When accessing both atom and bond data: join atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id to combine information from both tables using molecule_id as the linking key. 3) When filtering for double bonds: use T2.bond_type = '=' instead of 'double' to match the exact bond type syntax in the database. 4) When the calculation becomes complex: remove the AS carbon_percentage alias to avoid oversimplifying the output column name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (carbon_atoms / total_atoms) * 100 AS carbon_percentage FROM molecules WHERE bond_type = 'double';",
            "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id)\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.bond_type = '='"
        ],
        "amend_res": 1
    },
    "297": {
        "db_id": "toxicology",
        "question": "Among the atoms that contain element carbon, which one does not contain compound carcinogenic?",
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
        "amends": [
            "Do select `T1.atom_id` instead of `atom_name` and change the source to `atom AS T1` instead of `atoms`. Do add `INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id` instead of omitting the join. Do change the WHERE condition to `T1.element = 'c'` instead of `element = 'carbon'` and add `T2.label = '-'` instead of `compound_carcinogenic = 'true'`. The amended query now correctly joins tables and uses appropriate filter conditions to match the intended behavior."
        ],
        "rules": [
            "1) When answering about atoms containing element carbon: use table \"atom\" as T1 instead of \"atoms\" and select T1.atom_id instead of atom_name. 2) When the question mentions \"element carbon\": \"carbon\" actually means \"c\" in schema, so use T1.element = 'c' exactly. 3) When checking for compound carcinogenic: join with table \"molecule\" as T2 using T1.molecule_id = T2.molecule_id and use T2.label = '-' to represent not containing carcinogenic compound. 4) When combining T1 and T2 for shared entities: link rows where T1.molecule_id = T2.molecule_id exactly and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_name FROM atoms WHERE element = 'carbon' AND compound_carcinogenic = 'true';",
            "SELECT T1.atom_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'c' AND T2.label = '-'"
        ],
        "rule_sql": [
            "SELECT T1.atom_id \nFROM atom AS T1 \nJOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.element = 'c' AND T2.label = '-'"
        ],
        "amend_res": 1
    },
    "618": {
        "db_id": "codebase_community",
        "question": "List out the age of users who located in Vienna, Austria obtained the badge?",
        "ground_truth": "SELECT T1.Age FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'Vienna, Austria'",
        "amends": [
            "Do add `INNER JOIN badges AS T2 ON T1.Id = T2.UserId` instead of querying only the `users` table. Do change the column reference to `T1.Age` instead of just `age` to make the table alias explicit. Do remove the condition `badge_obtained = 1` from the WHERE clause instead of keeping it, as the join with badges table now implicitly filters for users with badges. The amended query now correctly joins the users and badges tables to find users from Vienna, Austria who have earned badges, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"users who located in Vienna, Austria obtained the badge\": make sure to combine the users table (T1) and badges table (T2) using an inner match where T1.Id equals T2.UserId. 2) When the question mentions \"age of users\": use the exact column token T1.Age for output. 3) When filtering for users located in Vienna, Austria: use the exact literal 'Vienna, Austria' for the location condition. 4) When determining which users obtained badges: rely on the inner join with badges table (T2) instead of using a badge_obtained column condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT age FROM users WHERE location = 'Vienna, Austria' AND badge_obtained = 1;",
            "SELECT T1.Age\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.Id = T2.UserId\nWHERE T1.Location = 'Vienna, Austria'"
        ],
        "rule_sql": [
            "SELECT T1.Age\nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T1.Location = 'Vienna, Austria'"
        ],
        "amend_res": 1
    },
    "552": {
        "db_id": "codebase_community",
        "question": "Please list the names of the badges obtained by csgillespie.",
        "ground_truth": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [
            "Do join `users` table instead of omitting it, using `INNER JOIN` on `T1.UserId = T2.Id` instead of querying `badges` alone. Do filter on `T2.DisplayName = 'csgillespie'` instead of `user_id = 'csgillespie'` to correctly reference the user by display name rather than ID. Do select `T1.Name` instead of `badge_name` to use the proper column name from the joined table structure. The amended query now correctly retrieves badge names by joining user information and filtering on display name instead of user ID, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"badges obtained by csgillespie\": make sure the output order: T1.Name\n2) When the question mentions \"csgillespie\": \"csgillespie\" actually means \"T2.DisplayName = 'csgillespie'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T1.UserId = T2.Id; keep only matching pairs (inner match)\n4) When selecting badge names: use T1.Name instead of badge_name to use the proper column name"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT badge_name FROM badges WHERE user_id = 'csgillespie';",
            "SELECT T1.Name \nFROM badges T1 \nINNER JOIN users T2 ON T1.UserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM badges T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T2.DisplayName = 'csgillespie'\nORDER BY T1.Name"
        ],
        "amend_res": 1
    },
    "608": {
        "db_id": "codebase_community",
        "question": "State the detailed content of the comment which was created on 7/19/2010 7:25:47 PM.",
        "ground_truth": "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:16:14.0'",
        "amends": [
            "Do select `Text` instead of `*` for the column list. Do filter on `CreationDate` instead of `created_at` for the date column. Do use the ISO format date literal `'2010-07-19 19:16:14.0'` instead of the non-standard `'7/19/2010 7:25:47 PM'` format. The amended query now correctly retrieves comment text based on the proper datetime column and standardized timestamp format.",
            "Do use the timestamp '2010-07-19 19:16:14.0' in the WHERE filter instead of '2010-07-19 19:25:47.0' to query for comments created at the correct datetime. The amended query now matches RIGHT_SQL's behavior by filtering for the intended creation timestamp."
        ],
        "rules": [
            "1) When the question asks for \"detailed content of the comment\": select the exact column \"Text\" instead of all columns. 2) When filtering by creation date: use the exact column name \"CreationDate\" instead of \"created_at\". 3) When specifying the timestamp '7/19/2010 7:25:47 PM': convert it to the ISO format literal '2010-07-19 19:16:14.0' for proper datetime comparison.",
            "1) When the question asks for a comment created on 7/19/2010 7:25:47 PM: use the timestamp literal '2010-07-19 19:16:14.0' exactly as specified in the amends for filtering the CreationDate column. 2) When filtering by datetime in the comments table: ensure the timestamp format matches exactly '2010-07-19 19:16:14.0' including the .0 millisecond precision. 3) When querying for comment text content: select the Text column from the comments table using the exact timestamp filter '2010-07-19 19:16:14.0'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM comments WHERE created_at = '7/19/2010 7:25:47 PM';",
            "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:25:47.0';",
            "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:16:14.0'"
        ],
        "rule_sql": [
            "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:16:14.0'"
        ],
        "amend_res": 1
    },
    "547": {
        "db_id": "codebase_community",
        "question": "Among the posts owned by an elder user, how many of them have a score of over 19?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score >= 20 AND T2.Age > 65",
        "amends": [
            "Do use `COUNT(T1.Id)` instead of `COUNT(*)` to count specific non-null values. Do join `posts AS T1` with `users AS T2` using `INNER JOIN` on `T1.OwnerUserId = T2.Id` instead of using a subquery with `IN` condition. Do filter with `T1.Score >= 20` instead of `score > 19` to include the threshold value. Do filter with `T2.Age > 65` in the WHERE clause instead of using a subquery condition. Do reference the joined table columns `T1.OwnerUserId` and `T2.Id` for the join condition instead of assuming `user_id` columns exist in both tables. The amended query now correctly counts posts from users over 65 with scores of 20 or higher using proper join semantics instead of subquery filtering."
        ],
        "rules": [
            "1) When counting posts: use COUNT(T1.Id) instead of COUNT(*) to count specific non-null values. 2) When combining posts and users tables: link rows using INNER JOIN where T1.OwnerUserId = T2.Id and keep only matching pairs. 3) When filtering for elder users: use T2.Age > 65 to identify users over 65 years old. 4) When filtering for high-scoring posts: use T1.Score >= 20 to include posts with scores of 20 or higher. 5) When referencing columns from joined tables: use the exact column tokens T1.OwnerUserId and T2.Id for the join condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE user_id IN (SELECT user_id FROM users WHERE age > 65) AND score > 19;",
            "SELECT COUNT(T1.Id) \nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id\nWHERE T2.Age > 65 AND T1.Score >= 20"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM posts T1\nINNER JOIN users T2 ON T1.OwnerUserId = T2.Id\nWHERE T2.Age > 65 AND T1.Score >= 20"
        ],
        "amend_res": 1
    }
}