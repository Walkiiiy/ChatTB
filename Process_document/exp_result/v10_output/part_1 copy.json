{
  "51": {
    "reason": "To solve the question, we need to find the school with the lowest average reading score from the `satscores` table and then retrieve its mailing street address and name from the `schools` table. The steps are as follows:\n1. Join the `satscores` table with the `schools` table using the `CDSCode` (or `cds` in `satscores`) as the common key.\n2. Order the results by the `AvgScrRead` column in ascending order to find the lowest score.\n3. Limit the result to 1 to get only the school with the lowest score.\n4. Select the `MailStreet` (mailing street address) and `School` (school name) columns from the `schools` table.",
    "sql": "SELECT s.MailStreet, s.School\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY sc.AvgScrRead ASC\nLIMIT 1;",
    "question": "In which mailing street address can you find the school that has the lowest average score in reading? Also give the school's name.",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
    "evidence": [
      ""
    ]
  },
  "134": {
    "reason": "To solve the question, we need to find the branch (district) where the largest number of crimes were committed in 1996, and then determine how many accounts were opened in that district. Here's the step-by-step reasoning:\n\n1. **Identify the district with the most crimes in 1996**: The `district` table contains crime-related columns (A15 and A16). Column A15 represents the number of crimes in 1995, and A16 represents the number of crimes in 1996. We need to find the district with the highest value in A16.\n\n2. **Find accounts opened in that district**: Once we have the district_id of the district with the most crimes in 1996, we can query the `account` table to count the number of accounts opened in that district.\n\n3. **Combine the queries**: First, find the district_id with the highest A16 value, then use this district_id to count the accounts in the `account` table.",
    "sql": "WITH max_crime_district AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A16 DESC\n    LIMIT 1\n)\nSELECT COUNT(*) AS accounts_opened\nFROM account\nWHERE district_id = (SELECT district_id FROM max_crime_district);",
    "question": "In the branch where the largest number of crimes were committed in 1996, how many accounts were opened?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY T1.A16 ORDER BY T1.A16 DESC LIMIT 1",
    "evidence": [
      "A16 stands for no. of committed crimes 1996"
    ]
  },
  "908": {
    "reason": "To find the race with the most laps, we need to look at the `results` table, which contains the `laps` column indicating the number of laps for each race. We will join the `results` table with the `races` table to get the race details (name, year) and the `circuits` table to get the circuit location. We will then group the results by race and order them by the number of laps in descending order to find the race with the highest number of laps.",
    "sql": "SELECT r.name AS race_name, r.year, c.location AS circuit_location, MAX(re.laps) AS max_laps\nFROM results re\nJOIN races r ON re.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nGROUP BY re.raceId\nORDER BY max_laps DESC\nLIMIT 1;",
    "question": "What is the most laps f1 races had? Name the race, year and circuit location where the races with most laps was hosted.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT T3.lap, T2.name, T2.year, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId INNER JOIN lapTimes AS T3 ON T3.raceId = T2.raceId ORDER BY T3.lap DESC LIMIT 1",
    "evidence": [
      ""
    ]
  },
  "425": {
    "reason": "To solve the question, we need to find card numbers that meet two conditions: \n1. The card does not have multiple faces (indicated by `side` being null in the `cards` table).\n2. The card has both 'Angel' and 'Wizard' in its subtypes.\n\nWe will query the `cards` table, filtering for records where `side` is null and the `subtypes` column contains both 'Angel' and 'Wizard'. The `subtypes` column is a text field, so we will use string operations to check for the presence of these subtypes.",
    "sql": "SELECT number FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%';",
    "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
    "evidence": [
      "don't have multiple faces on a single card side is null"
    ]
  },
  "463": {
    "reason": "To solve the question, we need to find the number of translations for the set of cards that include \"Angel of Mercy\" in their name. Here's the step-by-step reasoning:\n\n1. **Identify the card(s) with \"Angel of Mercy\" in their name**: We query the `cards` table to find the `uuid` of the card(s) where the `name` column contains \"Angel of Mercy\".\n\n2. **Find the set(s) associated with the card(s)**: Using the `setCode` from the `cards` table, we can identify the set(s) that include the card(s).\n\n3. **Count the translations for the identified set(s)**: We query the `set_translations` table to count the number of translations where the `setCode` matches the set(s) identified in the previous step.\n\n4. **Combine these steps into a single query**: We use a subquery to first find the `setCode` from the `cards` table and then count the translations in the `set_translations` table for that `setCode`.",
    "sql": "SELECT COUNT(*) AS translation_count\nFROM set_translations\nWHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy');",
    "question": "How many translations are there for the set of cards with \"Angel of Mercy\" in it?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT translation) FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Angel of Mercy' ) AND translation IS NOT NULL",
    "evidence": [
      "set of cards with \"Angel of Mercy\" in it refers to name = 'Angel of Mercy'"
    ]
  },
  "1503": {
    "reason": "To solve the question, we need to find the product descriptions of products bought in transactions where the currency is Euro. The steps are as follows:\n1. Identify transactions where the currency is Euro by joining the `transactions_1k` table with the `customers` table on `CustomerID`.\n2. Filter these transactions where the `Currency` is 'Euro'.\n3. Join the filtered transactions with the `products` table on `ProductID` to get the product descriptions.\n4. Select the `Description` column from the `products` table.",
    "sql": "SELECT p.Description\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE c.Currency = 'Euro';",
    "question": "Please list the product description of the products bought in transactions in euro.",
    "db_id": "debit_card_specializing",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T1.ProductID, T3.Description FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Currency = 'EUR'",
    "evidence": [
      ""
    ]
  },
  "868": {
    "reason": "To find the location coordinates (latitude and longitude) of the Malaysian Grand Prix, we need to:\n1. Identify the race named 'Malaysian Grand Prix' in the `races` table.\n2. Join the `races` table with the `circuits` table to get the circuit details, including the location coordinates (`lat` and `lng`).\n3. Select the `lat` and `lng` columns from the `circuits` table for the identified race.",
    "sql": "SELECT c.lat, c.lng\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Malaysian Grand Prix';",
    "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix'",
    "evidence": [
      "location coordinates refers to (lat, lng); Malaysian Grand Prix refers to races.name = 'Malaysian Grand Prix'"
    ]
  },
  "1455": {
    "reason": "To solve the question, we need to find the budget that allowed the most money for expenses described as 'Water, chips, cookies'. This involves the following steps:\n1. Identify the expense records where the `expense_description` matches 'Water, chips, cookies'.\n2. For these records, find the linked budget using the `link_to_budget` field.\n3. Among these budgets, determine which one has the highest `cost` associated with the expense.\n4. Retrieve the details of this budget to answer the question.",
    "sql": "SELECT b.budget_id, b.category, b.amount, b.spent, b.remaining, b.event_status\nFROM budget b\nJOIN expense e ON b.budget_id = e.link_to_budget\nWHERE e.expense_description = 'Water, chips, cookies'\nORDER BY e.cost DESC\nLIMIT 1;",
    "question": "Which budget allowed the most money for water, chips, and cookies?",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
    "evidence": [
      "budget allowed refers to expense_description; expense_description = 'Water, chips, cookies'; most money refers to MAX(cost)"
    ]
  },
  "957": {
    "reason": "To solve the question, we need to identify Italian drivers who haven't finished a race. According to the schema and the tip provided, a driver hasn't finished a race if the `time` field in the `results` table is null. Additionally, we need to filter drivers by their nationality, which is 'Italian'. The steps are:\n1. Join the `drivers` table with the `results` table to link drivers to their race results.\n2. Filter the results where the driver's nationality is 'Italian' and the `time` field in the `results` table is null.\n3. Count the distinct drivers who meet these criteria to avoid counting the same driver multiple times for different races.",
    "sql": "SELECT COUNT(DISTINCT d.driverId) AS italian_drivers_not_finished\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE d.nationality = 'Italian' AND r.time IS NULL;",
    "question": "How many Italian drivers haven't finished the race?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Italian' AND T1.time IS NULL",
    "evidence": [
      "haven't finished the race refers to time is null;"
    ]
  },
  "1253": {
    "reason": "To solve the question, we need to find the patient with the highest Ig A level within the normal range (80 to 500) and then retrieve their diagnosis. The steps are as follows:\n1. Identify the patient with the highest Ig A level within the normal range from the Laboratory table.\n2. Use the patient's ID to retrieve their diagnosis from the Patient table.\n3. The query will involve joining the Laboratory and Patient tables on the ID field to link the Ig A data with the diagnosis.",
    "sql": "SELECT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.IGA = (SELECT MAX(IGA) FROM Laboratory WHERE IGA BETWEEN 80 AND 500)\nAND l.IGA BETWEEN 80 AND 500;",
    "question": "For the patient who has the highest Ig A within the normal range, what is his or her diagnosis?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT patientData.Diagnosis FROM Patient AS patientData INNER JOIN Laboratory AS labData ON patientData.ID = labData.ID WHERE labData.IGA BETWEEN 80 AND 500 ORDER BY labData.IGA DESC LIMIT 1",
    "evidence": [
      "highest Ig A within the normal range refers to MAX(IGA BETWEEN 80 AND 500);"
    ]
  },
  "448": {
    "reason": "To solve the question, we need to find the foreign name of the card that has an 'abzan' watermark and also list its type. Here's the step-by-step reasoning:\n\n1. **Identify the card with 'abzan' watermark**: The `cards` table has a column named `watermark` which can be used to filter cards with the 'abzan' watermark.\n2. **Retrieve the foreign name**: The `foreign_data` table contains foreign names of cards, linked to the `cards` table via the `uuid` column.\n3. **Retrieve the card type**: The `cards` table also has a `type` column which lists the type of the card.\n4. **Join the tables**: We need to join the `cards` table with the `foreign_data` table to get the foreign name and type of the card with the 'abzan' watermark.\n5. **Filter and select**: Filter the `cards` table for the 'abzan' watermark, join with `foreign_data`, and select the foreign name and type.",
    "sql": "SELECT fd.name AS foreign_name, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'abzan';",
    "question": "Name the foreign name of the card that has abzan watermark? List out the type of this card.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'abzan'",
    "evidence": [
      ""
    ]
  },
  "381": {
    "reason": "To list the names of artists for cards in Chinese Simplified, we need to identify the cards that have foreign data entries in the 'Chinese Simplified' language. The steps are as follows:\n1. Join the 'cards' table with the 'foreign_data' table where the 'uuid' matches.\n2. Filter the 'foreign_data' table for entries where the 'language' is 'Chinese Simplified'.\n3. Select the 'artist' field from the 'cards' table for these matching entries.\n4. Ensure the results are distinct to avoid duplicates.",
    "sql": "SELECT DISTINCT c.artist\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Chinese Simplified';",
    "question": "List down the name of artists for cards in Chinese Simplified.",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
    "evidence": [
      "Chinese Simplified' is the language;"
    ]
  },
  "676": {
    "reason": "To solve the question, we need to list all display names of users who are adults. According to the tips provided, adults are defined as users where the age is between 19 and 65. The relevant table for this query is the `users` table, which contains the `DisplayName` and `Age` columns. The query will filter the users based on the age range and return their display names.",
    "sql": "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65;",
    "question": "Please list all display names of users who are adults.",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65",
    "evidence": [
      "adults refer to users where Age BETWEEN 19 and 65;"
    ]
  },
  "1348": {
    "reason": "To solve the question, we need to find out how many budgets for the event named \"November Meeting\" have exceeded their allocated amount. The steps are as follows:\n1. Identify the event_id for \"November Meeting\" from the event table.\n2. Use this event_id to find all budgets linked to this event in the budget table.\n3. For each budget, check if the spent amount is greater than the amount allocated (i.e., spent > amount).\n4. Count the number of such budgets where the condition is true.",
    "sql": "SELECT COUNT(*) \nFROM budget \nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'November Meeting') \nAND spent > amount;",
    "question": "For all the budgets for \"November Meeting\", how many of them had exceeded the budget?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT COUNT(T2.event_id) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Meeting' AND T1.remaining < 0",
    "evidence": [
      "'November Meeting' is an event name; remaining < 0 means the cost had exceeded the budget"
    ]
  },
  "1453": {
    "reason": "To solve the question, we need to list the names of events where the parking cost is less than the average parking cost across all events. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `event` table contains event names, and the `budget` table contains cost information related to events, including parking costs.\n2. **Filter for parking costs**: The `budget` table has a `category` column, and we need to filter for entries where `category = 'Parking'`.\n3. **Calculate the average parking cost**: We need to compute the average of the `cost` column (or `spent` column, depending on the schema) for all parking-related entries in the `budget` table.\n4. **Compare individual parking costs to the average**: For each event, compare its parking cost to the calculated average.\n5. **Retrieve event names**: For events where the parking cost is less than the average, retrieve the `event_name` from the `event` table.\n\nWe will join the `event` and `budget` tables to achieve this, filtering for parking costs and comparing them to the average.",
    "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.category = 'Parking'\nAND b.spent < (SELECT AVG(spent) FROM budget WHERE category = 'Parking');",
    "question": "List the name of events with less than average parking cost.",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T2.category = 'Parking' AND T3.cost < (SELECT AVG(cost) FROM expense)",
    "evidence": [
      "name of events refers to event_name; less than average parking cost refers to cost < DIVIDE(SUM(cost), COUNT(event_id)) where category = 'Parking'"
    ]
  },
  "686": {
    "reason": "To solve the question, we need to identify the total number of posts with views above the average view count. The steps are as follows:\n1. Calculate the average view count from the `posts` table using the `AVG(ViewCount)` function.\n2. Use this average to filter posts where `ViewCount` is greater than the calculated average.\n3. Count the number of such posts using the `COUNT(*)` function.\n\nThe query will involve a subquery to compute the average view count and then filter and count the posts based on this value.",
    "sql": "SELECT COUNT(*) AS TotalPostsAboveAverageViews\nFROM posts\nWHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
    "question": "Identify the total number of posts with views above average.",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
    "evidence": [
      "views above average refer to ViewCount > AVG(ViewCount);"
    ]
  },
  "824": {
    "reason": "To identify superheroes who can control wind and list their names in alphabetical order, we need to follow these steps:\n1. Identify the `power_name` 'Wind Control' in the `superpower` table to get its `id`.\n2. Use the `hero_power` table to find all `hero_id` values associated with this power.\n3. Join the `superhero` table with the results from the previous step to get the names of these superheroes.\n4. Order the results alphabetically by `superhero_name`.",
    "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Wind Control'\nORDER BY s.superhero_name ASC;",
    "question": "Identify superheroes who can control wind and list their names in alphabetical order.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Wind Control' ORDER BY T1.superhero_name",
    "evidence": [
      "superheroes refers to superhero_name; can control wind refers to power_name = 'Wind Control';"
    ]
  },
  "1059": {
    "reason": "To solve the question, we need to list player names whose height is greater than 180. The height information is stored in the `Player` table under the `height` column. The query will involve selecting the `player_name` from the `Player` table where the `height` is greater than 180.",
    "sql": "SELECT player_name FROM Player WHERE height > 180;",
    "question": "Please list player names which are higher than 180.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT player_name FROM Player WHERE height > 180",
    "evidence": [
      "height>180;"
    ]
  },
  "1449": {
    "reason": "To solve the question, we need to find the names and majors of members who had expenses exceeding $100. This involves joining the `member` table with the `expense` table to filter for expenses with a cost greater than 100. Additionally, we need to join the `major` table to get the major names for these members. The steps are:\n1. Join the `member` table with the `expense` table on `member_id`.\n2. Filter the results where the `cost` in the `expense` table is greater than 100.\n3. Join the result with the `major` table to get the major names.\n4. Select the `first_name`, `last_name`, and `major_name` columns.",
    "sql": "SELECT m.first_name, m.last_name, ma.major_name\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE e.cost > 100;",
    "question": "What is the name and major of members who had to spend more than a hundred dollars on an expense?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.first_name, T1.last_name, T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE T3.cost > 100",
    "evidence": [
      "full name refers to first_name, last_name; major of members refers to major_name; spend more than a hundred dollars on an expense refers to cost > 100"
    ]
  },
  "101": {
    "reason": "To find the accounts with the earliest trading date in 1995, we need to:\n1. Identify the earliest date in the `trans` table for the year 1995.\n2. Filter the `trans` table to include only transactions from that date.\n3. Join the `account` table to get the account details for these transactions.\n4. Select the relevant account information.",
    "sql": "SELECT a.account_id, a.district_id, a.frequency, a.date\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nWHERE t.date = (SELECT MIN(date) FROM trans WHERE strftime('%Y', date) = '1995')\nAND strftime('%Y', t.date) = '1995';",
    "question": "List out the accounts who have the earliest trading date in 1995 ?",
    "db_id": "financial",
    "res": 0,
    "ground_truth": "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1",
    "evidence": [
      ""
    ]
  },
  "160": {
    "reason": "To solve the question, we need to find the number of weekly issuance accounts that have a loan of under 200,000. Here's the step-by-step reasoning:\n\n1. **Identify weekly issuance accounts**: The `account` table has a column `frequency` where the value 'POPLATEK TYDNE' indicates weekly issuance.\n2. **Find accounts with loans under 200,000**: The `loan` table contains loan information, including the `amount` column. We need to filter loans where `amount` is less than 200,000.\n3. **Join the tables**: We need to join the `account` table with the `loan` table on `account_id` to find accounts that meet both criteria (weekly issuance and loan under 200,000).\n4. **Count the distinct accounts**: Finally, we count the distinct `account_id` values to get the number of such accounts.",
    "sql": "SELECT COUNT(DISTINCT a.account_id) AS weekly_accounts_with_loan_under_200000\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND l.amount < 200000;",
    "question": "Among the weekly issuance accounts, how many have a loan of under 200000?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.amount < 200000",
    "evidence": [
      "frequency = 'POPLATEK TYDNE' stands for weekly issuance"
    ]
  },
  "1291": {
    "reason": "To solve the question, we need to find the number of male patients with normal levels of albumin (ALB) and total protein (TP). The steps are as follows:\n1. Identify male patients from the `Patient` table where `SEX` is 'M'.\n2. Join the `Patient` table with the `Laboratory` table to access the laboratory test results for these patients.\n3. Filter the results to include only those records where ALB is between 3.5 and 5.5, and TP is between 6.0 and 8.5.\n4. Count the distinct patient IDs to ensure each patient is counted only once, regardless of how many tests they have.",
    "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' \nAND L.ALB > 3.5 AND L.ALB < 5.5 \nAND L.TP BETWEEN 6.0 AND 8.5;",
    "question": "How many male patients have a normal level of both albumin and total protein?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M'  AND T2.ALB > 3.5 AND T2.ALB < 5.5 AND T2.TP BETWEEN 6.0 AND 8.5",
    "evidence": [
      "male refers to Sex = 'M'; normal level of both albumin and total protein refers to ALB > 3.5 and ALB < 5.5 AND TP between 6.0 and 8.5;"
    ]
  },
  "1462": {
    "reason": "To find the category and the budgeted amount for the 'January Speaker' event, we need to follow these steps:\n1. Identify the event_id of the 'January Speaker' event from the 'event' table.\n2. Use this event_id to find the corresponding budget record in the 'budget' table.\n3. Retrieve the 'category' and 'amount' fields from the budget record associated with the event.\n\nThe query will involve joining the 'event' and 'budget' tables to link the event name to its budget details.",
    "sql": "SELECT b.category, b.amount\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'January Speaker';",
    "question": "What category was budgeted for the 'January Speaker' event and how much was the amount budgeted for that category?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T2.category, T2.amount FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'January Speaker'",
    "evidence": [
      "amount budgeted refers to amount, 'January Speaker' is the event name;"
    ]
  },
  "177": {
    "reason": "To solve the question, we need to follow these steps:\n1. Identify the account associated with client number 4 by joining the `client`, `disp`, and `account` tables.\n2. Find the transaction with ID 851 for this account from the `trans` table.\n3. Retrieve the balance after this transaction to determine the sum.\n4. Check the gender of the client (from the `client` table) to determine if the account owner is a man or a woman.\n\nThe query will involve joining multiple tables to gather the required information.",
    "sql": "SELECT \n    t.balance AS sum_after_transaction,\n    c.gender AS account_owner_gender\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    client c ON d.client_id = c.client_id\nWHERE \n    c.client_id = 4\n    AND t.trans_id = 851;",
    "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
    "evidence": [
      ""
    ]
  },
  "987": {
    "reason": "To solve the question, we need to find the average fastest lap time of the top 10 drivers in the 2006 United States Grand Prix. Here's the step-by-step reasoning:\n\n1. **Identify the race**: First, we need to find the raceId for the 2006 United States Grand Prix from the `races` table.\n2. **Identify the top 10 drivers**: We need to determine the top 10 drivers based on their finishing positions in the race. This can be found in the `results` table, where the `raceId` matches the identified race and the `position` is within the top 10.\n3. **Extract fastest lap times**: For these top 10 drivers, we need to retrieve their fastest lap times from the `results` table.\n4. **Calculate the average**: Finally, we calculate the average of these fastest lap times.\n\nThe query will involve joining the `races` and `results` tables to filter the relevant data and then computing the average.",
    "sql": "SELECT AVG(fastestLapTime) AS average_fastest_lap_time\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE year = 2006 AND name = 'United States Grand Prix')\nAND position <= 10\nAND fastestLapTime IS NOT NULL;",
    "question": "What is the average fastest lap time of the top 10 drivers in the 2006 United States Grand Prix?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT AVG(T1.fastestLapTime) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank < 11 AND T2.year = 2006 AND T2.name = 'United States Grand Prix'",
    "evidence": [
      "top 10 refers to rank <11; AVG(fastestLapTime);"
    ]
  },
  "218": {
    "reason": "To solve the question, we need to find the percentage of carcinogenic-type molecules (where `label = '+'`) that do not contain fluorine (where `element = 'f'`). The steps are as follows:\n1. Identify all carcinogenic molecules (`label = '+'`).\n2. For each of these molecules, check if they contain any fluorine atoms (`element = 'f'`).\n3. Count the number of carcinogenic molecules that do not contain fluorine.\n4. Calculate the percentage by dividing the count from step 3 by the total number of carcinogenic molecules and multiplying by 100.\n5. Ensure distinct molecules are considered to avoid duplicates.\n\nThe query will involve joining the `molecule` table with the `atom` table to check for fluorine atoms and then performing the necessary calculations.",
    "sql": "WITH carcinogenic_molecules AS (\n  SELECT DISTINCT m.molecule_id\n  FROM molecule m\n  WHERE m.label = '+'\n),\nfluorine_molecules AS (\n  SELECT DISTINCT a.molecule_id\n  FROM atom a\n  WHERE a.element = 'f'\n)\nSELECT \n  (COUNT(DISTINCT cm.molecule_id) - COUNT(DISTINCT fm.molecule_id)) * 100.0 / COUNT(DISTINCT cm.molecule_id) AS percentage\nFROM carcinogenic_molecules cm\nLEFT JOIN fluorine_molecules fm ON cm.molecule_id = fm.molecule_id;",
    "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
    "evidence": [
      "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;"
    ]
  },
  "1443": {
    "reason": "To solve the question, we need to retrieve the event ID, location, and status of events that were conducted between November 2019 and March 2020. The `event_date` column in the `event` table stores the date of the event, which we will use to filter the events within the specified date range. The date format in the database is not specified, but we will assume it is in a standard format (e.g., YYYY-MM-DD) for comparison. We will use the `BETWEEN` operator to filter events within the date range from '2019-11-01' to '2020-03-31'.",
    "sql": "SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';",
    "question": "Give the event ID, location, and status of events conducted from November 2019 to March 2020.",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT event_id, location, status FROM event WHERE date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-11-01' AND '2020-03-31'",
    "evidence": [
      "event_date BETWEEN '2019-11-01' and '2020-03-31'"
    ]
  },
  "307": {
    "reason": "To solve the question, we need to find the elements of the atoms that form the bond with `bond_id` 'TR000_2_3'. The bond is referenced in the `connected` table, which links two atoms (`atom_id` and `atom_id2`) via a `bond_id`. We will join the `connected` table with the `atom` table twice (once for each atom in the bond) to retrieve the elements of both atoms involved in the bond.",
    "sql": "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR000_2_3';",
    "question": "Name the atoms' elements that form bond TR000_2_3.",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3'",
    "evidence": [
      "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
    ]
  },
  "838": {
    "reason": "To find the full name of the superhero named 'Alien', we need to query the `superhero` table where the `superhero_name` is 'Alien'. The `full_name` column in the `superhero` table contains the full name of the superhero. The query will filter the `superhero` table for the record where `superhero_name` is 'Alien' and return the `full_name`.",
    "sql": "SELECT full_name FROM superhero WHERE superhero_name = 'Alien';",
    "question": "Provide the full name of the superhero named Alien.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT full_name FROM superhero WHERE superhero_name = 'Alien'",
    "evidence": [
      ""
    ]
  },
  "328": {
    "reason": "To solve the question, we need to list all elements with double bonds in the molecule TR024. Here's the step-by-step reasoning:\n\n1. **Identify the molecule**: The molecule of interest is TR024, which is referenced by its `molecule_id` in the `molecule` table.\n2. **Find atoms in the molecule**: We need to find all atoms (`atom_id`) that belong to the molecule TR024 from the `atom` table.\n3. **Identify bonds in the molecule**: We need to find all bonds (`bond_id`) in the molecule TR024 from the `bond` table, specifically those with `bond_type` = '=' (double bond).\n4. **Connect atoms and bonds**: Using the `connected` table, we can link atoms to bonds. We need to find all atoms connected by double bonds.\n5. **Retrieve elements**: Finally, we retrieve the `element` values for these atoms from the `atom` table.\n\nPutting it all together, the query will join the `molecule`, `atom`, `bond`, and `connected` tables to filter for the molecule TR024 and double bonds, then list the distinct elements involved.",
    "sql": "SELECT DISTINCT a.element\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE m.molecule_id = 'TR024' AND b.bond_type = '=';",
    "question": "List all the elements with double bond, consisted in molecule TR024.",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='",
    "evidence": [
      "double bond refers to bond_type = '='; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
    ]
  },
  "1019": {
    "reason": "To find the average lap time in milliseconds of all lap records set on circuits in Italy, we need to:\n1. Identify circuits located in Italy from the `circuits` table.\n2. Join the `circuits` table with the `races` table to find races held on these circuits.\n3. Join the `races` table with the `lapTimes` table to get lap times for these races.\n4. Calculate the average of the `milliseconds` column from the `lapTimes` table for these records.",
    "sql": "SELECT AVG(l.milliseconds) AS average_lap_time_ms\nFROM lapTimes l\nJOIN races r ON l.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Italy';",
    "question": "What is the average lap time in milliseconds of all the lap records set on the various circuits in Italy?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy'",
    "evidence": [
      "average = AVG(milliseconds)"
    ]
  },
  "728": {
    "reason": "To solve the question, we need to rank superheroes from Marvel Comics by the popularity of their eye colors, starting with the most common color. Here's the step-by-step reasoning:\n\n1. **Identify Marvel Comics superheroes**: Filter superheroes where the `publisher_id` corresponds to 'Marvel Comics' in the `publisher` table.\n2. **Count eye color occurrences**: For each eye color, count how many Marvel Comics superheroes have that eye color.\n3. **Rank by popularity**: Order the results by the count of superheroes in descending order to start with the most common eye color.\n4. **Join tables**: We need to join the `superhero` table with the `colour` table (for eye color) and the `publisher` table (to filter by 'Marvel Comics').\n5. **Group by eye color**: Group the results by eye color to perform the count.\n\nThe final query will involve joining these tables, filtering for Marvel Comics, grouping by eye color, and ordering by the count of superheroes.",
    "sql": "SELECT c.colour AS eye_colour, COUNT(s.id) AS superhero_count\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'Marvel Comics'\nGROUP BY c.colour\nORDER BY superhero_count DESC;",
    "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
    "db_id": "superhero",
    "res": 0,
    "ground_truth": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
    "evidence": [
      "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; most common color refers to COUNT(superhero.id) DESC;"
    ]
  },
  "327": {
    "reason": "To solve the question, we need to identify non-carcinogenic molecules that consist of more than 5 atoms. Here's the step-by-step reasoning:\n\n1. **Identify non-carcinogenic molecules**: The `molecule` table has a `label` column where `label = '-'` indicates non-carcinogenic molecules.\n2. **Count atoms per molecule**: The `atom` table links atoms to molecules via the `molecule_id` column. We need to count the number of atoms for each molecule.\n3. **Filter molecules with more than 5 atoms**: After counting, we filter molecules where the count exceeds 5.\n4. **Combine the conditions**: We join the `molecule` and `atom` tables, apply the non-carcinogenic condition, group by `molecule_id`, and filter for counts greater than 5.\n\nThe final SQL query will join these tables and apply the necessary conditions.",
    "sql": "SELECT m.molecule_id, m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '-'\nGROUP BY m.molecule_id, m.label\nHAVING COUNT(a.atom_id) > 5;",
    "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
    "evidence": [
      "label = '-' means molecules are non-carcinogenic; molecules consisted more than 5 atoms refers to COUNT(molecule_id) > 5"
    ]
  },
  "630": {
    "reason": "To find the name of tags used by John Salvatier, we need to follow these steps:\n1. Identify the user with the display name 'John Salvatier' in the `users` table to get their `Id`.\n2. Use this `Id` to find all posts owned by this user in the `posts` table.\n3. Extract the `Tags` from these posts, which contain the tags used by the user.\n4. Since the `Tags` field in the `posts` table is a text field containing multiple tags, we might need to parse it to get individual tag names.\n5. Alternatively, if the tags are stored in a normalized form in the `tags` table, we can join the `posts` table with the `tags` table to get the tag names.\n\nGiven the schema, the `Tags` field in the `posts` table is a text field, so we will directly extract and display the tags from the posts owned by John Salvatier.",
    "sql": "SELECT DISTINCT p.Tags\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'John Salvatier';",
    "question": "What is the name of tags used by John Salvatier's?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'John Salvatier'",
    "evidence": [
      "DisplayName = 'John Salvatier';"
    ]
  },
  "276": {
    "reason": "To solve the question, we need to find the atom IDs of the first and second atoms involved in triple bonds. The steps are as follows:\n1. Identify bonds with `bond_type = '#'` (triple bonds) from the `bond` table.\n2. Use the `connected` table to find the pairs of atoms (`atom_id` and `atom_id2`) connected by these triple bonds.\n3. Join the `bond` and `connected` tables on `bond_id` to filter for triple bonds.\n4. Select the `atom_id` and `atom_id2` from the `connected` table for these bonds.",
    "sql": "SELECT c.atom_id, c.atom_id2\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '#';",
    "question": "Write down the atom IDs of the first and second atoms of triple bond type molecules.",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
    "evidence": [
      "first atom refers to atom_id; second atom refers to atom_id2; triple bond refers to bond_type = '#';"
    ]
  },
  "1069": {
    "reason": "To find the football player with the shortest height, we need to query the `Player` table and retrieve the player(s) with the minimum height. The `height` column in the `Player` table stores the height of each player. We can use the `MIN(height)` function to find the shortest height and then retrieve the corresponding player(s).",
    "sql": "SELECT player_name, MIN(height) AS shortest_height FROM Player;",
    "question": "Which football player has the shortest height?",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT player_name FROM player ORDER BY height ASC LIMIT 1",
    "evidence": [
      "shortest height refers to MIN(height);"
    ]
  },
  "1066": {
    "reason": "To find the passing class of the CLB team, we need to follow these steps:\n1. Identify the team with the short name 'CLB' in the `Team` table to get its `team_api_id`.\n2. Use this `team_api_id` to query the `Team_Attributes` table to retrieve the `buildUpPlayPassingClass` attribute, which represents the passing class.\n3. The query will join the `Team` and `Team_Attributes` tables to ensure we are looking at the correct team.",
    "sql": "SELECT t.team_short_name, ta.buildUpPlayPassingClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_short_name = 'CLB';",
    "question": "What is the passing class of CLB team?",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT DISTINCT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'CLB'",
    "evidence": [
      "passing class refers to buildUpPlayPassingClass; CLB refers to team_short_name = 'CLB';"
    ]
  },
  "756": {
    "reason": "To find the number of bad superheroes, we need to identify superheroes whose `alignment_id` corresponds to 'Bad' in the `alignment` table. The steps are:\n1. Join the `superhero` table with the `alignment` table to match superheroes with their alignment.\n2. Filter the results where the `alignment` is 'Bad'.\n3. Count the number of such superheroes.",
    "sql": "SELECT COUNT(*) AS bad_superheroes_count\nFROM superhero\nWHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'Bad');",
    "question": "How many bad superheroes are there?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Bad'",
    "evidence": [
      "bad superheroes refers to alignment_id = Bad"
    ]
  },
  "1216": {
    "reason": "To solve the question, we need to find all male patients with albumin (ALB) levels not within the specified range (ALB <= 3.5 or ALB >= 5.5). The results should be sorted by their birthdays in descending order. Here's the step-by-step reasoning:\n\n1. **Identify the tables involved**: We need data from the `Patient` table (for SEX and Birthday) and the `Laboratory` table (for ALB values).\n2. **Filter conditions**:\n   - SEX must be 'M' (male).\n   - ALB must be <= 3.5 or >= 5.5.\n3. **Join the tables**: We need to join the `Patient` and `Laboratory` tables on the `ID` field to combine the relevant data.\n4. **Sort the results**: The final output should be sorted by the `Birthday` field in descending order.\n5. **Select the required fields**: We should include the patient's ID, Birthday, and ALB values in the output for clarity.",
    "sql": "SELECT P.ID, P.Birthday, L.ALB\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND (L.ALB <= 3.5 OR L.ALB >= 5.5)\nORDER BY P.Birthday DESC;",
    "question": "Sort in descending order all patients by birthday for male patient with albumin not within range.",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5) ORDER BY T1.Birthday DESC",
    "evidence": [
      "male = SEX = 'M'; albumin not within range refers to ALB < = 3.5 or ALB > = 5.5"
    ]
  },
  "1389": {
    "reason": "To find the event with the lowest cost, we need to follow these steps:\n1. Identify the tables involved: `event`, `expense`, and `budget`.\n2. The `expense` table contains the `cost` column, which we need to find the minimum value of.\n3. The `expense` table is linked to the `budget` table via `link_to_budget`, and the `budget` table is linked to the `event` table via `link_to_event`.\n4. We need to join these tables to connect the expense cost to the event name.\n5. Finally, we will use the `MIN(cost)` function to find the lowest cost and retrieve the corresponding event name.",
    "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.cost = (SELECT MIN(cost) FROM expense);",
    "question": "Which event has the lowest cost?",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
    "evidence": [
      "event refers to event_name; lowest cost means MIN(cost)"
    ]
  },
  "1128": {
    "reason": "To find the country with the heaviest average weight of players, we need to:\n1. Join the `Player` table with the `Match` table to associate players with their matches.\n2. Join the `Match` table with the `Country` table to associate matches with countries.\n3. Calculate the average weight of players for each country.\n4. Identify the country with the highest average weight.\n\nThe query will group players by their country and then calculate the average weight for each group. Finally, it will order the results in descending order of average weight and limit the result to the top country.",
    "sql": "SELECT c.name AS country_name, AVG(p.weight) AS average_weight\nFROM Player p\nJOIN Match m ON p.player_api_id IN (\n    m.home_player_1, m.home_player_2, m.home_player_3, m.home_player_4, m.home_player_5,\n    m.home_player_6, m.home_player_7, m.home_player_8, m.home_player_9, m.home_player_10, m.home_player_11,\n    m.away_player_1, m.away_player_2, m.away_player_3, m.away_player_4, m.away_player_5,\n    m.away_player_6, m.away_player_7, m.away_player_8, m.away_player_9, m.away_player_10, m.away_player_11\n)\nJOIN Country c ON m.country_id = c.id\nGROUP BY c.name\nORDER BY average_weight DESC\nLIMIT 1;",
    "question": "Which country's players have the heaviest average weights?",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id GROUP BY t1.name ORDER BY AVG(t3.weight) DESC LIMIT 1",
    "evidence": [
      "heaviest average weights refers to MAX(AVG(weight))"
    ]
  },
  "486": {
    "reason": "To find the percentage of cards with a converted mana cost of 7 in the set Coldsnap, we need to follow these steps:\n1. Identify the total number of cards in the Coldsnap set.\n2. Identify the number of cards in the Coldsnap set with a converted mana cost of 7.\n3. Calculate the percentage by dividing the number of cards with a converted mana cost of 7 by the total number of cards in the set, then multiplying by 100.\n\nThe query will involve joining the `cards` table with the `sets` table to filter cards by the set code 'Coldsnap' (assuming the set code is 'CSP' or similar).",
    "sql": "SELECT \n    (COUNT(CASE WHEN c.convertedManaCost = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards c\nJOIN \n    sets s ON c.setCode = s.code\nWHERE \n    s.code = 'CSP';",
    "question": "What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
    "evidence": [
      "converted mana cost of 7 refers to convertedManaCost = 7; card set Coldsnap refers to name = 'Coldsnap'; percentage = DIVIDE(SUM(convertedManaCost = 7), SUM(convertedManaCost))*100"
    ]
  },
  "1048": {
    "reason": "To find the overall rating of the football player Gabriel Tamas in the year 2011, we need to follow these steps:\n1. Identify the player_api_id of Gabriel Tamas from the Player table.\n2. Use this player_api_id to find his attributes in the Player_Attributes table for the year 2011.\n3. Extract the overall_rating from the Player_Attributes table for the specified year.\n\nThe query will involve joining the Player and Player_Attributes tables and filtering for the specific player and year.",
    "sql": "SELECT pa.overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Gabriel Tamas' AND strftime('%Y', pa.date) = '2011';",
    "question": "What is the overall rating of the football player Gabriel Tamas in year 2011?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Gabriel Tamas' AND strftime('%Y', t2.date) = '2011'",
    "evidence": [
      "in year 2011 refers to strftime('%Y', date) = '2011';"
    ]
  },
  "1203": {
    "reason": "To solve the question, we need to find the number of female patients with white blood cell (WBC) counts below 3.5. The steps are as follows:\n1. Identify female patients from the `Patient` table where `SEX` is 'F'.\n2. Join the `Patient` table with the `Laboratory` table on the `ID` field to access the WBC data.\n3. Filter the results to include only records where `WBC` is less than 3.5.\n4. Count the distinct patient IDs to ensure each patient is only counted once, regardless of how many times their WBC was measured below 3.5.",
    "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'F' AND L.WBC < 3.5;",
    "question": "How many patients who were female got white blood cells that were below 3.5?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC < 3.5 AND T1.SEX = 'F'",
    "evidence": [
      "female refers to SEX = 'F'; white blood cells that were below 3.5 refers to WBC < 3.5"
    ]
  },
  "1210": {
    "reason": "To solve the question, we need to calculate the average index of lactate dehydrogenase (LDH) for all patients where the LDH value is within the normal range (LDH < 500). The LDH values are stored in the Laboratory table. We will use the AVG function to compute the average of LDH values that meet the condition (LDH < 500). The query will filter the Laboratory table to include only records where LDH is less than 500 and then compute the average of these values.",
    "sql": "SELECT AVG(LDH) AS average_LDH FROM Laboratory WHERE LDH < 500;",
    "question": "What is the average index of the lactate dehydrogenase (LDH) for all patients with lactate dehydrogenase (LDH) within the normal range.",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT AVG(LDH) FROM Laboratory WHERE LDH < 500",
    "evidence": [
      "average index of the lactate dehydrogenase (LDH) refers to AVG(LDH); (LDH) within the normal range refers to LDH < 500"
    ]
  },
  "385": {
    "reason": "To find the ruling of the card \"Beacon of Immortality\", we need to query the `rulings` table. However, the `rulings` table references the `cards` table via the `uuid` column. Therefore, we first need to find the `uuid` of the card \"Beacon of Immortality\" from the `cards` table. Once we have the `uuid`, we can use it to retrieve the ruling text from the `rulings` table. The steps are:\n1. Query the `cards` table to get the `uuid` of the card with the name \"Beacon of Immortality\".\n2. Use this `uuid` to query the `rulings` table for the ruling text.",
    "sql": "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Beacon of Immortality';",
    "question": "Write down the ruling of Beacon of Immortality.",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
    "evidence": [
      "Beacon of Immortality' is the name of card;"
    ]
  },
  "946": {
    "reason": "To list the location coordinates of the US circuits, we need to query the `circuits` table. The question specifies that the US refers to the country 'USA'. The location coordinates are stored in the `lat` (latitude) and `lng` (longitude) columns. Therefore, we will select these columns along with the circuit name for clarity, filtering the results where the `country` column is 'USA'.",
    "sql": "SELECT name, lat, lng FROM circuits WHERE country = 'USA';",
    "question": "Please list the location coordinates of the US circuits.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT lat, lng FROM circuits WHERE country = 'USA'",
    "evidence": [
      "location coordinates refers to (lat, lng); the US refers to country = 'USA';"
    ]
  },
  "817": {
    "reason": "To solve the question, we need to find the race of the blue-haired male superhero. Here's the step-by-step reasoning:\n\n1. Identify the superheroes with blue hair: This involves joining the `superhero` table with the `colour` table where `hair_colour_id` matches the `id` in the `colour` table and the `colour` is 'blue'.\n2. Filter for male superheroes: This involves joining the `superhero` table with the `gender` table where `gender_id` matches the `id` in the `gender` table and the `gender` is 'male'.\n3. Retrieve the race of these superheroes: This involves joining the `superhero` table with the `race` table where `race_id` matches the `id` in the `race` table.\n4. Combine these conditions in a single query to get the desired result.",
    "sql": "SELECT r.race\nFROM superhero s\nJOIN colour c_hair ON s.hair_colour_id = c_hair.id\nJOIN gender g ON s.gender_id = g.id\nJOIN race r ON s.race_id = r.id\nWHERE c_hair.colour = 'blue' AND g.gender = 'male';",
    "question": "Give the race of the blue-haired male superhero.",
    "db_id": "superhero",
    "res": 0,
    "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T2.colour = 'Blue' AND T4.gender = 'Male'",
    "evidence": [
      "blue-haired refers to colour.colour = 'blue' WHERE hair_colour_id = colour.id; male refers to gender = 'male';"
    ]
  },
  "1394": {
    "reason": "To find the number of members in the Student_Club who have a major in 'Physics Teaching', we need to:\n1. Identify the major_id for 'Physics Teaching' from the 'major' table.\n2. Join the 'member' table with the 'major' table using the link_to_major field.\n3. Count the number of members where the major_name is 'Physics Teaching'.",
    "sql": "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Physics Teaching';",
    "question": "How many members of the Student_Club have major in 'Physics Teaching'?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Physics Teaching'",
    "evidence": [
      "'Physics Teaching' is the major_name;"
    ]
  },
  "505": {
    "reason": "To find the Simplified Chinese translation of the set \"Mirrodin\", we need to query the `set_translations` table. The `set_translations` table contains translations for set names in different languages. We will filter the records where the `language` is 'Chinese Simplified' and the `setCode` corresponds to the set \"Mirrodin\". To get the `setCode` for \"Mirrodin\", we first query the `sets` table where the `name` is 'Mirrodin' and then use the `code` from that result to filter the `set_translations` table.",
    "sql": "SELECT st.translation FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE st.language = 'Chinese Simplified' AND s.name = 'Mirrodin';",
    "question": "Show the Simplified Chinese translation of the name of the set \"Mirrodin\"?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT code FROM sets WHERE name = 'Mirrodin' ) AND language = 'Chinese Simplified'",
    "evidence": [
      "Simplified Chinese translation refers to language = 'Chinese Simplified'; name of the set \"Mirrodin\" refers to name = 'Mirrodin'"
    ]
  },
  "204": {
    "reason": "To solve the question, we need to count the number of carcinogenic molecules among the first 100 molecules in number order. According to the tips, the first 100 molecules have molecule_id values between 'TR000' and 'TR099', and a molecule is carcinogenic if its label is '+'. Therefore, the query should filter molecules where molecule_id is between 'TR000' and 'TR099' and label is '+', then count them.",
    "sql": "SELECT COUNT(*) FROM molecule WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND label = '+';",
    "question": "Of the first 100 molecules in number order, how many are carcinogenic?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'",
    "evidence": [
      "first 100 molecules in number order refers to molecule_id between 'TR000' and 'TR099'; label = '+' means molecules are carcinogenic"
    ]
  },
  "391": {
    "reason": "To solve the question, we need to identify Artifact cards that are black in color and have foreign language translations. Here's the step-by-step reasoning:\n\n1. **Identify Artifact cards**: The `cards` table has a column `originalType` which can be used to filter cards of type 'Artifact'.\n2. **Filter black color cards**: The `colors` column in the `cards` table can be checked for 'B' (black).\n3. **Check for foreign language translations**: The `foreign_data` table contains language information, and we can join it with the `cards` table using the `uuid` column to ensure the card has at least one foreign language entry.\n4. **Combine conditions**: The query will join the `cards` and `foreign_data` tables, filtering for cards that meet all the above conditions.\n\nThe final query will select the relevant columns from the `cards` table for these filtered cards.",
    "sql": "SELECT DISTINCT c.*\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.originalType = 'Artifact'\n  AND c.colors = 'B'\n  AND fd.language IS NOT NULL;",
    "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
    "evidence": [
      "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data"
    ]
  },
  "1126": {
    "reason": "To find the names of players who came from Belgium, we need to follow these steps:\n1. Identify the country_id for Belgium from the `Country` table.\n2. Use this country_id to find the league(s) associated with Belgium in the `League` table.\n3. Use the league_id(s) to find matches in the `Match` table that are associated with these leagues.\n4. From these matches, identify the home and away teams.\n5. Use the team_api_id(s) to find the players associated with these teams in the `Player` table.\n6. Finally, retrieve the player names from the `Player` table.\n\nHowever, the schema does not directly link players to countries or leagues. Instead, players are linked to teams, and teams are linked to matches, which are linked to leagues and countries. Therefore, the query will involve joining these tables to trace the path from country to player.",
    "sql": "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Match m ON p.player_api_id IN (\n    m.home_player_1, m.home_player_2, m.home_player_3, m.home_player_4, m.home_player_5,\n    m.home_player_6, m.home_player_7, m.home_player_8, m.home_player_9, m.home_player_10, m.home_player_11,\n    m.away_player_1, m.away_player_2, m.away_player_3, m.away_player_4, m.away_player_5,\n    m.away_player_6, m.away_player_7, m.away_player_8, m.away_player_9, m.away_player_10, m.away_player_11\n)\nJOIN League l ON m.league_id = l.id\nJOIN Country c ON l.country_id = c.id\nWHERE c.name = 'Belgium';",
    "question": "State the name of players who came from Belgium.",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Belgium'",
    "evidence": [
      "name of players refers to player_name; Belgium is name of country"
    ]
  },
  "1465": {
    "reason": "To determine which budget category the expense 'Posters' falls under, we need to follow these steps:\n1. Identify the expense 'Posters' in the `expense` table using the `expense_description` column.\n2. Retrieve the `link_to_budget` associated with this expense.\n3. Use the `link_to_budget` to find the corresponding budget record in the `budget` table.\n4. Extract the `category` from the budget record to determine the category of the expense.",
    "sql": "SELECT b.category\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nWHERE e.expense_description = 'Posters';",
    "question": "Which budget category does the expense 'Posters' fall to?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Posters'",
    "evidence": [
      "'Posters' refers to expense description"
    ]
  },
  "952": {
    "reason": "To find which constructors have been ranked 1, we need to look at the `constructorStandings` table, which contains the standings of constructors in each race. The `position` column in this table indicates the rank of the constructor. We need to filter for rows where `position` is 1 and then join this with the `constructors` table to get the names of the constructors.",
    "sql": "SELECT DISTINCT c.name \nFROM constructors c \nJOIN constructorStandings cs ON c.constructorId = cs.constructorId \nWHERE cs.position = 1;",
    "question": "Which constructors have been ranked 1?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T2.name FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.rank = 1",
    "evidence": [
      ""
    ]
  },
  "138": {
    "reason": "To solve the question, we need to find the branch (district) where the second-highest number of crimes were committed in 1995 (A15 column in the district table) and then count the number of male clients in that district. Here's the step-by-step reasoning:\n\n1. Identify the district with the second-highest number of crimes in 1995 (A15 column).\n2. Use this district_id to find all clients (from the client table) who are male (gender = 'M') and belong to this district.\n3. Count the number of such male clients.\n\nThe SQL query will involve:\n- Subquery to find the district_id with the second-highest A15 value.\n- Joining the client table to filter male clients in this district.\n- Counting the results.",
    "sql": "WITH SecondHighestCrimeDistrict AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A15 DESC\n    LIMIT 1 OFFSET 1\n)\nSELECT COUNT(*) AS male_clients_count\nFROM client\nWHERE gender = 'M' AND district_id = (SELECT district_id FROM SecondHighestCrimeDistrict);",
    "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
    "evidence": [
      "Male refers to gender = 'M'; A15 stands for no. of commited crimes 1995"
    ]
  },
  "420": {
    "reason": "To solve the question, we need to count the number of cards that meet three specific conditions: they are oversized, reprinted, and printed for promotions. These conditions correspond to the columns `isOversized`, `isReprint`, and `isPromo` in the `cards` table. All three columns are of type INTEGER with a default value of 0, and a value of 1 indicates that the condition is true. Therefore, we need to count the rows where all three columns have a value of 1.",
    "sql": "SELECT COUNT(*) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1;",
    "question": "How many cards are oversized, reprinted, and printed for promotions?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1",
    "evidence": [
      "are oversized refers to isOversized = 1; reprinted refers to isReprint = 1; printed for promotions refers to isPromo = 1"
    ]
  },
  "472": {
    "reason": "To solve the question, we need to find the number of sets in the block \"Ice Age\" that have an Italian translation. This involves two main steps:\n1. Identify all sets in the \"Ice Age\" block from the `sets` table.\n2. Check which of these sets have an Italian translation in the `set_translations` table (where `language` is 'Italian' and `translation` is not null).\n\nWe will join the `sets` and `set_translations` tables to filter the sets in the \"Ice Age\" block and then count those with Italian translations.",
    "sql": "SELECT COUNT(DISTINCT s.code) AS italian_translated_sets_count\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Ice Age' AND st.language = 'Italian' AND st.translation IS NOT NULL;",
    "question": "Among the sets in the block \"Ice Age\", how many of them have an Italian translation?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block = 'Ice Age' AND T2.language = 'Italian' AND T2.translation IS NOT NULL",
    "evidence": [
      "sets in the block \"Ice Age\" refers to block = 'Ice Age'; Italian translation refers to language = 'Italian' and translation is not null"
    ]
  },
  "1189": {
    "reason": "To solve the question, we need to find the number of patients who meet the following criteria:\n1. Thrombosis level 2 (Thrombosis = 2).\n2. ANA pattern of only S (ANA = 'S').\n3. Anti-Cardiolip in antibody (IgM) level is 20% higher than the average.\n\nSteps:\n1. Calculate the average `aCL IgM` level from the Examination table.\n2. Determine the threshold for the 20% higher level by multiplying the average by 1.2.\n3. Count the number of patients who have Thrombosis = 2, ANA = 'S', and `aCL IgM` greater than the calculated threshold.\n4. Join the Examination table with the Patient table to ensure we are counting unique patients.",
    "sql": "WITH AvgACLIgM AS (\n    SELECT AVG(`aCL IgM`) AS avg_value FROM Examination\n)\nSELECT COUNT(DISTINCT E.ID) AS patient_count\nFROM Examination E\nJOIN Patient P ON E.ID = P.ID\nWHERE E.Thrombosis = 2\nAND E.ANA = 'S'\nAND E.`aCL IgM` > (SELECT avg_value * 1.2 FROM AvgACLIgM);",
    "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')",
    "evidence": [
      "thrombosis level 2 refers to Thrombosis = 2; ANA pattern of only S refers to ANA = 'S'; average anti-Cardiolip in antibody (IgM) refers to AVG(`aCL IgM`); calculation = MULTIPLY(AVG + AVG, 0.2)"
    ]
  },
  "1362": {
    "reason": "To find the number of cities in Orange County, Virginia, we need to query the `zip_code` table. The `zip_code` table contains columns for `county` and `state`, which we can use to filter the data. Specifically, we need to count the distinct `city` values where the `county` is 'Orange County' and the `state` is 'Virginia'.",
    "sql": "SELECT COUNT(DISTINCT city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia';",
    "question": "How many cities are there in Orange County, Virginia?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia'",
    "evidence": [
      "Orange County is the county name, Virginia is the state name"
    ]
  },
  "392": {
    "reason": "To solve the question, we need to find 3 cards with a rarity of 'uncommon' and list their names in ascending order of their ruling dates. Here's the step-by-step reasoning:\n\n1. **Filter by Rarity**: First, we need to select cards from the `cards` table where the `rarity` column is 'uncommon'.\n2. **Join with Rulings**: Next, we join the filtered cards with the `rulings` table using the `uuid` column to get the ruling dates for each card.\n3. **Order by Ruling Date**: We then order the results by the `date` column from the `rulings` table in ascending order.\n4. **Limit Results**: Finally, we limit the results to 3 cards to meet the requirement.\n\nThe query will involve joining the `cards` and `rulings` tables, filtering for 'uncommon' rarity, ordering by ruling date, and limiting the output.",
    "sql": "SELECT c.name\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.rarity = 'uncommon'\nORDER BY r.date ASC\nLIMIT 3;",
    "question": "Pick 3 cards with rarity of uncommon, list down name these cards according to ascending order of it's ruling date.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3",
    "evidence": [
      "uncommon refers to rarity = 'uncommon';"
    ]
  },
  "490": {
    "reason": "To find the Magic Card Market (MCM) ID for the set with the code 'SS2', we need to query the 'sets' table. The 'sets' table contains the 'code' column, which identifies each set, and the 'mcmId' column, which stores the Magic Card Market ID. The query should filter the 'sets' table for the row where 'code' is 'SS2' and then retrieve the 'mcmId' value from that row.",
    "sql": "SELECT mcmId FROM sets WHERE code = 'SS2';",
    "question": "For the set which had 'SS2' as the code, what is its magic card market id?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT mcmId FROM sets WHERE code = 'SS2'",
    "evidence": [
      "magic card market id refers to mcmId"
    ]
  },
  "2": {
    "reason": "To solve the question, we need to find the zip codes of all charter schools in Fresno County Office of Education. Here's the step-by-step reasoning:\n\n1. **Identify Charter Schools**: Charter schools are indicated by `Charter School (Y/N)` = 1 in the `frpm` table.\n2. **Filter by County**: The county name is stored in the `County Name` column in the `frpm` table. We need to filter for \"Fresno County Office of Education\".\n3. **Retrieve Zip Codes**: The zip codes are stored in the `Zip` column of the `schools` table.\n4. **Join Tables**: Since the `frpm` table contains the charter school information and the `schools` table contains the zip codes, we need to join these tables on the `CDSCode` column.\n5. **Select Distinct Zip Codes**: To avoid duplicates, we should select distinct zip codes.\n\nFinal SQL query will join the `frpm` and `schools` tables, filter for charter schools in Fresno County, and retrieve the distinct zip codes.",
    "sql": "SELECT DISTINCT s.Zip\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.\"Charter School (Y/N)\" = 1 AND f.\"County Name\" = 'Fresno County Office of Education';",
    "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
    "evidence": [
      "Charter schools refers to `Charter School (Y/N)` = 1 in the table fprm"
    ]
  },
  "1193": {
    "reason": "To solve the question, we need to find the number of women born between 1980 and 1989, excluding patients with an ANA Pattern of 'P'. The steps are as follows:\n1. Join the `Patient` and `Examination` tables to access both the patient's demographic data and their examination details.\n2. Filter the patients to include only those with `SEX = 'F'` (women).\n3. Further filter the patients to include only those born between 1980 and 1989 by checking their `Birthday`.\n4. Exclude patients with an `ANA Pattern` of 'P'.\n5. Count the remaining patients.",
    "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'F' \nAND P.Birthday BETWEEN '1980-01-01' AND '1989-12-31'\nAND (E.`ANA Pattern` IS NULL OR E.`ANA Pattern` != 'P');",
    "question": "Excluding all P only ANA Pattern patients, how many of the remainder are women born between 1980 and 1989?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.`ANA Pattern` != 'P' AND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989' AND T1.SEX = 'F'",
    "evidence": [
      "Excluding all P only ANA Pattern refers to `ANA Pattern`! = 'P'; women refers to SEX = 'F'; born between 1980 and 1989 refers to BIRTHDAY"
    ]
  },
  "812": {
    "reason": "To solve the question, we need to find the full names of superheroes with blue eyes. The steps are as follows:\n1. Identify the `colour` table to find the ID for the colour 'Blue'.\n2. Use this ID to filter superheroes in the `superhero` table where `eye_colour_id` matches the ID for 'Blue'.\n3. Retrieve the `full_name` of these superheroes.\n4. Limit the results to at least five entries.",
    "sql": "SELECT s.full_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE c.colour = 'Blue'\nLIMIT 5;",
    "question": "List down at least five full names of superheroes with blue eyes.",
    "db_id": "superhero",
    "res": 0,
    "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5",
    "evidence": [
      "blue eyes refers to colour.colour = 'Blue' WHERE eye_colour_id = colour.id; Name of superheroes refers to superhero_name;"
    ]
  },
  "1396": {
    "reason": "To solve the question, we need to find the number of events attended by Luisa Guidi and determine her major. Here's the step-by-step reasoning:\n\n1. **Identify Luisa Guidi's member_id**: We need to query the `member` table to find the `member_id` of Luisa Guidi using her first and last name.\n2. **Count the events she attended**: Using the `attendance` table, we can count the number of events linked to her `member_id`.\n3. **Determine her major**: Using the `member` table, we can find the `link_to_major` for Luisa Guidi, and then join with the `major` table to get the `major_name`.\n\nCombining these steps, we will first query the `member` table to get Luisa Guidi's `member_id` and `link_to_major`, then count the events she attended, and finally join with the `major` table to get her major name.",
    "sql": "WITH luisa_info AS (\n    SELECT member_id, link_to_major\n    FROM member\n    WHERE first_name = 'Luisa' AND last_name = 'Guidi'\n)\nSELECT \n    COUNT(a.link_to_event) AS number_of_events_attended,\n    m.major_name\nFROM \n    luisa_info li\nLEFT JOIN \n    attendance a ON li.member_id = a.link_to_member\nLEFT JOIN \n    major m ON li.link_to_major = m.major_id\nGROUP BY \n    m.major_name;",
    "question": "Provide the number of events attended by Luisa Guidi. What is her major?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT COUNT(T3.link_to_event), T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'",
    "evidence": [
      "major refers to major_name;"
    ]
  },
  "380": {
    "reason": "To solve the question, we need to list the `edhrecRank` for cards that have a `frameVersion` of \"2015\". The `frameVersion` and `edhrecRank` columns are both in the `cards` table. Therefore, we can directly query the `cards` table to filter records where `frameVersion` is \"2015\" and then select the `edhrecRank` column.",
    "sql": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
    "question": "List the edhrecRank for cards with frame version 2015.",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
    "evidence": [
      ""
    ]
  },
  "1352": {
    "reason": "To solve the question, we need to find the count of club members who are from the \"Business\" major and wear a medium-sized t-shirt. The steps are as follows:\n1. Identify the major_id for \"Business\" from the major table.\n2. Join the member table with the major table to filter members who are from the \"Business\" major.\n3. Further filter these members by their t_shirt_size being 'Medium'.\n4. Count the number of such members.",
    "sql": "SELECT COUNT(*) \nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' AND m.t_shirt_size = 'Medium';",
    "question": "For all the club members from \"Business\" major, how many of them wear medium size t-shirt?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'",
    "evidence": [
      "'Business' is a major name; wear medium size t-shirt refers to t_shirt_size = 'Medium'"
    ]
  },
  "762": {
    "reason": "To determine which power superheroes have the most of, we need to:\n1. Count the occurrences of each power in the `hero_power` table.\n2. Join the `hero_power` table with the `superpower` table to get the power names.\n3. Group the results by power name and count the occurrences.\n4. Order the results by the count in descending order to find the most common power.\n5. Limit the result to the top entry to get the power with the highest count.",
    "sql": "SELECT sp.power_name, COUNT(hp.power_id) AS power_count\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nGROUP BY sp.power_name\nORDER BY power_count DESC\nLIMIT 1;",
    "question": "Which power do superheroes have the most of?",
    "db_id": "superhero",
    "res": 0,
    "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T1.hero_id) DESC LIMIT 1",
    "evidence": [
      "power that superheroes have the most refers to MAX(COUNT(power_name))"
    ]
  },
  "510": {
    "reason": "To solve the question, we need to find the illustrator of the card art that has the highest converted mana cost among cards that do not have multiple faces. The steps are as follows:\n1. Identify cards that do not have multiple faces. This can be inferred from the `otherFaceIds` column in the `cards` table, where a NULL value indicates no multiple faces.\n2. From these cards, find the one with the highest `convertedManaCost`.\n3. Retrieve the `artist` of this card to identify the illustrator.",
    "sql": "SELECT artist FROM cards WHERE otherFaceIds IS NULL ORDER BY convertedManaCost DESC LIMIT 1;",
    "question": "Among the cards that doesn't have multiple faces on the same card, who is the illustrator of the card art that has the highest cost of converted mana?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1",
    "evidence": [
      "doesn't have multiple faces refers to side IS NULL; illustrator refers to artist"
    ]
  },
  "1011": {
    "reason": "To solve the question, we need to find the top 20 drivers with the shortest lap times ever recorded in Formula 1 races. The steps are as follows:\n1. The `lapTimes` table contains lap time data, including `driverId` and `time`.\n2. We need to join the `lapTimes` table with the `drivers` table to get the full names (forename and surname) of the drivers.\n3. The `time` column in `lapTimes` is in the format 'MM:SS.mmm' or 'M:SS.mmm', and we need to find the minimum (shortest) lap time.\n4. We will order the results by the `time` column in ascending order to get the shortest lap times first.\n5. Finally, we will limit the results to the top 20 drivers.",
    "sql": "SELECT d.forename || ' ' || d.surname AS full_name, lt.time\nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nORDER BY lt.time ASC\nLIMIT 20;",
    "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
    "evidence": [
      "shortest lap time refers to MIN(time); the time format for the shortest lap time is 'MM:SS.mmm' or 'M:SS.mmm'; full name of the driver refers to forename, surname"
    ]
  },
  "972": {
    "reason": "To solve the question, we need to find drivers who were born in 1971 and have the fastest lap time in any race. The steps are as follows:\n1. Identify drivers born in 1971 by filtering the `drivers` table where the year of birth (`dob`) is 1971.\n2. Join the `results` table to check if these drivers have a recorded fastest lap time (`fastestLapTime` is not null).\n3. Retrieve the `driverId` and `code` of these drivers from the `drivers` table.\n4. Ensure the query is optimized to only include relevant data.",
    "sql": "SELECT d.driverId, d.code\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE strftime('%Y', d.dob) = '1971'\nAND r.fastestLapTime IS NOT NULL;",
    "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
    "evidence": [
      "born in 1971 refers to year(dob) = 1971; has the fastest lap time refers to fastestLapTime has values"
    ]
  },
  "7": {
    "reason": "To solve the question, we need to find the phone number of the school with the highest number of test takers who scored over 1500 on the SAT. This involves the following steps:\n1. Identify the school with the highest `NumGE1500` value in the `satscores` table, as this column represents the number of test takers with SAT scores over 1500.\n2. Once the school is identified, retrieve its `CDSCode` or `cds` (primary key) to link it with the `schools` table.\n3. From the `schools` table, retrieve the phone number (`Phone`) of the identified school.\n\nThe query will join the `satscores` and `schools` tables on the `cds` (or `CDSCode`) field to fetch the required information.",
    "sql": "SELECT s.Phone\nFROM schools s\nJOIN satscores sat ON s.CDSCode = sat.cds\nWHERE sat.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);",
    "question": "What is the phone number of the school that has the highest number of test takers with an SAT score of over 1500?",
    "db_id": "california_schools",
    "res": 1,
    "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
    "evidence": [
      ""
    ]
  },
  "1227": {
    "reason": "To find the average age of male patients with high cholesterol, we need to follow these steps:\n1. Identify male patients (SEX = 'M') from the Patient table.\n2. Join the Patient table with the Laboratory table to access the cholesterol values (`T-CHO`).\n3. Filter for patients with high cholesterol (`T-CHO` >= 250).\n4. Calculate the age of each patient by subtracting their birth year from the current year.\n5. Compute the average of these ages.\n\nThe query will involve joining the Patient and Laboratory tables, filtering for the required conditions, and then performing the average calculation.",
    "sql": "SELECT AVG(strftime('%Y', 'now') - strftime('%Y', Birthday)) AS average_age\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.SEX = 'M' AND Laboratory.\"T-CHO\" >= 250;",
    "question": "What is the average age of the male patient with high cholesterol?",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-CHO` >= 250 AND T1.SEX = 'M'",
    "evidence": [
      "average age = DIVIDE(SUM(SUBTRACT(YEAR(NOW()), YEAR(birthday))), COUNT(ID)); male patient refers to sex = 'M'; high cholesterol refers to `T-CHO` > = 250;"
    ]
  },
  "259": {
    "reason": "To solve the question \"How many elements are there for single bond molecules?\", we need to follow these steps:\n1. Identify molecules with single bonds by checking the `bond` table where `bond_type` = '-'.\n2. For these molecules, find the atoms involved in the bonds by joining the `connected` table with the `atom` table.\n3. Count the distinct elements (`element` column in the `atom` table) for these atoms.\n\nThe query will involve joining the `bond`, `connected`, and `atom` tables to filter for single bonds and then count the distinct elements.",
    "sql": "SELECT COUNT(DISTINCT a.element) AS element_count\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a ON c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id\nWHERE b.bond_type = '-';",
    "question": "How many elements are there for single bond molecules?",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
    "evidence": [
      "single bond refers to bond_type = '-';"
    ]
  },
  "376": {
    "reason": "To find the card layouts of cards with the keyword 'flying', we need to query the `cards` table. The `cards` table contains the `layout` and `keywords` columns. The `keywords` column likely contains a list of keywords for each card, and we need to check if 'flying' is one of them. We can use the `LIKE` operator to search for the keyword 'flying' within the `keywords` column. Once we identify these cards, we can retrieve their `layout` values.",
    "sql": "SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%flying%';",
    "question": "What are the card layout of cards with keyword of flying?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT layout FROM cards WHERE keywords = 'Flying'",
    "evidence": [
      ""
    ]
  },
  "551": {
    "reason": "To find out how many badges the user 'csgillespie' has obtained, we need to follow these steps:\n1. First, identify the user ID of 'csgillespie' from the `users` table.\n2. Then, count the number of badges associated with that user ID in the `badges` table.\n\nThe query will involve joining the `users` and `badges` tables to match the user's display name with their badges.",
    "sql": "SELECT COUNT(*) AS badge_count\nFROM badges\nWHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');",
    "question": "How many badges has the user csgillespie obtained?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
    "evidence": [
      "\"csgillespie\" is the DisplayName of user"
    ]
  },
  "435": {
    "reason": "To solve the question, we need to find out how many cards have a black border color and list their IDs. The relevant table for this query is the `cards` table, which contains the `borderColor` column and the `id` column. The steps are as follows:\n1. Filter the `cards` table to include only rows where the `borderColor` is 'black'.\n2. Count the number of such rows to get the total number of cards with a black border.\n3. List the `id` of these cards.",
    "sql": "SELECT id FROM cards WHERE borderColor = 'black';",
    "question": "How many card border with black color ? List out the card id.",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id",
    "evidence": [
      "border with black color refers to borderColor = 'black'"
    ]
  },
  "457": {
    "reason": "To solve the question, we need to find the websites where cards with the promotional type of \"bundle\" can be purchased. The relevant information is stored in the `cards` table, specifically in the `promoTypes` and `purchaseUrls` columns. We will query the `cards` table to filter cards where the `promoTypes` column contains the value \"bundle\" and then retrieve the `purchaseUrls` for those cards.",
    "sql": "SELECT purchaseUrls FROM cards WHERE promoTypes LIKE '%bundle%';",
    "question": "Please list the websites where I can purchase the cards that have the promotional type of \"bundle\".",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
    "evidence": [
      "promotional type of \"bundle\" refers to promoTypes = 'bundle'; websites refers to purchaseUrls"
    ]
  },
  "759": {
    "reason": "To find the eye colour of the heaviest superhero, we need to follow these steps:\n1. Identify the superhero with the highest weight (weight_kg) from the `superhero` table.\n2. Retrieve the `eye_colour_id` of this superhero.\n3. Use the `eye_colour_id` to find the corresponding colour name from the `colour` table.\n4. Combine these steps into a single query to get the result.",
    "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.weight_kg = (SELECT MAX(weight_kg) FROM superhero);",
    "question": "What is the eye clolour of the heaviest superhero?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id ORDER BY T1.weight_kg DESC LIMIT 1",
    "evidence": [
      "the heaviest superhero refers to MAX(weight_kg); eye colour refers to colour where eye_colour_id = colour.id;"
    ]
  },
  "1134": {
    "reason": "To find the difference between the jumping scores of players with IDs 6 and 23, we need to query the `Player_Attributes` table for the `jumping` attribute of these two players. The difference can be calculated by subtracting the jumping score of player 23 from that of player 6. The query will involve filtering the `Player_Attributes` table for the specific player IDs and then performing the subtraction.",
    "sql": "SELECT (SELECT jumping FROM Player_Attributes WHERE player_api_id = 6) - (SELECT jumping FROM Player_Attributes WHERE player_api_id = 23) AS jumping_difference;",
    "question": "What is the difference between players 6 and 23's jumping scores?",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) FROM Player_Attributes AS t1",
    "evidence": [
      "difference between players 6 and 23's jumping scores refers to SUBTRACT(jumping AND id = 6,jumping AND id = 23)"
    ]
  },
  "171": {
    "reason": "To solve the question, we need to find the difference in the number of crimes committed in East and North Bohemia in 1996. According to the schema and the tips provided:\n1. The `district` table contains the region information in column `A3`.\n2. The number of crimes committed in 1996 is stored in column `A16`.\n3. We need to filter the districts for 'East Bohemia' and 'North Bohemia' using the `A3` column.\n4. Sum the `A16` values for each region.\n5. Calculate the difference between the sums of North Bohemia and East Bohemia.\n\nThe SQL query will involve selecting the sum of `A16` for each region and then computing the difference.",
    "sql": "SELECT \n    (SELECT SUM(A16) FROM district WHERE A3 = 'North Bohemia') - \n    (SELECT SUM(A16) FROM district WHERE A3 = 'East Bohemia') AS crime_difference;",
    "question": "What was the difference in the number of crimes committed in East and North Bohemia in 1996?",
    "db_id": "financial",
    "res": 0,
    "ground_truth": "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district",
    "evidence": [
      "Difference in no. of committed crimes between 2 regions = Total no. of committed crimes in 1996 in north Bohemia - Total no. of committed crimes in 1996 in e ast Bohemia. A3 refers to region. Data about no. of committed crimes 1996 appears in A16"
    ]
  },
  "1215": {
    "reason": "To solve the question, we need to find all female patients with a total protein (TP) value beyond the normal index (TP > 8.5) and calculate the deviation of their TP index from the normal (TP - 8.5). The steps are as follows:\n1. Identify female patients from the `Patient` table where `SEX = 'F'`.\n2. Join the `Patient` table with the `Laboratory` table to get the TP values for these patients.\n3. Filter the results to include only those records where `TP > 8.5`.\n4. Calculate the deviation as `TP - 8.5` for each of these records.\n5. Return the relevant information, including the patient ID and the deviation.",
    "sql": "SELECT P.ID, (L.TP - 8.5) AS TP_Deviation\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'F' AND L.TP > 8.5;",
    "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
    "evidence": [
      "female refers to SEX = 'F'; total protein (TP) beyond the normal index refers to TP > 8.5; deviation of TP index from normal refers to SUBTRACT(TP, 8.5)"
    ]
  },
  "155": {
    "reason": "To solve the question, we need to calculate the percentage of 'Gold' cards issued prior to 1998. The steps are as follows:\n1. Count the number of 'Gold' cards issued before 1998.\n2. Count the total number of cards in the database.\n3. Calculate the percentage by dividing the count from step 1 by the count from step 2 and multiplying by 100.\n\nThe query will involve filtering the `card` table for 'Gold' type cards with an issued date before '1998-01-01' and then performing the division and multiplication to get the percentage.",
    "sql": "SELECT (COUNT(CASE WHEN type = 'gold' AND issued < '1998-01-01' THEN 1 END) * 100.0 / COUNT(*)) AS percent_gold_pre_1998\nFROM card;",
    "question": "How many percent of 'Gold' cards were issued prior to 1998?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') AS REAL) * 100 / COUNT(card_id) FROM card",
    "evidence": [
      "Percent of Gold = [ count(type = 'gold' and issued date < 1998) / count(all cards)] * 100%"
    ]
  },
  "679": {
    "reason": "To find the post with the highest score, we need to query the `posts` table. The `Score` column in the `posts` table indicates the score of each post. We can use the `MAX(Score)` function to identify the highest score. Once we have the highest score, we can retrieve the `Id` and `Title` of the post with that score. The query will involve selecting the `Id` and `Title` columns from the `posts` table where the `Score` matches the maximum score found in the table.",
    "sql": "SELECT Id, Title FROM posts WHERE Score = (SELECT MAX(Score) FROM posts);",
    "question": "Which post has the highest score? Please give its id and title's name.",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT T1.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1",
    "evidence": [
      "the highest score refers to MAX(Score); owner's name refers to DisplayName;"
    ]
  },
  "1493": {
    "reason": "To solve the question, we need to determine the percentage of customers who consumed more than 528.3 in February 2012. The steps are as follows:\n1. Identify the date format for February 2012 in the `yearmonth` table, which is '201202'.\n2. Filter the `yearmonth` table for records where the `Date` is '201202' and `Consumption` is greater than 528.3.\n3. Count the number of customers who meet this condition.\n4. Count the total number of unique customers in February 2012.\n5. Calculate the percentage by dividing the count from step 3 by the count from step 4 and multiplying by 100.\n6. Round the result to ensure it is presented clearly.",
    "sql": "SELECT \n    ROUND(\n        (COUNT(CASE WHEN Consumption > 528.3 THEN 1 END) * 100.0 / COUNT(DISTINCT CustomerID)),\n        2\n    ) AS Percentage\nFROM \n    yearmonth\nWHERE \n    Date = '201202';",
    "question": "In February 2012, what percentage of customers consumed more than 528.3?",
    "db_id": "debit_card_specializing",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'",
    "evidence": [
      "February 2012 refers to '201202' in yearmonth.date; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
    ]
  },
  "695": {
    "reason": "To find out how many users were awarded the 'Citizen Patrol' badge, we need to query the `badges` table. Specifically, we will count the distinct `UserId` entries where the `Name` of the badge is 'Citizen Patrol'. This will give us the number of unique users who received this badge.",
    "sql": "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Citizen Patrol';",
    "question": "How many users were awarded with 'Citizen Patrol' badge?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(id) FROM badges WHERE `Name` = 'Citizen Patrol'",
    "evidence": [
      "Citizen Patrol' is the name of the badge;"
    ]
  },
  "22": {
    "reason": "To find the school in Contra Costa with the highest number of test takers, we need to:\n1. Identify the relevant tables: `satscores` for test taker data and `schools` for location (County) information.\n2. Join these tables on the `CDSCode` (or `cds` in `satscores`) to link test taker data with school location.\n3. Filter the results to only include schools in Contra Costa County.\n4. Order the results by the number of test takers (`NumTstTakr`) in descending order.\n5. Limit the result to the top school to get the one with the highest number of test takers.",
    "sql": "SELECT s.School, s.County, sc.NumTstTakr\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.County = 'Contra Costa'\nORDER BY sc.NumTstTakr DESC\nLIMIT 1;",
    "question": "Which school in Contra Costa has the highest number of test takers?",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1",
    "evidence": [
      ""
    ]
  },
  "786": {
    "reason": "To solve the question, we need to find the number of heroes who have the highest attribute value in 'Strength'. The steps are as follows:\n1. Identify the attribute_id for 'Strength' from the `attribute` table.\n2. Find the maximum attribute_value for 'Strength' from the `hero_attribute` table.\n3. Count the number of heroes in the `hero_attribute` table who have this maximum attribute_value for 'Strength'.",
    "sql": "WITH strength_attribute AS (\n    SELECT id FROM attribute WHERE attribute_name = 'Strength'\n),\nmax_strength AS (\n    SELECT MAX(attribute_value) AS max_value\n    FROM hero_attribute\n    WHERE attribute_id = (SELECT id FROM strength_attribute)\n)\nSELECT COUNT(DISTINCT hero_id) AS hero_count\nFROM hero_attribute\nWHERE attribute_id = (SELECT id FROM strength_attribute)\nAND attribute_value = (SELECT max_value FROM max_strength);",
    "question": "How many heroes have the highest attribute value in strength?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )",
    "evidence": [
      "highest attribute value in strength refers to MAX(attribute_value) WHERE attribute_name = 'Strength';"
    ]
  },
  "1102": {
    "reason": "To solve the question, we need to find the oldest player among those who had an overall rating of 77 on June 23, 2016. The steps are as follows:\n1. Filter the `Player_Attributes` table for records where `overall_rating` is 77 and the `date` is '2016-06-23'.\n2. Join these records with the `Player` table to get the player details, including their `birthday`.\n3. Since the larger the `birthday` value, the younger the player, we need to find the smallest `birthday` value to identify the oldest player.\n4. Order the results by `birthday` in ascending order and limit the result to the first record to get the oldest player.\n5. Retrieve the `player_name` of this player.",
    "sql": "SELECT p.player_name\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE pa.overall_rating = 77 AND pa.date LIKE '2016-06-23%'\nORDER BY p.birthday ASC\nLIMIT 1;",
    "question": "For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-06-23' AND t2.overall_rating = 77 ORDER BY t1.birthday ASC LIMIT 1",
    "evidence": [
      "77 points overall rating refers to overall_rating = 77; on 2016/6/23 refers to date LIKE '2016-06-23%'; The larger the birthday value, the younger the person is, and vice versa;"
    ]
  },
  "221": {
    "reason": "To find the atoms that are bonded in the molecule TR001 with the bond ID TR001_2_6, we need to follow these steps:\n1. Identify the bond with the ID TR001_2_6 in the `bond` table to confirm it belongs to the molecule TR001.\n2. Use the `connected` table to find the pairs of atoms (atom_id and atom_id2) that are connected by this bond ID.\n3. Retrieve the details of these atoms from the `atom` table to confirm they belong to the molecule TR001.\n\nThe query will join the `connected` table with the `atom` table to get the atom details and ensure the bond ID and molecule ID match the given criteria.",
    "sql": "SELECT a1.atom_id AS atom1, a2.atom_id AS atom2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_2_6' AND a1.molecule_id = 'TR001' AND a2.molecule_id = 'TR001';",
    "question": "What are the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6?",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1 , T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'",
    "evidence": [
      "TR001 is the molecule id; TR001_2_6 is the bond id"
    ]
  },
  "863": {
    "reason": "To find the season page of the year when the race with raceId 901 took place, we need to follow these steps:\n1. Identify the year of the race with raceId 901 from the races table.\n2. Use this year to find the corresponding season page URL from the seasons table.\n3. The query will join the races and seasons tables to retrieve the URL for the identified year.",
    "sql": "SELECT s.url \nFROM seasons s \nJOIN races r ON s.year = r.year \nWHERE r.raceId = 901;",
    "question": "Show me the season page of year when the race No. 901 took place.",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
    "evidence": [
      "race number refers to raceId;"
    ]
  },
  "888": {
    "reason": "To find the country where the first European Grand Prix was hosted, along with the circuit name and location, we need to follow these steps:\n1. Identify the earliest year (minimum year) in the `races` table where the race name is 'European Grand Prix'.\n2. Use this year to filter the `races` table to get the `circuitId` for the first European Grand Prix.\n3. Join the `races` table with the `circuits` table using the `circuitId` to retrieve the country, circuit name, and location.\n4. The query will return the country, circuit name, and location for the first European Grand Prix.",
    "sql": "SELECT c.country, c.name AS circuit_name, c.location\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'European Grand Prix'\nORDER BY r.year ASC\nLIMIT 1;",
    "question": "In which country was the first European Grand Prix hosted? Name the circuit and location.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT T1.country, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix' ORDER BY T2.year ASC LIMIT 1",
    "evidence": [
      "the first refers to min(year);"
    ]
  },
  "1161": {
    "reason": "To solve the question, we need to find the average anti-cardiolipin antibody (IgG) concentration for in-patients aged 50 and above. Here's the step-by-step reasoning:\n\n1. **Identify in-patients**: These are patients where the `Admission` field in the `Patient` table is '+'. \n2. **Filter patients aged 50 and above**: Calculate the age of each patient by subtracting their birth year from the current year. Patients with an age of 50 or more should be included.\n3. **Join with the Examination table**: The `aCL IgG` field in the `Examination` table contains the anti-cardiolipin antibody (IgG) concentration. We need to join the `Patient` table with the `Examination` table on the `ID` field.\n4. **Calculate the average**: Use the `AVG` function on the `aCL IgG` field for the filtered patients.\n\nPutting it all together, the query will filter in-patients aged 50 and above, join with the `Examination` table, and compute the average of `aCL IgG`.",
    "sql": "SELECT AVG(e.\"aCL IgG\") AS \"Average aCL IgG Concentration\"\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Admission = '+' AND (strftime('%Y', 'now') - strftime('%Y', p.Birthday)) >= 50;",
    "question": "For in-patient age 50 and above, what is their average anti-cardiolipin antibody (IgG) concentration?",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT AVG(T2.`aCL IgG`) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 AND T1.Admission = '+'",
    "evidence": [
      "in-patient refers to Admission = '+'; age 50 and above refers to SUBTRACT(year(current_timestamp), year(Birthday)) >= '50'; average anti-cardiolipin antibody (IgG) concentration refers to AVG(aCL IgG)"
    ]
  },
  "187": {
    "reason": "To solve the question, we need to find the number of clients who have an account with a weekly issuance frequency ('POPLATEK TYDNE') and are also marked as 'Owner' in the disp table. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: We need to use the `account` table to find accounts with weekly issuance, the `disp` table to check the type of the client (Owner), and the `client` table to count the clients.\n\n2. **Filter accounts with weekly issuance**: The `account` table has a column `frequency` where 'POPLATEK TYDNE' indicates weekly issuance.\n\n3. **Filter Owner clients**: The `disp` table has a column `type` where 'Owner' indicates the client is the owner of the account.\n\n4. **Join the tables**: We need to join the `account`, `disp`, and `client` tables to link the accounts with their respective clients and check the conditions.\n\n5. **Count the clients**: Finally, we count the distinct client IDs that meet the criteria.",
    "sql": "SELECT COUNT(DISTINCT c.client_id) AS client_count\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'Owner';",
    "question": "How many clients who choose statement of weekly issuance are Owner?",
    "db_id": "financial",
    "res": 0,
    "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'",
    "evidence": [
      "Frequency = 'POPLATEK TYDNE' refers to weekly issuance"
    ]
  },
  "397": {
    "reason": "To solve the question, we need to find the mana cost of cards that meet the following criteria:\n1. **Normal layout**: The `layout` column should be 'normal'.\n2. **2003 frame version**: The `frameVersion` column should be '2003'.\n3. **Black border color**: The `borderColor` column should be 'black'.\n4. **Available in paper and MTGO**: The `availability` column should include both 'paper' and 'mtgo'.\n\nWe will query the `cards` table to retrieve the `manaCost` for cards that satisfy all these conditions.",
    "sql": "SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability LIKE '%paper%' AND availability LIKE '%mtgo%';",
    "question": "What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT manaCost FROM cards WHERE availability = 'mtgo,paper' AND borderColor = 'black' AND frameVersion = 2003 AND layout = 'normal'",
    "evidence": [
      "available in paper and mtgo refers to availability = 'mtgo,paper'; frameVersion = 2003;borderColor = 'black'"
    ]
  },
  "132": {
    "reason": "To find the average loan amount by male borrowers, we need to follow these steps:\n1. Identify male clients from the `client` table where `gender` is 'M'.\n2. Join the `client` table with the `disp` table to link clients to their accounts, using `client_id`.\n3. Join the `disp` table with the `account` table to ensure we have the correct accounts.\n4. Join the `account` table with the `loan` table to get the loan details for these accounts.\n5. Calculate the average of the `amount` column from the `loan` table for these male borrowers.",
    "sql": "SELECT AVG(l.amount) AS average_loan_amount\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE c.gender = 'M';",
    "question": "What is the average loan amount by male borrowers?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT AVG(T4.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'M'",
    "evidence": [
      "Male refers to gender = 'M'"
    ]
  },
  "1464": {
    "reason": "To solve the question, we need to find the full names of students (members) who received funds on the date '9/9/2019' and include the amount received. The steps are as follows:\n1. Identify the relevant tables: `member` (for names) and `income` (for funds received).\n2. Join these tables on the `link_to_member` field in the `income` table and the `member_id` field in the `member` table.\n3. Filter the results to only include records where the `date_received` in the `income` table is '9/9/2019'.\n4. Select the `first_name` and `last_name` from the `member` table and the `amount` from the `income` table.\n5. Combine the `first_name` and `last_name` to form the full name.",
    "sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, i.amount\nFROM member m\nJOIN income i ON m.member_id = i.link_to_member\nWHERE i.date_received = '9/9/2019';",
    "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
    "evidence": [
      "full name refers to first_name, last_name, amount of funds received refers to amount, received funds on date refers to date_received"
    ]
  },
  "161": {
    "reason": "To find out the type of credit card owned by the client with ID 13539, we need to follow these steps:\n1. Identify the client's `disp_id` from the `disp` table, as the `disp_id` is linked to the `card` table.\n2. Use the `disp_id` to query the `card` table and retrieve the `type` of the card.\n3. The query will join the `disp` and `card` tables to get the required information.",
    "sql": "SELECT c.type \nFROM card c \nJOIN disp d ON c.disp_id = d.disp_id \nWHERE d.client_id = 13539;",
    "question": "What type of credit card does the client with the id 13539 own?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T3.type FROM disp AS T1 INNER JOIN client AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T1.disp_id = T3.disp_id WHERE T2.client_id = 13539",
    "evidence": [
      ""
    ]
  },
  "360": {
    "reason": "To find the languages available for the set that the card 'Angel of Mercy' is in, we need to follow these steps:\n1. Identify the set code for the card 'Angel of Mercy' from the 'cards' table.\n2. Use the set code to find the corresponding set in the 'sets' table.\n3. Join the 'sets' table with the 'set_translations' table to find all languages available for that set.\n4. Retrieve the distinct languages from the 'set_translations' table for the identified set.",
    "sql": "SELECT DISTINCT st.language\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode\nWHERE c.name = 'Angel of Mercy';",
    "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
    "evidence": [
      "Angel of Mercy' is the name of card;"
    ]
  },
  "1099": {
    "reason": "To determine which foot is preferred by Abdou Diallo, we need to query the `Player_Attributes` table. This table contains the `preferred_foot` attribute for players. However, we first need to find Abdou Diallo's `player_api_id` or `player_fifa_api_id` from the `Player` table, as the `Player_Attributes` table references these IDs. The steps are:\n1. Query the `Player` table to find Abdou Diallo's `player_api_id` or `player_fifa_api_id`.\n2. Use this ID to query the `Player_Attributes` table for the `preferred_foot` attribute.",
    "sql": "SELECT pa.preferred_foot \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Abdou Diallo';",
    "question": "Which foot is preferred by Abdou Diallo?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
    "evidence": [
      "Abdou Diallo refers to player_name = 'Abdou Diallo'; foot is preferred refers to preferred_foot"
    ]
  },
  "496": {
    "reason": "To find the number of cards in the set \"Rinascita di Alara\", we need to follow these steps:\n1. Identify the set code for \"Rinascita di Alara\" from the `set_translations` table where the translation matches the given name.\n2. Use the identified set code to query the `sets` table for the `baseSetSize`, which represents the number of cards in the set.\n3. The query will join the `set_translations` and `sets` tables to retrieve the required information.",
    "sql": "SELECT s.baseSetSize\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.translation = 'Rinascita di Alara';",
    "question": "What is the number of cards are there in the set of \"Rinascita di Alara\"?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Rinascita di Alara'",
    "evidence": [
      "number of cards refers to baseSetSize; set of \"Rinascita di Alara\" refers to translation = 'Rinascita di Alara'"
    ]
  },
  "866": {
    "reason": "To solve the question, we need to find the driver who achieved a lap time of 0:01:27 in the race with raceId 161 and then display their introduction website. The steps are as follows:\n1. Identify the driverId from the lapTimes table where the time is '0:01:27' and the raceId is 161.\n2. Use the driverId obtained to fetch the driver's details (specifically the url) from the drivers table.\n3. Join the lapTimes and drivers tables to get the required information in a single query.",
    "sql": "SELECT d.url \nFROM drivers d \nJOIN lapTimes l ON d.driverId = l.driverId \nWHERE l.raceId = 161 AND l.time = '0:01:27';",
    "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
    "evidence": [
      "player and driver are synonyms; the lap time of 0:0M:SS refers to lapTime.time LIKE 'M:SS%';race number refers to raceId; introduction website of the drivers refers to url;"
    ]
  },
  "1269": {
    "reason": "To solve the question, we need to find the IDs of patients who had an examination after January 1, 1997, and had a normal anti-scl70 result. The steps are as follows:\n1. Identify the relevant tables: `Examination` and `Patient`.\n2. Filter the `Examination` table for records where `Examination Date` is after '1997-01-01'.\n3. Further filter these records for those where `SC170` (anti-scl70) is either 'negative' or '0' (as per the tip).\n4. Join the filtered `Examination` records with the `Patient` table to ensure we are referencing valid patient IDs.\n5. Return the distinct patient IDs that meet both criteria.",
    "sql": "SELECT DISTINCT e.ID\nFROM Examination e\nJOIN Patient p ON e.ID = p.ID\nWHERE e.`Examination Date` > '1997-01-01'\nAND e.SC170 IN ('negative', '0');",
    "question": "Please list the IDs of the patients who had the examination done after 1997/1/1 and had a normal anti-scl70.",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SC170 IN ('negative','0') AND T2.Date > 1997-01-01",
    "evidence": [
      "examination done after 1997/1/1 refers to `Examination Date` >  1997-01-01; normal anti-scl70 refers to SC170 IN('negative','0');"
    ]
  },
  "108": {
    "reason": "To solve the question, we need to find the client who applied for the biggest loan and then determine their first transaction amount after opening their account. Here's the step-by-step reasoning:\n\n1. **Identify the biggest loan**: We need to find the loan with the maximum amount from the `loan` table.\n2. **Find the client associated with this loan**: Using the `account_id` from the biggest loan, we can trace back to the client via the `disp` and `client` tables.\n3. **Find the account opening date**: The `account` table contains the date when the account was opened.\n4. **Find the first transaction after account opening**: Using the `account_id` and the account opening date, we can query the `trans` table to find the earliest transaction (by date) that occurred after the account was opened.\n\nThis involves joining multiple tables (`loan`, `account`, `disp`, `client`, and `trans`) and using subqueries to filter the required data.",
    "sql": "WITH biggest_loan AS (\n    SELECT account_id, amount\n    FROM loan\n    ORDER BY amount DESC\n    LIMIT 1\n),\nclient_info AS (\n    SELECT c.client_id, c.gender, c.birth_date, d.account_id\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN biggest_loan bl ON d.account_id = bl.account_id\n    WHERE d.type = 'OWNER'\n),\naccount_opening_date AS (\n    SELECT a.account_id, a.date AS account_date\n    FROM account a\n    JOIN biggest_loan bl ON a.account_id = bl.account_id\n),\nfirst_transaction AS (\n    SELECT t.account_id, t.amount, t.date\n    FROM trans t\n    JOIN account_opening_date aod ON t.account_id = aod.account_id\n    WHERE t.date > aod.account_date\n    ORDER BY t.date ASC\n    LIMIT 1\n)\nSELECT ci.client_id, ci.gender, ci.birth_date, ft.amount AS first_transaction_amount\nFROM client_info ci\nJOIN first_transaction ft ON ci.account_id = ft.account_id;",
    "question": "For the client who applied the biggest loan, what was his/her first amount of transaction after opened the account?",
    "db_id": "financial",
    "res": 0,
    "ground_truth": "SELECT T3.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY T1.amount DESC, T3.date ASC LIMIT 1",
    "evidence": [
      ""
    ]
  },
  "209": {
    "reason": "To determine the type of bond that chlorine (element 'cl') is involved in, we need to follow these steps:\n1. Identify all atoms where the element is 'cl'.\n2. Find the bonds connected to these chlorine atoms by joining the `connected` table with the `bond` table.\n3. Retrieve the `bond_type` from the `bond` table for these connections.\n4. Group the results by `bond_type` to see the distinct types of bonds chlorine is involved in.",
    "sql": "SELECT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'cl'\nGROUP BY b.bond_type;",
    "question": "Chlorine is in what type of bond?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T3.element = 'cl'",
    "evidence": [
      "type of bond refers to bond_type; chlorine refers to element = 'cl'"
    ]
  },
  "998": {
    "reason": "To solve the question, we need to find the number of victories (wins) for the driver who ranked 91st in terms of points. Here's the step-by-step reasoning:\n\n1. **Identify the driver ranked 91st by points**: We need to query the `driverStandings` table to find the driver with the 91st highest points. This involves ordering the drivers by points in descending order and selecting the 91st entry.\n\n2. **Retrieve the number of victories for this driver**: Once we have the `driverId` of the 91st-ranked driver, we can query the `driverStandings` table again to find the number of wins (`wins` column) for this driver.\n\n3. **Combine the queries**: We can use a subquery to first find the `driverId` of the 91st-ranked driver and then use this `driverId` to fetch the number of wins.",
    "sql": "SELECT wins FROM driverStandings WHERE driverId = (SELECT driverId FROM driverStandings ORDER BY points DESC LIMIT 1 OFFSET 90);",
    "question": "In terms of number of points acquired, how many victories did the driver who ranked 91st acquired?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) FROM driverStandings",
    "evidence": [
      "victories refer to wins; 91st refers to points\n\n"
    ]
  },
  "222": {
    "reason": "To solve the question, we need to calculate the difference between the number of carcinogenic molecules (labeled '+') and non-carcinogenic molecules (labeled '-'). The schema provides a `molecule` table with a `label` column where '+' indicates carcinogenic and '-' indicates non-carcinogenic. The difference is defined as the count of '+' labels minus the count of '-' labels. We can achieve this by using a single SQL query that counts the occurrences of each label and then subtracts the counts.",
    "sql": "SELECT (SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN label = '-' THEN 1 ELSE 0 END)) AS difference FROM molecule;",
    "question": "What is the difference between the number of molecules that are carcinogenic and those that are not?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar FROM molecule t",
    "evidence": [
      "label = '+' means molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; difference = SUBTRACT(SUM(label = '+'), SUM(label = '-'))"
    ]
  },
  "905": {
    "reason": "To find Eddie Irvine's average points scored in the year 2000, we need to follow these steps:\n1. Identify Eddie Irvine's driverId from the drivers table using his name (forename and surname).\n2. Join the results table with the races table to filter races from the year 2000.\n3. Filter the results for Eddie Irvine using his driverId.\n4. Calculate the average of the points he scored in those races.",
    "sql": "SELECT AVG(r.points) AS average_points\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.year = 2000 AND d.forename = 'Eddie' AND d.surname = 'Irvine';",
    "question": "What is Eddie Irvine's average points scored in year 2000?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine' AND T3.year = 2000",
    "evidence": [
      "average points = AVG(points where year = 2000)"
    ]
  },
  "800": {
    "reason": "To calculate the percentage of superheroes with blue eyes, we need to follow these steps:\n1. Identify the total number of superheroes in the database.\n2. Identify the number of superheroes who have blue eyes (where `eye_colour_id` corresponds to the colour 'Blue').\n3. Calculate the percentage by dividing the number of superheroes with blue eyes by the total number of superheroes and multiplying by 100.\n\nThe schema indicates that the `colour` table has an entry for 'Blue' (assuming `id = 7` based on the tip provided). We will use this to filter superheroes with blue eyes.",
    "sql": "SELECT (COUNT(CASE WHEN eye_colour_id = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_blue_eyes\nFROM superhero;",
    "question": "Calculate the percentage of superheroes with blue eyes.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id",
    "evidence": [
      "percentage = MULTIPLY(DIVIDE(SUM(superhero_name WHERE color = 'Blue'), COUNT(superhero_name)), 100.0); blue eyes refers to color = 'Blue' and color.id =  eye_colour_id = 7;"
    ]
  },
  "1285": {
    "reason": "To solve the question, we need to find the latest patient's medical data recorded, where the patient has an abnormal level of lactate dehydrogenase (LDH ≥ 500). The steps are as follows:\n1. Identify the latest patient by finding the maximum 'First Date' from the Patient table.\n2. Join the Patient table with the Laboratory table to access the LDH values for the patient.\n3. Filter the records where LDH is ≥ 500.\n4. Retrieve the date of the medical data from the Laboratory table for this patient.",
    "sql": "SELECT l.Date\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.ID = (SELECT ID FROM Patient WHERE `First Date` = (SELECT MAX(`First Date`) FROM Patient))\nAND l.LDH >= 500;",
    "question": "When is the latest patient's medical data recorded? This patient should have an abnormal level of lactate dehydrogenase.",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH >= 500 ORDER BY T1.`First Date` DESC LIMIT 1",
    "evidence": [
      "latest patient refers to ID with MAX('First Date'); abnormal level of lactate dehydrogenase refers to LDH > = 500;"
    ]
  },
  "682": {
    "reason": "To find the most valuable post in 2010, we need to identify the post with the highest `FavoriteCount` where the `CreationDate` is in the year 2010. The question also asks for the post's `Id` and the owner's `DisplayName`. \n\n1. We will filter the `posts` table to include only posts created in 2010 using the `strftime` function to extract the year from `CreationDate`.\n2. We will then find the post with the maximum `FavoriteCount` in this subset.\n3. Finally, we will join the result with the `users` table to get the owner's `DisplayName`.",
    "sql": "SELECT p.Id, u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE strftime('%Y', p.CreationDate) = '2010'\nORDER BY p.FavoriteCount DESC\nLIMIT 1;",
    "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
    "evidence": [
      "the most valuable post in 2015 refers to MAX(FavoriteCount) where year(CreationDate) = 2010;"
    ]
  },
  "1": {
    "reason": "To solve the question, we need to find the lowest three eligible free rates for students aged 5-17 in continuation schools. The eligible free rate is calculated as `Free Meal Count (Ages 5-17)` divided by `Enrollment (Ages 5-17)`. We will filter for continuation schools by checking the `School Type` column in the `frpm` table. The steps are:\n1. Calculate the eligible free rate for each school.\n2. Filter schools where `School Type` is 'Continuation'.\n3. Order the results by the eligible free rate in ascending order to get the lowest rates.\n4. Limit the results to the top 3.",
    "sql": "SELECT \n    `School Name`,\n    `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` AS `Eligible Free Rate`\nFROM \n    frpm\nWHERE \n    `School Type` = 'Continuation'\n    AND `Enrollment (Ages 5-17)` > 0\nORDER BY \n    `Eligible Free Rate` ASC\nLIMIT 3;",
    "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3",
    "evidence": [
      "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`"
    ]
  },
  "1330": {
    "reason": "To find the college that offers the major Tyler Hewitt took, we need to follow these steps:\n1. Identify Tyler Hewitt in the `member` table using his first and last name.\n2. Retrieve the `link_to_major` for Tyler Hewitt from the `member` table.\n3. Use the `link_to_major` to find the corresponding major in the `major` table.\n4. From the `major` table, retrieve the `college` associated with the major.\n\nThe query will join the `member` and `major` tables to fetch the required information.",
    "sql": "SELECT m.college\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Tyler' AND mb.last_name = 'Hewitt';",
    "question": "What college offers the major that Tyler Hewitt took?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'",
    "evidence": [
      ""
    ]
  },
  "882": {
    "reason": "To find the year of the first Singapore Grand Prix, we need to identify the earliest race in the 'races' table where the 'name' column contains 'Singapore Grand Prix'. We can achieve this by querying the 'races' table for the minimum 'year' where the 'name' matches the pattern 'Singapore Grand Prix'.",
    "sql": "SELECT MIN(year) AS first_year FROM races WHERE name LIKE '%Singapore Grand Prix%';",
    "question": "Which year was the first Singapore Grand Prix?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT year FROM races WHERE name = 'Singapore Grand Prix' ORDER BY year ASC LIMIT 1",
    "evidence": [
      "the first race refers to race happened in min(year);"
    ]
  },
  "515": {
    "reason": "To solve the question, we need to find the oldest mythic card and its legal play formats. Here's the step-by-step reasoning:\n\n1. **Identify the oldest mythic card**: We need to find the card with the earliest `originalReleaseDate` where the `rarity` is 'mythic' from the `cards` table.\n2. **Retrieve its legal play formats**: Once we have the oldest mythic card's `uuid`, we can join the `legalities` table to find all formats where the `status` is 'legal' for that card.\n3. **Combine the results**: The final query will involve filtering the `cards` table for mythic rarity, ordering by `originalReleaseDate` to find the oldest, and then joining with the `legalities` table to get the legal formats.",
    "sql": "SELECT c.originalReleaseDate, l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic' AND l.status = 'legal'\nORDER BY c.originalReleaseDate ASC\nLIMIT 1;",
    "question": "When was the oldest mythic card released and what are its legal play formats?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate LIMIT 1",
    "evidence": [
      "the oldest card refers to MIN(originalReleaseDate); mythic card refers to rarity = 'mythic'; legal play refers to status = 'legal'; play format refers to format"
    ]
  },
  "1318": {
    "reason": "To find the event with the highest attendance of students from the Student_Club, we need to follow these steps:\n1. Identify the attendance records in the `attendance` table, which links events to members.\n2. Count the number of attendees for each event by grouping the `attendance` table by `link_to_event`.\n3. Join the result with the `event` table to get the event details (e.g., `event_name`).\n4. Order the results by the count of attendees in descending order and limit the result to the top event.\n\nThe query will use `GROUP BY` to count attendees per event, `JOIN` to fetch event details, and `ORDER BY` with `LIMIT` to get the event with the highest attendance.",
    "sql": "SELECT e.event_id, e.event_name, COUNT(a.link_to_member) AS attendance_count\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nGROUP BY e.event_id, e.event_name\nORDER BY attendance_count DESC\nLIMIT 1;",
    "question": "What is the event that has the highest attendance of the students from the Student_Club?",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_name ORDER BY COUNT(T2.link_to_event) DESC LIMIT 1",
    "evidence": [
      "event with highest attendance refers to MAX(COUNT(link_to_event))"
    ]
  },
  "1110": {
    "reason": "To find the build-up play passing class for \"FC Lorient\" on 2010/2/22, we need to follow these steps:\n1. Identify the team_api_id for \"FC Lorient\" from the Team table.\n2. Use this team_api_id to find the corresponding Team_Attributes record for the date 2010-02-22.\n3. Retrieve the buildUpPlayPassingClass from the Team_Attributes table for this record.",
    "sql": "SELECT ta.buildUpPlayPassingClass \nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE t.team_long_name = 'FC Lorient' AND ta.date LIKE '2010-02-22%';",
    "question": "Tell the build Up play passing class for \"FC Lorient\" on 2010/2/22.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'FC Lorient' AND t2.`date` LIKE '2010-02-22%'",
    "evidence": [
      "\"FC Lorient\" refers to team_long_name = 'FC Lorient'; on 2010/2/22 refers to date LIKE '2010-02-22%';"
    ]
  },
  "1281": {
    "reason": "To solve the question, we need to find the youngest patient among those who have an abnormal level of glutamic oxaloacetic transaminase (GOT >= 60). The steps are as follows:\n1. Identify patients with GOT >= 60 from the Laboratory table.\n2. Join these patients with the Patient table to get their birth dates.\n3. Since the larger the birthday value, the younger the person is, we need to find the maximum birthday value among these patients.\n4. Retrieve the birth date of the youngest patient.",
    "sql": "SELECT MAX(p.Birthday) AS YoungestBirthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GOT >= 60;",
    "question": "Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60 ORDER BY T1.Birthday DESC LIMIT 1",
    "evidence": [
      "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; The larger the birthday value, the younger the person is, and vice versa;"
    ]
  },
  "367": {
    "reason": "To find the names of the artists who illustrated the card art in Phyrexian, we need to identify cards that have a Phyrexian language entry in the `foreign_data` table. The `foreign_data` table contains information about cards in different languages, including Phyrexian. We can join the `cards` table with the `foreign_data` table where the language is 'Phyrexian' and then retrieve the artist names from the `cards` table.",
    "sql": "SELECT DISTINCT c.artist FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Phyrexian';",
    "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
    "evidence": [
      "Phyrexian' is the language; name of artists refers to artist;"
    ]
  },
  "387": {
    "reason": "To find the cards for the set OGW and their colors, we need to query the `cards` table where the `setCode` is 'OGW'. The `colors` column in the `cards` table contains the color information for each card. We will select the `name` and `colors` columns from the `cards` table where the `setCode` matches 'OGW'.",
    "sql": "SELECT name, colors FROM cards WHERE setCode = 'OGW';",
    "question": "What are the cards for set OGW? State the colour for these cards.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT id, colors FROM cards WHERE id IN ( SELECT id FROM set_translations WHERE setCode = 'OGW' )",
    "evidence": [
      "set OGW refers to setCode = 'OGW';"
    ]
  },
  "513": {
    "reason": "To solve the question, we need to identify the set with the highest total number of cards among sets whose expansion type is 'Commander'. The question specifies that we should include promotional and related supplemental products but exclude Alchemy modifications. The schema provides a table called 'sets' which contains the relevant fields: 'type' (to filter for 'Commander') and 'totalSetSize' (to determine the highest number of cards). The steps are as follows:\n1. Filter the 'sets' table to include only rows where 'type' is 'Commander'.\n2. From the filtered rows, select the set with the maximum 'totalSetSize'.\n3. Retrieve the 'id' of this set.",
    "sql": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1;",
    "question": "Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1",
    "evidence": [
      "expansion type refers to type where type = 'commander'; totalSetSize: The total number of cards in the set, including promotional and related supplemental products but excluding Alchemy modifications; highest total number of cards refers to MAX(totalSetSize)"
    ]
  },
  "753": {
    "reason": "To solve the question, we need to find superheroes with a height between 170 cm and 190 cm and no eye color. The steps are as follows:\n1. Identify the superheroes with height_cm BETWEEN 170 AND 190.\n2. Among these, filter those with no eye color, which is indicated by eye_colour_id referencing a colour with colour = 'No Colour'.\n3. Join the superhero table with the colour table to check the eye color condition.\n4. Return the superhero_name from the filtered results.",
    "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.height_cm BETWEEN 170 AND 190\nAND c.colour = 'No Colour';",
    "question": "Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'",
    "evidence": [
      "height from 170 to 190 refers to height_cm BETWEEN 170 AND 190; no eye color refers to colour = 'No Colour'"
    ]
  },
  "1041": {
    "reason": "To solve the question, we need to follow these steps:\n1. Identify teams with a normal build-up play dribbling class in 2014. This involves filtering the `Team_Attributes` table for records where `buildUpPlayDribblingClass` is 'Normal' and the `date` falls within the year 2014.\n2. Calculate the average `chanceCreationPassing` value across all teams in the dataset.\n3. Filter the teams identified in step 1 to only include those with a `chanceCreationPassing` value less than the average calculated in step 2.\n4. Join the filtered results with the `Team` table to get the team names (`team_long_name`).\n5. Sort the results in descending order of `chanceCreationPassing`.",
    "sql": "WITH AvgChanceCreation AS (\n    SELECT AVG(chanceCreationPassing) AS avg_chance_creation\n    FROM Team_Attributes\n),\nTeamsIn2014 AS (\n    SELECT team_api_id, chanceCreationPassing\n    FROM Team_Attributes\n    WHERE buildUpPlayDribblingClass = 'Normal'\n    AND date >= '2014-01-01 00:00:00' AND date <= '2014-12-31 23:59:59'\n)\nSELECT t.team_long_name, ti.chanceCreationPassing\nFROM TeamsIn2014 ti\nJOIN Team t ON ti.team_api_id = t.team_api_id\nJOIN AvgChanceCreation ac ON ti.chanceCreationPassing < ac.avg_chance_creation\nORDER BY ti.chanceCreationPassing DESC;",
    "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
    "evidence": [
      "normal build-up play dribbling class refers to buildUpPlayDribblingClass = 'Normal'; in 2014 refers to date > = '2014-01-01 00:00:00' AND date < = '2014-01-31 00:00:00'; names of the teams refers to team_long_name; less than average chance creation passing = DIVIDE(SUM(chanceCreationPassing), COUNT(id)) > chanceCreationPassing;"
    ]
  },
  "856": {
    "reason": "To find the time of the races held on the Sepang International Circuit, we need to follow these steps:\n1. Identify the circuitId of the Sepang International Circuit from the circuits table.\n2. Use this circuitId to find all races held at this circuit in the races table.\n3. Retrieve the time of these races from the races table.",
    "sql": "SELECT r.time \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.name = 'Sepang International Circuit';",
    "question": "Please list the time of the races held on Sepang International Circuit.",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
    "evidence": [
      ""
    ]
  },
  "27": {
    "reason": "To solve the question, we need to find the average writing score for schools that were either opened after 1991 or closed before 2000. Additionally, we need to list the school names and their communication numbers (phone numbers) if available. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `satscores` table contains the average writing scores (`AvgScrWrite`), and the `schools` table contains the opening (`OpenDate`) and closing (`ClosedDate`) dates, as well as the school names (`School`) and communication numbers (`Phone`).\n\n2. **Filter schools based on dates**: We need to filter schools where:\n   - `OpenDate` is after 1991 (`OpenDate > '1991-12-31'`), or\n   - `ClosedDate` is before 2000 (`ClosedDate < '2000-01-01'`).\n\n3. **Join the tables**: We will join the `schools` table with the `satscores` table using the `CDSCode` (in `schools`) and `cds` (in `satscores`) fields to get the writing scores for the filtered schools.\n\n4. **Select the required fields**: We need to select the school name (`sname` from `satscores` or `School` from `schools`), the average writing score (`AvgScrWrite`), and the communication number (`Phone`).\n\n5. **Handle NULL values**: Ensure that we only include schools with valid writing scores and communication numbers if they exist.\n\n6. **Order the results**: Optionally, we can order the results by the school name or writing score for better readability.",
    "sql": "SELECT s.School AS \"School Name\", sc.AvgScrWrite AS \"Average Writing Score\", s.Phone AS \"Communication Number\"\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE (s.OpenDate > '1991-12-31' OR s.ClosedDate < '2000-01-01')\nAND sc.AvgScrWrite IS NOT NULL\nORDER BY s.School;",
    "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
    "evidence": [
      "Communication number refers to phone number."
    ]
  },
  "456": {
    "reason": "To find the list of all types for the card \"Molimo, Maro-Sorcerer\", we need to query the `cards` table where the `name` column matches \"Molimo, Maro-Sorcerer\". The types of the card are stored in the `subtypes` and `supertypes` columns. We will combine these columns to get the complete list of types for the card.",
    "sql": "SELECT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';",
    "question": "What's the list of all types for the card \"Molimo, Maro-Sorcerer\"?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'",
    "evidence": [
      "card \"Molimo, Maro-Sorcerer\" refers to name = 'Molimo, Maro-Sorcerer'; list of all types refers to subtypes,supertypes"
    ]
  },
  "291": {
    "reason": "To solve the question, we need to count the number of chemical compounds (molecules) in the database that are identified as carcinogenic. According to the tips, molecules with the label '+' are carcinogenic. The steps are as follows:\n1. Query the `molecule` table to filter rows where the `label` is '+', indicating carcinogenic molecules.\n2. Count the number of such rows to get the total number of carcinogenic chemical compounds.",
    "sql": "SELECT COUNT(*) FROM molecule WHERE label = '+';",
    "question": "How many chemical compounds in the database are identified as carcinogenic.",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
    "evidence": [
      "label = '+' mean molecules are carcinogenic;"
    ]
  },
  "542": {
    "reason": "To find the total number of comments for all posts owned by 'csgillespie', we need to follow these steps:\n1. Identify the user 'csgillespie' in the `users` table to get their `Id`.\n2. Use this `Id` to find all posts owned by 'csgillespie' in the `posts` table.\n3. For each of these posts, sum the `CommentCount` from the `posts` table to get the total number of comments.\n\nThe query will join the `users` and `posts` tables to achieve this.",
    "sql": "SELECT SUM(p.CommentCount) AS TotalComments\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';",
    "question": "What is the total number of comments of all the posts owned by csgillespie?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT SUM(T1.CommentCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
    "evidence": [
      "\"csgillespie\" is the DisplayName of user; total number of comments refers to Sum(CommentCount)"
    ]
  },
  "1154": {
    "reason": "To solve the question, we need to retrieve the sex and birthday of the patient with ID '163109' from the Patient table. Additionally, we need to find the examination date and symptoms from the Examination table for the same patient. The query involves joining the Patient and Examination tables on the ID field to get all the required information in one result set.",
    "sql": "SELECT p.SEX, p.Birthday, e.\"Examination Date\", e.Symptoms\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.ID = 163109;",
    "question": "State the sex and birthday of patient ID '163109'. When was the examination taken and what symptom does the patient had.",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT T1.SEX, T1.Birthday, T2.`Examination Date`, T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = 163109",
    "evidence": [
      "When was the examination taken refers to `Examination Date`"
    ]
  },
  "126": {
    "reason": "To calculate the percentage of accounts from the 'Decin' district that were opened in 1993, we need to follow these steps:\n1. Identify the district_id for 'Decin' from the district table.\n2. Count the total number of accounts opened in 1993.\n3. Count the number of accounts opened in 1993 from the 'Decin' district.\n4. Calculate the percentage by dividing the count from step 3 by the count from step 2 and multiplying by 100.\n\nThe query will involve joining the account and district tables to filter accounts by district and date.",
    "sql": "WITH decin_accounts AS (\n    SELECT COUNT(*) AS decin_count\n    FROM account\n    JOIN district ON account.district_id = district.district_id\n    WHERE district.A2 = 'Decin'\n    AND strftime('%Y', account.date) = '1993'\n),\ntotal_1993_accounts AS (\n    SELECT COUNT(*) AS total_count\n    FROM account\n    WHERE strftime('%Y', account.date) = '1993'\n)\nSELECT (decin_count * 100.0 / total_count) AS percentage\nFROM decin_accounts, total_1993_accounts;",
    "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
    "evidence": [
      "A2 contains the information about district."
    ]
  },
  "898": {
    "reason": "To find the youngest Japanese driver, we need to identify the driver with the latest date of birth (dob) among those with nationality 'Japanese'. The age can be calculated as the difference between the current year and the year of birth. The youngest driver will have the maximum dob value. We will then retrieve the driver's name (forename and surname) and calculate their age.",
    "sql": "SELECT forename, surname, (strftime('%Y', 'now') - strftime('%Y', dob)) AS age FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1;",
    "question": "How old is the youngest Japanese driver? What is his name?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
    "evidence": [
      "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);"
    ]
  },
  "514": {
    "reason": "To solve the question, we need to find the top 10 cards with the highest unconverted mana cost in the 'duel' format. The steps are as follows:\n1. Identify cards that are legal in the 'duel' format by querying the 'legalities' table where `format = 'duel'`.\n2. Join the 'legalities' table with the 'cards' table to get the mana cost of these cards.\n3. Use the `MAX(convertedManaCost)` to find the highest unconverted mana cost.\n4. Order the results by `convertedManaCost` in descending order and limit the output to the top 10 cards.\n5. Include relevant details like the card name and mana cost in the output.",
    "sql": "SELECT c.name, c.convertedManaCost\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'duel'\nORDER BY c.convertedManaCost DESC\nLIMIT 10;",
    "question": "In duels, what are the top 10 cards with the highest uncoverted mana cost?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 0, 10",
    "evidence": [
      "duels refer to format = 'duel'; the highest uncoverted mana cost refers to MAX(manaCost)"
    ]
  },
  "975": {
    "reason": "To determine the year with the lowest speed of lap time, we need to analyze the lap times recorded in the `lapTimes` table. The tip suggests that the lowest speed corresponds to the maximum lap time (`Max(time)`). Here's the step-by-step reasoning:\n\n1. **Identify the relevant table**: The `lapTimes` table contains the lap time data, including `raceId`, `driverId`, `lap`, and `time`.\n2. **Link to the `races` table**: The `raceId` in `lapTimes` can be joined with the `races` table to get the `year` of the race.\n3. **Find the slowest lap time**: We need to find the maximum lap time (`Max(time)`) across all records in the `lapTimes` table.\n4. **Determine the year**: Once the slowest lap time is identified, we can retrieve the corresponding year from the `races` table.\n\nThis involves joining the `lapTimes` and `races` tables, grouping by year, and then finding the year with the maximum lap time.",
    "sql": "SELECT r.year\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nGROUP BY r.year\nORDER BY MAX(lt.time) DESC\nLIMIT 1;",
    "question": "Which year has the lowest speed of lap time?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId ORDER BY T1.time DESC LIMIT 1",
    "evidence": [
      "lowest speed of lap time refers to Max(time);"
    ]
  },
  "477": {
    "reason": "To determine which artists (Jeremy Jarvis, Aaron Miller, or Chippy) have designed a card in the set 'Coldsnap', we need to follow these steps:\n1. Identify the set 'Coldsnap' in the `sets` table to get its `code`.\n2. Join the `cards` table with the `sets` table using the `setCode` field to find all cards in the 'Coldsnap' set.\n3. Filter the results to include only cards where the `artist` is one of the three specified artists (Jeremy Jarvis, Aaron Miller, or Chippy).\n4. Select the distinct `artist` names from the filtered results to avoid duplicates.\n\nThe query will involve joining the `cards` and `sets` tables and filtering based on the artist names and set code.",
    "sql": "SELECT DISTINCT c.artist\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Coldsnap'\nAND c.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy');",
    "question": "Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (T2.name = 'Coldsnap' AND T1.artist = 'Chippy') OR (T2.name = 'Coldsnap' AND T1.artist = 'Aaron Miller') OR (T2.name = 'Coldsnap' AND T1.artist = 'Jeremy Jarvis') GROUP BY T1.artist",
    "evidence": [
      "card set Coldsnap refers to name = 'Coldsnap'; Jeremy Jarvis, Aaron Miller or Chippy are the name of artists which refers to artist IN ('Jeremy Jarvis', 'Aaron Miller','Chippy');"
    ]
  },
  "1295": {
    "reason": "To solve the question, we need to identify patients whose total bilirubin (`T-BIL`) is over the normal range (>= 2.0) and then determine how many of these patients have a peripheral pattern observed in their ANA examination (ANA Pattern contains 'P'). The steps are as follows:\n1. Filter patients from the Laboratory table where `T-BIL` >= 2.0.\n2. Join these patients with the Examination table to check their ANA Pattern.\n3. Count the number of patients where the ANA Pattern contains 'P'.",
    "sql": "SELECT COUNT(DISTINCT p.ID) AS PatientCount\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.`T-BIL` >= 2.0 AND e.`ANA Pattern` LIKE '%P%';",
    "question": "Among the patients whose total bilirubin is over the normal range, how many of them have a peripheral pattern observed in the sheet of ANA examination?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` >= 2 AND T3.`ANA Pattern` LIKE '%P%'",
    "evidence": [
      "total bilirubin is over the normal range refers to `T-BIL` > = 2.0; peripheral pattern is observed in the sheet of ANA examination refers to that ANA Pattern contains 'P';"
    ]
  },
  "860": {
    "reason": "To solve the question, we need to find the nationality of the driver who had a Q2 time of 0:01:40 in the qualifying race with raceId 355. Here's the step-by-step reasoning:\n\n1. **Identify the qualifying record**: We need to look in the `qualifying` table for the record where `raceId` is 355 and `q2` is '0:01:40'.\n2. **Retrieve the driverId**: From the qualifying record, extract the `driverId` associated with the Q2 time.\n3. **Find the driver's nationality**: Using the `driverId` obtained, query the `drivers` table to get the `nationality` of the driver.\n\nBy joining these steps, we can directly query the `qualifying` and `drivers` tables to get the required information.",
    "sql": "SELECT d.nationality\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nWHERE q.raceId = 355 AND q.q2 = '0:01:40';",
    "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
    "evidence": [
      "race number refers to raceId;"
    ]
  },
  "790": {
    "reason": "To calculate the difference between Emil Blonsky's weight and Charles Chandler's weight, we need to:\n1. Identify the superhero entries for Emil Blonsky and Charles Chandler in the `superhero` table.\n2. Retrieve their respective weights (`weight_kg`).\n3. Subtract Charles Chandler's weight from Emil Blonsky's weight to find the difference.\n\nThe query will involve joining the `superhero` table with itself to compare the weights of the two individuals.",
    "sql": "SELECT (e.weight_kg - c.weight_kg) AS weight_difference\nFROM superhero e, superhero c\nWHERE e.full_name = 'Emil Blonsky'\nAND c.full_name = 'Charles Chandler';",
    "question": "Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky' ) - ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler' ) AS CALCULATE",
    "evidence": [
      "difference = SUBTRACT(SUM(weight_kg WHERE full_name = 'Emil Blonsky'), SUM(weight_kg WHERE full_name = 'Charles Chandler')); Emil Blonsky is the full name of superhero; Charles Chandler is the full name of superhero;"
    ]
  },
  "1208": {
    "reason": "To solve the question, we need to find male patients (SEX = 'M') who have a history of ALT glutamic pyruvic transaminase (GPT) exceeding the normal range (GPT >= 60). The steps are as follows:\n1. Identify male patients from the Patient table.\n2. Join the Patient table with the Laboratory table to access GPT values.\n3. Filter records where GPT >= 60.\n4. Ensure the patients are male (SEX = 'M').\n5. Return the distinct IDs of these patients to avoid duplicates.",
    "sql": "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.GPT >= 60;",
    "question": "Provide IDs for male patients with ALT glutamic pylvic transaminase (GPT) that have history of ALT glutamic pylvic transaminase (GPT) exceed the normal range.",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.GPT >= 60",
    "evidence": [
      "male refers to SEX = 'M'; ALT glutamic pylvic transaminase (GPT) exceed the normal range refers to GPT > = 60"
    ]
  },
  "258": {
    "reason": "To find the bond types for atoms with the element Tin (Sn), we need to follow these steps:\n1. Identify all atoms with the element 'sn' (Tin) in the `atom` table.\n2. For each of these atoms, find the bonds they are involved in by joining the `connected` table.\n3. Retrieve the bond types from the `bond` table for these bonds.\n4. The query will involve joining the `atom`, `connected`, and `bond` tables to get the required information.",
    "sql": "SELECT DISTINCT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'sn';",
    "question": "What are the bond type for atoms with element Tin?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
    "evidence": [
      "element Tin refers to element = 'sn'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#'"
    ]
  },
  "1368": {
    "reason": "To find out what the person with the phone number \"809-555-3360\" majors in, we need to follow these steps:\n1. Identify the member with the phone number \"809-555-3360\" in the `member` table.\n2. Retrieve the `link_to_major` field for this member, which references the `major_id` in the `major` table.\n3. Join the `member` table with the `major` table using the `link_to_major` field to get the major details.\n4. Select the `major_name` from the `major` table for the identified member.",
    "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.phone = '809-555-3360';",
    "question": "What does the person with the phone number \"809-555-3360\" major in?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.phone = '809-555-3360'",
    "evidence": [
      "major in refers to major_name"
    ]
  },
  "1025": {
    "reason": "To find the league with the most goals in the 2016 season, we need to:\n1. Filter matches from the 2016 season (season = '2015/2016').\n2. Calculate the total goals for each league by summing the home_team_goal and away_team_goal for each match.\n3. Group the results by league_id to aggregate the total goals per league.\n4. Join the Match table with the League table to get the league names.\n5. Order the results by total goals in descending order and limit to the top result to find the league with the most goals.",
    "sql": "SELECT l.name AS league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2015/2016'\nGROUP BY m.league_id\nORDER BY total_goals DESC\nLIMIT 1;",
    "question": "Give the name of the league had the most goals in the 2016 season?",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' GROUP BY t2.name ORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC LIMIT 1",
    "evidence": [
      "league that had the most goals refers to MAX(SUM(home_team_goal, away_team_goal)); 2016 season refers to season = '2015/2016';"
    ]
  },
  "1341": {
    "reason": "To find the location for the event named \"Spring Budget Review\", I need to query the `event` table. The `event_name` column contains the name of the event, and the `location` column contains the location. I will filter the `event` table for the row where `event_name` is \"Spring Budget Review\" and retrieve the `location` value.",
    "sql": "SELECT location FROM event WHERE event_name = 'Spring Budget Review';",
    "question": "Give the location for \"Spring Budget Review\".",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT location FROM event WHERE event_name = 'Spring Budget Review'",
    "evidence": [
      "'Spring Budget Review' is an event name;"
    ]
  },
  "1307": {
    "reason": "To solve the question, we need to identify patients who meet two conditions: \n1. They have an abnormal level of red blood cells (RBC), which is defined as RBC ≤ 3.5 or RBC ≥ 6.0.\n2. They are followed at the outpatient clinic, which is indicated by Admission = '-' in the Patient table.\n\nWe will join the Patient and Laboratory tables to check these conditions. The query will filter patients based on their RBC levels and Admission status.",
    "sql": "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE (L.RBC <= 3.5 OR L.RBC >= 6.0) AND P.Admission = '-';",
    "question": "Please list the patient's ID if he or she has an abnormal level of red blood cell and is followed at the outpatient clinic.",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RBC <= 3.5 OR T2.RBC >= 6) AND T1.Admission = '-'",
    "evidence": [
      "RBC < = 3.5 or RBC > = 6.0 means the patient has an abnormal level of red blood cell; 3.5 < RBC < 6.0 means the patient has a normal level of red blood cell; followed at the outpatient clinic refers to Admission = '-';"
    ]
  },
  "1049": {
    "reason": "To find the number of matches in the 2015/2016 season held in the Scotland Premier League, we need to:\n1. Identify the league_id for the Scotland Premier League from the League table.\n2. Count the number of matches in the Match table where the league_id matches the identified league_id and the season is '2015/2016'.",
    "sql": "SELECT COUNT(*) \nFROM \"Match\" \nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Scotland Premier League') \nAND season = '2015/2016';",
    "question": "How many matches in the 2015/2016 season were held in Scotland Premier League\n?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' AND t1.name = 'Scotland Premier League'",
    "evidence": [
      "Scotland Premier League refers to League.name = 'Scotland Premier League';"
    ]
  },
  "879": {
    "reason": "To find the nationality of the driver who set the fastest lap speed, we need to follow these steps:\n1. Identify the driver with the fastest lap speed from the `results` table. The `fastestLapSpeed` column in the `results` table contains this information.\n2. Once we have the `driverId` of this driver, we can join the `results` table with the `drivers` table to retrieve the driver's nationality.\n3. The query will involve selecting the `nationality` from the `drivers` table where the `driverId` matches the one found in the `results` table with the highest `fastestLapSpeed`.",
    "sql": "SELECT d.nationality \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nWHERE r.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results);",
    "question": "For the driver who set the fastest lap speed, what is his nationality?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
    "evidence": [
      "the fastest lap speed refers to (MAX) fastestLapSpeed;"
    ]
  },
  "499": {
    "reason": "To find the number of translations of the name of the set \"Tenth Edition\", we need to follow these steps:\n1. Identify the set code for \"Tenth Edition\" from the `sets` table.\n2. Use this set code to query the `set_translations` table for all translations where the `setCode` matches the identified code.\n3. Count the number of rows returned from the `set_translations` query to get the total number of translations.\n\nThe tip provided indicates that the set \"Salvat 2011\" refers to the name \"Tenth Edition\", but since the question directly asks for \"Tenth Edition\", we will use the name \"Tenth Edition\" to find the set code.",
    "sql": "SELECT COUNT(*) AS translation_count\nFROM set_translations\nWHERE setCode = (SELECT code FROM sets WHERE name = 'Tenth Edition');",
    "question": "How many translations of the name of the set \"Tenth Edition\"?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL",
    "evidence": [
      "translations of the name refers to translation; translation is not NULL; set \"Salvat 2011\" refers to name = 'Tenth Edition'"
    ]
  },
  "445": {
    "reason": "To solve the question, we need to find the language and flavor text of a card that has a 'colorpie' watermark. Additionally, we need to list the type of this card. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `cards` table contains the watermark information, and the `foreign_data` table contains the language and flavor text for cards in different languages. The `cards` table also contains the type of the card.\n\n2. **Filter cards with 'colorpie' watermark**: We need to query the `cards` table to find cards where the `watermark` column is 'colorpie'.\n\n3. **Join with the `foreign_data` table**: Once we have the card(s) with the 'colorpie' watermark, we need to join this with the `foreign_data` table to get the language and flavor text.\n\n4. **Select the required fields**: We need to select the `language` and `flavorText` from the `foreign_data` table, and the `type` from the `cards` table.\n\n5. **Ensure uniqueness**: Since a card might have multiple entries in the `foreign_data` table (for different languages), we need to ensure we get all relevant entries.",
    "sql": "SELECT fd.language, fd.flavorText, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'colorpie';",
    "question": "What is the language and flavor text of the card that has colorpie watermark? List out the type of this card.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T2.language, T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'colorpie'",
    "evidence": [
      ""
    ]
  },
  "1213": {
    "reason": "To solve the question, we need to find the patient ID of someone born on April 1st, 1982, and then check if their ALP (alkaline phosphatase) levels are within the normal range (ALP < 300). The steps are as follows:\n1. Query the `Patient` table to find the ID of the patient born on '1982-04-01'.\n2. Use this ID to query the `Laboratory` table to retrieve the ALP value for this patient.\n3. Check if the ALP value is less than 300 to determine if it is within the normal range.",
    "sql": "SELECT p.ID, l.ALP, \n       CASE WHEN l.ALP < 300 THEN 'Within normal range' ELSE 'Above normal range' END AS ALP_Status\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Birthday = '1982-04-01';",
    "question": "Name the ID of the patient who is born on the April 1st, 1982. Is his/her alkaliphophatase (ALP) within normal range?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT T1.ID , CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1982-04-01'",
    "evidence": [
      "alkaliphophatase (ALP) within normal range refers to ALP < 300"
    ]
  },
  "1294": {
    "reason": "To solve the question, we need to find patients whose creatinine level (CRE) is normal (CRE < 1.5) and whose anti-Cardiolipin antibody concentration level (aCL IgA) is the highest. The steps are as follows:\n1. Identify patients with normal creatinine levels (CRE < 1.5) from the Laboratory table.\n2. From these patients, find the one with the highest aCL IgA value from the Examination table.\n3. Combine these conditions to list the patient IDs that meet both criteria.",
    "sql": "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.CRE < 1.5\nAND e.`aCL IgA` = (SELECT MAX(`aCL IgA`) FROM Examination WHERE `aCL IgA` IS NOT NULL);",
    "question": "Please list the patient's ID whose creatinine level is normal and whose anti Cardiolipin antibody concentration level is the highest.",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT T2.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.CRE < 1.5 ORDER BY T2.`aCL IgA` DESC LIMIT 1",
    "evidence": [
      "creatinine level is normal refers to CRE < 1.5; anti Cardiolipin antibody concentration level is the highest refers to MAX(aCL IgA);"
    ]
  },
  "144": {
    "reason": "To solve the question, we need to calculate the average amount of credit card withdrawals (Operation = 'VYBER KARTOU') made by account holders in each month of the year 2021. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `trans` table contains transaction data, including the operation type and amount. The `account` table links transactions to account holders.\n2. **Filter transactions**: We need to filter transactions where the operation is 'VYBER KARTOU' (credit card withdrawal) and the date falls within the year 2021.\n3. **Group by month**: Extract the month from the transaction date to group the data by month.\n4. **Calculate the average amount**: For each month, calculate the average amount of these transactions.\n5. **Join with account table**: Ensure the transactions are linked to valid account holders.\n\nThis will give us the average amount of credit card withdrawals per month in 2021.",
    "sql": "SELECT \n    strftime('%m', t.date) AS month,\n    AVG(t.amount) AS average_amount\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nWHERE \n    t.operation = 'VYBER KARTOU'\n    AND strftime('%Y', t.date) = '2021'\nGROUP BY \n    month\nORDER BY \n    month;",
    "question": "How much is the average amount in credit card made by account holders in a month, in year 2021?",
    "db_id": "financial",
    "res": 0,
    "ground_truth": "SELECT AVG(T4.amount) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE STRFTIME('%Y', T4.date) = '1998' AND T4.operation = 'VYBER KARTOU'",
    "evidence": [
      "Operation = 'VYBER KARTOU' refers to credit card withdrawn"
    ]
  },
  "14": {
    "reason": "To solve the question, we need to list the top five schools with the highest enrollment for students aged 5-17, ordered in descending order. The NCES school identification number is required for each school. The enrollment data is stored in the `frpm` table, and the NCES school identification number is stored in the `schools` table. We will join these two tables on the `CDSCode` field to retrieve the required information. The query will order the results by the `Enrollment (Ages 5-17)` column in descending order and limit the output to the top five schools.",
    "sql": "SELECT s.NCESchool, f.\"School Name\", f.\"Enrollment (Ages 5-17)\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nORDER BY f.\"Enrollment (Ages 5-17)\" DESC\nLIMIT 5;",
    "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
    "evidence": [
      ""
    ]
  },
  "556": {
    "reason": "To find the average number of badges obtained by users with over 200 views, we need to follow these steps:\n1. Identify users who have more than 200 views from the `users` table.\n2. For each of these users, count the number of badges they have obtained from the `badges` table.\n3. Calculate the average of these counts to get the desired result.\n\nThe query will involve joining the `users` and `badges` tables, filtering users with views > 200, grouping by user, counting badges per user, and then averaging these counts.",
    "sql": "SELECT AVG(badge_count) AS average_badges\nFROM (\n    SELECT u.Id, COUNT(b.Id) AS badge_count\n    FROM users u\n    LEFT JOIN badges b ON u.Id = b.UserId\n    WHERE u.Views > 200\n    GROUP BY u.Id\n) AS user_badges;",
    "question": "What is the average number of badges obtained by a user with over 200 views?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Views > 200",
    "evidence": [
      "user with over 200 views refers to Views > 200; average number of badges = Divide (Count(Id), Count(DisplayName))"
    ]
  },
  "1202": {
    "reason": "To solve the question, we need to find the number of male patients who underwent testing between 1995 and 1997, were diagnosed with Behcet disease, and did not stay in the hospital. The steps are as follows:\n1. Identify male patients (SEX = 'M') from the Patient table.\n2. Join the Patient table with the Examination table to filter patients who underwent testing between 1995 and 1997 (`Examination Date` between '1995-01-01' and '1997-12-31').\n3. Filter these patients for those diagnosed with Behcet disease (Diagnosis = 'Behcet').\n4. Ensure these patients did not stay in the hospital (Admission = '-').\n5. Count the distinct patients who meet all these criteria.",
    "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'M'\nAND E.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31'\nAND E.Diagnosis = 'Behcet'\nAND P.Admission = '-';",
    "question": "How many male patients who underwent testing between 1995 and 1997 and were subsequently diagnosed with Behcet disease did not stay in the hospital for treatment?",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'Behcet' AND T1.SEX = 'M' AND STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1995' AND '1997' AND T1.Admission = '-'",
    "evidence": [
      "male refers to SEX = 'M'; underwent testing between 1995 and 1997 refers to `Examination Date` between '1995' and '1997'; Behcet refers to diagnosis; did not stay in the hospital refers to Admission = '-'"
    ]
  },
  "835": {
    "reason": "To solve the question, we need to identify the percentage of 'good' superheroes among all superheroes in Marvel Comics. Here's the step-by-step reasoning:\n\n1. **Identify Marvel Comics superheroes**: We need to filter superheroes whose `publisher_id` corresponds to 'Marvel Comics' in the `publisher` table.\n2. **Identify 'good' superheroes**: We need to filter superheroes whose `alignment_id` corresponds to 'good' in the `alignment` table.\n3. **Calculate the percentage**: Divide the count of 'good' Marvel Comics superheroes by the total count of Marvel Comics superheroes and multiply by 100 to get the percentage.\n\nWe will join the `superhero` table with the `publisher` and `alignment` tables to achieve this.",
    "sql": "SELECT \n    (COUNT(CASE WHEN a.alignment = 'Good' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_good\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    alignment a ON s.alignment_id = a.id\nWHERE \n    p.publisher_name = 'Marvel Comics';",
    "question": "Among all superheroes in Marvel Comics, identify the percentage of 'good' superheroes.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics'",
    "evidence": [
      "Marvel Comics refers to publisher_name = 'Marvel Comics'; percentage = MULTIPLY(DIVIDE(SUM(alignment = 'Good' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100.0); good superheroes refers to alignment = 'Good';"
    ]
  },
  "1373": {
    "reason": "To find out how many members' hometowns are from Maryland state, we need to:\n1. Join the `member` table with the `zip_code` table using the `zip` column in `member` and `zip_code` column in `zip_code`.\n2. Filter the results where the `state` column in the `zip_code` table is 'Maryland'.\n3. Count the number of distinct members who meet this condition.",
    "sql": "SELECT COUNT(DISTINCT m.member_id) \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE z.state = 'Maryland';",
    "question": "How many of the members' hometowns are from Maryland state?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT COUNT(T2.member_id) FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T1.state = 'Maryland'",
    "evidence": [
      ""
    ]
  },
  "1427": {
    "reason": "To solve the question, we need to find the budget categories of events that meet the following criteria:\n1. The event is located at 'MU 215'.\n2. The event type is 'Guest Speaker'.\n3. The budget spent for the event is 0.\n\nWe will join the `event` table with the `budget` table to link the event details with the budget information. The join condition will be based on the `event_id` in the `event` table and the `link_to_event` in the `budget` table. Then, we will filter the results based on the given criteria.",
    "sql": "SELECT b.category\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.location = 'MU 215'\n  AND e.type = 'Guest Speaker'\n  AND b.spent = 0;",
    "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
    "evidence": [
      "budget category refers to category; events located at refers to location; type = 'Guest Speaker'; 0 budget spent refers to spent = 0; "
    ]
  },
  "1060": {
    "reason": "To find the number of players born after 1990, we need to query the `Player` table and filter the records where the `birthday` field is after the year 1990. The `birthday` field is stored as text, so we can use the `strftime` function to extract the year from the date and compare it with 1990. We will then count the number of such players.",
    "sql": "SELECT COUNT(*) FROM Player WHERE strftime('%Y', birthday) > '1990';",
    "question": "How many players were born after 1990?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990'",
    "evidence": [
      "born after 1990 refers to strftime('%Y', birthday) = '1990';"
    ]
  },
  "869": {
    "reason": "To solve the question, we need to find the constructor with the highest points in race No. 9 and then retrieve its introduction website. The steps are as follows:\n1. Identify the constructor with the highest points in race No. 9 from the `constructorResults` table.\n2. Use the `constructorId` obtained from the first step to fetch the constructor's website URL from the `constructors` table.\n3. Combine these steps into a single query to get the desired result.",
    "sql": "SELECT c.url\nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nWHERE cr.raceId = 9\nORDER BY cr.points DESC\nLIMIT 1;",
    "question": "For the constructor which got the highest point in the race No. 9 , what is its introduction website?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T2.url FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 9 ORDER BY T1.points DESC LIMIT 1",
    "evidence": [
      "race number refers to raceId; constructor which got the highest point refers to MAX(constructorResults.points); introduction website of the constructor refers to url;"
    ]
  },
  "1089": {
    "reason": "To find the number of matches held in Belgium during the 2008/2009 season, we need to:\n1. Identify the country_id for Belgium from the `Country` table.\n2. Use this country_id to filter matches in the `Match` table where the `season` is '2008/2009' and the `country_id` matches the one for Belgium.\n3. Count the number of such matches.",
    "sql": "SELECT COUNT(*) AS number_of_matches\nFROM Match\nWHERE season = '2008/2009'\nAND country_id = (SELECT id FROM Country WHERE name = 'Belgium');",
    "question": "How many matches in the 2008/2009 season were held in Belgium?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Belgium' AND t2.season = '2008/2009'",
    "evidence": [
      "Belgium refers to Country.name = 'Belgium';"
    ]
  },
  "446": {
    "reason": "To solve the question, we need to find the percentage of cards in the set 'Abyssal Horror' that have a converted mana cost (CMC) of 10. The steps are as follows:\n1. Identify the set code for 'Abyssal Horror' from the 'sets' table.\n2. Count the total number of cards in the 'Abyssal Horror' set from the 'cards' table.\n3. Count the number of cards in the 'Abyssal Horror' set with a CMC of 10.\n4. Calculate the percentage by dividing the count of cards with CMC 10 by the total count of cards in the set and multiplying by 100.\n5. Ensure the query handles cases where the total count might be zero to avoid division by zero errors.",
    "sql": "WITH abyssal_horror_set AS (\n    SELECT code FROM sets WHERE name = 'Abyssal Horror'\n),\ntotal_cards AS (\n    SELECT COUNT(*) AS total FROM cards WHERE setCode = (SELECT code FROM abyssal_horror_set)\n),\ncmc_10_cards AS (\n    SELECT COUNT(*) AS cmc_10 FROM cards WHERE setCode = (SELECT code FROM abyssal_horror_set) AND convertedManaCost = 10\n)\nSELECT (cmc_10 * 100.0 / NULLIF(total, 0)) AS percentage\nFROM total_cards, cmc_10_cards;",
    "question": "What is percentage of the cards with a converted Mana Cost of 10 in set of Abyssal Horror?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'",
    "evidence": [
      "set of Abyssal Horror refers to name = 'Abyssal Horror'; percentage refers to DIVIDE(COUNT(convertedManaCost = 16),COUNT(convertedManaCost))*100"
    ]
  },
  "887": {
    "reason": "To solve the question, we need to find the races in the year 2017 that were not hosted in the year 2000. This involves two steps:\n1. Identify all races that took place in 2017.\n2. From these races, exclude those that were also hosted in 2000.\n\nTo achieve this, we can use a subquery to find the circuits that hosted races in 2000 and then exclude races in 2017 that used these circuits. The query will join the `races` table with itself to compare the circuits used in both years.",
    "sql": "SELECT r2017.name\nFROM races r2017\nWHERE r2017.year = 2017\nAND r2017.circuitId NOT IN (\n    SELECT r2000.circuitId\n    FROM races r2000\n    WHERE r2000.year = 2000\n);",
    "question": "Name the races in year 2017 that are not hosted in year 2000.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT name FROM races WHERE year = 2017 AND name NOT IN ( SELECT name FROM races WHERE year = 2000 )",
    "evidence": [
      "not hosted means not in;"
    ]
  },
  "216": {
    "reason": "To identify all connected atoms with a triple bond, we need to follow these steps:\n1. Understand that a triple bond is indicated by `bond_type = '#'` in the `bond` table.\n2. The `connected` table links atoms (`atom_id` and `atom_id2`) via a `bond_id`.\n3. We need to join the `connected` table with the `bond` table to filter for triple bonds.\n4. Once filtered, we can retrieve the connected atom pairs (`atom_id` and `atom_id2`) that are linked by a triple bond.\n5. Optionally, we can also include the `bond_id` for reference.",
    "sql": "SELECT c.atom_id, c.atom_id2, c.bond_id\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '#';",
    "question": "Identify all connected atoms with a triple bond.",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
    "evidence": [
      "triple bond refers to bond_type = '#';"
    ]
  },
  "1052": {
    "reason": "To solve the question, we need to find the number of players who weigh under 130 and have a preferred foot in attacking as 'left'. The steps are as follows:\n1. Identify the relevant table: `Player` for weight and `Player_Attributes` for preferred foot.\n2. Join these tables on the common player identifiers (`player_api_id` or `player_fifa_api_id`).\n3. Filter the players where `weight` is less than 130 and `preferred_foot` is 'left'.\n4. Count the number of such players.",
    "sql": "SELECT COUNT(*) AS left_footed_players_under_130_weight\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.weight < 130 AND pa.preferred_foot = 'left';",
    "question": "Among all the players whose weight is under 130, how many of them preferred foot in attacking is left?",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.weight < 130 AND t2.preferred_foot = 'left'",
    "evidence": [
      "weight < 130; preferred foot in attacking refers to preferred_foot; preferred_foot = 'left';"
    ]
  },
  "41": {
    "reason": "To solve the question, we need to identify virtual schools that are among the top 5 in their respective counties based on average reading scores. Here's the step-by-step reasoning:\n\n1. **Identify Virtual Schools**: The question specifies that we need to consider schools where `Virtual = 'F'` (as per the tip).\n2. **Filter by County**: We need to partition the data by county to find the top 5 schools in each county.\n3. **Rank Schools by Reading Scores**: Within each county, we will rank schools based on their average reading scores (`AvgScrRead`).\n4. **Select Top 5 Schools**: For each county, we will select the top 5 schools with the highest average reading scores.\n5. **Join Tables**: We will join the `satscores` table with the `schools` table to get the school names and other relevant details.\n6. **Filter Results**: Finally, we will filter the results to include only virtual schools (`Virtual = 'F'`).\n\nThe SQL query will use window functions to partition by county and rank schools by their average reading scores, then filter for the top 5 in each county and virtual schools.",
    "sql": "WITH RankedSchools AS (\n    SELECT \n        s.School,\n        s.County,\n        sc.AvgScrRead,\n        RANK() OVER (PARTITION BY s.County ORDER BY sc.AvgScrRead DESC) AS rank_in_county\n    FROM \n        schools s\n    JOIN \n        satscores sc ON s.CDSCode = sc.cds\n    WHERE \n        s.Virtual = 'F'\n)\nSELECT \n    School,\n    County,\n    AvgScrRead\nFROM \n    RankedSchools\nWHERE \n    rank_in_county <= 5\nORDER BY \n    County, rank_in_county;",
    "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
    "evidence": [
      "Exclusively virtual refers to Virtual = 'F'; respective counties means PARTITION BY County"
    ]
  },
  "1275": {
    "reason": "To solve the question, we need to find the number of male patients who have normal levels of both anti-centromere (CENTROMEA) and anti-SSB (SSB). The normal levels for these are defined as CENTROMEA IN ('-', '+-') and SSB IN ('-', '+-'). We will join the Patient table with the Laboratory table to filter patients based on these conditions and then count the distinct male patients.",
    "sql": "SELECT COUNT(DISTINCT P.ID) AS MalePatientsWithNormalLevels\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M'\nAND L.CENTROMEA IN ('-', '+-')\nAND L.SSB IN ('-', '+-');",
    "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
    "evidence": [
      "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;"
    ]
  },
  "1436": {
    "reason": "To solve the question, we need to find members who have paid more than $50 (i.e., cost > 50 in the expense table) and then link these members to the events they attended. The steps are as follows:\n1. Identify members in the expense table where the cost is greater than 50.\n2. Use the link_to_member field in the expense table to join with the member table to get member details.\n3. Join the member table with the attendance table to find the events these members attended.\n4. Finally, join the attendance table with the event table to get the event details.\n5. Return the event_id (link_to_event) for these members.",
    "sql": "SELECT DISTINCT a.link_to_event\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nWHERE e.cost > 50;",
    "question": "Please provide links to events for members who have paid more than 50 dollar.",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T1.cost > 50",
    "evidence": [
      "have paid more than 50 dollar refers to cost > 50"
    ]
  },
  "394": {
    "reason": "To solve the question, we need to find the count of white-bordered cards that are also considered powerful. According to the tips provided:\n1. White-bordered cards are identified by the condition `borderColor = 'white'`.\n2. Powerful cards are identified by the condition `cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL`.\n\nWe will query the `cards` table to count the number of rows that satisfy both conditions.",
    "sql": "SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
    "question": "How many white bordered cards are powerful?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
    "evidence": [
      "white bordered cards refer to borderColor = 'white'; powerful cards refers to cardKingdomFoilId is not null AND cardKingdomId is not null (replace)"
    ]
  },
  "1002": {
    "reason": "To solve the question, we need to find the youngest racer (based on the maximum date of birth), their full name (forename + surname), nationality, and the name of the first race they participated in. The steps are as follows:\n1. Identify the youngest racer by finding the driver with the maximum date of birth (dob) from the `drivers` table.\n2. Retrieve the full name (forename + surname) and nationality of this driver.\n3. Find the earliest race this driver participated in by joining the `results` table with the `races` table and ordering by the race date.\n4. Combine these results to get the required information.",
    "sql": "WITH youngest_driver AS (\n    SELECT driverId, forename || ' ' || surname AS full_name, nationality, dob\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 1\n),\nfirst_race AS (\n    SELECT r.raceId, r.name AS race_name, ra.date\n    FROM results r\n    JOIN races ra ON r.raceId = ra.raceId\n    JOIN youngest_driver yd ON r.driverId = yd.driverId\n    ORDER BY ra.date ASC\n    LIMIT 1\n)\nSELECT yd.full_name, yd.nationality, fr.race_name\nFROM youngest_driver yd, first_race fr;",
    "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
    "evidence": [
      "full name refers to forename+surname; Youngest racer = MAX(dob)"
    ]
  },
  "354": {
    "reason": "To solve the question, we need to find out how many distinct types of cards the artist 'Aaron Boyd' has illustrated. The schema includes a 'cards' table with an 'artist' column and a 'types' column. The 'artist' column contains the name of the artist, and the 'types' column contains the types of the cards. We will query the 'cards' table to filter records where the artist is 'Aaron Boyd', then count the distinct types of cards he has illustrated.",
    "sql": "SELECT COUNT(DISTINCT types) FROM cards WHERE artist = 'Aaron Boyd';",
    "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
    "evidence": [
      "Aaron Boyd' is artist;"
    ]
  },
  "426": {
    "reason": "To find the top three sets that don't appear in Magic: The Gathering Online (MTGO), we need to query the `sets` table where the `mtgoCode` is NULL or empty, as this indicates the set is not available on MTGO. We then order the results by the set name in alphabetical order and limit the output to the top three sets.",
    "sql": "SELECT name FROM sets WHERE mtgoCode IS NULL OR mtgoCode = '' ORDER BY name ASC LIMIT 3;",
    "question": "Please provide top three sets that don't appear in Magic: The Gathering Online, along with their names in in alphabetical order.",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3",
    "evidence": [
      "don't appear in Magic: The Gathering Online refers to mtgoCode is NULL or mtgoCode = ''"
    ]
  },
  "352": {
    "reason": "To calculate the percentage of cards available in Chinese Simplified, we need to:\n1. Count the total number of cards in the `foreign_data` table where the language is 'Chinese Simplified'.\n2. Count the total number of unique cards (using `uuid`) in the `foreign_data` table.\n3. Divide the count from step 1 by the count from step 2 and multiply by 100 to get the percentage.\n\nThe query will use the `foreign_data` table and filter for 'Chinese Simplified' language.",
    "sql": "SELECT (COUNT(DISTINCT CASE WHEN language = 'Chinese Simplified' THEN uuid END) * 100.0 / COUNT(DISTINCT uuid)) AS percentage\nFROM foreign_data;",
    "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
    "evidence": [
      "Chinese Simplified' is the language; percentage = Divide(Sum(id where language = 'Chinese Simplified'), Count(id)) *100"
    ]
  },
  "1506": {
    "reason": "To solve the question, we need to find the product descriptions of transactions that occurred in gas stations located in the Czech Republic. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `transactions_1k` table contains transaction details, including `GasStationID` and `ProductID`. The `gasstations` table contains information about gas stations, including their `Country`. The `products` table contains product descriptions.\n\n2. **Filter gas stations in the Czech Republic**: We need to join the `transactions_1k` table with the `gasstations` table to filter transactions where the `Country` is 'CZE' (Czech Republic).\n\n3. **Retrieve product descriptions**: After filtering the transactions, we join the result with the `products` table to get the `Description` of the products involved in these transactions.\n\n4. **Final query**: The query will involve joining the three tables (`transactions_1k`, `gasstations`, and `products`) and filtering for the Czech Republic.",
    "sql": "SELECT p.Description\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE g.Country = 'CZE';",
    "question": "Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.",
    "db_id": "debit_card_specializing",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T3.Description FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Country = 'CZE'",
    "evidence": [
      "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; "
    ]
  },
  "123": {
    "reason": "To solve the question, we need to find the account ID, district, and region for loans with an amount greater than USD 300,000. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `loan` table contains loan amounts, the `account` table links loans to accounts, and the `district` table provides district and region information.\n2. **Join the tables**: We need to join the `loan` table with the `account` table using `account_id`, and then join the result with the `district` table using `district_id`.\n3. **Filter the data**: We will filter the loans where the `amount` is greater than 300,000.\n4. **Select the required columns**: The columns to select are `account_id` from the `account` table, `A2` (district name) and `A3` (region) from the `district` table.\n\nThis will give us the desired result.",
    "sql": "SELECT a.account_id, d.A2 AS district, d.A3 AS region\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.amount > 300000;",
    "question": "Provide the account ID, district and region for loan amount greater than USD300,000.",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.amount > 300000",
    "evidence": [
      "A2 contains district names and A3 contains region names."
    ]
  },
  "1425": {
    "reason": "To solve the question, we need to find the number of majors in the College of Agriculture and Applied Sciences that are under the department of School of Applied Sciences, Technology and Education. We will query the `major` table, filtering for records where the `college` is 'College of Agriculture and Applied Sciences' and the `department` is 'School of Applied Sciences, Technology and Education'. The result will be the count of such records.",
    "sql": "SELECT COUNT(*) FROM major WHERE college = 'College of Agriculture and Applied Sciences' AND department = 'School of Applied Sciences, Technology and Education';",
    "question": "In the College of Agriculture and Applied Sciences, how many majors are under the department of School of Applied Sciences, Technology and Education?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT COUNT(major_id) FROM major WHERE department = 'School of Applied Sciences, Technology and Education' AND college = 'College of Agriculture and Applied Sciences'",
    "evidence": [
      ""
    ]
  },
  "984": {
    "reason": "To find the website of the constructor with the most total wins, we need to follow these steps:\n1. Identify the table that tracks constructor wins, which is `constructorStandings`.\n2. Sum the wins for each constructor by grouping them by `constructorId`.\n3. Find the constructor with the highest sum of wins.\n4. Retrieve the website URL of this constructor from the `constructors` table.\n5. Join the `constructorStandings` and `constructors` tables to get the required information.",
    "sql": "SELECT c.url\nFROM constructors c\nJOIN (\n    SELECT constructorId, SUM(wins) AS total_wins\n    FROM constructorStandings\n    GROUP BY constructorId\n    ORDER BY total_wins DESC\n    LIMIT 1\n) AS max_wins ON c.constructorId = max_wins.constructorId;",
    "question": "What is the website of the constructor who tallied the most total wins.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1",
    "evidence": [
      "introduction website refers to url;"
    ]
  },
  "1290": {
    "reason": "To solve the question, we need to find the examination date of the patient whose albumin (ALB) is the highest within the normal range (3.5 to 5.5). The steps are as follows:\n1. Identify the patient with the highest ALB value within the normal range from the Laboratory table.\n2. Use the ID of this patient to find their examination date from the Examination table.\n3. Join the Laboratory and Examination tables on the patient ID to link the ALB value with the examination date.\n4. Filter the ALB values to only include those within the normal range (3.5 to 5.5).\n5. Order the results by ALB in descending order to find the highest value.\n6. Limit the result to the top record to get the patient with the highest ALB.",
    "sql": "SELECT e.\"Examination Date\"\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE l.ALB BETWEEN 3.5 AND 5.5\nORDER BY l.ALB DESC\nLIMIT 1;",
    "question": "What is the examination date of the patient whose albumin is the highest in the normal range?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1",
    "evidence": [
      "examination date refers to Date; albumin is the highest in the normal range refers to MAX(ALB > 3.5 and ALB < 5.5);"
    ]
  },
  "794": {
    "reason": "To find the fastest hero, we need to identify the superhero with the highest attribute value for 'Speed'. This involves joining the `superhero` table with the `hero_attribute` and `attribute` tables. The steps are:\n1. Join `hero_attribute` with `attribute` to filter for the 'Speed' attribute.\n2. Join the result with the `superhero` table to get the hero's name.\n3. Use the `MAX` function on `attribute_value` to find the highest speed value.\n4. Retrieve the superhero name corresponding to this maximum speed value.",
    "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nGROUP BY s.superhero_name\nORDER BY MAX(ha.attribute_value) DESC\nLIMIT 1;",
    "question": "Which hero was the fastest?",
    "db_id": "superhero",
    "res": 0,
    "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
    "evidence": [
      "which hero refers to superhero_name; fastest refers to MAX(attribute_value) WHERE attribute_name = 'Speed';"
    ]
  },
  "447": {
    "reason": "To find the code of sets that have the type 'expansion' and 'commander', we need to query the 'sets' table. The 'type' column in the 'sets' table contains the type of the set. We will filter the sets where the 'type' column includes both 'expansion' and 'commander'. This can be achieved by using a WHERE clause to check for the desired type.",
    "sql": "SELECT code FROM sets WHERE type = 'expansion' OR type = 'commander';",
    "question": "Give the code of sets have expansion commander type?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
    "evidence": [
      "code of sets refers to setCode"
    ]
  },
  "730": {
    "reason": "To solve the question, we need to list superheroes from Marvel Comics who have the superpower 'Super Strength'. This involves the following steps:\n1. Identify the publisher 'Marvel Comics' in the `publisher` table.\n2. Identify the superpower 'Super Strength' in the `superpower` table.\n3. Join the `superhero` table with the `publisher` table to filter superheroes from Marvel Comics.\n4. Join the `superhero` table with the `hero_power` and `superpower` tables to filter superheroes with 'Super Strength'.\n5. Combine these conditions to get the final list of superheroes.",
    "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE p.publisher_name = 'Marvel Comics'\nAND sp.power_name = 'Super Strength';",
    "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
    "evidence": [
      "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; super power of \"Super Strength\" refers to power_name = 'Super Strength';"
    ]
  },
  "926": {
    "reason": "To find the fastest lap time ever in a race for Lewis Hamilton, we need to:\n1. Identify Lewis Hamilton's driverId from the drivers table using his name (forename and surname).\n2. Join the results table with the drivers table to filter results for Lewis Hamilton.\n3. Find the minimum value of the fastestLapTime column in the results table for Lewis Hamilton.\n4. Ensure the query handles the time format correctly to determine the minimum time.",
    "sql": "SELECT MIN(r.fastestLapTime) AS fastest_lap_time\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
    "question": "What's the fastest lap time ever in a race for Lewis Hamilton?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T2.fastestLapTime FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
    "evidence": [
      "fastest lap time ever refers to min(fastestLapTime)"
    ]
  },
  "642": {
    "reason": "To find the number of posts created on 21st July 2010, we need to query the `posts` table and count the entries where the `CreationDate` falls within the specified date range (from '2010-07-21 00:00:00' to '2010-07-21 23:59:59'). The `CreationDate` column in the `posts` table stores the date and time when each post was created. The query will use the `COUNT` function to tally the number of posts that meet this condition.",
    "sql": "SELECT COUNT(*) FROM posts WHERE CreationDate BETWEEN '2010-07-21 00:00:00' AND '2010-07-21 23:59:59';",
    "question": "How many posts were created on 21st July, 2010?",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT COUNT(id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'",
    "evidence": [
      "created on 21st July, 2010 refers to CreationDate BETWEEN '2010-07-21 00:00:00' and '2012-07-21 23:59:59';"
    ]
  },
  "1174": {
    "reason": "To solve the question, we need to find the average age of patients as of the year 1999 who were examined in the laboratory during October 1991. Here's the step-by-step reasoning:\n\n1. **Identify Patients Examined in October 1991**: We need to filter the `Laboratory` table for records where the `Date` falls between October 1, 1991, and October 31, 1991.\n2. **Calculate Age as of 1999**: For each patient identified in step 1, calculate their age as of the year 1999. This involves subtracting the year of their `Birthday` from 1999.\n3. **Compute Average Age**: Finally, compute the average of the ages calculated in step 2.\n\nWe will join the `Laboratory` table with the `Patient` table to access the `Birthday` field for each patient.",
    "sql": "SELECT AVG(1999 - strftime('%Y', p.Birthday)) AS average_age\nFROM Laboratory l\nJOIN Patient p ON l.ID = p.ID\nWHERE l.Date BETWEEN '1991-10-01' AND '1991-10-31';",
    "question": "What is the average age of patients as of year 1999 examined in the laboratory for the October of the year 1991?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT AVG('1999'  - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
    "evidence": [
      "average age of patients as of year 1999 refers to AVG(SUBTRACT('1999', year(Birthday))); October of 1991 refers to Date BETWEEN '1991-10-01' AND '1991-10-30'"
    ]
  },
  "700": {
    "reason": "To solve the question, we need to identify the number of posts that offer a bounty amount over 30. The `votes` table contains information about bounties, including the `BountyAmount` column. We will query the `votes` table to count the number of records where `BountyAmount` is greater than or equal to 30. The `PostId` in the `votes` table links to the `posts` table, but since we only need the count of such posts, we don't need to join with the `posts` table for this specific query.",
    "sql": "SELECT COUNT(*) AS NumberOfPostsWithBountyOver30 FROM votes WHERE BountyAmount >= 30;",
    "question": "Identify the number of posts that offer a bounty amount over 30.",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(id) FROM votes WHERE BountyAmount >= 30",
    "evidence": [
      "bounty amount over 30 refers to BountyAmount > = 30;"
    ]
  },
  "919": {
    "reason": "To find out which circuit was used for the 2009 Spanish Grand Prix, we need to query the `races` table. The `races` table contains information about races, including the year, name, and the circuitId (which links to the `circuits` table). We can filter the races by the year 2009 and the name 'Spanish Grand Prix', then join the result with the `circuits` table to get the circuit's name.",
    "sql": "SELECT c.name AS circuit_name FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2009 AND r.name = 'Spanish Grand Prix';",
    "question": "Which circuit did the 2009 Spanish Grand Prix use?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
    "evidence": [
      ""
    ]
  },
  "814": {
    "reason": "To solve the question, we need to find the skin colour of superheroes who have an attribute value of 100. This involves joining multiple tables:\n1. The `hero_attribute` table to filter superheroes with an attribute value of 100.\n2. The `superhero` table to get the skin colour ID of these superheroes.\n3. The `colour` table to translate the skin colour ID into the actual skin colour name.\n\nThe steps are:\n- Join `hero_attribute` with `superhero` on `hero_id`.\n- Filter records where `attribute_value` is 100.\n- Join the result with the `colour` table on `skin_colour_id` to get the skin colour name.\n- Select the `colour` field from the `colour` table.",
    "sql": "SELECT c.colour\nFROM hero_attribute ha\nJOIN superhero s ON ha.hero_id = s.id\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE ha.attribute_value = 100;",
    "question": "List the skin colour of the superheroes with 100 attribute value.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id WHERE T3.attribute_value = 100",
    "evidence": [
      "skin colour refers to colour.colour where skin_colour_id = colour.id; 100 attribute value refers to attribute_value = 100;"
    ]
  },
  "940": {
    "reason": "To solve the question, we need to identify drivers who finished the 2008 Chinese Grand Prix and then determine how many of them have participated in other Formula 1 races. Here's the step-by-step reasoning:\n\n1. **Identify the raceId for the 2008 Chinese Grand Prix**: We need to find the raceId from the `races` table where the year is 2008 and the name is 'Chinese Grand Prix'.\n\n2. **Find drivers who finished the race**: Using the `results` table, we look for entries where the raceId matches the one found in step 1 and the `time` field is not NULL (indicating they finished the race).\n\n3. **Count participation in other races**: For each driver identified in step 2, we count how many times they appear in the `results` table (excluding the 2008 Chinese Grand Prix) to determine their participation in other races.\n\n4. **Filter drivers with participation in other races**: We filter the list to include only those drivers who have participated in at least one other race (COUNT(raceId) > 0).\n\n5. **Count the number of such drivers**: Finally, we count the number of drivers who meet the criteria.",
    "sql": "WITH chinese_gp_2008 AS (\n    SELECT raceId\n    FROM races\n    WHERE year = 2008 AND name = 'Chinese Grand Prix'\n),\nfinished_drivers AS (\n    SELECT driverId\n    FROM results\n    WHERE raceId = (SELECT raceId FROM chinese_gp_2008) AND time IS NOT NULL\n),\nparticipated_drivers AS (\n    SELECT r.driverId\n    FROM results r\n    JOIN finished_drivers fd ON r.driverId = fd.driverId\n    WHERE r.raceId != (SELECT raceId FROM chinese_gp_2008)\n    GROUP BY r.driverId\n    HAVING COUNT(r.raceId) > 0\n)\nSELECT COUNT(*) AS num_drivers\nFROM participated_drivers;",
    "question": "Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )",
    "evidence": [
      "COUNT(raceID) > 0 reveals that this driver participated in races; drivers who finished the race refers to time has value."
    ]
  },
  "1178": {
    "reason": "To find the gender of the first AORTITIS diagnosed patient, we need to follow these steps:\n1. Identify the patient(s) with the diagnosis 'AORTITIS' from the `Patient` table.\n2. Among these patients, determine the one with the earliest diagnosis date (referred to as 'First Date' in the schema).\n3. Retrieve the gender (SEX) of this patient.\n\nThe query will involve joining the `Patient` table with itself or filtering to find the earliest 'First Date' for 'AORTITIS' patients, then selecting the SEX of that patient.",
    "sql": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' ORDER BY `First Date` ASC LIMIT 1;",
    "question": "What was the gender of the first AORTITIS diagnosed patient?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
    "evidence": [
      "gender means SEX; 'AORTITIS' refers to Diagnosis;"
    ]
  },
  "46": {
    "reason": "To solve the question, we need to identify state special schools (DOC = 31) with the highest number of enrollees from grades 1 through 12 (K-12). The steps are as follows:\n1. Join the `schools` table with the `frpm` table using the `CDSCode` to access enrollment data.\n2. Filter for schools where `DOC` is '31' (state special schools).\n3. Use the `Enrollment (K-12)` column from the `frpm` table to determine the number of enrollees.\n4. Order the results by `Enrollment (K-12)` in descending order to find the highest numbers.\n5. Limit the results to the top entries if needed.",
    "sql": "SELECT s.CDSCode, s.School, s.District, s.County, f.\"Enrollment (K-12)\"\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.DOC = '31'\nORDER BY f.\"Enrollment (K-12)\" DESC\nLIMIT 10;",
    "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
    "evidence": [
      "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12"
    ]
  },
  "1322": {
    "reason": "To solve the question, we need to find out how many events are meetings (type = 'Meeting') and have been attended by more than 10 members. The steps are as follows:\n1. Identify all events where the type is 'Meeting'.\n2. For each of these events, count the number of members who attended (using the attendance table).\n3. Filter out events where the count of attendees is greater than 10.\n4. Finally, count the number of such events that meet both criteria.",
    "sql": "SELECT COUNT(*) AS meeting_events_with_more_than_10_attendees\nFROM event e\nWHERE e.type = 'Meeting'\nAND (\n    SELECT COUNT(*)\n    FROM attendance a\n    WHERE a.link_to_event = e.event_id\n) > 10;",
    "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
    "evidence": [
      "meetings events refers to type = 'Meeting'; attended by more than 10 members refers to COUNT(event_id) > 10"
    ]
  },
  "1243": {
    "reason": "To solve the question, we need to find the percentage of female patients older than 55 years who have an abnormal prothrombin time (PT >= 14). The steps are as follows:\n1. Identify patients older than 55 years by calculating the difference between the current year and their birth year.\n2. From this subset, count the number of female patients (SEX = 'F') with PT >= 14.\n3. Also, count the total number of patients (regardless of sex) with PT >= 14 in the same age group.\n4. Calculate the percentage by dividing the count of female patients with abnormal PT by the total count of patients with abnormal PT, then multiplying by 100.\n5. The query will join the `Patient` and `Laboratory` tables to access both the patient's age and PT values.",
    "sql": "SELECT \n    (SUM(CASE WHEN P.SEX = 'F' AND L.PT >= 14 THEN 1 ELSE 0 END) * 100.0 / \n    SUM(CASE WHEN L.PT >= 14 THEN 1 ELSE 0 END)) AS percentage_female_abnormal_PT\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 55;",
    "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
    "evidence": [
      "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; "
    ]
  },
  "1038": {
    "reason": "To solve the question, we need to determine the top 5 leagues based on the total number of goals scored in all seasons combined. The steps are as follows:\n1. **Identify the relevant tables**: The `Match` table contains the goals scored by home and away teams, and the `League` table contains the league names.\n2. **Calculate total goals per league**: For each match, sum the `home_team_goal` and `away_team_goal` to get the total goals for that match. Then, group these totals by the `league_id`.\n3. **Join with the `League` table**: To get the league names, join the results with the `League` table.\n4. **Order the results**: Sort the leagues in ascending order of total goals.\n5. **Limit the results**: Return only the top 5 leagues.",
    "sql": "SELECT l.name AS league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM Match m\nJOIN League l ON m.league_id = l.id\nGROUP BY m.league_id\nORDER BY total_goals ASC\nLIMIT 5;",
    "question": "List the top 5 leagues in ascending order of the number of goals made in all seasons combined.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT t1.name, SUM(t2.home_team_goal) + SUM(t2.away_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id GROUP BY t1.name ORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC LIMIT 5",
    "evidence": [
      "number of goals made in all seasons combine = SUM(home_team_goal, away_team_goal);"
    ]
  },
  "113": {
    "reason": "To find the birthday of the client who applied for a loan of 98832 USD on 1996/1/3, we need to follow these steps:\n1. Identify the loan record with the specified amount and date in the `loan` table.\n2. Use the `account_id` from the loan record to find the corresponding account in the `account` table.\n3. From the `account` table, use the `account_id` to find the associated client in the `disp` table (since `disp` links accounts to clients).\n4. From the `disp` table, use the `client_id` to find the client's details in the `client` table.\n5. Retrieve the `birth_date` from the `client` table for the identified client.",
    "sql": "SELECT c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.amount = 98832 AND l.date = '1996-01-03';",
    "question": "For the client who applied 98832 USD loan in 1996/1/3, when was his/her birthday?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T4.birth_date FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T1.date = '1996-01-03' AND T1.amount = 98832",
    "evidence": [
      ""
    ]
  },
  "15": {
    "reason": "To solve the question, we need to find the active district with the highest average score in Reading. Here's the step-by-step reasoning:\n\n1. **Identify Active Districts**: We need to filter districts where the schools are active. This can be done by checking the `StatusType` column in the `schools` table.\n2. **Join Tables**: We need to join the `schools` table with the `satscores` table to get the average reading scores for each district. The join can be done using the `CDSCode` column.\n3. **Filter Relevant Data**: We need to ensure we are only considering districts (not individual schools) by filtering the `rtype` column in the `satscores` table to 'D' (for district).\n4. **Calculate Average Reading Score**: For each district, we need to calculate the average reading score (`AvgScrRead`).\n5. **Find the Highest Average**: Finally, we need to order the results by the average reading score in descending order and limit the result to the top district.\n\nPutting it all together, the query will join the tables, filter for active districts, and return the district with the highest average reading score.",
    "sql": "SELECT s.District, AVG(sc.AvgScrRead) AS AvgReadingScore\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.StatusType = 'Active' AND sc.rtype = 'D'\nGROUP BY s.District\nORDER BY AvgReadingScore DESC\nLIMIT 1;",
    "question": "Which active district has the highest average score in Reading?",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1",
    "evidence": [
      ""
    ]
  },
  "1476": {
    "reason": "To solve the question, we need to calculate the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: \n   - `customers` table contains customer information, including the currency they use (CZK or EUR).\n   - `yearmonth` table contains consumption data for customers by date.\n   - `transactions_1k` table links customers to gas stations and products, but we don't need it directly for this question.\n\n2. **Filter data for 2012**: \n   - The `yearmonth` table has a `Date` column, which we can filter to include only dates from 2012.\n\n3. **Group consumption by currency**: \n   - Join the `customers` table with the `yearmonth` table on `CustomerID`.\n   - Filter customers by currency (CZK or EUR).\n   - Sum the `Consumption` for each currency group.\n\n4. **Calculate the difference**: \n   - Subtract the total consumption of EUR-paying customers from the total consumption of CZK-paying customers.\n\n5. **Output the result**: \n   - The final query will return the difference in consumption between the two currency groups.",
    "sql": "SELECT \n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'CZK' AND ym.Date LIKE '2012%') -\n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'EUR' AND ym.Date LIKE '2012%') AS ConsumptionDifference;",
    "question": "What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?",
    "db_id": "debit_card_specializing",
    "res": 1,
    "ground_truth": "SELECT SUM(IIF(T1.Currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.Currency = 'EUR', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2012'",
    "evidence": [
      "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year; Difference in Consumption = CZK customers consumption in 2012 - EUR customers consumption in 2012"
    ]
  },
  "1042": {
    "reason": "To solve the question, we need to:\n1. Identify the leagues where the average goals scored by the home team are higher than the average goals scored by the away team during the 2009/2010 season.\n2. Calculate the average goals for home and away teams for each league in the specified season.\n3. Filter the leagues where the home team's average goals are greater than the away team's.\n4. Join the `Match` table with the `League` table to get the league names.\n5. Group the results by league and apply the necessary filtering conditions.",
    "sql": "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2009/2010'\nGROUP BY l.name\nHAVING AVG(m.home_team_goal) > AVG(m.away_team_goal);",
    "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0",
    "evidence": [
      "name of league refers to League.name; average goals by the home team is higher than the away team = AVG(home_team_goal) > AVG(away_team_goal); AVG(xx_goal) = SUM(xx_goal) / COUNT(DISTINCT Match.id); 2009/2010 season refers to season = '2009/2010'"
    ]
  },
  "374": {
    "reason": "To solve the question, we need to find the count of black border cards that are only available on MTGO. The schema provides a table `cards` with columns `borderColor` and `availability`. The tip specifies that black border cards refer to `borderColor = 'black'` and available on MTGO refers to `availability = 'mtgo'`. Therefore, the query should count the rows in the `cards` table where `borderColor` is 'black' and `availability` is 'mtgo'.",
    "sql": "SELECT COUNT(*) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo';",
    "question": "How many black border cards are only available on mtgo?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT COUNT(id) FROM cards WHERE availability = 'mtgo' AND borderColor = 'black'",
    "evidence": [
      "black border card refers to borderColor = black; available on mtgo refers to availability = mtgo;\n\nadd quotes for string = 'black' and = 'mtgo'"
    ]
  },
  "93": {
    "reason": "To solve the question, we need to find the number of male customers living in North Bohemia with an average salary greater than 8000. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables and columns**:\n   - The `client` table contains information about customers, including their gender (`gender`) and district (`district_id`).\n   - The `district` table contains details about districts, including the region (`A3`) and average salary (`A11`).\n\n2. **Filter conditions**:\n   - Gender should be 'M' (male).\n   - Region (`A3`) should be 'North Bohemia'.\n   - Average salary (`A11`) should be greater than 8000.\n\n3. **Join the tables**:\n   - Join the `client` table with the `district` table on `district_id` to access the region and average salary information.\n\n4. **Count the results**:\n   - Count the number of male customers meeting the criteria.\n\n5. **Final query**:\n   - The query will join the `client` and `district` tables, apply the filters, and count the results.",
    "sql": "SELECT COUNT(*) AS male_customers_north_bohemia_high_salary\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.gender = 'M' AND d.A3 = 'North Bohemia' AND d.A11 > 8000;",
    "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
    "db_id": "financial",
    "res": 0,
    "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
    "evidence": [
      "Male means that gender = 'M'; A3 refers to region; A11 pertains to average salary."
    ]
  },
  "776": {
    "reason": "To find the hero name and race of Charles Chandler, we need to query the `superhero` table for the record where `full_name` is 'Charles Chandler'. The `superhero` table contains the `superhero_name` and `race_id` fields. To get the actual race name, we need to join the `superhero` table with the `race` table using the `race_id` field. The query will select the `superhero_name` from the `superhero` table and the `race` from the `race` table where the `full_name` matches 'Charles Chandler'.",
    "sql": "SELECT s.superhero_name, r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.full_name = 'Charles Chandler';",
    "question": "Provide the hero name and race of Charles Chandler.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT T1.superhero_name, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.full_name = 'Charles Chandler'",
    "evidence": [
      "hero name refers to superhero_name; Charles Chandler is the full name of superhero;"
    ]
  },
  "402": {
    "reason": "To solve the question, we need to calculate the percentage of Story Spotlight cards that do not have a text box. The tips provided clarify that these cards are identified by `isStorySpotlight = 1` and `isTextless = 0`. The steps to solve this are:\n1. Count the total number of cards in the `cards` table.\n2. Count the number of cards that meet the criteria (`isStorySpotlight = 1` AND `isTextless = 0`).\n3. Calculate the percentage by dividing the count from step 2 by the total count from step 1 and multiplying by 100.\n4. List the IDs of the cards that meet the criteria.",
    "sql": "WITH total_cards AS (\n    SELECT COUNT(*) AS total FROM cards\n),\nstory_spotlight_cards AS (\n    SELECT COUNT(*) AS spotlight_count, GROUP_CONCAT(id) AS spotlight_ids \n    FROM cards \n    WHERE isStorySpotlight = 1 AND isTextless = 0\n)\nSELECT \n    (spotlight_count * 100.0 / total) AS percentage,\n    spotlight_ids AS story_spotlight_card_ids\nFROM total_cards, story_spotlight_cards;",
    "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
    "evidence": [
      "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 0; Percentage = DIVIDE(SUM(count(id) where isStorylight = 1 AND isTextless = 0 ), SUM(count(id))) * 100"
    ]
  },
  "1259": {
    "reason": "To solve the question, we need to find the diseases of patients who meet two conditions: 1) born after 1985-1-1, and 2) have a normal Rheumatoid Factor (RA IN('-', '+-')). The steps are as follows:\n1. Identify patients born after 1985-1-1 by filtering the `Patient` table where `Birthday` is greater than or equal to '1985-01-01'.\n2. Join the `Patient` table with the `Laboratory` table to check for patients with a normal Rheumatoid Factor (RA IN('-', '+-')).\n3. Retrieve the `Diagnosis` field from the `Patient` table for these patients.\n4. Ensure the query is valid SQLite syntax and uses the provided tips.",
    "sql": "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Birthday >= '1985-01-01'\nAND l.RA IN('-', '+-');",
    "question": "Please list the diseases of the patients born after 1985-1-1 and have a normal Rhuematoid Factor.",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > '1985-01-01'",
    "evidence": [
      "diseases refers to Diagnosis; born after 1985/1/1 refers to YEAR(Birthday) > = 1985; normal Rhuematoid Factor refers to RA IN('-', '+-');"
    ]
  },
  "1133": {
    "reason": "To solve the question, we need to find the number of football players born after the 1990s with the first name \"Aaron\". The relevant table for this query is the `Player` table, which contains the `player_name` and `birthday` columns. We will filter the `player_name` to start with \"Aaron\" using the `LIKE` operator and the `birthday` to be after the year 1990. Finally, we will count the number of such players.",
    "sql": "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Aaron%' AND birthday > '1990-12-31';",
    "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
    "evidence": [
      "first name \"Aaron\" refers to player_name LIKE 'Aaron%'; born after the 1990s refers to birthday > '1990'"
    ]
  },
  "5": {
    "reason": "To solve the question, we need to find the number of schools that are exclusively virtual (Virtual = 'F') and have an average SAT Math score greater than 400. The steps are as follows:\n1. Join the `satscores` table with the `schools` table using the `cds` (in `satscores`) and `CDSCode` (in `schools`) fields to get the virtual status of the schools.\n2. Filter the results to include only schools where the `Virtual` field is 'F' (exclusively virtual) and the `AvgScrMath` field is greater than 400.\n3. Count the number of such schools.",
    "sql": "SELECT COUNT(*) \nFROM satscores \nJOIN schools ON satscores.cds = schools.CDSCode \nWHERE schools.Virtual = 'F' AND satscores.AvgScrMath > 400;",
    "question": "How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?",
    "db_id": "california_schools",
    "res": 1,
    "ground_truth": "SELECT COUNT(DISTINCT T2.School) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' AND T1.AvgScrMath > 400",
    "evidence": [
      "Exclusively virtual refers to Virtual = 'F'"
    ]
  },
  "673": {
    "reason": "To solve the question, we need to find the average number of posts voted by the oldest users. This involves two main steps:\n\n1. **Identify the oldest users**: We need to find users with the maximum age from the `users` table.\n2. **Calculate the average number of posts voted by these users**: For each of these oldest users, we need to count the number of posts they voted on (using the `votes` table) and then calculate the average of these counts.\n\nWe will first find the maximum age in the `users` table, then filter users who have this age. Next, we will join these users with the `votes` table to count the number of posts each of them voted on. Finally, we will compute the average of these counts.",
    "sql": "WITH OldestUsers AS (\n    SELECT Id\n    FROM users\n    WHERE Age = (SELECT MAX(Age) FROM users)\n)\nSELECT AVG(PostCount) AS AveragePostsVoted\nFROM (\n    SELECT COUNT(v.PostId) AS PostCount\n    FROM OldestUsers ou\n    LEFT JOIN votes v ON ou.Id = v.UserId\n    GROUP BY ou.Id\n);",
    "question": "What is the average number of posts voted by the oldest users?",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT AVG(PostId) FROM votes WHERE UserId IN ( SELECT Id FROM users WHERE Age = ( SELECT MAX(Age) FROM users ) )",
    "evidence": [
      "average number of posts voted refers to AVG(PostId) FROM votes; the oldest users refer to MAX(Age);"
    ]
  },
  "1240": {
    "reason": "To solve the question, we need to find the average hematocrit level (HCT) from laboratory examinations in 1991 where the HCT is lower than the normal range (HCT < 29). The steps are as follows:\n1. Filter the laboratory examinations to include only those from 1991 by checking if the Date column starts with '1991'.\n2. Further filter these records to include only those where HCT is less than 29.\n3. Calculate the average of the HCT values from the filtered records.",
    "sql": "SELECT AVG(HCT) AS average_hematocrit_below_normal \nFROM Laboratory \nWHERE Date LIKE '1991%' AND HCT < 29;",
    "question": "From laboratory examinations in 1991, what is the average hematoclit level that is lower than the normal range.",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT AVG(T2.HCT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HCT < 29 AND STRFTIME('%Y', T2.Date) = '1991'",
    "evidence": [
      "laboratory examinations in 1991 refers to Date like '1991%'; average hematoclit level = AVG(HCT); hematoclit level that is lower than the normal range refers to HCT < 29;"
    ]
  },
  "1399": {
    "reason": "To determine if Maya Mclean attended the 'Women's Soccer' event, we need to follow these steps:\n1. Identify Maya Mclean's member_id from the member table using her first name 'Maya' and last name 'Mclean'.\n2. Identify the event_id of the 'Women's Soccer' event from the event table.\n3. Check the attendance table for a record where link_to_event matches the event_id of 'Women's Soccer' and link_to_member matches Maya Mclean's member_id.\n4. If such a record exists, Maya attended the event; otherwise, she did not.",
    "sql": "SELECT CASE WHEN EXISTS (\n    SELECT 1\n    FROM attendance a\n    JOIN member m ON a.link_to_member = m.member_id\n    JOIN event e ON a.link_to_event = e.event_id\n    WHERE m.first_name = 'Maya' AND m.last_name = 'Mclean'\n    AND e.event_name = 'Women''s Soccer'\n) THEN 'Yes' ELSE 'No' END AS did_attend;",
    "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
    "evidence": [
      "Maya Mclean is the full name; full name refers to first_name, last_name; 'Women's Soccer' is an event_name"
    ]
  },
  "330": {
    "reason": "To calculate the percentage of carcinogenic molecules with triple bonded Hydrogen atoms, we need to follow these steps:\n1. Identify all molecules that have Hydrogen atoms (element = 'h').\n2. Identify all bonds that are triple bonds (bond_type = '#').\n3. Find molecules where Hydrogen atoms are connected via triple bonds.\n4. Among these molecules, count how many are carcinogenic (label = '+').\n5. Calculate the percentage by dividing the count of carcinogenic molecules by the total count of molecules with triple bonded Hydrogen atoms, then multiplying by 100.0.\n\nThe query will involve joining the `atom`, `bond`, `connected`, and `molecule` tables to filter and aggregate the required data.",
    "sql": "SELECT (SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM molecule m\nJOIN atom a1 ON m.molecule_id = a1.molecule_id\nJOIN connected c ON a1.atom_id = c.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a1.element = 'h' AND b.bond_type = '#';",
    "question": "Calculate the percentage of carcinogenic molecules with triple bonded Hidrogen atoms.",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T2.element = 'h'",
    "evidence": [
      "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) * 100.0 where element = 'h' AND bond_type = '#';"
    ]
  },
  "361": {
    "reason": "To solve the question, we need to find the number of cards that meet two conditions: 1) their legal status is 'restricted', and 2) they have text boxes (i.e., they are not textless, which means `isTextless = 0`).\n\n1. **Identify the tables involved**: The `cards` table contains the `isTextless` column, and the `legalities` table contains the `status` column.\n2. **Join the tables**: We need to join the `cards` table with the `legalities` table on the `uuid` column to match cards with their legal statuses.\n3. **Filter the data**: We will filter the joined data to include only cards where `status = 'restricted'` and `isTextless = 0`.\n4. **Count the results**: Finally, we will count the number of cards that meet these criteria.\n\nThe SQL query will involve a join between the `cards` and `legalities` tables, followed by filtering and counting.",
    "sql": "SELECT COUNT(*) \nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.status = 'restricted' AND c.isTextless = 0;",
    "question": "How many cards of legalities whose status is restricted have text boxes?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isTextless = 0",
    "evidence": [
      "restricted refers to status = 'restricted'; have text boxes refers to is Textless = 0;"
    ]
  },
  "411": {
    "reason": "To find the artist of the card with the specific text \"Das perfekte perfekte Gegenmittel zu einer dichten Formation\", we need to follow these steps:\n1. Identify the card in the `cards` table that has the given text in its `text` column.\n2. Once the card is identified, retrieve the `artist` associated with that card.\n\nThe query will involve searching the `cards` table for the matching text and then selecting the `artist` field from the matching record.",
    "sql": "SELECT artist FROM cards WHERE text = 'Das perfekte Gegenmittel zu einer dichten Formation';",
    "question": "To which artist does the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\" belong?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
    "evidence": [
      ""
    ]
  },
  "71": {
    "reason": "To find the district code for the school that does not offer a magnet program in the city of Fresno, we need to follow these steps:\n1. Identify the school(s) in the city of Fresno from the `schools` table.\n2. Filter these schools to exclude those that offer a magnet program (i.e., where `Magnet` is not equal to 1).\n3. Join the filtered schools with the `frpm` table to retrieve the district code for the identified school(s).\n4. Ensure the query returns the `District Code` from the `frpm` table.",
    "sql": "SELECT f.`District Code`\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.City = 'Fresno' AND s.Magnet != 1;",
    "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
    "db_id": "california_schools",
    "res": 1,
    "ground_truth": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
    "evidence": [
      "When magent is equal to 0 in the database, it means ths school doesn't offer a magnet program."
    ]
  },
  "1360": {
    "reason": "To solve the question, we need to determine the percentage of the budget allocated for 'Parking' compared to the total budget for the event named 'November Speaker'. Here's the step-by-step reasoning:\n\n1. **Identify the event**: First, we need to find the `event_id` for the event named 'November Speaker' from the `event` table.\n2. **Retrieve the budget for 'Parking'**: Using the `event_id`, we will query the `budget` table to get the `amount` allocated for the category 'Parking'.\n3. **Retrieve the total budget for the event**: Using the same `event_id`, we will sum all the `amount` values in the `budget` table for the event.\n4. **Calculate the percentage**: Finally, we will calculate the percentage of the 'Parking' budget relative to the total budget for the event.\n\nThe SQL query will join the `event` and `budget` tables to achieve this.",
    "sql": "SELECT \n    (b1.amount * 100.0 / SUM(b2.amount)) AS percentage\nFROM \n    event e\nJOIN \n    budget b1 ON e.event_id = b1.link_to_event\nJOIN \n    budget b2 ON e.event_id = b2.link_to_event\nWHERE \n    e.event_name = 'November Speaker' AND b1.category = 'Parking'\nGROUP BY \n    b1.amount;",
    "question": "What percentage was the budget for Parking to the total budget for the \"November Speaker\"?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Speaker'",
    "evidence": [
      "DIVDE(SUM( amount where category = 'Parking' and event_name = 'November Speaker'), COUNT(event_name = 'November Speaker)) * 100"
    ]
  },
  "1079": {
    "reason": "To find the tallest player, we need to query the `Player` table and retrieve the player with the maximum height. The `height` column in the `Player` table stores the height of each player. We can use the `MAX` function to find the tallest player. The query will select the `player_name` and `height` from the `Player` table where the `height` is equal to the maximum height in the table.",
    "sql": "SELECT player_name, height FROM Player WHERE height = (SELECT MAX(height) FROM Player);",
    "question": "Which player is the tallest?",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
    "evidence": [
      "tallest player refers to MAX(height);"
    ]
  },
  "1100": {
    "reason": "To find the highest overall rating received by Dorlan Pabon, we need to:\n1. Identify the player_api_id of Dorlan Pabon from the Player table.\n2. Use this player_api_id to query the Player_Attributes table for all records related to Dorlan Pabon.\n3. From these records, find the maximum value of the overall_rating attribute.\n\nThe query will involve joining the Player and Player_Attributes tables to ensure we are looking at the correct player.",
    "sql": "SELECT MAX(pa.overall_rating) AS highest_overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Dorlan Pabon';",
    "question": "What is the highest overall rating received by Dorlan Pabon?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT MAX(t2.overall_rating) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Dorlan Pabon'",
    "evidence": [
      "Dorlan Pabon refers to T2.player_name = 'Dorlan Pabon'; highest overall rating refers to MAX(overall_rating)"
    ]
  },
  "47": {
    "reason": "To solve the question, we need to find the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980. The steps are as follows:\n1. Identify schools in Alameda County (County = 'Alameda').\n2. Filter schools that are under the Elementary School District (DOC = '52').\n3. Filter schools that opened in 1980 (OpenDate between '1980-01-01' and '1980-12-31').\n4. Count the number of such schools.\n5. Divide the count by 12 to get the monthly average.",
    "sql": "SELECT COUNT(*) / 12.0 AS monthly_average\nFROM schools\nWHERE County = 'Alameda'\n  AND DOC = '52'\n  AND strftime('%Y', OpenDate) = '1980';",
    "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
    "db_id": "california_schools",
    "res": 1,
    "ground_truth": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
    "evidence": [
      "Elementary School District refers to DOC = 52; Monthly average number of schools that opened in 1980 = count(schools that opened in 1980) / 12"
    ]
  },
  "96": {
    "reason": "To solve the question, we need to find the number of customers who have chosen a weekly issuance (frequency = 'POPLATEK TYDNE') and are also Owners (type = 'OWNER') in the disp table. Here's the step-by-step reasoning:\n\n1. Identify the relevant tables: \n   - `account` (to filter accounts with weekly issuance).\n   - `disp` (to filter owners).\n   - `client` (to count unique customers).\n\n2. Join these tables:\n   - Join `account` with `disp` on `account_id`.\n   - Join `disp` with `client` on `client_id`.\n\n3. Apply the filters:\n   - `account.frequency = 'POPLATEK TYDNE'` (weekly issuance).\n   - `disp.type = 'OWNER'` (owner type).\n\n4. Count the distinct `client_id` to get the number of unique customers.",
    "sql": "SELECT COUNT(DISTINCT c.client_id) AS customer_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'OWNER';",
    "question": "How many customers who choose statement of weekly issuance are Owner?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK TYDNE'",
    "evidence": [
      "'POPLATEK TYDNE' stands for weekly issuance"
    ]
  },
  "166": {
    "reason": "To solve the question, we need to find the number of accounts from the Jesenik district. The steps are as follows:\n1. Identify the district_id for Jesenik from the district table, where the district name is stored in column A2.\n2. Use this district_id to filter accounts in the account table.\n3. Count the number of accounts that match this district_id.",
    "sql": "SELECT COUNT(*) \nFROM account \nWHERE district_id = (SELECT district_id FROM district WHERE A2 = 'Jesenik');",
    "question": "How many of the accounts are from Jesenik district?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A2 = 'Jesenik'",
    "evidence": [
      ""
    ]
  },
  "1147": {
    "reason": "To find the player with the greatest overall strength, we need to identify the player with the highest `overall_rating` in the `Player_Attributes` table. This involves:\n1. Selecting the `player_api_id` and `overall_rating` from the `Player_Attributes` table.\n2. Ordering the results by `overall_rating` in descending order to get the highest rating first.\n3. Limiting the result to 1 to get only the top player.\n4. Joining with the `Player` table to get the player's name.",
    "sql": "SELECT p.player_name, pa.overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;",
    "question": "Please name one player whose overall strength is the greatest.",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = ( SELECT MAX(overall_rating) FROM Player_Attributes)",
    "evidence": [
      "overall strength is the greatest refers to MAX(overall_rating)"
    ]
  },
  "146": {
    "reason": "To solve the question, we need to identify female account holders who own credit cards and also have loans. Here's the step-by-step reasoning:\n\n1. **Identify female clients**: We start by filtering clients where `gender = 'F'`.\n2. **Link clients to their accounts**: Using the `disp` table, we connect clients to their accounts. The `disp` table has `client_id` and `account_id`.\n3. **Check for credit card ownership**: The `card` table contains information about credit cards. We need to ensure the client has a card of type 'credit'.\n4. **Check for loans**: The `loan` table contains information about loans. We need to ensure the client's account has an associated loan.\n5. **Combine these conditions**: We join the `client`, `disp`, `account`, `card`, and `loan` tables to ensure all conditions are met.\n6. **Select the required details**: We will select the client's ID and any other relevant details to identify them.",
    "sql": "SELECT DISTINCT c.client_id, c.gender, c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN card cd ON d.disp_id = cd.disp_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.gender = 'F' AND cd.type = 'credit';",
    "question": "Who are the female account holders who own credit cards and also have loans?",
    "db_id": "financial",
    "res": 0,
    "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T5 ON T2.account_id = T5.account_id INNER JOIN loan AS T3 ON T5.account_id = T3.account_id INNER JOIN card AS T4 ON T2.disp_id = T4.disp_id WHERE T1.gender = 'F'",
    "evidence": [
      "Female refers to gender = 'F'"
    ]
  },
  "320": {
    "reason": "To find the type of the bond connecting two atoms (TR000_1 and TR000_2), we need to follow these steps:\n1. Identify the bond_id in the `connected` table that links the two atoms (TR000_1 and TR000_2).\n2. Use the bond_id to query the `bond` table to retrieve the bond_type.\n\nThe query will join the `connected` table with the `bond` table to get the bond_type for the specified atoms.",
    "sql": "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR000_1' AND c.atom_id2 = 'TR000_2') OR (c.atom_id = 'TR000_2' AND c.atom_id2 = 'TR000_1');",
    "question": "What is the type of the bond which is presenting the connection between two atoms TR000_1 and TR000_2?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'",
    "evidence": [
      "type of bond refers to bond_type; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
    ]
  },
  "578": {
    "reason": "To solve the question, we need to find the user who made a post with the title 'Understanding what Dassault iSight is doing?' and then retrieve their reputation. This involves two main steps:\n1. Identify the post with the given title in the `posts` table and retrieve the `OwnerUserId` (the user who made the post).\n2. Use the `OwnerUserId` to find the corresponding user in the `users` table and retrieve their `Reputation`.",
    "sql": "SELECT u.DisplayName, u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Understanding what Dassault iSight is doing?';",
    "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
    "evidence": [
      "\"Understanding what Dassault iSight is doing?\" is the Title of post; user refers to DisplayName;"
    ]
  },
  "881": {
    "reason": "To solve the question, we need to determine the race completion rate for drivers who participated in the race on 1983-07-16. The steps are as follows:\n1. Identify the race(s) that occurred on 1983-07-16 by querying the `races` table.\n2. For each identified race, retrieve the list of drivers who participated by querying the `results` table.\n3. For each driver, determine their completion status by checking the `status` field in the `results` table. A completed race typically has a status indicating completion (e.g., \"Finished\").\n4. Calculate the completion rate by dividing the number of drivers who completed the race by the total number of drivers who participated.\n5. Return the completion rate as a percentage.\n\nThe query will involve joining the `races`, `results`, and `status` tables to gather the necessary information.",
    "sql": "WITH race_on_date AS (\n    SELECT raceId FROM races WHERE date = '1983-07-16'\n),\ndriver_participation AS (\n    SELECT r.driverId, s.status\n    FROM results r\n    JOIN race_on_date rod ON r.raceId = rod.raceId\n    JOIN status s ON r.statusId = s.statusId\n),\ncompletion_stats AS (\n    SELECT \n        COUNT(*) AS total_drivers,\n        SUM(CASE WHEN status = 'Finished' THEN 1 ELSE 0 END) AS completed_drivers\n    FROM driver_participation\n)\nSELECT \n    (completed_drivers * 100.0 / total_drivers) AS completion_rate_percentage\nFROM completion_stats;",
    "question": "For the drivers who took part in the race in 1983/7/16, what's their race completion rate?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'",
    "evidence": [
      "DIVIDE(COUNT(driverid when time has value ), (COUNT(driverid )) as percentage; in 1983/7/16 refers to when date = '1983-07-16'"
    ]
  },
  "1379": {
    "reason": "To determine how many meeting events were held in 2020, we need to query the `event` table. The question specifies that meeting events are identified by the `type` column being 'Meeting' and the events held in 2020 are identified by the year in the `event_date` column. We will use the `COUNT` function to count the number of such events. The `WHERE` clause will filter events where `type` is 'Meeting' and the `event_date` contains '2020' (assuming the date is stored in a format like 'YYYY-MM-DD').",
    "sql": "SELECT COUNT(*) FROM event WHERE type = 'Meeting' AND event_date LIKE '%2020%';",
    "question": "How many meeting events were held in 2020?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT COUNT(event_id) FROM event WHERE type = 'Meeting' AND SUBSTR(event_date, 1, 4) = '2020'",
    "evidence": [
      "meeting events refers to type = 'Meeting'; held in 2020 refers to YEAR(event_date) = 2020"
    ]
  },
  "822": {
    "reason": "To solve the question, we need to find the number of green-skinned villains in the superhero universe. The steps are as follows:\n1. Identify villains by checking the `alignment` table where `alignment` is 'Bad'.\n2. Identify green-skinned superheroes by checking the `colour` table where `colour` is 'Green' and linking it to the `skin_colour_id` in the `superhero` table.\n3. Join the `superhero` table with the `alignment` and `colour` tables to filter for green-skinned villains.\n4. Count the number of such superheroes.",
    "sql": "SELECT COUNT(*) AS green_skinned_villains\nFROM superhero\nJOIN alignment ON superhero.alignment_id = alignment.id\nJOIN colour ON superhero.skin_colour_id = colour.id\nWHERE alignment.alignment = 'Bad' AND colour.colour = 'Green';",
    "question": "How many green-skinned villains are there in the superhero universe?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
    "evidence": [
      "green-skinned refers to colour.colour = 'Green' WHERE skin_colour_id = colour.id; villains refers to alignment = 'Bad';"
    ]
  },
  "253": {
    "reason": "To list the elements of all the triple bonds, we need to follow these steps:\n1. Identify all bonds with `bond_type = '#'` (triple bonds) from the `bond` table.\n2. For each triple bond, find the connected atoms using the `connected` table.\n3. Retrieve the elements of these connected atoms from the `atom` table.\n4. Combine the results to display the elements involved in each triple bond.\n\nThe query will join the `bond`, `connected`, and `atom` tables to achieve this.",
    "sql": "SELECT a1.element AS element1, a2.element AS element2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = '#';",
    "question": "List the elements of all the triple bonds.",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T3.element FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T1.bond_type = '#'",
    "evidence": [
      "triple bond refers to bond_type = '#';"
    ]
  },
  "1101": {
    "reason": "To solve the question, we need to find the average number of goals made by Parma as the away team while playing in Italy. Here's the step-by-step reasoning:\n\n1. **Identify Parma's team ID**: We need to find the `team_api_id` for Parma from the `Team` table.\n2. **Filter matches in Italy**: We need to identify matches where the league is in Italy. This involves joining the `Match` table with the `League` and `Country` tables to filter matches by country name (Italy).\n3. **Filter matches where Parma is the away team**: Using the `team_api_id` from step 1, filter matches where Parma is the away team (`away_team_api_id`).\n4. **Calculate the average goals**: For these filtered matches, calculate the average of `away_team_goal` (since Parma is the away team).\n\nCombining these steps, we will join the necessary tables and apply the filters to get the desired result.",
    "sql": "SELECT AVG(m.away_team_goal) AS average_goals\nFROM Match m\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nJOIN League l ON m.league_id = l.id\nJOIN Country c ON l.country_id = c.id\nWHERE t.team_long_name = 'Parma' AND c.name = 'Italy';",
    "question": "What is the average number of goals made by Parma as the away team while playing in Italy?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) FROM \"Match\" AS T1 INNER JOIN TEAM AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN Country AS T3 ON T1.country_id = T3.id WHERE T2.team_long_name = 'Parma' AND T3.name = 'Italy'",
    "evidence": [
      "Parma refers to team_long_name = 'Parma'; average number of goals refers to AVG(away_team_goal)"
    ]
  },
  "176": {
    "reason": "To solve the question, we need to determine the amount of debt that client number 992 has and assess their payment status. Here's the step-by-step reasoning:\n\n1. **Identify the client's account(s):** Client number 992 is associated with one or more accounts through the `disp` table, where `client_id` is linked to `account_id`.\n2. **Find the loan(s) associated with the account(s):** Using the `account_id` from the `disp` table, we can query the `loan` table to find the loan amount and payment status.\n3. **Retrieve the loan details:** The `loan` table contains the `amount` (debt) and `status` (payment status) for each loan.\n4. **Filter for client 992:** We need to ensure the query is specific to client 992 by joining the `client`, `disp`, `account`, and `loan` tables.\n\nFinal SQL query will join these tables and filter for client 992 to retrieve the loan amount and payment status.",
    "sql": "SELECT l.amount AS debt_amount, l.status AS payment_status\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.client_id = 992;",
    "question": "What is the amount of debt that client number 992 has, and how is this client doing with payments?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T4.amount, T4.status FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 on T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 992",
    "evidence": [
      ""
    ]
  },
  "636": {
    "reason": "To solve the question, we need to find the number of negative comments (score < 60) that Neil McGuigan received on his posts. The steps are as follows:\n1. Identify Neil McGuigan's user ID from the `users` table using his display name ('Neil McGuigan').\n2. Find all posts where Neil McGuigan is the owner (using the `OwnerUserId` from the `posts` table).\n3. For each of these posts, count the number of comments with a score less than 60 in the `comments` table.\n4. Sum these counts to get the total number of negative comments on Neil McGuigan's posts.",
    "sql": "SELECT COUNT(*) AS NegativeCommentCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'Neil McGuigan' AND c.Score < 60;",
    "question": "How many negative comments did Neil McGuigan get in his posts?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(T3.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T1.DisplayName = 'Neil McGuigan' AND T3.Score < 60",
    "evidence": [
      "Negative comment refers to score < 60; DisplayName = 'Neil McGuigan';"
    ]
  },
  "1096": {
    "reason": "To calculate the average overall rating of Pietro Marino, we need to follow these steps:\n1. Identify Pietro Marino's player_api_id from the Player table using his name.\n2. Use this player_api_id to find all his entries in the Player_Attributes table.\n3. Calculate the average of the overall_rating column for these entries.",
    "sql": "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Pietro Marino');",
    "question": "Calculate the average overall rating of Pietro Marino.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Pietro Marino'",
    "evidence": [
      "Pietro Marino refers to player_name = 'Pietro Marino'; average overall rating AVG(T1.overall_rating)"
    ]
  },
  "263": {
    "reason": "To solve the question, we need to find the percentage of chlorine atoms (`element = 'cl'`) among all atoms in molecules that have single bonds (`bond_type = '-'`). The steps are as follows:\n1. Identify all molecules that have single bonds by querying the `bond` table where `bond_type = '-'`.\n2. For these molecules, count the total number of atoms and the number of chlorine atoms by joining the `atom` table with the filtered molecules.\n3. Calculate the percentage of chlorine atoms by dividing the count of chlorine atoms by the total count of atoms and multiplying by 100.\n4. Ensure the result is presented as a percentage.",
    "sql": "SELECT \n    (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS chlorine_percentage\nFROM \n    atom a\nJOIN \n    molecule m ON a.molecule_id = m.molecule_id\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nWHERE \n    b.bond_type = '-';",
    "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
    "evidence": [
      "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'"
    ]
  },
  "1036": {
    "reason": "To solve the question, we need to identify teams with above-average build-up play passing in 2012. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `Team_Attributes` table contains the `buildUpPlayPassing` attribute, and the `Team` table contains the `team_long_name`.\n2. **Filter for the year 2012**: The `date` column in `Team_Attributes` will be used to filter records from 2012.\n3. **Calculate the average build-up play passing**: We need to compute the average `buildUpPlayPassing` value for all teams in 2012.\n4. **Filter teams with above-average build-up play passing**: Compare each team's `buildUpPlayPassing` value to the calculated average.\n5. **Join the `Team` table to get the team's long name**: The `team_api_id` or `team_fifa_api_id` can be used to join the `Team` table.\n\nFinally, we will select the `team_long_name` from the `Team` table for teams that meet the criteria.",
    "sql": "SELECT t.team_long_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE strftime('%Y', ta.date) = '2012'\nAND ta.buildUpPlayPassing > (\n    SELECT AVG(buildUpPlayPassing)\n    FROM Team_Attributes\n    WHERE strftime('%Y', date) = '2012'\n);",
    "question": "List the long name of teams with above-average build-up play passing in 2012.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT DISTINCT t4.team_long_name FROM Team_Attributes AS t3 INNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTR(t3.`date`, 1, 4) = '2012' AND t3.buildUpPlayPassing > ( SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE STRFTIME('%Y',t2.`date`) = '2012')",
    "evidence": [
      "long name of teams refers to team_long_name; build-up play passing refers to buildUpPlayPassing; above-average build-up play passing = buildUpPlayPassing > DIVIDE(SUM(buildUpPlayPassing), COUNT(team_long_name) WHERE buildUpPlayPassing IS NOT NULL); in 2012 refers to strftime('%Y', date) = '2012'; "
    ]
  },
  "484": {
    "reason": "To solve the question, we need to find the Italian names of the cards in the set 'Coldsnap' with the highest converted mana cost. Here's the step-by-step reasoning:\n\n1. **Identify the set 'Coldsnap'**: We need to find the set code for 'Coldsnap' from the `sets` table.\n2. **Find cards in 'Coldsnap'**: Using the set code, we can find all cards in the `cards` table that belong to this set.\n3. **Determine the highest converted mana cost**: Among these cards, we need to find the maximum value of `convertedManaCost`.\n4. **Filter cards with the highest converted mana cost**: From the cards in 'Coldsnap', filter those with the highest `convertedManaCost`.\n5. **Retrieve Italian names**: For these filtered cards, retrieve their Italian names from the `foreign_data` table where the language is 'Italian'.\n\nCombining these steps, we will join the `cards`, `sets`, and `foreign_data` tables to get the desired result.",
    "sql": "WITH ColdsnapCards AS (\n    SELECT c.id, c.name, c.convertedManaCost, c.uuid\n    FROM cards c\n    JOIN sets s ON c.setCode = s.code\n    WHERE s.name = 'Coldsnap'\n),\nMaxCMC AS (\n    SELECT MAX(convertedManaCost) AS max_cmc\n    FROM ColdsnapCards\n)\nSELECT fd.name AS italian_name\nFROM foreign_data fd\nJOIN ColdsnapCards cc ON fd.uuid = cc.uuid\nJOIN MaxCMC m ON cc.convertedManaCost = m.max_cmc\nWHERE fd.language = 'Italian';",
    "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
    "evidence": [
      "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'; highest converted mana cost refers to MAX(convertedManaCost)"
    ]
  },
  "117": {
    "reason": "To find the percentage of loan amounts that have been fully paid with no issues, we need to follow these steps:\n1. Identify the total loan amount from the `loan` table.\n2. Identify the loan amount where the status is 'A' (indicating the loan was fully paid with no issues).\n3. Calculate the percentage by dividing the amount from step 2 by the total amount from step 1 and multiplying by 100.\n\nThe query will sum the `amount` column for all loans and for loans with status 'A', then compute the percentage.",
    "sql": "SELECT (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0 / SUM(amount)) AS percentage_paid_no_issue\nFROM loan;",
    "question": "What is the percentage of loan amount that has been fully paid with no issue.",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
    "evidence": [
      "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%"
    ]
  },
  "230": {
    "reason": "To solve the question, we need to find the elements of the atoms and the label of the molecule with the ID 'TR060'. The steps are as follows:\n1. First, we need to identify the molecule with the ID 'TR060' from the `molecule` table to get its label.\n2. Then, we need to find all atoms associated with this molecule by joining the `atom` table with the `molecule` table on the `molecule_id` field.\n3. Finally, we will select the `element` from the `atom` table and the `label` from the `molecule` table for the molecule 'TR060'.",
    "sql": "SELECT a.element, m.label FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR060';",
    "question": "What are the elements of the toxicology and label of molecule TR060?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'",
    "evidence": [
      "TR060 is the molecule id; "
    ]
  },
  "301": {
    "reason": "To find the bond type of `TR007_4_19`, we need to identify the `bond_type` associated with the bond ID `TR007_4_19` in the `bond` table. The `bond` table contains the `bond_id` and `bond_type` columns, so we can directly query this table for the given bond ID.",
    "sql": "SELECT bond_type FROM bond WHERE bond_id = 'TR007_4_19';",
    "question": "What is the bond type of TR007_4_19?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT T.bond_type FROM bond AS T WHERE T.bond_id = 'TR007_4_19'",
    "evidence": [
      "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
    ]
  },
  "836": {
    "reason": "To find the total number of superheroes that have 'John' as their first name, we need to analyze the `superhero` table. The `full_name` column in this table likely contains the full names of the superheroes. We can use the `LIKE` operator to search for names that start with 'John' (e.g., 'John%'). The query will count the number of rows where the `full_name` starts with 'John'.",
    "sql": "SELECT COUNT(*) FROM superhero WHERE full_name LIKE 'John%';",
    "question": "What is the total number of superheroes that have John as their first name?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name LIKE 'John%'",
    "evidence": [
      "have John as their first name refers to full_name LIKE 'John%';"
    ]
  },
  "39": {
    "reason": "To solve the question, we need to find the average number of test takers from schools in Fresno that opened between January 1, 1980, and December 31, 1980. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `schools` table contains information about schools, including their opening dates and locations (County). The `satscores` table contains the number of test takers (`NumTstTakr`).\n\n2. **Filter schools in Fresno**: The `County` column in the `schools` table can be used to filter schools located in Fresno.\n\n3. **Filter schools opened in 1980**: The `OpenDate` column in the `schools` table can be used to filter schools that opened between January 1, 1980, and December 31, 1980.\n\n4. **Join the tables**: The `CDSCode` in the `schools` table corresponds to the `cds` column in the `satscores` table. We need to join these tables to get the number of test takers for the filtered schools.\n\n5. **Calculate the average**: Use the `AVG` function on the `NumTstTakr` column from the `satscores` table to find the average number of test takers.\n\n6. **Final query**: Combine all these steps into a single SQL query.",
    "sql": "SELECT AVG(s.NumTstTakr) AS average_test_takers\nFROM schools sc\nJOIN satscores s ON sc.CDSCode = s.cds\nWHERE sc.County = 'Fresno'\nAND sc.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';",
    "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
    "db_id": "california_schools",
    "res": 1,
    "ground_truth": "SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T2.County = 'Fresno'",
    "evidence": [
      "between 1/1/1980 and 12/31/1980 means the year = 1980"
    ]
  },
  "103": {
    "reason": "To find the client who issued their card on 1994/3/3, we need to follow these steps:\n1. Identify the card issued on 1994/3/3 from the `card` table.\n2. Link the card to its owner via the `disp` table, which connects the card to a client.\n3. Retrieve the client ID from the `client` table.\n\nThe query will join the `card`, `disp`, and `client` tables to find the client ID where the card's issued date is 1994/3/3.",
    "sql": "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.issued = '1994-03-03';",
    "question": "Which client issued his/her card in 1994/3/3, give his/her client id.",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T2.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.issued = '1994-03-03'",
    "evidence": [
      ""
    ]
  },
  "1342": {
    "reason": "To find the cost for the \"Posters\" event on 2019/9/4, we need to follow these steps:\n1. Identify the event_id for the \"Posters\" event that occurred on 2019-09-04 from the `event` table.\n2. Use this event_id to find the corresponding budget_id in the `budget` table.\n3. From the `expense` table, sum up the `cost` values where the `link_to_budget` matches the budget_id found in step 2.\n4. The result will give the total cost for the \"Posters\" event on the specified date.",
    "sql": "SELECT SUM(e.cost) AS total_cost\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Posters' AND ev.event_date = '2019-09-04';",
    "question": "What was the cost for the \"Posters\" on 2019/9/4?",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04'",
    "evidence": [
      "'Poster' is an event description; on 2019/9/14 refers to event_date = '2019-09-04'"
    ]
  },
  "485": {
    "reason": "To find the ruling date for the card 'Reminisce', we need to follow these steps:\n1. First, locate the card 'Reminisce' in the 'cards' table to get its UUID, as the 'rulings' table references cards by UUID.\n2. Once we have the UUID, we can query the 'rulings' table for the 'date' associated with that UUID.\n3. The query will join the 'cards' and 'rulings' tables on the UUID to retrieve the ruling date for 'Reminisce'.",
    "sql": "SELECT r.date FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Reminisce';",
    "question": "When was the ruling for the card 'Reminisce' created?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Reminisce'",
    "evidence": [
      "Reminisce refers to name = 'Reminisce'; when created is the date"
    ]
  },
  "931": {
    "reason": "To find the fastest lap speed among all drivers in the 2009 Spanish Grand Prix, we need to follow these steps:\n1. Identify the raceId for the 2009 Spanish Grand Prix from the `races` table.\n2. Use the `results` table to find the fastest lap speed for each driver in that race.\n3. Retrieve the maximum value of the `fastestLapSpeed` column from the `results` table for the identified race.\n\nThe query will join the `races` and `results` tables to filter for the specific race and then find the maximum fastest lap speed.",
    "sql": "SELECT MAX(r.fastestLapSpeed) AS fastest_lap_speed\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 2009 AND rc.name = 'Spanish Grand Prix';",
    "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
    "evidence": [
      "the fastest lap speed among all refers to max(fastestLapSpeed); Spanish Grand Prix refers to races.name = 'Spanish Grand Prix';"
    ]
  },
  "1417": {
    "reason": "To solve the question, we need to list the types of events that have a remaining budget of more than 30 USD. This involves querying the `event` table and joining it with the `budget` table to filter events based on the remaining budget. The steps are:\n1. Join the `event` table with the `budget` table using the `event_id` as the linking key.\n2. Filter the results to include only those records where the `remaining` field in the `budget` table is greater than 30.\n3. Select the `type` field from the `event` table to list the types of events that meet the criteria.",
    "sql": "SELECT DISTINCT e.type\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.remaining > 30;",
    "question": "List out the type of events which have remaining budget more than 30 USD.",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 30",
    "evidence": [
      "remaining budget more than 30 USD refers to remaining > 30"
    ]
  },
  "0": {
    "reason": "To find the highest eligible free rate for K-12 students in Alameda County, we need to:\n1. Filter the `frpm` table to include only schools in Alameda County by checking the `County Name` column.\n2. From these schools, select the maximum value of the `Percent (%) Eligible Free (K-12)` column.\n3. The query will return the highest eligible free rate for K-12 students in Alameda County.",
    "sql": "SELECT MAX(`Percent (%) Eligible Free (K-12)`) AS HighestEligibleFreeRate\nFROM frpm\nWHERE `County Name` = 'Alameda';",
    "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
    "db_id": "california_schools",
    "res": 1,
    "ground_truth": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
    "evidence": [
      "Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`"
    ]
  },
  "227": {
    "reason": "To find the percentage of molecules that are carcinogenic, we need to count the total number of molecules and the number of molecules labeled as '+'. The percentage is then calculated by dividing the count of carcinogenic molecules by the total number of molecules and multiplying by 100. The result should be formatted to three decimal places. The schema provides a `molecule` table with a `label` column where '+' indicates carcinogenic molecules.",
    "sql": "SELECT ROUND((SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(molecule_id)), 3) AS percentage\nFROM molecule;",
    "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3) FROM molecule t",
    "evidence": [
      "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent"
    ]
  },
  "106": {
    "reason": "To solve the question, we need to find the biggest transaction amount made by a client whose card was opened on 1996/10/21. Here's the step-by-step reasoning:\n\n1. **Identify the client**: First, we need to find the client(s) who have a card issued on 1996/10/21. This involves joining the `card` table with the `disp` table (to link the card to a client) and then the `client` table.\n\n2. **Find transactions**: Once we have the client(s), we need to find their transactions. This involves joining the `account` table (to link the client's account) with the `trans` table.\n\n3. **Filter transactions**: We need to filter transactions made by the identified client(s).\n\n4. **Find the maximum amount**: Finally, we need to find the maximum transaction amount from the filtered transactions.\n\nThe query will involve multiple joins and a subquery to ensure we only consider transactions from the client(s) with the specified card issue date.",
    "sql": "SELECT MAX(t.amount) AS biggest_transaction_amount\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN card cd ON d.disp_id = cd.disp_id\nWHERE cd.issued = '1996-10-21';",
    "question": "What is the biggest amount of transaction that the client whose card was opened in 1996/10/21 made?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T4.amount FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 on T2.account_id = T3.account_id JOIN trans AS T4 on T3.account_id = T4.account_id WHERE T1.issued = '1996-10-21' ORDER BY T4.amount DESC LIMIT 1",
    "evidence": [
      ""
    ]
  },
  "833": {
    "reason": "To find the superhero known as Charles Chandler, we need to query the `superhero` table where the `full_name` column matches 'Charles Chandler'. The query will retrieve the `superhero_name` from the `superhero` table for this specific full name.",
    "sql": "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';",
    "question": "Name the superhero, otherwise known as Charles Chandler.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler'",
    "evidence": [
      "name the superhero refers to superhero_name; Charles Chandler is the full name of superhero;"
    ]
  },
  "82": {
    "reason": "To solve the question, we need to find the school with the highest longitude value and then determine its grade span (Low Grade to High Grade). The steps are as follows:\n1. Identify the school with the highest longitude value from the `schools` table.\n2. Use the CDSCode of this school to find its corresponding grade span in the `frpm` table.\n3. Retrieve the `Low Grade` and `High Grade` values for this school.",
    "sql": "SELECT f.\"Low Grade\", f.\"High Grade\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.Longitude = (SELECT MAX(Longitude) FROM schools);",
    "question": "What is the grade span offered in the school with the highest longitude?",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
    "evidence": [
      "the highest longitude refers to the school with the maximum absolute longitude value."
    ]
  },
  "410": {
    "reason": "To solve the question, we need to find cards from the artist 'Erica Yang' that are available in the 'pauper' format and are also available in paper. The steps are as follows:\n1. Join the `cards` table with the `legalities` table to filter cards that are legal in the 'pauper' format (where `format = 'pauper'` and `status` indicates legality).\n2. Filter the `cards` table for cards where `artist = 'Erica Yang'` and `availability = 'paper'`.\n3. Select the `id` of the matching cards to indicate their IDs.",
    "sql": "SELECT c.id\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.artist = 'Erica Yang'\nAND c.availability = 'paper'\nAND l.format = 'pauper'\nAND l.status = 'legal';",
    "question": "Is there any card from Erica Yang artist in pauper format and available in paper? If so, indicate its ID.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper'",
    "evidence": [
      "available in paper refers to availability = 'paper'"
    ]
  },
  "765": {
    "reason": "To find the number of heroes with the stealth power, we need to follow these steps:\n1. Identify the `id` of the power named 'stealth' from the `superpower` table.\n2. Use this `id` to find all entries in the `hero_power` table where the `power_id` matches the stealth power's `id`.\n3. Count the distinct `hero_id` values in these entries to get the number of unique heroes with the stealth power.",
    "sql": "SELECT COUNT(DISTINCT hero_id) AS hero_count\nFROM hero_power\nWHERE power_id = (SELECT id FROM superpower WHERE power_name = 'stealth');",
    "question": "How many heroes have stealth power?",
    "db_id": "superhero",
    "res": 0,
    "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'",
    "evidence": [
      "stealth power refers to power_name = 'stealth';"
    ]
  },
  "566": {
    "reason": "To find the reputation points of the owner user of post No. 65041, we need to follow these steps:\n1. Identify the `OwnerUserId` of the post with `Id = 65041` from the `posts` table.\n2. Use this `OwnerUserId` to query the `users` table and retrieve the `Reputation` of the user.",
    "sql": "SELECT u.Reputation\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Id = 65041;",
    "question": "For the owner user of post No. 65041, what is his/her reputation points?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
    "evidence": [
      "post no. 65041 refers to Id = '65041'; reputation point refers to Reputation"
    ]
  },
  "309": {
    "reason": "To solve the question, we need to perform two main tasks:\n1. List all atom IDs that belong to the molecule with the label 'TR346'.\n2. Count the number of distinct bond types associated with the same molecule ('TR346').\n\nFor the first task, we will join the `molecule` table with the `atom` table on the `molecule_id` field and filter for the molecule labeled 'TR346'.\n\nFor the second task, we will join the `molecule` table with the `bond` table on the `molecule_id` field, again filtering for 'TR346', and then count the distinct `bond_type` values.\n\nFinally, we will combine these results into a single query to provide the required output.",
    "sql": "SELECT a.atom_id, COUNT(DISTINCT b.bond_type) AS bond_type_count\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nLEFT JOIN bond b ON m.molecule_id = b.molecule_id\nWHERE m.label = 'TR346'\nGROUP BY a.atom_id;",
    "question": "List out the atom id that belongs to the TR346 molecule and how many bond type can be created by this molecule?",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type),T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR000' GROUP BY T1.atom_id, T2.bond_type",
    "evidence": [
      ""
    ]
  },
  "960": {
    "reason": "To find the average of the fastest lap speed in the 2009 Spanish Grand Prix race, we need to follow these steps:\n1. Identify the raceId for the 2009 Spanish Grand Prix from the `races` table.\n2. Use the `results` table to find the fastest lap speeds for all drivers in that race.\n3. Calculate the average of the `fastestLapSpeed` values from the `results` table for the identified race.\n\nThe query will involve joining the `races` and `results` tables to filter the results for the specific race and then computing the average of the `fastestLapSpeed` column.",
    "sql": "SELECT AVG(CAST(fastestLapSpeed AS REAL)) AS average_fastest_lap_speed\nFROM results\nJOIN races ON results.raceId = races.raceId\nWHERE races.year = 2009 AND races.name = 'Spanish Grand Prix';",
    "question": "What is the average of fastest lap speed in the 2009 Spanish Grand Prix race?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT AVG(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
    "evidence": [
      "Spanish Grand Prix is the name of race refers to name = 'Spanish Grand Prix'; average fastest lap speed refers to avg(fastestLapSpeed);"
    ]
  },
  "224": {
    "reason": "To solve the question, we need to find all bond IDs where the atom ID 2 is the same as the atom ID 2 in the bond connected to TR000_2. Here's the step-by-step reasoning:\n\n1. First, identify the atom ID 2 for the bond connected to TR000_2. This involves querying the `connected` table for records where `atom_id` or `atom_id2` is TR000_2.\n2. Once we have the atom ID 2, we then find all bond IDs in the `connected` table where `atom_id2` matches the atom ID 2 from the previous step.\n3. The result will give us the bond IDs that have the same atom ID 2 as TR000_2.",
    "sql": "SELECT DISTINCT c1.bond_id\nFROM connected c1\nJOIN connected c2 ON c1.atom_id2 = c2.atom_id2\nWHERE c2.atom_id = 'TR000_2' OR c2.atom_id2 = 'TR000_2';",
    "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
    "evidence": [
      "TR000_2 is the atom id; atom ID 2 refers to atom_id2"
    ]
  },
  "88": {
    "reason": "To solve the question, we need to find the school with the highest number of test takers who received SAT scores of at least 1500 (NumGE1500) and then retrieve the administrator's email address for that school. Here's the step-by-step reasoning:\n\n1. Identify the school with the highest `NumGE1500` from the `satscores` table.\n2. Use the `CDSCode` of this school to join with the `schools` table to get the administrator's email address (`AdmEmail1`).\n3. Also, retrieve the school name (`sname` from `satscores` or `School` from `schools`).\n\nThe query will involve:\n- Selecting the school with the maximum `NumGE1500`.\n- Joining the `satscores` table with the `schools` table on `CDSCode`.\n- Retrieving the administrator's email and the school name.",
    "sql": "SELECT s.AdmEmail1, sc.sname\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);",
    "question": "What is the administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500?Provide the name of the school.",
    "db_id": "california_schools",
    "res": 1,
    "ground_truth": "SELECT T2.AdmEmail1, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
    "evidence": [
      ""
    ]
  },
  "1123": {
    "reason": "To find the players with the highest potential, we need to query the `Player_Attributes` table, which contains the `potential` attribute for each player. The steps are as follows:\n1. Identify the maximum potential value in the `Player_Attributes` table.\n2. Retrieve all players who have this maximum potential value.\n3. Join the `Player` table to get the names of these players.",
    "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes);",
    "question": "What is the name of players with the highest potential?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.potential DESC LIMIT 1",
    "evidence": [
      "highest potential refers to MAX(potential)"
    ]
  },
  "1190": {
    "reason": "To solve the question, we need to find the percentage of patients with a proteinuria level within the normal range (`U-PRO` > 0 AND `U-PRO` < 30) who also have a uric acid level below the normal range (UA <= 6.5). The steps are as follows:\n1. Count the total number of patients with a proteinuria level within the normal range.\n2. Count the number of patients within this group who also have a uric acid level below the normal range.\n3. Calculate the percentage by dividing the count from step 2 by the count from step 1 and multiplying by 100.\n4. Ensure the query handles cases where the denominator (total patients with normal proteinuria) is zero to avoid division by zero errors.",
    "sql": "WITH normal_proteinuria AS (\n    SELECT COUNT(DISTINCT ID) AS total_patients\n    FROM Laboratory\n    WHERE `U-PRO` > 0 AND `U-PRO` < 30\n),\nlow_uric_acid AS (\n    SELECT COUNT(DISTINCT ID) AS patients_with_low_ua\n    FROM Laboratory\n    WHERE `U-PRO` > 0 AND `U-PRO` < 30 AND UA <= 6.5\n)\nSELECT \n    CASE \n        WHEN total_patients = 0 THEN 0\n        ELSE (patients_with_low_ua * 100.0 / total_patients)\n    END AS percentage\nFROM normal_proteinuria, low_uric_acid;",
    "error": "something went wrong, tool did not call.",
    "question": "What percentage of patients with a proteinuria level within the normal range have a uric acid level below the normal range?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Laboratory WHERE `U-PRO` > 0 AND `U-PRO` < 30",
    "evidence": [
      "proteinuria level within the normal range refers to `U-PRO` > 0 AND `U-PRO` < 30; uric acid level below the normal range refers to UA < = 6.5; calculation = MULTIPLY(DIVIDE(UA < = 6.5, `U-PRO` > 0 AND `U-PRO` < 30)，100)"
    ]
  },
  "36": {
    "reason": "To solve the question, we need to find the school with the highest number of students scoring 1500 or more on the SAT (NumGE1500) and then retrieve the full names of its administrators. The steps are as follows:\n1. Identify the school with the highest NumGE1500 from the satscores table.\n2. Join the schools table to get the administrator details for that school.\n3. Combine the first and last names of the administrators to form their full names.\n4. Return the full names of the administrators.",
    "sql": "WITH top_school AS (\n    SELECT cds\n    FROM satscores\n    ORDER BY NumGE1500 DESC\n    LIMIT 1\n)\nSELECT \n    CASE \n        WHEN AdmFName1 IS NOT NULL AND AdmLName1 IS NOT NULL THEN AdmFName1 || ' ' || AdmLName1\n        ELSE NULL\n    END AS admin1,\n    CASE \n        WHEN AdmFName2 IS NOT NULL AND AdmLName2 IS NOT NULL THEN AdmFName2 || ' ' || AdmLName2\n        ELSE NULL\n    END AS admin2,\n    CASE \n        WHEN AdmFName3 IS NOT NULL AND AdmLName3 IS NOT NULL THEN AdmFName3 || ' ' || AdmLName3\n        ELSE NULL\n    END AS admin3\nFROM schools\nWHERE CDSCode = (SELECT cds FROM top_school);",
    "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
    "evidence": [
      "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500"
    ]
  },
  "1144": {
    "reason": "To solve the question, we need to find the player with the heaviest weight from the `Player` table, then retrieve their finishing rate and curve score from the `Player_Attributes` table. The steps are as follows:\n1. Identify the player with the maximum weight in the `Player` table.\n2. Use the `player_api_id` of this player to join with the `Player_Attributes` table.\n3. Retrieve the `finishing` (finishing rate) and `curve` (curve score) attributes for this player.",
    "sql": "SELECT p.player_name, pa.finishing AS finishing_rate, pa.curve AS curve_score\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.weight = (SELECT MAX(weight) FROM Player);",
    "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
    "evidence": [
      "finishing rate refer to finishing; curve score refer to curve; heaviest weight refers to MAX(weight)"
    ]
  },
  "1152": {
    "reason": "To solve the question, we need to calculate the ratio of outpatient to inpatient followed up treatment among all 'SLE' diagnosed patients. The steps are as follows:\n1. Identify all patients diagnosed with 'SLE' (Diagnosis = 'SLE').\n2. Separate these patients into two groups based on their admission status: inpatient (Admission = '+') and outpatient (Admission = '-').\n3. Count the number of patients in each group.\n4. Calculate the ratio of outpatient to inpatient counts.\n\nThe query will involve joining the `Patient` table to filter for 'SLE' diagnosed patients and then counting the admissions.",
    "sql": "SELECT \n    (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '-') AS outpatient_count,\n    (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '+') AS inpatient_count,\n    (1.0 * (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '-') / \n    (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '+')) AS outpatient_to_inpatient_ratio\nFROM Patient\nWHERE Diagnosis = 'SLE'\nLIMIT 1;",
    "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
    "evidence": [
      "'SLE' diagnosed patient means Diagnosis = 'SLE'; inpatient refers to Admission = '+'; outpatient refers to Admission = '-'; calculation =  DIVIDE(COUNT(ID) where Diagnosis = 'SLE' and Admission = '+', COUNT(ID) where Diagnosis = 'SLE' and Admission = '-')"
    ]
  },
  "669": {
    "reason": "To determine when 'chl' cast its first vote in a post, we need to follow these steps:\n1. Identify the user 'chl' in the `users` table by matching the `DisplayName` field.\n2. Retrieve the `Id` of the user 'chl' from the `users` table.\n3. Use this `Id` to find all votes cast by 'chl' in the `votes` table.\n4. From these votes, find the earliest (minimum) `CreationDate` to determine the first vote.\n\nThe query will join the `users` and `votes` tables to achieve this.",
    "sql": "SELECT MIN(v.CreationDate) AS FirstVoteDate\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE u.DisplayName = 'chl';",
    "question": "When did 'chl' cast its first vote in a post?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T2.CreationDate FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl' ORDER BY T2.CreationDate LIMIT 1",
    "evidence": [
      "DisplayName = 'chl'; cast its first vote refers to MIN(CreationDate);"
    ]
  },
  "802": {
    "reason": "To find the tallest superhero, we need to identify the superhero with the maximum height in centimeters (`height_cm`). The `superhero` table contains the `height_cm` column, and we can use the `MAX` function to find the tallest superhero. We will then join this result with the `superhero` table to retrieve the superhero's name.",
    "sql": "SELECT superhero_name FROM superhero WHERE height_cm = (SELECT MAX(height_cm) FROM superhero);",
    "question": "Who is the tallest superhero?",
    "db_id": "superhero",
    "res": 0,
    "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
    "evidence": [
      "who refers to superhero_name; tallest superhero refers to MAX(height_cm);"
    ]
  },
  "1482": {
    "reason": "",
    "sql": "",
    "error": "something went wrong, tool did not call.",
    "question": "Which of the three segments—SME, LAM and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
    "db_id": "debit_card_specializing",
    "res": 0,
    "ground_truth": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
    "evidence": [
      "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year"
    ]
  },
  "966": {
    "reason": "To determine how many drivers participated in race ID number 18, we need to count the distinct driver entries in the `results` table where the `raceId` is 18. The `results` table contains records of all race results, including the `driverId` for each participant. By counting the distinct `driverId` values for `raceId` 18, we can find the number of drivers who participated in that race.",
    "sql": "SELECT COUNT(DISTINCT driverId) FROM results WHERE raceId = 18;",
    "question": "How many driver participated in race ID number 18?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18",
    "evidence": [
      ""
    ]
  },
  "651": {
    "reason": "To find the related post title of \"How to tell if something happened in a data set which monitors a value over time\", we need to follow these steps:\n1. Identify the `PostId` of the post with the given title from the `posts` table.\n2. Use the `postLinks` table to find the `RelatedPostId` linked to this `PostId`.\n3. Retrieve the title of the related post from the `posts` table using the `RelatedPostId`.\n\nThe query will involve joining the `posts` table with the `postLinks` table to fetch the required information.",
    "sql": "SELECT p2.Title AS RelatedPostTitle\nFROM posts p1\nJOIN postLinks pl ON p1.Id = pl.PostId\nJOIN posts p2 ON pl.RelatedPostId = p2.Id\nWHERE p1.Title = 'How to tell if something happened in a data set which monitors a value over time';",
    "question": "Provide the related post title of \"How to tell if something happened in a data set which monitors a value over time\".",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T3.Title FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN posts AS T3 ON T1.RelatedPostId = T3.Id WHERE T2.Title = 'How to tell if something happened in a data set which monitors a value over time'",
    "evidence": [
      ""
    ]
  },
  "427": {
    "reason": "To find the languages available in the set known as Archenemy with the code ARC, we need to query the `set_translations` table. This table contains the `language` field, which lists the languages for each set. The `setCode` field in `set_translations` references the `code` field in the `sets` table. We will join these tables to filter for the set with the code 'ARC' and retrieve the distinct languages available for this set.",
    "sql": "SELECT DISTINCT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.code = 'ARC';",
    "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
    "evidence": [
      "known as Archenemy refers to mcmName = 'Archenemy'; having the code ARC refers to setCode = 'ARC'"
    ]
  },
  "1067": {
    "reason": "To solve the question, we need to identify teams with a build-up play passing attribute greater than 70 and list their short names. The relevant tables are `Team` and `Team_Attributes`. The `Team_Attributes` table contains the `buildUpPlayPassing` attribute, and the `Team` table contains the `team_short_name` field. We will join these tables on the `team_api_id` to match the team attributes with their respective short names.",
    "sql": "SELECT t.team_short_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE ta.buildUpPlayPassing > 70;",
    "question": "Which teams have build up play passing more than 70? Please list their short names.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayPassing > 70",
    "evidence": [
      "build up play passing refers to buildUpPlayPassing; buildUpPlayPassing > 70; short names refers to team_short_name;"
    ]
  },
  "336": {
    "reason": "To solve the question, we need to find the number of molecules with triple bonds that are not carcinogenic. The steps are as follows:\n1. Identify molecules with triple bonds by checking the `bond` table where `bond_type` is '#'.\n2. Join the `bond` table with the `molecule` table to get the `label` of these molecules.\n3. Filter the results to include only molecules where the `label` is '-', indicating they are non-carcinogenic.\n4. Count the distinct `molecule_id` values from the filtered results to get the number of such molecules.",
    "sql": "SELECT COUNT(DISTINCT b.molecule_id) \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.bond_type = '#' AND m.label = '-';",
    "question": "in molecules with triple bonds, how many of them are not carcinogenic?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND T1.label = '-'",
    "evidence": [
      "triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic"
    ]
  },
  "310": {
    "reason": "To solve the question, we need to break it down into two parts:\n1. Identify molecules that have a double bond type (bond_type = ' = ').\n2. Among these molecules, count how many are labeled as carcinogenic (label = '+').\n\nStep 1: Find molecules with double bonds by joining the `bond` table where `bond_type` is ' = '.\nStep 2: Join the result with the `molecule` table to filter molecules labeled as '+'.\nStep 3: Count the distinct molecules in each case.",
    "sql": "WITH double_bond_molecules AS (\n  SELECT DISTINCT molecule_id\n  FROM bond\n  WHERE bond_type = ' = '\n)\nSELECT \n  COUNT(*) AS total_molecules_with_double_bond,\n  SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) AS carcinogenic_molecules_with_double_bond\nFROM double_bond_molecules dbm\nJOIN molecule m ON dbm.molecule_id = m.molecule_id;",
    "question": "How many molecules have a double bond type and among these molecule, how many are labeled as carcinogenic compound?",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id), SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '='",
    "evidence": [
      "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic;"
    ]
  },
  "398": {
    "reason": "To solve the question, we need to find the total unconverted mana cost of all cards created by the artist \"Rob Alexander\". The unconverted mana cost is stored in the `manaCost` column of the `cards` table. The steps are:\n1. Filter the `cards` table to include only rows where the `artist` column is \"Rob Alexander\".\n2. Sum the values in the `manaCost` column for these filtered rows.\n3. Return the total sum as the result.",
    "sql": "SELECT SUM(manaCost) AS total_unconverted_mana_cost FROM cards WHERE artist = 'Rob Alexander';",
    "question": "What is the  unconverted mana do all the cards created by Rob Alexander cost in total?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
    "evidence": [
      "unconverted mana refer to manaCost; Rob Alexander refer to artist"
    ]
  },
  "136": {
    "reason": "To solve the question, we need to find the number of loans with an amount of at least 250,000 per account that were approved for accounts with monthly statement issuance (frequency = 'POPLATEK MESICNE') between 1/1/1995 and 12/31/1997. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: We need data from the `account` table (for frequency), the `loan` table (for loan details), and possibly the `disp` table to link accounts to loans.\n2. **Filter accounts with monthly issuance**: The `account` table has a `frequency` column where 'POPLATEK MESICNE' indicates monthly issuance.\n3. **Filter loans within the date range and amount**: The `loan` table has `date` and `amount` columns. We need loans between 1/1/1995 and 12/31/1997 with an amount of at least 250,000.\n4. **Check loan status**: The `loan` table has a `status` column; we need loans with an approved status.\n5. **Count loans per account**: We need to count the number of loans per account that meet the criteria.\n6. **Join tables**: We need to join the `account`, `loan`, and `disp` tables to link accounts to loans.\n\nThe final query will filter accounts with monthly issuance, join them with loans, filter loans by date, amount, and status, and then count the loans per account.",
    "sql": "SELECT COUNT(*) AS loan_count\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nWHERE a.frequency = 'POPLATEK MESICNE'\nAND l.date BETWEEN '1995-01-01' AND '1997-12-31'\nAND l.amount >= 250000\nAND l.status = 'approved';",
    "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
    "db_id": "financial",
    "res": 0,
    "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
    "evidence": [
      "Frequency = 'POPLATEK MESICNE' stands for monthly issurance"
    ]
  },
  "434": {
    "reason": "To solve the question, we need to find the number of sets that are available only in Japanese and not in Magic: The Gathering Online (MTGO). This involves the following steps:\n1. Identify sets that are available in Japanese by checking the `set_translations` table where the language is 'Japanese'.\n2. Exclude sets that are available in MTGO by checking the `sets` table where `mtgoCode` is not null (since MTGO sets have an `mtgoCode`).\n3. Count the distinct sets that meet both criteria.",
    "sql": "SELECT COUNT(DISTINCT s.code) \nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Japanese'\nAND s.mtgoCode IS NULL;",
    "question": "How many sets are available just in Japanese and not in Magic: The Gathering Online?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.language = 'Japanese'  AND (T1.mtgoCode IS NULL OR T1.mtgoCode = '')",
    "evidence": [
      "Japanese refers to language = 'Japanese'; not in Magic: The Gathering Online refers to mtgoCode is null or mtgoCode = ''"
    ]
  },
  "1502": {
    "reason": "To solve the question, we need to identify the chains of gas stations where transactions were made in euros. The steps are as follows:\n1. Identify transactions where the currency is 'EUR' (euro). This information is in the `customers` table under the `Currency` column.\n2. Join the `transactions_1k` table with the `customers` table to filter transactions in euros.\n3. Join the result with the `gasstations` table to get the `ChainID` of the gas stations involved in these transactions.\n4. Group the results by `ChainID` to list the unique chains.",
    "sql": "SELECT DISTINCT g.ChainID\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE c.Currency = 'EUR';",
    "question": "Please list the chains of the gas stations with transactions in euro.",
    "db_id": "debit_card_specializing",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T3.ChainID FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN gasstations AS T3 ON T1.GasStationID = T3.GasStationID WHERE T2.Currency = 'EUR'",
    "evidence": [
      ""
    ]
  },
  "1437": {
    "reason": "To solve the question, we need to identify members who were approved for expenses between 1/10/2019 and 11/19/2019. The question also asks for the events these members attended. Here's the step-by-step reasoning:\n\n1. **Filter Approved Expenses**: First, we need to find all expenses that were approved (`approved = 'true'`) and occurred between the specified dates (`expense_date BETWEEN '2019-01-10' AND '2019-11-19'`).\n2. **Link to Members**: From these expenses, we can get the `link_to_member` to identify the members involved.\n3. **Link to Events**: Using the `attendance` table, we can find the events these members attended by matching the `link_to_member` with the `link_to_event`.\n4. **Retrieve Member and Event Details**: Finally, we join the `member` and `event` tables to get the names of the members and the details of the events they attended.\n\nThe query will involve joining the `expense`, `member`, `attendance`, and `event` tables to gather all the required information.",
    "sql": "SELECT m.member_id, m.first_name, m.last_name, e.event_id, e.event_name, e.event_date\nFROM expense ex\nJOIN member m ON ex.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE ex.approved = 'true'\nAND ex.expense_date BETWEEN '2019-01-10' AND '2019-11-19'",
    "question": "Which members who were approved from 1/10/2019 to 11/19/2019? Please identify the member who attended the event and the link to their event.",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T1.link_to_member, T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true'",
    "evidence": [
      "approved from 1/10/2019 to 11/19/2019 refers to approved = 'true' and expense_date BETWEEN '2019-01-10' and '2019-11-19'"
    ]
  },
  "1319": {
    "reason": "To find out which college the vice president of the Student Club is from, we need to follow these steps:\n1. Identify the member who holds the position of 'Vice President' in the `member` table.\n2. Retrieve the `link_to_major` for this member, which links to the `major` table.\n3. From the `major` table, retrieve the `college` associated with the major of the vice president.\n4. Combine these steps in a query to get the desired result.",
    "sql": "SELECT m.college\nFROM member AS mem\nJOIN major AS m ON mem.link_to_major = m.major_id\nWHERE mem.position = 'Vice President';",
    "question": "Which college is the vice president of the Student_Club from?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position LIKE 'vice president'",
    "evidence": [
      "Vice President is a position of the Student Club"
    ]
  },
  "1062": {
    "reason": "To solve the question, we need to find players who had an overall rating of over 80 between the years 2008 and 2010. The steps are as follows:\n1. Identify the relevant tables: `Player_Attributes` for the ratings and dates, and `Player` for the player names.\n2. Filter the `Player_Attributes` table for records where `overall_rating` is greater than 80 and the `date` falls between 2008 and 2010.\n3. Join the filtered `Player_Attributes` table with the `Player` table to get the player names.\n4. Ensure distinct player names are returned to avoid duplicates if a player had multiple ratings over 80 in the specified period.",
    "sql": "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating > 80\nAND pa.date BETWEEN '2008-01-01' AND '2010-12-31';\n",
    "question": "Which players had an overall rating of over 80 from 2008 to 2010? Please list player names.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating > 80 AND SUBSTR(t2.`date`, 1, 4) BETWEEN '2008' AND '2010'",
    "evidence": [
      "overall_rating > 80; from 2008 to 2010 refers to strftime('%Y', date) BETWEEN '2008' AND '2010';"
    ]
  },
  "571": {
    "reason": "To solve the question, we need to compare the number of posts made by user No. 24 to the number of votes they have received. The steps are as follows:\n1. Count the number of posts where the OwnerUserId is 24.\n2. Count the number of votes where the UserId is 24.\n3. Calculate the ratio of the number of posts to the number of votes.\n4. Return the result as a ratio.",
    "sql": "SELECT \n    (SELECT COUNT(*) FROM posts WHERE OwnerUserId = 24) AS post_count,\n    (SELECT COUNT(*) FROM votes WHERE UserId = 24) AS vote_count,\n    CASE \n        WHEN (SELECT COUNT(*) FROM votes WHERE UserId = 24) = 0 THEN NULL\n        ELSE CAST((SELECT COUNT(*) FROM posts WHERE OwnerUserId = 24) AS FLOAT) / (SELECT COUNT(*) FROM votes WHERE UserId = 24)\n    END AS post_to_vote_ratio;",
    "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
    "evidence": [
      "user no. 24 refers to UserId = OwnerUserId = '24'; times of his/her post than votes = Divide (Count(post.Id), Count(votes.Id))"
    ]
  },
  "503": {
    "reason": "To find the expansion type for the set containing the card \"Samite Pilgrim\", we need to follow these steps:\n1. First, locate the card \"Samite Pilgrim\" in the `cards` table to get its `setCode`.\n2. Then, use the `setCode` to query the `sets` table to find the `type` of the set.\n\nThe query will involve joining the `cards` table with the `sets` table based on the `setCode`.",
    "sql": "SELECT s.type \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Samite Pilgrim';",
    "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
    "evidence": [
      "expansion type refers to type; card \"Samite Pilgrim\" refers to name = 'Samite Pilgrim'"
    ]
  },
  "416": {
    "reason": "To solve the question, we need to find the percentage of cards without power that are in French. The steps are as follows:\n1. Identify cards without power (where `power` is NULL or `power = '*'`).\n2. From these cards, identify those that have French translations in the `foreign_data` table (where `language = 'French'`).\n3. Calculate the percentage by dividing the count of French cards without power by the total count of cards without power, then multiplying by 100.\n4. The query will join the `cards` table with the `foreign_data` table to filter for French language entries.",
    "sql": "SELECT (COUNT(CASE WHEN fd.language = 'French' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM cards c\nLEFT JOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.power IS NULL OR c.power = '*';",
    "question": "What percentage of cards without power are in French?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power = '*'",
    "evidence": [
      "in French refers to language = 'French'; cards without power refers to power IS NULL OR power = '*'; percentage = DIVIDE(COUNT(language = 'French' and power is NULL or power = '*'), COUNT( power is NULL or power = '*'))*100"
    ]
  },
  "260": {
    "reason": "To solve the question, we need to calculate the total number of atoms in molecules that have triple bonds and contain either phosphorus ('p') or bromine ('br'). Here's the step-by-step reasoning:\n\n1. **Identify molecules with triple bonds**: We need to find all `molecule_id`s from the `bond` table where `bond_type` is '#' (triple bond).\n2. **Filter atoms in these molecules**: From the `atom` table, we need to find all atoms where the `molecule_id` matches those identified in step 1 and the `element` is either 'p' (phosphorus) or 'br' (bromine).\n3. **Count the atoms**: Finally, we count the number of such atoms.\n\nThe query will involve joining the `bond` and `atom` tables to filter the relevant molecules and atoms, and then counting the results.",
    "sql": "SELECT COUNT(a.atom_id) AS total_atoms\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE b.bond_type = '#' AND (a.element = 'p' OR a.element = 'br');",
    "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
    "evidence": [
      "triple bond refers to bond_type = '#'; phosphorus refers to element = 'p'; bromine refers to element = 'br'"
    ]
  },
  "1085": {
    "reason": "To determine which player performs the best in crossing actions among Alexis, Ariel Borysiuk, and Arouna Kone, we need to:\n1. Identify the player_api_id for each of these players from the Player table.\n2. Retrieve their crossing attribute values from the Player_Attributes table.\n3. Compare the crossing values to determine the highest performer.\n\nThe query will join the Player and Player_Attributes tables to fetch the crossing attribute for each player.",
    "sql": "SELECT p.player_name, pa.crossing\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone')\nORDER BY pa.crossing DESC\nLIMIT 1;",
    "question": "Which of these players performs the best in crossing actions, Alexis, Ariel Borysiuk or Arouna Kone?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT t1.player_name, t2.crossing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY t2.crossing DESC LIMIT 1",
    "evidence": [
      "player who perform best in crossing actions refers to MAX(crossing);"
    ]
  },
  "1479": {
    "reason": "To solve the question, we need to find the year with the highest gas consumption paid in CZK. Here's the step-by-step reasoning:\n\n1. **Identify relevant tables**: The `transactions_1k` table contains transaction details, including `GasStationID`, `ProductID`, `Amount`, and `Price`. The `customers` table contains the `Currency` field, which indicates the payment currency (CZK in this case). The `yearmonth` table contains `Consumption` data linked to `CustomerID` and `Date`.\n\n2. **Filter transactions paid in CZK**: Join the `transactions_1k` table with the `customers` table to filter transactions where `Currency` is 'CZK'.\n\n3. **Extract the year from the Date**: The `yearmonth` table's `Date` field can be used to extract the year (first 4 characters).\n\n4. **Calculate total consumption per year**: Sum the `Consumption` values from the `yearmonth` table for each year.\n\n5. **Find the year with the highest consumption**: Group the results by year and order them by total consumption in descending order, then limit the result to the top year.\n\n6. **Final query**: Combine these steps into a SQL query that joins the relevant tables, filters for CZK, groups by year, and orders by total consumption.",
    "sql": "SELECT SUBSTR(ym.Date, 1, 4) AS Year, SUM(ym.Consumption) AS TotalConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Currency = 'CZK'\nGROUP BY Year\nORDER BY TotalConsumption DESC\nLIMIT 1;",
    "question": "Which year recorded the most consumption of gas paid in CZK?",
    "db_id": "debit_card_specializing",
    "res": 0,
    "ground_truth": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
    "evidence": [
      "The first 4 strings of the Date values in the yearmonth table can represent year."
    ]
  },
  "53": {
    "reason": "To solve the question, we need to find the number of test takers at schools whose mailing city address is in Fresno. The steps are as follows:\n1. Identify the schools with a mailing city of 'Fresno' from the `schools` table.\n2. Join these schools with the `satscores` table to get the number of test takers (`NumTstTakr`) for each school.\n3. Sum the number of test takers to get the total count.",
    "sql": "SELECT SUM(s.NumTstTakr) AS TotalTestTakers\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE sc.MailCity = 'Fresno';",
    "question": "How many test takers are there at the school/s whose mailing city address is in Fresno?",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'",
    "evidence": [
      ""
    ]
  },
  "478": {
    "reason": "To find card number 4 in the set Coldsnap, I need to query the `cards` table. The `cards` table contains the `number` field (which represents the card number) and the `setCode` field (which represents the set the card belongs to). The question specifies that the set is 'Coldsnap', so I will filter the `setCode` to match 'Coldsnap' and the `number` to match '4'. The result will give me the details of the card with number 4 in the Coldsnap set.",
    "sql": "SELECT * FROM cards WHERE setCode = 'Coldsnap' AND number = '4';",
    "question": "What is card number 4 in the set Coldsnap?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.number = 4",
    "evidence": [
      "card set Coldsnap refers to name = 'Coldsnap'; card number 4 refers to number = 4"
    ]
  },
  "767": {
    "reason": "To find the average of superheroes with no skin colour, we need to follow these steps:\n1. Identify the condition for \"no skin colour\" which is `skin_colour_id = 1` (as per the tip provided).\n2. Count the total number of superheroes in the `superhero` table.\n3. Count the number of superheroes where `skin_colour_id = 1`.\n4. Calculate the average by dividing the total count of superheroes by the count of superheroes with no skin colour.\n5. The query will involve joining the `superhero` table with the `colour` table to ensure the condition is correctly applied.",
    "sql": "SELECT COUNT(*) * 1.0 / SUM(CASE WHEN skin_colour_id = 1 THEN 1 ELSE 0 END) AS average_no_skin_colour\nFROM superhero;",
    "question": "What is the average of superheroes with no skin colour?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id",
    "evidence": [
      "average = DIVIDE(COUNT(superhero.id), SUM(skin_colour_id = 1)); no skin colour refers to skin_colour_id WHERE colour.id = 1;"
    ]
  },
  "583": {
    "reason": "To solve the question, we need to find the total score of posts edited by a user with the display name \"Yevgeny\" and include the user's website URL. Here's the step-by-step reasoning:\n\n1. **Identify the user**: First, we need to find the user with the display name \"Yevgeny\" in the `users` table to get their `Id` and `WebsiteUrl`.\n2. **Find edited posts**: Using the `posts` table, we need to find all posts where the `LastEditorUserId` matches the `Id` of the user \"Yevgeny\".\n3. **Calculate total score**: Sum the `Score` of all these posts to get the total score.\n4. **Include website URL**: Ensure the result includes the `WebsiteUrl` of the user \"Yevgeny\".\n\nCombining these steps, we will join the `users` and `posts` tables, filter for the user \"Yevgeny\", and aggregate the scores of their edited posts.",
    "sql": "SELECT SUM(p.Score) AS TotalScore, u.WebsiteUrl\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE u.DisplayName = 'Yevgeny';\n",
    "question": "What is the total score of the posts edited by Yevgeny and include the user's website URL.",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT SUM(T1.Score), T2.WebsiteUrl FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Yevgeny' GROUP BY T2.WebsiteUrl",
    "evidence": [
      "\"Yevgeny\" is the DisplayName; edited refers to LastEditorUserId"
    ]
  },
  "1448": {
    "reason": "To solve the question, we need to find the name and date of events where expenses for pizza were more than $50 but less than $100. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The question involves `event` (for event details), `expense` (for expense details), and `budget` (to link expenses to events).\n\n2. **Filter expenses for pizza**: The `expense` table has a column `expense_description` where we can filter for entries containing \"pizza\".\n\n3. **Filter cost range**: The `expense` table also has a `cost` column, which we need to filter for values greater than 50 and less than 100.\n\n4. **Link expenses to events**: The `expense` table links to the `budget` table via `link_to_budget`, and the `budget` table links to the `event` table via `link_to_event`. We need to join these tables to get the event details.\n\n5. **Select required fields**: Finally, we need to select the `event_name` and `event_date` from the `event` table for the filtered events.",
    "sql": "SELECT e.event_name, e.event_date\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.expense_description LIKE '%pizza%'\nAND ex.cost > 50\nAND ex.cost < 100;",
    "question": "Find the name and date of events with expenses for pizza that were more than fifty dollars but less than a hundred dollars.",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T1.event_name, T1.event_date FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.expense_description = 'Pizza' AND T3.cost > 50 AND T3.cost < 100",
    "evidence": [
      "name of event refers to event_name; date of event refers to event_date; expenses for pizza refers to expense_description = 'Pizza' where cost > 50 and cost < 100"
    ]
  },
  "1512": {
    "reason": "To find out which customer paid the most on 2012/8/25, we need to:\n1. Filter the transactions_1k table for transactions that occurred on 2012-08-25.\n2. Calculate the total amount paid by each customer by multiplying the Amount and Price for each transaction and summing these values.\n3. Group the results by CustomerID to aggregate the total payments per customer.\n4. Order the results in descending order of the total payment to find the customer who paid the most.\n5. Limit the result to the top customer.",
    "sql": "SELECT CustomerID, SUM(Amount * Price) AS TotalPaid\nFROM transactions_1k\nWHERE Date = '2012-08-25'\nGROUP BY CustomerID\nORDER BY TotalPaid DESC\nLIMIT 1;",
    "question": "Which customer paid the most in 2012/8/25?",
    "db_id": "debit_card_specializing",
    "res": 0,
    "ground_truth": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
    "evidence": [
      "'2012/8/25' can be represented by '2012-08-25'"
    ]
  },
  "502": {
    "reason": "To find the release date for the set \"Ola de frío\", we need to understand that \"Ola de frío\" is a translation of a set name. The schema includes a table called `set_translations` which links set codes to their translations in different languages. The `sets` table contains the release date for each set, identified by its code. Therefore, the steps are:\n1. Query the `set_translations` table to find the set code where the translation is \"Ola de frío\".\n2. Use the set code obtained from the first step to query the `sets` table for the release date of that set.",
    "sql": "SELECT s.releaseDate \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Ola de frío';",
    "question": "What is the release date for the set \"Ola de frío\"?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT T1.releaseDate FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Ola de frío'",
    "evidence": [
      "release date is the date of card set being released; set \"Ola de frío\" refers to translation = 'Ola de frío'"
    ]
  },
  "158": {
    "reason": "To find the district ID of the account that placed the order with the ID 33333, we need to follow these steps:\n1. Locate the order with `order_id = 33333` in the `order` table to get the `account_id` associated with this order.\n2. Use the `account_id` to find the corresponding account in the `account` table, which contains the `district_id`.\n3. Retrieve the `district_id` from the `account` table.\n\nThe query will join the `order` and `account` tables to link the order ID to the district ID.",
    "sql": "SELECT a.district_id\nFROM account a\nJOIN `order` o ON a.account_id = o.account_id\nWHERE o.order_id = 33333;",
    "question": "What is the district Id of the account that placed the order with the id 33333?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
    "evidence": [
      ""
    ]
  },
  "572": {
    "reason": "To find the number of views for the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer', we need to query the `posts` table. The `posts` table contains the `Title` and `ViewCount` columns, which are relevant to this question. We will filter the posts by the exact title and retrieve the `ViewCount` for that post.",
    "sql": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';",
    "question": "How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'",
    "evidence": [
      "\"Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer\" is the Title of post; views refers to ViewCount"
    ]
  },
  "479": {
    "reason": "To solve the question, we need to find the number of cards in the 'Coldsnap' set with a converted mana cost higher than 5 and an unknown power. The steps are as follows:\n1. Identify the 'Coldsnap' set by its name in the 'sets' table.\n2. Join the 'cards' table with the 'sets' table using the 'setCode' field to filter cards from the 'Coldsnap' set.\n3. Filter cards where the 'convertedManaCost' is greater than 5.\n4. Further filter cards where the 'power' is either '*' or NULL (unknown power).\n5. Count the number of such cards.",
    "sql": "SELECT COUNT(*) \nFROM cards \nJOIN sets ON cards.setCode = sets.code \nWHERE sets.name = 'Coldsnap' \nAND cards.convertedManaCost > 5 \nAND (cards.power = '*' OR cards.power IS NULL);",
    "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
    "evidence": [
      "card set Coldsnap refers to name = 'Coldsnap'; converted mana cost higher than 5 refers to convertedManaCost > 5; unknown power refers to power = '*' or T1.power is null"
    ]
  },
  "724": {
    "reason": "To solve the question, we need to find superheroes with blue eyes and blond hair. This involves querying the `superhero` table and joining it with the `colour` table twice: once for eye colour and once for hair colour. The steps are as follows:\n1. Join the `superhero` table with the `colour` table for eye colour (where `eye_colour_id` matches `colour.id` and `colour.colour` is 'Blue').\n2. Join the `superhero` table again with the `colour` table for hair colour (where `hair_colour_id` matches `colour.id` and `colour.colour` is 'Blond').\n3. Select the `superhero_name` from the filtered results.",
    "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id AND eye_colour.colour = 'Blue'\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id AND hair_colour.colour = 'Blond';\n",
    "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
    "evidence": [
      "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; blond hair refers to colour = 'Blond' and hair_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'"
    ]
  },
  "604": {
    "reason": "To solve the question, we need to find the average up votes and the average age of users who have created more than 10 posts. Here's the step-by-step reasoning:\n\n1. **Identify users with more than 10 posts**: We need to count the number of posts each user has created by grouping the `posts` table by `OwnerUserId` and filtering for users with a count greater than 10.\n\n2. **Calculate average up votes and age**: For these users, we will then calculate the average of the `UpVotes` and `Age` fields from the `users` table.\n\n3. **Join tables**: We will join the `users` table with the filtered list of users from the `posts` table to get the required data.\n\n4. **Aggregate results**: Finally, we will compute the averages for the filtered users.",
    "sql": "SELECT AVG(u.UpVotes) AS average_up_votes, AVG(u.Age) AS average_user_age\nFROM users u\nJOIN (\n    SELECT OwnerUserId, COUNT(*) AS post_count\n    FROM posts\n    GROUP BY OwnerUserId\n    HAVING COUNT(*) > 10\n) p ON u.Id = p.OwnerUserId;",
    "question": "What is the average of the up votes and the average user age for users creating more than 10 posts?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT AVG(T1.UpVotes), AVG(T1.Age) FROM users AS T1 INNER JOIN ( SELECT OwnerUserId, COUNT(*) AS post_count FROM posts GROUP BY OwnerUserId HAVING post_count > 10) AS T2 ON T1.Id = T2.OwnerUserId",
    "evidence": [
      "creating more than 10 post refers to Count (UserId) > 10; average of the up votes = Divide (Sum(UpVotes), Count (UserId)); average age = Divide (Sum(Age), Count(UserId))"
    ]
  },
  "267": {
    "reason": "To solve the question, we need to list the bond types for molecules with IDs ranging from TR000 to TR050. The bond types are stored in the `bond` table, and the `molecule_id` column in this table links to the `molecule` table. We will query the `bond` table for all records where the `molecule_id` is between TR000 and TR050, inclusive. The result will include the `bond_type` for these molecules.",
    "sql": "SELECT bond_type FROM bond WHERE molecule_id BETWEEN 'TR000' AND 'TR050';",
    "question": "List down the bond type for molecules from molecule id TR000 to TR050.",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'",
    "evidence": [
      "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
    ]
  },
  "621": {
    "reason": "To find the names of badges obtained by users with the lowest reputation, we need to follow these steps:\n1. Identify the users with the lowest reputation from the `users` table.\n2. Join these users with the `badges` table to find the badges they have obtained.\n3. Extract the names of these badges.\n\nThe query will first find the minimum reputation value, then find users with that reputation, and finally join with the `badges` table to get the badge names.",
    "sql": "SELECT DISTINCT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Reputation = (SELECT MIN(Reputation) FROM users);",
    "question": "What are the name of badges that users who have the lowest reputation obtained?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
    "evidence": [
      "lowest reputation refers to Min(Reputation); user refers to UserId"
    ]
  },
  "627": {
    "reason": "To determine how many users are adults, we need to count the number of users in the `users` table where the `Age` falls between 19 and 65, inclusive. The schema defines an adult as a user with an age in this range. The query will involve filtering the `users` table based on the `Age` column and then counting the results.",
    "sql": "SELECT COUNT(*) AS adult_users_count FROM users WHERE Age BETWEEN 19 AND 65;",
    "question": "How many users were adult?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
    "evidence": [
      "adult refers to user where Age BETWEEN 19 and 65;"
    ]
  },
  "521": {
    "reason": "To solve the question, we need to find the status of a specific card in the legacy play format. The card must meet the following criteria:\n1. Its frame style version is 1997.\n2. It is illustrated by D. Alexander Gregory.\n3. It has sensitive content or is associated with Wizards of the Coast.\n\nWe will break this down into steps:\n1. Identify cards with frame version '1997' from the `cards` table.\n2. Filter these cards to those illustrated by D. Alexander Gregory (using the `artist` field).\n3. Further filter these cards to those with sensitive content (`hasContentWarning = 1`) or associated with Wizards of the Coast (this might require checking the `flavorText` or other fields, but the schema does not explicitly indicate this, so we will focus on `hasContentWarning`).\n4. Join the filtered cards with the `legalities` table to find their status in the 'legacy' format.\n\nThe query will involve joining the `cards` and `legalities` tables and applying the necessary filters.",
    "sql": "SELECT l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.frameVersion = '1997'\nAND c.artist = 'D. Alexander Gregory'\nAND (c.hasContentWarning = 1 OR c.flavorText LIKE '%Wizards of the Coast%')\nAND l.format = 'legacy';",
    "question": "Among the cards whose version of frame style is 1997, what is the status of the card illustrated by D. Alexander Gregory in legacy play format that has sensitive content or Wizards of the Coast?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.frameVersion = 1997 AND T1.hasContentWarning = 1 AND T1.artist = 'D. Alexander Gregory' AND T2.format = 'legacy'",
    "evidence": [
      "version of frame style is 1997 refers to frameVersion = '1997'; illustrated by D. Alexander Gregory refers to artist = 'D. Alexander Gregory'; sensitive content refers to hasContentWarning = 1; legacy play format refers to format = 'legacy'; status of the card refers to status"
    ]
  },
  "1471": {
    "reason": "To find the ratio of customers who pay in EUR against customers who pay in CZK, we need to:\n1. Count the number of customers who pay in EUR.\n2. Count the number of customers who pay in CZK.\n3. Calculate the ratio by dividing the count of EUR customers by the count of CZK customers.\n\nWe will query the `customers` table to get these counts based on the `Currency` column.",
    "sql": "SELECT \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'EUR') * 1.0 / \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'CZK') AS ratio_EUR_to_CZK;",
    "question": "What is the ratio of customers who pay in EUR against customers who pay in CZK?",
    "db_id": "debit_card_specializing",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) AS ratio FROM customers",
    "evidence": [
      "ratio of customers who pay in EUR against customers who pay in CZK = count(Currency = 'EUR') / count(Currency = 'CZK')."
    ]
  },
  "732": {
    "reason": "To find the publisher that published the slowest superhero, we need to follow these steps:\n1. Identify the attribute related to speed in the `attribute` table. This is likely an attribute named 'Speed' or similar.\n2. Join the `hero_attribute` table with the `attribute` table to filter for the 'Speed' attribute.\n3. Find the superhero with the lowest `attribute_value` for 'Speed'.\n4. Join the `superhero` table with the `publisher` table to get the publisher's name for the identified superhero.\n5. Return the publisher's name.",
    "sql": "SELECT p.publisher_name\nFROM publisher p\nJOIN superhero s ON p.id = s.publisher_id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nORDER BY ha.attribute_value ASC\nLIMIT 1;",
    "question": "Which publisher published the slowest superhero?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed' ORDER BY T3.attribute_value LIMIT 1",
    "evidence": [
      "the slowest superhero refers to attribute_name = 'Speed' where MIN(attribute_value); publisher refers to publisher_name"
    ]
  },
  "575": {
    "reason": "To find the badge name that the user 'SilentGhost' obtained, we need to follow these steps:\n1. First, identify the user ID of 'SilentGhost' from the `users` table.\n2. Then, use this user ID to query the `badges` table to find all badges associated with this user.\n3. Finally, retrieve the `Name` column from the `badges` table for the user 'SilentGhost'.",
    "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'SilentGhost';",
    "question": "What is the badge name that user 'SilentGhost' obtained?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'SilentGhost'",
    "evidence": [
      "\"SilentGhost\" is the DisplayName of user;"
    ]
  },
  "1267": {
    "reason": "To solve the question, we need to find the number of patients who have normal anti-SM and do not have thrombosis. The steps are as follows:\n1. Identify patients with normal anti-SM based on the tips provided: SM IN('-', '+-').\n2. Join the `Examination` table with the `Patient` table to ensure we are working with valid patient records.\n3. Filter these patients to include only those who do not have thrombosis (Thrombosis = 0).\n4. Count the distinct patient IDs that meet these criteria.",
    "sql": "SELECT COUNT(DISTINCT E.ID) \nFROM Examination E\nJOIN Patient P ON E.ID = P.ID\nWHERE (E.SM IN('-', '+-')) AND E.Thrombosis = 0;",
    "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
    "evidence": [
      "normal anti-SM refers to SM IN('-', '+-'); SM = 'negative' means '-'; SM = '0' means '+-'; SM = '1' means '+'; does not have thrombosis refers to Thrombosis = 0;"
    ]
  },
  "797": {
    "reason": "To find superheroes with blue eyes and brown hair, we need to:\n1. Identify the `colour` IDs for 'Blue' (eyes) and 'Brown' (hair).\n2. Join the `superhero` table with the `colour` table twice: once for eye colour and once for hair colour.\n3. Filter the results where the eye colour is 'Blue' and the hair colour is 'Brown'.\n4. Return the `superhero_name` of the matching superheroes.",
    "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id\nWHERE eye_colour.colour = 'Blue' AND hair_colour.colour = 'Brown';",
    "question": "Which superheroes have blue eyes with brown hair?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'",
    "evidence": [
      "which superheroes refers to superhero_name; blue eyes refers to color = 'Blue' and color.id = eye_colour_id; brown hair refers to color = 'Brown' and color.id = hair_colour_id;"
    ]
  },
  "666": {
    "reason": "To solve the question, we need to find the most valuable post among those voted by user 1465. The value of a post can be determined by its score, which is stored in the `posts` table. The `votes` table records the votes cast by users, including user 1465. We will join the `votes` and `posts` tables to find the posts voted by user 1465 and then identify the one with the highest score.",
    "sql": "SELECT p.Id \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE v.UserId = 1465 \nORDER BY p.Score DESC \nLIMIT 1;",
    "question": "Among the posts that were voted by user 1465, what is the id of the most valuable post?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T2.Id FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 1465 ORDER BY T2.FavoriteCount DESC LIMIT 1",
    "evidence": [
      "user 1465 refers to UserId = 1465; the most valuable post refers to MAX(FavoriteCount);"
    ]
  },
  "84": {
    "reason": "To find the two most common first names among school administrators and the districts they administer, we need to analyze the `schools` table. The table contains columns for administrator first names (`AdmFName1`, `AdmFName2`, `AdmFName3`) and the district (`District`). The steps are as follows:\n1. Combine all administrator first names from the three columns (`AdmFName1`, `AdmFName2`, `AdmFName3`) into a single list.\n2. Count the occurrences of each first name.\n3. Group the results by the first name and district to ensure we capture the district information.\n4. Order the results by the count in descending order to find the most common names.\n5. Limit the results to the top two most common names.",
    "sql": "WITH combined_names AS (\n  SELECT AdmFName1 AS first_name, District FROM schools WHERE AdmFName1 IS NOT NULL\n  UNION ALL\n  SELECT AdmFName2 AS first_name, District FROM schools WHERE AdmFName2 IS NOT NULL\n  UNION ALL\n  SELECT AdmFName3 AS first_name, District FROM schools WHERE AdmFName3 IS NOT NULL\n)\nSELECT first_name, District, COUNT(*) AS name_count\nFROM combined_names\nGROUP BY first_name, District\nORDER BY name_count DESC\nLIMIT 2;",
    "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
    "evidence": [
      ""
    ]
  },
  "357": {
    "reason": "To find the type of promotion for the card 'Duress', we need to query the `cards` table where the `name` is 'Duress' and retrieve the `promoTypes` column. The `promoTypes` column contains the promotion types associated with the card.",
    "sql": "SELECT promoTypes FROM cards WHERE name = 'Duress';",
    "question": "What type of promotion is of card 'Duress'?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL",
    "evidence": [
      "card Duress refers to name = 'Duress'; type of promotion refers to promoTypes;"
    ]
  },
  "1191": {
    "reason": "To solve the question, we need to calculate the percentage of male patients who first presented to the hospital in 1981 and were diagnosed with BEHCET. The steps are as follows:\n1. Identify male patients (SEX = 'M') who first presented in 1981 (YEAR(`First Date`) = '1981').\n2. From this subset, count how many were diagnosed with BEHCET (Diagnosis = 'BEHCET').\n3. Calculate the total number of male patients who first presented in 1981.\n4. Divide the count from step 2 by the total from step 3 and multiply by 100 to get the percentage.\n\nThe query will involve joining the `Patient` table with itself to filter the required conditions and then performing the calculations.",
    "sql": "SELECT \n    (SUM(CASE WHEN p.Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient p\nWHERE \n    p.SEX = 'M' AND \n    strftime('%Y', p.`First Date`) = '1981';",
    "question": "What percentage of male patients who first presented to the hospital in 1981 were diagnosed with BEHCET?",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE STRFTIME('%Y', `First Date`) = '1981' AND SEX = 'M'",
    "evidence": [
      "male refers to SEX = 'M'; first presented to the hospital in 1981 refers to YEAR(`FIRST DATE`) = '1981'; BEHCET refers to diagnosis; calculation = DIVIDE(SUM(DIAGNOSIS = 'BEHCET') where YEAR(`FIRST DATE`) = '1981', MULTIPLY(COUNT(YEAR(`FIRST DATE`) = '1981')), 100)"
    ]
  },
  "1043": {
    "reason": "To find the short name of the football team Queens Park Rangers, we need to query the `Team` table where the `team_long_name` is 'Queens Park Rangers'. The `team_short_name` column in the `Team` table will give us the desired short name.",
    "sql": "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers';",
    "question": "What is the short name of the football team Queens Park Rangers?",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers'",
    "evidence": [
      "short name of the football team refers to team_short_name; Queens Park Rangers refers to team_long_name = 'Queens Park Rangers';"
    ]
  },
  "1406": {
    "reason": "To solve the question, we need to find the budget with the highest amount allocated for the 'Food' category. The schema includes a `budget` table with columns `category` and `amount`. The tip provided suggests using `MAX(amount)` where the `category` is 'Food'. Therefore, the query should filter budgets by the 'Food' category and then select the one with the maximum amount.",
    "sql": "SELECT * FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food');",
    "question": "Among the budgets for Food, which one has the highest budgeted amount?",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget )",
    "evidence": [
      "MAX(amount) where category = 'Food'"
    ]
  },
  "727": {
    "reason": "To find the publisher of Sauron, we need to follow these steps:\n1. Identify the superhero record for Sauron in the `superhero` table.\n2. Retrieve the `publisher_id` associated with Sauron's record.\n3. Join the `superhero` table with the `publisher` table to get the publisher's name using the `publisher_id`.\n\nThe query will filter the `superhero` table for the superhero_name 'Sauron' and then join it with the `publisher` table to fetch the publisher's name.",
    "sql": "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Sauron';",
    "question": "Who is the publisher of Sauron?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Sauron'",
    "evidence": [
      "the publisher refers to publisher_name; Sauron refers to superhero_name = 'Sauron'"
    ]
  },
  "476": {
    "reason": "To solve the question, we need to find the names of the cards in the set 'Coldsnap' with the highest converted mana cost. Here's the step-by-step reasoning:\n\n1. **Identify the set 'Coldsnap'**: The set is referenced by its name, so we need to find the set code for 'Coldsnap' from the `sets` table.\n2. **Filter cards by the set 'Coldsnap'**: Using the set code obtained, we can filter the cards in the `cards` table that belong to this set.\n3. **Find the highest converted mana cost**: Among the filtered cards, we need to determine the maximum value of the `convertedManaCost` column.\n4. **Retrieve the names of cards with the highest converted mana cost**: Finally, we will select the names of the cards that have this maximum converted mana cost.\n\nThis involves joining the `cards` table with the `sets` table (or using the `setCode` column in `cards` if it exists) and then applying the necessary filtering and aggregation.",
    "sql": "WITH ColdsnapCards AS (\n    SELECT c.name, c.convertedManaCost\n    FROM cards c\n    JOIN sets s ON c.setCode = s.code\n    WHERE s.name = 'Coldsnap'\n),\nMaxManaCost AS (\n    SELECT MAX(convertedManaCost) AS maxCost\n    FROM ColdsnapCards\n)\nSELECT name\nFROM ColdsnapCards\nWHERE convertedManaCost = (SELECT maxCost FROM MaxManaCost);",
    "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
    "evidence": [
      "card set Coldsnap refers to name = 'Coldsnap'"
    ]
  },
  "681": {
    "reason": "To solve the question, we need to find users whose posts had over 20,000 views in the year 2011. The steps are as follows:\n1. Identify the relevant tables: `users` (for display names) and `posts` (for views and creation dates).\n2. Filter posts from the year 2011 with more than 20,000 views.\n3. Join these posts with the `users` table to get the display names of the users who created these posts.\n4. Ensure the query is structured to return only the display names of these users.",
    "sql": "SELECT DISTINCT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ViewCount > 20000\nAND strftime('%Y', p.CreaionDate) = '2011';",
    "question": "Please list the users' display names whose posts had over 20000 views in 2011.",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2011' AND T2.ViewCount > 20000",
    "evidence": [
      "had over 20000 views in 2011 refers to ViewCount > 20000 where YEAR(CreationDate) = 2011;"
    ]
  },
  "1176": {
    "reason": "To find the anti-nucleus antibody (ANA) concentration level for the patient with ID 3605340 on the date 1996/12/2, we need to query the `Examination` table. The `Examination` table contains the `ANA` column, which stores the ANA concentration level. We will filter the records by the patient ID and the examination date to get the specific result.",
    "sql": "SELECT `ANA` FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02';",
    "question": "What was the anti-nucleus antibody concentration level for the patient id 3605340 on 1996/12/2?",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT ANA FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02'",
    "evidence": [
      "anti-nucleus antibody refers to ANA; 1996/12/2 refers to `Examination Date` = '1996-12-02'"
    ]
  },
  "483": {
    "reason": "To solve the question, we need to find the Italian text rulings of all cards in the set 'Coldsnap'. Here's the step-by-step reasoning:\n\n1. **Identify the set 'Coldsnap'**: The set 'Coldsnap' is referenced by its name in the `sets` table. We need to find the `code` of the set 'Coldsnap' from the `sets` table.\n\n2. **Find cards in the 'Coldsnap' set**: Using the `setCode` from the `sets` table, we can find all cards in the 'Coldsnap' set by joining the `cards` table with the `sets` table on the `setCode` field.\n\n3. **Retrieve Italian rulings for these cards**: The `rulings` table contains the rulings for each card, but it does not directly include the language. However, the `foreign_data` table contains translations, including Italian text. We need to join the `cards` table with the `foreign_data` table to get the Italian text rulings.\n\n4. **Filter for Italian language**: In the `foreign_data` table, we filter for rows where the `language` is 'Italian'.\n\n5. **Combine the results**: Finally, we join all these tables to get the Italian text rulings for all cards in the 'Coldsnap' set.",
    "sql": "SELECT c.name AS card_name, fd.text AS italian_ruling_text\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE s.name = 'Coldsnap' AND fd.language = 'Italian';",
    "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
    "evidence": [
      "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'"
    ]
  },
  "1155": {
    "reason": "To solve the question, we need to find patients whose LDH (Lactate Dehydrogenase) levels are beyond the normal range (LDH > 500). The relevant data is stored in the `Laboratory` table, which includes the `ID` of the patient and the `LDH` value. We also need to retrieve the patient's `SEX` and `Birthday` from the `Patient` table. The steps are as follows:\n\n1. Join the `Laboratory` table with the `Patient` table on the `ID` field to link the LDH data with the patient's personal details.\n2. Filter the records where `LDH` is greater than 500.\n3. Select the required fields: `ID`, `SEX`, and `Birthday` from the `Patient` table.",
    "sql": "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.LDH > 500;",
    "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
    "evidence": [
      "LDH beyond normal range refers to LDH > '500';"
    ]
  },
  "892": {
    "reason": "To find the driver with the most points scored and their full name, we need to:\n1. Identify the driver who has the highest total points from the `driverStandings` table.\n2. Join the `driverStandings` table with the `drivers` table to get the full name (forename and surname) of the driver.\n3. Use the `MAX` function on the `points` column to determine the highest points scored.\n4. Group the results by driverId to ensure we aggregate points correctly.\n5. Order the results by points in descending order and limit to the top result to get the driver with the most points.",
    "sql": "SELECT d.forename || ' ' || d.surname AS full_name, MAX(ds.points) AS max_points\nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nGROUP BY ds.driverId\nORDER BY max_points DESC\nLIMIT 1;",
    "question": "State the driver with the most points scored. Find his full name with that points.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
    "evidence": [
      "the most points scored refers to max(points); Full name of the driver refers to drivers.forename and drivers.surname;"
    ]
  },
  "995": {
    "reason": "To find the average score of Lewis Hamilton in all Turkish Grand Prix races, we need to follow these steps:\n1. Identify Lewis Hamilton's driverId from the drivers table using his name (forename and surname).\n2. Identify all Turkish Grand Prix races from the races table using the race name.\n3. Join the results table with the races table to filter results for Turkish Grand Prix races.\n4. Filter the results further to include only Lewis Hamilton's entries.\n5. Calculate the average of the points he scored in these races using the AVG function.",
    "sql": "SELECT AVG(r.points) AS average_score\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.name LIKE '%Turkish Grand Prix%'\nAND d.forename = 'Lewis' AND d.surname = 'Hamilton';",
    "question": "What is the average score of Lewis Hamilton among all the Turkish Grand Prix?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T3.name = 'Turkish Grand Prix'",
    "evidence": [
      "Average score = AVG(points)"
    ]
  },
  "859": {
    "reason": "To find Bruno Senna's Q1 result in the qualifying race No. 354, we need to follow these steps:\n1. Identify Bruno Senna's driverId from the drivers table using his surname 'Senna' and forename 'Bruno'.\n2. Use the qualifying table to find the Q1 result for the driverId identified in step 1 and the raceId 354.",
    "sql": "SELECT q.q1\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE d.forename = 'Bruno' AND d.surname = 'Senna' AND q.raceId = 354;",
    "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
    "evidence": [
      "race number refers to raceId; Bruno Senna refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;"
    ]
  },
  "550": {
    "reason": "To solve the question, we need to find the most popular tag and then determine the post from which this tag's excerpt is taken. The steps are as follows:\n1. Identify the most popular tag by finding the tag with the highest count in the `tags` table.\n2. Once the most popular tag is identified, use its `ExcerptPostId` to find the corresponding post in the `posts` table.\n3. Retrieve the body of the post using the `ExcerptPostId`.",
    "sql": "SELECT p.Body \nFROM posts p \nJOIN tags t ON p.Id = t.ExcerptPostId \nWHERE t.Count = (SELECT MAX(Count) FROM tags);",
    "question": "From which post is the most popular tag excerpted from? Please give the body of the post.",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT Body FROM posts WHERE id = ( SELECT ExcerptPostId FROM tags ORDER BY Count DESC LIMIT 1 )",
    "evidence": [
      "most popular tag refers to Max(Count); excerpt from refer to ExcerptPostId"
    ]
  },
  "801": {
    "reason": "To find the ratio between male and female superheroes, we need to:\n1. Count the number of male superheroes by filtering the `superhero` table where `gender_id` corresponds to 'Male' in the `gender` table.\n2. Count the number of female superheroes similarly by filtering for 'Female'.\n3. Calculate the ratio of male to female superheroes by dividing the count of male superheroes by the count of female superheroes.\n4. Ensure we join the `superhero` table with the `gender` table to map the `gender_id` to the actual gender names.",
    "sql": "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Male')) * 1.0 /\n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female')) AS male_to_female_ratio;",
    "question": "Find the ratio between male superheroes and female superheroes.",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id",
    "evidence": [
      "ratio = DIVIDE(SUM(gender_id = 1) / SUM(gender_id = 2)); male superheroes refers to gender = 'Female'; female superheroes refers to gender = 'Male';"
    ]
  },
  "212": {
    "reason": "To solve the question, we need to find the element that is the least numerous in non-carcinogenic molecules. Here's the step-by-step reasoning:\n\n1. Identify non-carcinogenic molecules: These are molecules where the `label` is '-'. We can filter the `molecule` table for this condition.\n2. Join the `molecule` table with the `atom` table to get all atoms in these non-carcinogenic molecules.\n3. Group the results by the `element` column to count how many times each element appears in these molecules.\n4. Find the element with the minimum count, which is the least numerous element.\n\nThe query will involve filtering, joining, grouping, and aggregating the data to find the desired result.",
    "sql": "SELECT a.element, COUNT(a.element) AS element_count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '-'\nGROUP BY a.element\nORDER BY element_count ASC\nLIMIT 1;",
    "question": "Which element is the least numerous in non-carcinogenic molecules?",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
    "evidence": [
      "label = '-' means molecules are non-carcinogenic; least numerous refers to MIN(COUNT(element));"
    ]
  },
  "154": {
    "reason": "To find the number of male clients in the 'Hl.m. Praha' district, we need to:\n1. Identify the district_id for 'Hl.m. Praha' from the district table.\n2. Use this district_id to filter clients in the client table who are male (gender = 'M').\n3. Count the number of such clients.",
    "sql": "SELECT COUNT(*) \nFROM client \nWHERE gender = 'M' AND district_id = (SELECT district_id FROM district WHERE A2 = 'Hl.m. Praha');",
    "question": "How many male clients in 'Hl.m. Praha' district?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'",
    "evidence": [
      "District data appears in the A2; Male means that gender = 'M'"
    ]
  },
  "1258": {
    "reason": "To solve the question, we need to find the number of distinct patients who meet two conditions:\n1. They have a normal Rheumatoid Factor (RA in ('-', '+-')).\n2. They have a positive measure of degree of coagulation (KCT = '+').\n\nWe will join the `Patient` table with the `Examination` table to check these conditions. The `Examination` table contains the `KCT` field for coagulation and the `Laboratory` table contains the `RA` field for Rheumatoid Factor. However, since the `RA` field is in the `Laboratory` table, we need to ensure we are checking the correct records for each patient.\n\nThe steps are:\n1. Join the `Patient` table with the `Examination` table to filter patients with KCT = '+'.\n2. Join the result with the `Laboratory` table to filter patients with RA in ('-', '+-').\n3. Count the distinct patient IDs that satisfy both conditions.",
    "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nJOIN Laboratory L ON P.ID = L.ID\nWHERE E.KCT = '+' AND L.RA IN ('-', '+-');",
    "question": "How many patients with a normal Rhuematoid Factor has a positive measure of degree of coagulation?",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T3.KCT = '+'",
    "evidence": [
      "normal Rhuematoid Factor refers TO RA IN('-', '+-'); positive measure of degree of coagulation refers to KCT = '+'; Should compute the number of distinct ones"
    ]
  },
  "708": {
    "reason": "To solve the question, we need to find the creation date and age of users who have commented with a website. The comments table contains the text of comments, and the users table contains the creation date and age of users. We need to join these tables to get the required information. The tip mentions that a website is indicated by the presence of 'http://' in the comment text. Therefore, we will filter comments that contain 'http://' and then join with the users table to retrieve the creation date and age of those users.",
    "sql": "SELECT u.CreationDate, u.Age\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text LIKE '%http://%';",
    "question": "List the creation date and age of the user that commented with webiste.",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT T2.CreationDate, T2.Age FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.text LIKE '%http://%'",
    "evidence": [
      "commented with webiste refers to the value contains 'http://'"
    ]
  },
  "1511": {
    "reason": "To solve the question, we need to find the average total price of transactions for customers who paid in euros. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `customers` table contains information about the currency used by each customer, and the `transactions_1k` table contains the transaction details, including the price.\n\n2. **Filter customers by currency**: We need to filter customers who paid in euros (Currency = 'EUR').\n\n3. **Join the tables**: Join the `customers` table with the `transactions_1k` table on the `CustomerID` field to get the transactions for these customers.\n\n4. **Calculate the total price**: For each transaction, the total price can be calculated as `Amount * Price`.\n\n5. **Compute the average**: Finally, compute the average of these total prices for all transactions by customers who paid in euros.",
    "sql": "SELECT AVG(Amount * Price) AS AverageTotalPrice\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE c.Currency = 'EUR';",
    "question": "For the customers who paid in the euro, what is their average total price of the transactions?",
    "db_id": "debit_card_specializing",
    "res": 0,
    "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Currency = 'EUR'",
    "evidence": [
      ""
    ]
  },
  "304": {
    "reason": "To list all carcinogenic molecules and their elements, we need to:\n1. Identify molecules labeled as '+' (carcinogenic) from the `molecule` table.\n2. Join the `molecule` table with the `atom` table to get the elements of each atom in these molecules.\n3. Group the results by molecule and element to avoid duplicates.\n\nThe query will involve:\n- Selecting the `molecule_id` and `label` from the `molecule` table where `label` is '+'.\n- Joining with the `atom` table to get the `element` for each atom in these molecules.\n- Grouping by `molecule_id` and `element` to ensure each element is listed once per molecule.",
    "sql": "SELECT m.molecule_id, m.label, a.element\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+'\nGROUP BY m.molecule_id, a.element;",
    "question": "List all carcinogenic molecules and their elements.",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
    "evidence": [
      "label = '+' mean molecules are carcinogenic; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
    ]
  },
  "1230": {
    "reason": "To solve the question, we need to list all outpatient patients (where Admission = '-') who have a normal range of creatinine phosphokinase (CPK < 250). The query should return distinct patient IDs. We will join the Patient and Laboratory tables to filter out the required records. The steps are:\n1. Join the Patient and Laboratory tables on the ID field.\n2. Filter records where Admission = '-' (outpatient) and CPK < 250 (normal range).\n3. Select distinct IDs from the filtered records.",
    "sql": "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Admission = '-' AND l.CPK < 250;",
    "question": "List all outpatient within normal range of creatinine phosphokinase. Give me the distinct ids.",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CPK < 250 AND T1.Admission = '-'",
    "evidence": [
      "outpatient refers to Admission = '-'; normal range of creatinine phosphokinase refers to CPK < 250;"
    ]
  },
  "321": {
    "reason": "To find the molecule of the atoms with IDs \"TR000_2\" and \"TR000_4\", we need to follow these steps:\n1. Identify the `molecule_id` for each atom from the `atom` table.\n2. Ensure that both atoms belong to the same molecule by comparing their `molecule_id` values.\n3. Retrieve the molecule details (e.g., `label`) from the `molecule` table using the common `molecule_id`.\n\nThe query will join the `atom` table with the `molecule` table to fetch the required information.",
    "sql": "SELECT m.molecule_id, m.label\nFROM atom a1\nJOIN atom a2 ON a1.molecule_id = a2.molecule_id\nJOIN molecule m ON a1.molecule_id = m.molecule_id\nWHERE a1.atom_id = 'TR000_2' AND a2.atom_id = 'TR000_4';",
    "question": "What is the molecule of atom id \"TR000_2\" and atom id 2 \"TR000_4\"?",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'",
    "evidence": [
      ""
    ]
  },
  "492": {
    "reason": "To find the expansion type of the set \"From the Vault: Lore\", we need to query the `sets` table. The `sets` table contains a column named `type` which stores the expansion type of each set. We will filter the records in the `sets` table where the `name` column matches \"From the Vault: Lore\" and then retrieve the `type` column for that set.",
    "sql": "SELECT type FROM sets WHERE name = 'From the Vault: Lore';",
    "question": "For the set \"From the Vault: Lore\", what is its expansion type?",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT type FROM sets WHERE name LIKE '%FROM the Vault: Lore%'",
    "evidence": [
      "set \"From the Vault refers to name which contains 'From the Vault: Lore'; expansion type refers to type"
    ]
  },
  "145": {
    "reason": "To solve the question, we need to identify account holders whose transactions on the credit card (Operation = 'VYBER KARTOU') have an amount less than the average transaction amount in 1998. Here's the step-by-step reasoning:\n\n1. **Filter Transactions**: First, we need to filter transactions from the `trans` table where the operation is 'VYBER KARTOU' (credit card withdrawal) and the date is in 1998.\n2. **Calculate Average Amount**: Next, we calculate the average amount of these filtered transactions.\n3. **Filter Transactions Below Average**: Then, we filter transactions where the amount is less than the calculated average.\n4. **Join with Account Holders**: Finally, we join these transactions with the `disp` table to get the account holder's client ID, and then with the `client` table to get the client's identification number.\n\nThis will give us the list of account holder identification numbers who meet the criteria.",
    "sql": "WITH credit_card_transactions AS (\n    SELECT account_id, amount\n    FROM trans\n    WHERE operation = 'VYBER KARTOU'\n    AND strftime('%Y', date) = '1998'\n),\naverage_amount AS (\n    SELECT AVG(amount) AS avg_amount\n    FROM credit_card_transactions\n)\nSELECT DISTINCT c.client_id\nFROM credit_card_transactions cct\nJOIN disp d ON cct.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE cct.amount < (SELECT avg_amount FROM average_amount);",
    "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
    "db_id": "financial",
    "res": 0,
    "ground_truth": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
    "evidence": [
      "Operation = 'VYBER KARTOU' refers to credit card withdrawal"
    ]
  },
  "1001": {
    "reason": "To solve the question, we need to find the full name of the racer who ranked 1st in the 3rd qualifying race (Q3) held in the Marina Bay Street Circuit in 2008. Here's the step-by-step reasoning:\n\n1. **Identify the Marina Bay Street Circuit**: First, we need to find the `circuitId` for the Marina Bay Street Circuit from the `circuits` table.\n2. **Find the race in 2008 at this circuit**: Using the `circuitId` from step 1, we query the `races` table to find the `raceId` for the race held in 2008 at this circuit.\n3. **Retrieve qualifying results for Q3**: Using the `raceId` from step 2, we query the `qualifying` table to find the driver who ranked 1st in Q3 (minimum `q3` time).\n4. **Get the driver's full name**: Using the `driverId` from step 3, we query the `drivers` table to get the full name (concatenation of `forename` and `surname`).",
    "sql": "SELECT d.forename || ' ' || d.surname AS full_name\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nJOIN races r ON q.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Marina Bay Street Circuit'\n  AND r.year = 2008\n  AND q.position = 1\n  AND q.q3 IS NOT NULL\nORDER BY q.q3 ASC\nLIMIT 1;",
    "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
    "evidence": [
      "Ranked 1st in the 3rd qualifying race refer to MIN(q3); 2008 is the year of race; full name of racer = forename, surname"
    ]
  },
  "721": {
    "reason": "To find the number of superheroes with blue eyes, we need to:\n1. Identify the `colour` record where `colour` is 'Blue' to get its `id`.\n2. Use this `id` to filter superheroes in the `superhero` table where `eye_colour_id` matches the `id` of the 'Blue' colour.\n3. Count the number of such superheroes.",
    "sql": "SELECT COUNT(*) AS blue_eyed_superheroes\nFROM superhero\nWHERE eye_colour_id = (SELECT id FROM colour WHERE colour = 'Blue');",
    "question": "How many superheroes have blue eyes?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue'",
    "evidence": [
      "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id;"
    ]
  },
  "351": {
    "reason": "To find all cards that have alternative language data in Japanese, we need to query the `foreign_data` table where the `language` column is 'Japanese'. Since the `foreign_data` table references the `cards` table via the `uuid` column, we can join these two tables to get the card names. The query will select the `name` column from the `cards` table where there is a matching entry in the `foreign_data` table with `language` set to 'Japanese'.",
    "sql": "SELECT DISTINCT c.name FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Japanese';",
    "question": "Name all the cards which have alternative language in Japanese.",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'",
    "evidence": [
      "Japanese' is the language;"
    ]
  },
  "217": {
    "reason": "To identify all the atoms connected to the atoms of the TR181 molecule, we need to follow these steps:\n1. First, find all the atoms that belong to the TR181 molecule by querying the `atom` table where `molecule_id` is 'TR181'.\n2. Then, use the `connected` table to find all connections involving these atoms. This includes both cases where the TR181 atom is `atom_id` or `atom_id2` in the `connected` table.\n3. Finally, retrieve the details of these connected atoms from the `atom` table.",
    "sql": "SELECT DISTINCT a2.*\nFROM atom a1\nJOIN connected c ON a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2\nJOIN atom a2 ON (a2.atom_id = c.atom_id OR a2.atom_id = c.atom_id2) AND a2.atom_id != a1.atom_id\nWHERE a1.molecule_id = 'TR181';",
    "question": "Identify all the atoms that are connected to the atoms of the TR181 molecule.",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T1.molecule_id = 'TR181'",
    "evidence": [
      "TR181 molecule refers to molecule_id = 'TR181'"
    ]
  },
  "143": {
    "reason": "To find accounts that have gold credit cards, we need to follow these steps:\n1. Identify the `card` table to find all cards of type 'gold'.\n2. Join the `card` table with the `disp` table to link the card to its associated account via the `disp_id`.\n3. Finally, select the `account_id` from the `disp` table to get the accounts associated with gold credit cards.",
    "sql": "SELECT DISTINCT d.account_id\nFROM card c\nJOIN disp d ON c.disp_id = d.disp_id\nWHERE c.type = 'gold';",
    "question": "What are the accounts that have gold credit cards?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T2.account_id FROM disp AS T2  INNER JOIN card AS T1 ON T1.disp_id = T2.disp_id  WHERE T1.type = 'gold'",
    "evidence": [
      ""
    ]
  },
  "932": {
    "reason": "To find the years in which Lewis Hamilton participated in Formula 1 races, we need to follow these steps:\n1. Identify Lewis Hamilton's driverId from the drivers table using his name (forename and surname).\n2. Use the driverId to find all races he participated in from the results table.\n3. Extract the unique years from the races table based on the raceIds found in the results table.\n4. Return the list of distinct years.",
    "sql": "SELECT DISTINCT r.year\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';\n",
    "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
    "evidence": [
      ""
    ]
  },
  "487": {
    "reason": "To solve the question, we need to find the percentage of incredibly powerful cards in the set 'Coldsnap'. According to the tips provided, a card is considered incredibly powerful if it has both `cardKingdomFoilId` and `cardKingdomId` not null. The percentage is calculated by dividing the number of incredibly powerful cards by the total number of cards in the 'Coldsnap' set, then multiplying by 100.\n\n1. First, we need to count the total number of cards in the 'Coldsnap' set. This can be done by filtering the `cards` table where the `setCode` is 'Coldsnap'.\n2. Next, we count the number of incredibly powerful cards in the 'Coldsnap' set by filtering the `cards` table where `setCode` is 'Coldsnap' and both `cardKingdomFoilId` and `cardKingdomId` are not null.\n3. Finally, we calculate the percentage by dividing the count of incredibly powerful cards by the total count of cards in 'Coldsnap' and multiplying by 100.",
    "sql": "SELECT \n    (COUNT(CASE WHEN cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 END) * 100.0 / \n    COUNT(*)) AS percentage_incredibly_powerful\nFROM \n    cards\nWHERE \n    setCode = 'Coldsnap';",
    "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
    "db_id": "card_games",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
    "evidence": [
      "card set Coldsnap refers to name = 'Coldsnap'; foil is incredibly powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null; the percentage of incredibly powerful cards in the set refers to DIVIDE(SUM(incredibly powerful), SUM(name = 'Coldsnap'))*100"
    ]
  },
  "867": {
    "reason": "To solve the question, we need to find the driver who set the fastest lap speed in race No. 933 and then determine their nationality. Here's the step-by-step reasoning:\n\n1. **Identify the driver with the fastest lap speed in race No. 933**:\n   - The `results` table contains information about race results, including the `fastestLapSpeed` and `raceId`.\n   - We need to filter the `results` table for `raceId = 933` and find the row with the highest `fastestLapSpeed`.\n\n2. **Retrieve the driver's nationality**:\n   - Once we have the `driverId` of the driver with the fastest lap speed, we can join the `drivers` table to get their nationality (`nationality` field).\n\n3. **Combine the queries**:\n   - Use a subquery or a join to link the `results` and `drivers` tables based on the `driverId`.\n   - The final query will return the nationality of the driver who set the fastest lap speed in race No. 933.",
    "sql": "SELECT d.nationality\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE r.raceId = 933\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;",
    "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
    "evidence": [
      "fastest lap speed refers to MAX(fastestLapSpeed);"
    ]
  },
  "1473": {
    "reason": "To find the average monthly consumption of customers in the SME segment for the year 2013, we need to follow these steps:\n1. Identify customers in the SME segment from the `customers` table.\n2. Filter the `yearmonth` table for records where the `Date` falls within the year 2013 (i.e., the first 4 characters of `Date` are '2013').\n3. Calculate the average consumption for these customers over the filtered period.\n4. Divide the average consumption by 12 to get the average monthly consumption.\n\nThe query will join the `customers` and `yearmonth` tables, filter for SME customers and the year 2013, and then compute the required average.",
    "sql": "SELECT AVG(Consumption) / 12 AS AverageMonthlyConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Segment = 'SME' AND SUBSTR(ym.Date, 1, 4) = '2013';",
    "question": "What was the average monthly consumption of customers in SME for the year 2013?",
    "db_id": "debit_card_specializing",
    "res": 1,
    "ground_truth": "SELECT AVG(T2.Consumption) / 12 FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME'",
    "evidence": [
      "Average Monthly consumption = AVG(Consumption) / 12; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year."
    ]
  },
  "1063": {
    "reason": "To find Aaron Doran's potential score, we need to follow these steps:\n1. Identify the `player_api_id` for Aaron Doran from the `Player` table.\n2. Use this `player_api_id` to query the `Player_Attributes` table for the `potential` score.\n3. The query will join the `Player` and `Player_Attributes` tables to retrieve the required information.",
    "sql": "SELECT p.player_name, pa.potential\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Aaron Doran';",
    "question": "What is Aaron Doran's potential score?",
    "db_id": "european_football_2",
    "res": 0,
    "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
    "evidence": [
      "potential score refers to potential;"
    ]
  },
  "1364": {
    "reason": "To find Amy Firth's hometown, we need to determine the city, county, and state associated with her zip code. The steps are as follows:\n1. Locate Amy Firth in the `member` table using her first and last name.\n2. Retrieve her zip code from the `member` table.\n3. Use the zip code to query the `zip_code` table for the corresponding city, county, and state.\n4. Combine these details to form her hometown.",
    "sql": "SELECT z.city, z.county, z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Amy' AND m.last_name = 'Firth';",
    "question": "Where is Amy Firth's hometown?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T2.city, T2.county, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Amy' AND T1.last_name = 'Firth'",
    "evidence": [
      "hometown refers to city, county, state"
    ]
  },
  "1412": {
    "reason": "To solve the question, we need to find the types of expenses incurred by members who wear an X-Large t-shirt size. The steps are as follows:\n1. Identify members with `t_shirt_size = 'X-Large'` from the `member` table.\n2. Link these members to their expenses in the `expense` table using the `link_to_member` field.\n3. Retrieve the `expense_description` from the `expense` table for these members.\n4. Ensure the query joins the `member` and `expense` tables correctly to filter and fetch the required data.",
    "sql": "SELECT DISTINCT e.expense_description\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE m.t_shirt_size = 'X-Large';",
    "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
    "evidence": [
      "kind of expenses refers to expense_description; t_shirt_size = 'X-Large'"
    ]
  },
  "105": {
    "reason": "To solve the question, we need to find the district ID of the branch where an account was opened, given that a loan was approved on 1994/8/25. The steps are as follows:\n1. Identify the loan record with the date '1994-08-25' in the `loan` table.\n2. From the loan record, get the `account_id` associated with the loan.\n3. Use the `account_id` to find the corresponding account in the `account` table.\n4. From the account record, retrieve the `district_id` which indicates where the account was opened.\n5. Return the `district_id` as the result.",
    "sql": "SELECT a.district_id\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.date = '1994-08-25';",
    "question": "There was a loan approved in 1994/8/25, where was that account opened, give the district Id of the branch.",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'",
    "evidence": [
      ""
    ]
  },
  "609": {
    "reason": "To solve the question, we need to count the number of posts that have a score of 10. The `posts` table contains the `Score` column, which stores the score of each post. We will query the `posts` table and count the rows where the `Score` column equals 10.",
    "sql": "SELECT COUNT(*) FROM posts WHERE Score = 10;",
    "question": "How many posts have a score of 10 on the list?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score = 10",
    "evidence": [
      "score of 10 refers to Score = 10; post refers to Id"
    ]
  },
  "1460": {
    "reason": "To solve the question, we need to find the full name of the member who spent money on items described as 'Water, Veggie tray, supplies' and include the cost of these expenses. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The question involves the `member` table (for member details like first and last name), the `expense` table (for expense details like description and cost), and the `budget` table (to link expenses to events if needed).\n\n2. **Filter expenses**: We need to filter the `expense` table for entries where the `expense_description` matches 'Water, Veggie tray, supplies'.\n\n3. **Join tables**: Join the `expense` table with the `member` table to get the member's full name (first_name and last_name) and the cost of the expense.\n\n4. **Select the required fields**: The query should return the concatenated full name (first_name and last_name) and the cost from the filtered expenses.\n\n5. **Ensure the query is valid**: The query should correctly join the tables and filter the data as specified.",
    "sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, e.cost\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.expense_description = 'Water, Veggie tray, supplies';",
    "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT T2.first_name, T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
    "evidence": [
      "full name refers to first_name, last name; spent money for refers expense description; expense_description = 'Water, Veggie tray, supplies'"
    ]
  },
  "1358": {
    "reason": "To find the first member who paid their dues, we need to look at the `income` table, which records payments received from members. The `income` table includes a `date_received` field, which we can use to determine the earliest payment. We will join the `income` table with the `member` table to get the full name of the member who made the earliest payment. The query will order the results by `date_received` in ascending order and limit the result to the first record.",
    "sql": "SELECT m.first_name, m.last_name\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nORDER BY i.date_received ASC\nLIMIT 1;",
    "question": "Who was the first one paid his/her dues? Tell the full name.",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.source = 'Dues' ORDER BY T2.date_received LIMIT 1",
    "evidence": [
      "full name refers to first_name, last_name; first paid dues refers to MIN(received_date) where source = 'Dues'"
    ]
  },
  "954": {
    "reason": "To calculate the race completion percentage of Japanese drivers from 2007 to 2009, we need to follow these steps:\n1. Identify all Japanese drivers from the `drivers` table where `nationality` is 'Japanese'.\n2. Find all races from 2007 to 2009 in the `races` table.\n3. Join the `results` table with the filtered `drivers` and `races` to get the results for Japanese drivers in the specified years.\n4. Count the total number of races completed by Japanese drivers (where `time` is not null) and the total number of races they participated in.\n5. Calculate the percentage by dividing the completed races by the total races and multiplying by 100.\n\nThe query will involve joins between `drivers`, `races`, and `results` tables, and filtering based on nationality and year range.",
    "sql": "SELECT \n    (COUNT(CASE WHEN r.time IS NOT NULL THEN 1 END) * 100.0 / COUNT(*)) AS race_completion_percentage\nFROM \n    results r\nJOIN \n    drivers d ON r.driverId = d.driverId\nJOIN \n    races rc ON r.raceId = rc.raceId\nWHERE \n    d.nationality = 'Japanese'\n    AND rc.year BETWEEN 2007 AND 2009;",
    "question": "Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.raceId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009",
    "evidence": [
      "from 2007 to 2009 refers to year between 2007 and 2009; race completion refers to time is not null; percentage = Divide(COUNT(DriverID where time is not null and year between 2007 and 2009),Count (DriverID where year between 2007 and 2009))*100; "
    ]
  },
  "596": {
    "reason": "To solve the question, we need to find the users who have posted the most comments and then list their badges. Here's the step-by-step reasoning:\n\n1. **Identify users with the most comments**: We need to count the number of comments each user has made by grouping the `comments` table by `UserId` and counting the `Id` of comments. Then, we can order the results in descending order to find the top users.\n\n2. **Retrieve user badges**: Once we have the top users, we need to join the results with the `badges` table to fetch the badges associated with these users.\n\n3. **Combine the results**: The final query will involve joining the `comments` table with the `badges` table on the `UserId` field to get the required information.",
    "sql": "SELECT u.Id, u.DisplayName, COUNT(c.Id) AS CommentCount, b.Name AS BadgeName\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nLEFT JOIN badges b ON u.Id = b.UserId\nGROUP BY u.Id, u.DisplayName\nORDER BY CommentCount DESC\nLIMIT 10;",
    "question": "Which users have posted the most comments. List out the user's badge?",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT Name FROM badges AS T1 INNER JOIN comments AS T2 ON T1.UserId = t2.UserId GROUP BY T2.UserId ORDER BY COUNT(T2.UserId) DESC LIMIT 1",
    "evidence": [
      "user with the most comments refers to UserId where Max(Count(Id)"
    ]
  },
  "588": {
    "reason": "To find the total number of comments posted by user ID 13, we need to query the `comments` table where the `UserId` column matches 13. The `COUNT` function will be used to count the number of such records.",
    "sql": "SELECT COUNT(*) AS TotalComments FROM comments WHERE UserId = 13;",
    "question": "Give the total number of comments posted by user ID 13.",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13",
    "evidence": [
      ""
    ]
  },
  "594": {
    "reason": "To find the user who created post ID 1 and their reputation, we need to follow these steps:\n1. Identify the `OwnerUserId` of post ID 1 from the `posts` table.\n2. Use this `OwnerUserId` to query the `users` table to retrieve the user's `DisplayName` and `Reputation`.",
    "sql": "SELECT u.DisplayName, u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Id = 1;",
    "question": "Which user created post ID 1 and what is the reputation of this user?",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT T2.Id, T2.Reputation FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.PostId = 1",
    "evidence": [
      ""
    ]
  },
  "1223": {
    "reason": "To determine whether there are more male patients with creatinine (CRE) levels not within the normal range (CRE >= 1.5) than female patients, we need to:\n1. Filter the `Laboratory` table for records where CRE >= 1.5.\n2. Join these records with the `Patient` table to get the sex of each patient.\n3. Count the number of male (SEX = 'M') and female (SEX = 'F') patients in the filtered records.\n4. Compare the counts to determine if there are more males than females.\n\nThe query will return 'True' if the count of males is greater than the count of females, otherwise 'False'.",
    "sql": "SELECT \n    (SELECT COUNT(DISTINCT P.ID) \n     FROM Patient P \n     JOIN Laboratory L ON P.ID = L.ID \n     WHERE L.CRE >= 1.5 AND P.SEX = 'M') > \n    (SELECT COUNT(DISTINCT P.ID) \n     FROM Patient P \n     JOIN Laboratory L ON P.ID = L.ID \n     WHERE L.CRE >= 1.5 AND P.SEX = 'F') AS result;",
    "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
    "evidence": [
      "creatinine (CRE) not within the normal range refers to CRE > = 1.5; male refers to Sex = 'M'; female refers to Sex = 'F'; calculation = (SUM(SEX = 'M') > SUM(SEX = 'F')) where CRE > = 1.5"
    ]
  },
  "1122": {
    "reason": "To find the name of the strongest player, we need to identify the player with the highest `overall_rating` in the `Player_Attributes` table. This involves joining the `Player_Attributes` table with the `Player` table to get the player's name. The steps are:\n1. Find the maximum `overall_rating` in the `Player_Attributes` table.\n2. Join the `Player_Attributes` table with the `Player` table to match the player's ID with their name.\n3. Filter the results to only include the player(s) with the maximum `overall_rating`.\n4. Retrieve the player's name.",
    "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);",
    "question": "State the name of the most strongest player.",
    "db_id": "european_football_2",
    "res": 1,
    "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)",
    "evidence": [
      "strongest players refers to player has MAX(overall_rating)"
    ]
  },
  "1000": {
    "reason": "To find the racetrack that hosted the most recent race, we need to identify the race with the maximum date in the `races` table. Once we have that race, we can join it with the `circuits` table to get the full location (location + country) of the racetrack. The steps are:\n1. Find the race with the maximum date in the `races` table.\n2. Join this race with the `circuits` table to get the location and country details.\n3. Concatenate the location and country to form the full location.",
    "sql": "SELECT c.name AS racetrack, c.location || ', ' || c.country AS full_location\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.date = (SELECT MAX(date) FROM races);",
    "question": "Which racetrack hosted the most recent race? Indicate the full location.",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1",
    "evidence": [
      "full location refers to location+country; most recent race = MAX(date)\n\n"
    ]
  },
  "1515": {
    "reason": "To determine the segment of the customer at the specific time '2012/8/23 21:20:00', we need to follow these steps:\n1. Identify the transaction(s) that occurred at the exact time '2012/8/23 21:20:00' from the `transactions_1k` table.\n2. From the identified transaction(s), extract the `CustomerID` involved.\n3. Use the `CustomerID` to query the `customers` table and retrieve the `Segment` of the customer.\n\nThe query will involve joining the `transactions_1k` table with the `customers` table based on the `CustomerID` and filtering for the specific date and time.",
    "sql": "SELECT c.Segment\nFROM customers c\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE t.Date = '2012-08-23' AND t.Time = '21:20:00';",
    "question": "What segment did the customer have at 2012/8/23 21:20:00?",
    "db_id": "debit_card_specializing",
    "res": 1,
    "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.date = '2012-08-23' AND T1.time = '21:20:00'",
    "evidence": [
      "'2012/8/23' can be represented by '2012-08-23'"
    ]
  },
  "659": {
    "reason": "To solve the question, we need to find the number of tags where the post count (stored in the `Count` column of the `tags` table) is between 5,000 and 7,000. The query involves filtering the `tags` table based on the `Count` column and then counting the number of rows that meet the condition.",
    "sql": "SELECT COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000;",
    "question": "How many tags have post count between 5,000 to 7,000?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(Id) FROM tags WHERE Count BETWEEN 5000 AND 7000",
    "evidence": [
      "post count between 5,000 to 7,000 refers to Count BETWEEN 5000 and 7000;"
    ]
  },
  "184": {
    "reason": "To find the number of female customers with a junior credit card, we need to follow these steps:\n1. Identify female customers from the `client` table where `gender` is 'F'.\n2. Join the `client` table with the `disp` table to link clients to their accounts.\n3. Join the `disp` table with the `card` table to find the type of card associated with the account.\n4. Filter the results to only include cards where `type` is 'junior' (assuming 'junior' is the correct type).\n5. Count the distinct female clients who meet these criteria.",
    "sql": "SELECT COUNT(DISTINCT c.client_id) AS female_junior_card_holders\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE c.gender = 'F' AND ca.type = 'junior';",
    "question": "How many female customers have a junior credit card?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
    "evidence": [
      "Female refers to gender = 'F'"
    ]
  },
  "920": {
    "reason": "To find all the years that the Silverstone Circuit was used in a Formula 1 race, we need to:\n1. Identify the circuitId for Silverstone Circuit from the circuits table.\n2. Use this circuitId to find all races held at Silverstone Circuit in the races table.\n3. Extract the unique years from these races to list all the years the circuit was used.",
    "sql": "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit';",
    "question": "Please list all the years that Silverstone Circuit was used in a Formula_1 race.",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
    "evidence": [
      ""
    ]
  },
  "599": {
    "reason": "To solve the question, we need to address two parts:\n1. Find the post history type IDs for post ID 3720.\n2. Count the number of unique users who have commented on the post with ID 3720.\n\nFor the first part, we query the `postHistory` table where `PostId` is 3720 and retrieve the `PostHistoryTypeId` values.\nFor the second part, we query the `comments` table where `PostId` is 3720 and count the distinct `UserId` values to get the number of unique users who commented.",
    "sql": "-- Query to find post history type IDs for post ID 3720\nSELECT DISTINCT PostHistoryTypeId\nFROM postHistory\nWHERE PostId = 3720;\n\n-- Query to count unique users who commented on post ID 3720\nSELECT COUNT(DISTINCT UserId) AS UniqueCommentingUsers\nFROM comments\nWHERE PostId = 3720;",
    "question": "What are the post history type IDs for post ID 3720 and how many unique users have commented on the post?",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory AS T1 WHERE T1.PostId = 3720",
    "evidence": [
      ""
    ]
  },
  "1194": {
    "reason": "To solve the question, we need to find the sex of a patient who meets two conditions: \n1. Diagnosed with PSS in a medical examination (from the Examination table).\n2. Had specific laboratory results (C-reactive protein 2+, creatinine 1, and LDH 123) in the Laboratory table.\n\nSteps:\n1. Identify the patient ID(s) from the Examination table where the Diagnosis is 'PSS'.\n2. From the Laboratory table, find the patient ID(s) where CRP is '2+', CRE is 1, and LDH is 123.\n3. Join these results with the Patient table to get the sex of the patient(s) who meet both conditions.",
    "sql": "SELECT p.SEX\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nJOIN Laboratory l ON p.ID = l.ID\nWHERE e.Diagnosis = 'PSS'\nAND l.CRP = '2+'\nAND l.CRE = 1\nAND l.LDH = 123;",
    "question": "What sex is the patient who in a medical examination was diagnosed with PSS and in a laboratory examination had a blood level of C-reactive protein de 2+, createnine 1 and LDH 123?",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T3.ID = T2.ID WHERE T2.Diagnosis = 'PSS' AND T3.CRP = '2+' AND T3.CRE = 1.0 AND T3.LDH = 123",
    "evidence": [
      "PSS' refers to diagnosis; blood level of C-reactive protein de 2+refers to CRP > 2; createnine 1 refers to CRE = 1; LDH 123 refers to LDH = 123"
    ]
  },
  "1386": {
    "reason": "To find the total expense for the Yearly Kickoff, we need to follow these steps:\n1. Identify the event_id for the Yearly Kickoff from the event table.\n2. Use the event_id to find the corresponding budget_id in the budget table.\n3. Sum all the costs from the expense table where the link_to_budget matches the budget_id found in step 2.",
    "sql": "SELECT SUM(e.cost) AS total_expense\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Yearly Kickoff';",
    "question": "What is the total expense for the Yearly Kickoff?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'Yearly Kickoff'",
    "evidence": [
      "'Yearly Kickoff' is an event name; total expense refers to SUM(cost)"
    ]
  },
  "962": {
    "reason": "To solve the question, we need to calculate the percentage of drivers who were born before 1985 and completed more than 50 laps in races held between 2000 and 2005. The steps are as follows:\n1. Identify all drivers who participated in races between 2000 and 2005.\n2. From these drivers, filter those who were born before 1985.\n3. Further filter these drivers to include only those who completed more than 50 laps in any race.\n4. Calculate the percentage by dividing the count of drivers from step 3 by the total count of drivers from step 1, then multiplying by 100.\n\nThe query will involve joining the `drivers` table with the `results` and `races` tables to filter based on the criteria.",
    "sql": "WITH drivers_2000_2005 AS (\n    SELECT DISTINCT d.driverId, d.dob\n    FROM drivers d\n    JOIN results r ON d.driverId = r.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE rc.year BETWEEN 2000 AND 2005\n),\ndrivers_before_1985_over_50_laps AS (\n    SELECT DISTINCT d.driverId\n    FROM drivers d\n    JOIN results r ON d.driverId = r.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE strftime('%Y', d.dob) < '1985'\n    AND r.laps > 50\n    AND rc.year BETWEEN 2000 AND 2005\n)\nSELECT \n    (COUNT(d.driverId) * 100.0 / (SELECT COUNT(*) FROM drivers_2000_2005)) AS percentage\nFROM drivers_before_1985_over_50_laps d;",
    "error": "something went wrong, tool did not call.",
    "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
    "db_id": "formula_1",
    "res": 0,
    "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
    "evidence": [
      "born before 1985 refers to year(dob)<1985; in 2000 to 2005 refers to year between 2000 and 2005; percentage = Divide(COUNT(driverId where year (dob) <1985 and laps >50),COUNT(DriverID where year between 2000 and 2005) *100;"
    ]
  },
  "1347": {
    "reason": "To find the hometown county for \"Adela O'Gallagher\", we need to follow these steps:\n1. Locate the member record for \"Adela O'Gallagher\" in the `member` table to get her ZIP code.\n2. Use the ZIP code to look up the corresponding county in the `zip_code` table.\n3. Join the `member` and `zip_code` tables on the ZIP code to retrieve the county information.",
    "sql": "SELECT z.county\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Adela' AND m.last_name = 'O''Gallagher';",
    "question": "Tell the hometown county for \"Adela O'Gallagher\".",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'",
    "evidence": [
      "hometown county refers to county"
    ]
  },
  "170": {
    "reason": "To solve the question, we need to find the number of credit card withdrawals recorded after 1995. The key points are:\n1. The operation 'VYBER KARTOU' indicates a credit card withdrawal.\n2. The date must be after 1995.\n3. The relevant table is `trans`, which contains the `operation` and `date` columns.\n\nSteps:\n1. Filter the `trans` table for records where `operation` is 'VYBER KARTOU'.\n2. Further filter these records to include only those where the `date` is after '1995-12-31'.\n3. Count the number of such records.",
    "sql": "SELECT COUNT(*) AS credit_card_withdrawals_after_1995\nFROM trans\nWHERE operation = 'VYBER KARTOU' AND date > '1995-12-31';",
    "question": "How many credit card withdrawals were recorded after 1995?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
    "evidence": [
      "Operation = 'VYBER KARTOU' means credit card withdrawals"
    ]
  },
  "26": {
    "reason": "To solve the question, we need to find high schools in Monterey that have more than 800 free or reduced-price meals (FRPM) for ages 15-17. The steps are as follows:\n1. Identify high schools in Monterey by checking the `County` field in the `schools` table.\n2. Filter these schools to ensure they are high schools by checking the `High Grade` field in the `frpm` table (assuming '12' or similar indicates high school).\n3. Join the `frpm` table with the `schools` table using the `CDSCode` to get the full communication address.\n4. Filter the `frpm` table for schools with `FRPM Count (Ages 5-17)` > 800 (assuming ages 15-17 are included in this range).\n5. Select the school name and full communication address (Street, City, State, and Zip) from the `schools` table.",
    "sql": "SELECT s.School AS \"School Name\", s.Street, s.City, s.State, s.Zip\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.County = 'Monterey'\n  AND f.\"High Grade\" LIKE '%12%'\n  AND f.\"FRPM Count (Ages 5-17)\" > 800;",
    "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
    "db_id": "california_schools",
    "res": 0,
    "ground_truth": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
    "evidence": [
      "Full communication address should include Street, City, State and zip code if any."
    ]
  },
  "768": {
    "reason": "To find the number of superheroes published by Dark Horse Comics, we need to:\n1. Identify the publisher_id for 'Dark Horse Comics' in the publisher table.\n2. Count the number of superheroes in the superhero table where the publisher_id matches the one found in step 1.",
    "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Dark Horse Comics');",
    "question": "How many superheroes were published by Dark Horse Comics?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Dark Horse Comics'",
    "evidence": [
      "published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';"
    ]
  },
  "914": {
    "reason": "To find out how many drivers don't have a code, we need to query the `drivers` table and count the rows where the `code` column is NULL or an empty string. The SQL query will use the `COUNT` function to count these rows.",
    "sql": "SELECT COUNT(*) FROM drivers WHERE code IS NULL OR code = '';",
    "question": "How many drivers don't have a code?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT COUNT(driverId) - COUNT(CASE WHEN code IS NOT NULL THEN code END) FROM drivers",
    "evidence": [
      "don't have a code refers to code is null"
    ]
  },
  "754": {
    "reason": "To find the superpower of the hero with ID 56, we need to follow these steps:\n1. Identify the hero in the `superhero` table with `id = 56`.\n2. Join the `hero_power` table to link the hero's ID with their superpowers.\n3. Join the `superpower` table to get the names of the superpowers associated with the hero.\n4. Retrieve the `power_name` from the `superpower` table for the hero with ID 56.",
    "sql": "SELECT sp.power_name \nFROM superhero sh \nJOIN hero_power hp ON sh.id = hp.hero_id \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE sh.id = 56;",
    "question": "What is the superpower of hero ID 56?",
    "db_id": "superhero",
    "res": 1,
    "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 56",
    "evidence": [
      "superpower refers to hero_power"
    ]
  },
  "1273": {
    "reason": "To solve the question, we need to find the number of distinct patients who meet two conditions: \n1. They have a normal anti-SSB (SSB IN('-', '+-')).\n2. They are diagnosed with SLE (Diagnosis = 'SLE') in the Examination table.\n\nWe will join the Patient and Examination tables to ensure we are checking the correct patients. Then, we will filter based on the conditions mentioned and count the distinct patient IDs.",
    "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Examination E ON P.ID = E.ID \nWHERE E.Diagnosis = 'SLE' \nAND (E.SSB IN('-', '+-'));",
    "question": "How many patients have a normal anti-SSB and are diagnosed with SLE in the examination?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Diagnosis = 'SLE'",
    "evidence": [
      "normal anti-SSB refers to SSB IN('-', '+-'); '-' is expressed as 'negative' and '+-' is expressed as '0' in the database ; diagnosed with SLE refers to Diagnosis = 'SLE'; Should compute the number of distinct ones"
    ]
  },
  "1510": {
    "reason": "To find the average total price of transactions in gas stations in the Czech Republic, we need to:\n1. Identify gas stations in the Czech Republic by filtering the `gasstations` table where `Country` is 'CZE'.\n2. Join the `transactions_1k` table with the filtered gas stations to get all transactions that occurred in these gas stations.\n3. Calculate the total price for each transaction by multiplying `Amount` and `Price`.\n4. Compute the average of these total prices.",
    "sql": "SELECT AVG(Amount * Price) AS average_total_price\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE';",
    "question": "What is the average total price of the transactions taken place in gas stations in the Czech Republic?",
    "db_id": "debit_card_specializing",
    "res": 0,
    "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE'",
    "evidence": [
      "Gas station in the Czech Republic implies that Country = 'CZE'"
    ]
  },
  "1246": {
    "reason": "To solve the question, we need to find the number of patients with an abnormal activated partial prothrombin time (APTT) who do not have thrombosis. Here's the step-by-step reasoning:\n\n1. **Identify abnormal APTT**: The `Laboratory` table contains the `APTT` column. We need to define what constitutes an abnormal APTT. For this query, we'll assume an abnormal APTT is when the value is outside the normal range (e.g., less than 25 or greater than 35 seconds).\n\n2. **Check for thrombosis**: The `Examination` table contains the `Thrombosis` column, which indicates whether a patient has thrombosis (1 for yes, 0 for no).\n\n3. **Join tables**: We need to join the `Laboratory` and `Examination` tables on the `ID` column to correlate APTT values with thrombosis status.\n\n4. **Filter and count**: Filter for patients with abnormal APTT and no thrombosis (Thrombosis = 0), then count these patients.\n\n5. **Final query**: The query will join the tables, apply the filters, and count the results.",
    "sql": "SELECT COUNT(DISTINCT L.ID) \nFROM Laboratory L\nJOIN Examination E ON L.ID = E.ID\nWHERE (L.APTT < 25 OR L.APTT > 35) AND E.Thrombosis = 0;",
    "question": "For the patients with an abnormal activated partial prothrom bin time, how many of them does not have thrombosis?",
    "db_id": "thrombosis_prediction",
    "res": 1,
    "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T3.Thrombosis = 0 AND T2.APTT > 45",
    "evidence": [
      "abnormal activated partial prothrom bin time refers to APTT > 45; does not have thrombosis refers to Thrombosis = 0; Only count ones without repetitive."
    ]
  },
  "251": {
    "reason": "To find the least common element of all carcinogenic molecules, we need to follow these steps:\n1. Identify all carcinogenic molecules by filtering the `molecule` table where `label = '+'`.\n2. Join the `atom` table with the filtered `molecule` table to get all atoms belonging to carcinogenic molecules.\n3. Group the atoms by their `element` and count the occurrences of each element.\n4. Order the results by the count in ascending order to find the least common element.\n5. Limit the result to the first row to get the least common element.",
    "sql": "SELECT a.element, COUNT(a.element) AS element_count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+'\nGROUP BY a.element\nORDER BY element_count ASC\nLIMIT 1;",
    "question": "What is the least common element of all carcinogenic molecules?",
    "db_id": "toxicology",
    "res": 0,
    "ground_truth": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
    "evidence": [
      "label = '+' mean molecules are carcinogenic"
    ]
  },
  "190": {
    "reason": "To solve the question, we need to find the number of clients born in 1920 who reside in East Bohemia. The steps are as follows:\n1. Identify the `district_id` for East Bohemia from the `district` table.\n2. Filter clients in the `client` table who were born in 1920 (using the `birth_date` column).\n3. Join the `client` table with the `district` table to ensure the clients are from East Bohemia.\n4. Count the number of such clients.",
    "sql": "SELECT COUNT(*) \nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE strftime('%Y', c.birth_date) = '1920' \nAND d.A3 = 'east Bohemia';",
    "question": "How many clients who were born in 1920 stay in east Bohemia?",
    "db_id": "financial",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.birth_date) = '1920' AND T2.A3 = 'east Bohemia'",
    "evidence": [
      "East Bohemia appears in the column A3, which refers to the region."
    ]
  },
  "701": {
    "reason": "To solve the question, we need to follow these steps:\n1. Identify the most influential user, which is the user with the highest reputation.\n2. Find all posts posted by this user.\n3. Calculate the percentage of these posts that have a score above 50.\n\nThe steps involve:\n- Querying the `users` table to find the user with the highest reputation.\n- Using this user's ID to filter posts in the `posts` table.\n- Counting the total posts by this user and the posts with a score above 50.\n- Calculating the percentage by dividing the count of high-score posts by the total posts and multiplying by 100.",
    "sql": "WITH most_influential_user AS (\n    SELECT Id\n    FROM users\n    ORDER BY Reputation DESC\n    LIMIT 1\n),\nuser_posts AS (\n    SELECT Id, Score\n    FROM posts\n    WHERE OwnerUserId = (SELECT Id FROM most_influential_user)\n),\ntotal_posts AS (\n    SELECT COUNT(*) AS total\n    FROM user_posts\n),\nhigh_score_posts AS (\n    SELECT COUNT(*) AS high_score\n    FROM user_posts\n    WHERE Score > 50\n)\nSELECT (high_score * 100.0 / total) AS percentage\nFROM high_score_posts, total_posts;",
    "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
    "evidence": [
      "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));"
    ]
  },
  "662": {
    "reason": "To solve the question, we need to find the number of posts that meet the following criteria:\n1. The posts have votes.\n2. The votes were created in 2011.\n3. The votes have a bounty of 50.\n\nWe will approach this step by step:\n1. Join the `posts` table with the `votes` table to link posts with their votes.\n2. Filter the votes to only include those created in 2011 and with a bounty of 50.\n3. Count the distinct posts that meet these criteria.",
    "sql": "SELECT COUNT(DISTINCT p.Id) \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE strftime('%Y', v.CreationDate) = '2011' \nAND v.BountyAmount = 50;",
    "question": "How many posts with votes that were created in 2011 have a bounty of 50?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.BountyAmount = 50 AND STRFTIME('%Y', T2.CreationDate) = '2011'",
    "evidence": [
      "created in 2012 refers YEAR(CreationDate) = 2011; BountyAmount = 50;"
    ]
  },
  "933": {
    "reason": "To find Lewis Hamilton's final rank in the 2008 Chinese Grand Prix, we need to follow these steps:\n1. Identify Lewis Hamilton's driverId from the drivers table using his name (forename and surname).\n2. Identify the raceId for the 2008 Chinese Grand Prix from the races table using the year (2008) and the race name (Chinese Grand Prix).\n3. Query the results table to find his final rank (positionOrder) for the identified raceId and driverId.",
    "sql": "SELECT r.positionOrder \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' \nAND ra.year = 2008 AND ra.name = 'Chinese Grand Prix';",
    "question": "What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT T2.positionOrder FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.name = 'Chinese Grand Prix' AND T1.year = 2008",
    "evidence": [
      "Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; final rank refers to positionOrder; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';"
    ]
  },
  "610": {
    "reason": "To solve the question, we need to find the names of badges obtained by users who have the highest reputation. The steps to achieve this are:\n1. Identify the user(s) with the highest reputation from the `users` table.\n2. Use the `UserId` of these users to find the badges they have obtained from the `badges` table.\n3. Retrieve the `Name` of these badges.\n\nThe query will involve joining the `users` and `badges` tables, filtering for users with the maximum reputation, and then selecting the badge names.",
    "sql": "SELECT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Reputation = (SELECT MAX(Reputation) FROM users);",
    "question": "What are the name of badge that users who have the highest reputation obtained?",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT T2.name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1",
    "evidence": [
      "highest reputation refers to Max(Reputation); user refers to UserId"
    ]
  },
  "319": {
    "reason": "To determine how many elements are contained in the bond with `bond_id` TR001_3_4, we need to follow these steps:\n1. Identify the atoms connected by the bond with `bond_id` TR001_3_4 from the `connected` table.\n2. Retrieve the elements of these atoms from the `atom` table.\n3. Count the distinct elements to find out how many unique elements are involved in the bond.\n\nThe query will join the `connected` table with the `atom` table twice (once for each atom in the bond) to get the elements of both atoms, and then count the distinct elements.",
    "sql": "SELECT COUNT(DISTINCT a1.element) AS element_count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_3_4';",
    "question": "How many elements are contained in bond_id TR001_3_4?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT COUNT(DISTINCT T1.element) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_3_4'",
    "evidence": [
      "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
    ]
  },
  "1470": {
    "reason": "To solve the question, we need to find the number of gas stations in CZE (Czech Republic) that offer Premium gas. The `gasstations` table contains information about gas stations, including their country and segment. The segment 'Premium' indicates the type of gas offered. We will filter the gas stations by country 'CZE' and segment 'Premium', then count the results.",
    "sql": "SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium';",
    "question": "How many gas stations in CZE has Premium gas?",
    "db_id": "debit_card_specializing",
    "res": 1,
    "ground_truth": "SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium'",
    "evidence": [
      ""
    ]
  },
  "1397": {
    "reason": "To solve the question, we need to calculate the average amount spent on food for events that are in the past (i.e., events with status 'Closed'). The steps are as follows:\n1. Identify all budgets linked to events with status 'Closed'.\n2. Filter these budgets to only include those with the category 'Food'.\n3. Calculate the average of the 'spent' column for these budgets.\n4. The result will give the average spending on food for past events.",
    "sql": "SELECT AVG(spent) AS average_food_spending\nFROM budget\nWHERE category = 'Food' AND link_to_event IN (SELECT event_id FROM event WHERE status = 'Closed');",
    "question": "On average, how much did the Student_Club spend on food for the typical event in the past?",
    "db_id": "student_club",
    "res": 1,
    "ground_truth": "SELECT SUM(spent) / COUNT(spent) FROM budget WHERE category = 'Food' AND event_status = 'Closed'",
    "evidence": [
      "DIVIDE(SUM(spent), COUNT(spent)) where category = 'Food'; 'event in the past' means event_status = 'Closed'"
    ]
  },
  "316": {
    "reason": "To solve the question, we need to identify molecules that contain the element \"c\" and are not carcinogenic. The steps are as follows:\n1. First, find all atoms with the element \"c\" and retrieve their associated `molecule_id`.\n2. Then, join these `molecule_id`s with the `molecule` table to check if their `label` is \"-\", indicating they are non-carcinogenic.\n3. Finally, return the distinct `molecule_id`s that meet both criteria.",
    "sql": "SELECT DISTINCT a.molecule_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'c' AND m.label = '-';",
    "question": "Among the molecules which contain \"c\" element, which of them are not carcinogenic?",
    "db_id": "toxicology",
    "res": 1,
    "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
    "evidence": [
      "label = '-' means molecules are non-carcinogenic"
    ]
  },
  "1457": {
    "reason": "To solve the question, we need to find members who spent more than the average cost on each expense. Here's the step-by-step reasoning:\n\n1. **Calculate the average cost of all expenses**: This will give us the baseline to compare individual expenses against.\n2. **Identify expenses where the cost is greater than the average**: These are the expenses that meet the criteria.\n3. **Link these expenses to the members who made them**: Using the `link_to_member` field in the `expense` table, we can connect the expenses to the members.\n4. **Retrieve the full name and contact number of these members**: The `member` table contains the `first_name`, `last_name`, and `phone` fields needed for the output.\n\nBy joining the `expense` and `member` tables and filtering for expenses with a cost greater than the average, we can achieve the desired result.",
    "sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, m.phone AS contact_number\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost > (SELECT AVG(cost) FROM expense);",
    "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
    "db_id": "student_club",
    "res": 0,
    "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
    "evidence": [
      "full name refers to first_name, last_name; contact number refers to phone; had spent more than average on each expense refers to cost > AVG(cost)"
    ]
  },
  "1251": {
    "reason": "To solve the question, we need to find the number of patients with an Ig G (IGG) level higher than normal, which is defined as IGG >= 2000. The IGG data is stored in the Laboratory table. Since the question asks for the number of patients (not the number of records), we need to ensure we count distinct patients. Here's the step-by-step reasoning:\n\n1. Identify the relevant table: Laboratory, as it contains the IGG data.\n2. Filter records where IGG >= 2000.\n3. Count the distinct patient IDs from the filtered records to avoid counting the same patient multiple times.\n4. Return the count as the result.",
    "sql": "SELECT COUNT(DISTINCT ID) FROM Laboratory WHERE IGG >= 2000;",
    "question": "How many patients with an Ig G higher than normal?",
    "db_id": "thrombosis_prediction",
    "res": 0,
    "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
    "evidence": [
      "Ig G higher than normal refers to IGG >= 2000; Should consider DISTINCT in the final result;"
    ]
  },
  "535": {
    "reason": "To solve the question, we need to identify users who have more than 100 upvotes and then count how many of these users also have more than 1 downvote. The steps are as follows:\n1. Filter users from the `users` table where `UpVotes` > 100.\n2. From this filtered list, count the number of users where `DownVotes` > 1.",
    "sql": "SELECT COUNT(*) AS UserCount\nFROM users\nWHERE UpVotes > 100 AND DownVotes > 1;",
    "question": "Among the users who have more than 100 upvotes, how many of them have more then 1 downvotes?",
    "db_id": "codebase_community",
    "res": 1,
    "ground_truth": "SELECT COUNT(Id) FROM users WHERE Upvotes > 100 AND Downvotes > 1",
    "evidence": [
      "more than 100 upvotes refers to Upvotes > 100; more than 1 downvotes refers to Downvotes > 1"
    ]
  },
  "689": {
    "reason": "To solve the question, we need to identify the user who was the last to edit the post with ID 183. The post's last editor is stored in the `LastEditorUserId` column of the `posts` table. We can use this information to join the `users` table and retrieve the display name and location of the user. The steps are as follows:\n1. Query the `posts` table to find the `LastEditorUserId` for the post with ID 183.\n2. Join the `users` table with the `LastEditorUserId` to get the display name and location of the user.\n3. Return the required fields.",
    "sql": "SELECT u.DisplayName, u.Location\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE p.Id = 183;",
    "question": "Identify the display name and location of the user, who was the last to edit the post with ID 183.",
    "db_id": "codebase_community",
    "res": 0,
    "ground_truth": "SELECT T2.DisplayName, T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 183 ORDER BY T1.LastEditDate DESC LIMIT 1",
    "evidence": [
      "last to edit refers to MAX(LastEditDate);"
    ]
  },
  "968": {
    "reason": "To find the reference name of Robert Kubica, we need to query the `drivers` table where the forename is 'Robert' and the surname is 'Kubica'. The reference name is stored in the `driverRef` column of the `drivers` table.",
    "sql": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';",
    "question": "What is reference name of Robert Kubica?",
    "db_id": "formula_1",
    "res": 1,
    "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica'",
    "evidence": [
      "reference name refers to driverRef;"
    ]
  },
  "375": {
    "reason": "To list all card IDs with a converted mana cost of 0, we need to query the `cards` table and filter for rows where the `convertedManaCost` column equals 0. The `id` column in the `cards` table represents the card ID, so we will select this column for the output.",
    "sql": "SELECT id FROM cards WHERE convertedManaCost = 0;",
    "question": "List down all the card IDs with converted mana cost of 0.",
    "db_id": "card_games",
    "res": 1,
    "ground_truth": "SELECT id FROM cards WHERE convertedManaCost = 0",
    "evidence": [
      "converted mana cost of 0 refers to covertedManaCost = 0;"
    ]
  }
}