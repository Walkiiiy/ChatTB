{
    "615": {
        "reason": "To solve the question, we need to:\n1. Identify users who have obtained the \"Organizer\" badge from the `badges` table.\n2. Determine which of these users are teenagers (age between 13 and 19) from the `users` table.\n3. Calculate the percentage of teenage users among those who have the \"Organizer\" badge.\n\nThe steps involve joining the `badges` and `users` tables, filtering for the \"Organizer\" badge and age range, and then performing the percentage calculation.",
        "sql": "SELECT \n    (COUNT(CASE WHEN u.Age BETWEEN 13 AND 19 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_teenagers\nFROM \n    badges b\nJOIN \n    users u ON b.UserId = u.Id\nWHERE \n    b.Name = 'Organizer';",
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "evidence": [
            "\"Organizer\" is the Name of badge; teenager refers to Age BETWEEN 13 AND 18; percentage = Divide (Count(UserId where Age BETWEEN 13 AND 18), Count(UserId)) *100"
        ]
    },
    "1387": {
        "reason": "To find out which student has been entrusted to manage the budget for the Yearly Kickoff, we need to follow these steps:\n1. Identify the event_id for the 'Yearly Kickoff' event from the 'event' table.\n2. Use this event_id to find the corresponding budget entry in the 'budget' table.\n3. The 'budget' table has a 'link_to_event' field that connects it to the event.\n4. The 'expense' table has a 'link_to_budget' field that connects it to the budget, and a 'link_to_member' field that connects it to the member managing the budget.\n5. Finally, join the 'member' table to get the details of the student (first_name and last_name) who is managing the budget.\n\nWe will use a series of joins to connect these tables and filter for the 'Yearly Kickoff' event.",
        "sql": "SELECT m.first_name, m.last_name\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Yearly Kickoff';",
        "question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
        "evidence": [
            "name of students means the full name; full name refers to first_name, last_name;'Yearly Kickoff' is an event name;"
        ]
    },
    "748": {
        "reason": "To find the eye colour of the superhero with ID 75, we need to:\n1. Identify the `eye_colour_id` for the superhero with `id = 75` from the `superhero` table.\n2. Use this `eye_colour_id` to look up the corresponding colour name in the `colour` table.\n3. Join the `superhero` table with the `colour` table on the `eye_colour_id` to retrieve the colour name.",
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.id = 75;",
        "question": "What is the eye colour of superhero with superhero ID 75?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.id = 75",
        "evidence": [
            "eye colour refers to colour where eye_colour_id = colour.id;"
        ]
    },
    "1211": {
        "reason": "To solve the question, we need to find patients with lactate dehydrogenase (LDH) levels between 600 and 800 (which is 100-300 index above the normal range of 100-300). The steps are as follows:\n1. Calculate the age of each patient by subtracting the year of their birthday from the current year.\n2. Filter the Laboratory table for records where LDH is strictly greater than 600 and strictly less than 800.\n3. Join the filtered Laboratory records with the Patient table to get the patient's ID and birthday.\n4. Use DISTINCT to ensure each patient is listed only once, even if they have multiple matching LDH records.\n5. Return the ID and calculated age of these patients.",
        "sql": "SELECT DISTINCT P.ID, (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', P.Birthday) AS age\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.LDH > 600 AND L.LDH < 800;",
        "question": "Provide the ID and age of patient with lactate dehydrogenase (LDH) between 100-300 index above the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 600 AND T2.LDH < 800",
        "evidence": [
            "age refers to SUBTRACT(year(current_timestamp), year(Birthday)); lactate dehydrogenase (LDH) between 100-300 index above the normal range refers to LDH between 600 and 800;",
            "The normal range for lactate dehydrogenase (LDH) is 100-300, so values above this range are considered elevated. The query should filter for LDH values strictly above 600 and below 800 to capture the specified range.",
            "The DISTINCT keyword ensures unique patient records are returned when multiple laboratory entries match the criteria. The correct age calculation uses CURRENT_TIMESTAMP for accurate year extraction.",
            "The query should use strict inequality operators (> and <) for range filtering to exclude boundary values, not BETWEEN which includes them."
        ]
    },
    "729": {
        "reason": "To find the average height of superheroes from Marvel Comics, we need to:\n1. Identify the publisher_id for 'Marvel Comics' in the `publisher` table.\n2. Join the `superhero` table with the `publisher` table to filter superheroes associated with Marvel Comics.\n3. Calculate the average height (height_cm) of these superheroes.",
        "sql": "SELECT AVG(height_cm) AS average_height\nFROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel Comics';",
        "question": "What is the average height of the superheroes from Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "evidence": [
            "superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; average height of the superheroes refers to AVG(height_cm)"
        ]
    },
    "1400": {
        "reason": "To solve the question, we need to find the percentage share of events related to 'Community Service' among all events held by the Student_Club in 2019. Here's the step-by-step reasoning:\n\n1. **Filter events for the year 2019**: The `event_date` column in the `event` table likely contains dates in a format that includes the year. We need to extract the year from this column and filter for events in 2019.\n\n2. **Identify 'Community Service' events**: The `type` column in the `event` table specifies the type of event. We need to count how many of these events are of type 'Community Service'.\n\n3. **Calculate the total number of events in 2019**: This will be the denominator for our percentage calculation.\n\n4. **Calculate the percentage**: Divide the count of 'Community Service' events by the total number of events in 2019 and multiply by 100 to get the percentage.\n\n5. **Return the result**: The final query will return the calculated percentage.",
        "sql": "SELECT \n    (COUNT(CASE WHEN type = 'Community Service' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_share\nFROM \n    event\nWHERE \n    strftime('%Y', event_date) = '2019';",
        "question": "Among all events hold by the Student_Club in 2019, find the percentage share of events related to 'Community Service'",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(type) FROM event WHERE SUBSTR(event_date, 1, 4) = '2019'",
        "evidence": [
            "DIVIDE(SUM(type = 'Community Service'), COUNT(event_id)) * 100 where event_date BETWEEN' 2019-01-01' and '2019-12-31'"
        ]
    },
    "11": {
        "reason": "To solve the question, we need to find the school codes (CDSCode) where the total enrollment is over 500. The total enrollment is calculated by summing `Enrollment (K-12)` and `Enrollment (Ages 5-17)` from the `frpm` table. We will query the `frpm` table, calculate the total enrollment for each school, and filter the results to include only those schools with a total enrollment greater than 500.",
        "sql": "SELECT CDSCode FROM frpm WHERE (\"Enrollment (K-12)\" + \"Enrollment (Ages 5-17)\") > 500;",
        "question": "Please list the codes of the schools with a total enrollment of over 500.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.CDSCode FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` + T2.`Enrollment (Ages 5-17)` > 500",
        "evidence": [
            "Total enrollment can be represented by `Enrollment (K-12)` + `Enrollment (Ages 5-17)`"
        ]
    },
    "337": {
        "reason": "To solve the question, we need to list the elements and bond types included in the molecule with the ID `TR002`. This involves querying the `atom` table to get the elements and the `bond` table to get the bond types, both of which are linked to the molecule via the `molecule_id` field. We will join these tables to gather the required information for the molecule with `molecule_id = 'TR002'`.",
        "sql": "SELECT a.element, b.bond_type\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.molecule_id = 'TR002';\n",
        "question": "List the element and bond type included in the molecule with molecule ID of TR002.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element, T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR002'",
        "evidence": [
            "TR002 is the molecule id"
        ]
    },
    "30": {
        "reason": "To solve the question, we need to find the cities with the top 5 lowest enrollment numbers for students in grades 1 through 12. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables and columns**:\n   - The `frpm` table contains the `Enrollment (K-12)` column, which represents the total enrollment for grades 1 through 12.\n   - The `schools` table contains the `City` column, which is needed to group the results by city.\n\n2. **Join the tables**:\n   - We need to join the `frpm` table with the `schools` table using the `CDSCode` column to associate each school's enrollment data with its city.\n\n3. **Aggregate the data**:\n   - Sum the `Enrollment (K-12)` values for all schools in each city to calculate the total enrollment per city.\n\n4. **Filter and order the results**:\n   - Order the results by the summed enrollment in ascending order to identify the cities with the lowest enrollment.\n   - Limit the results to the top 5 cities.\n\n5. **Final query**:\n   - The query will join the tables, group by city, sum the enrollment, order by the sum, and limit the results to 5.",
        "sql": "SELECT s.City, SUM(f.\"Enrollment (K-12)\") AS TotalEnrollment\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nGROUP BY s.City\nORDER BY TotalEnrollment ASC\nLIMIT 5;",
        "question": "Which cities have the top 5 lowest enrollment number for students in grades 1 through 12?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode GROUP BY T2.City ORDER BY SUM(T1.`Enrollment (K-12)`) ASC LIMIT 5",
        "evidence": [
            "K-12 refers to students in grades 1 through 12.",
            "The `Enrollment (K-12)` column in the `frpm` table represents the total enrollment for grades 1 through 12, which should be aggregated by city.\nThe `schools` table provides the city information for each school, which is essential for grouping results by city.\nAggregating enrollment by city requires summing the `Enrollment (K-12)` values for all schools in each city.",
            "The `Enrollment (K-12)` column in the `frpm` table should be summed for each city to calculate total enrollment.\nThe `City` column in the `schools` table is used to group results by city.\nResults should be ordered by the summed enrollment in ascending order to identify the lowest values.",
            "The `Enrollment (K-12)` column in the `frpm` table should be summed for each city to calculate total enrollment.\nThe `City` column in the `schools` table is used to group results by city.\nResults should be ordered by the summed enrollment in ascending order to identify the lowest values."
        ]
    },
    "834": {
        "reason": "To solve the question, we need to identify the percentage of female superheroes among all superheroes created by George Lucas. Here's the step-by-step reasoning:\n\n1. **Identify George Lucas's Publisher ID**: First, we need to find the `id` of the publisher named \"George Lucas\" from the `publisher` table.\n\n2. **Filter Superheroes by Publisher**: Using the publisher ID, filter the `superhero` table to get all superheroes created by George Lucas.\n\n3. **Count Total Superheroes by George Lucas**: Count the total number of superheroes in the filtered list.\n\n4. **Filter Female Superheroes**: From the filtered list, further filter superheroes where `gender_id` corresponds to \"Female\" in the `gender` table.\n\n5. **Count Female Superheroes**: Count the number of female superheroes in this subset.\n\n6. **Calculate Percentage**: Divide the count of female superheroes by the total count of superheroes and multiply by 100 to get the percentage.\n\n7. **Join Tables**: Join the `superhero`, `publisher`, and `gender` tables to access the required data.\n\n8. **Final Query**: Combine all these steps into a single SQL query.",
        "sql": "SELECT \n    (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    gender g ON s.gender_id = g.id\nWHERE \n    p.publisher_name = 'George Lucas';",
        "question": "Among all superheroes created by George Lucas, identify the percentage of female superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas'",
        "evidence": [
            "created by George Lucas refers to publisher_name = 'George Lucas'; percentage = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'George Lucas'), COUNT(publisher_name = 'George Lucas')), 100.0); female refers to gender = 'Female';"
        ]
    },
    "683": {
        "reason": "To calculate the percentage of posts whose owners had a reputation of over 1000 in 2011, we need to follow these steps:\n1. Identify all posts created in 2011 by checking the `CreaionDate` field in the `posts` table.\n2. Join the `posts` table with the `users` table to access the `Reputation` field of the post owners.\n3. Count the total number of posts created in 2011 (denominator).\n4. Count the number of posts created in 2011 where the owner's reputation is over 1000 (numerator).\n5. Calculate the percentage by dividing the numerator by the denominator and multiplying by 100.\n\nNote: The `CreaionDate` field in the `posts` table is used for filtering by year, not `CreationDate`.",
        "sql": "SELECT \n    (COUNT(CASE WHEN u.Reputation > 1000 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nWHERE \n    strftime('%Y', p.CreaionDate) = '2011';",
        "question": "What is the percentage of posts whose owners had a reputation of over 1000 in 2011?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
        "evidence": [
            "percentage = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2011 and Reputation > 1000), COUNT(Id) ) * 100;",
            "To calculate percentages, ensure the numerator and denominator are derived from the same dataset scope, including all relevant filters.\nThe `CreaionDate` field in the `posts` table is used for filtering by year, not `CreationDate`.\nJoining tables should include all necessary conditions in the join or where clause to avoid incorrect aggregation.",
            "To calculate percentages, ensure the numerator and denominator are derived from the same dataset scope, including all relevant filters.\nThe `CreaionDate` field in the `posts` table is used for filtering by year, not `CreationDate`.\nJoining tables should include all necessary conditions in the join or where clause to avoid incorrect aggregation."
        ]
    },
    "590": {
        "reason": "To find the user ID with the lowest views, we need to query the `users` table and identify the user with the minimum value in the `Views` column. The steps are as follows:\n1. Select the `Id` column from the `users` table.\n2. Use the `MIN(Views)` function to find the lowest view count.\n3. The query will return the user ID associated with this minimum view count.",
        "sql": "SELECT Id FROM users WHERE Views = (SELECT MIN(Views) FROM users);",
        "question": "Which user ID has the lowest view?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id FROM users WHERE Views = ( SELECT MIN(Views) FROM users )",
        "evidence": [
            "lowest views refers to Min(Views)"
        ]
    },
    "877": {
        "reason": "To solve the question, we need to find the youngest driver among those who finished the race with raceId 872. The steps are as follows:\n1. Identify drivers who finished the race by checking the `results` table where `raceId` is 872 and `time` is not null (indicating they finished the race).\n2. Join the `results` table with the `drivers` table to get the date of birth (dob) of these drivers.\n3. Order the drivers by their date of birth in descending order to find the youngest driver (latest dob).\n4. Limit the result to 1 to get the youngest driver.",
        "sql": "SELECT d.driverId, d.forename, d.surname, d.dob\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 872 AND r.time IS NOT NULL\nORDER BY d.dob DESC\nLIMIT 1;",
        "question": "For all the drivers who finished the game in race No. 872, who is the youngest?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 872 AND T2.time IS NOT NULL ORDER BY T1.dob DESC LIMIT 1",
        "evidence": [
            "race number refers to raceId; drivers who finished the race refers to time has value; the youngest is a driver where MAX(dob);",
            "raceId uniquely identifies a race; drivers who finished a race have non-null time values in the results table; youngest driver is determined by the latest dob.",
            "raceId uniquely identifies a race; drivers who finished a race have non-null time values in the results table; youngest driver is determined by the latest dob."
        ]
    },
    "540": {
        "reason": "To solve the question, we need to find the title of the post owned by the user with the display name \"csgillespie\" and has the highest popularity (i.e., the maximum view count). The steps are as follows:\n1. First, identify the user ID of \"csgillespie\" from the `users` table.\n2. Then, find all posts owned by this user ID from the `posts` table.\n3. Among these posts, identify the one with the highest `ViewCount`.\n4. Retrieve the `Title` of this post.",
        "sql": "SELECT p.Title\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie'\nORDER BY p.ViewCount DESC\nLIMIT 1;",
        "question": "What is the title of the post that is owned by csgillespie and has the highest popularity?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' ORDER BY T1.ViewCount DESC LIMIT 1",
        "evidence": [
            "\"csgillespie\" is the DisplayName of user; highest popularity refers to Max(ViewCount)"
        ]
    },
    "271": {
        "reason": "To determine if bond ID `TR001_1_8` has both chlorine (`cl`) and carbon (`c`) elements, we need to:\n1. Identify the atoms connected by the bond `TR001_1_8` from the `connected` table.\n2. Retrieve the elements of these atoms from the `atom` table.\n3. Check if one atom has the element `cl` (chlorine) and the other has `c` (carbon).\n4. The query will join the `connected` table with the `atom` table twice (once for each atom in the bond) to verify the elements.",
        "sql": "SELECT \n    CASE \n        WHEN (a1.element = 'cl' AND a2.element = 'c') OR (a1.element = 'c' AND a2.element = 'cl') THEN 'Yes'\n        ELSE 'No'\n    END AS has_both_elements\nFROM \n    connected c\nJOIN \n    atom a1 ON c.atom_id = a1.atom_id\nJOIN \n    atom a2 ON c.atom_id2 = a2.atom_id\nWHERE \n    c.bond_id = 'TR001_1_8';",
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "evidence": [
            "chlorine refers to element = 'cl'; carbon refers to element = 'c'",
            "The `connected` table links atoms via bonds, requiring joins to retrieve atom details.\nTo verify elements, filter atoms connected by the bond and check their elements.\nA bond involves two atoms, so both must be checked for the required elements.",
            "To verify elements in a bond, ensure the query checks both atoms linked by the bond for the required elements.\nThe `connected` table links atoms via bonds, requiring joins to retrieve atom details for both atoms involved.\nFiltering for specific elements involves checking each atom's element attribute separately.",
            "To verify elements in a bond, ensure the query checks each atom's element separately and combines results for the bond.\nThe `connected` table links atoms via bonds, requiring joins to retrieve atom details for each atom involved.\nFiltering for specific elements involves checking each atom's element attribute individually."
        ]
    },
    "1029": {
        "reason": "To solve the question, we need to find the top 4 teams with the highest build-up play speed. The `buildUpPlaySpeed` attribute is stored in the `Team_Attributes` table, and we can join this table with the `Team` table to get the team names. The steps are as follows:\n1. Join the `Team_Attributes` table with the `Team` table using the `team_api_id` or `team_fifa_api_id`.\n2. Select the `team_long_name` (or `team_short_name`) and the `buildUpPlaySpeed` from the joined tables.\n3. Order the results by `buildUpPlaySpeed` in descending order to get the highest values first.\n4. Limit the results to the top 4 teams.",
        "sql": "SELECT t.team_long_name, ta.buildUpPlaySpeed\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nORDER BY ta.buildUpPlaySpeed DESC\nLIMIT 4;",
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4",
        "evidence": [
            "speed in which attacks are put together refers to buildUpPlaySpeed;highest build up play speed refers to MAX(buildUpPlaySpeed)",
            "buildUpPlaySpeed is stored in Team_Attributes and can be joined with Team for team details; highest values require descending order, while lowest values require ascending order.",
            "buildUpPlaySpeed is stored in Team_Attributes and can be joined with Team for team details; highest values require descending order, while lowest values require ascending order."
        ]
    },
    "348": {
        "reason": "To solve the question, we need to find the rulings for the card named 'Sublime Epiphany' with the number '74s'. The steps are as follows:\n1. First, locate the card in the 'cards' table using the name 'Sublime Epiphany' and the number '74s' to get its 'uuid'.\n2. Once we have the 'uuid', we can query the 'rulings' table to retrieve all rulings associated with that 'uuid'.\n3. The 'rulings' table contains the 'text' field, which stores the ruling information we need.",
        "sql": "SELECT r.text \nFROM rulings r \nJOIN cards c ON r.uuid = c.uuid \nWHERE c.name = 'Sublime Epiphany' AND c.number = '74s';",
        "question": "Describe the information about rulings for card named 'Sublime Epiphany' with number 74s.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'",
        "evidence": [
            "Sublime Epiphany' is name of cards; number 74s refers to number = '74s'; information refers to text;",
            "The 'rulings' table stores the text of rulings for cards, linked via the 'uuid' field. The 'cards' table's 'number' field is used to uniquely identify a card within its set."
        ]
    },
    "130": {
        "reason": "To solve the question, we need to find the number of account holders in the South Bohemia region who do not own credit cards. Here's the step-by-step reasoning:\n\n1. **Identify the South Bohemia region**: The `district` table contains region names in the `A3` column. We need to filter for 'South Bohemia'.\n\n2. **Find account holders in South Bohemia**: The `account` table is linked to the `district` table via `district_id`. We need to join these tables to find accounts in South Bohemia.\n\n3. **Identify account owners**: The `disp` table's `type` column distinguishes account owners (marked as 'OWNER') from others. We need to filter for 'OWNER' to ensure we are only considering account holders.\n\n4. **Exclude account holders with credit cards**: The `card` table is linked to the `disp` table via `disp_id`. To find account holders without credit cards, we need to ensure there is no corresponding record in the `card` table for the `disp_id` of the account owner.\n\n5. **Count the results**: Finally, we count the number of such account holders.\n\nThe query will involve joining the `district`, `account`, `disp`, and `card` tables, filtering for the South Bohemia region, account owners, and the absence of credit card records.",
        "sql": "SELECT COUNT(DISTINCT d.client_id) AS account_holders_without_cards\nFROM district di\nJOIN account a ON di.district_id = a.district_id\nJOIN disp d ON a.account_id = d.account_id\nLEFT JOIN card c ON d.disp_id = c.disp_id\nWHERE di.A3 = 'South Bohemia'\nAND d.type = 'OWNER'\nAND c.card_id IS NULL;",
        "question": "How many of the account holders in South Bohemia still do not own credit cards?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT COUNT(T3.account_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.client_id = T3.client_id WHERE T1.A3 = 'south Bohemia' AND T3.type != 'OWNER'",
        "evidence": [
            "A3 contains the region names; South Bohemia is one of region names.",
            "The `disp` table's `type` column distinguishes account owners from others; filtering for 'OWNER' ensures only account holders are considered.\nThe `card` table is not required to determine account holders without credit cards; the absence of a `disp` record linked to a card suffices.",
            "The `disp` table's `type` column includes 'OWNER' and other values; filtering for 'OWNER' ensures only account owners are considered.\nTo identify account holders without credit cards, the absence of a linked record in the `card` table is not required; instead, the `disp` table's `type` column can be used directly.",
            "The `disp` table's `type` column includes 'OWNER' and other values; filtering for 'OWNER' ensures only account owners are considered.\nTo identify account holders without credit cards, the absence of a linked record in the `card` table is not required; instead, the `disp` table's `type` column can be used directly."
        ]
    },
    "872": {
        "reason": "To solve the question, we need to find the abbreviated code of the driver who had a Q3 time of '0:01:33' in race No. 45. The steps are as follows:\n1. Identify the qualifying records for race No. 45 where the Q3 time matches '0:01:33'.\n2. Join the qualifying table with the drivers table to get the driver's code.\n3. Filter the qualifying records for the specific race and Q3 time.\n4. Retrieve the driver's code from the drivers table.",
        "sql": "SELECT d.code \nFROM qualifying q \nJOIN drivers d ON q.driverId = d.driverId \nWHERE q.raceId = 45 AND q.q3 LIKE '1:33%';",
        "question": "In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'",
        "evidence": [
            "race number refers to raceId; had the Q3 time as 0:0M:SS refers to q3 LIKE 'M:SS%'",
            "q3 time filtering requires partial matching with LIKE for minute-second format; raceId uniquely identifies a race.",
            "q3 time filtering requires partial matching with LIKE for minute-second format; raceId uniquely identifies a race.\njoin direction should prioritize qualifying table as the primary source for filtering.\npartial matching on q3 time ensures flexibility in time format variations."
        ]
    },
    "240": {
        "reason": "To solve the question, we need to list all the elements of the toxicology of the molecule \"TR004\". The schema includes tables for `atom`, `bond`, `connected`, and `molecule`. The `molecule` table contains the molecule ID and label, while the `atom` table contains the elements associated with each molecule. Since the question asks for the elements of the molecule \"TR004\", we need to query the `atom` table for all elements where the `molecule_id` is \"TR004\". The `connected` and `bond` tables are not directly relevant to this query.",
        "sql": "SELECT element FROM atom WHERE molecule_id = 'TR004';",
        "question": "List all the elements of the toxicology of the molecule \"TR004\".",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
        "evidence": [
            "TR004 is the molecule id;"
        ]
    },
    "637": {
        "reason": "To solve the question, we need to find all the tags used by Mark Meckes in his posts that do not have comments. Here's the step-by-step reasoning:\n\n1. **Identify Mark Meckes' UserId**: First, we need to find the `Id` of the user with the `DisplayName` 'Mark Meckes' from the `users` table.\n2. **Find Posts by Mark Meckes**: Using the `UserId` obtained, we can find all posts where `OwnerUserId` matches this `Id` from the `posts` table.\n3. **Filter Posts Without Comments**: From these posts, we need to filter those where `CommentCount` is 0.\n4. **Extract Tags from Posts**: For the filtered posts, we need to extract the `Tags` field, which contains the tags used in the posts.\n5. **Return Distinct Tags**: Finally, we should return the distinct tags to avoid duplicates.\n\nThe query will join the `users` and `posts` tables to achieve this.",
        "sql": "SELECT DISTINCT p.Tags\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'Mark Meckes' AND p.CommentCount = 0;",
        "error": "something went wrong, tool did not call.",
        "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
        "evidence": [
            "used by Mark Meckes refers to DisplayName = 'Mark Meckes'; Doen't have comments refers to CommentCount = 0;",
            "The `postHistory` table records edits or changes to posts, which may not directly indicate ownership or authorship.\nTo identify posts by a user, the `OwnerUserId` in the `posts` table is the correct field to use.\nThe `CommentCount` field in the `posts` table directly indicates the number of comments on a post."
        ]
    },
    "900": {
        "reason": "To solve the question, we need to identify circuits in the USA that hosted F1 races in 2006. The steps are as follows:\n1. Join the `circuits` table with the `races` table to link circuits to races.\n2. Filter the results to include only races from the year 2006 (`races.year = 2006`).\n3. Further filter the results to include only circuits located in the USA (`circuits.country = 'USA'`).\n4. Select the required columns: the name and location of the circuit (`circuits.name`, `circuits.location`) and the name of the race (`races.name`).",
        "sql": "SELECT circuits.name AS circuit_name, circuits.location, races.name AS race_name\nFROM circuits\nJOIN races ON circuits.circuitId = races.circuitId\nWHERE races.year = 2006 AND circuits.country = 'USA';",
        "question": "List circuits in USA which hosted f1 races in 2006. State the name and location of circuit and the name of the race it hosted.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.location, T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'USA' AND T2.year = 2006",
        "evidence": [
            ""
        ]
    },
    "1257": {
        "reason": "To solve the question, we need to identify patients with abnormal creatinine levels (CRE >= 1.5) and then filter those who are not yet 70 years old. The steps are:\n1. Join the `Patient` and `Laboratory` tables to access both patient age (calculated from the `Birthday` field) and creatinine levels (CRE).\n2. Filter records where CRE >= 1.5.\n3. Calculate the age of each patient by subtracting the birth year from the current year.\n4. Further filter patients whose age is less than 70.\n5. Count the number of such patients.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.CRE >= 1.5 \nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) < 70;",
        "question": "Among the patients whose creatinine level is abnormal, how many of them aren't 70 yet?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70",
        "evidence": [
            "creatinine level is abnormal refers to CRE >= 1.5; aren't 70 yet refers to SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) < 70; "
        ]
    },
    "1513": {
        "reason": "To find the country of the gas station that had the first paid customer on August 25, 2012, we need to follow these steps:\n1. Identify the earliest transaction on the specified date (2012-08-25) by checking the `Date` and `Time` fields in the `transactions_1k` table.\n2. Join the `transactions_1k` table with the `gasstations` table to get the `Country` information for the gas station involved in the earliest transaction.\n3. Order the transactions by `Date` and `Time` to find the earliest one, and limit the result to the first record.\n4. Retrieve the `Country` from the joined result.",
        "sql": "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-25'\nORDER BY t.Time ASC\nLIMIT 1;",
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "evidence": [
            "'2012/8/25' can be represented by '2012-08-25'"
        ]
    },
    "295": {
        "reason": "To solve the question, we need to find the number of atoms that belong to a molecule where the element is hydrogen (element = 'h') and the molecule is labeled as carcinogenic (label = '+'). The steps are as follows:\n1. Identify the molecule(s) with label = '+' (carcinogenic).\n2. From these molecules, find the atoms where the element is 'h' (hydrogen).\n3. Count the number of such atoms.\n\nThe query will involve joining the `molecule` table with the `atom` table to filter the atoms based on the molecule's label and the atom's element.",
        "sql": "SELECT COUNT(*) \nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'h' AND m.label = '+';",
        "question": "How many atoms belong to the molecule that element is hydrogen and labeled with carcinogenic compound?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.atom_id) AS atomnums_h FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'h'",
        "evidence": [
            "label = '+' mean molecules are carcinogenic; hydrogen refers to element = h'"
        ]
    },
    "949": {
        "reason": "To find the constructor with the highest points in any single race, we need to join the `constructorStandings` table with the `constructors` table. The `constructorStandings` table contains the points for each constructor in each race, and the `constructors` table provides the names of the constructors. By joining these tables, we can link the points to the constructor names. We then sort the results by points in descending order and limit the result to the top entry to find the constructor with the highest points.",
        "sql": "SELECT c.name, cs.points\nFROM constructorStandings cs\nJOIN constructors c ON cs.constructorId = c.constructorId\nORDER BY cs.points DESC\nLIMIT 1;",
        "question": "Which constructor has the highest point?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId ORDER BY T1.points DESC LIMIT 1",
        "evidence": [
            "",
            "The `constructorStandings` table records points per race, not cumulative points, so aggregation is unnecessary.\nTo find the constructor with the highest points in any single race, sorting by points in descending order suffices.",
            "The `constructorStandings` table tracks points per race, and the `constructors` table provides constructor names. Joining these tables links points to constructor names.",
            "The `constructorStandings` table tracks points per race, and the `constructors` table provides constructor names. Joining these tables links points to constructor names."
        ]
    },
    "993": {
        "reason": "To find the location, country, and coordinates of the Hungaroring circuit, we need to query the `circuits` table. The `name` column in this table uniquely identifies circuits, so we can filter by `name = 'Hungaroring'` to retrieve the specific details. The columns `location`, `country`, `lat`, and `lng` will provide the required information. Since `location` is optional, we include it in the query, but the other columns are guaranteed to be populated.",
        "sql": "SELECT location, country, lat, lng FROM circuits WHERE name = 'Hungaroring';",
        "question": "In which location does the Hungaroring circuit located? Also, find the country and coordinates of this circuit?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring'",
        "evidence": [
            "coordinates expressed in latitude and longitude refers to (lat, lng)",
            "The `name` column in the `circuits` table uniquely identifies circuits, and filtering by it retrieves specific circuit details.",
            "The `location` column in the `circuits` table is optional and may not always be populated, while `country`, `lat`, and `lng` are guaranteed to provide relevant details.",
            "The `location` column in the `circuits` table is optional and may not always be populated, while `country`, `lat`, and `lng` are guaranteed to provide relevant details."
        ]
    },
    "1139": {
        "reason": "To solve the question, we need to find the final score of a match that occurred on September 24, 2008, in the Belgian Jupiler League. The steps are as follows:\n1. Identify the league_id for the Belgian Jupiler League from the League table.\n2. Use the league_id to filter matches in the Match table that occurred on '2008-09-24'.\n3. Retrieve the home_team_goal and away_team_goal columns from the Match table for the filtered match.\n4. The final score will be the combination of home_team_goal and away_team_goal.",
        "sql": "SELECT home_team_goal, away_team_goal \nFROM Match \nWHERE date LIKE '2008-09-24%' \nAND league_id = (SELECT id FROM League WHERE name = 'Belgium Jupiler League');",
        "question": "What was the final score for the match on September 24, 2008, in the Belgian Jupiler League between the home team and the away team?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.home_team_goal, t2.away_team_goal FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND t2.`date` LIKE '2008-09-24%'",
        "evidence": [
            "September 24, 2008 refers to date like '2008-09-24%'; in the Belgian Jupiler League refers to League.name = 'Belgium Jupiler League'; final score for home team refers to home_team_goal; final score for away team refers to away_team_goal"
        ]
    },
    "1118": {
        "reason": "To list players who are 35 years old or older, we need to calculate their age based on their birthday. The schema provides a `Player` table with a `birthday` column. We can use the `JULIANDAY` function in SQLite to calculate the difference between the current date and the player's birthday, then convert this difference into years. Players whose age is 35 or more should be included in the result. The query will select the `player_name` from the `Player` table where the calculated age meets the condition.",
        "sql": "SELECT player_name FROM Player WHERE (JULIANDAY('now') - JULIANDAY(birthday)) / 365 >= 35;",
        "question": "List down the name of players who are 35 years old and above.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE CAST((JULIANDAY('now') - JULIANDAY(birthday)) AS REAL) / 365 >= 35",
        "evidence": [
            "35 years old and above refers to datetime(CURRENT_TIMESTAMP,'localtime') - datetime(birthday) > 34",
            "To calculate age accurately, use `JULIANDAY` for precise date differences in SQLite, converting the result to years by dividing by 365."
        ]
    },
    "781": {
        "reason": "To solve the question, we need to find the heights of heroes whose eye color is 'Amber'. The eye color is stored in the `colour` table, and the `superhero` table references the eye color via `eye_colour_id`. We will join the `superhero` table with the `colour` table on the `eye_colour_id` and filter for rows where the `colour` is 'Amber'. Finally, we will select the `height_cm` column from the `superhero` table.",
        "sql": "SELECT superhero.height_cm FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'Amber';",
        "question": "Provide the heights of the heroes whose eye colours are amber.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'",
        "evidence": [
            "heights of the heroes refers to height_cm; eye colours are amber refers to colour.colour = 'Amber' WHERE eye_colour_id = colour.id;"
        ]
    },
    "656": {
        "reason": "To solve the question, we need to find the display name of the parent post owner for the child post with the highest score. Here's the step-by-step reasoning:\n\n1. **Identify the child post with the highest score**: We need to query the `posts` table to find the child post (where `ParentId` is not null) with the maximum `Score`.\n\n2. **Retrieve the parent post details**: Once we have the child post, we use its `ParentId` to find the corresponding parent post in the `posts` table.\n\n3. **Get the display name of the parent post owner**: The parent post's `OwnerUserId` links to the `users` table, where we can find the authoritative `DisplayName` of the owner.\n\n4. **Combine these steps in a query**: We will join the `posts` table (for child and parent posts) with the `users` table to fetch the display name of the parent post owner.",
        "sql": "SELECT u.DisplayName\nFROM posts child\nJOIN posts parent ON child.ParentId = parent.Id\nJOIN users u ON parent.OwnerUserId = u.Id\nWHERE child.ParentId IS NOT NULL\nORDER BY child.Score DESC\nLIMIT 1;",
        "question": "Describe the display name of the parent ID for child post with the highest score.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts WHERE ParentId IS NOT NULL ORDER BY Score DESC LIMIT 1 )",
        "evidence": [
            "If the parent id is not null, the post is the child post; the highest score refers to MAX(Score);",
            "The `OwnerDisplayName` in the `posts` table may not always be populated; the `DisplayName` from the `users` table is the authoritative source for user display names.",
            "The `OwnerUserId` in the `posts` table links directly to the `users` table, which contains the authoritative `DisplayName` for the parent post owner.",
            "The `ParentId` in the `posts` table indicates a child post, and the highest score is determined by ordering by `Score` in descending order and limiting to one result."
        ]
    },
    "591": {
        "reason": "To solve the question, we need to find the number of users who were awarded the 'Supporter' badge during the year 2011. The steps to achieve this are:\n1. Identify the relevant table: `badges` contains information about badges awarded to users.\n2. Filter the badges where the `Name` is 'Supporter' and the `Date` falls within the year 2011.\n3. Count the distinct `UserId` values from the filtered results to get the number of unique users awarded the badge.",
        "sql": "SELECT COUNT(DISTINCT UserId) AS NumberOfUsers\nFROM badges\nWHERE Name = 'Supporter' AND strftime('%Y', Date) = '2011';",
        "question": "How many users are awarded with supporter badge during year 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE STRFTIME('%Y', Date) = '2011' AND Name = 'Supporter'",
        "evidence": [
            "\"Supporter\" is the Name of badge; in year 2011 refers to year(Date) = 2011"
        ]
    },
    "386": {
        "reason": "To solve the question, we need to perform two tasks:\n1. Count the number of cards with a 'future' frame version.\n2. List the legality statuses of these cards.\n\nFor the first task, we will query the `cards` table and filter for rows where `frameVersion` is 'future'.\nFor the second task, we will join the `cards` table with the `legalities` table on the `uuid` column to retrieve the legality statuses of these cards. The `legalities` table contains the `format` and `status` columns, which will provide the required information.",
        "sql": "-- Count the number of cards with 'future' frame version\nSELECT COUNT(*) AS future_frame_card_count\nFROM cards\nWHERE frameVersion = 'future';\n\n-- List the legality statuses of these cards\nSELECT c.name, l.format, l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.frameVersion = 'future';",
        "question": "How many cards are having future frame version and what are the legality status of these cards?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future'",
        "evidence": [
            "future frame version refers to frameVersion = 'future'; legility status refers to status = 'legal';",
            "The `frameVersion` column in the `cards` table indicates the frame type of a card, such as 'future'.\nThe `legalities` table contains the legality status of cards, linked via the `uuid` column.\nCounting cards with a specific frame version requires filtering by `frameVersion` and joining with `legalities` for status details.",
            "The `frameVersion` column in the `cards` table identifies cards with a 'future' frame, while the `legalities` table provides their status.\nCounting cards with a specific frame version requires filtering by `frameVersion` and joining with `legalities` for status details.\nThe query should focus on counting cards without grouping by status to get the total count.",
            "The query should count cards with a specific frame version without grouping by status to get the total count.\nThe `legalities` table provides status details but is not required for the count itself."
        ]
    },
    "744": {
        "reason": "To determine which publisher, DC Comics or Marvel Comics, has published more superheroes and find the difference between them, we need to:\n1. Count the number of superheroes published by DC Comics (publisher_name = 'DC Comics').\n2. Count the number of superheroes published by Marvel Comics (publisher_name = 'Marvel Comics').\n3. Calculate the difference between these two counts (Marvel Comics count - DC Comics count).\n\nThe schema includes a `superhero` table linked to the `publisher` table via `publisher_id`. We will join these tables to filter and count the superheroes for each publisher.",
        "sql": "SELECT \n    (SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics') - \n    (SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'DC Comics') AS difference;",
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "evidence": [
            "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = SUBTRACT(SUM(publisher_name = 'Marvel Comics'), SUM(publisher_name = 'DC Comics'))"
        ]
    },
    "1265": {
        "reason": "To solve the question, we need to find the number of patients who meet two conditions: \n1. They have a normal level of anti-ribonuclear protein (RNP), which is indicated by 'negative' or '0' in the Laboratory table.\n2. They have been admitted to the hospital, which is indicated by '+' in the Admission column of the Patient table.\n\nWe will join the Patient and Laboratory tables on the ID column to combine the relevant data. Then, we will filter for patients with normal RNP levels and admission status. Finally, we will count the distinct patient IDs to ensure each patient is counted only once, even if they have multiple matching records.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE (L.RNP = 'negative' OR L.RNP = '0') \nAND P.Admission = '+';",
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "evidence": [
            "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;",
            "The RNP column in the Laboratory table uses 'negative' and '0' to indicate normal levels, not '-' or '+-'.",
            "The RNP column in the Laboratory table uses 'negative' and '0' to indicate normal levels, not '-' or '+-'.\nAdmission status is stored in the Patient table with '+' indicating admission.\nDISTINCT ensures each patient is counted only once, regardless of multiple matching records.",
            "The RNP column in the Laboratory table uses 'negative' and '0' to indicate normal levels.\nAdmission status is stored in the Patient table with '+' indicating admission.\nDISTINCT ensures each patient is counted only once, regardless of multiple matching records."
        ]
    },
    "107": {
        "reason": "To solve the question, we need to find the gender of the oldest client who opened an account in the branch with the highest average salary. Here's the step-by-step reasoning:\n\n1. **Identify the branch with the highest average salary**: The `district` table contains the average salary in column `A11`. We need to find the `district_id` with the highest `A11` value.\n\n2. **Find accounts opened in this branch**: Using the `district_id` from step 1, we can find all accounts (`account_id`) in the `account` table that belong to this district.\n\n3. **Find clients associated with these accounts**: Using the `account_id` from step 2, we can find the `client_id` from the `disp` table where the `type` is 'OWNER' (assuming the owner is the primary client).\n\n4. **Find the oldest client among these clients**: Using the `client_id` from step 3, we can find the client with the earliest `birth_date` (oldest client) from the `client` table.\n\n5. **Retrieve the gender of this client**: Finally, we retrieve the `gender` of the oldest client identified in step 4.\n\nCombining these steps, we can write a query that joins the `district`, `account`, `disp`, and `client` tables to achieve the desired result.",
        "sql": "WITH highest_salary_district AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A11 DESC\n    LIMIT 1\n),\naccounts_in_district AS (\n    SELECT account_id\n    FROM account\n    WHERE district_id = (SELECT district_id FROM highest_salary_district)\n),\nclient_accounts AS (\n    SELECT client_id\n    FROM disp\n    WHERE account_id IN (SELECT account_id FROM accounts_in_district) AND type = 'OWNER'\n),\noldest_client AS (\n    SELECT client_id, gender\n    FROM client\n    WHERE client_id IN (SELECT client_id FROM client_accounts)\n    ORDER BY birth_date ASC\n    LIMIT 1\n)\nSELECT gender\nFROM oldest_client;",
        "question": "What is the gender of the oldest client who opened his/her account in the highest average salary branch?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.gender FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id ORDER BY T1.A11 DESC, T2.birth_date ASC LIMIT 1",
        "evidence": [
            "Earlier birthdate refers to older age; A11 refers to average salary"
        ]
    },
    "1225": {
        "reason": "To solve the question, we need to list and group all patients by sex for those whose total bilirubin (T-BIL) level is not within the normal range (i.e., T-BIL >= 2.0). The steps are as follows:\n1. Identify the relevant table: The `Laboratory` table contains the `T-BIL` field.\n2. Filter records where `T-BIL` is >= 2.0.\n3. Join the `Laboratory` table with the `Patient` table to get the patient's sex.\n4. Group the results by sex and patient ID to ensure each patient is listed separately.\n5. Select the required fields: patient ID and sex.",
        "sql": "SELECT P.SEX, L.ID\nFROM Laboratory L\nJOIN Patient P ON L.ID = P.ID\nWHERE L.`T-BIL` >= 2.0\nGROUP BY P.SEX, L.ID;",
        "question": "List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T1.ID,T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 GROUP BY T1.SEX,T1.ID",
        "evidence": [
            "List refers to GROUP_CONCAT(DISTINCT ID); total bilirubin (T-BIL) not within normal range refers to T-BIL > = 2.0",
            "The query requires listing individual patients grouped by sex, not concatenating IDs. The GROUP BY clause must include both sex and ID to ensure each patient is listed separately.",
            "The query requires listing individual patients grouped by sex, not concatenating IDs. The GROUP BY clause must include both sex and ID to ensure each patient is listed separately."
        ]
    },
    "1343": {
        "reason": "To solve the question, we need to find the remaining amount of the biggest budget allocated for the 'Food' category. Here's the step-by-step reasoning:\n\n1. **Identify the relevant table**: The `budget` table contains information about budgets, including the category, spent amount, remaining amount, and the total amount.\n2. **Filter for the 'Food' category**: We need to filter the budgets where the `category` is 'Food'.\n3. **Find the biggest budget**: Among the filtered budgets, we need to find the one with the highest `amount`.\n4. **Retrieve the remaining amount**: Once the biggest budget is identified, we need to retrieve its `remaining` amount.\n\nThis involves querying the `budget` table, filtering for 'Food', ordering by `amount` in descending order, and limiting the result to the top row to get the biggest budget, then selecting its `remaining` amount.",
        "sql": "SELECT remaining FROM budget WHERE category = 'Food' ORDER BY amount DESC LIMIT 1;",
        "question": "With the biggest budget for the \"Food\", what was the remaining of it?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT remaining FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget WHERE category = 'Food' )",
        "evidence": [
            "remaining of budget refers to remaining, biggest budget for 'Food' refers to MAX(budget.amount) where category = 'Food'"
        ]
    },
    "332": {
        "reason": "To solve the question, we need to find out how many molecules between 'TR004' and 'TR010' have single bonds. The steps are as follows:\n1. Identify the bond type for single bonds, which is '-' as per the tips.\n2. Filter the `bond` table for bonds where `bond_type` is '-' and `molecule_id` is between 'TR004' and 'TR010'.\n3. Count the distinct `molecule_id` values from the filtered bonds to get the number of molecules with single bonds in the specified range.",
        "sql": "SELECT COUNT(DISTINCT molecule_id) \nFROM bond \nWHERE bond_type = '-' \nAND molecule_id BETWEEN 'TR004' AND 'TR010';",
        "question": "Among the molecules between TR004 to TR010, how many of them has single bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.molecule_id BETWEEN 'TR004' AND 'TR010' AND T.bond_type = '-'",
        "evidence": [
            "single bond refers to bond_type = '-'; molecules between TR004 to TR010 refers molecule_id BETWEEN 'TR004' and 'TR010';"
        ]
    },
    "355": {
        "reason": "To find the keyword on the card 'Angel of Mercy', we need to query the `cards` table where the `name` column matches 'Angel of Mercy'. The `keywords` column in the `cards` table contains the keywords associated with the card. We will select the `keywords` column for the matching card.",
        "sql": "SELECT keywords FROM cards WHERE name = 'Angel of Mercy';",
        "question": "What is the keyword found on card 'Angel of Mercy'?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy'",
        "evidence": [
            "Angel of Mercy' is the name of card;"
        ]
    },
    "649": {
        "reason": "To solve the question, we need to find the post history counts and the last edit date for a specific post titled \"What is the best introductory Bayesian statistics textbook?\". Here's the step-by-step reasoning:\n\n1. **Identify the Post**: First, we need to find the post with the given title in the `posts` table. This will give us the `Id` of the post.\n\n2. **Retrieve Post History Counts**: Using the `Id` from the `posts` table, we can count the number of entries in the `postHistory` table that are linked to this post via the `PostId` column.\n\n3. **Retrieve Last Edit Date**: The `posts` table already stores the latest edit date in the `LastEditDate` column, so we can directly fetch this value for the identified post.\n\n4. **Combine Results**: Finally, we will combine the results to display the post history counts and the last edit date for the specified post.",
        "sql": "SELECT \n    COUNT(ph.Id) AS PostHistoryCount,\n    p.LastEditDate\nFROM \n    posts p\nLEFT JOIN \n    postHistory ph ON p.Id = ph.PostId\nWHERE \n    p.Title = 'What is the best introductory Bayesian statistics textbook?'\nGROUP BY \n    p.Id, p.LastEditDate;",
        "question": "Describe the post history counts and last edit date of the post title \"What is the best introductory Bayesian statistics textbook?\"",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.Id, T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'",
        "evidence": [
            "",
            "The `postHistory` table records edits and other changes to posts, linked via `PostId` to the `posts` table.\nTo find the latest edit date, use the `LastEditDate` column in the `posts` table, not `CreationDate` from `postHistory`.\nCounts of post history entries should be derived directly from the `postHistory` table without aggregation.",
            "The `postHistory` table tracks individual edits, while the `posts` table stores the latest edit date in `LastEditDate`.\nTo link post history entries to a specific post, use `PostId` in `postHistory` to join with `Id` in `posts`.\nFiltering by post title requires querying the `posts` table directly.",
            "The `postHistory` table contains individual edit records, while the `posts` table stores the latest edit date in `LastEditDate`.\nTo retrieve post history entries for a specific post, join `postHistory` with `posts` using `PostId` and filter by the post title in the `posts` table.\nThe `LastEditDate` should be fetched directly from the `posts` table without aggregation."
        ]
    },
    "644": {
        "reason": "To solve the question, we need to find the last edit date and last edit user ID for a specific post titled \"Detecting a given face in a database of facial images\". The relevant information is stored in the `posts` table, specifically the `LastEditDate` and `LastEditorUserId` columns. We will query the `posts` table, filtering for the post with the given title.",
        "sql": "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images';",
        "question": "Provide the last edit date and last edit user ID for the post \"Detecting a given face in a database of facial images\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images'",
        "evidence": [
            "Title = 'Detecting a given face in a database of facial images';"
        ]
    },
    "403": {
        "reason": "To calculate the percentage of cards in Spanish, we need to analyze the `foreign_data` table. The steps are as follows:\n1. Count the total number of records in the `foreign_data` table where the `language` is 'Spanish'.\n2. Count the total number of records in the `foreign_data` table.\n3. Calculate the percentage by dividing the count of Spanish records by the total count and multiplying by 100.\n4. List the names of the cards in Spanish from the `foreign_data` table.\n\nThe query will first calculate the percentage and then list the names of the Spanish cards.",
        "sql": "WITH spanish_count AS (\n    SELECT COUNT(*) AS count FROM foreign_data WHERE language = 'Spanish'\n),\ntotal_count AS (\n    SELECT COUNT(*) AS count FROM foreign_data\n)\nSELECT \n    name,\n    (SELECT (spanish_count.count * 100.0 / total_count.count) FROM spanish_count, total_count) AS percentage\nFROM \n    foreign_data\nWHERE \n    language = 'Spanish';",
        "question": "Calculate the percentage of cards in Spanish. List them by name.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
        "evidence": [
            "Spanish refer to language; Percentage refer to DIVIDE(SUM(ID where language = 'Spanish'), COUNT(id))*100",
            "Spanish translations are stored in the `foreign_data` table, not directly in the `cards` table. The percentage calculation should focus on records in `foreign_data` where `language` is 'Spanish'.",
            "The percentage calculation should directly compare the count of Spanish records to the total records in the `foreign_data` table, not distinct `uuid` values. The `name` field in the result should come from the `foreign_data` table, not joined with `cards`.",
            "The percentage calculation requires a single scalar value, not a per-row percentage. The `name` field should be listed separately from the percentage calculation."
        ]
    },
    "764": {
        "reason": "To find the superpowers of heroes with ID 1, we need to query the `hero_power` table, which links superheroes to their powers. The `hero_power` table has a `hero_id` column that references the `superhero` table and a `power_id` column that references the `superpower` table. We will join these tables to get the power names for the hero with ID 1.",
        "sql": "SELECT sp.power_name FROM hero_power hp JOIN superpower sp ON hp.power_id = sp.id WHERE hp.hero_id = 1;",
        "question": "What are the superpowers of heroes with ID 1?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1",
        "evidence": [
            "superpowers refers to power_name; heroes with ID 1 refers to hero_id = 1;"
        ]
    },
    "450": {
        "reason": "To solve the question, we need to find all cards designed by Aaron Miller (artist = 'Aaron Miller') and then count how many of these cards are incredibly powerful. According to the tips, incredibly powerful cards are those where both `cardKingdomFoilId` and `cardKingdomId` are not null. The steps are:\n1. Filter the `cards` table for records where `artist` is 'Aaron Miller'.\n2. From these records, count those where both `cardKingdomFoilId` and `cardKingdomId` are not null.\n3. The result will give the number of incredibly powerful cards designed by Aaron Miller.",
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'Aaron Miller' \nAND cardKingdomFoilId IS NOT NULL \nAND cardKingdomId IS NOT NULL;",
        "question": "Of all the cards that are designed by Aaron Miller, how many of them are incredibly powerful?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) FROM cards",
        "evidence": [
            "designed by Aaron Miller refers to artist = 'Aaron Miller'; are icredibily powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null"
        ]
    },
    "1485": {
        "reason": "To solve the question, we need to compare the consumption of customer 7 and customer 5 in April 2013 (represented as '201304' in the `yearmonth` table). The steps are as follows:\n1. Retrieve the consumption value for customer 7 in April 2013.\n2. Retrieve the consumption value for customer 5 in April 2013.\n3. Calculate the difference between the two consumption values to determine how much more customer 7 was consuming compared to customer 5.",
        "sql": "SELECT \n    (SELECT Consumption FROM yearmonth WHERE CustomerID = 7 AND Date = '201304') - \n    (SELECT Consumption FROM yearmonth WHERE CustomerID = 5 AND Date = '201304') AS ConsumptionDifference;",
        "question": "How much more was customer 7 consuming in April 2013 than customer 5?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0)) FROM yearmonth WHERE Date = '201304'",
        "evidence": [
            "April 2013 refers to 201304 in the yearmonth.date"
        ]
    },
    "70": {
        "reason": "To solve the question, we need to count the number of active and closed District Community Day Schools in Alpine County. The steps are as follows:\n1. Identify the relevant table: `schools` contains the necessary fields (`StatusType`, `County`, `SOC`).\n2. Filter schools where `County` is 'Alpine' and `SOC` is 69 (District Community Day Schools).\n3. Group the results by `StatusType` to count active and closed schools separately.\n4. Use the `COUNT` function to aggregate the results.",
        "sql": "SELECT StatusType, COUNT(*) AS SchoolCount\nFROM schools\nWHERE County = 'Alpine' AND SOC = 69\nGROUP BY StatusType;",
        "question": "How many active and closed District Community Day Schools are there in the county of Alpine?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69 AND County = 'Alpine'",
        "evidence": [
            "",
            "The `SOC` field in the `schools` table identifies the type of school, such as District Community Day Schools, using specific codes like 69.",
            "The `StatusType` field in the `schools` table includes values like 'Active' and 'Closed' to indicate school status.\nThe `SOC` field uses numeric codes (e.g., 69) to identify school types, not string values.\nAggregation can be simplified by directly counting schools meeting the criteria without grouping.",
            "The `SOC` field in the `schools` table uses numeric codes (e.g., 69) for school types, not string values.\nThe `StatusType` field in the `schools` table includes values like 'Active' and 'Closed' for filtering school status.\nAggregation can be simplified by directly counting schools meeting the criteria without grouping."
        ]
    },
    "605": {
        "reason": "To find out how many users obtained the \"Announcer\" badge, we need to query the `badges` table. The `Name` column in the `badges` table contains the badge names, and the `UserId` column identifies the users who obtained the badges. We will count the distinct `UserId` values where the `Name` is \"Announcer\" to ensure we count each user only once, even if they obtained the badge multiple times.",
        "sql": "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Announcer';",
        "question": "How many users obtained the \"Announcer\" badge?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE Name = 'Announcer'",
        "evidence": [
            "\"Announcer\" is the Name of badge; user refers to UserId",
            "The `Id` column in the `badges` table uniquely identifies each badge entry, while `UserId` links to the user who obtained it. Counting `Id` gives the total number of badge instances, whereas counting `UserId` gives the number of unique users.",
            "The `Id` column in the `badges` table represents each unique badge instance, while `UserId` links to the user who obtained it. Counting `Id` gives the total number of badge instances, whereas counting `UserId` gives the number of unique users.",
            "The `Id` column in the `badges` table represents each unique badge instance, while `UserId` links to the user who obtained it. Counting `Id` gives the total number of badge instances, whereas counting `UserId` gives the number of unique users."
        ]
    },
    "504": {
        "reason": "To solve the question, we need to find the number of cards in the set 'World Championship Decks 2004' with a converted mana cost of '3'. This involves the following steps:\n1. Identify the set code for 'World Championship Decks 2004' from the 'sets' table.\n2. Use the set code to filter cards in the 'cards' table that belong to this set.\n3. Further filter these cards to only include those with a converted mana cost of '3'.\n4. Count the number of such cards.",
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT code FROM sets WHERE name = 'World Championship Decks 2004') \nAND convertedManaCost = 3;",
        "question": "How many cards are there in the set 'World Championship Decks 2004' with the converted mana cost as '3'.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE setCode IN ( SELECT code FROM sets WHERE name = 'World Championship Decks 2004' ) AND convertedManaCost = 3",
        "evidence": [
            "the set 'World Championship Decks 2004' refers to name = 'World Championship Decks 2004'"
        ]
    },
    "1109": {
        "reason": "To solve the question, we need to find the build-up play dribbling class for the team with the short name \"LEI\" on the date \"2015-09-10\". The steps are as follows:\n1. Identify the team with the short name \"LEI\" from the `Team` table to get its `team_api_id`.\n2. Use the `team_api_id` to join with the `Team_Attributes` table to retrieve the `buildUpPlayDribblingClass`.\n3. Filter the results to only include records where the date matches \"2015-09-10\" (ignoring the time component).",
        "sql": "SELECT ta.buildUpPlayDribblingClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_short_name = 'LEI' \nAND SUBSTR(ta.date, 1, 10) = '2015-09-10';",
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "evidence": [
            "\"LEI\" refers to team_short_name = 'LEI'; on 2015/9/10 refers to\u00a0 date = '2015-09-10 00:00:00'",
            "The date comparison should use SUBSTR to match only the date part, ignoring the time component.",
            "The `Team_Attributes` table stores team-specific attributes, including `buildUpPlayDribblingClass`, which can be retrieved by joining with the `Team` table using `team_api_id`."
        ]
    },
    "855": {
        "reason": "To find information about races held at the Sepang International Circuit, we need to:\n1. Identify the circuit in the `circuits` table where the name is 'Sepang International Circuit'.\n2. Join the `circuits` table with the `races` table to get all races held at this circuit.\n3. Retrieve the URLs from the `races` table, as these URLs provide specific race details.\n\nThe query will filter the `circuits` table for the Sepang International Circuit, join it with the `races` table, and return the race URLs.",
        "sql": "SELECT r.url\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Sepang International Circuit';",
        "question": "Where can I find the information about the races held on Sepang International Circuit?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "evidence": [
            "information about races refers to url;",
            "The `url` field in the `circuits` table provides direct links to circuit information, while the `url` in the `races` table links to specific race details.",
            "The `url` field in the `circuits` table provides direct links to circuit information, while the `url` in the `races` table links to specific race details.\nTo retrieve circuit-specific URLs, the query should focus on the `circuits` table and join with `races` to ensure the circuit is referenced.",
            "The `url` field in the `circuits` table provides direct links to circuit information, while the `url` in the `races` table links to specific race details.\nTo retrieve circuit-specific URLs, the query should focus on the `circuits` table and join with `races` to ensure the circuit is referenced."
        ]
    },
    "1015": {
        "reason": "1. Identify the circuitId for the Austrian Grand Prix Circuit from the circuits table.\n2. Join the races, results, and circuits tables to filter races held at this circuit.\n3. Parse the FastestLapTime into numerical seconds for accurate comparison.\n4. Compare the parsed times to find the minimum value, representing the fastest lap record.\n5. Retrieve the race details associated with this minimum time.",
        "sql": "WITH austrian_circuit AS (\n    SELECT circuitId FROM circuits WHERE name = 'Austrian Grand Prix Circuit'\n),\nrace_lap_records AS (\n    SELECT r.raceId, r.year, r.name AS race_name, res.fastestLapTime\n    FROM races r\n    JOIN results res ON r.raceId = res.raceId\n    WHERE r.circuitId = (SELECT circuitId FROM austrian_circuit)\n    AND res.fastestLapTime IS NOT NULL\n)\nSELECT raceId, year, race_name, fastestLapTime\nFROM race_lap_records\nWHERE fastestLapTime = (SELECT MIN(fastestLapTime) FROM race_lap_records);",
        "question": "In which Formula_1 race was the lap record for the Austrian Grand Prix Circuit set?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T2.name FROM races AS T2 INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN results AS T1 on T2.raceId = T1.raceId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix'",
        "evidence": [
            "lap record means the fastest time recorded which refers to time",
            "The fastest lap time is stored in the results table under the column FastestLapTime, not in the races table.\nTo compare lap times accurately, the FastestLapTime must be converted into a numerical format (e.g., seconds) for proper aggregation and comparison.",
            "The FastestLapTime in the results table is stored as a text string in the format 'MM:SS.sss' and must be converted to a numerical value (seconds) for accurate comparison.\nTo identify the fastest lap record, the conversion of FastestLapTime to seconds is necessary before aggregation and comparison.",
            "The FastestLapTime in the results table must be parsed into numerical seconds for accurate comparison, involving substring extraction and arithmetic operations.\nTo identify the fastest lap record, the parsed numerical value must be compared to find the minimum time.\nThe race name in the races table corresponds to the circuit name in the circuits table, requiring a join to filter races by circuit."
        ]
    },
    "439": {
        "reason": "To find the set name of the set with the code \"ALL\", we need to query the `sets` table. The `sets` table contains the `name` column, which stores the name of the set, and the `code` column, which stores the set code. We will filter the records where the `code` is \"ALL\" and retrieve the corresponding `name`.",
        "sql": "SELECT name FROM sets WHERE code = 'ALL';",
        "question": "List out the set name of the set code \"ALL\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM sets WHERE code = 'ALL'",
        "evidence": [
            ""
        ]
    },
    "1504": {
        "reason": "To find the average total price of transactions in January 2012, we need to:\n1. Filter the transactions from the `transactions_1k` table where the `Date` falls within January 2012.\n2. Calculate the total price for each transaction by multiplying `Amount` and `Price`.\n3. Compute the average of these total prices.",
        "sql": "SELECT AVG(Amount * Price) AS average_total_price\nFROM transactions_1k\nWHERE strftime('%Y-%m', Date) = '2012-01';",
        "question": "What is the average total price of the transactions taken place in January, 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(Amount) FROM transactions_1k WHERE Date LIKE '2012-01%'",
        "evidence": [
            "In January, 2012 means Date contains '2012-01'"
        ]
    },
    "323": {
        "reason": "To determine if the molecule TR000 is carcinogenic, we need to analyze the data in the provided tables. However, the schema does not include any column or table that directly indicates whether a molecule is carcinogenic. The `molecule` table has a `label` column, but it is unclear if this label includes information about carcinogenicity. Without additional data or a specific column indicating carcinogenicity, it is not possible to determine if molecule TR000 is carcinogenic based on the given schema.",
        "sql": "-- The schema does not provide any information about carcinogenicity, so the query cannot determine if molecule TR000 is carcinogenic.\n-- The following query retrieves the label of molecule TR000, but it does not confirm carcinogenicity.\nSELECT label FROM molecule WHERE molecule_id = 'TR000';",
        "question": "Is molecule TR000 is carcinogenic or not?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT label FROM molecule AS T WHERE T.molecule_id = 'TR000'",
        "evidence": [
            "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1138": {
        "reason": "To determine the country where the Poland Ekstraklasa took place, we need to query the `League` table, which contains the league names and their associated country IDs. The `Country` table holds the country names. By joining these two tables, we can find the country name corresponding to the league named 'Poland Ekstraklasa'.",
        "sql": "SELECT c.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE l.name = 'Poland Ekstraklasa';",
        "question": "In what country did the Poland Ekstraklasa take place?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT name FROM Country WHERE id IN ( SELECT country_id FROM League WHERE name = 'Poland Ekstraklasa' )",
        "evidence": [
            ""
        ]
    },
    "1367": {
        "reason": "To determine which college most members go to, we need to analyze the `member` table and its relationship with the `major` table. The `member` table has a foreign key `link_to_major` that references the `major_id` in the `major` table. The `major` table includes a `college` column. The goal is to count the number of members associated with each college and then identify the college with the highest count. This involves joining the `member` and `major` tables, grouping by the `college` column, counting the members, and then selecting the college with the maximum count.",
        "sql": "SELECT m.college\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nGROUP BY m.college\nORDER BY COUNT(mb.member_id) DESC\nLIMIT 1;",
        "question": "Which college do most of the members go to?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "evidence": [
            "college most members go refers to MAX(COUNT(major.college))"
        ]
    },
    "1372": {
        "reason": "To find out when the member Casey Mason received income, we need to:\n1. Identify the member_id of Casey Mason from the member table using their first and last name.\n2. Use this member_id to query the income table for the date_received field.\n3. Join the member and income tables on the link_to_member field to ensure we are looking at the correct member's income records.",
        "sql": "SELECT i.date_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.first_name = 'Casey' AND m.last_name = 'Mason';",
        "question": "When did the member, Casey Mason, received the income?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "evidence": [
            "when the income was received refers to date_received"
        ]
    },
    "827": {
        "reason": "To solve the question, we need to find the average height of non-human superheroes published by Dark Horse Comics. Here's the step-by-step reasoning:\n\n1. **Identify the publisher**: First, we need to find the publisher_id for \"Dark Horse Comics\" from the `publisher` table.\n2. **Filter non-human superheroes**: We need to exclude superheroes whose race is \"Human\" by checking the `race` table.\n3. **Join tables**: We will join the `superhero` table with the `publisher` and `race` tables to filter the required records.\n4. **Calculate average height**: Finally, we will calculate the average height (height_cm) of the filtered superheroes.\n\nThe query will involve:\n- Joining `superhero` with `publisher` to filter by publisher_name.\n- Joining `superhero` with `race` to exclude \"Human\" race.\n- Using the AVG function to compute the average height.",
        "sql": "SELECT AVG(s.height_cm) AS average_height\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN race r ON s.race_id = r.id\nWHERE p.publisher_name = 'Dark Horse Comics'\nAND r.race != 'Human';",
        "question": "What is the average height of a non-human superhero in Dark Horse Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.race != 'Human'",
        "evidence": [
            "average = AVG(height_cm); non-human superhero refers to race <> 'Human'; Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';"
        ]
    },
    "164": {
        "reason": "To find out who placed the order with the ID 32423, we need to trace the path from the `order` table to the `client` table. Here's the step-by-step reasoning:\n\n1. Start with the `order` table to identify the order with `order_id = 32423`.\n2. From the `order` table, join with the `account` table using `account_id` to link the order to an account.\n3. From the `account` table, join with the `disp` table using `account_id` to link the account to a client (via `disp`).\n4. From the `disp` table, join with the `client` table using `client_id` to get the client details.\n5. Finally, retrieve the client's information (e.g., `client_id`, `gender`, `birth_date`) to identify who placed the order.",
        "sql": "SELECT c.client_id, c.gender, c.birth_date\nFROM `order` o\nJOIN account a ON o.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE o.order_id = 32423;",
        "question": "Who placed the order with the id 32423?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT T3.client_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T4.account_id = T2.account_id  INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE T1.order_id = 32423",
        "evidence": [
            "",
            "The `account` table acts as an intermediary between `order` and `disp`, requiring an additional join to link `order` to `disp` via `account`.",
            "The `disp` table links accounts to clients, and its `type` column distinguishes between owners and users of the account.",
            "The `disp` table's `type` column is not required for filtering when linking `order` to `client` via `account` and `disp`."
        ]
    },
    "903": {
        "reason": "To determine how many times Michael Schumacher won races hosted at the Sepang International Circuit, we need to follow these steps:\n1. Identify the `circuitId` for the Sepang International Circuit from the `circuits` table.\n2. Identify the `driverId` for Michael Schumacher from the `drivers` table.\n3. Join the `races` table with the `driverStandings` table to find races held at the Sepang International Circuit where Michael Schumacher had wins (`wins` column in `driverStandings`).\n4. Sum the `wins` column for these races to get the total number of wins.",
        "sql": "SELECT SUM(ds.wins) AS total_wins\nFROM driverStandings ds\nJOIN races r ON ds.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nJOIN drivers d ON ds.driverId = d.driverId\nWHERE c.name = 'Sepang International Circuit' AND d.forename = 'Michael' AND d.surname = 'Schumacher';",
        "question": "How many times did Michael Schumacher won from races hosted in Sepang International Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.wins) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId INNER JOIN circuits AS T4 ON T4.circuitId = T3.circuitId WHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher' AND T4.name = 'Sepang International Circuit'",
        "evidence": [
            "win from races refers to max(points)",
            "The `driverStandings` table records the number of wins per driver per race, which is more accurate for counting wins than checking position in the `results` table.\nTo count wins, use the `wins` column in `driverStandings` instead of filtering for position in `results`."
        ]
    },
    "85": {
        "reason": "To solve the question, we need to find the \"Percent (%) Eligible Free (K-12)\" for schools administered by an administrator whose first name is \"Alusine\". The steps are as follows:\n1. Identify the schools where the primary administrator's first name (`AdmFName1`) is \"Alusine\" from the `schools` table.\n2. Join the `schools` table with the `frpm` table using the `CDSCode` to access the relevant data for calculating the percentage.\n3. Calculate the percentage using the formula: `(Free Meal Count (K-12) / Enrollment (K-12)) * 100`.\n4. Include the `District Code` from the `frpm` table in the output.",
        "sql": "SELECT f.\"District Code\", (f.\"Free Meal Count (K-12)\" / f.\"Enrollment (K-12)\") * 100 AS \"Percent (%) Eligible Free (K-12)\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.AdmFName1 = 'Alusine';",
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "evidence": [
            "Percent (%) Eligible Free (K-12) = `Free Meal Count (K-12)` / `Enrollment (K-12)` * 100%",
            "The `AdmFName1` field in the `schools` table specifically identifies the primary administrator's first name, while `AdmFName2` and `AdmFName3` are optional fields for additional administrators.\nThe calculation for `Percent (%) Eligible Free (K-12)` should directly multiply the numerator by 100 before division to ensure correct percentage representation.",
            "The calculation for `Percent (%) Eligible Free (K-12)` should prioritize multiplication before division to avoid integer division issues.\nThe `District Code` is directly available in the `frpm` table and should be included in the output.",
            "The `Percent (%) Eligible Free (K-12)` calculation should multiply the numerator by 100 before division to avoid integer division issues.\nThe `District Code` is directly available in the `frpm` table and should be included in the output."
        ]
    },
    "1432": {
        "reason": "To solve the question, we need to calculate the percentage of income records with an amount of 50 among members who have a t-shirt size of 'Medium'. The steps are as follows:\n1. Filter members with t-shirt size 'Medium'.\n2. Join these members with their income records.\n3. Count the total number of income records for these members.\n4. Count the number of income records with an amount of 50 for these members.\n5. Calculate the percentage by dividing the count of income records with amount 50 by the total count of income records and multiplying by 100.\n6. Ensure the position of the member is 'Member' as per the tip.",
        "sql": "SELECT \n    (COUNT(CASE WHEN i.amount = 50 THEN 1 END) * 100.0 / COUNT(i.income_id)) AS percentage\nFROM \n    member m\nJOIN \n    income i ON m.member_id = i.link_to_member\nWHERE \n    m.t_shirt_size = 'Medium' AND m.position = 'Member';",
        "question": "Among the members with t-shirt size of medium, what is the percentage of the amount 50 received by the Student_Club?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) AS REAL) * 100 / COUNT(T2.income_id) FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium'",
        "evidence": [
            "t_shirt_size = 'Medium' where position = 'Member'; percentage = DIVIDE(COUNT(amount = 50), COUNT(member_id)) * 100",
            "The percentage calculation should focus on income records linked to members, not just members. The filter for position = 'Member' is required to align with the intent."
        ]
    },
    "1040": {
        "reason": "To solve the question, we need to find the top 10 players whose heights are above 180 cm, ordered by their average heading accuracy in descending order. Here's the step-by-step reasoning:\n\n1. **Filter Players by Height**: We need to join the `Player` table with the `Player_Attributes` table to access both the height and heading accuracy data. We will filter players whose height is greater than 180 cm.\n\n2. **Calculate Average Heading Accuracy**: For each player, we will calculate the average heading accuracy by summing the `heading_accuracy` values and dividing by the count of records for that player. This avoids using the `AVG` function directly, as per the tips.\n\n3. **Group by Player ID**: We will group the results by the player's primary key (`id` in the `Player` table) to ensure unique player records are considered.\n\n4. **Order by Average Heading Accuracy**: The results will be ordered by the calculated average heading accuracy in descending order.\n\n5. **Limit to Top 10**: Finally, we will limit the results to the top 10 players.",
        "sql": "SELECT p.player_name, SUM(pa.heading_accuracy) / COUNT(pa.player_fifa_api_id) AS avg_heading_accuracy\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height > 180\nGROUP BY p.id\nORDER BY avg_heading_accuracy DESC\nLIMIT 10;",
        "question": "List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 GROUP BY t1.id ORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.`player_fifa_api_id`) DESC LIMIT 10",
        "evidence": [
            "heights are above 180 refers to Player.height > 180; average heading accuracy = DIVIDE(SUM(heading_accuracy), COUNT(player_fifa_api_id));",
            "The average heading accuracy is calculated by dividing the sum of heading_accuracy by the count of player_fifa_api_id, not using the AVG function directly.\nGrouping should be done by player_id to ensure unique player records are considered.\nThe ORDER BY clause must use the calculated average explicitly.",
            "The GROUP BY clause must use the primary key (id) of the Player table to ensure unique player records are considered.\nThe ORDER BY clause should explicitly cast the division result to REAL for accurate numerical sorting.",
            "The GROUP BY clause must reference the primary key (id) of the Player table to ensure unique player records are considered.\nThe ORDER BY clause should explicitly cast the division result to REAL for accurate numerical sorting."
        ]
    },
    "1145": {
        "reason": "To solve the question, we need to identify the top 4 leagues with the most games in the 2015-2016 season. The steps are as follows:\n1. Filter the `Match` table for the season '2015/2016'.\n2. Join the `Match` table with the `League` table using `league_id` to get the league names.\n3. Group the results by `League.name` to count the number of games per league.\n4. Order the results by the count of games in descending order to find the leagues with the most games.\n5. Limit the results to the top 4 leagues.",
        "sql": "SELECT League.name, COUNT(Match.id) AS game_count\nFROM Match\nJOIN League ON Match.league_id = League.id\nWHERE Match.season = '2015/2016'\nGROUP BY League.name\nORDER BY game_count DESC\nLIMIT 4;",
        "question": "Which top 4 leagues had the most games in the 2015-2016 season?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' GROUP BY t1.name ORDER BY COUNT(t2.id) DESC LIMIT 4",
        "evidence": [
            "in the 2015-2016 season refers to season = '2015/2016'; league with most games refers to League.name where MAX(COUNT(id))",
            "To identify leagues with the most games, group by `League.name` instead of `league_id` to ensure the count is tied to the league name directly.",
            "To count games per league, join `Match` with `League` using `league_id` and group by `League.name` for accurate league identification.",
            "To retrieve league names, use `League.name` directly in the SELECT clause instead of referencing it through an alias.\nEnsure the GROUP BY clause aligns with the SELECT clause to avoid ambiguity in aggregation.\nThe ORDER BY clause should reference the aggregated count directly for clarity."
        ]
    },
    "1446": {
        "reason": "To calculate the percentage of zip codes that are PO boxes, we need to:\n1. Count the total number of zip codes in the `zip_code` table.\n2. Count the number of zip codes where the `type` is 'PO Box'.\n3. Divide the count of PO Box zip codes by the total count of zip codes and multiply by 100 to get the percentage.\n\nThe tip provided suggests using the formula `DIVIDE(SUM(type = 'PO Box'), COUNT(zip_code)) * 100`, which aligns with this logic. In SQLite, we can use `SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END)` to count the PO Box zip codes and `COUNT(zip_code)` for the total count.",
        "sql": "SELECT (SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) * 100.0 / COUNT(zip_code)) AS percentage_po_boxes FROM zip_code;",
        "question": "Calculate the percentage of zip codes that are PO boxes.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(zip_code) FROM zip_code",
        "evidence": [
            "DIVIDE(SUM(type = 'PO Box'), COUNT(zip_code)) * 100"
        ]
    },
    "62": {
        "reason": "To solve the question, we need to find the total number of non-chartered schools in Los Angeles County where the percentage of eligible free meals for grades K-12 is less than 0.18%. Here's the step-by-step reasoning:\n\n1. **Identify Non-Chartered Schools**: Non-chartered schools are those where the `Charter` field is 0 in the `schools` table.\n2. **Filter by County**: We need to filter schools located in Los Angeles County. This can be done by checking the `County` field in the `schools` table.\n3. **Calculate Eligible Free Meal Percentage**: The percentage of eligible free meals for K-12 is given by the formula `(`Free Meal Count (K-12)` * 100 / `Enrollment (K-12)`)`. We need to ensure this percentage is less than 0.18%.\n4. **Join Tables**: The `frpm` table contains the necessary fields for calculating the percentage, and it is linked to the `schools` table via the `CDSCode` field.\n5. **Count the Schools**: Finally, we count the number of schools that meet all the above criteria.\n\nThe query will join the `schools` and `frpm` tables, apply the filters, and count the results.",
        "sql": "SELECT COUNT(*) AS TotalNonCharteredSchools\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.Charter = 0\nAND s.County = 'Los Angeles'\nAND (f.[Free Meal Count (K-12)] * 100.0 / f.[Enrollment (K-12)]) < 0.18;",
        "question": "What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.School) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.Charter = 0 AND CAST(T1.`Free Meal Count (K-12)` AS REAL) * 100 / T1.`Enrollment (K-12)` < 0.18",
        "evidence": [
            "non-chartered schools refer to schools whose Charter = 0; K-12 means grades 1 through 12; percent of eligible free rate for K-12 = `Free Meal Count (K-12)` * 100 / `Enrollment (K-12)`"
        ]
    },
    "1278": {
        "reason": "To solve the question, we need to find the number of patients with a normal level of IGG (900 < IGG < 2000) who were admitted to the hospital (Admission = '+'). The steps are as follows:\n1. Join the `Patient` and `Laboratory` tables on the `ID` field to combine patient and laboratory data.\n2. Filter the records to include only those where the `IGG` level is between 900 and 2000.\n3. Further filter these records to include only patients with `Admission = '+'`.\n4. Count the distinct patient IDs to get the number of such patients.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nINNER JOIN Laboratory L ON P.ID = L.ID\nWHERE L.IGG > 900 AND L.IGG < 2000 AND P.Admission = '+';",
        "question": "Of the patients with an normal level of IGG, how many of them admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG > 900 AND T2.IGG <2000 AND  T1.Admission = '+'",
        "evidence": [
            "normal level of IGG refers to 900 < IGG < 2000; admitted to the hospital refers to Admission = '+';",
            "The Laboratory table contains multiple entries per patient, so filtering by IGG levels requires ensuring the latest or relevant entry is considered.",
            "The query should directly join the Patient and Laboratory tables without subqueries for filtering IGG levels, as the latest entry is not required for this specific condition.",
            "The query should use INNER JOIN to ensure only matching records from both tables are included, as the question requires data from both Patient and Laboratory tables."
        ]
    },
    "1328": {
        "reason": "To solve the question, we need to find the last names of all students who majored in 'Law and Constitutional Studies'. This involves the following steps:\n1. Identify the major_id for 'Law and Constitutional Studies' from the 'major' table.\n2. Use this major_id to find all members (students) in the 'member' table who have this major_id linked to them.\n3. Retrieve the 'last_name' of these members.",
        "sql": "SELECT m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Law and Constitutional Studies';",
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "evidence": [
            "'Law and Constitutional Studies' is the major name"
        ]
    },
    "122": {
        "reason": "To find the district and region for loan ID '4990', we need to follow these steps:\n1. Identify the `account_id` associated with the loan ID '4990' from the `loan` table.\n2. Use the `account_id` to find the `district_id` from the `account` table.\n3. Use the `district_id` to retrieve the district name (`A2`) and region (`A3`) from the `district` table.\n\nThe query will involve joining the `loan`, `account`, and `district` tables to fetch the required information.",
        "sql": "SELECT d.A2 AS district, d.A3 AS region\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.loan_id = 4990;",
        "question": "State the district and region for loan ID '4990'.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.loan_id = 4990",
        "evidence": [
            "A2, A3 contains the information about district and region respectively."
        ]
    },
    "904": {
        "reason": "To find the race and year in which Michael Schumacher had his fastest lap, we need to follow these steps:\n1. Identify Michael Schumacher's driverId from the drivers table using his forename and surname.\n2. Join the lapTimes table with the races table to get the race details (year and name) for each lap.\n3. Filter the lapTimes records to only include those where the driverId matches Michael Schumacher's.\n4. Order the results by milliseconds in ascending order to find the fastest lap (lowest milliseconds).\n5. Limit the result to the top record to get the fastest lap.\n6. Select the race name and year from the races table for the identified fastest lap.",
        "sql": "SELECT r.name AS race_name, r.year \nFROM lapTimes lt \nJOIN races r ON lt.raceId = r.raceId \nJOIN drivers d ON lt.driverId = d.driverId \nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher' \nORDER BY lt.milliseconds ASC \nLIMIT 1;",
        "question": "State the race and year of race in which Michael Schumacher had his fastest lap.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' ORDER BY T2.milliseconds ASC LIMIT 1",
        "evidence": [
            "fastest lap refers to min(milliseconds); Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
            "fastest lap is determined by the minimum milliseconds in the lapTimes table, not the results table.\nTo find the fastest lap, join lapTimes with races and drivers, then order by milliseconds.\nThe fastest lap is the record with the lowest milliseconds value."
        ]
    },
    "501": {
        "reason": "To solve the question, we need to find the card name in the set 'Journey into Nyx Hero's Path' with the highest converted mana cost. The steps are as follows:\n1. Identify the set code for 'Journey into Nyx Hero's Path' from the 'sets' table.\n2. Use this set code to filter cards in the 'cards' table that belong to this set.\n3. Among these cards, find the one with the highest 'convertedManaCost'.\n4. Retrieve the 'name' of this card.\n\nThe query will involve joining the 'cards' table with the 'sets' table to filter cards by the set name, then ordering by 'convertedManaCost' in descending order and limiting the result to the top entry.",
        "sql": "SELECT c.name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Journey into Nyx Hero''s Path'\nORDER BY c.convertedManaCost DESC\nLIMIT 1;",
        "question": "Which card name in the set 'Journey into Nyx Hero's Path' has the highest converted mana cost.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Journey into Nyx Hero''s Path' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "evidence": [
            "set 'Journey into Nyx Hero's Path' refers to name = 'Journey into Nyx Hero''s Path'"
        ]
    },
    "280": {
        "reason": "To solve the question, we need to enumerate the bond IDs of triple bond type molecules and determine if they are carcinogenic or not. The steps are as follows:\n1. Identify bonds with `bond_type = '#'` (triple bond) from the `bond` table.\n2. For each such bond, check the `molecule_id` it belongs to.\n3. Use the `molecule_id` to look up the `label` in the `molecule` table to determine if the molecule is carcinogenic (`label = '+'`) or non-carcinogenic (`label = '-'`).\n4. Combine this information to list the bond IDs and their carcinogenic status.",
        "sql": "SELECT b.bond_id, m.label AS carcinogenic_status\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '#';",
        "question": "Enumerate the bond ID of triple bond type molecules and tell me if they are carcinogenic or not.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.bond_id, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "evidence": [
            "triple bond refers to bond_type = '#'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1070": {
        "reason": "To determine which country the league 'Italy Serie A' is from, we need to query the `League` table, which contains the `name` of the league and a `country_id` that references the `Country` table. By joining these two tables, we can retrieve the country name associated with the league 'Italy Serie A'.",
        "sql": "SELECT c.name AS country_name\nFROM League l\nJOIN Country c ON l.country_id = c.id\nWHERE l.name = 'Italy Serie A';",
        "question": "Which country is the league Italy Serie A from?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Italy Serie A'",
        "evidence": [
            "Italy Serie A from refers to League.name = 'Italy Serie A';"
        ]
    },
    "585": {
        "reason": "To solve the question, we need to find the total bounty amount of posts titled about 'data'. The steps are as follows:\n1. Identify posts with titles containing the word 'data' from the `posts` table.\n2. Join these posts with the `votes` table to find the bounty amounts associated with these posts.\n3. Sum the bounty amounts (`BountyAmount`) from the `votes` table for these posts.\n\nThe query will involve filtering the `posts` table for titles containing 'data', joining with the `votes` table, and then summing the bounty amounts.",
        "sql": "SELECT SUM(v.BountyAmount) AS TotalBountyAmount\nFROM posts p\nJOIN votes v ON p.Id = v.PostId\nWHERE p.Title LIKE '%data%';",
        "question": "How much is the total bounty amount of the post titled about 'data'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.BountyAmount) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data%'",
        "evidence": [
            "About data means the title contains 'data'; total bounty Amount refers to Sum(BountyAmount)"
        ]
    },
    "127": {
        "reason": "To list the account IDs with monthly issuance of statements, we need to look at the `account` table where the `frequency` column indicates monthly issuance. The tip provided mentions that 'POPLATEK MESICNE' stands for monthly issuance, so we should filter the `account` table for records where `frequency` is 'POPLATEK MESICNE'.",
        "sql": "SELECT account_id FROM account WHERE frequency = 'POPLATEK MESICNE';",
        "question": "List the account IDs with monthly issuance of statements.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT account_id FROM account WHERE Frequency = 'POPLATEK MESICNE'",
        "evidence": [
            "'POPLATEK MESICNE' stands for monthly issuance"
        ]
    },
    "1312": {
        "reason": "To find Angela Sanders's major, we need to follow these steps:\n1. Identify Angela Sanders in the `member` table using her first and last name.\n2. Retrieve the `link_to_major` field from her record, which references the `major_id` in the `major` table.\n3. Join the `member` table with the `major` table to get the `major_name` corresponding to the `major_id`.",
        "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Angela' AND mb.last_name = 'Sanders';",
        "question": "What's Angela Sanders's major?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "evidence": [
            "Angela Sanders is the full name; full name refers to first_name, last_name; major refers to major_name."
        ]
    },
    "44": {
        "reason": "To solve the question, we need to find the school with the highest number of test takers whose total SAT scores are greater or equal to 1500 (NumGE1500). Once we identify this school, we need to retrieve its average writing score (AvgScrWrite) and the city where it is located (City from the schools table). The steps are as follows:\n1. Join the satscores table with the schools table on the CDSCode/cds field to access the city information.\n2. Identify the school with the highest NumGE1500 value.\n3. Retrieve the AvgScrWrite and City for this school.",
        "sql": "SELECT s.AvgScrWrite, sc.City\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE s.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);",
        "question": "What is the average writing score of the school who has the highest number of test takers whose total SAT sscores are greater or equal to 1500? Indicate the city to where the school is situated.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.AvgScrWrite, T2.City FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "evidence": [
            ""
        ]
    },
    "661": {
        "reason": "To determine the age of the most influential user, we need to define what makes a user influential. In the context of the provided schema, influence can be measured by the user's reputation, as it reflects their contributions and interactions within the community. Therefore, the most influential user would be the one with the highest reputation. Once identified, we can retrieve their age from the users table.",
        "sql": "SELECT Age FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);",
        "question": "How old is the most influential user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Age FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "evidence": [
            "How old describes age; the most influential refers to user where MAX(Reputation);"
        ]
    },
    "772": {
        "reason": "To solve the question, we need to list the eye_colour_id, hair_colour_id, and skin_colour_id of all female superheroes published by Dark Horse Comics. Here's the step-by-step reasoning:\n\n1. **Identify the required tables**: We need data from the `superhero` table for colour IDs, the `gender` table to filter by gender, and the `publisher` table to filter by publisher.\n2. **Filter conditions**:\n   - Gender must be 'Female' (from the `gender` table).\n   - Publisher must be 'Dark Horse Comics' (from the `publisher` table).\n3. **Joins**:\n   - Join `superhero` with `gender` on `gender_id` to filter female superheroes.\n   - Join `superhero` with `publisher` on `publisher_id` to filter by publisher.\n4. **Output**: Select the columns `eye_colour_id`, `hair_colour_id`, and `skin_colour_id` from the `superhero` table.\n5. **No need to resolve colour IDs to names**: The question specifies to retrieve the IDs directly.",
        "sql": "SELECT s.eye_colour_id, s.hair_colour_id, s.skin_colour_id\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE g.gender = 'Female' AND p.publisher_name = 'Dark Horse Comics';",
        "question": "List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'",
        "evidence": [
            "eyes refers to eye_colour_id; hair refers to hair_colour_id; skin colour refers to skin_colour_id; female superheroes refers to gender = 'Female'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
            "The query should directly retrieve the colour IDs (eye_colour_id, hair_colour_id, skin_colour_id) from the superhero table without joining the colour table for names.\nFiltering by publisher_name and gender requires joining the superhero table with publisher and gender tables.\nThe output should focus on the IDs rather than resolving them to colour names."
        ]
    },
    "687": {
        "reason": "To solve the question, we need to find the post with the highest score and then count the number of comments associated with that post. The steps are as follows:\n1. Identify the post with the highest score by selecting the post with the maximum score from the `posts` table.\n2. Join the `posts` table with the `comments` table on the `PostId` to find all comments related to the highest-scoring post.\n3. Count the number of comments for this post.\n\nThe query will first find the highest-scoring post and then count the comments for that post.",
        "sql": "SELECT COUNT(*) AS comment_count\nFROM comments\nWHERE PostId = (SELECT Id FROM posts ORDER BY Score DESC LIMIT 1);",
        "question": "How many comments were added to the post with the highest score?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T2.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId GROUP BY T1.Id ORDER BY SUM(T1.Score) DESC LIMIT 1",
        "evidence": [
            "the highest score refers to MAX(Score);",
            "To count comments for the highest-scoring post, join the posts and comments tables, then group by post ID and order by the sum of scores.\nThe highest-scoring post is determined by ordering posts by their score in descending order and limiting to one result.",
            "To count comments for the highest-scoring post, join the posts and comments tables, then group by post ID and order by the sum of scores.\nThe highest-scoring post is determined by ordering posts by their score in descending order and limiting to one result."
        ]
    },
    "1395": {
        "reason": "To find out how many members attended the event 'Community Theater' in 2019, we need to follow these steps:\n1. Identify the event_id for the event named 'Community Theater' and held in 2019 from the `event` table.\n2. Use the `attendance` table to count the number of members (link_to_member) associated with this event_id.\n3. The query will involve joining the `event` and `attendance` tables to filter and count the relevant records.",
        "sql": "SELECT COUNT(DISTINCT a.link_to_member) AS member_count\nFROM attendance a\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Community Theater' AND strftime('%Y', e.event_date) = '2019';",
        "question": "How many members did attend the event 'Community Theater' in 2019?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Community Theater' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "evidence": [
            "event 'Community Theater' in 2019 refers to event_name = 'Community Theater' where YEAR(event_date) = 2019"
        ]
    },
    "1299": {
        "reason": "To solve the question, we need to find the number of patients who have a normal level of triglyceride (TG < 200) and also have other symptoms recorded in the `Examination` table. The steps are as follows:\n1. Join the `Laboratory` table with the `Examination` table on the `ID` field to correlate triglyceride levels with symptoms.\n2. Filter the results to include only patients with TG < 200 (normal triglyceride level).\n3. Further filter to include only patients where the `Symptoms` field in the `Examination` table is not null (indicating other symptoms are observed).\n4. Count the distinct `ID` values to get the number of such patients.",
        "sql": "SELECT COUNT(DISTINCT e.ID) AS PatientCount\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE l.TG < 200 AND e.Symptoms IS NOT NULL;",
        "question": "Among the patients with the normal level of triglyceride, how many of them have other symptoms observed?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL",
        "evidence": [
            "normal level of triglyceride refers to TG < 200; have other symptoms refers to Symptoms is not null;",
            "The `Examination` table contains the `Symptoms` field, while the `Laboratory` table contains the `TG` field. A direct join between these two tables is sufficient to access both fields.",
            "The `Examination` table is the primary source for symptom-related data, while the `Laboratory` table holds triglyceride levels. A join between these tables on `ID` is necessary to correlate the data.\nTo count patients, ensure the query aggregates distinct `ID` values from the `Examination` table, as it directly links to symptom records.",
            "The `Laboratory` table contains multiple records per patient, so joining it with `Examination` requires ensuring the join condition includes both `ID` and a relevant date field if needed.\nCounting distinct `ID` values is unnecessary when the join already ensures unique patient records are considered."
        ]
    },
    "458": {
        "reason": "To solve the question, we need to find the number of distinct artists who have designed cards with a black border color and are available in both \"arena\" and \"mtgo\" printing types. Here's the step-by-step reasoning:\n\n1. **Filter by Border Color**: We need to filter cards where the `borderColor` is \"black\".\n2. **Filter by Availability**: The `availability` column contains comma-separated values. We need to ensure the card is available in both \"arena\" and \"mtgo\". This can be checked by ensuring the `availability` string contains both substrings.\n3. **Count Distinct Artists**: After filtering, we count the distinct values in the `artist` column.\n\nCombining these steps, the query will filter cards with a black border and the required availability, then count the distinct artists.",
        "sql": "SELECT COUNT(DISTINCT artist) AS artist_count\nFROM cards\nWHERE borderColor = 'black'\nAND availability LIKE '%arena%'\nAND availability LIKE '%mtgo%';",
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards",
        "evidence": [
            "available in both \"arena\" and \"mtgo\" refers to availability like '%arena,mtgo%'",
            "The `availability` column may contain comma-separated values, requiring exact pattern matching for combined terms like 'arena,mtgo'.\nCounting distinct artists can be replaced with a conditional count to ensure precise filtering.",
            "The `availability` column requires exact pattern matching for combined terms like 'arena,mtgo', but the condition should be applied within a `CASE` statement for precise counting.\nCounting distinct artists can be replaced with a conditional count to ensure precise filtering.",
            "The `availability` column requires exact pattern matching for combined terms like 'arena,mtgo', but the condition should be applied within a `CASE` statement for precise counting.\nCounting distinct artists can be replaced with a conditional count to ensure precise filtering."
        ]
    },
    "201": {
        "reason": "To solve the question, we need to calculate the percentage of carbon atoms in molecules that have double bonds. Here's the step-by-step reasoning:\n\n1. **Identify double-bond molecules**: We need to find all molecules that have at least one bond with `bond_type = '='` in the `bond` table.\n2. **Count total atoms in double-bond molecules**: For these molecules, count the total number of distinct atoms (using `atom_id`).\n3. **Count carbon atoms in double-bond molecules**: For the same molecules, count the number of atoms where `element = 'c'`.\n4. **Calculate the percentage**: Divide the count of carbon atoms by the total count of atoms and multiply by 100 to get the percentage.\n\nWe will use subqueries to first identify the relevant molecules and then perform the counts.",
        "sql": "WITH double_bond_molecules AS (\n  SELECT DISTINCT molecule_id FROM bond WHERE bond_type = '='\n),\n\ntotal_atoms AS (\n  SELECT COUNT(DISTINCT a.atom_id) AS total\n  FROM atom a\n  JOIN double_bond_molecules d ON a.molecule_id = d.molecule_id\n),\n\ncarbon_atoms AS (\n  SELECT COUNT(DISTINCT a.atom_id) AS carbon\n  FROM atom a\n  JOIN double_bond_molecules d ON a.molecule_id = d.molecule_id\n  WHERE a.element = 'c'\n)\n\nSELECT (carbon_atoms.carbon * 100.0 / total_atoms.total) AS percentage_carbon\nFROM carbon_atoms, total_atoms;",
        "question": "What is the percentage of carbon in double-bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
        "evidence": [
            "carbon refers to element = 'c'; double-bond molecules refers to bond_type = '='; percentage = DIVIDE(SUM(element = 'c'), COUNT(atom_id))",
            "double-bond molecules are identified by bond_type = '=' in the bond table; carbon atoms are identified by element = 'c' in the atom table; percentage calculation requires distinct counts of atoms to avoid duplicates."
        ]
    },
    "821": {
        "reason": "To list down Ajax's superpowers, we need to follow these steps:\n1. Identify the superhero_id for Ajax from the `superhero` table.\n2. Use this superhero_id to find all entries in the `hero_power` table where the hero_id matches.\n3. Join the `hero_power` table with the `superpower` table to get the names of the superpowers associated with Ajax.\n\nThe query will involve joining the `superhero`, `hero_power`, and `superpower` tables to retrieve the required information.",
        "sql": "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Ajax';",
        "question": "List down Ajax's superpowers.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Ajax'",
        "evidence": [
            "Ajax refers to superhero_name = 'Ajax'; superpowers refers to power_name;"
        ]
    },
    "1095": {
        "reason": "To find the average build-up play speed of the Heart of Midlothian team, we need to:\n1. Identify the team in the `Team` table using its name (team_long_name or team_short_name).\n2. Join the `Team` table with the `Team_Attributes` table using the team_api_id or team_fifa_api_id.\n3. Calculate the average of the `buildUpPlaySpeed` attribute for the Heart of Midlothian team.",
        "sql": "SELECT AVG(buildUpPlaySpeed) AS average_build_up_play_speed\nFROM Team_Attributes\nJOIN Team ON Team_Attributes.team_api_id = Team.team_api_id\nWHERE Team.team_long_name = 'Heart of Midlothian';",
        "question": "How much is the average build up play speed of the Heart of Midlothian team?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Heart of Midlothian'",
        "evidence": [
            "Heart of Midlothian refers to team_long_name = 'Heart of Midlothian'; average build up play speed refers to\u00a0 AVG(buildUpPlaySpeed)"
        ]
    },
    "1304": {
        "reason": "To solve the question, we need to count the number of distinct patients who meet two conditions: having a normal blood glucose level (GLU < 180) and not having thrombosis (Thrombosis = 0). The steps are as follows:\n1. Join the `Laboratory` table with the `Patient` table to ensure we are working with valid patients.\n2. Join the result with the `Examination` table to access the `Thrombosis` data.\n3. Filter the records to include only those with `GLU < 180` (normal blood glucose) and `Thrombosis = 0` (no thrombosis).\n4. Count the distinct patient IDs to ensure each patient is only counted once, even if they have multiple records meeting the conditions.",
        "sql": "SELECT COUNT(DISTINCT P.ID) AS NormalGlucoseNoThrombosisCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.GLU < 180 AND E.Thrombosis = 0;",
        "question": "Among the patients with a normal blood glucose, how many of them don't have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.GLU < 180 AND T3.Thrombosis = 0",
        "evidence": [
            "normal blood glucose refers to GLU < 180; don't have thrombosis refers to Thrombosis = 0;",
            "The Laboratory table contains blood glucose levels (GLU) and requires joining with the Examination table to access Thrombosis data.\nThe query should count distinct patients meeting both conditions (GLU < 180 and Thrombosis = 0).",
            "The Patient table serves as the central table linking Laboratory and Examination data, ensuring all joined records correspond to valid patients.\nCounting distinct patients requires joining through the Patient table to avoid potential mismatches or duplicates from direct joins between Laboratory and Examination.",
            "The query must ensure that the join between Laboratory and Examination tables is correctly linked through the Patient table to avoid mismatches.\nCounting distinct patients is not necessary if the join logic ensures each patient is uniquely represented.\nThe filter conditions (GLU < 180 and Thrombosis = 0) must be applied to the respective tables."
        ]
    },
    "373": {
        "reason": "To find the cards illustrated by Aaron Boyd, we need to query the `cards` table where the `artist` column matches 'Aaron Boyd'. The `name` column in the `cards` table contains the names of the cards. Therefore, the query should select the `name` column from the `cards` table where `artist` is 'Aaron Boyd'.",
        "sql": "SELECT name FROM cards WHERE artist = 'Aaron Boyd';",
        "question": "Name the cards that were illustrated by Aaron Boyd.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd'",
        "evidence": [
            "Aaron Boyd' is artist;"
        ]
    },
    "618": {
        "reason": "To solve the question, we need to find the age of users who are located in Vienna, Austria and have obtained a badge. The steps to achieve this are:\n1. Join the `users` table with the `badges` table to link users with their badges.\n2. Filter the users based on their location (Vienna, Austria).\n3. Select the age of these users.\n\nThe query will involve an inner join between the `users` and `badges` tables, with a condition to filter users by location.",
        "sql": "SELECT u.Age\nFROM users u\nINNER JOIN badges b ON u.Id = b.UserId\nWHERE u.Location = 'Vienna, Austria';",
        "question": "List out the age of users who located in Vienna, Austria obtained the badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Age FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'Vienna, Austria'",
        "evidence": [
            "\"Vienna, Austria\" is the Location"
        ]
    },
    "559": {
        "reason": "To find the creation date of the maximum number of votes, we need to:\n1. Count the number of votes for each creation date from the `votes` table.\n2. Identify the creation date with the highest count of votes.\n3. Return this creation date as the result.\n\nThis involves grouping the votes by `CreationDate`, counting the number of votes in each group, and then selecting the date with the maximum count.",
        "sql": "SELECT CreationDate\nFROM votes\nGROUP BY CreationDate\nORDER BY COUNT(Id) DESC\nLIMIT 1;",
        "question": "Indicate the creation date of the maximum number of votes.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CreationDate FROM votes GROUP BY CreationDate ORDER BY COUNT(Id) DESC LIMIT 1",
        "evidence": [
            "the creation date of the maximum number of votes refers to CreationDate where Max(Count(Id))"
        ]
    },
    "976": {
        "reason": "To solve the question, we need to find the top five drivers with the fastest time during the first lap of the race. The steps are as follows:\n1. Identify the relevant table: `lapTimes` contains lap time data for drivers in races.\n2. Filter for the first lap (`lap = 1`).\n3. Order the results by the `time` column in ascending order to get the fastest times.\n4. Limit the results to the top five drivers.\n5. Select the `driverId` column to identify the drivers.\n\nThe query will join the `lapTimes` table with the `drivers` table to ensure we are working with valid driver data.",
        "sql": "SELECT l.driverId\nFROM lapTimes l\nJOIN drivers d ON l.driverId = d.driverId\nWHERE l.lap = 1\nORDER BY l.time ASC\nLIMIT 5;",
        "question": "List the driver's ID of the top five driver, by descending order, the fastest time during the first lap of the race.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY time LIMIT 5",
        "evidence": [
            "fastest time refers to Min(time);"
        ]
    },
    "1283": {
        "reason": "To solve the question, we need to find the number of male patients with a normal glutamic pyruvic transaminase (GPT) level, which is defined as GPT < 60. The steps are as follows:\n1. Identify patients with GPT < 60 from the Laboratory table.\n2. Join these patients with the Patient table to filter for male patients (SEX = 'M').\n3. Count the distinct male patients who meet the GPT condition.",
        "sql": "SELECT COUNT(DISTINCT P.ID) AS MalePatientsWithNormalGPT\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.GPT < 60 AND P.SEX = 'M';",
        "question": "For the patients with the normal glutamic pylvic transaminase level, how many of them are male?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "evidence": [
            "normal glutamic pylvic transaminase level refers to GOT < 60; male refers to Sex = 'M';",
            "normal glutamic pyruvic transaminase level refers to GPT < 60, not GOT < 60; male refers to SEX = 'M' in the Patient table.",
            "normal glutamic pyruvic transaminase level refers to GPT < 60, not GOT < 60; male refers to SEX = 'M' in the Patient table."
        ]
    },
    "999": {
        "reason": "To solve the question, we need to find the race with the fastest lap speed recorded by a racer. The schema indicates that the `results` table contains the `fastestLapTime` and `fastestLapSpeed` columns, which are relevant to this query. The `races` table contains the name of the race. We will join these tables to retrieve the race name associated with the fastest lap speed. The fastest lap speed is determined by the minimum `fastestLapTime` (as per the tip provided). Here's the step-by-step reasoning:\n\n1. Join the `results` table with the `races` table to link race results with race names.\n2. Filter the results to include only those with a valid `fastestLapTime`.\n3. Order the results by `fastestLapTime` in ascending order to find the fastest lap.\n4. Limit the result to the top record to get the race with the fastest lap speed.\n5. Select the race name from the `races` table.",
        "sql": "SELECT r.name AS race_name\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nWHERE res.fastestLapTime IS NOT NULL\nORDER BY res.fastestLapTime ASC\nLIMIT 1;",
        "question": "In terms of the fastest lap time, what is the name of the race which recorded the fastest lap speed by a racer?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "evidence": [
            "Fastest lap speed refers to MIN(fastestLapTime)\n\n"
        ]
    },
    "1197": {
        "reason": "To solve the question, we need to find the first documented medical information for patient number 48473, including the date and the disease she had. The relevant tables are `Patient` and `Examination`. The `Patient` table contains the patient's basic information, including the `First Date` which likely indicates the first documentation date. The `Examination` table contains the `Diagnosis` field which indicates the disease. We will join these tables to retrieve the required information.",
        "sql": "SELECT p.`First Date`, e.Diagnosis FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE p.ID = 48473 ORDER BY p.`First Date` LIMIT 1;",
        "question": "When was the medical information on patient number 48473 first documented, and what disease did she have?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT `First Date`, Diagnosis FROM Patient WHERE ID = 48473",
        "evidence": [
            "medical information first documented refers to Description; disease refers to diagnosis; patient number refers to id"
        ]
    },
    "945": {
        "reason": "To find the number of circuits in Adelaide, Australia, we need to query the `circuits` table. The relevant columns for this query are `location` and `country`. We will filter the records where the `location` is 'Adelaide' and the `country` is 'Australia', and then count the number of such records.",
        "sql": "SELECT COUNT(*) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia';",
        "question": "How many circuits are there in Adelaide, Australia?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia'",
        "evidence": [
            "Australia is the country; Melbourne is the location of circuit;"
        ]
    },
    "1188": {
        "reason": "To solve the question, we need to find female patients born in 1964 who were admitted to the hospital. The steps are as follows:\n1. Identify the relevant table: `Patient` contains the necessary information (SEX, Birthday, Admission).\n2. Filter for female patients (SEX = 'F').\n3. Filter for patients born in 1964 (YEAR(Birthday) = 1964).\n4. Filter for patients admitted to the hospital (Admission = '+').\n5. List the IDs of these patients.",
        "sql": "SELECT ID FROM Patient WHERE SEX = 'F' AND strftime('%Y', Birthday) = '1964' AND Admission = '+';",
        "question": "How many female patients born in 1964 were admitted to the hospital? List them by ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT ID FROM Patient WHERE STRFTIME('%Y', Birthday) = '1964' AND SEX = 'F' AND Admission = '+'",
        "evidence": [
            "female refers to SEX = 'F'; born in 1964 refers to YEAR(Birthday) = 1964; admitted to the hospital refers to Admission = '+'"
        ]
    },
    "1355": {
        "reason": "To find the hometown state for \"Sacha Harrison\", we need to follow these steps:\n1. Locate the member record for \"Sacha Harrison\" in the `member` table.\n2. Extract the `zip` code associated with this member.\n3. Use the `zip` code to look up the corresponding state in the `zip_code` table.\n4. Return the `state` field from the `zip_code` table.\n\nThe query will involve joining the `member` table with the `zip_code` table on the `zip` field to retrieve the state information.",
        "sql": "SELECT z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison';",
        "question": "Where is the hometown state for \"Sacha Harrison\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
        "evidence": [
            "hometown state refers to state;"
        ]
    },
    "440": {
        "reason": "To find the foreign language used by the card \"A Pedra Fellwar\", we need to query the `foreign_data` table. The `foreign_data` table contains a column `language` which stores the language of the foreign data entry. Since the `foreign_data` table directly stores the `name` of the card, we can filter the entries where the `name` is \"A Pedra Fellwar\" and retrieve the `language` column.",
        "sql": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar';",
        "question": "Which foreign language used by \"A Pedra Fellwar\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'",
        "evidence": [
            "\"A Pedra Fellwar\" refers to name = 'A Pedra Fellwar'",
            "The `foreign_data` table directly stores the `name` of the card, allowing language lookup without joining to the `cards` table."
        ]
    },
    "1250": {
        "reason": "To solve the question, we need to find patients who meet two criteria: 1) they have a normal proteinuria level (0 < `U-PRO` < 30), and 2) they are diagnosed with SLE (Diagnosis = 'SLE'). The `U-PRO` field is in the `Laboratory` table, and the `Diagnosis` field is in the `Patient` table. We will join these tables on the `ID` field to combine the necessary information. The query will filter for patients where `U-PRO` is between 0 and 30 and `Diagnosis` is 'SLE'.",
        "sql": "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.\"U-PRO\" > 0 AND L.\"U-PRO\" < 30 AND P.Diagnosis = 'SLE';",
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "evidence": [
            "normal proteinuria level refers to 0 < `U-PRO` < 30; diagnosed with SLE refers to Diagnosis = 'SLE';"
        ]
    },
    "298": {
        "reason": "To calculate the percentage of molecules containing carcinogenic compounds where the element is hydrogen, we need to follow these steps:\n1. Identify carcinogenic molecules (those with `label = '+'`).\n2. For these molecules, count how many contain hydrogen atoms (`element = 'h'`).\n3. Calculate the total number of carcinogenic molecules.\n4. Divide the count from step 2 by the count from step 3 and multiply by 100 to get the percentage.\n\nWe will use `INNER JOIN` to ensure both counts are derived from the same scope of carcinogenic molecules.",
        "sql": "SELECT (COUNT(DISTINCT CASE WHEN a.element = 'h' THEN m.molecule_id END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM molecule m\nINNER JOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+';",
        "question": "Calculate the percentage of molecules containing carcinogenic compounds that element is hydrogen.",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "evidence": [
            "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+' and element = 'h'), COUNT(molecule_id)) * 100.0",
            "To calculate percentages, ensure the numerator and denominator are derived from the same join scope to avoid mismatched counts. Use INNER JOIN to filter only relevant records for both parts of the calculation.",
            "To ensure accurate percentage calculation, both the numerator and denominator must filter for carcinogenic molecules (label = '+'). Use INNER JOIN to align the scope of both counts.",
            "To calculate percentages, ensure the numerator and denominator are derived from the same join scope to avoid mismatched counts. Use INNER JOIN to filter only relevant records for both parts of the calculation."
        ]
    },
    "865": {
        "reason": "To solve the question, we need to find the oldest driver among those who finished the race with raceId 592. The steps are as follows:\n1. Identify drivers who finished the race by checking the `results` table where `time` is not NULL and `raceId` is 592.\n2. Join the `results` table with the `drivers` table to access the drivers' date of birth (dob).\n3. Filter out drivers with NULL dob to ensure accurate age comparison.\n4. Order the results by dob in ascending order to find the oldest driver (earliest dob).\n5. Limit the result to 1 to get the oldest driver.",
        "sql": "SELECT d.driverId, d.forename, d.surname, d.dob\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 592 AND r.time IS NOT NULL AND d.dob IS NOT NULL\nORDER BY d.dob ASC\nLIMIT 1;",
        "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
        "evidence": [
            "drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL); race number refers to raceId; date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
            "To ensure completeness, filter drivers with non-null date of birth (dob) when determining age-related queries.\nResults with non-null time indicate finished races, but additional checks for valid dob are necessary for accurate age comparison.",
            "The `results` table links to `drivers` via `driverId` to retrieve driver details like date of birth (dob).\nFor age-related queries, ensure the join between `results` and `drivers` is correctly specified to access dob.\nOrdering by dob in ascending order identifies the oldest driver, as earlier dates indicate older age.",
            "The `results` table links to `drivers` via `driverId` to retrieve driver details like date of birth (dob).\nFor age-related queries, ensure the join between `results` and `drivers` is correctly specified to access dob.\nOrdering by dob in ascending order identifies the oldest driver, as earlier dates indicate older age."
        ]
    },
    "111": {
        "reason": "To solve the question, we need to find the number of accounts opened in Litomerice in 1996. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `account` table contains information about accounts, including the `district_id` (which links to the `district` table) and the `date` when the account was opened.\n2. **Filter by district**: The `district` table has a column `A2` which contains the district name. We need to find the `district_id` for Litomerice.\n3. **Filter by year**: The `date` column in the `account` table needs to be filtered to include only dates from the year 1996.\n4. **Count the accounts**: After filtering, we count the number of accounts that meet these criteria.\n\nSo, the query will:\n- Join the `account` and `district` tables on `district_id`.\n- Filter for `A2 = 'Litomerice'` and `date` in 1996.\n- Count the resulting rows.",
        "sql": "SELECT COUNT(*) \nFROM account \nJOIN district ON account.district_id = district.district_id \nWHERE district.A2 = 'Litomerice' \nAND strftime('%Y', account.date) = '1996';",
        "question": "How many accounts were opened in Litomerice in 1996?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1996' AND T1.A2 = 'Litomerice'",
        "evidence": [
            "A2 refers to district name; Litomerice is one of district names."
        ]
    },
    "1183": {
        "reason": "To solve the question, we need to find the original diagnosis of a patient who was diagnosed with SLE (Systemic Lupus Erythematosus) on 1997/1/27. The steps are as follows:\n1. Identify the patient(s) who were diagnosed with SLE on the specified date from the `Examination` table.\n2. Use the patient's ID to find their original diagnosis from the `Patient` table, specifically the `Diagnosis` field recorded when they first came to the hospital (`First Date`).\n3. Join the `Examination` and `Patient` tables on the patient ID to retrieve the required information.",
        "sql": "SELECT p.Diagnosis\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE e.Diagnosis = 'SLE' AND e.`Examination Date` = '1997-01-27' AND p.`First Date` IS NOT NULL;",
        "question": "For the patient who was diagnosed SLE on 1997/1/27, what was his/her original diagnose when he/she came to the hospital for the first time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = ( SELECT ID FROM Examination WHERE `Examination Date` = '1997-01-27' AND Diagnosis = 'SLE' ) AND T2.`Examination Date` = T1.`First Date`",
        "evidence": [
            "'SLE' AND original diagnose refers to diagnosis; 1997/1/27 refer to `Examination Date` = '1997-01-27'; first came to the hospital refers to patient.`First Date`"
        ]
    },
    "393": {
        "reason": "To solve the question, we need to find the number of cards designed by John Avon where the foil version is non-powerful. According to the tips, non-powerful foils are indicated by either `cardKingdomId` or `cardKingdomFoilId` being NULL. The artist column identifies the designer of the card, such as 'John Avon'. Therefore, the steps are:\n1. Filter cards where the artist is 'John Avon'.\n2. From these cards, count those where either `cardKingdomId` or `cardKingdomFoilId` is NULL, indicating a non-powerful foil.",
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'John Avon' \nAND (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL);",
        "question": "On how many cards designed by John Avon is its foil non-powerful?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'",
        "evidence": [
            "John Avon refer to artist; foil poweful foils refers to cardKingdomId and cardKingdomFoildId is NOT NULL \n",
            "Non-powerful foils are indicated by either `cardKingdomId` or `cardKingdomFoilId` being NULL, not just `cardKingdomFoilId`.\nThe `artist` column identifies the designer of the card, such as 'John Avon'."
        ]
    },
    "358": {
        "reason": "To find the border color of the card \"Ancestor's Chosen\", I need to query the `cards` table. The `cards` table contains a column named `borderColor` which stores the border color information for each card. The card's name is stored in the `name` column. Since the card name includes an apostrophe, I need to ensure it is properly escaped in the SQL query. The query will filter the `cards` table for the row where the `name` column matches \"Ancestor's Chosen\" and then retrieve the `borderColor` value.",
        "sql": "SELECT borderColor FROM cards WHERE name = 'Ancestor''s Chosen';",
        "question": "What is the border color of card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT borderColor FROM cards WHERE name = 'Ancestor''s Chosen'",
        "evidence": [
            "name of card  = 'Ancestor''s Chosen' ;"
        ]
    },
    "1314": {
        "reason": "To solve the question, we need to find the full names of students in the Student_Club who come from the Art and Design Department. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `member` table contains student information, including their names and links to their majors. The `major` table contains department information.\n\n2. **Filter by department**: The question specifies students from the 'Art and Design Department'. This requires joining the `member` table with the `major` table and filtering where the `department` column in the `major` table matches 'Art and Design Department' exactly.\n\n3. **Retrieve full names**: The full name can be constructed by concatenating the `first_name` and `last_name` columns from the `member` table.\n\n4. **Output the result**: The query should return the concatenated full names of the students who meet the criteria.",
        "sql": "SELECT member.first_name || ' ' || member.last_name AS full_name\nFROM member\nJOIN major ON member.link_to_major = major.major_id\nWHERE major.department = 'Art and Design Department';",
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "evidence": [
            "full name refers to first_name, last_name;",
            "department filtering requires exact match to the full department name, including 'Department' suffix.",
            "The full name can be represented as separate columns (first_name, last_name) or concatenated; both are valid but must align with the output requirement.",
            "The output format can specify whether to return separate columns (first_name, last_name) or a concatenated string, depending on the requirement."
        ]
    },
    "1172": {
        "reason": "To solve the question, we need to find the number of male patients with an elevated total bilirubin count (`T-BIL` >= 2.0). The steps are as follows:\n1. Identify male patients from the `Patient` table where `SEX` = 'M'.\n2. Join the `Patient` table with the `Laboratory` table on the `ID` field to access the bilirubin data.\n3. Filter the records where `T-BIL` is greater than or equal to 2.0.\n4. Count the distinct male patients who meet the criteria.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.`T-BIL` >= 2.0;",
        "question": "How many male patients have elevated total bilirubin count?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "evidence": [
            "male refers to SEX = 'M'; elevated means above the normal range; total bilirubin above the normal range refers to `T-BIL` >= '2.0'"
        ]
    },
    "1456": {
        "reason": "To solve the question, we need to identify the top five members who have spent the most money. The spending is tracked in the `expense` table via the `cost` column, which is linked to members through the `link_to_member` column. We will aggregate the `cost` for each member, join the `member` table to get their full names, and then order the results in descending order of total spending. Finally, we will limit the results to the top five members.",
        "sql": "SELECT m.first_name, m.last_name, SUM(e.cost) AS total_spending\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nGROUP BY m.member_id\nORDER BY total_spending DESC\nLIMIT 5;",
        "question": "List the full name of the top five members who spend the most money in the descending order of spending.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T3.first_name, T3.last_name FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id ORDER BY T2.spent DESC LIMIT 5",
        "evidence": [
            "full name refers to first_name, last_name; spend the most money refers to MAX(expense.cost)",
            "Spending is tracked via the `spent` column in the `budget` table, not the `cost` column in the `expense` table. The `expense` table links to `budget` via `link_to_budget`.",
            "The `spent` column in the `budget` table represents the total spending per budget, not per member. To find individual spending, aggregate the `cost` column from the `expense` table.",
            "The `spent` column in the `budget` table reflects total spending per budget, not per member. To track individual spending, use the `cost` column in the `expense` table linked to members via `link_to_member`."
        ]
    },
    "318": {
        "reason": "To find the molecule ID associated with the bond ID 'TR001_1_7', we need to query the `bond` table. The `bond` table contains the `molecule_id` column, which is linked to the `molecule` table. Since the question asks for the molecule ID of a specific bond ID, we can directly query the `bond` table for the `molecule_id` where the `bond_id` matches 'TR001_1_7'.",
        "sql": "SELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';",
        "question": "What is the molecule id of bond id TR001_1_7?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "evidence": [
            ""
        ]
    },
    "370": {
        "reason": "To solve the question \"How many borderless cards are illustrated in Russian?\", we need to follow these steps:\n\n1. **Identify the criteria for borderless cards**: Borderless cards are typically indicated by the `borderColor` field in the `cards` table. We need to filter cards where `borderColor` is \"borderless\".\n\n2. **Identify the criteria for Russian illustrations**: The `foreign_data` table contains information about cards in different languages, including Russian. We need to filter entries where `language` is \"Russian\".\n\n3. **Join the tables**: We need to join the `cards` table with the `foreign_data` table using the `uuid` field to find cards that meet both criteria.\n\n4. **Count the results**: Finally, we count the number of unique cards that satisfy both conditions.\n\nPutting it all together, the query will join the `cards` and `foreign_data` tables, filter for borderless cards and Russian illustrations, and count the results.",
        "sql": "SELECT COUNT(DISTINCT c.id) \nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.borderColor = 'borderless' AND fd.language = 'Russian';",
        "question": "How many borderless cards are illustrated in Russian?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.borderColor = 'borderless' AND T2.language = 'Russian'",
        "evidence": [
            "borderless card refers to borderColor = 'borderless'; 'Russian' is the language;"
        ]
    },
    "1221": {
        "reason": "To solve the question, we need to find patients diagnosed with 'RA' (Rheumatoid Arthritis) who also have a UN (Urea Nitrogen) value within the normal range (UN < 30). The steps are as follows:\n1. Identify patients with Diagnosis = 'RA' in the Patient table.\n2. Join the Patient table with the Laboratory table to access the UN values.\n3. Filter the results to include only those patients with UN < 30.\n4. Select the required fields: ID, SEX, and Birthday from the Patient table.",
        "sql": "SELECT P.ID, P.SEX, P.Birthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'RA' AND L.UN < 30;",
        "question": "Provide the ID, sex, birthday of all patients diagnosed with 'RA' that are within the UN normal index.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN < 30 AND T1.Diagnosis = 'RA'",
        "evidence": [
            "within the UN normal index refers to UN < 30; Diagnosis = 'RA'"
        ]
    },
    "1207": {
        "reason": "To solve the question, we need to list patients with their sex and birthday whose GOT (AST glutamic oxaloacetic transaminase) index is within the normal range (GOT < 60) for laboratory examinations conducted in 1994. The steps are as follows:\n1. Join the `Patient` table with the `Laboratory` table using the `ID` field to link the patient information with their laboratory results.\n2. Filter the laboratory results to include only those where the `GOT` value is less than 60 and the year of the `Date` is 1994.\n3. Select the required fields: `SEX` and `Birthday` from the `Patient` table, and ensure the results are distinct to avoid duplicates.",
        "sql": "SELECT DISTINCT p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GOT < 60 AND strftime('%Y', l.Date) = '1994';",
        "question": "List all patients with their sex and date of birthday, whose AST glutamic oxaloacetic transaminase (GOT) index is within normal range for loboratory examination in 1994.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND STRFTIME('%Y', T2.Date) = '1994'",
        "evidence": [
            "AST glutamic oxaloacetic transaminase (GOT) index is within normal range refers to GOT < 60; examination in 1994 refers to year(Date) = 1994",
            "The query should include the patient's sex and birthday from the Patient table, joined with the Laboratory table where GOT is below 60 and the year is 1994."
        ]
    },
    "225": {
        "reason": "To solve the question, we need to retrieve the top five molecules that have double bonds, ordered alphabetically by their molecule IDs. The double bond is identified by the bond_type '=' in the bond table. Since the question specifies that the join with the molecule table is unnecessary, we can directly query the bond table. We will filter for bond_type '=', select distinct molecule_id to avoid duplicates, order the results alphabetically by molecule_id, and limit the output to the top five results.",
        "sql": "SELECT DISTINCT molecule_id FROM bond WHERE bond_type = '=' ORDER BY molecule_id ASC LIMIT 5;",
        "question": "Please list top five molecules that have double bonds in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id LIMIT 5",
        "evidence": [
            "double bond refers to bond_type = ' = ';",
            "The query should focus on retrieving distinct molecule IDs directly from the bond table where the bond type matches the criteria.\nOrdering should be applied to the molecule_id column for alphabetical sorting.\nThe join with the molecule table is unnecessary for this specific query.",
            "The bond_type value for double bonds is '=' without spaces around it.\nThe query should use table aliases for clarity and consistency."
        ]
    },
    "1135": {
        "reason": "To solve the question, we need to find the top five football players with the lowest potential who prefer to use their right foot when attacking. The steps are as follows:\n1. Query the `Player_Attributes` table to filter players with `preferred_foot` = 'right'.\n2. Order these players by their `potential` in ascending order to get the lowest potential players.\n3. Limit the results to the top five players.\n4. Retrieve the `player_api_id` (foreign key referencing the `Player` table) to identify the players.",
        "sql": "SELECT player_api_id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential ASC LIMIT 5;",
        "question": "Please provide top five football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential DESC LIMIT 5",
        "evidence": [
            "lowest potential players refers to MIN(potential); prefer to use the right foot when attacking refers to preferred_foot = 'right'",
            "The `id` column in `Player_Attributes` uniquely identifies each record, while `player_api_id` is a foreign key referencing the `Player` table.\nTo retrieve the lowest potential players, use `ORDER BY potential ASC` to sort in ascending order.\nThe `LIMIT` clause restricts the output to the top five results.",
            "The `id` column in `Player_Attributes` is the primary key, while `player_api_id` is a foreign key referencing the `Player` table.\nTo retrieve the lowest potential players, use `ORDER BY potential ASC` to sort in ascending order.\nThe `LIMIT` clause restricts the output to the top five results.",
            "The `id` column in `Player_Attributes` is the primary key for identifying records, while `player_api_id` is a foreign key.\nTo retrieve the lowest potential players, use `ORDER BY potential DESC` to sort in descending order.\nThe `LIMIT` clause restricts the output to the top five results."
        ]
    },
    "466": {
        "reason": "To solve the question, we need to find the number of cards in the set \"Hauptset Zehnte Edition\" that are designed by Adam Rex. This involves the following steps:\n1. Identify the set code for \"Hauptset Zehnte Edition\" from the `set_translations` table where the translation matches the given name.\n2. Use the identified set code to filter cards in the `cards` table where the `setCode` matches the set code from step 1.\n3. Further filter these cards by checking if the `artist` field is 'Adam Rex'.\n4. Count the number of such cards.",
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT setCode FROM set_translations WHERE translation = 'Hauptset Zehnte Edition') \nAND artist = 'Adam Rex';",
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "evidence": [
            "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; designed by Adam refers to artist = 'Adam Rex'"
        ]
    },
    "73": {
        "reason": "To solve the question, we need to find the free or reduced-price meal count for ages 5 to 17 in a Youth Authority School with a mailing street address of 'PO Box 1040'. Here's the step-by-step reasoning:\n\n1. **Identify the School**: First, we need to locate the school in the `schools` table that has a `SOCType` of 'Youth Authority Facilities' and a `MailStreet` of 'PO Box 1040'.\n\n2. **Retrieve the CDSCode**: Once the school is identified, we need its `CDSCode` to link it with the `frpm` table.\n\n3. **Fetch the Meal Count**: Using the `CDSCode` from the `schools` table, we can query the `frpm` table to get the `FRPM Count (Ages 5-17)` for the identified school.\n\n4. **Combine the Queries**: We will join the `schools` and `frpm` tables on the `CDSCode` to fetch the required information in a single query.",
        "sql": "SELECT f.\"FRPM Count (Ages 5-17)\"\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.SOCType = 'Youth Authority Facilities' AND s.MailStreet = 'PO Box 1040';",
        "question": "What is the free or reduced price meal count for ages 5 to 17 in the Youth Authority School with a mailing street address of PO Box 1040?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`FRPM Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.MailStreet = 'PO Box 1040' AND T2.SOCType = 'Youth Authority Facilities'",
        "evidence": [
            "",
            "The `SOCType` column in the `schools` table identifies the type of school, such as 'Youth Authority Facilities', which is crucial for filtering specific school types.\nThe `FRPM Count (Ages 5-17)` column in the `frpm` table provides the count of free or reduced-price meals for the specified age group."
        ]
    },
    "614": {
        "reason": "To solve the question, we need to calculate the percentage of users who obtained the \"Teacher\" badge among all users. Here's the step-by-step reasoning:\n\n1. **Identify users with the \"Teacher\" badge**: We need to query the `badges` table where the `Name` column is \"Teacher\" and collect the `UserId`s of these users.\n2. **Count the total number of users**: We need to count all distinct users in the `users` table.\n3. **Count the number of users with the \"Teacher\" badge**: We need to count the distinct `UserId`s from the first step.\n4. **Calculate the percentage**: Divide the count of users with the \"Teacher\" badge by the total number of users and multiply by 100 to get the percentage.\n5. **Handle edge cases**: Ensure that division by zero is avoided if there are no users in the database.\n\nThe final SQL query will combine these steps to produce the desired result.",
        "sql": "SELECT \n    (COUNT(DISTINCT b.UserId) * 100.0 / NULLIF(COUNT(DISTINCT u.Id), 0)) AS percentage_teacher_badge_users\nFROM \n    users u\nLEFT JOIN \n    badges b ON u.Id = b.UserId AND b.Name = 'Teacher';",
        "question": "Among the users who obtained the \"Teacher\" badge, calculate their percentage of users",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) * 100 / (SELECT COUNT(Id) FROM users) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Teacher'",
        "evidence": [
            "\"Teacher\" is the Name of badge;  percentage = Divide (Count(UserId where it's \"Teacher\"), Count(UserId)) * 100"
        ]
    },
    "1442": {
        "reason": "To determine the percentage of events that went over budget, we need to follow these steps:\n1. Identify all events and their associated budgets.\n2. For each event, check if the total spent (`spent` in the `budget` table) exceeds the allocated amount (`amount` in the `budget` table).\n3. Count the total number of events and the number of events where `spent` > `amount`.\n4. Calculate the percentage by dividing the count of over-budget events by the total number of events and multiplying by 100.\n\nThe query will join the `event` and `budget` tables to gather the necessary data and perform the calculations.",
        "sql": "SELECT \n    (COUNT(CASE WHEN b.spent > b.amount THEN 1 END) * 100.0 / COUNT(*)) AS percentage_over_budget\nFROM \n    event e\nJOIN \n    budget b ON e.event_id = b.link_to_event;",
        "question": "What is the percentage of the events that went over budget?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(budget_id) FROM budget",
        "evidence": [
            "went over budget refers to remaining < 0; percentage = DIVIDE(SUM(remaining < 0), COUNT(event_id)) * 100"
        ]
    },
    "825": {
        "reason": "To identify the gender of the superhero who has the ability of Phoenix Force, we need to follow these steps:\n1. First, find the `id` of the superpower named 'Phoenix Force' in the `superpower` table.\n2. Then, find the `hero_id` associated with this power in the `hero_power` table.\n3. Next, use the `hero_id` to find the corresponding superhero in the `superhero` table.\n4. Finally, join the `superhero` table with the `gender` table to get the gender of the identified superhero.",
        "sql": "SELECT g.gender\nFROM gender g\nJOIN superhero s ON g.id = s.gender_id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Phoenix Force';",
        "question": "Identify the gender of the superhero who has the ability of Phoenix Force.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Phoenix Force'",
        "evidence": [
            "ability of Phoenix Force refers to power_name = 'Phoenix Force';"
        ]
    },
    "1080": {
        "reason": "To solve the question, we need to identify players whose preferred foot is the left foot when attacking and determine how many of them would remain in their position during the team's attack. The key steps are:\n1. Identify players with `preferred_foot` as 'left' in the `Player_Attributes` table.\n2. Check the `attacking_work_rate` column in the same table to see if the player remains in their position (likely indicated by a value like 'low' or 'stay back').\n3. Count the number of such players.\n\nThe query will join the `Player` and `Player_Attributes` tables to get the player details and their attributes, then filter based on the conditions mentioned.",
        "sql": "SELECT COUNT(*) AS count_left_foot_players_stay_back\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.preferred_foot = 'left' AND pa.attacking_work_rate = 'low';",
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "evidence": [
            "preferred foot when attacking was the left refers to preferred_foot = 'left'; players who would remain in his position when the team attacked refers to attacking_work_rate = 'low';"
        ]
    },
    "1228": {
        "reason": "To solve the question, we need to find patients with a triglyceride (TG) index greater than 100 of the normal range, which translates to TG > 300. The steps are as follows:\n1. Identify the relevant table: The `Laboratory` table contains the TG values.\n2. Filter records where TG > 300.\n3. Join the `Laboratory` table with the `Patient` table to get the patient details and their diagnosis.\n4. Return the list of patients and their diagnosis.",
        "sql": "SELECT p.ID, p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TG > 300;",
        "question": "Provide list of patients and their diagnosis with triglyceride (TG) index greater than 100 of the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG > 300",
        "evidence": [
            "triglyceride (TG) index greater than 100 of the normal range refers to TG > 300;"
        ]
    },
    "1274": {
        "reason": "To solve the question, we need to find the number of distinct patients who have normal anti-SSB results (SSB IN ('negative', '0')) and also have non-null symptoms recorded in their examination. The steps are as follows:\n1. Join the `Examination` and `Laboratory` tables on the `ID` field to link patient records.\n2. Filter the records where `SSB` is either 'negative' or '0' (normal anti-SSB results).\n3. Further filter the records where the `Symptoms` field in the `Examination` table is not null.\n4. Count the distinct `ID` values to get the number of unique patients meeting these criteria.",
        "sql": "SELECT COUNT(DISTINCT e.ID) AS NumberOfPatients\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE (l.SSB IN ('negative', '0')) AND e.Symptoms IS NOT NULL;",
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "evidence": [
            "anti-SSB are normal refers to SSB IN ('negative', '0'); have other symptoms refers to Symptoms IS NOT NULL; Should compute the number of distinct ones",
            "The query should directly join the Examination and Laboratory tables to filter patients with normal anti-SSB results and non-null symptoms.\nThe condition for normal anti-SSB results should use OR logic explicitly.\nThe join should focus on the Examination table as the primary source for symptom data.",
            "The condition for normal anti-SSB results should use OR logic explicitly to ensure accurate filtering.\nThe join should include all relevant records from both tables to capture the required patient data.",
            "The condition for normal anti-SSB results should use OR logic explicitly to ensure accurate filtering.\nThe join should include all relevant records from both tables to capture the required patient data."
        ]
    },
    "805": {
        "reason": "To solve the question, we need to list the full names of superheroes with missing weight. According to the tips, missing weight refers to cases where `weight_kg` is either NULL or 0. Additionally, the `full_name` must be non-null to be included in the results. We will use the `superhero` table to retrieve the relevant data. The query should filter for rows where `weight_kg` is NULL or 0 and `full_name` is not NULL, and then return the distinct `full_name` values to avoid duplicates.",
        "sql": "SELECT DISTINCT full_name FROM superhero WHERE (weight_kg IS NULL OR weight_kg = 0) AND full_name IS NOT NULL;",
        "question": "List the full names of superheroes with missing weight.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0)",
        "evidence": [
            "missing weight refers to weight_kg = 0 OR weight_kg = NULL;",
            "missing weight includes cases where weight_kg is NULL or 0, and full_name must be non-null to be included in results.\nDISTINCT ensures no duplicate full names are returned."
        ]
    },
    "1324": {
        "reason": "To find the average attendance of meetings in 2020, we need to follow these steps:\n1. Identify all events in the `event` table that occurred in 2020. This can be done by filtering the `event_date` column for dates in 2020.\n2. For each of these events, count the number of attendees from the `attendance` table.\n3. Calculate the average of these counts to get the average attendance.\n\nThe query will involve joining the `event` and `attendance` tables, filtering for events in 2020, grouping by event, counting attendees, and then averaging the counts.",
        "sql": "SELECT AVG(attendance_count) AS average_attendance\nFROM (\n    SELECT COUNT(*) AS attendance_count\n    FROM event e\n    JOIN attendance a ON e.event_id = a.link_to_event\n    WHERE e.event_date LIKE '2020%'\n    GROUP BY e.event_id\n);",
        "question": "What is the average attendance of meetings in 2020?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE SUBSTR(T1.event_date, 1, 4) = '2020' AND T1.type = 'Meeting'",
        "evidence": [
            "meetings in 2020 refers to type = 'Meeting' where YEAR(event_date) = 2020; average = DIVIDE(COUNT(event_id), COUNT(DISTINCT event_name))"
        ]
    },
    "747": {
        "reason": "To find the total number of superheroes without a full name, we need to query the `superhero` table and count the rows where the `full_name` column is NULL. The query will use the `COUNT` function to aggregate the results.",
        "sql": "SELECT COUNT(*) FROM superhero WHERE full_name IS NULL;",
        "question": "What is the total number of superheroes without full name?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL",
        "evidence": [
            "superheroes without full name refers to full_name IS NULL"
        ]
    },
    "257": {
        "reason": "To solve the question, we need to list down the `atom_id2` for atoms where the element is sulfur ('s'). The steps are as follows:\n1. Identify the `atom_id` of atoms with the element 's' from the `atom` table.\n2. Use these `atom_id` values to find the corresponding `atom_id2` in the `connected` table, where these atoms are connected to other atoms.\n3. The query will join the `atom` and `connected` tables to retrieve the required information.",
        "sql": "SELECT c.atom_id2\nFROM connected c\nJOIN atom a ON c.atom_id = a.atom_id\nWHERE a.element = 's';",
        "question": "List down atom id2 for atoms with element sulfur.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'",
        "evidence": [
            "element sulfur refers to element = 's'"
        ]
    },
    "795": {
        "reason": "To find the number of superheroes with a neutral alignment, we need to query the `superhero` table where the `alignment_id` corresponds to the neutral alignment. According to the tips, neutral alignment is represented by `alignment_id = 3`. We will count the rows in the `superhero` table where `alignment_id` is 3.",
        "sql": "SELECT COUNT(*) FROM superhero WHERE alignment_id = 3;",
        "question": "How many superheroes have a neutral alignment?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "evidence": [
            "neutral alignment refers to alignment_id = 3;"
        ]
    },
    "1051": {
        "reason": "To list all football players with the highest potential score, we need to:\n1. Identify the maximum potential score from the `Player_Attributes` table.\n2. Join the `Player` table with the `Player_Attributes` table to get player names and their potential scores.\n3. Filter the results to only include players whose potential matches the maximum potential score identified in step 1.\n4. Use `DISTINCT` to avoid duplicate entries for the same player, as the `Player_Attributes` table may contain multiple records per player.",
        "sql": "SELECT DISTINCT p.player_name, pa.potential\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes);",
        "question": "List all the football player with the highest potential score.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT DISTINCT(t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = (SELECT MAX(potential) FROM Player_Attributes) ",
        "evidence": [
            "potential score refers to potential; highest potential score refers to MAX(potential);",
            "The `Player_Attributes` table may contain duplicate entries for the same player, so `DISTINCT` is needed to avoid listing the same player multiple times.",
            "The `Player` table contains unique player entries, so joining with `Player_Attributes` ensures no duplicates in player names.\nThe `Player_Attributes` table stores multiple records per player, so filtering by the maximum potential requires a subquery.",
            "The `Player` table contains unique player entries, so joining with `Player_Attributes` ensures no duplicates in player names.\nThe `Player_Attributes` table stores multiple records per player, so filtering by the maximum potential requires a subquery."
        ]
    },
    "1414": {
        "reason": "To find the name of the major that Phillip Cullen has joined, we need to follow these steps:\n1. Identify Phillip Cullen in the `member` table using his first and last name.\n2. Retrieve the `link_to_major` field from his record, which references the `major_id` in the `major` table.\n3. Use this `major_id` to query the `major` table and retrieve the `major_name`.\n\nThe SQL query will join the `member` and `major` tables to accomplish this.",
        "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Phillip' AND mb.last_name = 'Cullen';",
        "question": "State the name of major that Phillip Cullen has joined.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "evidence": [
            "name of major refers to major_name"
        ]
    },
    "757": {
        "reason": "To identify the race of the superhero who weighed 169 kg, we need to follow these steps:\n1. Query the `superhero` table to find the superhero with a `weight_kg` of 169.\n2. Once we have the superhero's record, we can join it with the `race` table using the `race_id` from the `superhero` table to get the race name.\n3. The result will give us the race of the superhero who meets the weight criteria.",
        "sql": "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.weight_kg = 169;",
        "question": "Identify the race of the superhero who weighed 169 kg.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 169",
        "evidence": [
            "weighed 169 kg refers to weight_kg = 169"
        ]
    },
    "229": {
        "reason": "To find the type of bond that molecule TR000 has when involved in any bonds, we need to:\n1. Identify the bonds associated with the molecule TR000 by joining the `bond` table with the `molecule` table where the `molecule_id` is 'TR000'.\n2. Retrieve the `bond_type` from the `bond` table for these bonds.",
        "sql": "SELECT b.bond_type FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR000';",
        "question": "What is the type of bond that molecule TR000 has when involved in any bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.bond_type FROM bond AS T WHERE T.molecule_id = 'TR000'",
        "evidence": [
            "type of bond refers to bond_type; TR000 is the molecule id"
        ]
    },
    "1081": {
        "reason": "To determine which country the Belgium Jupiler League is from, we need to query the `League` table, which contains the league names and their associated country IDs. We then join this with the `Country` table to get the country name corresponding to the league. The query will filter the `League` table for the entry where the `name` is 'Belgium Jupiler League' and then retrieve the associated country name from the `Country` table.",
        "sql": "SELECT c.name AS country_name\nFROM League l\nJOIN Country c ON l.country_id = c.id\nWHERE l.name = 'Belgium Jupiler League';",
        "question": "Which country is the Belgium Jupiler League from?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "evidence": [
            "Belgium Jupiler League refers to League.name = 'Belgium Jupiler League';"
        ]
    },
    "415": {
        "reason": "To solve the question, we need to calculate the percentage of cards that are legal in the 'commander' format and do not have a content warning. Here's the step-by-step reasoning:\n\n1. **Filter Cards by Legal Status and Format**: Join the `cards` table with the `legalities` table to filter cards that have a 'legal' status in the 'commander' format.\n2. **Count Total Legal Cards**: Count the total number of cards that meet the above criteria.\n3. **Count Cards Without Content Warnings**: From the filtered cards, count those where `hasContentWarning` is 0 (indicating no content warning).\n4. **Calculate Percentage**: Divide the count of cards without content warnings by the total count of legal cards, then multiply by 100 to get the percentage.\n5. **Ensure Accurate Division**: Use explicit casting to REAL to ensure the division is accurate.\n\nThe final query will join the `cards` and `legalities` tables, apply the necessary filters, and perform the calculation.",
        "sql": "SELECT (CAST(COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) AS REAL) / CAST(COUNT(*) AS REAL) * 100 AS percentage\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'commander' AND l.status = 'legal';",
        "question": "What percentage of cards with format commander and legal status do not have a content warning?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
        "evidence": [
            "do not have a content warning refers to hasContentWarning = 0; percentage refers to DIVIDE(COUNT(hasContentWarning = 0),COUNT(ID))*100 where format = 'commander' AND Status = 'legal';",
            "The calculation of percentage requires explicit casting to REAL for accurate division. The join between 'cards' and 'legalities' must ensure the correct filtering of cards with 'Legal' status in the 'commander' format.",
            "The calculation of percentage requires summing the count of cards without content warnings and dividing by the total count of cards, ensuring both counts are derived from the same filtered set.",
            "The join between 'cards' and 'legalities' must ensure the correct filtering of cards with 'Legal' status in the 'commander' format, and the calculation should use explicit casting to REAL for accurate division."
        ]
    },
    "396": {
        "reason": "To solve the question, we need to find the number of cards that meet the following criteria:\n1. Have a frame version of \"1993\".\n2. Are available on paper (i.e., `hasNonFoil` or `hasFoil` is 1).\n3. Have a sensitive content warning (i.e., `hasContentWarning` is 1).\n\nWe will query the `cards` table and count the rows that satisfy all these conditions.",
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE frameVersion = '1993' \nAND (hasNonFoil = 1 OR hasFoil = 1) \nAND hasContentWarning = 1;",
        "question": "How many cards with a 1993 frame version and available on paper have a sensitive content warning?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE frameVersion = 1993 AND availability = 'paper' AND hasContentWarning = 1",
        "evidence": [
            "sensitive content warning refer to hasContentWarning = 1; available on paper refer to availability = 'paper' 1993 refer to frameVersion"
        ]
    },
    "915": {
        "reason": "To find the country of the oldest driver, we need to determine the driver with the earliest date of birth (dob) from the `drivers` table. Once we identify this driver, we can retrieve their nationality (country). The query will involve selecting the `nationality` of the driver with the minimum `dob` value.",
        "sql": "SELECT nationality FROM drivers WHERE dob = (SELECT MIN(dob) FROM drivers);",
        "question": "Which country is the oldest driver from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1",
        "evidence": [
            "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;"
        ]
    },
    "1009": {
        "reason": "To solve the question, we need to find the time each driver spent at the pit stop during the 2011 Australian Grand Prix. Here's the step-by-step reasoning:\n\n1. **Identify the race**: The race is the 2011 Australian Grand Prix. We need to find the `raceId` for this race from the `races` table by filtering on the `year` (2011) and `name` (Australian Grand Prix).\n\n2. **Join with pitStops**: Once we have the `raceId`, we can join the `pitStops` table with the `races` table using `raceId` to get all pit stop records for this race.\n\n3. **Join with drivers**: To get the driver names, we need to join the `pitStops` table with the `drivers` table using `driverId`.\n\n4. **Select relevant columns**: We need to select the driver's name (from the `drivers` table) and the pit stop duration (from the `pitStops` table).\n\n5. **Order the results**: Optionally, we can order the results by driver name or pit stop duration for better readability.\n\nPutting it all together, the query will involve joining the `races`, `pitStops`, and `drivers` tables, filtering for the specific race, and selecting the required columns.",
        "sql": "SELECT d.forename || ' ' || d.surname AS driver_name, ps.duration AS pit_stop_duration\nFROM pitStops ps\nJOIN races r ON ps.raceId = r.raceId\nJOIN drivers d ON ps.driverId = d.driverId\nWHERE r.year = 2011 AND r.name = 'Australian Grand Prix'\nORDER BY driver_name;",
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "evidence": [
            "time spent at pit stop refers to duration",
            "The pitStops table records pit stop durations for drivers, linked to races via raceId.\nTo filter for a specific race, join pitStops with races using raceId and apply year and name conditions.",
            "The pitStops table directly contains the duration of pit stops, which is the required metric for time spent.\nTo filter for a specific race, join pitStops with races using raceId and apply year and name conditions.",
            "The pitStops table directly contains the duration of pit stops, which is the required metric for time spent.\nTo filter for a specific race, join pitStops with races using raceId and apply year and name conditions."
        ]
    },
    "803": {
        "reason": "To find the power ID of 'cryokinesis', we need to query the `superpower` table where the `power_name` exactly matches 'cryokinesis'. Since the `power_name` is case-sensitive, we must ensure the query matches the exact capitalization. The query will select the `id` column from the `superpower` table where `power_name` is 'cryokinesis'.",
        "sql": "SELECT id FROM superpower WHERE power_name = 'cryokinesis';",
        "question": "What is the power ID of cryokinesis?",
        "db_id": "superhero",
        "res": 0,
        "ground_truth": "SELECT id FROM superpower WHERE power_name = 'Cryokinesis'",
        "evidence": [
            "power ID refers to superpower.id; cryokinesis refers to power_name = 'cryokinesis';",
            "The `power_name` in the `superpower` table is case-sensitive, requiring exact matches for filtering.",
            "The `power_name` in the `superpower` table requires exact case matching, including capitalization, for filtering.",
            "The `power_name` in the `superpower` table must match the exact capitalization of the value being queried, as it is case-sensitive."
        ]
    },
    "640": {
        "reason": "To calculate the difference in view count between posts posted by 'Mornington' and posts posted by 'Amos', we need to follow these steps:\n\n1. **Filter Users**: First, identify the users with the display names 'Mornington' and 'Amos' from the `users` table.\n2. **Join with Posts**: For each of these users, join their user IDs with the `posts` table to get the posts they have created (either directly as the owner or indirectly via the `postHistory` table).\n3. **Calculate View Counts**: Sum the `ViewCount` for posts associated with 'Mornington' and separately for posts associated with 'Amos'.\n4. **Compute Difference**: Subtract the total view count for 'Amos' from the total view count for 'Mornington' to get the desired difference.\n\nWe will use conditional aggregation to compute the sums directly in a single query pass, ensuring efficiency and accuracy.",
        "sql": "SELECT \n    (SUM(CASE WHEN u.DisplayName = 'Mornington' THEN p.ViewCount ELSE 0 END) - \n    SUM(CASE WHEN u.DisplayName = 'Amos' THEN p.ViewCount ELSE 0 END)) AS view_count_difference\nFROM \n    users u\nLEFT JOIN \n    posts p ON u.Id = p.OwnerUserId\nLEFT JOIN \n    postHistory ph ON u.Id = ph.UserId AND p.Id = ph.PostId\nWHERE \n    u.DisplayName IN ('Mornington', 'Amos');",
        "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "evidence": [
            "calculation = SUBTRACT(SUM(ViewCount where DisplayName = 'Mornington'), SUM(ViewCount where DisplayName = 'Amos'));",
            "The `postHistory` table links users to posts via `UserId` and `PostId`, providing an alternative path to associate users with posts.\nUse conditional aggregation with `IIF` to compute differences directly in a single query pass.\nThe `DisplayName` filter should be applied to the `users` table before joining with `posts`.",
            "The `postHistory` table serves as an intermediary linking users to posts, requiring joins through `UserId` and `PostId` for accurate post attribution.\nConditional aggregation should account for both direct (`OwnerUserId`) and indirect (`postHistory`) user-post relationships.\nFiltering by `DisplayName` must precede joins to ensure only relevant users are included in calculations.",
            "The `postHistory` table is essential for linking users to posts when the direct `OwnerUserId` relationship is not sufficient.\nConditional aggregation should include both direct and indirect user-post relationships for accurate calculations.\nFiltering by `DisplayName` must be applied to the `users` table before joining with intermediary tables."
        ]
    },
    "168": {
        "reason": "To solve the question, we need to find the percentage of female clients who opened their accounts in districts with an average salary (A11 in the district table) of over 10000. The steps are as follows:\n1. Identify districts with an average salary (A11) greater than 10000.\n2. Join the `district` table with the `client` table to find clients in these districts.\n3. Filter the clients to only include women (gender = 'F').\n4. Count the total number of clients in these districts and the number of female clients.\n5. Calculate the percentage of female clients by dividing the number of female clients by the total number of clients and multiplying by 100.",
        "sql": "WITH high_salary_districts AS (\n    SELECT district_id\n    FROM district\n    WHERE A11 > 10000\n),\nclients_in_high_salary_districts AS (\n    SELECT c.client_id, c.gender\n    FROM client c\n    JOIN high_salary_districts hsd ON c.district_id = hsd.district_id\n),\ntotal_clients AS (\n    SELECT COUNT(*) AS total\n    FROM clients_in_high_salary_districts\n),\nfemale_clients AS (\n    SELECT COUNT(*) AS female\n    FROM clients_in_high_salary_districts\n    WHERE gender = 'F'\n)\nSELECT (female * 100.0 / total) AS percentage_female\nFROM female_clients, total_clients;",
        "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
        "evidence": [
            "Female refers to gender = 'F'; Woman and female are closed; Average salary can be found in A11",
            "The `client` table directly links to `district` via `district_id`, bypassing the need for intermediate joins through `account` and `disp`.\nAverage salary filtering should directly apply to the `district` table before joining with `client`.\nCounting and percentage calculation can be streamlined using conditional aggregation."
        ]
    },
    "1270": {
        "reason": "To solve the question, we need to find the number of female patients with a normal anti-scl70 (SC170 IN('negative', '0')) and no symptoms (Symptoms IS NULL). The steps are as follows:\n1. Identify patients with normal anti-scl70 from the Laboratory table where SC170 is either 'negative' or '0'.\n2. Join these patients with the Patient table to filter for female patients (SEX = 'F').\n3. Further filter these patients to ensure they have no symptoms by checking the Examination table where Symptoms IS NULL.\n4. Count the distinct patients who meet all these criteria.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.SC170 IN('negative', '0') \nAND P.SEX = 'F' \nAND E.Symptoms IS NULL;",
        "question": "Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.SC170 = 'negative' OR T2.SC170 = '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL",
        "evidence": [
            "normal anti-scl70 refers to SC170 IN('negative', '0'); female refers to Sex = 'F'; does not have any symptom refers to symptoms IS NULL; Should consider DISTINCT in the final result;"
        ]
    },
    "1403": {
        "reason": "To solve the question, we need to find the name of the closed event whose cost has exceeded the budget the most. Here's the step-by-step reasoning:\n\n1. **Identify Closed Events**: First, filter events where the status is 'Closed'.\n2. **Link to Budget**: For these closed events, join with the budget table to get the budget details.\n3. **Exceeded Budget**: Calculate the remaining budget. The event that exceeded the budget the most will have the smallest (most negative) remaining value.\n4. **Retrieve Event Name**: From the filtered and joined data, select the event_name of the event with the smallest remaining budget.\n\nThis involves joining the `event` and `budget` tables, filtering for closed events, and then finding the event with the most negative remaining budget.",
        "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.status = 'Closed' AND b.remaining < 0\nORDER BY b.remaining ASC\nLIMIT 1;",
        "question": "Indicate the name of the closed event whose cost has exceeded the budget the most.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event WHERE T1.event_status = 'Closed' AND T1.remaining < 0 ORDER BY T1.remaining LIMIT 1",
        "evidence": [
            "closed events refers to event_name where status = 'Closed'; exceed the budget the most refers to MIN(remaining) where remaining < 0"
        ]
    },
    "131": {
        "reason": "To find the district with the highest active loan, we need to follow these steps:\n1. Identify active loans in the `loan` table where the status is either 'C' or 'D'.\n2. Join the `loan` table with the `account` table to link loans to their respective accounts.\n3. Join the `account` table with the `district` table to get the district names (`A3`).\n4. Group the results by district name (`A3`) and calculate the sum of loan amounts for each district.\n5. Order the results by the sum of loan amounts in descending order to find the district with the highest active loan.\n6. Limit the result to the top district.",
        "sql": "SELECT d.A3 AS district_name, SUM(l.amount) AS total_active_loan_amount\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.status IN ('C', 'D')\nGROUP BY d.A3\nORDER BY total_active_loan_amount DESC\nLIMIT 1;",
        "question": "Which district has highest active loan?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.status IN ('C', 'D') GROUP BY T2.A3 ORDER BY SUM(T3.amount) DESC LIMIT 1",
        "evidence": [
            "A3 refers to district names; Active loan refers to running contracts; Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
            "Active loans are filtered by status 'C' or 'D' in the loan table. The highest active loan is determined by the sum of loan amounts, not the count of loans. District names are retrieved from the district table via the account table.",
            "The `account` table serves as the central link between `loan` and `district` tables, requiring joins through it to connect loan data to district names. Aggregation by district name (`A3`) must follow the join sequence to ensure correct grouping.",
            "The `account` table is the intermediary for linking `loan` and `district` tables, requiring sequential joins to connect loan data to district names. Aggregation must be performed after all joins to ensure accurate grouping by district."
        ]
    },
    "1477": {
        "reason": "To solve the question, we need to find the year with the highest gas consumption paid in EUR. Here's the step-by-step reasoning:\n\n1. **Filter customers by currency**: We need to include only customers who use EUR as their currency. This is done by joining the `customers` table with the `yearmonth` table on `CustomerID` and filtering where `Currency` is 'EUR'.\n\n2. **Extract the year from the date**: The `Date` column in the `yearmonth` table is stored as text, so we'll use the `SUBSTRING` function to extract the year component.\n\n3. **Sum the consumption by year**: We'll group the results by the extracted year and sum the `Consumption` values for each year.\n\n4. **Order by total consumption**: Finally, we'll order the results by the summed consumption in descending order to find the year with the highest gas use.\n\n5. **Limit the result**: Since we only need the top year, we'll limit the result to 1.",
        "sql": "SELECT SUBSTRING(Date, 1, 4) AS Year, SUM(Consumption) AS TotalConsumption\nFROM yearmonth\nJOIN customers ON yearmonth.CustomerID = customers.CustomerID\nWHERE customers.Currency = 'EUR'\nGROUP BY Year\nORDER BY TotalConsumption DESC\nLIMIT 1;",
        "question": "Which year recorded the most gas use paid in EUR?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT SUBSTRING(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY SUBSTRING(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "evidence": [
            "",
            "The `yearmonth` table tracks gas consumption (`Consumption`) by customer and date, while the `transactions_1k` table records individual transactions with `Amount` and `Price`.\nTo analyze gas use, the `yearmonth` table provides aggregated consumption data, which is more suitable than summing `Amount` from transactions.\nThe `Currency` filter should be applied via the `customers` table, as it contains the currency information for each customer.",
            "The `Date` column in the `yearmonth` table is stored as text, requiring substring extraction to isolate the year component for grouping.\nAggregation functions like `SUM` should be directly referenced in the `ORDER BY` clause to sort results by total consumption.",
            "The `SUBSTRING` function is used to extract the year from the `Date` column in the `yearmonth` table, which is stored as text.\nAggregation functions like `SUM` should be directly referenced in the `ORDER BY` clause to sort results by total consumption.\nThe `Currency` filter should be applied via the `customers` table, as it contains the currency information for each customer."
        ]
    },
    "252": {
        "reason": "To find the atoms that can bond with the atom that has the element lead (Pb), we need to follow these steps:\n1. Identify the `atom_id` of the lead atom (where `element = 'pb'`).\n2. Use the `connected` table to find all bonds involving this lead atom. Since the `connected` table records bonds bidirectionally, we need to check both `atom_id` and `atom_id2` columns for the lead atom's `atom_id`.\n3. For each bond found, retrieve the other atom involved in the bond (either `atom_id` or `atom_id2`, whichever is not the lead atom).\n4. Join this result with the `atom` table to get the details of the bonded atoms (e.g., their `element`).",
        "sql": "SELECT DISTINCT a2.atom_id, a2.element\nFROM atom a1\nJOIN connected c ON (a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2)\nJOIN atom a2 ON (a2.atom_id = CASE WHEN a1.atom_id = c.atom_id THEN c.atom_id2 ELSE c.atom_id END)\nWHERE a1.element = 'pb' AND a2.atom_id != a1.atom_id;",
        "question": "What are the atoms that can bond with the atom that has the element lead?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'pb'",
        "evidence": [
            "atom that has the element lead refers to atom_id where element = 'pb'",
            "The `connected` table records bonding pairs, where `atom_id` and `atom_id2` represent the two atoms involved in a bond.\nTo find atoms bonded to a specific atom, only one direction of the bond (either `atom_id` or `atom_id2`) needs to be checked, as the relationship is bidirectional.",
            "The `connected` table records bonding pairs, where `atom_id` represents the first atom and `atom_id2` represents the second atom in the bond.\nTo find atoms bonded to a specific atom, the query should focus on one direction of the bond (either `atom_id` or `atom_id2`) to avoid redundancy.",
            "The `connected` table records bonding pairs, where `atom_id` represents the first atom and `atom_id2` represents the second atom in the bond.\nTo find atoms bonded to a specific atom, the query should focus on one direction of the bond (either `atom_id` or `atom_id2`) to avoid redundancy."
        ]
    },
    "577": {
        "reason": "To find all comments made by the user 'A Lion', we need to query the `comments` table. The `comments` table contains a column `UserId` which references the `users` table, and the `users` table has a `DisplayName` column. We will join these tables to match the `DisplayName` 'A Lion' with the corresponding `UserId`, and then filter the comments based on this `UserId`.",
        "sql": "SELECT c.Text FROM comments c JOIN users u ON c.UserId = u.Id WHERE u.DisplayName = 'A Lion';",
        "question": "Write all comments made by user 'A Lion.'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Text FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'A Lion'",
        "evidence": [
            "\"A Lion\" is the DisplayName of user; comment refers to Text"
        ]
    },
    "1450": {
        "reason": "The question asks for the city and country of events where there are more than forty incomes. However, the schema and tips clarify that the focus is on incomes with amounts over forty, not the count of incomes per event. Additionally, the location details (city and country) are derived from the member's zip code, not the event's location. Therefore, the query should:\n1. Identify incomes with amounts over forty.\n2. Link these incomes to members to get their zip codes.\n3. Use the zip codes to retrieve the city and country from the zip_code table.\n4. Since the question mentions \"events with more than forty incomes,\" but the schema clarifies that it's about incomes over forty, the query should filter incomes with amounts > 40 and then link them to members and their locations.",
        "sql": "SELECT DISTINCT z.city, z.county\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE i.amount > 40;",
        "question": "In the events with more than forty incomes, list the city and country in which the event is happening.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.city, T3.county FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip WHERE T1.amount > 40",
        "evidence": [
            "more than fifty incomes refers to income > 40",
            "The income table directly links to members, and members link to zip codes for location details. Events are not required to filter incomes by count; instead, incomes with amounts over forty are the focus.",
            "The query should focus on incomes with amounts over forty, not counting incomes per event. The location details are derived from the member's zip code, not the event's location."
        ]
    },
    "1475": {
        "reason": "To solve the question, we need to find the number of customers in the KAM segment who had a total consumption of less than 30,000 for the year 2012. Here's the step-by-step reasoning:\n\n1. **Identify the KAM segment**: The `Segment` column in the `customers` table identifies the customer segment. We need to filter customers where `Segment` is 'KAM'.\n\n2. **Filter for the year 2012**: The `Date` column in the `yearmonth` table can be filtered to include only records from 2012. This can be done by checking if the `Date` starts with '2012' (using `SUBSTRING` or `LIKE`).\n\n3. **Calculate total consumption per customer**: For each customer in the KAM segment, we need to sum their `Consumption` values for 2012.\n\n4. **Filter customers with consumption < 30,000**: After aggregating the consumption, we filter out customers whose total consumption is less than 30,000.\n\n5. **Count the remaining customers**: Finally, we count the number of customers who meet the criteria.\n\n6. **Use a subquery**: The aggregation and filtering should be done in a subquery to ensure correct grouping and filtering before counting.",
        "sql": "SELECT COUNT(*) AS CustomerCount\nFROM (\n    SELECT y.CustomerID, SUM(y.Consumption) AS TotalConsumption\n    FROM yearmonth y\n    JOIN customers c ON y.CustomerID = c.CustomerID\n    WHERE c.Segment = 'KAM'\n    AND y.Date LIKE '2012%'\n    GROUP BY y.CustomerID\n    HAVING SUM(y.Consumption) < 30000\n) AS FilteredCustomers;",
        "question": "How many customers in KAM had a consumption of less than 30,000 for the year 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T2.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND SUBSTRING(T2.Date, 1, 4) = '2012' GROUP BY T2.CustomerID HAVING SUM(T2.Consumption) < 30000 ) AS t1",
        "evidence": [
            "Year 2012 can be presented as Between 201201 And 201212, which means between January and December in 2012",
            "The `Date` column in the `yearmonth` table can be filtered by year using `SUBSTRING` to extract the first four characters representing the year.\nAggregation should be performed before counting to ensure the correct grouping of customers by their total consumption.",
            "The `HAVING` clause should be applied after aggregating the total consumption per customer, not within the same query level as the `GROUP BY`.\nA subquery is needed to first aggregate consumption per customer and then filter the results based on the aggregated value."
        ]
    },
    "206": {
        "reason": "To find the elements in the TR004_8_9 bond atoms, we need to follow these steps:\n1. Identify the bond with the ID 'TR004_8_9' in the `bond` table.\n2. Find the atoms connected by this bond in the `connected` table.\n3. Retrieve the elements of these atoms from the `atom` table.\n\nThe query will join the `bond`, `connected`, and `atom` tables to get the required information.",
        "sql": "SELECT a.element \nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_id = 'TR004_8_9';\n",
        "question": "What elements are in the TR004_8_9 bond atoms?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'",
        "evidence": [
            "TR004_8_9 bond atoms refers to bond_id = 'TR004_8_9';"
        ]
    },
    "704": {
        "reason": "To find the excerpt post ID and wiki post ID of the tag named 'sample', we need to query the `tags` table. The `tags` table contains columns `TagName`, `ExcerptPostId`, and `WikiPostId`. We will filter the rows where `TagName` is 'sample' and retrieve the corresponding `ExcerptPostId` and `WikiPostId`.",
        "sql": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample';",
        "question": "What is the excerpt post ID and wiki post ID of the tag named sample?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'",
        "evidence": [
            "tag named sample refers to TagName = 'sample';"
        ]
    },
    "1024": {
        "reason": "To find the top 5 players who perform better in crossing actions, we need to query the `Player_Attributes` table and sort the results by the `crossing` attribute in descending order. The `crossing` attribute directly measures a player's performance in crossing actions. We will limit the results to the top 5 players and include their `player_api_id` to identify them. The `id` column in `Player_Attributes` is not necessary for this query since we are interested in the player's identifier (`player_api_id`).",
        "sql": "SELECT player_api_id, crossing FROM Player_Attributes ORDER BY crossing DESC LIMIT 5;",
        "question": "Who are the top 5 players who perform better in crossing actions? Indicate their player id.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5",
        "evidence": [
            "perform better in crossing actions refers to MAX(crossing)",
            "The `Player_Attributes` table contains the `crossing` attribute, which directly measures a player's performance in crossing actions.\nTo identify top performers, sorting by `crossing` in descending order and limiting results is sufficient.\nJoining with the `Player` table is unnecessary if only the player IDs from `Player_Attributes` are required.",
            "The `id` column in `Player_Attributes` uniquely identifies each record, while `player_api_id` is a foreign key referencing the `Player` table.\nTo retrieve the correct player identifiers, use the `id` column from `Player_Attributes` instead of `player_api_id`.",
            "The `id` column in `Player_Attributes` is the primary key and uniquely identifies each record, while `player_api_id` is a foreign key referencing the `Player` table.\nTo retrieve the correct player identifiers for top performers, use the `id` column from `Player_Attributes` instead of `player_api_id`."
        ]
    },
    "1127": {
        "reason": "To solve the question, we need to identify players with vision scores of 90 and above and then determine the country of these players. The steps are as follows:\n1. Join the `Player_Attributes` table with the `Player` table to get the player names and their vision scores.\n2. Filter the results to include only players with vision scores greater than 89.\n3. Join the `Player` table with the `Match` table to link players to their matches.\n4. Join the `Match` table with the `Country` table to get the country names associated with the matches.\n5. Group the results by player and country to avoid duplicates.\n6. Select the player names and their respective countries.",
        "sql": "SELECT DISTINCT p.player_name, c.name AS country\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nJOIN Match m ON p.player_api_id = m.home_player_1 OR p.player_api_id = m.home_player_2 OR p.player_api_id = m.home_player_3 OR p.player_api_id = m.home_player_4 OR p.player_api_id = m.home_player_5 OR p.player_api_id = m.home_player_6 OR p.player_api_id = m.home_player_7 OR p.player_api_id = m.home_player_8 OR p.player_api_id = m.home_player_9 OR p.player_api_id = m.home_player_10 OR p.player_api_id = m.home_player_11 OR p.player_api_id = m.away_player_1 OR p.player_api_id = m.away_player_2 OR p.player_api_id = m.away_player_3 OR p.player_api_id = m.away_player_4 OR p.player_api_id = m.away_player_5 OR p.player_api_id = m.away_player_6 OR p.player_api_id = m.away_player_7 OR p.player_api_id = m.away_player_8 OR p.player_api_id = m.away_player_9 OR p.player_api_id = m.away_player_10 OR p.player_api_id = m.away_player_11\nJOIN Country c ON m.country_id = c.id\nWHERE pa.vision > 89\nORDER BY p.player_name;",
        "question": "Locate players with vision scores of 90 and above, state the country of these players.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT DISTINCT t4.name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id INNER JOIN Match AS t3 ON t2.player_api_id = t3.home_player_8 INNER JOIN Country AS t4 ON t3.country_id = t4.id WHERE t1.vision > 89",
        "evidence": [
            "vision scores of 90 and above refers to vision > 89",
            "The `Match` table links players to countries via `country_id`, but only specific player positions (e.g., `home_player_8`) are directly associated with the match.\nTo avoid redundancy, focus on a single player position column in the `Match` table for joining with `Player`.",
            "The `Match` table associates players with countries via `country_id`, but players can appear in multiple position columns (e.g., `home_player_1` to `home_player_11`).\nTo ensure all players are considered, any player position column in the `Match` table can be used for joining with `Player`.",
            "The `Match` table links players to countries via `country_id`, but only specific player positions (e.g., `home_player_8`) are directly associated with the match.\nTo avoid redundancy, focus on a single player position column in the `Match` table for joining with `Player`."
        ]
    },
    "558": {
        "reason": "To solve the question, we need to find out how many votes the user with ID 58 received on July 19, 2010. The relevant table for this query is the `votes` table, which contains information about votes, including the `UserId` (who received the vote) and the `CreationDate` (when the vote was cast). We will filter the records where `UserId` is 58 and the `CreationDate` is '2010-07-19'. Finally, we will count the number of such records to get the total votes received by the user on that date.",
        "sql": "SELECT COUNT(*) AS vote_count FROM votes WHERE UserId = 58 AND DATE(CreationDate) = '2010-07-19';",
        "question": "How many votes did the user No.58 take on 2010/7/19?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19'",
        "evidence": [
            "user no. 58 refers to UserId = 58; on 2010/7/19 refers to CreationDate = '2010-07-19'"
        ]
    },
    "526": {
        "reason": "To solve the question, we need to find the number of cards designed by Matthew D. Wilson that are available only in the paper. The steps are as follows:\n1. Identify cards where the `artist` is 'Matthew D. Wilson'.\n2. Among these cards, filter those that are available only in the paper. This can be inferred from the `availability` column, which likely contains information about the card's availability (e.g., 'paper', 'online', or both).\n3. Count the number of such cards.\n\nThe query will join the `cards` table with itself to ensure we are only counting cards that meet both criteria.",
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'Matthew D. Wilson' \nAND availability = 'paper';",
        "question": "Among the card designed by Matthew D. Wilson, how many are available only in the paper?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper'",
        "evidence": [
            "card designed by Matthew D. Wilson refers to artist = 'Matthew D. Wilson'; available only in the paper refers to availability = 'paper'"
        ]
    },
    "519": {
        "reason": "To find the language of the \"Battlebond\" set, we need to follow these steps:\n1. First, identify the `code` of the \"Battlebond\" set from the `sets` table, as the `set_translations` table references the `sets` table via the `setCode` field.\n2. Once we have the `code` for \"Battlebond\", we can query the `set_translations` table to find the `language` associated with that `setCode`.\n3. The query will involve joining the `sets` and `set_translations` tables on the `code` and `setCode` fields, respectively, to retrieve the language information for the \"Battlebond\" set.",
        "sql": "SELECT st.language\nFROM set_translations st\nJOIN sets s ON st.setCode = s.code\nWHERE s.name = 'Battlebond';",
        "question": "What is the language of the \"Battlebond\" set?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM sets WHERE name = 'Battlebond' )",
        "evidence": [
            "\"Battlebond\" set refers to name = 'Battlebond'",
            "The `set_translations` table links to the `sets` table via `setCode`, which is a foreign key referencing the `code` field in `sets`.\nTo retrieve data for a specific set, first identify the set's `code` from the `sets` table, then use it to filter records in `set_translations`.",
            "The `sets` table contains a unique identifier `id` that can be used to directly link to the `set_translations` table without requiring a join.",
            "The `sets` table's `id` field is a primary key and can be directly used to link to the `set_translations` table without requiring a join."
        ]
    },
    "1332": {
        "reason": "To determine how much the Student_Club members spent on food in the September Meeting, we need to follow these steps:\n1. Identify the event_id for the event named 'September Meeting' from the 'event' table.\n2. Use this event_id to find the corresponding budget_id in the 'budget' table where the category is 'Food'.\n3. Sum the 'spent' column in the 'budget' table for the identified budget_id to get the total amount spent on food for the September Meeting.",
        "sql": "SELECT SUM(b.spent) AS total_spent_on_food\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'September Meeting' AND b.category = 'Food';",
        "question": "How much did the Student_Club members spend on food in September Meeting?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Food' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "evidence": [
            "amount spent refers to spent; spend on food in September Meeting refers to category = 'Food' where event_name = 'September Meeting'"
        ]
    },
    "789": {
        "reason": "To find the average weight of heroes who are aliens, we need to:\n1. Identify the `race_id` corresponding to 'Alien' in the `race` table.\n2. Join the `superhero` table with the `race` table to filter heroes who are aliens.\n3. Calculate the average weight (`weight_kg`) of these heroes.",
        "sql": "SELECT AVG(s.weight_kg) AS average_weight\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Alien';",
        "question": "Find the average weight of the heroes who are aliens.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "evidence": [
            "average = AVG(weight_kg); aliens refers to race = 'Alien';"
        ]
    },
    "371": {
        "reason": "To solve the question, we need to calculate the percentage of Story Spotlight cards that have French language data in the `foreign_data` table. Here's the step-by-step reasoning:\n\n1. **Identify Story Spotlight Cards**: Filter the `cards` table to include only cards where `isStorySpotlight = 1`.\n2. **Join with Foreign Data**: Perform an inner join between the filtered `cards` table and the `foreign_data` table to ensure we only consider cards with foreign data.\n3. **Count French Language Cards**: Count the number of Story Spotlight cards where the language is French (`language = 'French'`).\n4. **Count Total Story Spotlight Cards**: Count the total number of Story Spotlight cards.\n5. **Calculate Percentage**: Divide the count of French Story Spotlight cards by the total count of Story Spotlight cards and multiply by 100 to get the percentage.\n\nWe will use explicit casting to REAL for accurate division and SUM with CASE for counting specific conditions.",
        "sql": "SELECT \n    (SUM(CASE WHEN fd.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards c\nINNER JOIN \n    foreign_data fd ON c.uuid = fd.uuid\nWHERE \n    c.isStorySpotlight = 1;",
        "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1",
        "evidence": [
            "Story Spotlight card refers to isStorySpotlight = 1; French is the language; Percentage = Divide(Count(id) where language = 'French' and isStorySpotlight = 1, Count(id) where isStorySpotlight = 1)*100",
            "The `foreign_data` table contains language-specific attributes, requiring an inner join to ensure only cards with foreign data are considered.\nPercentage calculations should use explicit casting to REAL for accurate division.\nFiltering for Story Spotlight cards must be applied to the `cards` table before joining.",
            "An inner join is required to ensure only cards with foreign data are included in the calculation.\nPercentage calculations should use SUM with CASE for accurate counting of specific conditions.\nFiltering for Story Spotlight cards must be applied before joining to avoid incorrect counts."
        ]
    },
    "384": {
        "reason": "To solve the question, we need to list the UUIDs of legacy cards and their corresponding foreign languages. This involves the following steps:\n1. Identify legacy cards by checking the `legalities` table where the `format` is 'legacy'.\n2. Join the `legalities` table with the `cards` table to get the UUIDs of these legacy cards.\n3. Join the result with the `foreign_data` table to retrieve the foreign languages associated with these cards.\n4. Ensure the query returns the UUID from the `cards` table and the `language` from the `foreign_data` table.",
        "sql": "SELECT c.uuid, fd.language\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE l.format = 'legacy';",
        "question": "List down the uuid for legacy cards and the foreign language of these cards.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'",
        "evidence": [
            "legacy card refers to format = 'legacy'; foreign language refers to language in foreign_data",
            "legacy cards are identified by their format in the legalities table, requiring a join with the cards table to ensure completeness.\nforeign language data is linked to cards via the foreign_data table, necessitating a join with the cards table for accurate retrieval."
        ]
    },
    "296": {
        "reason": "To solve the question, we need to find the molecule ID associated with the bond named 'TR000_1_2' where the first atom is named 'TR000_1'. Here's the step-by-step reasoning:\n\n1. **Identify the bond**: The bond ID is given as 'TR000_1_2', so we need to filter the `bond` table for this bond ID.\n2. **Find the connected atoms**: The `connected` table links atoms to bonds. We need to find the entry where `bond_id` is 'TR000_1_2' and `atom_id` is 'TR000_1' (the first atom).\n3. **Retrieve the molecule ID**: The `bond` table contains the `molecule_id` for the bond, which we can join with the `connected` table to get the molecule ID.\n4. **Output the result**: The query should return the molecule ID associated with the bond 'TR000_1_2' and the atom 'TR000_1'.",
        "sql": "SELECT b.molecule_id\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.bond_id = 'TR000_1_2' AND c.atom_id = 'TR000_1';",
        "question": "Indicate the molecule id is belonging to the TR000_1_2 bond that has the first atom named TR000_1.",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T2.molecule_id, T2.bond_id, T1.atom_id FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'",
        "evidence": [
            "",
            "The `connected` table links atoms and bonds, requiring joins to retrieve molecule details from the `bond` table.\nTo identify a specific bond and its associated molecule, both the bond ID and atom ID must be filtered in the query.\nThe query should include the bond ID and atom ID in the result set for clarity and verification.",
            "The `connected` table includes both `atom_id` and `atom_id2` columns, so filtering on either can identify bonds involving specific atoms.\nTo retrieve bond and molecule details, the query must join the `connected` and `bond` tables, ensuring the bond ID matches the specified criteria.",
            "The query should include both the bond ID and atom ID in the result set for clarity and verification.\nTo ensure completeness, the result set should explicitly list the bond ID and atom ID alongside the molecule ID."
        ]
    },
    "853": {
        "reason": "To find the names of the races held on the circuits in Spain, we need to:\n1. Identify the circuits located in Spain from the `circuits` table.\n2. Join the `circuits` table with the `races` table to get the races held on these circuits.\n3. Filter the results to include only circuits where the `country` is 'Spain'.\n4. Select the `name` column from the `races` table to get the names of the races.",
        "sql": "SELECT r.name \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.country = 'Spain';",
        "question": "Please give the names of the races held on the circuits in Spain.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "evidence": [
            "Spain is a name of country;"
        ]
    },
    "255": {
        "reason": "To solve the question, we need to calculate the proportion of single bonds that are carcinogenic. The steps are as follows:\n1. Identify all single bonds (where `bond_type = '-'`).\n2. For each single bond, determine if the associated molecule is carcinogenic (where `label = '+'`).\n3. Calculate the proportion by dividing the count of carcinogenic single bonds by the total count of single bonds, then multiply by 100 to get the percentage.\n4. Format the result to five decimal places.\n\nThe query involves joining the `bond` table with the `molecule` table to check the `label` of the molecule associated with each bond. We then count the relevant bonds and compute the proportion.",
        "sql": "SELECT \n    ROUND((SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100.0) / COUNT(b.bond_id), 5) AS proportion\nFROM \n    bond b\nJOIN \n    molecule m ON b.molecule_id = m.molecule_id\nWHERE \n    b.bond_type = '-';",
        "question": "What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id),5) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'",
        "evidence": [
            "single bond refers to bond_type = '-'; label = '+' mean molecules are carcinogenic; proportion = DIVIDE(SUM(label = '+') * 100, COUNT(bond_id)) where bond_type = '-'"
        ]
    },
    "508": {
        "reason": "To solve the question, we need to find the available printing types of cards that meet two conditions: they are created by Aleksi Briclot (artist = 'Aleksi Briclot') and they do not have a text box (isTextless = 1). The available printing types are stored in the `availability` column of the `cards` table. The steps are as follows:\n1. Filter the `cards` table for rows where `artist` is 'Aleksi Briclot' and `isTextless` is 1.\n2. Select the `availability` column from these filtered rows to get the available printing types.",
        "sql": "SELECT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1;",
        "question": "What are the available printing types of the cards that doesn't have a text box created by Aleksi Briclot?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1",
        "evidence": [
            "created by Aleksi Briclot refers to artist = 'Aleksi Briclot'; doesn't have a text box refers to isTextless = 1; available printing types refers to availability"
        ]
    },
    "1239": {
        "reason": "To solve the question, we need to find patients who have undergone two or more laboratory examinations where their hematocrit (HCT) level exceeded the normal range (HCT >= 52). The steps are as follows:\n1. Calculate the age of each patient by subtracting their birth year from the current year.\n2. Identify patients who have at least two laboratory records with HCT >= 52.\n3. Return the ID and age of these patients.\n\nWe will use the `Patient` table to get the patient's ID and birthday, and the `Laboratory` table to check the HCT levels and count the number of valid records per patient.",
        "sql": "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age\nFROM Patient P\nWHERE P.ID IN (\n    SELECT L.ID\n    FROM Laboratory L\n    WHERE L.HCT >= 52\n    GROUP BY L.ID\n    HAVING COUNT(L.ID) >= 2\n);",
        "question": "Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )",
        "evidence": [
            "age = SUBTRACT(year(current_timestamp), year(Birthday)); patient with two or more laboratory examinations refers to COUNT(ID) > 2; hematoclit level exceeded the normal range refers to HCT > = 52;"
        ]
    },
    "593": {
        "reason": "To solve the question, we need to find the number of distinct users from New York who have both the 'Teacher' and 'Supporter' badges. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `badges` table contains information about badges, including the `Name` of the badge and the `UserId` of the user who earned it. The `users` table contains user details, including their `Location`.\n\n2. **Filter users by location**: We need to filter users whose `Location` is 'New York'.\n\n3. **Filter users by badges**: We need to ensure that the same user has both the 'Teacher' and 'Supporter' badges. This requires checking the `badges` table for entries where the `Name` is either 'Teacher' or 'Supporter' and the `UserId` matches the filtered users from New York.\n\n4. **Count distinct users**: Since a user can have multiple badges, we need to count distinct `UserId`s to avoid duplicates.\n\n5. **Join the tables**: Join the `users` table with the `badges` table to combine the location and badge information.\n\n6. **Use subqueries or grouping**: To ensure a user has both badges, we can use subqueries or group by `UserId` and count the distinct badge names.\n\n7. **Final count**: Count the distinct `UserId`s that meet all the criteria.",
        "sql": "SELECT COUNT(DISTINCT u.Id) AS UserCount\nFROM users u\nWHERE u.Location = 'New York'\nAND EXISTS (SELECT 1 FROM badges b1 WHERE b1.UserId = u.Id AND b1.Name = 'Teacher')\nAND EXISTS (SELECT 1 FROM badges b2 WHERE b2.UserId = u.Id AND b2.Name = 'Supporter');",
        "question": "How many users from New York have a teacher and supporter badge?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name IN ('Supporter', 'Teacher') AND T2.Location = 'New York'",
        "evidence": [
            "\"Supporter\" and \"Teachers\" are both Name of badge; 'New York' is the Location; user refers to UserId",
            "The badges table contains multiple entries per user, so filtering for users with both badges requires checking for the presence of both badge names in the same table.\nThe Location column in the users table is used to filter users by geographic criteria.\nCounting distinct users ensures each user is only counted once regardless of badge multiplicity.",
            "The badges table is the primary table for filtering users by badge names, and the users table provides location data.\nCounting distinct users requires joining the badges table to the users table and filtering for both badge names and location.",
            "The badges table can be joined directly to the users table to filter for both badge names and location in a single query.\nCounting distinct users requires ensuring the query includes all relevant badge names without duplicating user counts."
        ]
    },
    "1532": {
        "reason": "To solve the question, we need to find the country of the gas station that sold the most expensive product with ProductID 2 for one unit. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: We need data from the `transactions_1k` table (for transactions involving ProductID 2 and their prices) and the `gasstations` table (to get the country of the gas station).\n\n2. **Filter transactions for ProductID 2**: We will filter the `transactions_1k` table to only include transactions where `ProductID = 2`.\n\n3. **Find the most expensive transaction for ProductID 2**: We will sort the filtered transactions by `Price` in descending order and limit the result to the top record to find the highest price.\n\n4. **Retrieve the country of the gas station**: Using the `GasStationID` from the most expensive transaction, we will join with the `gasstations` table to get the `Country`.\n\n5. **Return the country**: The final result will be the `Country` from the `gasstations` table.",
        "sql": "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.ProductID = 2\nORDER BY t.Price DESC\nLIMIT 1;",
        "question": "Which country had the gas station that sold the most expensive product id No.2 for one unit?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.ProductID = 2 ORDER BY T1.Price DESC LIMIT 1",
        "evidence": [
            ""
        ]
    },
    "1027": {
        "reason": "To solve the question, we need to find the top 10 players with the highest number of penalties. The steps are as follows:\n1. Join the `Player` table with the `Player_Attributes` table using `player_api_id` to link the player's name with their attributes.\n2. Group the results by `player_api_id` and `player_name` to ensure each player is counted once.\n3. Use the `MAX(penalties)` function to get the highest penalty value for each player.\n4. Order the results by the `penalties` value in descending order to get the top players.\n5. Limit the results to the top 10 players.",
        "sql": "SELECT p.player_name, MAX(pa.penalties) AS highest_penalties\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nGROUP BY p.player_api_id, p.player_name\nORDER BY highest_penalties DESC\nLIMIT 10;",
        "question": "Indicate the full names of the top 10 players with the highest number of penalties.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t2.player_name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.id = t2.id ORDER BY t1.penalties DESC LIMIT 10",
        "evidence": [
            "full name refers to player_name; players with highest number of penalties refers to MAX(penalties);",
            "The `Player_Attributes` table links to the `Player` table via `player_api_id`, not `id`.\nTo retrieve the latest attributes for each player, ensure the join uses the correct linking field.",
            "The `Player_Attributes` table links to the `Player` table via `player_api_id`, not `id`.\nTo retrieve the latest attributes for each player, ensure the join uses the correct linking field."
        ]
    },
    "1005": {
        "reason": "To find the longest time a driver had ever spent at a pit stop, we need to query the `pitStops` table. The `duration` column in this table stores the time spent at each pit stop. By sorting the `duration` column in descending order and limiting the result to the top row, we can identify the longest duration. No additional joins are required for this query since all necessary information is available in the `pitStops` table.",
        "sql": "SELECT MAX(duration) AS longest_pitstop_duration FROM pitStops;",
        "question": "What was the longest time a driver had ever spent at a pit stop?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1",
        "evidence": [
            "longest time spent at pitstop refers to MAX(duration)",
            "The `pitStops` table's `duration` column stores the time spent at each pit stop, and the longest duration can be identified by sorting in descending order and limiting to the top result.",
            "The `pitStops` table's `duration` column directly provides the time spent at each pit stop, and no additional joins are necessary to retrieve the longest duration."
        ]
    },
    "1131": {
        "reason": "To find the average height of Italy players, we need to follow these steps:\n1. Identify the `Country` table to filter for Italy by its name.\n2. Join the `Match` table with the `Country` table using `country_id` to get matches involving Italy.\n3. Join the `Player` table with the `Match` table using `player_api_id` to get players who participated in these matches.\n4. Calculate the average height of these players using the `AVG` function on the `height` column from the `Player` table.\n5. Ensure the query is precise by using `CAST` if necessary.",
        "sql": "SELECT AVG(CAST(p.height AS REAL)) AS average_height\nFROM Player p\nJOIN Match m ON p.player_api_id IN (\n    m.home_player_1, m.home_player_2, m.home_player_3, m.home_player_4, m.home_player_5,\n    m.home_player_6, m.home_player_7, m.home_player_8, m.home_player_9, m.home_player_10, m.home_player_11,\n    m.away_player_1, m.away_player_2, m.away_player_3, m.away_player_4, m.away_player_5,\n    m.away_player_6, m.away_player_7, m.away_player_8, m.away_player_9, m.away_player_10, m.away_player_11\n)\nJOIN Country c ON m.country_id = c.id\nWHERE c.name = 'Italy';",
        "question": "What is the average heights of Italy players?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) FROM Player AS T1 INNER JOIN Match AS T2 ON T1.id = T2.id INNER JOIN Country AS T3 ON T2.country_id = T3.ID WHERE T3.NAME = 'Italy'",
        "evidence": [
            "average heights refers to Avg(height); Italy is name of country",
            "The `Player` table contains player height data, while the `Match` table links players to countries via `country_id`.\nTo filter players by country, join `Player` with `Match` and `Country` using the correct foreign keys.\nThe average height calculation should use `CAST` to ensure precision.",
            "The `Player` table links to `Match` via `player_api_id`, not directly through `id`.\nTo filter players by country, join `Player` with `Match` using `player_api_id` and then with `Country`.\nThe average height calculation should use `SUM` and `COUNT` for precision.",
            "The `Player` table links to `Match` via `player_api_id`, not through `id`.\nTo filter players by country, join `Player` with `Match` using `player_api_id` and then with `Country`.\nThe average height calculation should use `SUM` and `COUNT` for precision."
        ]
    },
    "534": {
        "reason": "To find the display name of the user who has the most number of views, we need to query the `users` table. The `users` table contains the `DisplayName` and `Views` columns. We will sort the users by the `Views` column in descending order and limit the result to the top 1 to get the user with the highest number of views. Finally, we will select the `DisplayName` of that user.",
        "sql": "SELECT DisplayName FROM users ORDER BY Views DESC LIMIT 1;",
        "question": "What is the display name of the user who has the most number of views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "evidence": [
            "user who has the most number of view refers to Max(Views)"
        ]
    },
    "1196": {
        "reason": "To find the most common sign of patients with SLE disease, we need to:\n1. Filter the `Examination` table to include only patients with a `Diagnosis` of 'SLE'.\n2. Extract and count the occurrences of each symptom from the `Symptoms` column.\n3. Group the results by the symptom and count the occurrences.\n4. Order the results by the count in descending order to find the most common symptom.\n5. Limit the result to the top entry to get the most common sign.",
        "sql": "SELECT Symptoms, COUNT(*) as symptom_count\nFROM Examination\nWHERE Diagnosis = 'SLE'\nGROUP BY Symptoms\nORDER BY symptom_count DESC\nLIMIT 1;",
        "question": "What is the most common sign of patients with SLE disease?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1",
        "evidence": [
            "the most common sign refers to MAX(symptoms); 'SLE' refers to diagnosis",
            "The `Symptoms` column in the `Examination` table contains textual data, and the most common sign is determined by grouping and counting occurrences of each symptom. The `Diagnosis` column filters patients with SLE.",
            "The `Symptoms` column in the `Examination` table contains textual data, and the most common sign is determined by grouping and counting occurrences of each symptom. The `Diagnosis` column filters patients with SLE."
        ]
    },
    "792": {
        "reason": "To find Abomination's superpower, we need to follow these steps:\n1. Identify the superhero_id for Abomination from the `superhero` table.\n2. Use this superhero_id to find the corresponding power_id(s) in the `hero_power` table.\n3. Join the `hero_power` table with the `superpower` table to get the names of the superpowers associated with Abomination.\n\nThe query will involve joining the `superhero`, `hero_power`, and `superpower` tables to retrieve the required information.",
        "sql": "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Abomination';",
        "question": "What is Abomination's superpower?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Abomination'",
        "evidence": [
            "Abomination refers to superhero_name = 'Abomination'; superpower refers to power_name;"
        ]
    },
    "121": {
        "reason": "To solve the question, we need to list the account ID and account opening date for accounts from the district 'Prachatice'. Here's the step-by-step reasoning:\n\n1. Identify the district ID for 'Prachatice' from the `district` table, as the `account` table references the `district` table via `district_id`.\n2. Join the `account` table with the `district` table to filter accounts from 'Prachatice'.\n3. Select the `account_id` and `date` (account opening date) from the `account` table for the matching records.",
        "sql": "SELECT a.account_id, a.date\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE d.A2 = 'Prachatice';",
        "question": "List account ID and account opening date for accounts from 'Prachatice'.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T1.date FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Prachatice'",
        "evidence": [
            "A2 refers to the names of districts."
        ]
    },
    "189": {
        "reason": "To solve the question, we need to find the account numbers of female clients who are the oldest and have the lowest average salary. Here's the step-by-step reasoning:\n\n1. **Identify Female Clients**: Filter the `client` table for clients with gender 'F'.\n2. **Find Oldest Clients**: Among these female clients, find those with the earliest birth date (oldest).\n3. **Link to District for Salary**: Join the `client` table with the `district` table to access the average salary (A11).\n4. **Find Lowest Average Salary**: Among the oldest female clients, find those with the lowest average salary.\n5. **Link to Account**: Join the `client` table with the `disp` table to get the account_id, and then with the `account` table to get the account numbers.\n6. **Final Query**: Combine all these steps into a single query to retrieve the account numbers.",
        "sql": "WITH oldest_female_clients AS (\n    SELECT c.client_id, c.birth_date, d.A11 AS average_salary\n    FROM client c\n    JOIN district d ON c.district_id = d.district_id\n    WHERE c.gender = 'F'\n    ORDER BY c.birth_date ASC, d.A11 ASC\n    LIMIT 1\n)\nSELECT a.account_id\nFROM oldest_female_clients ofc\nJOIN disp dp ON ofc.client_id = dp.client_id\nJOIN account a ON dp.account_id = a.account_id;",
        "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
        "evidence": [
            "Female refers to 'F' in the gender; A11 contains information about average salary"
        ]
    },
    "194": {
        "reason": "To solve the question, we need to find clients who have a high-level credit card (card.type = 'gold') and are eligible for loans (disp.type = 'OWNER'). The steps are as follows:\n1. Join the `disp` table with the `card` table to link clients with their credit cards.\n2. Filter for high-level credit cards (card.type = 'gold').\n3. Join the `disp` table with the `client` table to get client details, including their birth date.\n4. Filter for clients who are eligible for loans (disp.type = 'OWNER').\n5. Calculate the client's age using their birth date and the current timestamp.\n6. Select the client's ID and calculated age.",
        "sql": "SELECT c.client_id, \n       (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', c.birth_date)) - \n       (STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', c.birth_date)) AS age\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card cd ON d.disp_id = cd.disp_id\nWHERE cd.type = 'gold' AND d.type = 'OWNER';",
        "question": "Provide the IDs and age of the client with high level credit card, which is eligible for loans.",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'",
        "evidence": [
            "the credit card is high-level refers to card.type = 'gold'; eligible for loans refers to disp.type = 'OWNER'",
            "The age calculation should directly use the client's birth date without additional adjustments for the current date. The join path should start from the disp table to ensure correct linkage between client, disp, and card.",
            "The age calculation should use STRFTIME with CURRENT_TIMESTAMP for accurate year extraction. The join path must correctly link disp, card, and client tables to ensure all conditions are met.",
            "The age calculation should use STRFTIME with CURRENT_TIMESTAMP for accurate year extraction. The join path must correctly link disp, card, and client tables to ensure all conditions are met."
        ]
    },
    "557": {
        "reason": "To solve the question, we need to determine the percentage of posts with a score greater than 5 that are owned by elder users (users with age > 65). The steps are as follows:\n1. Identify all posts with a score > 5.\n2. Among these posts, count how many are owned by users with age > 65.\n3. Calculate the total number of posts with a score > 5.\n4. Compute the percentage by dividing the count from step 2 by the count from step 3 and multiplying by 100.\n\nThe query will join the `posts` table with the `users` table to check the age of the post owners and filter accordingly.",
        "sql": "SELECT \n    (COUNT(CASE WHEN u.Age > 65 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nWHERE \n    p.Score > 5;",
        "question": "Among the posts with a score of over 5, what is the percentage of them being owned by an elder user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age > 65, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score > 5",
        "evidence": [
            "score of over 5 refers to Score > 5; elder user refers to Age > 65; percentage = Divide (Count(Id where Age>65), Count(Id)) * 100"
        ]
    },
    "28": {
        "reason": "To solve the question, we need to follow these steps:\n1. Calculate the average difference between K-12 enrollment and 15-17 enrollment for all schools that are locally funded. This difference is computed as `Enrollment (K-12)` - `Enrollment (Ages 5-17)`.\n2. Identify schools that are locally funded by checking the `FundingType` column in the `schools` table for the value 'Locally funded'.\n3. For each locally funded school, compute the difference between K-12 enrollment and 15-17 enrollment.\n4. Compare each school's difference to the average difference calculated in step 1.\n5. List the names and DOC type of schools where the difference is above the average difference.\n\nThe query will involve joining the `frpm` and `schools` tables to access both enrollment data and funding type information.",
        "sql": "WITH AvgDifference AS (\n    SELECT AVG(f.`Enrollment (K-12)` - f.`Enrollment (Ages 5-17)`) AS avg_diff\n    FROM frpm f\n    JOIN schools s ON f.CDSCode = s.CDSCode\n    WHERE s.FundingType = 'Locally funded'\n)\nSELECT s.School, s.DOC\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nCROSS JOIN AvgDifference\nWHERE s.FundingType = 'Locally funded'\nAND (f.`Enrollment (K-12)` - f.`Enrollment (Ages 5-17)`) > AvgDifference.avg_diff;",
        "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
        "evidence": [
            "Difference between K-12 enrollment and 15-17 enrollment can be computed by `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
            "The `FundingType` column in the `schools` table uses the value 'Locally funded' for locally funded schools, not 'Local'.\nThe `DOC` column in the `schools` table is used for the DOC type, not `DOCType`."
        ]
    },
    "1136": {
        "reason": "To solve the question, we need to find the number of players who had the highest potential score for crossing and preferred to use their left foot while attacking. Here's the step-by-step reasoning:\n\n1. **Identify the highest potential score for crossing**: We need to find the maximum value in the `crossing` column from the `Player_Attributes` table.\n2. **Filter players with the highest crossing potential**: Using the maximum value found, filter players who have this value in their `crossing` attribute.\n3. **Filter players who prefer left foot**: Among the filtered players, further filter those who have `preferred_foot` as 'left'.\n4. **Count the players**: Finally, count the number of players who meet both criteria.\n\nThe query will involve subqueries to first find the maximum crossing potential and then filter players based on that and their preferred foot.",
        "sql": "SELECT COUNT(*) AS number_of_players\nFROM Player_Attributes\nWHERE crossing = (SELECT MAX(crossing) FROM Player_Attributes)\nAND preferred_foot = 'left'\nAND attacking_work_rate IS NOT NULL;",
        "question": "How many players had the highest potential score for crossing that preferred to use their left foots while attacking?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t1.id) FROM Player_Attributes AS t1 WHERE t1.preferred_foot = 'left' AND t1.crossing = ( SELECT MAX(crossing) FROM Player_Attributes)",
        "evidence": [
            "highest potential score for crossing refers to MAX(crossing); preferred to use their left foots while attacking refers to preferred_foot = 'left'"
        ]
    },
    "994": {
        "reason": "To solve the question, we need to find the constructor that scored the most points from Monaco Grand Prix races between 1980 and 2010. Here's the step-by-step reasoning:\n\n1. **Identify Monaco Grand Prix Races**: Filter the `races` table for races named 'Monaco Grand Prix' and occurring between 1980 and 2010.\n2. **Join with Constructor Results**: Join the filtered races with the `constructorResults` table to get the points scored by constructors in these races.\n3. **Aggregate Points**: Sum the points for each constructor across all Monaco Grand Prix races in the specified period.\n4. **Join with Constructors**: Join the aggregated results with the `constructors` table to get the constructor's name and nationality.\n5. **Sort and Limit**: Sort the results by total points in descending order and limit to the top result to find the constructor with the most points.\n\nThe final query will join these tables, filter for the Monaco Grand Prix, aggregate the points, and return the top constructor with their score, name, and nationality.",
        "sql": "SELECT SUM(cr.points) AS total_points, c.name, c.nationality\nFROM constructorResults cr\nJOIN races r ON cr.raceId = r.raceId\nJOIN constructors c ON cr.constructorId = c.constructorId\nWHERE r.name = 'Monaco Grand Prix' AND r.year BETWEEN 1980 AND 2010\nGROUP BY c.constructorId, c.name, c.nationality\nORDER BY total_points DESC\nLIMIT 1;",
        "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
        "evidence": [
            "Monaco Grand Priz refers to the race; race in year between 1980 and 2010",
            "The `constructorResults` table stores points scored by constructors in races, requiring aggregation to sum points per constructor.\nJoining `constructorResults` with `constructors` and `races` is necessary to link points to constructor details and race conditions.\nGrouping by constructor name ensures unique aggregation per constructor, not just by ID."
        ]
    },
    "1165": {
        "reason": "To find the age gap between the youngest and oldest patient with a normal triglyceride (TG >= 200), we need to follow these steps:\n1. Identify patients with a normal triglyceride level (TG >= 200) from the Laboratory table.\n2. Retrieve the birth years of these patients from the Patient table.\n3. Calculate the difference between the maximum and minimum birth years to determine the age gap.\n4. Since the schema provides a tip that the age gap is calculated as the difference between the maximum and minimum birth years, we can directly use this approach.",
        "sql": "SELECT MAX(strftime('%Y', Birthday)) - MIN(strftime('%Y', Birthday)) AS age_gap\nFROM Patient\nWHERE ID IN (SELECT DISTINCT ID FROM Laboratory WHERE TG >= 200);",
        "question": "What is the age gap between the youngest and oldest patient with a normal triglyceride recorded?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', MAX(T1.Birthday)) - STRFTIME('%Y', MIN(T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200",
        "evidence": [
            "age gap refers to SUBTRACT(MAX(year(Birthday)) - MIN(year(Birthday))); normal triglyceride refers to tg > = 200"
        ]
    },
    "612": {
        "reason": "To find the name of the badge obtained by the user with the display name \"Pierre\", we need to follow these steps:\n1. First, identify the user's `Id` from the `users` table where the `DisplayName` is \"Pierre\".\n2. Then, use this `Id` to query the `badges` table to find the badge(s) associated with this user.\n3. Finally, retrieve the `Name` of the badge(s) from the `badges` table.",
        "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'Pierre';",
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "evidence": [
            ""
        ]
    },
    "782": {
        "reason": "To solve the question, we need to list the superhero names whose eye and hair colors are both black. The schema indicates that eye_colour_id and hair_colour_id in the superhero table reference the colour table. We need to join the superhero table with the colour table twice (once for eye color and once for hair color) to check if both colors are 'Black'. The steps are:\n1. Join the superhero table with the colour table for eye color (alias: eye_colour).\n2. Join the superhero table with the colour table again for hair color (alias: hair_colour).\n3. Filter records where both eye_colour.colour and hair_colour.colour are 'Black'.\n4. Select the superhero_name from the filtered records.",
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id\nWHERE eye_colour.colour = 'Black' AND hair_colour.colour = 'Black';",
        "question": "List the heroes' names whose eyes and hair colours are both black.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id WHERE T2.colour = 'Black'",
        "evidence": [
            "heroes' names refers to superhero_name; eyes and hair colours are both black refers to eye_colour_id AND hair_colour_id WHERE colour.colour = 'Black';"
        ]
    },
    "1492": {
        "reason": "To determine the percentage of KAM (Key Account Management) customers who pay in euros, we need to follow these steps:\n1. Identify all customers who are in the 'KAM' segment from the `customers` table.\n2. From these KAM customers, count how many have 'EUR' as their currency.\n3. Calculate the percentage of KAM customers who pay in euros by dividing the count from step 2 by the total count of KAM customers and multiplying by 100.\n4. The result will give us the desired percentage.",
        "sql": "SELECT \n    (COUNT(CASE WHEN c.Currency = 'EUR' THEN 1 END) * 100.0 / COUNT(*)) AS Percentage_KAM_EUR\nFROM \n    customers c\nWHERE \n    c.Segment = 'KAM';",
        "question": "What percentage of KAM customers pay in euros?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(Currency = 'EUR') AS FLOAT) * 100 / COUNT(CustomerID) FROM customers WHERE Segment = 'KAM'",
        "evidence": [
            "Percentage of KAM uses Euro = (Total of KAM uses Euro / Total of KAM) * 100%."
        ]
    },
    "1266": {
        "reason": "To find the youngest patient with an abnormal anti-ribonuclear protein (RNP) level, we need to follow these steps:\n1. Identify patients with abnormal RNP levels from the Laboratory table. Abnormal RNP levels are indicated by non-null or non-empty values in the RNP column.\n2. Join the Laboratory table with the Patient table to get the patient's date of birth (Birthday).\n3. Order the results by the patient's date of birth in descending order to find the youngest patient.\n4. Limit the result to the first record to get the youngest patient.\n5. Extract the date of birth from the result.",
        "sql": "SELECT p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.RNP IS NOT NULL AND l.RNP != ''\nORDER BY p.Birthday DESC\nLIMIT 1;",
        "question": "Which is the youngest patient with an abnormal anti-ribonuclear protein level? Please list his or her date of birth.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP != '-' OR '+-' ORDER BY T1.Birthday DESC LIMIT 1",
        "evidence": [
            "youngest patient refers to MAX(Birthday); abnormal anti-ribonuclear protein level refers to RNP NOT IN('-', '+-'); date of birth refers to Birthday;"
        ]
    },
    "1231": {
        "reason": "To solve the question, we need to find the number of male patients born between 1936 and 1956 who have creatinine phosphokinase (CPK) levels beyond the normal range (CPK >= 250). The steps are as follows:\n1. Filter patients from the `Patient` table who are male (SEX = 'M') and born between 1936 and 1956 (year(Birthday) BETWEEN '1936' AND '1956').\n2. Join these patients with the `Laboratory` table to check their CPK levels.\n3. Filter records where CPK >= 250.\n4. Count the distinct patient IDs to avoid duplicates in the result.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' \nAND strftime('%Y', P.Birthday) BETWEEN '1936' AND '1956'\nAND L.CPK >= 250;",
        "question": "For patient born between 1936-1956, how many male patients have creatinine phosphokinase beyond the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' AND T1.SEX = 'M' AND T2.CPK >= 250",
        "evidence": [
            "born between 1936-1956 refers to year(Birthday) BETWEEN '1936' AND '1956'; male patients refers to sex = 'M'; creatinine phosphokinase beyond the normal range refers to CPK > = 250; Should consider DISTINCT in the final result;"
        ]
    },
    "390": {
        "reason": "To solve the question, we need to retrieve the colors of cards with IDs between 1 and 20 from the `cards` table and the format of these cards from the `legalities` table. Since the question involves data from two tables, we will use an INNER JOIN to combine the relevant records. The steps are as follows:\n1. Select the `colors` column from the `cards` table for cards with IDs between 1 and 20.\n2. Join the `legalities` table to include the `format` column for these cards.\n3. Ensure the join is based on the `uuid` column, which is the common key between the two tables.\n4. Filter the results to only include cards with IDs between 1 and 20.",
        "sql": "SELECT c.colors, l.format\nFROM cards c\nINNER JOIN legalities l ON c.uuid = l.uuid\nWHERE c.id BETWEEN 1 AND 20;",
        "question": "What are the colors of cards from ID 1-20? What are the format of these cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.colors, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20",
        "evidence": [
            "ID 1-20 refers to id BETWEEN 1 and 20;",
            "The `colors` and `format` attributes are retrieved from the `cards` and `legalities` tables, respectively, requiring an INNER JOIN to ensure only matching records are included."
        ]
    },
    "428": {
        "reason": "To solve the question, we need to find the name of the set with `id = 5` in the `sets` table and then retrieve its translations from the `set_translations` table. The steps are as follows:\n1. Query the `sets` table to get the name of the set where `id = 5`.\n2. Use the `code` of the set obtained from the first query to filter the `set_translations` table and retrieve all translations for that set.\n3. Combine the results to display the set name and its translations.",
        "sql": "SELECT s.name AS set_name, st.language, st.translation\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.id = 5;",
        "question": "What is the name of set number 5 and its translation?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT T1.name, T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 5 GROUP BY T1.name, T2.translation",
        "evidence": [
            "set number 5 refers to id = 5",
            "The `id` in the `set_translations` table uniquely identifies each translation entry, not the set itself.\nTo retrieve translations for a specific set, filter by `setCode` in the `set_translations` table, not by its `id`.",
            "The `id` in the `set_translations` table uniquely identifies each translation entry, not the set itself.\nTo retrieve translations for a specific set, filter by `setCode` in the `set_translations` table, not by its `id`."
        ]
    },
    "87": {
        "reason": "To solve the question, we need to find the valid email addresses of administrators for schools meeting specific criteria:\n1. Located in San Bernardino County.\n2. City is San Bernardino City Unified.\n3. Opened between 1/1/2009 and 12/31/2010.\n4. School types are public Intermediate/Middle Schools (SOC = 62) and Unified Schools (DOC = 54).\n\nWe will use the `schools` table to filter by county, city, open date, and school type (DOC and SOC). We will then retrieve the administrator email addresses (AdmEmail1, AdmEmail2, AdmEmail3) from the same table. The query will involve filtering and joining as needed to ensure all conditions are met.",
        "sql": "SELECT AdmEmail1, AdmEmail2, AdmEmail3\nFROM schools\nWHERE County = 'San Bernardino'\n  AND City = 'San Bernardino City Unified'\n  AND strftime('%Y', OpenDate) BETWEEN '2009' AND '2010'\n  AND (DOC = 54 OR SOC = 62);",
        "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
        "evidence": [
            "Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; years between 2009 and 2010 can refer to 'between 1/1/2009 to 12/31/2010'",
            "The `frpm` table contains school details linked via `CDSCode` to the `schools` table, which holds administrator email addresses. Filtering by `OpenDate` requires using `strftime` for year extraction. Unified Schools are identified by `DOC = 54` and Intermediate/Middle Schools by `SOC = 62`.",
            "The `frpm` table links to `schools` via `CDSCode` and may contain additional filtering criteria. Use `strftime` for year extraction when filtering by `OpenDate` to ensure accurate date range comparisons.",
            "The `frpm` table provides additional filtering criteria for schools, such as `City`, which is not directly available in the `schools` table. Use `INNER JOIN` to link `frpm` and `schools` for comprehensive filtering.\nFiltering by `City` requires referencing the `City` column in the `schools` table, not the `District` column.\nThe `DOC` and `SOC` values should be compared as integers, not strings, to match the schema definition."
        ]
    },
    "710": {
        "reason": "To solve the question, we need to find out how many comments have a score of 0 in posts that have exactly 1 comment. Here's the step-by-step reasoning:\n\n1. **Identify posts with exactly 1 comment**: This can be done by filtering the `posts` table where `CommentCount = 1`.\n2. **Join the `comments` table**: We need to join the `comments` table with the filtered `posts` table to access the comments for these posts.\n3. **Filter comments with a score of 0**: From the joined data, we need to count the comments where `Score = 0`.\n4. **Count the results**: Finally, we count the number of such comments.\n\nThe query will involve joining the `posts` and `comments` tables, filtering for posts with exactly 1 comment, and then counting the comments with a score of 0 in those posts.",
        "sql": "SELECT COUNT(*) AS ZeroScoreCommentsCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.CommentCount = 1 AND c.Score = 0;",
        "question": "In posts with 1 comment, how many of the comments have 0 score?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
        "evidence": [
            "in posts with 1 comment refers to CommentCount = 1;",
            "The Score column in the posts table represents the post's score, not the comment's score. Comments' scores are stored in the comments table.",
            "The Score column in the comments table represents the comment's score, not the post's score. Posts' scores are stored in the posts table.\nTo count comments with specific conditions, the query should focus on the comments table and join with the posts table for filtering.\nThe CommentCount in the posts table indicates the number of comments, but the actual comments' data is stored in the comments table.",
            "The Score column in the posts table represents the post's score, not the comment's score. Comments' scores are stored in the comments table.\nTo count comments with specific conditions, the query should focus on the comments table and join with the posts table for filtering.\nThe CommentCount in the posts table indicates the number of comments, but the actual comments' data is stored in the comments table."
        ]
    },
    "1035": {
        "reason": "To solve the question, we need to find the `team_fifa_api_id` of teams whose `buildUpPlaySpeed` is greater than 50 but less than 60. This involves querying the `Team_Attributes` table where the `buildUpPlaySpeed` column meets the specified condition. The result should include the `team_fifa_api_id` of such teams.",
        "sql": "SELECT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60;",
        "question": "Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60",
        "evidence": [
            "teams with more than 50 but less than 60 build-up play speed refers to buildUpPlaySpeed >50 AND buildUpPlaySpeed <60; "
        ]
    },
    "1219": {
        "reason": "To solve the question, we need to find the average UA index for all patients with normal uric acid (UA) based on their latest laboratory examination result. The steps are as follows:\n1. Identify the latest laboratory examination date for each patient.\n2. Filter the laboratory results to include only those with the latest date for each patient.\n3. Apply the condition for normal UA (UA < 8.0 for males (SEX = 'M') or UA < 6.5 for females (SEX = 'F')).\n4. Calculate the average UA index for these filtered results.\n\nThe query will involve joining the `Patient` and `Laboratory` tables to access both the UA values and the patient's sex. We will use a subquery to find the latest date for each patient and then filter the results accordingly.",
        "sql": "SELECT AVG(l.UA) AS average_UA_index\nFROM Laboratory l\nJOIN Patient p ON l.ID = p.ID\nWHERE l.Date = (SELECT MAX(Date) FROM Laboratory WHERE ID = l.ID)\nAND ((p.SEX = 'M' AND l.UA < 8.0) OR (p.SEX = 'F' AND l.UA < 6.5));",
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "evidence": [
            "uric acid (UA) with normal range refers to UA < 8.0 and SEX = 'M' or UA < 6.5 and SEX = 'F'; average UA index refers to AVG(UA)",
            "The latest laboratory examination result for a patient is determined by the maximum date in the Laboratory table for that patient.\nTo calculate the average UA index, ensure the query filters for the latest date per patient before applying the UA condition.",
            "The latest laboratory examination result for all patients is determined by the maximum date in the Laboratory table, not per patient.\nTo filter for the latest result, use a subquery with MAX(Date) without grouping by ID.",
            "The latest laboratory examination result for all patients is determined by the maximum date in the Laboratory table, not per patient.\nTo filter for the latest result, use a subquery with MAX(Date) without grouping by ID."
        ]
    },
    "1286": {
        "reason": "To solve the question, we need to find the number of patients with an abnormal alkaline phosphatase level (ALP >= 300) who are also admitted to the hospital (Admission = '+'). The steps are as follows:\n1. Join the `Patient` and `Laboratory` tables on the `ID` field to link patient data with their lab results.\n2. Filter the results to include only patients with ALP >= 300 (abnormal level) and Admission = '+' (admitted to the hospital).\n3. Count the distinct patient IDs to avoid duplicates in the result.\n4. Since the join condition ensures unique patient IDs, COUNT(DISTINCT) is not necessary.",
        "sql": "SELECT COUNT(Patient.ID) \nFROM Patient \nINNER JOIN Laboratory ON Patient.ID = Laboratory.ID \nWHERE Laboratory.ALP >= 300 AND Patient.Admission = '+';",
        "question": "For the patient with an abnormal alkaliphophatase level, how many of them are admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP >= 300 AND T1.Admission = '+'",
        "evidence": [
            "abnormal alkaliphophatase level refers to ALP > = 300; admitted to the hospital refers to Admission = '+';",
            "The query should count distinct patient IDs to avoid duplicates in the result.\nThe join between Patient and Laboratory tables ensures patient data is linked to their lab results.\nFiltering for ALP >= 300 and Admission = '+' identifies the target patients.",
            "The query should use INNER JOIN to ensure only matching records from both tables are included.\nCOUNT(DISTINCT) is unnecessary when the join condition already ensures unique patient IDs."
        ]
    },
    "256": {
        "reason": "To calculate the total number of atoms consisting of the elements carbon ('c') and hydrogen ('h'), we need to query the `atom` table. The `element` column in this table stores the element type of each atom. We will count the number of rows where the `element` is either 'c' (carbon) or 'h' (hydrogen). Since the question specifies that filtering for these elements requires explicit conditions using '=' or 'OR' operators, we will use these operators in our query. The count will be based on the `atom_id` column, as it is the primary key and ensures accuracy.",
        "sql": "SELECT COUNT(atom_id) AS total_atoms FROM atom WHERE element = 'c' OR element = 'h';",
        "question": "Calculate the total atoms consisting of the element carbon and hydrogen.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.element = 'c' OR T.element = 'h'",
        "evidence": [
            "consisting of element carbon and hydrogen refers to element in('c', 'h')",
            "filtering for elements 'c' or 'h' requires explicit conditions using '=' or 'OR' operators, not 'IN'.\ncounting atoms involves referencing the primary key column 'atom_id' for accuracy."
        ]
    },
    "1349": {
        "reason": "To find the total number of the budget amount for the \"September Speaker\" event, we need to:\n1. Identify the event_id of the \"September Speaker\" event from the `event` table.\n2. Use this event_id to find the corresponding budget record in the `budget` table.\n3. Sum the `amount` field from the `budget` table for this event.",
        "sql": "SELECT SUM(amount) AS total_budget_amount\nFROM budget\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'September Speaker');",
        "question": "Provide the total number of the budget amount for \"September Speaker\" event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'September Speaker'",
        "evidence": [
            "'September Speaker' is an event name; total number of budget amount refers to SUM(amount)"
        ]
    },
    "38": {
        "reason": "To solve the question, we need to find the webpages of schools in Los Angeles County that have between 2,000 and 3,000 test takers. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `satscores` table contains information about test takers (`NumTstTakr`), and the `schools` table contains the county information (`County`) and the school's website (`Website`).\n\n2. **Filter by county**: We need to filter schools located in Los Angeles County. This can be done by checking the `County` field in the `schools` table.\n\n3. **Filter by test takers**: We need to filter schools where the number of test takers (`NumTstTakr`) is between 2,000 and 3,000. This is found in the `satscores` table.\n\n4. **Join the tables**: Since the required information is spread across two tables, we need to join the `schools` and `satscores` tables using the `CDSCode` (in `schools`) and `cds` (in `satscores`) fields.\n\n5. **Select the required fields**: Finally, we need to select the `Website` field from the `schools` table for the filtered schools.",
        "sql": "SELECT s.Website\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.County = 'Los Angeles'\nAND sc.NumTstTakr BETWEEN 2000 AND 3000;",
        "question": "What are the webpages for the Los Angeles County school that has between 2,000 and 3,000 test takers?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Website FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumTstTakr BETWEEN 2000 AND 3000 AND T2.County = 'Los Angeles'",
        "evidence": [
            ""
        ]
    },
    "512": {
        "reason": "To solve the question, we need to find the number of cards that meet the following conditions:\n1. The card's power is either NULL or equal to '*' (unknown power).\n2. The card cannot be found in foil (hasFoil = 0).\n3. The card is part of duel deck A (duelDeck = 'a').\n\nWe will query the `cards` table and apply these conditions using a WHERE clause. The COUNT function will be used to get the total number of such cards.",
        "sql": "SELECT COUNT(*) FROM cards WHERE (power IS NULL OR power = '*') AND hasFoil = 0 AND duelDeck = 'a';",
        "question": "How many cards with unknown power that can't be found in foil is in duel deck A?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE hasFoil = 0 AND duelDeck = 'a'",
        "evidence": [
            "unknown power refers to power IS NULL or power = '*'; can't be found in foil refers to hasFoil = 0; duel deck A refers to duelDeck = 'a'"
        ]
    },
    "541": {
        "reason": "To find the display name of the user who is the owner of the most valuable post, we need to determine what makes a post 'most valuable'. Typically, this could be based on the highest score, highest view count, or other metrics. For this query, we will assume the most valuable post is the one with the highest score. We will join the `posts` table with the `users` table to get the display name of the owner of the post with the highest score.",
        "sql": "SELECT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Score = (SELECT MAX(Score) FROM posts);",
        "question": "What is the display name of the user who is the owner of the most valuable post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.FavoriteCount DESC LIMIT 1",
        "evidence": [
            "most valuable post refers to Max(FavoriteCount)"
        ]
    },
    "34": {
        "reason": "To find the free rate for students aged 5-17 at the school run by Kacey Gibson, we need to follow these steps:\n1. Identify the school where Kacey Gibson is an administrator by querying the `schools` table using `AdmFName1` = 'Kacey' and `AdmLName1` = 'Gibson'.\n2. Join the `schools` table with the `frpm` table using the `CDSCode` to access the enrollment and meal count data for students aged 5-17.\n3. Calculate the free rate by dividing `Free Meal Count (Ages 5-17)` by `Enrollment (Ages 5-17)` from the `frpm` table.\n4. Ensure the division is performed as a numeric operation by casting the values to REAL type.\n5. Return the calculated free rate.",
        "sql": "SELECT (CAST(f.`Free Meal Count (Ages 5-17)` AS REAL) / CAST(f.`Enrollment (Ages 5-17)` AS REAL) AS free_rate\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.AdmFName1 = 'Kacey' AND s.AdmLName1 = 'Gibson';",
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "evidence": [
            "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
            "The `schools` table contains administrator details in columns like `AdmFName1` and `AdmLName1`, which can uniquely identify a school.\nThe `frpm` table stores enrollment and meal count data for students aged 5-17, which is used to calculate the free rate.",
            "The `CAST` function ensures numeric division by converting `Free Meal Count (Ages 5-17)` to REAL type.\nThe query retrieves only the calculated free rate without including the school name in the output.",
            "The `schools` table links to the `frpm` table via `CDSCode`, which is the primary key in both tables.\nThe `AdmFName1` and `AdmLName1` columns in the `schools` table uniquely identify administrators.\nThe free rate calculation requires joining these tables to access enrollment and meal count data."
        ]
    },
    "116": {
        "reason": "To solve the question, we need to follow these steps:\n1. Identify the client whose loan was approved first on 1993/7/5.\n2. Retrieve the account associated with this client.\n3. Find the account balance on 1993/3/22 (date B) and 1998/12/27 (date A).\n4. Calculate the increase rate using the formula: [(balance of date A - balance of date B) / balance of date B] * 100%.\n\nWe will join the `loan`, `account`, `disp`, and `client` tables to find the client and their account. Then, we will use the `trans` table to get the balances on the specified dates.",
        "sql": "WITH first_loan_client AS (\n    SELECT l.account_id, c.client_id\n    FROM loan l\n    JOIN account a ON l.account_id = a.account_id\n    JOIN disp d ON a.account_id = d.account_id\n    JOIN client c ON d.client_id = c.client_id\n    WHERE l.date = '1993-07-05'\n    ORDER BY l.loan_id\n    LIMIT 1\n),\nbalance_b AS (\n    SELECT t.account_id, t.balance\n    FROM trans t\n    JOIN first_loan_client flc ON t.account_id = flc.account_id\n    WHERE t.date = '1993-03-22'\n    ORDER BY t.trans_id DESC\n    LIMIT 1\n),\nbalance_a AS (\n    SELECT t.account_id, t.balance\n    FROM trans t\n    JOIN first_loan_client flc ON t.account_id = flc.account_id\n    WHERE t.date = '1998-12-27'\n    ORDER BY t.trans_id DESC\n    LIMIT 1\n)\nSELECT \n    ((ba.balance - bb.balance) * 100.0 / bb.balance) AS increase_rate\nFROM balance_a ba\nJOIN balance_b bb ON ba.account_id = bb.account_id;",
        "error": "something went wrong, tool did not call.",
        "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
        "evidence": [
            "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%"
        ]
    },
    "713": {
        "reason": "To find the up vote number of the user who commented \"R is also lazy evaluated.\", we need to follow these steps:\n1. Identify the comment with the text \"R is also lazy evaluated.\" in the `comments` table.\n2. Retrieve the `UserId` associated with that comment.\n3. Use the `UserId` to find the corresponding user in the `users` table.\n4. Extract the `UpVotes` value for that user.",
        "sql": "SELECT u.UpVotes\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text = 'R is also lazy evaluated.';",
        "question": "What is the up vote number of the user that commented \"R is also lazy evaluated.\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'R is also lazy evaluated.'",
        "evidence": [
            "commented \"R is also lazy evaluated.\" refers to Text of the comment;"
        ]
    },
    "716": {
        "reason": "To solve the question, we need to calculate the percentage of users with 0 up votes among the comments with scores between 5 and 10. Here's the step-by-step reasoning:\n\n1. **Filter Comments**: First, we need to filter comments where the score is between 5 and 10.\n2. **Join with Users**: Next, we join these comments with the users table to access the up votes attribute of the users who made these comments.\n3. **Count Total Users**: We count the total number of distinct users who made comments with scores between 5 and 10.\n4. **Count Users with 0 Up Votes**: We count the number of distinct users who made comments with scores between 5 and 10 and have 0 up votes.\n5. **Calculate Percentage**: Finally, we calculate the percentage by dividing the count of users with 0 up votes by the total count of users and multiplying by 100.\n\nThe SQL query will use conditional aggregation to achieve this.",
        "sql": "SELECT \n    (SUM(CASE WHEN u.UpVotes = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT c.UserId)) AS percentage\nFROM \n    comments c\nJOIN \n    users u ON c.UserId = u.Id\nWHERE \n    c.Score BETWEEN 5 AND 10;",
        "question": "Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10",
        "evidence": [
            "percentage = DIVIDE(COUNT(UserId where UpVotes = 0 and Score BETWEEN 5 and 10))*100, (COUNT(UserId where Score BETWEEN 5 and 10));",
            "To calculate percentages, ensure the numerator and denominator are derived from the same filtered dataset.\nUse SUM with conditional logic to count specific cases directly.\nJoin tables to access user attributes for filtering.",
            "To calculate percentages, ensure the numerator and denominator are derived from the same filtered dataset.\nUse SUM with conditional logic to count specific cases directly.\nJoin tables to access user attributes for filtering."
        ]
    },
    "862": {
        "reason": "To solve the question, we need to find out how many drivers did not finish the Bahrain Grand Prix in 2007. According to the schema and the tips provided, drivers who finished the race have a non-empty `time` field in the `results` table. Therefore, drivers who did not finish the race will have a `NULL` value in the `time` field. The steps to solve this are:\n1. Identify the `raceId` for the Bahrain Grand Prix in 2007 from the `races` table.\n2. Use this `raceId` to filter records in the `results` table where the `time` field is `NULL`.\n3. Count the number of such records to get the number of drivers who did not finish the race.",
        "sql": "SELECT COUNT(*) AS drivers_not_finished\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE name = 'Bahrain Grand Prix' AND year = 2007)\nAND time IS NULL;",
        "question": "For the Bahrain Grand Prix in 2007, how many drivers not finished the game?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2007 AND T1.name = 'Bahrain Grand Prix' AND T2.time IS NULL",
        "evidence": [
            "Bahrain Grand Prix refers to races.name = 'Bahrain Grand Prix'; drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL);"
        ]
    },
    "4": {
        "reason": "To solve the question, we need to find the phone numbers of directly funded charter schools that were opened after January 1, 2000. Here's the step-by-step reasoning:\n\n1. **Identify Directly Funded Charter Schools**: The `frpm` table contains the `Charter School (Y/N)` column (where 1 indicates a charter school) and the `Charter Funding Type` column (where 'Directly funded' indicates direct funding).\n\n2. **Filter Schools Opened After 2000/1/1**: The `schools` table contains the `OpenDate` column, which we can use to filter schools opened after January 1, 2000.\n\n3. **Link Tables**: The `frpm` and `schools` tables are linked via the `CDSCode` column.\n\n4. **Retrieve Phone Numbers**: The `schools` table also contains the `Phone` column, which we need to retrieve.\n\n5. **Combine Conditions**: We will join the `frpm` and `schools` tables, filter for charter schools (`Charter School (Y/N) = 1`), directly funded (`Charter Funding Type = 'Directly funded'`), and opened after 2000/1/1 (`OpenDate > '2000-01-01'`).\n\n6. **Select Phone Numbers**: Finally, we will select the `Phone` column from the `schools` table for the filtered schools.",
        "sql": "SELECT s.Phone\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.`Charter School (Y/N)` = 1\n  AND f.`Charter Funding Type` = 'Directly funded'\n  AND s.OpenDate > '2000-01-01';",
        "question": "Please list the phone numbers of the direct charter-funded schools that are opened after 2000/1/1.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`Charter School (Y/N)` = 1 AND T2.OpenDate > '2000-01-01'",
        "evidence": [
            "Charter schools refers to `Charter School (Y/N)` = 1 in the frpm",
            "Charter funding type is specified in the `frpm` table under `Charter Funding Type`, not in the `schools` table.\nThe `frpm` table links to `schools` via `CDSCode` for additional details like phone numbers.",
            "The `Charter Funding Type` in the `frpm` table uses 'Directly funded' as the value for directly funded charter schools, not 'Direct'."
        ]
    },
    "1061": {
        "reason": "To solve the question, we need to find the number of players whose first names are 'Adam' and whose weight is more than 170. The relevant table for this query is the `Player` table, which contains the `player_name` and `weight` columns. We will filter the `player_name` column to include only names that start with 'Adam' (to ensure the first name is Adam) and the `weight` column to include only values greater than 170. Finally, we will count the number of such players.",
        "sql": "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Adam%' AND weight > 170;",
        "question": "How many players whose first names are Adam and weigh more than 170?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE weight > 170 AND player_name LIKE 'Adam%'",
        "evidence": [
            "team names refers to team_long_name; speed class refers to buildUpPlaySpeedClass; buildUpPlaySpeedClass = 'Fast';"
        ]
    },
    "647": {
        "reason": "To solve the question, we need to find the badge names received in 2011 by users whose location is in the North Pole. The steps are as follows:\n1. Identify users whose location is 'North Pole' from the `users` table.\n2. Join the `users` table with the `badges` table to find badges associated with these users.\n3. Filter the badges to only include those received in the year 2011.\n4. Select the badge names from the filtered results.",
        "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.Location = 'North Pole' \nAND strftime('%Y', b.Date) = '2011';",
        "question": "Provide the badge names received in 2011 for the user whose location is in the North Pole.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE STRFTIME('%Y', T2.Date) = '2011' AND T1.Location = 'North Pole'",
        "evidence": [
            "received in 2011 refers to year(Date) = 2011;"
        ]
    },
    "1447": {
        "reason": "To solve the question, we need to find events that have underspent their budget. This involves comparing the `spent` and `amount` fields in the `budget` table. If the `spent` is less than the `amount`, the event has underspent its budget. We will join the `event` and `budget` tables to get the event name and location for such events.",
        "sql": "SELECT e.event_name, e.location FROM event e JOIN budget b ON e.event_id = b.link_to_event WHERE b.spent < b.amount;",
        "question": "List the name and location of events that underspend its budget.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.event_name, T1.location FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 0",
        "evidence": [
            "name of event refers to event_name; underspend its budget refers to remaining > 0"
        ]
    },
    "42": {
        "reason": "To solve the question, we need to find the school with the highest average math score from the `satscores` table and then determine the type of education offered (`EdOpsName`) for that school from the `schools` table. The steps are as follows:\n1. Identify the school with the highest average math score (`AvgScrMath`) in the `satscores` table.\n2. Use the `cds` (CDSCode) of that school to join with the `schools` table.\n3. Retrieve the `EdOpsName` from the `schools` table for the identified school.",
        "sql": "SELECT s.EdOpsName\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY sc.AvgScrMath DESC\nLIMIT 1;",
        "question": "What is the type of education offered in the school who scored the highest average in Math?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.EdOpsName FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 1",
        "evidence": [
            "",
            "To retrieve the highest value, use ORDER BY with DESC and LIMIT 1 instead of a subquery with MAX.\nThe `EdOpsName` column in the `schools` table indicates the type of education offered."
        ]
    },
    "883": {
        "reason": "To solve the question, we need to perform two tasks:\n1. Count the number of races in the year 2005.\n2. List all the races in 2005 in descending order by their names.\n\nFor the first task, we will query the `races` table, filter for the year 2005 using the `year` column, and count the results.\nFor the second task, we will again query the `races` table, filter for the year 2005, and order the results by the `name` column in descending order.",
        "sql": "-- Count the number of races in 2005\nSELECT COUNT(*) AS race_count FROM races WHERE year = 2005;\n\n-- List all races in 2005 in descending order by name\nSELECT name FROM races WHERE year = 2005 ORDER BY name DESC;",
        "question": "How many races were there in 2005? Name all the races in descending order.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC",
        "evidence": [
            "",
            "The `races` table includes a `year` column to filter races by specific years and a `name` column to retrieve race names. Ordering by `name` in descending order requires using the `ORDER BY` clause with `DESC`.",
            "The `races` table can be queried directly for race names without needing a separate count query when the goal is to list all races for a specific year.",
            "The `races` table contains all necessary columns (`year` and `name`) to filter and order races without requiring a separate count query."
        ]
    },
    "399": {
        "reason": "To list all types of cards available in Arena, we need to query the `cards` table where the `availability` column is 'arena'. The `types` column in the `cards` table contains the distinct types of cards. We will select the `types` column and ensure we only include distinct values to avoid duplicates. Additionally, we will filter for non-null values in the `types` column to ensure valid entries are included.",
        "sql": "SELECT DISTINCT types FROM cards WHERE availability = 'arena' AND types IS NOT NULL;",
        "question": "Lists all types of cards available in arena.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL",
        "evidence": [
            "all types refer to subtypes and supertypes\n\navailble in arena refers to availability = 'arena'",
            "The `types` column in the `cards` table is distinct from `subtypes` and `supertypes`, which are separate columns.\nFiltering for non-null values in `subtypes` and `supertypes` ensures only valid entries are included.",
            "The `availability` column in the `cards` table indicates where a card is available, such as 'arena'.\nThe `subtypes` and `supertypes` columns in the `cards` table store distinct classifications of card types.\nFiltering for non-null values in both `subtypes` and `supertypes` ensures only valid entries are included.",
            "The `subtypes` and `supertypes` columns in the `cards` table store distinct classifications of card types, which are separate from the `types` column.\nFiltering for non-null values in both `subtypes` and `supertypes` ensures only valid entries are included.\nThe `availability` column in the `cards` table indicates where a card is available, such as 'arena'."
        ]
    },
    "675": {
        "reason": "To solve the question, we need to count the number of users who meet two conditions: their reputation is higher than 2000, and their number of views is higher than 1000. The relevant table for this query is the `users` table, which contains the columns `Reputation` and `Views`. We will use a `COUNT` function to count the number of users who satisfy both conditions, and a `WHERE` clause to filter the users based on the given criteria.",
        "sql": "SELECT COUNT(*) FROM users WHERE Reputation > 2000 AND Views > 1000;",
        "question": "How many users whose reputations are higher than 2000 and the number of views is higher than 1000?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Reputation > 2000 AND Views > 1000",
        "evidence": [
            "reputations are higher than 2000 refer to Reputation > 2000; number of views is higher than 1000 refers to Views > 1000;"
        ]
    },
    "1282": {
        "reason": "To solve the question, we need to find the top three patients' birthdays with the highest glutamic pyruvic transaminase (GPT) values in the normal range (GPT < 60). The steps are as follows:\n1. Join the `Patient` and `Laboratory` tables on the `ID` field to link patient information with their laboratory results.\n2. Filter the laboratory results to include only those where GPT is below 60 (normal range).\n3. Sort the results by GPT in descending order to get the highest values first.\n4. Limit the results to the top three entries.\n5. Select the `Birthday` field from the `Patient` table for these top three entries.",
        "sql": "SELECT p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT < 60\nORDER BY l.GPT DESC\nLIMIT 3;",
        "question": "Please list the top three patients' birthdays with the highest glutamic pylvic transaminase in the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT < 60 ORDER BY T2.GPT DESC LIMIT 3",
        "evidence": [
            "highest glutamic pylvic transaminase in the normal range refers to MAX(GPT < 60);",
            "highest glutamic pyruvic transaminase in the normal range refers to individual GPT values below 60, not aggregated maximums.\njoin between patient and laboratory tables should directly filter and sort by GPT values, not group by patient."
        ]
    },
    "1103": {
        "reason": "To find the overall rating for Aaron Mooy on 2016/2/4, we need to follow these steps:\n1. Identify the player_api_id for Aaron Mooy from the Player table.\n2. Use this player_api_id to query the Player_Attributes table for the overall_rating on the specified date (2016-02-04).\n3. The date in the Player_Attributes table should match or be close to the specified date, so we use a LIKE condition to match the date format.\n4. Combine these steps into a single query to retrieve the desired information.",
        "sql": "SELECT pa.overall_rating \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Aaron Mooy' \nAND pa.date LIKE '2016-02-04%';",
        "question": "What was the overall rating for Aaron Mooy on 2016/2/4?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-02-04' AND t1.player_name = 'Aaron Mooy'",
        "evidence": [
            "Aaron Mooy refers to player_name = 'Aaron Mooy'; on 2016/2/4 refers to date LIKE '2016-02-04%';"
        ]
    },
    "1337": {
        "reason": "To find the total budgeted amount for all categories in the \"October Speaker\" event, we need to:\n1. Identify the event_id of the \"October Speaker\" event from the `event` table.\n2. Use this event_id to filter the `budget` table for all budget entries linked to this event.\n3. Sum the `amount` column in the `budget` table for these entries to get the total budgeted amount.",
        "sql": "SELECT SUM(amount) AS total_budgeted_amount\nFROM budget\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'October Speaker');",
        "question": "What is the total budgeted amount for all category in \"October Speaker\" event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.amount) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'October Speaker'",
        "evidence": [
            "total budgeted amount refers to SUM(amount) where event_name = 'October Speaker'"
        ]
    },
    "182": {
        "reason": "To solve the question, we need to identify male customers born between 1974 and 1976 who have made a payment on their home (indicated by `k_symbol = 'SIPO'`) exceeding $4000. The steps are as follows:\n1. Start with the `trans` table to filter transactions where `k_symbol = 'SIPO'` and `amount > 4000`.\n2. Join the `trans` table with the `account` table to link transactions to accounts.\n3. Join the `account` table with the `disp` table to link accounts to clients.\n4. Join the `disp` table with the `client` table to filter clients by gender (`gender = 'M'`) and birth year (between 1974 and 1976).\n5. Count the distinct `account_id` values to ensure each qualifying account is counted once.",
        "sql": "SELECT COUNT(DISTINCT t.account_id) \nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE c.gender = 'M' \nAND strftime('%Y', c.birth_date) BETWEEN '1974' AND '1976'\nAND t.k_symbol = 'SIPO'\nAND t.amount > 4000;",
        "question": "How many male customers who were born between 1974 and 1976 have made a payment on their home in excess of $4000?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T2.account_id = T4.account_id INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976' AND T3.gender = 'M' AND T1.amount > 4000 AND T1.k_symbol = 'SIPO'",
        "evidence": [
            "Man and male refers to gender = 'M'; 'SIPO' stands for household payment",
            "The `trans` table contains payment details, including `amount` and `k_symbol`, which are used to filter transactions.\nThe `client` table links to `account` via the `disp` table, requiring a multi-step join path.\nThe `birth_date` in the `client` table is filtered by year to identify specific age groups.",
            "The `trans` table is the primary source for payment details, requiring it to be the starting point for filtering transactions.\nThe join path should begin with `trans` and link to `account`, then `disp`, and finally `client` to ensure all conditions are met.\nCounting distinct `account_id` in `trans` ensures each qualifying account is counted once, regardless of the number of transactions.",
            "The `trans` table must be joined with `account`, `disp`, and `client` to link transactions to clients and filter by gender and birth year.\nThe `k_symbol` in `trans` identifies household payments, and `amount` filters transactions exceeding a threshold.\nCounting distinct `account_id` ensures each qualifying account is counted once, regardless of transaction count."
        ]
    },
    "188": {
        "reason": "To solve the question, we need to follow these steps:\n1. Identify accounts with loans that have a duration (validity) of more than 24 months.\n2. From these accounts, filter those that were opened before 1997.\n3. Among these filtered accounts, find the ones with the lowest approved loan amount.\n4. List out these accounts.\n\nWe will use the `loan` table to find loans with a duration > 24 months and the `account` table to check the opening date before 1997. We will join these tables to get the required information and then order the results by the loan amount to find the lowest ones.",
        "sql": "SELECT a.account_id, a.date AS account_opening_date, l.amount AS loan_amount, l.duration\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.duration > 24\nAND STRFTIME('%Y', a.date) < '1997'\nORDER BY l.amount ASC\nLIMIT 1;",
        "question": "Among the accounts who have loan validity more than 24 months, list out the accounts that have the lowest approved amount and have account opening date before 1997.",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.duration > 24 AND STRFTIME('%Y', T2.date) < '1997' ORDER BY T1.amount ASC LIMIT 1",
        "evidence": [
            "",
            "To filter accounts by year, use STRFTIME to extract the year from the date column.\nFor finding the lowest value, use ORDER BY with LIMIT instead of a subquery with MIN.",
            "To filter accounts by year, use STRFTIME to extract the year from the date column.\nFor finding the lowest value, use ORDER BY with LIMIT instead of a subquery with MIN."
        ]
    },
    "1350": {
        "reason": "To find the status of the event that bought \"Post Cards, Posters\" on 2019/8/20, we need to follow these steps:\n1. Identify the expense record in the `expense` table where the `expense_description` is \"Post Cards, Posters\" and the `expense_date` is \"2019-8-20\".\n2. From this expense record, get the `link_to_budget` to find the associated budget in the `budget` table.\n3. From the budget record, retrieve the `link_to_event` to find the event in the `event` table.\n4. However, the question specifies that the event status is stored in the `budget` table as `event_status`, so we can directly get the status from the budget record without joining with the `event` table.\n\nThe query will join the `expense` and `budget` tables to get the `event_status` for the specified expense.",
        "sql": "SELECT b.event_status\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nWHERE e.expense_description = 'Post Cards, Posters' AND e.expense_date = '2019-8-20';",
        "question": "What is the status of the event which bought \"Post Cards, Posters\" on 2019/8/20?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'",
        "evidence": [
            "'Post Cards, Posters' is an expense description; on 2019/8/20 refers to expense_date = '2019-8-20'; status of event refers to event_status",
            "The event status is stored in the budget table as event_status, not in the event table as status.",
            "The event_status is directly available in the budget table, eliminating the need to join with the event table.",
            "The expense_date format in the expense table should match the query date format for accurate filtering."
        ]
    },
    "584": {
        "reason": "To solve the question, we need to retrieve all comments left by users who edited a specific post titled 'Why square the difference instead of taking the absolute value in standard deviation?'. The steps are as follows:\n1. Identify the post with the given title in the `posts` table to get its `Id`.\n2. Use this `Id` to find all entries in the `postHistory` table where `PostId` matches the post's `Id`.\n3. Extract the `Comment` field from these entries to get the comments left by users during edits.\n\nThe query will join the `posts` and `postHistory` tables to achieve this.",
        "sql": "SELECT ph.Comment\nFROM postHistory ph\nJOIN posts p ON ph.PostId = p.Id\nWHERE p.Title = 'Why square the difference instead of taking the absolute value in standard deviation?' AND ph.Comment IS NOT NULL;",
        "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "evidence": [
            "\"Why square the difference instead of taking the absolute value in standard deviation?\" is the Title of post;",
            "The `postHistory` table contains a `Comment` field that directly stores comments made during post edits.\nTo retrieve comments from users who edited a post, the `postHistory` table should be queried for its `Comment` field linked to the post.\nThe `comments` table is not required for this task as the relevant comments are stored in `postHistory`."
        ]
    },
    "1046": {
        "reason": "To find the freedom of movement in the first two-thirds of the pitch for the ADO Den Haag team, we need to look at the `buildUpPlayPositioningClass` attribute in the `Team_Attributes` table. The `Team_Attributes` table is linked to the `Team` table via `team_api_id` or `team_fifa_api_id`. We first need to identify the `team_api_id` or `team_fifa_api_id` for ADO Den Haag from the `Team` table, then join it with the `Team_Attributes` table to retrieve the relevant attribute.",
        "sql": "SELECT ta.buildUpPlayPositioningClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'ADO Den Haag';",
        "question": "What is the ADO Den Haag team freedom of movement in the 1st two thirds of the pitch?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPositioningClass FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_fifa_api_id = t2.team_fifa_api_id WHERE t1.team_long_name = 'ADO Den Haag'",
        "evidence": [
            "ADO Den Haag refers to team_long_name = 'ADO Den Haag'; freedom of movement in the 1st two thirds of the pitch refers to buildUpPlayPositioningClass;"
        ]
    },
    "668": {
        "reason": "To find the display name of the user who acquired the highest amount of badges, we need to:\n1. Count the number of badges each user has by grouping the `badges` table by `UserId`.\n2. Join the result with the `users` table to get the `DisplayName` of the user.\n3. Order the results by the count of badges in descending order to find the user with the highest count.\n4. Limit the result to 1 to get only the top user.",
        "sql": "SELECT u.DisplayName\nFROM users u\nJOIN (\n    SELECT UserId, COUNT(*) AS badge_count\n    FROM badges\n    GROUP BY UserId\n) b ON u.Id = b.UserId\nORDER BY b.badge_count DESC\nLIMIT 1;",
        "question": "What is the display name of the user who acquired the highest amount of badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T1.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
        "evidence": [
            "highest amount of badges refers to MAX(COUNT(Name));"
        ]
    },
    "956": {
        "reason": "To solve the question, we need to find drivers born after 1975 who have been ranked 2 in any race. The steps are as follows:\n1. Identify drivers born after 1975 by checking their date of birth (dob) using `STRFTIME('%Y', dob) > '1975'`.\n2. Join the `drivers` table with the `results` table to get the ranking information.\n3. Filter the results where the `rank` column in the `results` table is 2.\n4. Select the `forename` and `surname` of these drivers.",
        "sql": "SELECT d.forename, d.surname\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE STRFTIME('%Y', d.dob) > '1975' AND r.rank = 2;",
        "question": "Which drivers born after 1975 have been ranked 2? Please give their forenames and surnames.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.forename, T2.surname FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) > '1975' AND T1.rank = 2",
        "evidence": [
            "born after 1975 refers to year(dob) >1975;",
            "The `rank` column in the `results` table indicates the driver's ranking, not `positionOrder`.\nTo filter drivers by birth year, use `STRFTIME('%Y', dob)` for accurate year extraction."
        ]
    },
    "1359": {
        "reason": "To solve the question, we need to compare the budget amounts for the 'Advertisement' category between two specific events: 'Yearly Kickoff' and 'October Meeting'. The steps are as follows:\n1. Join the `budget` table with the `event` table to access the event names.\n2. Filter the `budget` table for entries where the category is 'Advertisement'.\n3. Further filter for the two specific events: 'Yearly Kickoff' and 'October Meeting'.\n4. Calculate the sum of the `amount` for each of these events.\n5. Compare the sums to determine how many times the 'Yearly Kickoff' budget was more than the 'October Meeting' budget.\n\nSince the question asks for the number of times the 'Yearly Kickoff' budget was more than the 'October Meeting' budget, we need to count the occurrences where this condition is true. However, the question seems to imply a ratio comparison rather than counting occurrences, so we will calculate the ratio of the sums instead.",
        "sql": "SELECT \n    (SELECT SUM(b.amount) FROM budget b JOIN event e ON b.link_to_event = e.event_id WHERE b.category = 'Advertisement' AND e.event_name = 'Yearly Kickoff') AS yearly_kickoff_sum,\n    (SELECT SUM(b.amount) FROM budget b JOIN event e ON b.link_to_event = e.event_id WHERE b.category = 'Advertisement' AND e.event_name = 'October Meeting') AS october_meeting_sum,\n    CASE \n        WHEN (SELECT SUM(b.amount) FROM budget b JOIN event e ON b.link_to_event = e.event_id WHERE b.category = 'Advertisement' AND e.event_name = 'Yearly Kickoff') > \n             (SELECT SUM(b.amount) FROM budget b JOIN event e ON b.link_to_event = e.event_id WHERE b.category = 'Advertisement' AND e.event_name = 'October Meeting') \n        THEN 1 \n        ELSE 0 \n    END AS is_yearly_kickoff_more;",
        "question": "How many times was the budget in Advertisement for \"Yearly Kickoff\" meeting more than \"October Meeting\"?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting'",
        "evidence": [
            "budget in Advertisement refer to category = 'Advertisement' in the budget table; DIVIDE(SUM(amount when event_name = 'Yearly Kickoff'), SUM(amount when event_name = 'October Meeting'))",
            "The comparison involves calculating a ratio of budget amounts for two specific events, not counting occurrences. The budget table links to the event table via link_to_event, requiring a join to access event details.",
            "The comparison involves calculating a ratio of budget amounts for two specific events, not counting occurrences. The budget table links to the event table via link_to_event, requiring a join to access event details."
        ]
    },
    "902": {
        "reason": "To solve the question, we need to find the race where Alex Yoong was in a track position less than 20. The steps are as follows:\n1. Identify Alex Yoong's driver ID from the `drivers` table using his forename and surname.\n2. Join the `driverStandings` table with the `races` table to get the race details where his position was less than 20.\n3. Filter the results to include only Alex Yoong's records and positions less than 20.\n4. Retrieve the race name and other relevant details.",
        "sql": "SELECT r.name AS race_name, r.date, r.year, r.round\nFROM races r\nJOIN driverStandings ds ON r.raceId = ds.raceId\nJOIN drivers d ON ds.driverId = d.driverId\nWHERE d.forename = 'Alex' AND d.surname = 'Yoong' AND ds.position < 20;",
        "question": "Which race was Alex Yoong in when he was in track number less than 20?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
        "evidence": [
            "Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;track number less than 10 refers to position < 20",
            "The `driverStandings` table tracks driver positions in races, while the `results` table records race outcomes. For position-related queries, `driverStandings` is more appropriate than `results`.",
            "The `driverStandings` table records driver positions during races, while the `results` table captures final race outcomes. For queries involving race positions, `driverStandings` is the appropriate table.",
            "The `driverStandings` table records driver positions during races, while the `results` table captures final race outcomes. For queries involving race positions, `driverStandings` is the appropriate table.\nThe `position` column in `driverStandings` reflects the driver's standing during the race, which is relevant for tracking positions less than a certain value.\nJoining `drivers`, `driverStandings`, and `races` tables ensures the query retrieves the correct race details for the specified driver and position condition."
        ]
    },
    "1008": {
        "reason": "To solve the question, we need to find the lap during which Lewis Hamilton took a pit stop during the 2011 Australian Grand Prix. Here's the step-by-step reasoning:\n\n1. **Identify Lewis Hamilton's driverId**: We need to find the driverId for Lewis Hamilton from the `drivers` table.\n2. **Identify the raceId for the 2011 Australian Grand Prix**: We need to find the raceId for the race named 'Australian Grand Prix' in the year 2011 from the `races` table.\n3. **Query pit stops for Lewis Hamilton in the identified race**: Using the driverId and raceId, we can query the `pitStops` table to find the lap(s) during which Lewis Hamilton took a pit stop.\n\nThe final SQL query will join these steps to retrieve the required information.",
        "sql": "SELECT p.lap\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nJOIN races r ON p.raceId = r.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND r.year = 2011 AND r.name = 'Australian Grand Prix';",
        "question": "During which lap did Lewis Hamilton take a pit stop during the 2011 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.lap FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' AND T3.year = 2011 AND T3.name = 'Australian Grand Prix'",
        "evidence": [
            ""
        ]
    },
    "249": {
        "reason": "To find the elements of the atoms connected by the bond with the ID `TR144_8_19`, we need to follow these steps:\n1. Identify the `atom_id` and `atom_id2` in the `connected` table where the `bond_id` is `TR144_8_19`.\n2. Retrieve the `element` of these atoms from the `atom` table using the `atom_id` and `atom_id2` values obtained in the first step.\n3. Since the question specifies that only one atom's element is needed, we can focus on either `atom_id` or `atom_id2`.",
        "sql": "SELECT a.element FROM connected c JOIN atom a ON c.atom_id = a.atom_id WHERE c.bond_id = 'TR144_8_19' UNION SELECT a.element FROM connected c JOIN atom a ON c.atom_id2 = a.atom_id WHERE c.bond_id = 'TR144_8_19';",
        "question": "What are the elements of the atoms of TR144_8_19?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'",
        "evidence": [
            "TR144_8_19 is the bond id; ",
            "The `connected` table links atoms via bonds, but only one atom's element is needed for the query.\nThe `bond_id` in the `connected` table directly references the bond, not the molecule."
        ]
    },
    "1369": {
        "reason": "To find the event with the highest budget amount, I need to follow these steps:\n1. Identify the `budget` table, which contains the `amount` column representing the budget amount for each event.\n2. Use the `MAX(amount)` function to find the highest budget amount.\n3. Join the `budget` table with the `event` table using the `link_to_event` foreign key to get the event name associated with the highest budget.\n4. The query will select the `event_name` from the `event` table where the `amount` in the `budget` table matches the maximum amount found.",
        "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.amount = (SELECT MAX(amount) FROM budget);",
        "question": "Which event has the highest budget amount?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id ORDER BY T1.amount DESC LIMIT 1",
        "evidence": [
            "event refers to event_name; highest budget amount refers to MAX(amount)"
        ]
    },
    "929": {
        "reason": "To list the Formula 1 races that Lewis Hamilton participated in, we need to follow these steps:\n1. Identify Lewis Hamilton's `driverId` from the `drivers` table using his name (forename and surname).\n2. Join the `results` table with the `races` table using the `raceId` to get the details of the races.\n3. Filter the results to only include races where Lewis Hamilton's `driverId` appears in the `results` table.\n4. Select the relevant race details (e.g., race name, year, round, etc.) from the `races` table.\n\nThe `circuits` table is not needed for this query as we are only interested in the races Lewis Hamilton participated in, not the circuit details.",
        "sql": "SELECT r.name AS race_name, r.year, r.round, r.date\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nORDER BY r.year, r.round;",
        "question": "Please list the Formula_1 races that Lewis Hamilton participated.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "evidence": [
            "",
            "The `results` table links drivers to races via `driverId` and `raceId`, allowing retrieval of race details for a specific driver.\nTo filter races by a driver, join `results` with `races` and `drivers`, then apply the driver's name condition.\nThe `circuits` table is unnecessary for listing races a driver participated in.",
            "The `results` table connects drivers to races via `driverId` and `raceId`, enabling retrieval of race details for a specific driver.\nTo filter races by a driver, join `results` with `races` and `drivers`, then apply the driver's name condition.\nThe `circuits` table is unnecessary for listing races a driver participated in.",
            "The `results` table links drivers to races via `driverId` and `raceId`, enabling retrieval of race details for a specific driver.\nTo filter races by a driver, join `results` with `races` and `drivers`, then apply the driver's name condition.\nThe `circuits` table is unnecessary for listing races a driver participated in."
        ]
    },
    "1500": {
        "reason": "To solve the question, we need to find the product descriptions of products consumed in September 2013. The steps are as follows:\n1. Identify the transactions that occurred in September 2013. The `yearmonth` table contains the `Date` column, where the first 4 characters represent the year and the 5th and 6th characters represent the month. For September 2013, the date format is '201309'.\n2. Join the `yearmonth` table with the `transactions_1k` table using the `CustomerID` and `Date` to filter transactions for September 2013.\n3. Join the resulting data with the `products` table to get the product descriptions.\n4. Select the distinct product descriptions to avoid duplicates.",
        "sql": "SELECT DISTINCT p.Description\nFROM products p\nJOIN transactions_1k t ON p.ProductID = t.ProductID\nJOIN yearmonth ym ON t.CustomerID = ym.CustomerID AND ym.Date = '201309';",
        "question": "Please list the product description of the products consumed in September, 2013.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "evidence": [
            "September 2013 refers to 201309; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
        ]
    },
    "75": {
        "reason": "To solve the question, we need to find the educational level name (EILName) for schools that have 'Breakfast Provision 2' in their NSLP Provision Status and are located in county code '37'. The steps are as follows:\n1. Join the `frpm` table with the `schools` table on the `CDSCode` to access the educational level name and school name.\n2. Filter the `frpm` table for records where `NSLP Provision Status` is 'Breakfast Provision 2' and `County Code` is '37'.\n3. Select the `EILName` (educational level name) and the `School` (school name) from the `schools` table for the matching records.",
        "sql": "SELECT s.EILName, s.School\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.`NSLP Provision Status` = 'Breakfast Provision 2' AND f.`County Code` = '37';",
        "question": "What is the educational level name for the schools with Breakfast Provision 2 in county code 37? Indicate the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.EILName, T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2' AND T1.`County Code` = 37",
        "evidence": [
            "",
            "The `NSLP Provision Status` column in the `frpm` table contains values like 'Breakfast Provision 2', not just numeric codes.\nThe `EILName` column in the `schools` table holds the educational level name, not the `Educational Option Type` in `frpm`.\nJoining `frpm` with `schools` on `CDSCode` is necessary to access the educational level name and school name.",
            "The `County Code` in the `frpm` table is stored as an INTEGER, not as a TEXT, so filtering should use numeric comparison.\nThe `School` column in the `schools` table corresponds to the school name, not the `School Name` column in the `frpm` table.",
            "The `County Code` column in the `frpm` table is stored as TEXT, not INTEGER, so filtering should use string comparison.\nThe `School` column in the `schools` table is the correct source for school names, not the `School Name` column in `frpm`."
        ]
    },
    "991": {
        "reason": "To solve the question, we need to retrieve the full name (forename and surname) and date of birth (dob) of Austrian drivers born between 1981 and 1991. The steps are as follows:\n1. Identify the relevant table: `drivers` contains the required fields (forename, surname, dob, nationality).\n2. Filter drivers by nationality: `nationality = 'Austrian'`.\n3. Filter drivers by birth year: Use `STRFTIME('%Y', dob)` to extract the year from the date of birth and check if it falls between 1981 and 1991.\n4. Combine the forename and surname to form the full name in the output.\n5. Ensure the query is valid SQLite syntax.",
        "sql": "SELECT forename || ' ' || surname AS full_name, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991';",
        "question": "What is the full name and date of birth of Austrian drivers born between 1981 and 1991?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'",
        "evidence": [
            "Full name refers to forname, surname; Date of birth refers to dob; year(dob) BETWEEN '1981' AND '1991'; Austrian is a nationality",
            "Full name can be represented as separate forename and surname fields; date filtering requires STRFTIME for year extraction.",
            "Full name can be represented as separate forename and surname fields without concatenation; date filtering requires STRFTIME for year extraction.",
            "Full name can be represented as separate forename and surname fields without concatenation; date filtering requires STRFTIME for year extraction."
        ]
    },
    "441": {
        "reason": "To find the set code of the set with a release date of 07/13/2007, I need to query the 'sets' table. The 'sets' table contains the 'code' column, which represents the set code, and the 'releaseDate' column, which stores the release date of each set. I will filter the records in the 'sets' table where the 'releaseDate' matches '2007-07-13' (formatted as YYYY-MM-DD) and retrieve the 'code' column for the matching set.",
        "sql": "SELECT code FROM sets WHERE releaseDate = '2007-07-13';",
        "question": "State the set code of the set with release date of 07/13/2007?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'",
        "evidence": [
            "",
            "The 'set_translations' table links to the 'sets' table via the 'setCode' column, which corresponds to the 'code' column in 'sets'.\nTo retrieve set codes with translations, a join between 'sets' and 'set_translations' is required.",
            "The 'sets' table contains the 'releaseDate' column, which can be used to filter sets by their release date.\nThe 'set_translations' table provides additional set codes linked to the 'sets' table via the 'setCode' column matching the 'code' column in 'sets'.\nTo retrieve set codes with translations, a join between 'sets' and 'set_translations' is necessary.",
            "The 'sets' table contains the 'releaseDate' column for filtering sets by their release date.\nThe 'set_translations' table provides additional set codes linked to the 'sets' table via the 'setCode' column matching the 'code' column in 'sets'.\nTo retrieve set codes with translations, a join between 'sets' and 'set_translations' is necessary."
        ]
    },
    "1333": {
        "reason": "To find the city and state where the President of the Student_Club grew up, we need to follow these steps:\n1. Identify the member who holds the position of \"President\" in the `member` table.\n2. Retrieve the `zip` code of this member.\n3. Use the `zip` code to look up the corresponding `city` and `state` in the `zip_code` table.\n4. Join the `member` table with the `zip_code` table to get the required information.",
        "sql": "SELECT z.city, z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.position = 'President';",
        "question": "What city and state did the President of the Student_Club grow up?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.city, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.position = 'President'",
        "evidence": [
            "'President' is a position of Student Club;"
        ]
    },
    "214": {
        "reason": "To solve the question, we need to find the type of label that is not associated with molecules containing atoms of the element 'tin'. Here's the step-by-step reasoning:\n\n1. First, identify all molecules that have atoms with the element 'tin'. This can be done by querying the `atom` table where `element` is 'tin'.\n2. Next, find the `molecule_id`s of these molecules.\n3. Then, find all molecules that do not have these `molecule_id`s. These are the molecules that do not contain 'tin' atoms.\n4. Finally, retrieve the distinct `label` values from these molecules to determine the type of label not associated with 'tin' atoms.\n\nThe SQL query will involve subqueries to exclude molecules with 'tin' atoms and then retrieve the labels of the remaining molecules.",
        "sql": "SELECT DISTINCT m.label\nFROM molecule m\nWHERE m.molecule_id NOT IN (\n  SELECT a.molecule_id\n  FROM atom a\n  WHERE a.element = 'tin'\n);",
        "question": "What type of label is not on molecules with atoms with tin?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "evidence": [
            "tin refers to element ! = 'sn'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1408": {
        "reason": "To calculate the total cost spent for Parking, we need to identify the expenses related to Parking. The `expense` table contains the `expense_description` and `cost` fields, which can be used to filter and sum the costs for Parking-related expenses. The query will involve filtering the `expense_description` for entries that include 'Parking' and then summing the `cost` values for those entries.",
        "sql": "SELECT SUM(cost) AS total_parking_cost FROM expense WHERE expense_description LIKE '%Parking%';",
        "question": "Calculate the total cost spent for Parking in the list.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Parking'",
        "evidence": [
            "total cost spent for Parking refers to SUM(cost) where expense_description = 'Parking'"
        ]
    },
    "1260": {
        "reason": "To solve the question, we need to find patients who meet two conditions: their RF (Rheumatoid Factor) is normal (RF < 20) and they are older than 60 years. The steps are as follows:\n1. **Identify the RF condition**: The RF values are stored as TEXT but can be compared numerically. We will filter records where RF < 20.\n2. **Calculate age**: The age is calculated by subtracting the patient's birth year from the current year. We will use the `DATE('now')` function to get the current date and extract the year.\n3. **Join tables**: The `Laboratory` table contains the RF values, and the `Patient` table contains the birth dates. We will join these tables on the `ID` field.\n4. **Filter and list IDs**: After joining, we will filter for patients older than 60 and with normal RF, then list their IDs.",
        "sql": "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE CAST(l.RF AS REAL) < 20\nAND (strftime('%Y', DATE('now')) - strftime('%Y', p.Birthday)) > 60;",
        "question": "Please list the ID of the patient whose RF is normal and who is older than 60.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60",
        "evidence": [
            "RF is normal refers to RF < 20; older than 60 = SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) > 60;",
            "RF values in the Laboratory table are stored as TEXT but can be directly compared numerically without casting. Age calculation requires using DATE('now') for accurate current date handling.",
            "RF values in the Laboratory table can be compared numerically without casting, as they are stored as TEXT but represent numeric values. Age calculation should use DATE('now') for accurate current date handling.",
            "RF values in the Laboratory table can be compared numerically without casting, as they are stored as TEXT but represent numeric values. Age calculation should use DATE('now') for accurate current date handling."
        ]
    },
    "464": {
        "reason": "To solve the question, we need to find the names of the cards in the set \"Hauptset Zehnte Edition\". The schema includes a `sets` table and a `cards` table. The `sets` table contains information about the sets, including their codes and names, while the `cards` table contains information about individual cards, including the set they belong to (`setCode`).\n\n1. First, we need to identify the set code for \"Hauptset Zehnte Edition\" from the `sets` table. However, the name \"Hauptset Zehnte Edition\" is a translation, so we need to look it up in the `set_translations` table.\n2. Once we have the set code, we can join the `cards` table with the `sets` table (or the `set_translations` table) to filter cards that belong to this set.\n3. Finally, we will select the `name` column from the `cards` table for the matching set.",
        "sql": "SELECT c.name\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE st.translation = 'Hauptset Zehnte Edition';",
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "evidence": [
            "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'"
        ]
    },
    "261": {
        "reason": "To solve the question, we need to find the bond IDs for molecules that are carcinogenic. The schema provides the following information:\n1. The `molecule` table has a `label` column where `label = '+'` indicates carcinogenic molecules.\n2. The `bond` table contains the `bond_id` and `molecule_id` columns, which link bonds to molecules.\n3. The `molecule_id` in the `bond` table is a foreign key referencing the `molecule` table.\n\nSteps:\n1. Identify all molecules with `label = '+'` in the `molecule` table.\n2. Join the `bond` table with the filtered `molecule` table on `molecule_id` to get the bond IDs for carcinogenic molecules.\n3. Select the `bond_id` from the result of the join.",
        "sql": "SELECT b.bond_id\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE m.label = '+';",
        "question": "Write down bond id for molecules that are carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "evidence": [
            "label = '+' mean molecules are carcinogenic"
        ]
    },
    "857": {
        "reason": "To find the coordinate position for the Abu Dhabi Grand Prix, we need to locate the race named 'Abu Dhabi Grand Prix' in the `races` table. The `races` table has a foreign key `circuitId` that links to the `circuits` table, which contains the latitude (`lat`) and longitude (`lng`) coordinates. The steps are:\n1. Query the `races` table to find the `circuitId` for the race named 'Abu Dhabi Grand Prix'.\n2. Use this `circuitId` to query the `circuits` table for the `lat` and `lng` values.",
        "sql": "SELECT c.lat, c.lng \nFROM circuits c \nJOIN races r ON c.circuitId = r.circuitId \nWHERE r.name = 'Abu Dhabi Grand Prix';",
        "question": "Give the coordinate position for Abu Dhabi Grand Prix.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Abu Dhabi Grand Prix'",
        "evidence": [
            "coordinate position/location refers to lat, lng; Abu Dhabi Grand Prix refers to races.name = 'Abu Dhabi Grand Prix'"
        ]
    },
    "1300": {
        "reason": "To solve the question, we need to find the patient with the highest level of triglyceride (TG) within the normal range (TG < 200) and then determine their disease name. The steps are as follows:\n1. Identify the patient with the highest TG level from the Laboratory table where TG is less than 200.\n2. Use the patient's ID to retrieve their disease name from either the Patient or Examination table, as both contain a Diagnosis field. We will prioritize the Examination table for diagnosis as it might be more specific.\n3. Join the Laboratory table with the Examination table on the patient ID to get the diagnosis.",
        "sql": "SELECT e.Diagnosis\nFROM Laboratory l\nJOIN Examination e ON l.ID = e.ID\nWHERE l.TG < 200\nORDER BY l.TG DESC\nLIMIT 1;",
        "question": "What is the disease name of the patient who has the highest level of triglyceride within the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 ORDER BY T2.TG DESC LIMIT 1",
        "evidence": [
            "disease name referse to Diagnosis; highest level of triglyceride within the normal range refers to MAX(TG < 200);"
        ]
    },
    "850": {
        "reason": "To find the name of the race held on circuits in Germany, we need to:\n1. Identify circuits located in Germany from the `circuits` table.\n2. Join the `circuits` table with the `races` table to get the names of the races held on those circuits.\n3. Filter the results to include only circuits where the country is 'Germany'.",
        "sql": "SELECT r.name AS race_name\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Germany';",
        "question": "Please give the name of the race held on the circuits in Germany.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "evidence": [
            "Germany is a name of country;"
        ]
    },
    "1370": {
        "reason": "To list all expenses incurred by the vice president, we need to:\n1. Identify the vice president from the `member` table by filtering for the position 'Vice President'.\n2. Join the `member` table with the `expense` table using the `member_id` to link the expenses to the vice president.\n3. Retrieve the relevant expense details from the `expense` table.",
        "sql": "SELECT e.expense_id, e.expense_description, e.expense_date, e.cost, e.approved\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nWHERE m.position = 'Vice President';",
        "question": "List all the expenses incurred by the vice president.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T2.expense_id, T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "evidence": [
            "expense refers to expense_description; 'Vice President' is a position of the Student Club",
            "The `expense` table includes `expense_id` and `expense_description` as key fields for expense details. The `member` table links to `expense` via `member_id` to identify expenses by position.",
            "The `expense` table includes `expense_id` and `expense_description` as key fields for expense details. The `member` table links to `expense` via `member_id` to identify expenses by position."
        ]
    },
    "1125": {
        "reason": "To solve the question, we need to find the eldest player among those with a finishing rate of 1. The steps are as follows:\n1. Identify players with a finishing rate of 1 from the `Player_Attributes` table.\n2. Join these players with the `Player` table to get their names and birthdays.\n3. Calculate the age of each player based on their birthday.\n4. Order the players by their age in descending order to find the eldest.\n5. Select the top result to get the eldest player's name.",
        "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.finishing = 1\nORDER BY p.birthday ASC\nLIMIT 1;",
        "question": "Among the players with finishing rate of 1, pick the eldest player and state the player's name.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.finishing = 1 ORDER BY t1.birthday ASC LIMIT 1",
        "evidence": [
            "eldest player refers to MAX(SUBTRACT(datetime(CURRENT_TIMESTAMP,'localtime'),datetime(birthday))); finishing rate of 1 refers to finishing = 1"
        ]
    },
    "436": {
        "reason": "To solve the question, we need to find out how many cards have the frame effect 'extendedart' and list their IDs. The `frameEffects` column in the `cards` table stores the frame effect values. We will filter the `cards` table for rows where `frameEffects` contains 'extendedart'. Then, we will count the number of such cards and list their IDs.",
        "sql": "SELECT id FROM cards WHERE frameEffects = 'extendedart';",
        "question": "How many cards have frame effect as extendedart? List out the id of those cards.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id",
        "evidence": [
            "\nframe effect as extendedart refers to frameEffects = 'extendedart'\n",
            "The `frameEffects` column in the `cards` table stores frame effect values, and filtering for 'extendedart' retrieves the relevant cards.\nTo list individual card IDs, a simple selection query without aggregation is sufficient."
        ]
    },
    "1113": {
        "reason": "To find the defence aggression class for the team \"Hannover 96\" on 2015/9/10, we need to follow these steps:\n1. Identify the team_api_id for \"Hannover 96\" from the Team table, as team_long_name is 'Hannover 96'.\n2. Use this team_api_id to query the Team_Attributes table for the record where the date is '2015-09-10'.\n3. Retrieve the defenceAggressionClass from the matching record in the Team_Attributes table.",
        "sql": "SELECT t.team_long_name, ta.defenceAggressionClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_long_name = 'Hannover 96' AND ta.date LIKE '2015-09-10%';",
        "question": "For the team \"Hannover 96\", what was its defence aggression class on 2015/9/10?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t2.chanceCreationShootingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hannover 96' AND t2.`date` LIKE '2015-09-10%'",
        "evidence": [
            "\"Hannover 96\" refers to team_long_name = 'Hannover 96'; on 2015/9/10 refers to date LIKE '2015-09-10%';",
            "The attribute `defenceAggressionClass` is part of the `Team_Attributes` table, not `chanceCreationShootingClass`.",
            "The attribute `chanceCreationShootingClass` is part of the `Team_Attributes` table, not `defenceAggressionClass`.",
            "The attribute `chanceCreationShootingClass` is distinct from `defenceAggressionClass` and must be queried separately in the `Team_Attributes` table."
        ]
    },
    "1014": {
        "reason": "1. **Identify circuits in Italy**: Filter the `circuits` table by the `country` column for 'Italy'.\n2. **Retrieve races at these circuits**: Join the `races` table with the filtered `circuits` table using `circuitId`.\n3. **Extract and convert lap times**: Parse the `FastestLapTime` from the `results` table into minutes, seconds, and milliseconds, then convert to total seconds.\n4. **Find the minimum lap time**: Aggregate the converted lap times to identify the fastest record for each circuit.\n5. **Limit results**: Ensure the query returns only the fastest lap record per circuit.",
        "sql": "SELECT \n    c.name AS circuit_name,\n    MIN(\n        CAST(SUBSTR(r.fastestLapTime, 1, INSTR(r.fastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(r.fastestLapTime, INSTR(r.fastestLapTime, ':') + 1) AS REAL)\n    ) AS lap_record_seconds\nFROM \n    circuits c\nJOIN \n    races rc ON c.circuitId = rc.circuitId\nJOIN \n    results r ON rc.raceId = r.raceId\nWHERE \n    c.country = 'Italy'\n    AND r.fastestLapTime IS NOT NULL\nGROUP BY \n    c.name\nORDER BY \n    lap_record_seconds ASC;",
        "question": "Please list the lap records for the circuits in Italy.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "evidence": [
            "lap record means the fastest time recorded which refers to time",
            "The `results` table includes a `FastestLapTime` column specifically for recording the fastest lap times, which is more accurate for lap records than the general `time` column.\nTo compare lap times, the `FastestLapTime` must be converted into a numerical format (e.g., seconds) for accurate aggregation and filtering.",
            "The `FastestLapTime` column in the `results` table stores lap times in a string format (e.g., '1:23.456'), requiring conversion to numerical values for accurate comparison and aggregation.\nTo identify the fastest lap record, the query must convert `FastestLapTime` into a numerical format (e.g., seconds) and then find the minimum value for each circuit.",
            "The `FastestLapTime` column in the `results` table includes milliseconds, requiring conversion to seconds for precise comparison.\nTo accurately identify the fastest lap record, the query must parse the `FastestLapTime` string into minutes, seconds, and milliseconds, then convert it to a total numerical value in seconds."
        ]
    },
    "722": {
        "reason": "To find the skin color of Apocalypse, we need to follow these steps:\n1. Identify the superhero record for Apocalypse in the `superhero` table.\n2. Retrieve the `skin_colour_id` from this record.\n3. Use this `skin_colour_id` to look up the corresponding color name in the `colour` table.\n\nThe query will involve joining the `superhero` table with the `colour` table on the `skin_colour_id` field.",
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE s.superhero_name = 'Apocalypse';",
        "question": "What is the colour of Apocalypse's skin?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id WHERE T1.superhero_name = 'Apocalypse'",
        "evidence": [
            "Apocalypse refers to superhero_name = 'Apocalypse'; colour of skin refers to colour where skin_colour_id = colour.id"
        ]
    },
    "927": {
        "reason": "To find the driver who created the fastest lap speed in a Formula 1 race, we need to analyze the `results` table, which contains the `fastestLapSpeed` column. The `results` table also includes `driverId`, which can be linked to the `drivers` table to retrieve the driver's forename and surname. The query should join these tables and order the results by `fastestLapSpeed` in descending order to find the fastest lap speed. The top result will give us the required driver's details.",
        "sql": "SELECT d.forename, d.surname\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;",
        "question": "Which driver created the fastest lap speed in a Formula_1 race? Please give both his forename and surname.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "evidence": [
            ""
        ]
    },
    "997": {
        "reason": "To determine the most common nationality (citizenship) among drivers, we need to analyze the `nationality` column in the `drivers` table. The steps are as follows:\n1. Group the drivers by their `nationality`.\n2. Count the number of drivers in each nationality group using `COUNT(driverId)` to ensure uniqueness.\n3. Sort the results by the count in descending order to identify the nationality with the highest count.\n4. Limit the result to the top entry to find the most common nationality.",
        "sql": "SELECT nationality, COUNT(driverId) AS driver_count\nFROM drivers\nGROUP BY nationality\nORDER BY driver_count DESC\nLIMIT 1;",
        "question": "Which citizenship do the vast majority of the drivers hold?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1",
        "evidence": [
            "Citizenship of majority of drivers = MAX(nationality); citizenship and nationality are synonyms\n\n",
            "To identify the most common nationality, group by nationality and count driver occurrences, then sort by count in descending order.\nThe `nationality` column in the `drivers` table represents citizenship.\nUse `COUNT(driverId)` for accurate aggregation instead of `COUNT(*)` to ensure driver uniqueness.",
            "The `nationality` column in the `drivers` table is used to determine citizenship. Aggregating with `COUNT(driverId)` ensures uniqueness, and sorting by count in descending order identifies the most common nationality.",
            "The `nationality` column in the `drivers` table is the key attribute for determining citizenship. Aggregating with `COUNT(driverId)` ensures uniqueness, and sorting by count in descending order identifies the most common nationality."
        ]
    },
    "141": {
        "reason": "To solve the question, we need to identify districts where the total transaction amount exceeds $10,000 in the year 1997. Here's the step-by-step reasoning:\n\n1. **Link Transactions to Districts**: Transactions are linked to accounts, and accounts are linked to districts. Therefore, we need to join the `trans` table with the `account` table to get the `district_id` for each transaction.\n\n2. **Filter Transactions by Year**: We need to filter transactions to only include those from the year 1997. This can be done using the `WHERE` clause on the `date` column in the `trans` table.\n\n3. **Aggregate Transactions by District**: We need to group the transactions by `district_id` and calculate the total transaction amount for each district.\n\n4. **Filter Aggregated Results**: Finally, we need to filter the aggregated results to only include districts where the total transaction amount exceeds $10,000. This is done using the `HAVING` clause.\n\n5. **Retrieve District Information**: To get the district names or other details, we can join the results with the `district` table.\n\nThe query will involve joining the `trans`, `account`, and `district` tables, filtering by year, aggregating by district, and then filtering the aggregated results.",
        "sql": "SELECT d.district_id, d.A2 AS district_name, SUM(t.amount) AS total_transaction_amount\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE strftime('%Y', t.date) = '1997'\nGROUP BY d.district_id, d.A2\nHAVING SUM(t.amount) > 10000;",
        "question": "Which districts have transactions greater than USS$10,000 in 1997?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date) = '1997' GROUP BY T1.district_id HAVING SUM(T3.amount) > 10000",
        "evidence": [
            "",
            "Transactions must be aggregated by district to check if their total exceeds the threshold, not filtered individually.\nThe `HAVING` clause is used to filter aggregated results, not the `WHERE` clause for individual rows.\nJoins should include all necessary tables to link transactions to districts via accounts.",
            "The `district_id` is the primary key in the `district` table and is used to link accounts to districts.\nAggregation should be performed at the district level to ensure the total transaction amount is calculated per district.\nThe `WHERE` clause filters individual transactions by year before aggregation, while the `HAVING` clause filters aggregated results by total amount.",
            "The `district_id` in the `account` table is the key to link transactions to districts, not the `district` table directly.\nAggregation should be performed on the `account` table's `district_id` to ensure correct grouping.\nThe `WHERE` clause filters transactions by year before aggregation, while the `HAVING` clause filters aggregated results by total amount."
        ]
    },
    "533": {
        "reason": "To solve the question, we need to count the number of users who last accessed the website after September 1, 2014. The `LastAccessDate` column in the `users` table stores the datetime of the last access. We will use the `date()` function to compare the date part of `LastAccessDate` with '2014-09-01' to ensure accurate filtering. The query will count the rows where `LastAccessDate` is greater than this date.",
        "sql": "SELECT COUNT(*) FROM users WHERE date(LastAccessDate) > '2014-09-01';",
        "question": "How many users last accessed the website after 2014/9/1?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
        "evidence": [
            "last accessed after 2014/9/1 refers to LastAccessDate > '2014-09-01'",
            "The `LastAccessDate` column in the `users` table stores datetime values, and filtering requires using the `date()` function to compare dates accurately.",
            "The `date()` function is necessary to compare only the date part of `LastAccessDate` for accurate filtering."
        ]
    },
    "536": {
        "reason": "To solve the question, we need to find the number of users who have more than 10 views and created their accounts after the year 2013. The steps are as follows:\n1. Filter the `users` table to include only users with `Views` greater than 10.\n2. Further filter these users to include only those whose `CreationDate` is after December 31, 2013.\n3. Count the number of users who meet both criteria.",
        "sql": "SELECT COUNT(*) \nFROM users \nWHERE Views > 10 \nAND strftime('%Y', CreationDate) > '2013';",
        "question": "How many users with more than 10 views created their account after the year 2013?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM users WHERE STRFTIME('%Y', CreationDate) > '2013' AND Views > 10",
        "evidence": [
            "more than 10 views refers to Views > 10; created after the year 2013 refers to year (CreationDate) > 2013"
        ]
    },
    "619": {
        "reason": "To solve the question, we need to find the number of adults (users aged between 19 and 65) who have obtained the badge named 'Supporter'. This involves the following steps:\n1. Identify users who are adults by checking their age in the `users` table.\n2. Identify users who have the badge 'Supporter' by querying the `badges` table where the `Name` is 'Supporter'.\n3. Join these two results to count the number of users who meet both criteria.",
        "sql": "SELECT COUNT(DISTINCT u.Id) AS AdultSupporters\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE u.Age BETWEEN 19 AND 65\nAND b.Name = 'Supporter';",
        "question": "How many adults who obtained the badge Supporter?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Supporter' AND T1.Age BETWEEN 19 AND 65",
        "evidence": [
            "Supporter is the Name of badge; adult refers to Age BETWEEN 19 AND 65"
        ]
    },
    "1053": {
        "reason": "To solve the question, we need to find football teams that have a chance creation passing class of 'Risky'. The relevant table for this information is `Team_Attributes`, which contains the column `chanceCreationPassingClass`. We need to join this table with the `Team` table to get the team's short name (`team_short_name`). The query will filter records where `chanceCreationPassingClass` is 'Risky' and return the `team_short_name`.",
        "sql": "SELECT t.team_short_name\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE ta.chanceCreationPassingClass = 'Risky';",
        "question": "List the football teams that has a chance creation passing class of Risky. Inidcate its short name only.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Risky'",
        "evidence": [
            "chance creation passing class refers to chanceCreationPassingClass; chanceCreationPassingClass = 'Risky'; short name refers to team_short_name;"
        ]
    },
    "29": {
        "reason": "To solve the question, we need to find the school with the largest enrollment in grades K-12 and then determine when it opened. The steps are as follows:\n1. Identify the school with the largest enrollment from the `frpm` table, which contains the `Enrollment (K-12)` column.\n2. Once the school is identified, use its `CDSCode` to find its opening date from the `schools` table, which contains the `OpenDate` column.\n3. The query will join the `frpm` and `schools` tables on the `CDSCode` to retrieve the necessary information.",
        "sql": "SELECT s.OpenDate\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nORDER BY f.[Enrollment (K-12)] DESC\nLIMIT 1;",
        "question": "When did the first-through-twelfth-grade school with the largest enrollment open?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.OpenDate FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "evidence": [
            "K-12 means First-through-twelfth-grade"
        ]
    },
    "1321": {
        "reason": "To solve the question, we need to find out how many events Sacha Harrison attended in 2019. Here's the step-by-step reasoning:\n\n1. **Identify Sacha Harrison's member_id**: We need to find the `member_id` of Sacha Harrison from the `member` table using her first and last name.\n2. **Filter events in 2019**: We need to filter events from the `event` table where the `event_date` falls in the year 2019.\n3. **Join tables**: We need to join the `attendance` table to link the events Sacha attended with her `member_id`.\n4. **Count the events**: Finally, we count the number of events that meet the criteria.\n\nThe query will involve joining the `member`, `event`, and `attendance` tables, filtering for Sacha Harrison and events in 2019, and then counting the results.",
        "sql": "SELECT COUNT(*) AS event_count\nFROM attendance a\nJOIN member m ON a.link_to_member = m.member_id\nJOIN event e ON a.link_to_event = e.event_id\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison'\nAND strftime('%Y', e.event_date) = '2019';",
        "question": "How many events of the Student_Club did Sacha Harrison attend in 2019?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Sacha' AND T3.last_name = 'Harrison' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "evidence": [
            "events attended in 2019 refers to YEAR(event_date) = 2019"
        ]
    },
    "1044": {
        "reason": "To solve the question, we need to list football players born in October 1970. The `Player` table contains the `birthday` column, which stores dates in the format 'YYYY-MM-DD'. We can use the `SUBSTR` function to extract the year and month from the `birthday` column. Specifically, we will extract the first 7 characters (YYYY-MM) and filter for '1970-10' to identify players born in October 1970.",
        "sql": "SELECT player_name, birthday FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10';",
        "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
        "evidence": [
            "players with a birthyear of 1970 and a birthmonth of October refers to substr(birthday,1,7) AS 'year-month',WHERE year = '1970' AND month = '10';",
            "The `birthday` column in the `Player` table stores dates in a format that can be parsed using `SUBSTR` to extract year and month for filtering.",
            "The `birthday` column in the `Player` table can be filtered using `SUBSTR` to extract the year and month, assuming the format is 'YYYY-MM-DD'.",
            "The `birthday` column in the `Player` table can be filtered using `SUBSTR` to extract the year and month, assuming the format is 'YYYY-MM-DD'."
        ]
    },
    "680": {
        "reason": "To find the average score of Stephen Turner's posts, we need to follow these steps:\n1. Identify Stephen Turner's user ID from the `users` table using his display name (\"Stephen Turner\").\n2. Use this user ID to filter posts in the `posts` table where the `OwnerUserId` matches Stephen Turner's ID.\n3. Calculate the average score of these posts using the `AVG` function on the `Score` column.",
        "sql": "SELECT AVG(Score) AS AverageScore\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Stephen Turner');",
        "question": "What is the average score of Stephen Turner's posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.Score) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Stephen Turner'",
        "evidence": [
            "DisplayName = 'Stephen Turner'; average score refers to AVG(Score);"
        ]
    },
    "840": {
        "reason": "To find the attribute value of the superhero named Aquababy, we need to follow these steps:\n1. Identify the superhero's ID from the `superhero` table where the `superhero_name` is 'Aquababy'.\n2. Use this ID to join with the `hero_attribute` table to retrieve the `attribute_value` associated with Aquababy.\n3. Since the `hero_attribute` table already contains the attribute values, we don't need to join with the `attribute` table for this query.",
        "sql": "SELECT ha.attribute_value\nFROM superhero sh\nJOIN hero_attribute ha ON sh.id = ha.hero_id\nWHERE sh.superhero_name = 'Aquababy';",
        "question": "List the attribute value of the superhero named Aquababy.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Aquababy'",
        "evidence": [
            "",
            "The `hero_attribute` table directly links superheroes to their attribute values, so joining with the `attribute` table is unnecessary for retrieving the attribute values alone."
        ]
    },
    "741": {
        "reason": "To find the superhero with the most powers, we need to:\n1. Count the number of powers each superhero has by joining the `superhero` table with the `hero_power` table.\n2. Group the results by the superhero's name.\n3. Order the results by the count of powers in descending order.\n4. Limit the result to the top 1 to get the superhero with the most powers.",
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nGROUP BY s.superhero_name\nORDER BY COUNT(hp.power_id) DESC\nLIMIT 1;",
        "question": "What is the name of the superhero that has the most powers?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "evidence": [
            "name of the superhero refers to superhero_name; superhero that has the most powers refers to MAX(COUNT(superhero_name))"
        ]
    },
    "199": {
        "reason": "To solve the question, we need to find the count of non-carcinogenic molecules that contain sodium atoms. The steps are as follows:\n1. Identify all molecules that contain sodium atoms by joining the `atom` table with the `molecule` table where the element is 'na'.\n2. From these molecules, filter those that are non-carcinogenic (label = '-').\n3. Count the number of such molecules.",
        "sql": "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE a.element = 'na' AND m.label = '-';",
        "question": "In the molecule containing sodium atoms, how many are non-carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'na' AND T2.label = '-'",
        "evidence": [
            "non-carcinogenic refers to label = '-'; sodium atoms refers to element = 'na'"
        ]
    },
    "1233": {
        "reason": "To solve the question, we need to list each patient's ID and their blood glucose (GLU) index that falls within the normal range (GLU < 180) for patients whose data was first recorded in 1991. The steps are as follows:\n1. Identify patients whose data was first recorded in 1991 by checking the `First Date` field in the `Patient` table.\n2. For these patients, retrieve their GLU values from the `Laboratory` table.\n3. Filter the GLU values to only include those within the normal range (GLU < 180).\n4. Combine the results to list the patient ID and their corresponding GLU values.",
        "sql": "SELECT p.ID, l.GLU\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE strftime('%Y', p.\"First Date\") = '1991'\nAND l.GLU < 180;",
        "question": "List each patient's ID and blood glucose (GLU) index that were within normal range for patient's whose data was first recorded in 1991.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T2.GLU FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) = '1991' AND T2.GLU < 180",
        "evidence": [
            "blood glucose (GLU) index that were within normal range refers to GLU < 180; data that was first recorded in 1991 refers to year(Description) = 1991;",
            "The `First Date` field in the `Patient` table indicates when a patient's data was first recorded, not the `Description` field. The `Description` field is unrelated to recording dates."
        ]
    },
    "437": {
        "reason": "To solve the question, we need to identify cards that have both a black border (borderColor = 'black') and full artwork (isFullArt = 1). The query should return the unique identifier (id) of such cards. We will query the 'cards' table and filter for these conditions.",
        "sql": "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1;",
        "question": "Among black card borders, which card has full artwork?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1",
        "evidence": [
            "white card borders refers to borderColor = 'white'; has full artwork refers to isFullArt = 1",
            "black card borders are identified by borderColor = 'black'.\nfull artwork is indicated by isFullArt = 1.\ncard identification typically uses the id field for unique reference.",
            "The query should return only the unique identifier (id) of the card, not all details, to match the intent of identifying specific cards."
        ]
    },
    "175": {
        "reason": "To solve the question, we need to find the number of accounts that have an owner disposition and a frequency of 'POPLATEK PO OBRATU', which means the statement is generated upon a transaction. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: We need the `account` table (for frequency) and the `disp` table (for disposition type).\n2. **Filter conditions**: \n   - The `disp.type` should be 'OWNER' (indicating an owner disposition).\n   - The `account.frequency` should be 'POPLATEK PO OBRATU' (indicating issuance after transaction).\n3. **Join the tables**: The `disp` table links to the `account` table via `account_id`.\n4. **Count the distinct accounts**: We need to count the distinct `account_id` values that meet the above conditions.",
        "sql": "SELECT COUNT(DISTINCT a.account_id) AS account_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nWHERE d.type = 'OWNER' AND a.frequency = 'POPLATEK PO OBRATU';",
        "question": "How many accounts have an owner disposition and request for a statement to be generated upon a transaction?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK PO OBRATU'",
        "evidence": [
            "Frequency = 'POPLATEK PO OBRATU' stands for issuance after transaction"
        ]
    },
    "1007": {
        "reason": "To find the longest time Lewis Hamilton spent at a pit stop, we need to:\n1. Identify Lewis Hamilton's driverId from the drivers table using his name.\n2. Join the pitStops table with the drivers table to filter pit stops for Lewis Hamilton.\n3. Use the MAX function on the duration column in the pitStops table to find the longest pit stop time.\n4. Ensure the query returns the duration of the longest pit stop.",
        "sql": "SELECT MAX(p.duration) AS longest_pit_stop_time\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "question": "What was the longest time that Lewis Hamilton had spent at a pit stop?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.duration DESC LIMIT 1",
        "evidence": [
            "longest time refes to MAX(duration);"
        ]
    },
    "1405": {
        "reason": "To solve the question, we need to find the amount budgeted for the 'April Speaker' event and list all the budgeted categories for this event in ascending order based on their amount budgeted. Here's the step-by-step reasoning:\n\n1. **Identify the event**: First, we need to find the `event_id` for the event named 'April Speaker' from the `event` table.\n2. **Link to budget**: Using the `event_id`, we can find all budget entries linked to this event in the `budget` table.\n3. **Retrieve budget details**: For each budget entry linked to the event, we need to retrieve the `category` and `amount`.\n4. **Order by amount**: Finally, we need to order the results by the `amount` in ascending order.\n\nThe SQL query will involve joining the `event` and `budget` tables to get the required information.",
        "sql": "SELECT b.category, b.amount\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'April Speaker'\nORDER BY b.amount ASC;",
        "question": "Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category, SUM(T2.amount) FROM event AS T1 JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'April Speaker' GROUP BY T2.category ORDER BY SUM(T2.amount) ASC",
        "evidence": [
            "'April Speaker' is an event name; amount budgeted refers to SUM(amount); budget categories refers to category"
        ]
    },
    "32": {
        "reason": "To solve the question, we need to find the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count, specifically for schools with the ownership code 66. Here's the step-by-step reasoning:\n\n1. **Filter Schools by Ownership Code**: First, we need to filter the `schools` table to include only those schools where the `SOC` column (ownership code) is 66.\n\n2. **Join with FRPM Data**: Next, we join the filtered schools with the `frpm` table to get the relevant data for free or reduced price meals. The join is done using the `CDSCode` column.\n\n3. **Calculate Eligible Rate**: The eligible free or reduced price meal rate is calculated as `FRPM Count (K-12)` divided by `Enrollment (K-12)`. Both columns should be cast to `REAL` for accurate division.\n\n4. **Order by FRPM Count**: We order the results by the `FRPM Count (K-12)` in descending order to get the schools with the highest counts.\n\n5. **Limit to Top 5**: Finally, we limit the results to the top 5 schools to answer the question.",
        "sql": "SELECT \n    s.CDSCode,\n    s.School,\n    f.`FRPM Count (K-12)`,\n    f.`Enrollment (K-12)`,\n    (CAST(f.`FRPM Count (K-12)` AS REAL) / CAST(f.`Enrollment (K-12)` AS REAL)) AS `Eligible Rate`\nFROM \n    schools s\nJOIN \n    frpm f ON s.CDSCode = f.CDSCode\nWHERE \n    s.SOC = 66\nORDER BY \n    f.`FRPM Count (K-12)` DESC\nLIMIT 5;",
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "evidence": [
            "grades 1-12 means K-12; Eligible free or reduced price meal rate for K-12 = `FRPM Count (K-12)` / `Enrollment (K-12)`",
            "The ownership code is stored in the `SOC` column of the `schools` table, not the `DOC` column.",
            "The `SOC` column in the `schools` table stores ownership codes as integers, not strings, requiring numeric comparison.\nThe `FRPM Count (K-12)` and `Enrollment (K-12)` columns should be cast to REAL for accurate division.",
            "The `FRPM Count (K-12)` and `Enrollment (K-12)` columns should be explicitly cast to REAL for accurate division.\nThe `SOC` column in the `schools` table requires numeric comparison for ownership code filtering."
        ]
    },
    "507": {
        "reason": "To solve the question, we need to determine the percentage of sets with Brazil Portuguese translations that are only available online. Here's the step-by-step reasoning:\n\n1. **Identify sets with Brazil Portuguese translations**: We need to query the `set_translations` table where the `language` is 'Portuguese (Brazil)' to get the `setCode` values of these sets.\n\n2. **Filter online-only sets**: Using the `sets` table, we filter the sets identified in step 1 where `isOnlineOnly` is 1 (indicating they are only available online).\n\n3. **Calculate the percentage**: We divide the count of online-only sets (from step 2) by the total count of sets with Brazil Portuguese translations (from step 1) and multiply by 100 to get the percentage.\n\n4. **Ensure accurate division**: Cast the counts to REAL to avoid integer division issues in SQLite.\n\n5. **Final query**: Combine these steps into a single query that calculates the percentage.",
        "sql": "WITH brazil_portuguese_sets AS (\n    SELECT DISTINCT setCode\n    FROM set_translations\n    WHERE language = 'Portuguese (Brazil)'\n),\nonline_only_sets AS (\n    SELECT COUNT(*) AS online_count\n    FROM sets\n    WHERE isOnlineOnly = 1 AND code IN (SELECT setCode FROM brazil_portuguese_sets)\n),\ntotal_sets AS (\n    SELECT COUNT(*) AS total_count\n    FROM sets\n    WHERE code IN (SELECT setCode FROM brazil_portuguese_sets)\n)\nSELECT (CAST(online_only_sets.online_count AS REAL) / CAST(total_sets.total_count AS REAL)) * 100 AS percentage_online_only\nFROM online_only_sets, total_sets;",
        "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
        "evidence": [
            "Brazil Portuguese translation refers to language = 'Portuguese (Brazil)'; only available online refers to isOnlineOnly = 1; percentage of online only Brazil Portuguese in all Brazil Portuguese cards refers to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)))*100",
            "The `set_translations` table links to `sets` via `setCode`, not directly to `cards`.\nTo determine online-only availability, the `isOnlineOnly` field in the `sets` table must be used, not the `cards` table.\nPercentage calculation requires casting to REAL for accurate division.",
            "The `sets` table contains the `isOnlineOnly` field, which determines online availability, and must be queried directly for accurate results.\nTo filter sets with Brazil Portuguese translations, use a subquery on `set_translations` to identify relevant `setCode` values.\nPercentage calculation should use the `id` field in `sets` for counting to ensure accuracy."
        ]
    },
    "37": {
        "reason": "To find the complete address of the school with the lowest excellence rate, we need to follow these steps:\n1. Calculate the excellence rate for each school using the formula: `NumGE1500 / NumTstTakr` from the `satscores` table.\n2. Identify the school with the lowest excellence rate.\n3. Retrieve the complete address (Street, City, State, Zip) of this school from the `schools` table.\n4. Join the `satscores` and `schools` tables on the `CDSCode` (or `cds` in `satscores`) to link the data.\n5. Order the results by the excellence rate in ascending order and limit the result to the first row to get the school with the lowest rate.",
        "sql": "SELECT s.Street, s.City, s.State, s.Zip\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.NumTstTakr > 0\nORDER BY (sc.NumGE1500 * 1.0 / sc.NumTstTakr) ASC\nLIMIT 1;",
        "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
        "evidence": [
            "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code"
        ]
    },
    "1416": {
        "reason": "To solve the question, we need to find the number of members who are associated with the 'Business' major and have a 'Medium' t-shirt size. This involves querying the 'member' table and joining it with the 'major' table to filter members by their major. The steps are:\n1. Join the 'member' table with the 'major' table on the 'link_to_major' and 'major_id' fields.\n2. Filter the results where the 'major_name' is 'Business' and the 't_shirt_size' is 'Medium'.\n3. Count the number of such members.",
        "sql": "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Business' AND member.t_shirt_size = 'Medium';",
        "question": "How many members of Business have the Medium size of tee shirt?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business' AND T2.t_shirt_size = 'Medium'",
        "evidence": [
            "members of Economics refers to major_name = 'Business'; t_shirt_size = 'Medium'"
        ]
    },
    "560": {
        "reason": "To solve the question, we need to count the number of badges with the name \"Revival\". The relevant table for this query is the `badges` table, which contains the `Name` column. We will use the `COUNT` function to count the rows where the `Name` column matches \"Revival\".",
        "sql": "SELECT COUNT(*) FROM badges WHERE Name = 'Revival';",
        "question": "Give the number of \"Revival\" badges.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE Name = 'Revival'",
        "evidence": [
            "number refers to Id; 'Revival' is the Name of badge"
        ]
    },
    "537": {
        "reason": "To find out how many posts the user 'csgillespie' owns, we need to follow these steps:\n1. Identify the user ID of 'csgillespie' from the `users` table.\n2. Use this user ID to count the number of posts in the `posts` table where the `OwnerUserId` matches the identified user ID.\n\nThe query will involve joining the `users` table with the `posts` table to ensure we are counting the correct posts.",
        "sql": "SELECT COUNT(*) AS post_count\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');",
        "question": "How many posts does the user csgillespie own?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "evidence": [
            "\"csgillespie\" is the DisplayName of user"
        ]
    },
    "1021": {
        "reason": "To find the height of the tallest player and indicate his name, we need to query the `Player` table. The `height` column in the `Player` table stores the height of each player. We can use the `ORDER BY` clause to sort the players by height in descending order and then use `LIMIT 1` to get the tallest player. The query will select both the `player_name` and `height` columns to display the name and height of the tallest player.",
        "sql": "SELECT player_name, height FROM Player ORDER BY height DESC LIMIT 1;",
        "question": "What is the height of the tallest player? Indicate his name.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "evidence": [
            "tallest player refers to MAX(height);",
            "To retrieve the tallest player, use ORDER BY height DESC with LIMIT 1 instead of MAX(height) to ensure the correct player name is paired with the height.",
            "To retrieve the tallest player, focus on selecting only the player_name when using ORDER BY height DESC with LIMIT 1 to avoid redundant data.",
            "To retrieve only the player name of the tallest player, ensure the SELECT clause excludes the height column when using ORDER BY height DESC with LIMIT 1."
        ]
    },
    "798": {
        "reason": "To find the publisher for Hawkman, Karate Kid, and Speedy, we need to:\n1. Identify the superhero records for these three superheroes by their `superhero_name`.\n2. Join the `superhero` table with the `publisher` table to get the `publisher_name` for each of these superheroes.\n3. Filter the results to only include the specified superheroes.\n4. Return only the `publisher_name` without including the `superhero_name` in the output.",
        "sql": "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');",
        "question": "What is the publisher for Hawkman, Karate Kid and Speedy?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')",
        "evidence": [
            "publisher refers to publisher_name; Hawkman refers to superhero_name = 'Hawkman'; Karate Kid refers to superhero_name = 'Karate Kid'; Speedy refers to superhero_name = 'Speedy';",
            "The query should focus on retrieving only the publisher_name without including superhero_name in the output."
        ]
    },
    "955": {
        "reason": "To solve the question, we need to calculate the average time in seconds of champions for each year before 1975. The steps are as follows:\n1. Identify champions by filtering the `results` table where `positionOrder = 1` and `time` is not null.\n2. Join the `results` table with the `races` table to get the year of each race.\n3. Filter races that occurred before 1975 using `races.year < 1975`.\n4. Convert the `time` column in the `results` table to seconds. The `time` column can be in formats like 'H:MM:SS.mmm' or 'HH:MM:SS.mmm', so we need to parse it accordingly.\n5. Group the results by year and calculate the average time in seconds for each year.\n\nThe parsing logic for the `time` column involves:\n- Extracting hours, minutes, seconds, and milliseconds from the string.\n- Converting each part to seconds and summing them up.\n- Handling cases where the format might vary (e.g., 'H:MM:SS.mmm' vs 'HH:MM:SS.mmm').",
        "sql": "SELECT \n    races.year,\n    AVG(\n        CAST(SUBSTR(results.time, 1, INSTR(results.time, ':') - 1) AS REAL) * 3600 +\n        CAST(SUBSTR(results.time, INSTR(results.time, ':') + 1, 2) AS REAL) * 60 +\n        CAST(SUBSTR(results.time, INSTR(results.time, ':') + 4, 2) AS REAL) +\n        CAST(SUBSTR(results.time, INSTR(results.time, '.') + 1) AS REAL) / 1000\n    ) AS average_time_seconds\nFROM \n    results\nJOIN \n    races ON results.raceId = races.raceId\nWHERE \n    results.positionOrder = 1 \n    AND results.time IS NOT NULL \n    AND races.year < 1975\nGROUP BY \n    races.year\nORDER BY \n    races.year;",
        "question": "What is the average time in seconds of champion for each year, before year 1975?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
        "evidence": [
            "only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null; before year 1975 refers to year < 1975;",
            "The `positionOrder` column in the `results` table indicates the final race position, with 1 representing the champion.\nThe `time` column in the `results` table must be parsed differently based on its format, which can vary (e.g., 'H:MM:SS.mmm' or 'HH:MM:SS.mmm').\nFiltering for champions requires checking `positionOrder = 1` and ensuring the `time` is not null.",
            "The `time` column in the `results` table may have varying formats, such as 'H:MM:SS.mmm' or 'HH:MM:SS.mmm', requiring flexible parsing logic.\nChampions are identified by `positionOrder = 1` in the `results` table, and only non-null `time` values should be considered.\nFiltering for years before 1975 involves joining the `results` table with the `races` table and checking `races.year < 1975`."
        ]
    },
    "19": {
        "reason": "To find the phone number of the school with the highest average score in Math, we need to follow these steps:\n1. Identify the school with the highest average Math score from the `satscores` table. This can be done by ordering the `AvgScrMath` column in descending order and limiting the result to 1.\n2. Once we have the school's CDS code (primary key), we can join the `schools` table to retrieve the phone number associated with that CDS code.\n3. The join will be performed on the `CDSCode` column in the `schools` table and the `cds` column in the `satscores` table.",
        "sql": "SELECT s.Phone\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nORDER BY sc.AvgScrMath DESC\nLIMIT 1;",
        "question": "What is the phone number of the school that has the highest average score in Math?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY T2.AvgScrMath DESC LIMIT 1",
        "evidence": [
            "",
            "To retrieve the top record by a specific metric, use ORDER BY with DESC and LIMIT 1 instead of a subquery with MAX.\nJoining tables requires matching primary keys to ensure accurate results."
        ]
    },
    "1065": {
        "reason": "To solve the question, we need to find all team names where the speed class is 'Fast'. The speed class is stored in the `Team_Attributes` table under the column `buildUpPlaySpeedClass`. The team names are stored in the `Team` table under the column `team_long_name`. We will join these two tables on the `team_api_id` to match the team attributes with their respective team names. The query will filter for rows where `buildUpPlaySpeedClass` is 'Fast'.",
        "sql": "SELECT t.team_long_name \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE ta.buildUpPlaySpeedClass = 'Fast';",
        "question": "Please list all team names which the speed class is fast.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "evidence": [
            "team names refers to team_long_name; speed class refers to buildUpPlaySpeedClass; buildUpPlaySpeedClass = 'Fast';"
        ]
    },
    "545": {
        "reason": "To solve the question, we need to find out how many root posts are owned by the user with the display name 'csgillespie'. A root post is identified by having no `ParentId` (i.e., it is not an answer to another post). The steps are:\n1. Join the `posts` table with the `users` table to link posts to their owners.\n2. Filter the posts where the `OwnerUserId` matches the `Id` of the user with `DisplayName` 'csgillespie'.\n3. Further filter these posts to only include those where `ParentId` is NULL (indicating they are root posts).\n4. Count the number of such posts.",
        "sql": "SELECT COUNT(*) \nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie' AND p.ParentId IS NULL;",
        "question": "Among the posts owned by csgillespie, how many of them are root posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' AND T1.ParentId IS NULL",
        "evidence": [
            "\"csgillespie\" is the DisplayName of user; root post refers to ParentId IS Null"
        ]
    },
    "763": {
        "reason": "To find the attribute value of the superhero 'Abomination', we need to follow these steps:\n1. Identify the superhero ID for 'Abomination' from the `superhero` table.\n2. Use this ID to query the `hero_attribute` table to retrieve the attribute values associated with 'Abomination'.\n3. Since the question does not specify a particular attribute, we will retrieve all attribute values for 'Abomination'.",
        "sql": "SELECT ha.attribute_value\nFROM hero_attribute ha\nJOIN superhero sh ON ha.hero_id = sh.id\nWHERE sh.superhero_name = 'Abomination';",
        "question": "Indicate the attribute value of superhero Abomination.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Abomination'",
        "evidence": [
            "Abomination refers to superhero_name = 'Abomination';",
            "The `hero_attribute` table directly links superhero IDs to their attribute values, eliminating the need to join with the `attribute` table for retrieving only the attribute values."
        ]
    },
    "1376": {
        "reason": "To solve the question, we need to find the closed event with the highest spend-to-budget ratio. The steps are as follows:\n1. Identify closed events by filtering the `event` table where `status` is 'Closed'.\n2. Join the `event` table with the `budget` table using the `event_id` and `link_to_event` columns to link events with their budgets.\n3. Calculate the spend-to-budget ratio for each event by dividing `spent` by `amount` from the `budget` table.\n4. Order the results by the calculated ratio in descending order to find the highest ratio.\n5. Limit the result to the top entry to get the event with the highest ratio.\n6. Select the `event_name` and the calculated ratio for clarity.",
        "sql": "SELECT e.event_name, (b.spent / b.amount) AS spend_to_budget_ratio\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.status = 'Closed'\nORDER BY spend_to_budget_ratio DESC\nLIMIT 1;",
        "question": "Among all the closed events, which event has the highest spend-to-budget ratio?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
        "evidence": [
            "closed events refers to event_name where status = 'Closed'; highest spend-to budget ratio refers to MAX(DIVIDE(spent, amount))",
            "The spend-to-budget ratio is derived from the `budget` table, specifically the columns `spent` and `amount`.\nTo find the highest ratio, the query must order by the calculated ratio in descending order and limit to the top result.\nThe join between `event` and `budget` tables is necessary to link event details with their respective budget data.",
            "The `budget` table contains the `spent` and `amount` columns, which are used to calculate the spend-to-budget ratio.\nTo retrieve the event name, the query must join the `budget` table with the `event` table.\nThe highest ratio is determined by ordering the results in descending order and limiting to the top entry.",
            "The `budget` table must be the primary table in the join to ensure all budget-related calculations are prioritized.\nThe join condition should explicitly link the `budget` table to the `event` table using the `link_to_event` column.\nThe ratio calculation should directly reference columns from the `budget` table without aliasing in the ORDER BY clause."
        ]
    },
    "1163": {
        "reason": "To determine the age of the youngest patient when they initially arrived at the hospital, we need to calculate the age of each patient at their first recorded date (either 'First Date' or 'Admission' date) and then find the minimum age among them. The steps are:\n1. Extract the 'Birthday' and 'First Date' or 'Admission' date from the 'Patient' table.\n2. Calculate the age by finding the difference in years between the 'Birthday' and the 'First Date' or 'Admission' date.\n3. Use the MIN function to find the youngest age.",
        "sql": "SELECT MIN(strftime('%Y', `First Date`) - strftime('%Y', Birthday) - (strftime('%m-%d', `First Date`) < strftime('%m-%d', Birthday))) AS youngest_age FROM Patient;",
        "question": "What was the age of the youngest patient when they initially arrived at the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT MIN(STRFTIME('%Y', `First Date`) - STRFTIME('%Y', Birthday)) FROM Patient",
        "evidence": [
            "age refers to SUBTRACT(YEAR(`First Date`),YEAR(Birthday))"
        ]
    },
    "1083": {
        "reason": "To find the player with the strongest overall strength, we need to identify the player with the highest `overall_rating` in the `Player_Attributes` table. This involves joining the `Player_Attributes` table with the `Player` table to retrieve the player's name. The steps are as follows:\n1. Join `Player_Attributes` and `Player` on `player_api_id`.\n2. Select the player's name (`player_name`) and their `overall_rating`.\n3. Order the results by `overall_rating` in descending order to find the highest rating.\n4. Limit the result to 1 to get the player with the strongest overall strength.",
        "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;",
        "question": "Which player has the strongest overall strength?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
        "evidence": [
            "overall strength refers to overall_rating; strongest overall strength refers to MAX(overall_rating);",
            "The `overall_rating` column in `Player_Attributes` determines a player's overall strength, and the highest value indicates the strongest player.\nTo retrieve the player's name, join `Player` with `Player_Attributes` using `player_api_id`.\nThe query should focus on selecting only the player's name for clarity."
        ]
    },
    "809": {
        "reason": "To find the publisher name of the superhero with ID 38, we need to follow these steps:\n1. Identify the `publisher_id` associated with the superhero ID 38 in the `superhero` table.\n2. Use this `publisher_id` to look up the corresponding `publisher_name` in the `publisher` table.\n3. Join the `superhero` and `publisher` tables on the `publisher_id` to retrieve the desired information.",
        "sql": "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.id = 38;",
        "question": "What is the publisher name of the superhero ID 38?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.id = 38",
        "evidence": [
            "superhero ID 38 refers to superhero.id = 38;"
        ]
    },
    "1366": {
        "reason": "To list all members who attended the event \"October Meeting\", we need to follow these steps:\n1. Identify the event_id of the event named \"October Meeting\" from the `event` table.\n2. Use the `attendance` table to find all entries where `link_to_event` matches the event_id of \"October Meeting\".\n3. Retrieve the `link_to_member` values from these entries, which correspond to the member IDs of attendees.\n4. Ensure the query returns distinct member IDs to avoid duplicates.\n\nThe query will involve joining the `event` and `attendance` tables to link the event name to the member IDs.",
        "sql": "SELECT DISTINCT a.link_to_member\nFROM attendance a\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'October Meeting';",
        "question": "List all the members who attended the event \"October Meeting\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.member_id FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'October Meeting'",
        "evidence": [
            "'October Meeting' is an event name;",
            "The `attendance` table links members to events via `link_to_member` and `link_to_event` fields, requiring a join between `event`, `attendance`, and `member` tables.\nThe query should focus on retrieving distinct member IDs to avoid duplicates when listing attendees.",
            "The query should retrieve only member IDs to fulfill the requirement of listing attendees, not additional member details."
        ]
    },
    "1037": {
        "reason": "To solve the question, we need to calculate the percentage of players who prefer their left foot and were born between 1987 and 1992. The steps are as follows:\n1. Filter players born between 1987 and 1992 by extracting the year from the `birthday` field using `SUBSTR`.\n2. Count the total number of players in this birth year range.\n3. Count the number of players in this range who prefer their left foot (`preferred_foot = 'left'`).\n4. Calculate the percentage by dividing the count of left-footed players by the total count and multiplying by 100.\n5. Use `CAST` to ensure the division yields a real number for accurate percentage calculation.",
        "sql": "SELECT \n    (CAST(SUM(CASE WHEN pa.preferred_foot = 'left' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100 AS percentage_left_footed\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    SUBSTR(p.birthday, 1, 4) BETWEEN '1987' AND '1992';",
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "evidence": [
            "players who prefer left foot refers to preferred_foot = 'left'; percentage of players who prefer left foot = DIVIDE(MULTIPLY((SUM(preferred_foot = 'left'), 100)), COUNT(player_fifa_api_id)); born between 1987 and 1992 refers to YEAR(birthday) BETWEEN '1987' AND '1992';",
            "To calculate percentages, use CAST to ensure division yields a real number. Filtering by year can be done using SUBSTR for string manipulation on the birthday field."
        ]
    },
    "1175": {
        "reason": "To solve the question, we need to find the patient who had the highest hemoglobin count (HGB) at the time of their examination, determine their age at the time of the examination, and retrieve the doctor's diagnosis for that patient. Here's the step-by-step reasoning:\n\n1. **Identify the highest hemoglobin count**: We need to find the maximum value of HGB from the Laboratory table.\n2. **Find the patient with the highest HGB**: Once we have the highest HGB, we need to identify the patient (ID) associated with this value.\n3. **Calculate the patient's age at the time of examination**: Using the patient's birthday from the Patient table and the examination date from the Examination table, we can calculate the age by subtracting the year of birth from the year of the examination date.\n4. **Retrieve the doctor's diagnosis**: The diagnosis is stored in the Patient table, so we need to fetch it from there.\n5. **Combine the information**: Join the relevant tables (Patient, Laboratory, and Examination) to gather all the required data in a single query.\n\nThe query will involve:\n- Joining the Laboratory table with the Patient table to get the patient's details and diagnosis.\n- Joining the Examination table to get the examination date for age calculation.\n- Using the MAX function to find the highest HGB.\n- Calculating the age using the year difference between the examination date and the birthday.",
        "sql": "SELECT \n    (strftime('%Y', e.`Examination Date`) - strftime('%Y', p.Birthday)) AS age_at_examination,\n    p.Diagnosis\nFROM \n    Patient p\nJOIN \n    Laboratory l ON p.ID = l.ID\nJOIN \n    Examination e ON p.ID = e.ID\nWHERE \n    l.HGB = (SELECT MAX(HGB) FROM Laboratory)\nLIMIT 1;",
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "evidence": [
            "How old the patient refers to SUBTRACT(year(`Examination Date`), year(Birthday)); the highest hemoglobin count refers to MAX(HGB)",
            "The highest hemoglobin count requires ordering by HGB in descending order and limiting to the top result.\nThe diagnosis should be retrieved from the Patient table, not the Examination table.",
            "The highest hemoglobin count requires ordering by HGB in descending order and limiting to the top result.\nThe diagnosis should be retrieved from the Patient table, not the Examination table."
        ]
    },
    "1441": {
        "reason": "To solve the question, we need to find the number of members who have a major in 'education' and belong to the 'College of Education & Human Services'. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `member` table contains member details, and the `major` table contains major details. The `member` table links to the `major` table via the `link_to_major` column.\n\n2. **Filter members by position**: The question specifies that we should only consider members with the position 'Member'.\n\n3. **Filter majors by name and college**: The major name should be 'education' (case-insensitive), and the college should be 'College of Education & Human Services'.\n\n4. **Join the tables**: We need to join the `member` table with the `major` table on the `link_to_major` column to access the major details.\n\n5. **Count the members**: Finally, we count the distinct members who meet the criteria.",
        "sql": "SELECT COUNT(DISTINCT m.member_id) AS member_count\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE m.position = 'Member'\nAND LOWER(maj.major_name) LIKE '%education%'\nAND maj.college = 'College of Education & Human Services';",
        "question": "How many members have education major in the College of Education & Human Services?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member' AND T2.major_name LIKE '%Education%' AND T2.college = 'College of Education & Human Services'",
        "evidence": [
            "'education' is the major name; 'Member' is a position of club;",
            "The 'position' column in the 'member' table filters for members with a specific role.\nThe 'major_name' column in the 'major' table may contain partial matches, requiring a LIKE operator for broader filtering.",
            "The 'position' column in the 'member' table must be filtered to include only rows where the value is 'Member'.\nThe 'major_name' column in the 'major' table should use a case-insensitive LIKE operator for broader matching.",
            "The 'position' column in the 'member' table must be filtered to include only rows where the value is 'Member'.\nThe 'major_name' column in the 'major' table should use a case-insensitive LIKE operator for broader matching."
        ]
    },
    "347": {
        "reason": "To solve the question, we need to find all cards illustrated by the artist 'Stephen Daniele' and describe the text of the rulings for these cards. Additionally, we need to indicate if these cards have missing or degraded properties (which is indicated by the `hasContentWarning` column).\n\n1. **Filter cards by artist**: We will query the `cards` table to find all cards where the `artist` column is 'Stephen Daniele'.\n2. **Retrieve rulings for these cards**: We will join the `cards` table with the `rulings` table using the `uuid` column to get the rulings for each card.\n3. **Check for missing or degraded properties**: We will include the `hasContentWarning` column in the result to indicate if the card has missing or degraded properties.\n4. **Output the required information**: The result will include the card's `id`, the `text` of the ruling, and the `hasContentWarning` status.",
        "sql": "SELECT c.id, r.text AS ruling_text, c.hasContentWarning\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.artist = 'Stephen Daniele';",
        "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
        "evidence": [
            "cards have missing or degraded properties and value refers to hasContentWarning = 1; 'Stephen Daniele' is artist; Find all cards refers to return card id",
            "The `INNER JOIN` ensures only cards with rulings are included, while `LEFT JOIN` would include cards without rulings. The `hasContentWarning` column indicates missing or degraded properties."
        ]
    },
    "711": {
        "reason": "To solve the question, we need to find the total number of users aged 40 years old who have made comments with a score of 0. The steps to achieve this are:\n1. Join the `comments` table with the `users` table to link comments to their respective users.\n2. Filter the comments to only include those with a score of 0.\n3. Filter the users to only include those who are 40 years old.\n4. Count the distinct user IDs to ensure each user is only counted once, regardless of how many comments they have made.\n\nThe query will involve joining the `comments` and `users` tables, applying the necessary filters, and then counting the distinct users.",
        "sql": "SELECT COUNT(DISTINCT users.Id) AS TotalUsers\nFROM comments\nJOIN users ON comments.UserId = users.Id\nWHERE comments.Score = 0 AND users.Age = 40;",
        "question": "Among products comments with 0 score, what is the total number of users ages 40 years old?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40",
        "evidence": [
            "",
            "The `comments` table links to users via `UserId`, which references `users.Id`.\nFiltering for specific user attributes like age requires joining the `users` table.\nCounting distinct users ensures each user is only counted once, regardless of multiple comments.",
            "The `comments` table can be aliased for clarity in joins, though the query logic remains unchanged.\nCounting distinct user IDs from the `users` table ensures uniqueness, regardless of table aliases.",
            "Table aliases can simplify query readability without altering the logic.\nCounting distinct user IDs from the joined tables ensures uniqueness, regardless of aliases used."
        ]
    },
    "1303": {
        "reason": "To find the birthday of the oldest patient whose blood glucose is abnormal, we need to follow these steps:\n1. Identify patients with abnormal blood glucose levels (GLU > 180) from the Laboratory table.\n2. Among these patients, find the oldest one by checking their birthday (MIN(Birthday)).\n3. Retrieve the birthday of this oldest patient from the Patient table.\n\nWe will join the Patient and Laboratory tables to link patient information with their laboratory results, filter for abnormal glucose levels, and then find the oldest patient in this subset.",
        "sql": "SELECT MIN(P.Birthday) AS OldestPatientBirthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.GLU > 180;",
        "question": "When is the birthday of the oldest patient whose blood glucose is abnormal?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU > 180 ORDER BY T1.Birthday ASC LIMIT 1",
        "evidence": [
            "oldest patient refers to MIN(Birthday); blood glucose is abnormal refers to GLU > 180;"
        ]
    },
    "406": {
        "reason": "To solve the question, we need to list all Creature-type cards with a legal status. The steps are as follows:\n1. Identify cards with `types` exactly matching 'Creature'.\n2. Ensure these cards have a legal status in the `legalities` table, where `status` is 'legal'.\n3. Join the `cards` table with the `legalities` table using the `uuid` field to filter the results.\n4. Select the `id` field from the `cards` table to list the IDs of the qualifying cards.",
        "sql": "SELECT c.id\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.types = 'Creature' AND l.status = 'legal';",
        "question": "Lists by ID all Creature-type cards with legal status.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
        "evidence": [
            "legal status refer to status = 'legal'; Goblin-type cards refer to types = 'Creature';",
            "The `rulings` table is not required for filtering cards with legal status; the `legalities` table alone suffices.\nThe `types` field should be checked for exact match 'Creature' rather than using LIKE for substring matching.",
            "The `rulings` table is not required for filtering cards with legal status; the `legalities` table alone suffices.\nThe `types` field should be checked for exact match 'Creature' rather than using LIKE for substring matching."
        ]
    },
    "283": {
        "reason": "To solve the question, we need to identify whether chemical compounds containing Calcium (element 'ca') are carcinogenic. The steps are as follows:\n1. Join the `atom` table with the `molecule` table to link atoms to their respective molecules.\n2. Filter the atoms to only include those with the element 'ca' (Calcium).\n3. Retrieve the `label` from the `molecule` table for these molecules to determine their carcinogenic status ('+' for carcinogenic, '-' for non-carcinogenic).\n4. The query should return the `label` for all molecules containing Calcium, allowing us to see their carcinogenic status.",
        "sql": "SELECT DISTINCT m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE a.element = 'ca';",
        "question": "Identify whether the chemical compound that contains Calcium is carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'",
        "evidence": [
            "calcium refers to element = 'ca'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic;",
            "The `label` column in the `molecule` table indicates carcinogenicity with '+' or '-' values.\nTo determine carcinogenicity, the query must filter atoms by element 'ca' and join with the `molecule` table to access the `label`.\nThe result should focus on the `label` to indicate carcinogenic status.",
            "The query should return the `label` from the `molecule` table for all molecules containing Calcium, not just those marked as carcinogenic ('+').\nThe `label` column in the `molecule` table provides the carcinogenic status, and the query must include all relevant molecules to determine their status."
        ]
    },
    "617": {
        "reason": "To find the detailed content of the comment on the post created on 7/19/2010 7:37:33 PM, we need to:\n1. Identify the post created on the specified date by querying the `posts` table where `CreaionDate` matches '2010-07-19 19:37:33.0'.\n2. Join the `comments` table with the `posts` table using the `PostId` in `comments` and `Id` in `posts` to find comments related to the identified post.\n3. Retrieve the `Text` field from the `comments` table, which contains the detailed content of the comment.",
        "sql": "SELECT c.Text \nFROM comments c \nJOIN posts p ON c.PostId = p.Id \nWHERE p.CreaionDate = '2010-07-19 19:37:33.0';",
        "question": "What is the detailed content of the comment of the post which was created on 7/19/2010 7:37:33 PM?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:37:33.0'",
        "evidence": [
            "detailed content of the comment refers to Text; created on 7/19/2010 7:37:33 PM CreationDate = 2010-07-19 19:37:33.0'",
            "The detailed content of a comment is stored in the Text field of the comments table.\nThe CreationDate in the comments table determines when the comment was created, not the post.\nJoining comments and posts tables requires matching PostId in comments to Id in posts.",
            "The CreationDate in the comments table determines when the comment was created, not the post.\nFiltering comments by their own CreationDate is necessary to find comments created on a specific date.",
            "The CreationDate in the comments table determines when the comment was created, not the post.\nFiltering comments by their own CreationDate is necessary to find comments created on a specific date."
        ]
    },
    "56": {
        "reason": "To solve the question, we need to find the number of active schools with a mailing state address in California and located in San Joaquin city. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `schools` table contains the necessary information about schools, including their mailing state (`MailState`), city (`City`), and status (`StatusType`).\n\n2. **Filter conditions**:\n   - The mailing state must be 'CA' (California).\n   - The physical city must be 'San Joaquin'.\n   - The school must be active, which likely means `StatusType` is 'Active' or similar (assuming 'Active' is the value for active schools).\n\n3. **Count the schools**: We will use the `COUNT` function to count the number of schools that meet these conditions.\n\n4. **Query construction**: The query will select from the `schools` table, apply the filters, and count the results.",
        "sql": "SELECT COUNT(*) \nFROM schools \nWHERE MailState = 'CA' \nAND City = 'San Joaquin' \nAND StatusType = 'Active';",
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin city?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "evidence": [
            "",
            "The `City` column in the `schools` table refers to the physical location of the school, while `MailCity` refers to the mailing address city. For filtering by city, use the `City` column."
        ]
    },
    "624": {
        "reason": "To find the name of the user with the ID of 30, we need to query the `users` table, which contains user information including their `DisplayName`. The `Id` column in the `users` table uniquely identifies each user. We will filter the records where `Id` equals 30 and retrieve the `DisplayName`.",
        "sql": "SELECT DisplayName FROM users WHERE Id = 30;",
        "question": "What is the name of user with the ID of 30?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = 30",
        "evidence": [
            "name of user refers to DisplayName;"
        ]
    },
    "1521": {
        "reason": "To solve the question, we need to find the number of transactions that occurred between 8:00 and 9:00 on August 26, 2012, in the country 'CZE'. The steps are as follows:\n1. Filter the transactions in the `transactions_1k` table where the `Date` is '2012-08-26' and the `Time` is between '08:00:00' and '09:00:00'.\n2. Join the filtered transactions with the `gasstations` table to get the country information for each transaction.\n3. Filter the joined result to include only transactions where the `Country` is 'CZE'.\n4. Count the number of such transactions.",
        "sql": "SELECT COUNT(*) \nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-26' \nAND t.Time BETWEEN '08:00:00' AND '09:00:00'\nAND g.Country = 'CZE';",
        "question": "For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'",
        "evidence": [
            "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; '2012/8/26' can be represented by '2012-08-26'; during 8:00-9:00 can be represented as Time BETWEEN '08:00:00' AND '09:00:00'"
        ]
    },
    "288": {
        "reason": "To determine whether the molecule containing the atom TR001_1 is carcinogenic, we need to follow these steps:\n1. Identify the molecule_id associated with the atom TR001_1 from the `atom` table.\n2. Check the `label` of the molecule in the `molecule` table to see if it indicates carcinogenicity (e.g., if the label contains 'carcinogenic' or similar).\n3. The query will join the `atom` and `molecule` tables to retrieve the relevant information.",
        "sql": "SELECT m.label \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE a.atom_id = 'TR001_1';",
        "question": "Identify whether the molecule that contains atom TR001_1 is carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_1'",
        "evidence": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "109": {
        "reason": "To solve the question, we need to find the number of female clients who opened accounts in the Jesenik branch. Here's the step-by-step reasoning:\n\n1. **Identify the branch**: The branch name is stored in the `district` table under the column `A2` (region names). We need to filter for `A2 = 'Jesenik'`.\n\n2. **Link clients to the branch**: The `client` table has a `district_id` column that links directly to the `district` table. We can join these tables to find clients from the Jesenik branch.\n\n3. **Filter for female clients**: The `client` table has a `gender` column where female clients are marked as 'F'.\n\n4. **Count the clients**: We need to count the distinct `client_id` values that meet the above criteria.\n\n5. **Join with the account table**: Although the question mentions \"opened their accounts,\" the `client` table already links to the `district` table directly, so we don't need to involve the `account` table for this query.",
        "sql": "SELECT COUNT(DISTINCT c.client_id) AS female_clients_in_jesenik\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE d.A2 = 'Jesenik' AND c.gender = 'F';",
        "question": "How many clients opened their accounts in Jesenik branch were women?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'",
        "evidence": [
            "A2 has region names; Woman and female share the same meaning; female refers to gender = 'F'",
            "The client table directly links to the district table via district_id, bypassing the need for intermediate joins with account and disp tables.",
            "The client table directly links to the district table via district_id, eliminating the need for joining with the account table."
        ]
    },
    "311": {
        "reason": "To solve the question, we need to count the number of molecules that meet two conditions: they do not contain any sulphur atoms (element 's') and they do not have any double bonds (bond_type ' = '). Here's the step-by-step reasoning:\n\n1. **Identify molecules without sulphur atoms**: We need to exclude molecules where any atom has the element 's'. This can be done by checking the `atom` table.\n2. **Identify molecules without double bonds**: We need to exclude molecules where any bond has the bond_type ' = '. This can be done by checking the `bond` table.\n3. **Combine the conditions**: We need to find molecules that satisfy both conditions. This requires joining the `molecule` table with the `atom` and `bond` tables, ensuring that the molecule does not appear in the filtered results for sulphur atoms or double bonds.\n4. **Count the molecules**: Finally, count the distinct molecules that meet both criteria.\n\nThe query will involve:\n- A LEFT JOIN between `molecule` and `atom` to check for sulphur atoms.\n- A LEFT JOIN between `molecule` and `bond` to check for double bonds.\n- Filtering out molecules that have sulphur atoms or double bonds.\n- Counting the remaining molecules.",
        "sql": "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m\nLEFT JOIN atom a ON m.molecule_id = a.molecule_id AND a.element = 's'\nLEFT JOIN bond b ON m.molecule_id = b.molecule_id AND b.bond_type = ' = '\nWHERE a.atom_id IS NULL AND b.bond_id IS NULL;",
        "question": "How many molecules without sulphur element is not having double bond?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element <> 's' AND T2.bond_type <> '='",
        "evidence": [
            "double bond refers to bond_type = ' = '; bond_type ! = ' = '; sulphur refers to element = 's'",
            "To count molecules without sulphur and without double bonds, join the `atom` and `bond` tables on `molecule_id` to ensure both conditions are checked for the same molecule.",
            "To count molecules without sulphur and without double bonds, ensure the join between `atom` and `bond` tables is an INNER JOIN to only include molecules present in both tables.\nFilter conditions should directly exclude sulphur atoms and double bonds using inequality operators.",
            "To count molecules without sulphur and without double bonds, use an INNER JOIN between the `atom` and `bond` tables on `molecule_id` to ensure both conditions are checked for the same molecule.\nFilter conditions should directly exclude sulphur atoms and double bonds using inequality operators."
        ]
    },
    "1171": {
        "reason": "To determine the number of underage patients examined between 1990 and 1993, we need to:\n1. Identify patients who were underage (i.e., their age was less than 18 years) during the examination period.\n2. Calculate their age by comparing their birthday with the examination date.\n3. Filter the examinations that occurred between 1990 and 1993.\n4. Count the distinct patients who meet these criteria.\n\nWe will join the `Patient` and `Examination` tables to get the necessary information.",
        "sql": "SELECT COUNT(DISTINCT P.ID) AS UnderagePatientsExamined\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE E.`Examination Date` BETWEEN '1990-01-01' AND '1993-12-31'\nAND (strftime('%Y', E.`Examination Date`) - strftime('%Y', P.Birthday) - \n    (strftime('%m-%d', E.`Examination Date`) < strftime('%m-%d', P.Birthday))) < 18;",
        "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.Birthday) < 18",
        "evidence": [
            "underage patients refers to year(Birthday) < 18; three-year period from 1990 to 1993 refers to year(`Examination Date`) between '1990' and '1993'"
        ]
    },
    "738": {
        "reason": "To solve the question, we need to find superheroes with a durability attribute value of less than 50. The steps are as follows:\n1. Identify the attribute_id for 'Durability' from the attribute table.\n2. Join the superhero table with the hero_attribute table to filter superheroes based on the identified attribute_id and attribute_value < 50.\n3. Retrieve the superhero names from the filtered results.",
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Durability' AND ha.attribute_value < 50;",
        "question": "Which superheroes have a durability attribute value of less than 50?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "evidence": [
            "durability of less than 50 refers to attribute_name = 'Durability' AND attribute_value < 50"
        ]
    },
    "967": {
        "reason": "To solve the question, we need to find the top 3 youngest drivers and then determine how many of them are from the Netherlands (Netherlandic/Dutch). The steps are as follows:\n1. Identify the youngest drivers by sorting the `drivers` table by the `dob` (date of birth) in descending order (youngest first).\n2. Limit the results to the top 3.\n3. Check the nationality of these drivers to see if they are 'Dutch' or 'Netherlandic'.\n4. Count the number of drivers with this nationality among the top 3 youngest.",
        "sql": "WITH youngest_drivers AS (\n    SELECT code, nationality\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 3\n)\nSELECT \n    COUNT(*) AS netherlandic_drivers_count\nFROM youngest_drivers\nWHERE nationality IN ('Dutch', 'Netherlandic');",
        "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
        "evidence": [
            "youngest driver refers to Max (year(dob)); Netherlandic and Dutch refer to the same country"
        ]
    },
    "851": {
        "reason": "The question asks for the positions of circuits built by the constructor Renault. However, based on the schema and the provided tips, circuits are locations where races occur and are not directly built by constructors. Constructor standings track the performance of constructors in races, not circuits. Therefore, the question seems to be based on a misunderstanding. Circuits are not built by constructors, and their positions are not tracked in the database. Instead, constructors participate in races, and their standings are recorded in the constructorStandings table. To answer the question accurately, we need to clarify that circuits are not built by constructors and that the data does not support the query as phrased.",
        "sql": "-- The question is based on a misunderstanding. Circuits are not built by constructors, and their positions are not tracked in the database.\n-- Therefore, no valid SQL query can be generated for this question as phrased.",
        "question": "Please list the positions of the circuits built by the constructor Renault.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.position FROM constructorStandings AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T2.name = 'Renault'",
        "evidence": [
            "Renault is a name of constructor;",
            "Constructor standings track the positions of constructors in races, not circuits. Circuits are locations where races occur, not directly built by constructors.",
            "Constructor standings track the performance of constructors in races, not circuits. The position attribute in constructorStandings reflects the constructor's race performance.",
            "Constructor standings track the race performance of constructors, not circuits. The position attribute in constructorStandings reflects the constructor's performance in races."
        ]
    },
    "68": {
        "reason": "To solve the question, we need to identify the county with the most school closures in the 1980s where the school ownership code (SOC) is 11 (Youth Authority Facilities). The steps are as follows:\n1. Filter the `schools` table for schools that are closed (`StatusType = 'Closed'`).\n2. Further filter these schools to only include those closed in the 1980s (years between 1980 and 1989) using the `ClosedDate` column.\n3. Filter for schools with `SOC = 11` (Youth Authority Facilities).\n4. Group the results by `County` and count the number of schools in each county.\n5. Order the results by the count in descending order to find the county with the most closures.\n6. Limit the result to the top county.",
        "sql": "SELECT County, COUNT(*) AS NumberOfClosures\nFROM schools\nWHERE StatusType = 'Closed'\n  AND strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989'\n  AND SOC = '11'\nGROUP BY County\nORDER BY NumberOfClosures DESC\nLIMIT 1;",
        "question": "Which county reported the most number of school closure in the 1980s with school wonership code belonging to Youth Authority Facilities (CEA)?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT County FROM schools WHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND StatusType = 'Closed' AND SOC = 11 GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1",
        "evidence": [
            "Youth Authority Facilities (CEA) refers to SOC = 11; 1980s = years between 1980 and 1989",
            "The `StatusType` column in the `schools` table indicates whether a school is open or closed, and filtering for 'Closed' ensures only closed schools are considered.\nThe `strftime` function is used to extract the year from `ClosedDate` for accurate decade filtering.",
            "The `SOC` column in the `schools` table is stored as TEXT, but comparisons should use the numeric value 11 without quotes for consistency with the schema.\nGrouping by `County` and ordering by the count of `School` entries ensures accurate aggregation of school closures.",
            "The `SOC` column should be compared numerically (11) without quotes, as it is stored as TEXT but represents a numeric value.\nGrouping by `County` and ordering by the count of `School` entries ensures accurate aggregation of school closures."
        ]
    },
    "667": {
        "reason": "To find the title of the post with the oldest post link, we need to follow these steps:\n1. Identify the oldest post link by finding the post with the earliest `CreaionDate` in the `posts` table.\n2. Join the `postLinks` table with the `posts` table using the `PostId` to link them.\n3. Retrieve the title of the post from the `posts` table.\n4. Order the results by `CreaionDate` in ascending order to ensure the oldest post is selected.\n5. Limit the result to 1 to get only the oldest post link.\n\nThe query will join `postLinks` and `posts` on `PostId`, order by `CreaionDate`, and limit to 1 to get the title of the oldest post link.",
        "sql": "SELECT p.Title \nFROM postLinks pl \nJOIN posts p ON pl.PostId = p.Id \nORDER BY p.CreaionDate ASC \nLIMIT 1;",
        "question": "What is the title of the post with the oldest post link?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY T1.CreaionDate LIMIT 1",
        "evidence": [
            "the oldest post link refers to MIN(CreaionDate);",
            "the oldest post link refers to the post with the earliest `CreaionDate` in the `posts` table, not the `CreationDate` in `postLinks`.\njoin direction should link `postLinks` to `posts` via `PostId` to retrieve the post title.\nordering by `CreaionDate` and limiting to 1 ensures the oldest post is selected.",
            "The oldest post link is determined by the earliest `CreaionDate` in the `posts` table, not the `CreationDate` in `postLinks`.\nThe join should prioritize retrieving the post title from the `posts` table linked via `PostId`.\nOrdering by `CreaionDate` in `posts` ensures the oldest post is selected."
        ]
    },
    "482": {
        "reason": "To find the German type of the card \"Ancestor's Chosen\", we need to:\n1. Identify the card in the `cards` table using its name (`name = 'Ancestor''s Chosen'`).\n2. Join the `cards` table with the `foreign_data` table using the `uuid` field to get the translated attributes.\n3. Filter the results in the `foreign_data` table to only include entries where the `language` is 'German'.\n4. Retrieve the `type` field from the `foreign_data` table, which contains the German translation of the card's type.\n5. Use `DISTINCT` to ensure we get a unique result in case there are multiple entries for the same card and language.",
        "sql": "SELECT DISTINCT fd.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.name = 'Ancestor''s Chosen' AND fd.language = 'German';",
        "question": "What's the German type of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German'",
        "evidence": [
            "German refers to language = 'German'; \"Ancestor's Chosen\" refers to name = 'Ancestor''s Chosen'",
            "The `foreign_data` table contains translations for card attributes, including type, and must be joined with the `cards` table using the `uuid` field.\nThe `DISTINCT` keyword ensures unique results when multiple entries might exist for the same card and language.",
            "The `DISTINCT` keyword is necessary to avoid duplicate results when multiple entries exist for the same card and language in the `foreign_data` table.",
            "The `foreign_data` table stores translated attributes like type, linked to cards via the `uuid` field.\nTable aliases (e.g., T1, T2) can clarify joins without altering query logic.\nFiltering by `language` in `foreign_data` ensures the correct translation is retrieved."
        ]
    },
    "648": {
        "reason": "To solve the question, we need to find users' display names and their website URLs for posts that have a favorite count of more than 150. The steps are as follows:\n1. Identify the relevant tables: `posts` (for favorite count) and `users` (for display names and website URLs).\n2. Join the `posts` table with the `users` table using the `OwnerUserId` in `posts` and `Id` in `users`.\n3. Filter the posts where the `FavoriteCount` is greater than 150.\n4. Select the `DisplayName` and `WebsiteUrl` from the `users` table.",
        "sql": "SELECT u.DisplayName, u.WebsiteUrl \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE p.FavoriteCount > 150;",
        "question": "Provide the users' display names and available website URLs of the post with favorite count of more than 150.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName, T1.WebsiteUrl FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.FavoriteCount > 150",
        "evidence": [
            "favorite count of more than 150 refers to FavoriteCount > 150;"
        ]
    },
    "1401": {
        "reason": "To find the cost of posters for the 'September Speaker' event, we need to follow these steps:\n1. Identify the event_id of the 'September Speaker' event from the `event` table.\n2. Use this event_id to find the corresponding budget_id in the `budget` table where the category is likely 'posters'.\n3. Alternatively, if the category is not specified, we might need to look for expenses related to the event where the description includes 'posters'.\n4. Retrieve the cost from the `expense` table for the identified budget_id or expense_id.\n\nGiven the schema, the most direct approach is to join the `event`, `budget`, and `expense` tables to filter for the 'September Speaker' event and the 'posters' category or description.",
        "sql": "SELECT e.cost\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'September Speaker' AND (b.category = 'posters' OR e.expense_description LIKE '%posters%');",
        "question": "Indicate the cost of posters for 'September Speaker' event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Posters'",
        "evidence": [
            "'Posters' is the expense description; 'September Speaker' is an event name"
        ]
    },
    "1179": {
        "reason": "To solve the question, we need to follow these steps:\n1. Identify the patient diagnosed with SLE on 1994-02-19 by filtering the `Patient` table where `Diagnosis` is 'SLE' and `Description` is '1994-02-19'.\n2. Retrieve the patient's ID from the filtered result.\n3. Join the `Examination` table with the patient's ID to find the examination record on 1993-11-12.\n4. From the examination record, extract the anti-Cardiolipin antibody concentrations (`aCL IgA`, `aCL IgG`, and `aCL IgM`).",
        "sql": "SELECT e.\"aCL IgA\", e.\"aCL IgG\", e.\"aCL IgM\"\nFROM Examination e\nJOIN Patient p ON e.ID = p.ID\nWHERE p.Diagnosis = 'SLE' AND p.Description = '1994-02-19' AND e.\"Examination Date\" = '1993-11-12';",
        "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` FROM Examination WHERE ID IN ( SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19' ) AND `Examination Date` = '1993-11-12'",
        "evidence": [
            "diagnosed with SLE refers to Diagnosis = 'SLE'; 1994/2/19 refers to Description = '1994-02-19'; anti-Cardiolipin refers to aCL IgM; 1993/11/12 refers to Examination Date = '1993/11/12'",
            "anti-Cardiolipin antibody status includes multiple columns: aCL IgA, aCL IgG, and aCL IgM.\nThe query should retrieve all anti-Cardiolipin antibody columns, not just aCL IgM.\nPatient diagnosis and description are used to filter the correct patient ID before joining with Examination."
        ]
    },
    "124": {
        "reason": "To solve the question, we need to list the loan ID, district, and average salary for loans with a duration of 60 months. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `loan` table contains loan details including `loan_id`, `account_id`, and `duration`. The `account` table links to the `district` table via `district_id`, which contains district information. The `district` table includes the average salary (likely represented by one of its columns, such as `A11` or another relevant column).\n\n2. **Filter loans with a duration of 60 months**: We need to filter the `loan` table where `duration = 60`.\n\n3. **Join the tables**:\n   - Join `loan` with `account` on `account_id`.\n   - Join `account` with `district` on `district_id`.\n\n4. **Select the required columns**:\n   - `loan.loan_id` for the loan ID.\n   - `district.A2` (assuming `A2` represents the district name).\n   - `district.A11` (assuming `A11` represents the average salary).\n\n5. **Final query**: Combine the above steps into a SQL query.",
        "sql": "SELECT l.loan_id, d.A2 AS district, d.A11 AS average_salary\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.duration = 60;",
        "question": "List the loan ID, district and average salary for loan with duration of 60 months.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.loan_id, T2.A2, T2.A11 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.duration = 60",
        "evidence": [
            "A3 refers to regions; A11 refers to average salary"
        ]
    },
    "1279": {
        "reason": "To solve the question, we need to calculate the percentage of patients with abnormal GOT levels (GOT >= 60) who are also diagnosed with SLE. The steps are as follows:\n1. Identify all patients with abnormal GOT levels (GOT >= 60) from the Laboratory table.\n2. Among these patients, count those whose Diagnosis in the Patient table includes 'SLE' (using LIKE '%SLE%' for partial matches).\n3. Calculate the percentage by dividing the count from step 2 by the total count from step 1 and multiplying by 100.\n4. Ensure the query handles cases where the denominator (total abnormal GOT patients) is zero to avoid division by zero errors.",
        "sql": "SELECT \n    CASE \n        WHEN COUNT(DISTINCT l.ID) = 0 THEN 0\n        ELSE (COUNT(DISTINCT CASE WHEN p.Diagnosis LIKE '%SLE%' THEN l.ID END) * 100.0 / COUNT(DISTINCT l.ID))\n    END AS percentage\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.GOT >= 60;",
        "question": "What is the percentage of patient who has a abnormal level of glutamic oxaloacetic transaminase level, yet he or she is diagnosed with SLE?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`GOT` >= 60",
        "evidence": [
            "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; percentage = MULTIPLY(DIVIDE(COUNT(ID WHERE GOT > = 60 AND Diagnosis = 'SLE'), COUNT(ID WHERE GOT > = 60)), 1.0);",
            "abnormal GOT levels are identified in the Laboratory table, while SLE diagnosis is recorded in the Patient table.\npercentage calculations should use the total count of patients with abnormal GOT levels as the denominator.\nSLE diagnosis in the Patient table may include partial matches (LIKE '%SLE%').",
            "abnormal GOT levels are filtered in the Laboratory table, while SLE diagnosis is checked in the Patient table.\npercentage calculations should use the total count of patients with abnormal GOT levels as the denominator.\nSLE diagnosis in the Patient table may include partial matches (LIKE '%SLE%').",
            "abnormal GOT levels are filtered in the Laboratory table, while SLE diagnosis is checked in the Patient table.\npercentage calculations should use the total count of patients with abnormal GOT levels as the denominator.\nSLE diagnosis in the Patient table may include partial matches (LIKE '%SLE%')."
        ]
    },
    "1142": {
        "reason": "To solve the question, we need to determine the number of games played in the Italian Serie A league during the 2015\u20132016 season. The steps are as follows:\n1. Identify the `league_id` for the Italian Serie A league from the `League` table.\n2. Use the `Match` table to count the number of games where the `league_id` matches the identified `league_id` and the `season` is '2015/2016'.",
        "sql": "SELECT COUNT(*) AS total_games\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Italy Serie A')\nAND season = '2015/2016';",
        "question": "In the 2015\u20132016 season, how many games were played in the Italian Serie A league?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Italy Serie A' AND t2.season = '2015/2016'",
        "evidence": [
            "In the 2015\u20132016 season refers to season = '2015/2016'"
        ]
    },
    "810": {
        "reason": "To find the race of the superhero with the maximum attribute value, we need to follow these steps:\n1. Identify the superhero with the highest attribute value from the `hero_attribute` table.\n2. Retrieve the `race_id` of this superhero from the `superhero` table.\n3. Map the `race_id` to the corresponding race name in the `race` table.\n4. Combine these steps into a single query to get the desired result.",
        "sql": "SELECT r.race\nFROM race r\nJOIN superhero s ON r.id = s.race_id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nWHERE ha.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute)\nLIMIT 1;",
        "question": "What is the race of the superhero with maximum attribute value?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN race AS T3 ON T1.race_id = T3.id ORDER BY T2.attribute_value DESC LIMIT 1",
        "evidence": [
            "maximum attribute value refers to MAX(attribute_value);"
        ]
    },
    "921": {
        "reason": "To retrieve more information about the Formula 1 races that used the Silverstone Circuit, we need to follow these steps:\n1. Identify the Silverstone Circuit in the `circuits` table using its name.\n2. Join the `circuits` table with the `races` table to get all races held at the Silverstone Circuit.\n3. The `races` table contains details like the year, round, date, and name of the race.\n4. The `url` field in the `circuits` table provides additional information about the circuit.\n5. We will select relevant columns from both tables to provide comprehensive information about the races at Silverstone Circuit.",
        "sql": "SELECT c.name AS circuit_name, c.url AS circuit_info, r.year, r.round, r.name AS race_name, r.date, r.url AS race_info\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nWHERE c.name = 'Silverstone Circuit';",
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "evidence": [
            "more information refers to url",
            "The 'url' field in the circuits table provides additional information about the circuit, including Silverstone Circuit.",
            "The 'url' field in the circuits table links to detailed information about the circuit, while the races table contains race-specific details.",
            "The 'url' field in the circuits table uniquely identifies each circuit and provides a direct link to detailed information about it.\nTo retrieve specific URLs, the query must focus on the circuits table and join with races to filter by circuit name.\nDISTINCT ensures no duplicate URLs are returned for the same circuit."
        ]
    },
    "970": {
        "reason": "To solve the question, we need to identify the top 3 German drivers born between 1980 and 1990 who have the earliest lap time. Here's the step-by-step reasoning:\n\n1. **Filter German Drivers**: We first filter the `drivers` table to include only those drivers with `nationality` as 'German' and whose `dob` (date of birth) falls between 1980 and 1990. This can be done using the `STRFTIME` function to extract the year from `dob`.\n\n2. **Join with PitStops**: Next, we join the filtered drivers with the `pitStops` table to get their lap times. The `pitStops` table contains the `time` column, which represents the lap time.\n\n3. **Order by Lap Time**: We order the results by the `time` column in ascending order to find the earliest lap times.\n\n4. **Limit Results**: Finally, we limit the results to the top 3 drivers with the earliest lap times.\n\nThe query will involve joining the `drivers` and `pitStops` tables, filtering for the specified conditions, ordering by lap time, and limiting the output.",
        "sql": "SELECT d.driverId, d.forename, d.surname, d.dob, d.nationality, p.time AS earliest_lap_time\nFROM drivers d\nJOIN pitStops p ON d.driverId = p.driverId\nWHERE d.nationality = 'German' AND STRFTIME('%Y', d.dob) BETWEEN '1980' AND '1990'\nORDER BY p.time ASC\nLIMIT 3;",
        "question": "List out top 3 German drivers who were born from 1980-1990 and have the earliest lap time.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990' ORDER BY T1.time LIMIT 3",
        "evidence": [
            "born from 1980-1990 refers to year(dob) between 1980 and 1990; earliest lap time refers to Min(time);",
            "pitStops table contains the earliest pit stop times, which can be used to determine the earliest lap time for drivers.\nGerman drivers can be filtered by nationality and birth year in the drivers table.\nThe earliest lap time is derived from the pitStops table's time column.",
            "The earliest lap time is determined by ordering the pitStops.time column directly, not by aggregating with MIN(time).\nGerman nationality and birth year filtering should use STRFTIME for year extraction from dob.",
            "The earliest lap time is determined by ordering the pitStops.time column directly, not by aggregating with MIN(time).\nGerman nationality and birth year filtering should use STRFTIME for year extraction from dob."
        ]
    },
    "281": {
        "reason": "To solve the question, we need to identify the elements of the 4th atom in each carcinogenic molecule (where the molecule's label is '+'). The 4th atom is identified by checking if the last character of the `atom_id` is '4' when the length of `atom_id` is 7. The steps are as follows:\n1. Filter molecules with `label = '+'` to find carcinogenic molecules.\n2. Join the `molecule` table with the `atom` table to get atoms belonging to these molecules.\n3. Filter atoms where the last character of `atom_id` is '4' (assuming the length is 7).\n4. Select the distinct elements of these atoms to tally the toxicology elements.",
        "sql": "SELECT DISTINCT a.element\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+' AND substr(a.atom_id, -1) = '4' AND length(a.atom_id) = 7;",
        "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
        "evidence": [
            "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; ",
            "The 4th atom is identified by checking the last character of `atom_id` when its length is 7, not by a fixed substring position.\nDistinct elements are required, not a count of occurrences."
        ]
    },
    "1143": {
        "reason": "To find the highest score of the home team in the Netherlands Eredivisie league, we need to:\n1. Identify the league_id for the Netherlands Eredivisie from the `League` table.\n2. Filter matches in the `Match` table where the league_id matches the identified league_id.\n3. Select the maximum value of the `home_team_goal` column from these filtered matches.",
        "sql": "SELECT MAX(home_team_goal) AS highest_home_score\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Netherlands Eredivisie');",
        "question": "What was the highest score of the home team in the Netherlands Eredivisie league?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT MAX(t2.home_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Netherlands Eredivisie'",
        "evidence": [
            "highest score of the home team refers to MAX(home_team_goal)"
        ]
    },
    "81": {
        "reason": "To solve the question, we need to find the school in California with the lowest latitude coordinates. The steps are as follows:\n1. Join the `schools` table with the `frpm` table using the `CDSCode` to access both location data (latitude) and school details (name, low grade).\n2. Filter the results to include only schools in California (state = 'CA').\n3. Order the results by latitude in ascending order to find the school with the lowest latitude.\n4. Select the city, school name, and low grade from the results.",
        "sql": "SELECT s.City, f.`School Name`, f.`Low Grade`\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.State = 'CA'\nORDER BY s.Latitude ASC\nLIMIT 1;",
        "question": "In which city can you find the school in the state of California with the lowest latitude coordinates and what is its lowest grade? Indicate the school name.",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T2.City, T1.`Low Grade`, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.State = 'CA' ORDER BY T2.Latitude ASC LIMIT 1",
        "evidence": [
            "State of California refers to state = 'CA'",
            "The `Low Grade` and `School Name` attributes are sourced from the `frpm` table, not the `schools` table.\nJoining `frpm` to `schools` ensures access to both location data and school details.\nThe query must order by latitude to find the lowest value.",
            "The `Low Grade` and `School Name` attributes are sourced from the `frpm` table, not the `schools` table.\nJoining `frpm` to `schools` ensures access to both location data and school details.\nThe query must order by latitude to find the lowest value."
        ]
    },
    "1501": {
        "reason": "To solve the question, we need to find the countries of gas stations where transactions occurred in June 2013. The steps are as follows:\n1. Identify transactions in June 2013 by joining the `transactions_1k` table with the `yearmonth` table on `CustomerID` and filtering for the date '201306' (June 2013).\n2. Join the resulting transactions with the `gasstations` table on `GasStationID` to get the country information for each gas station involved in those transactions.\n3. Select the distinct countries from the gas stations to avoid duplicates.",
        "sql": "SELECT DISTINCT g.Country\nFROM transactions_1k t\nJOIN yearmonth y ON t.CustomerID = y.CustomerID\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE y.Date = '201306';",
        "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Date = '201306'",
        "evidence": [
            "June 2013 refers to '201306'; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month;",
            "The `yearmonth` table links `CustomerID` and `Date` to track consumption, which can be used to filter transactions by date.\nTransactions in `transactions_1k` can be filtered by joining with `yearmonth` on `CustomerID` and matching the `Date` field.\nThe `gasstations` table provides the `Country` information for gas stations involved in transactions."
        ]
    },
    "233": {
        "reason": "To solve the question, we need to find the top two bonds associated with the molecule TR006, ordered alphabetically by bond_id. The steps are as follows:\n1. Identify the bonds linked to the molecule TR006 by joining the `bond` table with the `connected` table, as the `connected` table links bonds to atoms and indirectly to molecules.\n2. Filter the bonds to only include those where the `molecule_id` is TR006.\n3. Select distinct bond IDs to avoid duplicates from multiple atom connections.\n4. Order the results alphabetically by bond_id.\n5. Limit the output to the top two bonds.",
        "sql": "SELECT DISTINCT b.bond_id\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.molecule_id = 'TR006'\nORDER BY b.bond_id\nLIMIT 2;",
        "question": "Please list top two bonds that happened with the molecule TR006 in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.molecule_id = 'TR006' ORDER BY T2.bond_id LIMIT 2",
        "evidence": [
            "TR006 is the molecule id",
            "The `connected` table links atoms and bonds, requiring joins to retrieve bond details for a molecule.\nDistinct bond IDs are needed to avoid duplicates when multiple atoms share the same bond.\nAlphabetical ordering applies to bond IDs, not bond types, in the correct output.",
            "The `connected` table is the primary source for bond information, requiring joins with the `atom` table to filter bonds by molecule.\nDistinct bond IDs must be selected to avoid duplicates from multiple atom connections.\nAlphabetical ordering is applied to bond IDs directly from the `connected` table."
        ]
    },
    "1354": {
        "reason": "To find the major name for the Vice President of the club, we need to follow these steps:\n1. Identify the member who holds the position of 'Vice President' in the `member` table.\n2. Retrieve the `link_to_major` for this member, which references the `major_id` in the `major` table.\n3. Join the `member` table with the `major` table using the `link_to_major` and `major_id` fields to get the `major_name` for the Vice President.",
        "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'Vice President';",
        "question": "State the major name for the Vice President of the club.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Vice President'",
        "evidence": [
            "'Vice President' is a position of Student Club"
        ]
    },
    "1523": {
        "reason": "To determine the country of the card owner with CardID 667467, we need to follow these steps:\n1. Identify the CustomerID associated with the CardID 667467 from the transactions_1k table.\n2. Use the identified CustomerID to find the corresponding GasStationID from the transactions_1k table.\n3. Use the GasStationID to find the country in the gasstations table.\n\nThis involves joining the transactions_1k table with the gasstations table to get the country information.",
        "sql": "SELECT g.Country \nFROM transactions_1k t \nJOIN gasstations g ON t.GasStationID = g.GasStationID \nWHERE t.CardID = 667467;",
        "question": "Which country was the card owner of No.667467 in?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.CardID = '667467'",
        "evidence": [
            ""
        ]
    },
    "1264": {
        "reason": "To solve the question, we need to identify patients who have blood clots in veins (indicated by the Diagnosis column in the Patient table as 'APS') and then check if they have a normal level of complement 4 (C4 > 10 in the Laboratory table). The steps are as follows:\n1. Join the Patient and Laboratory tables to link patient IDs with their laboratory results.\n2. Filter patients where the Diagnosis is 'APS' (indicating blood clots in veins).\n3. Further filter these patients to include only those with C4 levels greater than 10.\n4. Count the distinct patient IDs to ensure each patient is only counted once, regardless of how many lab results they have.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'APS' AND L.C4 > 10;",
        "question": "Among the patients have blood clots in veins, how many of them have a normal level of complement 4?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C4 > 10 AND T1.Diagnosis = 'APS'",
        "evidence": [
            "APS will result in Blood Clots in veins; normal level of complement 4 refers to C4 > 10; Should compute the number of different ones",
            "The Diagnosis column in the Patient table indicates conditions like APS, which is linked to blood clots in veins.\nThe Laboratory table contains C4 levels, and normal levels are defined as C4 > 10.\nThe Examination table is not required for this query as the relevant condition (APS) is directly available in the Patient table.",
            "The Diagnosis column in the Patient table uses exact matching for conditions like APS, not pattern matching with LIKE.\nThe query should ensure distinct patient counts by joining and filtering on exact conditions."
        ]
    },
    "1384": {
        "reason": "To find out how much income was generated by Grant Gilmour, we need to:\n1. Identify the member_id of Grant Gilmour from the member table using his first and last name.\n2. Use this member_id to query the income table and sum the amount of income records linked to him.",
        "sql": "SELECT SUM(amount) AS total_income FROM income WHERE link_to_member = (SELECT member_id FROM member WHERE first_name = 'Grant' AND last_name = 'Gilmour');",
        "question": "How many income generated by Grant Gilmour?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'",
        "evidence": [
            "income generated refers to income.amount"
        ]
    },
    "1028": {
        "reason": "To solve the question, we need to identify the away team that won the most matches in the Scotland Premier League during the 2010 season. The steps are as follows:\n1. Filter matches from the `Match` table where the `league_id` corresponds to the 'Scotland Premier League' (using the `League` table to find the correct `league_id`).\n2. Further filter these matches to only include those from the 2010 season (season = '2009/2010').\n3. Identify matches where the away team won (i.e., `away_team_goal` > `home_team_goal`).\n4. Group these matches by the `away_team_api_id` and count the number of wins for each away team.\n5. Join the result with the `Team` table to get the team's long name.\n6. Order the results by the count of wins in descending order and limit to the top result to find the team with the most wins.",
        "sql": "SELECT t.team_long_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nWHERE l.name = 'Scotland Premier League'\n  AND m.season = '2009/2010'\n  AND m.away_team_goal > m.home_team_goal\nGROUP BY m.away_team_api_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "evidence": [
            "Final result should return the Team.team_long_name; Scotland Premier League refers to League.name = 'Scotland Premier League'; away team refers to away_team_api_id; away team that won the most refers to MAX(SUBTRACT(away_team_goal, home_team_goal) > 0); 2010 season refers to season = '2009/2010'; won the most refers to MAX(COUNT(*));"
        ]
    },
    "1419": {
        "reason": "To find the category of the event that took place on 2020-03-24T12:00:00, we need to follow these steps:\n1. Identify the event with the event_date '2020-03-24T12:00:00' in the `event` table.\n2. Join the `event` table with the `budget` table using the `event_id` from the `event` table and the `link_to_event` from the `budget` table.\n3. Retrieve the `category` column from the `budget` table for the matched event.\n\nThe query will filter the `event` table for the specific date and then join it with the `budget` table to get the category.",
        "sql": "SELECT b.category FROM event e JOIN budget b ON e.event_id = b.link_to_event WHERE e.event_date = '2020-03-24T12:00:00';",
        "question": "What is the category of event which was taken place in 2020-03-24T12:00:00?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_date = '2020-03-24T12:00:00'",
        "evidence": [
            "taken place in 2020-03-24T12:00:00 refers to event_date = '2020-03-24T12:00:00'",
            "The category of an event is stored in the `category` column of the `budget` table, not the `type` column of the `event` table.\nTo retrieve the category, a join between the `event` and `budget` tables is required using `event_id` and `link_to_event` as the linking columns."
        ]
    },
    "1530": {
        "reason": "To determine the top five best-selling products, we need to analyze the `transactions_1k` table, which contains transaction details including the `ProductID` and `Amount` (quantity per transaction). The `Amount` column should be used for ordering to reflect individual transaction volumes. We will join the `transactions_1k` table with the `products` table to retrieve the full product names. The query will order the results by the `Amount` column in descending order and limit the output to the top five products.",
        "sql": "SELECT p.Description AS ProductName, t.Amount\nFROM transactions_1k t\nJOIN products p ON t.ProductID = p.ProductID\nORDER BY t.Amount DESC\nLIMIT 5;",
        "question": "Which are the top five best selling products? Please state the full name of them.",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.Amount DESC LIMIT 5",
        "evidence": [
            "Description of products contains full name",
            "To determine the best-selling products, the `Amount` column in `transactions_1k` should be used for ordering, not summing, to reflect individual transaction volumes.",
            "The `Amount` column in `transactions_1k` represents the quantity per transaction, and ordering by it directly reflects individual transaction volumes without aggregation.\nTo retrieve the full name of products, join the `transactions_1k` table with the `products` table using the `ProductID` column.",
            "The `Amount` column in `transactions_1k` should be used for ordering to reflect individual transaction volumes, not summing, to identify the best-selling products.\nTo retrieve the full name of products, join the `transactions_1k` table with the `products` table using the `ProductID` column."
        ]
    },
    "1429": {
        "reason": "To solve the question, we need to find the name of a social event attended by the vice president of the Student_Club located at 900 E. Washington St. Here's the step-by-step reasoning:\n\n1. **Identify the vice president**: We need to find the member whose `position` is 'Vice President'.\n2. **Locate the member's attendance**: Using the `attendance` table, find the events (`link_to_event`) attended by this vice president.\n3. **Filter social events**: From the `event` table, filter events where `type` is 'Social' and match the event IDs from the attendance records.\n4. **Check location**: Ensure the event's `location` is '900 E. Washington St.'.\n5. **Retrieve the event name**: Finally, select the `event_name` of the matching event.\n\nThe query will join the `member`, `attendance`, and `event` tables to achieve this.",
        "sql": "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nWHERE m.position = 'Vice President'\nAND e.type = 'Social'\nAND e.location = '900 E. Washington St.';",
        "question": "What is the name of the social event that was attended by the vice president of the Student_Club located at 900 E. Washington St.?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T3.position = 'Vice President' AND T2.location = '900 E. Washington St.' AND T2.type = 'Social'",
        "evidence": [
            "name of social event refers to event_name where type = 'Social'; 'Vice President' is position; located at refers to location"
        ]
    },
    "631": {
        "reason": "To count the number of posts created by Daniel Vassallo, we need to identify the user's ID from the `users` table where the `DisplayName` is 'Daniel Vassallo'. Once we have the user's ID, we can join the `postHistory` table to count the number of posts where the `UserId` matches the identified user ID and the `PostHistoryTypeId` indicates a post creation activity. The `postHistory` table is the primary source for tracking post creation activities.",
        "sql": "SELECT COUNT(*) AS post_count\nFROM postHistory ph\nJOIN users u ON ph.UserId = u.Id\nWHERE u.DisplayName = 'Daniel Vassallo' AND ph.PostHistoryTypeId = (SELECT Id FROM PostHistoryTypes WHERE Name = 'Post Creation');",
        "question": "How many posts were created by Daniel Vassallo?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "evidence": [
            "DisplayName = 'Daniel Vassallo';",
            "The `postHistory` table records user activities on posts, including creation, which may be relevant for counting posts.\nTo count posts created by a user, consider both the `posts` and `postHistory` tables for comprehensive results.",
            "The `postHistory` table tracks user activities, including post creation, and can be joined with the `users` table to count posts by a specific user.\nTo count posts created by a user, focus on the `postHistory` table where the `UserId` matches the user's ID from the `users` table.",
            "The `postHistory` table records post creation activities, which can be directly linked to users via the `UserId` field.\nTo count posts created by a user, focus on the `postHistory` table joined with the `users` table where the `DisplayName` matches."
        ]
    },
    "241": {
        "reason": "To determine how many molecules are not carcinogenic, we need to count the number of molecules where the `label` is '-'. This is indicated in the tips provided. The query will involve selecting from the `molecule` table and counting the rows where `label = '-'`.",
        "sql": "SELECT COUNT(*) FROM molecule WHERE label = '-';",
        "question": "How many of the molecules are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '-'",
        "evidence": [
            "label = '-' means molecules are non-carcinogenic"
        ]
    },
    "289": {
        "reason": "To determine if the molecule TR151 is carcinogenic, we need to analyze the data in the provided tables. The question implies that the 'label' column in the 'molecule' table might contain information about whether the molecule is carcinogenic. However, the schema does not explicitly mention a 'carcinogenic' attribute. Therefore, we will query the 'label' column of the 'molecule' table for the molecule with 'molecule_id' equal to 'TR151' to see if the label indicates carcinogenicity.",
        "sql": "SELECT label FROM molecule WHERE molecule_id = 'TR151';",
        "question": "Is molecule TR151 carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR151'",
        "evidence": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "916": {
        "reason": "To list the surnames of all Italian drivers, we need to query the `drivers` table. The `nationality` column in this table indicates the driver's nationality. We will filter for drivers where the `nationality` is 'Italian' and then select the `surname` column to get the surnames of these drivers.",
        "sql": "SELECT surname FROM drivers WHERE nationality = 'Italian';",
        "question": "Please list the surnames of all the Italian drivers.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT surname FROM drivers WHERE nationality = 'Italian'",
        "evidence": [
            "Italian refers to nationality = 'italian'"
        ]
    },
    "1078": {
        "reason": "To determine which player is older between Aaron Lennon and Abdelaziz Barrada, we need to compare their birthdays from the `Player` table. The player with the earlier birthday is the older one. The query will retrieve the `player_name` and `birthday` for both players, order them by `birthday` in ascending order (to get the oldest first), and limit the result to the first row, which will be the older player.",
        "sql": "SELECT player_name, birthday FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1;",
        "question": "Which player is older, Aaron Lennon or Abdelaziz Barrada?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1",
        "evidence": [
            "The larger the birthday value, the younger the person is, and vice versa;",
            "The `birthday` column in the `Player` table stores dates, and ordering by `birthday` in ascending order retrieves the oldest player first.",
            "The `birthday` column in the `Player` table is used to determine player age, with earlier dates indicating older players. The query should focus on retrieving the player name directly without redundant columns.",
            "The `player_name` column alone is sufficient to identify the older player when combined with the `birthday` column for ordering."
        ]
    },
    "1173": {
        "reason": "To find the most common illness among patients whose lab work was done between 1/1/1985 and 12/31/1995, we need to:\n1. Join the `Examination` table with the `Patient` table using the `ID` field to link the examination dates to the patient diagnoses.\n2. Filter the examinations to only include those with `Examination Date` between '1985-01-01' and '1995-12-31'.\n3. Group the results by the `Diagnosis` field from the `Patient` table.\n4. Count the occurrences of each diagnosis.\n5. Order the results by the count in descending order to find the most common diagnosis.\n6. Limit the result to the top diagnosis.",
        "sql": "SELECT p.Diagnosis, COUNT(p.Diagnosis) AS DiagnosisCount\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE e.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY p.Diagnosis\nORDER BY DiagnosisCount DESC\nLIMIT 1;",
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "evidence": [
            "the most common illness refers to MAX(COUNT(Diagnosis)); lab work between 1/1/1985 and 12/31/1995 refers to `Examination Date` between '1985-01-01' and '1995-12-31 '",
            "The diagnosis is stored in the `Patient` table, not the `Examination` table, requiring a join to access it.\nTo count the most common diagnosis, group by `Patient.Diagnosis` and order by the count of diagnoses.\nThe join ensures the diagnosis is correctly linked to the examination date range.",
            "The `Diagnosis` field in the `Patient` table is the primary source for identifying illnesses, while the `Examination` table links to patients via the `ID` field.\nTo count diagnoses, group by `Patient.Diagnosis` and order by the count of diagnoses in descending order.\nThe join between `Examination` and `Patient` ensures the correct linkage for filtering by examination date.",
            "The `Diagnosis` field in the `Patient` table is the primary source for identifying illnesses, while the `Examination` table links to patients via the `ID` field.\nTo count diagnoses, group by `Patient.Diagnosis` and order by the count of diagnoses in descending order.\nThe join between `Examination` and `Patient` ensures the correct linkage for filtering by examination date."
        ]
    },
    "236": {
        "reason": "To solve the question, we need to find the bond type and the atoms involved in the bond with the ID 'TR001_6_9'. The bond information is stored in the `bond` table, and the atoms connected by this bond are stored in the `connected` table. The bond type is directly available in the `bond` table, while the atoms involved in the bond can be retrieved from the `connected` table by matching the `bond_id` with 'TR001_6_9'. We will join these tables to get the required information.",
        "sql": "SELECT b.bond_type, c.atom_id, c.atom_id2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.bond_id = 'TR001_6_9';",
        "question": "What are the bond type and the atoms of the bond ID of TR001_6_9?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_id = 'TR001_6_9'",
        "evidence": [
            "atoms refer to atom_id or atom_id2"
        ]
    },
    "1393": {
        "reason": "To solve the question, we need to retrieve the full name (first_name and last_name) and email address of the member whose position is 'Secretary' in the Student Club. The relevant table for this information is the 'member' table, which contains the columns 'first_name', 'last_name', 'email', and 'position'. We will query this table with a condition on the 'position' column to filter for 'Secretary'.",
        "sql": "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary';",
        "question": "Provide the full name and email address of the Student_Club's Secretary.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'",
        "evidence": [
            "full name refers to first_name, last_name; 'Secretary' is a position of Student Club",
            "The full name can be retrieved as separate columns (first_name, last_name) rather than concatenated."
        ]
    },
    "1094": {
        "reason": "To solve the question, we need to compare the overall ratings of two players: Ariel Borysiuk and Paulin Puel. The steps are as follows:\n1. Retrieve the overall_rating for Ariel Borysiuk from the Player_Attributes table, joining with the Player table to match the player name.\n2. Retrieve the overall_rating for Paulin Puel in the same way.\n3. Calculate the percentage difference between Ariel Borysiuk's rating and Paulin Puel's rating using the formula: ((Ariel's rating - Paulin's rating) / Paulin's rating) * 100.\n4. Ensure the query uses INNER JOIN to link the Player and Player_Attributes tables via player_api_id for accurate matching.",
        "sql": "SELECT \n    ((Ariel.overall_rating - Paulin.overall_rating) * 100.0 / Paulin.overall_rating) AS percentage_higher\nFROM \n    (SELECT overall_rating \n     FROM Player_Attributes \n     INNER JOIN Player ON Player_Attributes.player_api_id = Player.player_api_id \n     WHERE Player.player_name = 'Ariel Borysiuk') AS Ariel,\n    (SELECT overall_rating \n     FROM Player_Attributes \n     INNER JOIN Player ON Player_Attributes.player_api_id = Player.player_api_id \n     WHERE Player.player_name = 'Paulin Puel') AS Paulin;",
        "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "evidence": [
            "how much higher in percentage = MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100);",
            "To calculate percentage differences, aggregate functions like SUM with conditional logic (CASE WHEN) are used to isolate specific player ratings.\nJoins should link Player and Player_Attributes tables via player_api_id to ensure accurate player-attribute matching.",
            "To calculate percentage differences, use conditional aggregation (CASE WHEN) to isolate specific player ratings within a single query.\nJoins between Player and Player_Attributes should use INNER JOIN to ensure only matching records are included.",
            "To calculate percentage differences, use conditional aggregation (CASE WHEN) to isolate specific player ratings within a single query.\nJoins between Player and Player_Attributes should use INNER JOIN to ensure only matching records are included."
        ]
    },
    "1245": {
        "reason": "To solve the question, we need to find the number of examinations done after 1997/1/1 that have an inactivated partial prothrombin time (APTT >= 45). The question involves two tables: `Examination` and `Laboratory`. However, the `Examination` table does not contain the `APTT` field, which is found in the `Laboratory` table. Therefore, we need to focus on the `Laboratory` table.\n\n1. Filter the records in the `Laboratory` table where the `Date` is after '1997-01-01'.\n2. From these records, count those where `APTT` is greater than or equal to 45.\n3. The result will give the number of examinations with inactivated partial prothrombin time after the specified date.",
        "sql": "SELECT COUNT(*) AS InactivatedPartialProthrombinTimeCount\nFROM Laboratory\nWHERE Date > '1997-01-01' AND APTT >= 45;",
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "evidence": [
            "examinations done after 1997/1/1 refers to `Examination Date` > '1997-01-01'; normal activated partial prothrom bin time refesr to APTT < 45;",
            "examinations done after 1997/1/1 refers to `Date` > '1997-01-01' in the `Laboratory` table; inactivated partial prothrombin time refers to `APTT` >= 45 in the `Laboratory` table."
        ]
    },
    "1093": {
        "reason": "To find the average overall rating of players born before the year 1986, we need to:\n1. Join the `Player` table with the `Player_Attributes` table to access both the players' birth years and their overall ratings.\n2. Filter the players to include only those born before 1986 using string manipulation on the `birthday` field (since the year is part of the date string).\n3. Calculate the average overall rating by dividing the sum of the `overall_rating` values by the count of players who meet the criteria.",
        "sql": "SELECT SUM(pa.overall_rating) / COUNT(pa.id) AS average_overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE SUBSTR(p.birthday, 1, 4) < '1986';",
        "question": "What is the average overall rating of the players born before the year 1986?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.overall_rating) / COUNT(t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) < '1986'",
        "evidence": [
            "average overall rating = DIVIDE(SUM(overall_rating), COUNT(id)); born before the year 1986 refers to strftime('%Y', birthday) < '1986';",
            "The `AVG` function can be replaced with explicit division of `SUM` and `COUNT` for precise control over aggregation.\nFiltering by year can use `SUBSTR` for direct string manipulation instead of `strftime`."
        ]
    },
    "1320": {
        "reason": "To find the event names attended by Maya Mclean, we need to follow these steps:\n1. Identify Maya Mclean's member_id from the member table using her first and last name.\n2. Use the attendance table to find all events (link_to_event) associated with her member_id.\n3. Join the event table with the results from the attendance table to get the event names.\n\nThe query will involve joining the member, attendance, and event tables to retrieve the required information.",
        "sql": "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nWHERE m.first_name = 'Maya' AND m.last_name = 'Mclean';",
        "question": "Please list the event names of all the events attended by Maya Mclean.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean'",
        "evidence": [
            ""
        ]
    },
    "149": {
        "reason": "To solve the question, we need to identify account types that are not eligible for loans and where the average income (A11 in the district table) of the district where the account is located is between $8000 and $9000. Here's the step-by-step reasoning:\n\n1. **Identify non-eligible account types**: According to the tips, accounts with type 'OWNER' are eligible for loans. Therefore, non-eligible account types are those where the `type` in the `disp` table is not 'OWNER'.\n\n2. **Filter districts by average income**: We need to join the `account` table with the `district` table to filter accounts located in districts where the average income (A11) is between $8000 and $9000.\n\n3. **Combine the conditions**: We will join the `disp` table to get the account types and filter for non-eligible types, then join the `account` and `district` tables to apply the income condition.\n\n4. **Select distinct account types**: Finally, we will select the distinct account types that meet both conditions.",
        "sql": "SELECT DISTINCT d.type\nFROM disp d\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE d.type != 'OWNER'\nAND di.A11 > 8000 AND di.A11 <= 9000;",
        "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
        "evidence": [
            "A11 represents the average salary; Salary and income share the similar meanings; when the account type = 'OWNER', it's eligible for loans"
        ]
    },
    "635": {
        "reason": "To solve the question, we need to find the number of posts by Matt Parker that have more than 4 votes. Here's the step-by-step reasoning:\n\n1. **Identify Matt Parker's UserId**: First, we need to find the `UserId` of Matt Parker from the `users` table where the `DisplayName` is 'Matt Parker'.\n\n2. **Find Posts by Matt Parker**: Using the `UserId` obtained, we can find all posts where the `OwnerUserId` matches Matt Parker's `UserId` in the `posts` table.\n\n3. **Count Votes for Each Post**: For each post found, we need to count the number of votes in the `votes` table where the `PostId` matches the post's `Id`.\n\n4. **Filter Posts with More Than 4 Votes**: We will filter the posts to only include those where the vote count is greater than 4.\n\n5. **Count the Resulting Posts**: Finally, we will count the number of posts that meet the criteria.\n\n6. **Combine the Steps**: We will join the `users`, `posts`, and `votes` tables to achieve this in a single query.",
        "sql": "SELECT COUNT(DISTINCT p.Id) AS PostCount\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nJOIN votes v ON p.Id = v.PostId\nWHERE u.DisplayName = 'Matt Parker'\nGROUP BY p.Id\nHAVING COUNT(v.Id) > 4;",
        "question": "How many posts by Matt Parker have more than 4 votes?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id INNER JOIN votes AS T4 ON T4.PostId = T3.Id WHERE T1.DisplayName = 'Matt Parker' GROUP BY T2.PostId, T4.Id HAVING COUNT(T4.Id) > 4",
        "evidence": [
            "more than 4 votes refer to PostId > 4; DisplayName = 'Matt Parker';",
            "The `postHistory` table tracks user contributions to posts, including edits and other actions, which may be relevant for identifying posts associated with a user.\nTo count votes per post accurately, ensure the join includes the `postHistory` table to capture all relevant post interactions.\nGrouping by both `PostId` and `VoteId` ensures distinct vote counts are correctly aggregated for each post.",
            "The `postHistory` table links user contributions to posts, which is necessary for identifying posts associated with a user.\nTo count votes per post accurately, ensure the join includes the `postHistory` table to capture all relevant post interactions.\nGrouping by both `PostId` and `VoteId` ensures distinct vote counts are correctly aggregated for each post.",
            "The `postHistory` table links user contributions to posts, which is necessary for identifying posts associated with a user.\nTo count votes per post accurately, ensure the join includes the `postHistory` table to capture all relevant post interactions.\nGrouping by both `PostId` and `VoteId` ensures distinct vote counts are correctly aggregated for each post."
        ]
    },
    "986": {
        "reason": "To find the race where the fastest 1st lap time was recorded, we need to:\n1. Identify the fastest 1st lap time from the `lapTimes` table by filtering for `lap = 1` and sorting by `milliseconds` in ascending order.\n2. Retrieve the corresponding race details from the `races` table using the `raceId` from the fastest lap record.\n3. Include the fastest lap time in milliseconds in the result.",
        "sql": "SELECT r.raceId, r.name AS race_name, r.year, r.circuitId, lt.milliseconds AS fastest_lap_time_ms\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nWHERE lt.lap = 1\nORDER BY lt.milliseconds ASC\nLIMIT 1;",
        "question": "In which race did the fastest 1st lap time was recorded? Please indicate the time in milliseconds.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.milliseconds FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.lap = 1 ORDER BY T1.time LIMIT 1",
        "evidence": [
            "fastest refers to Min(time);",
            "The `time` column in the `lapTimes` table records lap times, while `milliseconds` provides a numeric representation for comparison.\nTo find the fastest lap, sorting by `time` is more accurate than `milliseconds` due to potential data inconsistencies.",
            "The `milliseconds` column in the `lapTimes` table provides a numeric value for precise comparison of lap times, which is essential for identifying the fastest lap.\nTo ensure accuracy, sorting by `milliseconds` is preferred over `time` for determining the fastest lap, as it avoids potential inconsistencies in text-based time formats.",
            "The `time` column in the `lapTimes` table is the primary field for determining the fastest lap, while `milliseconds` serves as a supplementary numeric representation.\nTo ensure consistency, sorting by `time` is prioritized over `milliseconds` for identifying the fastest lap."
        ]
    },
    "1287": {
        "reason": "To solve the question, we need to find the number of patients followed at the outpatient clinic (Admission = '-') who have a normal level of alkaline phosphatase (ALP < 300). The steps are as follows:\n1. Identify patients with Admission = '-' in the Patient table.\n2. Join these patients with the Laboratory table to check their ALP levels.\n3. Filter for patients with ALP < 300.\n4. Count the distinct patient IDs to ensure each patient is only counted once.\n5. Use an INNER JOIN to ensure only matching records from both tables are included.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nINNER JOIN Laboratory L ON P.ID = L.ID\nWHERE P.Admission = '-' AND L.ALP < 300;",
        "question": "Among the patients followed at the outpatient clinic, how many of them have a normal level of alkaliphophatase?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300 AND T1.Admission = '-'",
        "evidence": [
            "followed at the outpatient clinic refers to Admission = '-'; normal level of alkaliphophatase refers to ALP < 300;",
            "The query should count distinct patients based on their ID, not the number of records in the join result.",
            "The query should use an INNER JOIN to ensure only matching records from both tables are included.\nCounting distinct IDs is unnecessary when the join condition already ensures uniqueness per patient.\nThe filter for normal ALP levels should be applied directly in the WHERE clause.",
            "The query should count distinct patients based on their ID, not the number of records in the join result.\nThe filter for normal ALP levels should be applied directly in the WHERE clause.\nAn INNER JOIN ensures only matching records from both tables are included, making COUNT(DISTINCT) redundant."
        ]
    },
    "305": {
        "reason": "To solve the question, we need to retrieve all bonds with a single bond type (bond_type = '-') and the pairs of atoms connected by these bonds. The query should join the `bond` and `connected` tables to get the bond details and the connected atom pairs. We should avoid involving the `atom` table as per the requirement. The query will use table aliases for clarity, such as `b` for the `bond` table and `c` for the `connected` table. The result will list the bond_id, bond_type, and the connected atom pairs (atom_id and atom_id2).",
        "sql": "SELECT b.bond_id, b.bond_type, c.atom_id, c.atom_id2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.bond_type = '-';",
        "question": "Name all bonds with single bond types and what atoms are connected to the molecules.",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T1.bond_id, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "evidence": [
            "single bond refers to bond_type = '-';",
            "The query should focus on retrieving bond details and connected atom pairs without including additional atom attributes like element types.",
            "The query should explicitly join the `bond` and `connected` tables to retrieve bond details and connected atom pairs, without involving the `atom` table.",
            "The query should use table aliases for clarity and consistency in referencing columns across joined tables."
        ]
    },
    "793": {
        "reason": "To solve the question, we need to find the number of male superheroes with the race of \"god/eternal\". The steps are as follows:\n1. Identify the race_id for \"god/eternal\" from the tips, which is 21.\n2. Identify the gender_id for \"male\" from the tips, which is 1.\n3. Query the `superhero` table to count the number of superheroes where `race_id` is 21 and `gender_id` is 1.",
        "sql": "SELECT COUNT(*) FROM superhero WHERE race_id = 21 AND gender_id = 1;",
        "question": "Among the superheroes with the race of god/eternal, how many of them are male",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T1.race_id = 21 AND T1.gender_id = 1",
        "evidence": [
            "race \"god/eternal\" refers to race_id = 21; male refers to gender.id = 1"
        ]
    },
    "969": {
        "reason": "To find the number of British drivers born in 1980, we need to query the `drivers` table. The criteria are:\n1. Nationality should be 'British'.\n2. The year of birth (extracted from the `dob` column) should be 1980.\n\nWe will use the `COUNT` function to count the number of drivers meeting these conditions.",
        "sql": "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) = '1980';",
        "question": "How many British drivers who were born in 1980?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) = '1980'",
        "evidence": [
            "born in 1980 refers to year(dob) = 1980;"
        ]
    },
    "725": {
        "reason": "To find the number of superheroes published by Marvel Comics, we need to:\n1. Identify the publisher_id for 'Marvel Comics' in the `publisher` table.\n2. Count the number of superheroes in the `superhero` table where the `publisher_id` matches the one found in step 1.",
        "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');",
        "question": "How many superheroes are published by Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "evidence": [
            "published by Marvel Comics refers to publisher_name = 'Marvel Comics'"
        ]
    },
    "254": {
        "reason": "To solve the question, we need to determine the percentage of bonds that have the most common combination of atoms' elements. Here's the step-by-step reasoning:\n\n1. **Identify the most common combination of atoms' elements in bonds**:\n   - For each bond, we need to find the elements of the two atoms connected by the bond.\n   - Group these combinations (element pairs) and count their occurrences.\n   - The most common combination is the one with the highest count.\n\n2. **Calculate the total number of bonds**:\n   - This is straightforward by counting all entries in the `bond` table.\n\n3. **Calculate the percentage**:\n   - Divide the count of the most common combination by the total number of bonds and multiply by 100 to get the percentage.\n\n4. **SQL Implementation**:\n   - Use a subquery to find the most common combination of elements.\n   - Join the `connected`, `atom`, and `bond` tables to get the required data.\n   - Aggregate and calculate the percentage.",
        "sql": "WITH element_combinations AS (\n  SELECT \n    a1.element AS element1, \n    a2.element AS element2, \n    COUNT(*) AS combination_count\n  FROM \n    connected c\n    JOIN atom a1 ON c.atom_id = a1.atom_id\n    JOIN atom a2 ON c.atom_id2 = a2.atom_id\n    JOIN bond b ON c.bond_id = b.bond_id\n  GROUP BY \n    a1.element, a2.element\n),\nmax_combination AS (\n  SELECT \n    MAX(combination_count) AS max_count\n  FROM \n    element_combinations\n),\ntotal_bonds AS (\n  SELECT \n    COUNT(*) AS total\n  FROM \n    bond\n)\nSELECT \n  (mc.max_count * 100.0 / tb.total) AS percentage\nFROM \n  max_combination mc, \n  total_bonds tb;",
        "question": "What percentage of bonds have the most common combination of atoms' elements?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT CAST((SELECT COUNT(T1.atom_id) FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id GROUP BY T2.bond_type ORDER BY COUNT(T2.bond_id) DESC LIMIT 1 ) AS REAL) * 100 / ( SELECT COUNT(atom_id) FROM connected )",
        "evidence": [
            "DIVIDE(COUNT(bond_id), COUNT(atom_id where MAX(COUNT(atom_id)) ))",
            "To find the percentage of bonds with the most common combination of atoms' elements, focus on counting bonds grouped by their bond type and comparing to the total number of bonds.",
            "To determine the percentage of bonds with the most common combination of atoms' elements, focus on counting bonds grouped by their bond type and comparing to the total number of bonds.",
            "To determine the percentage of bonds with the most common combination of atoms' elements, focus on counting bonds grouped by their bond type and comparing to the total number of bonds."
        ]
    },
    "737": {
        "reason": "To find Copycat's race, we need to follow these steps:\n1. Identify the superhero with the name 'Copycat' in the `superhero` table.\n2. Retrieve the `race_id` associated with this superhero.\n3. Join the `superhero` table with the `race` table to get the actual race name corresponding to the `race_id`.\n4. Return the race name.",
        "sql": "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.superhero_name = 'Copycat';",
        "question": "What is Copycat's race?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'Copycat'",
        "evidence": [
            "Copycat is the superhero_name;"
        ]
    },
    "1073": {
        "reason": "To solve the question, we need to count the number of matches held in the league 'Germany 1. Bundesliga' between August and October 2008. The steps are as follows:\n1. Identify the league_id for 'Germany 1. Bundesliga' from the League table.\n2. Filter matches in the Match table where the league_id matches the identified league_id and the date falls between August and October 2008.\n3. Count the number of such matches.",
        "sql": "SELECT COUNT(*) AS match_count\nFROM Match\nWHERE league_id = (SELECT id FROM League WHERE name = 'Germany 1. Bundesliga')\nAND strftime('%Y-%m', date) BETWEEN '2008-08' AND '2008-10';",
        "question": "How many matches were held in the league Germany 1. Bundesliga\nfrom August to October 2008?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Germany 1. Bundesliga' AND SUBSTR(t2.`date`, 1, 7) BETWEEN '2008-08' AND '2008-10'",
        "evidence": [
            "Germany 1. Bundesliga refers to League.name = 'Germany 1. Bundesliga'; from August to October 2008 refers to strftime('%Y-%m', date) BETWEEN '2008-08' AND '2008-10';"
        ]
    },
    "906": {
        "reason": "To solve the question, we need to find Lewis Hamilton's first race and the points he recorded in that race. Here's the step-by-step reasoning:\n\n1. **Identify Lewis Hamilton**: We need to locate Lewis Hamilton in the `drivers` table using his full name (forename and surname).\n2. **Find his first race**: The first race is determined by the earliest year in the `races` table. We join the `races` table with the `driverStandings` table to link races with driver standings.\n3. **Retrieve points for the first race**: The `driverStandings` table records the points for each driver in each race. We will retrieve the points for Lewis Hamilton in his first race.\n4. **Order and limit**: We order the races by year in ascending order and limit the result to 1 to get the earliest race.\n\nBy joining the `drivers`, `races`, and `driverStandings` tables, we can link all the necessary information to answer the question.",
        "sql": "SELECT r.name AS race_name, r.year, ds.points\nFROM drivers d\nJOIN driverStandings ds ON d.driverId = ds.driverId\nJOIN races r ON ds.raceId = r.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nORDER BY r.year ASC\nLIMIT 1;",
        "question": "Which was Lewis Hamilton first race? What was his points recorded for his first race event?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.name, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year ASC LIMIT 1",
        "evidence": [
            "first race refers to min(Year); Lewis Hamiltonrefers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
            "The driverStandings table records points for drivers in each race, not the results table.\nTo find the earliest race, ordering by year and limiting to 1 ensures the first race is retrieved.\nJoining races, driverStandings, and drivers links race details, points, and driver information.",
            "The earliest race for a driver is determined by the minimum year in the races table, not just ordering by year and date.\nPoints for a driver in a race are recorded in the driverStandings table, not the results table.\nJoining drivers, races, and driverStandings ensures all necessary information is linked.",
            "The earliest race for a driver is determined by ordering races by year in ascending order and limiting to 1, not by finding the minimum year.\nPoints for a driver in a race are retrieved directly from the driverStandings table, not through intermediate joins.\nJoining drivers, races, and driverStandings ensures all necessary information is linked without additional subqueries."
        ]
    },
    "23": {
        "reason": "To solve the question, we need to find schools where the difference in enrollment between K-12 and ages 5-17 is more than 30. The difference is calculated as `Enrollment (K-12)` minus `Enrollment (Ages 5-17)`. Additionally, we need to provide the full street address of these schools. The `School Name` in the `frpm` table corresponds to the `School` column in the `schools` table, and the full street address is derived from the `Street` column in the `schools` table. We will join the `frpm` and `schools` tables on the `CDSCode` and filter for schools where the enrollment difference exceeds 30.",
        "sql": "SELECT f.`School Name`, s.Street AS \"Full Street Address\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE (f.`Enrollment (K-12)` - f.`Enrollment (Ages 5-17)`) > 30;",
        "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
        "evidence": [
            "Diffrence in enrollement = `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
            "The `School Name` in the `frpm` table corresponds to the `School` column in the `schools` table.\nThe full street address is derived from combining `Street`, `City`, `State`, and `Zip` columns in the `schools` table.",
            "The difference in enrollment is calculated as `Enrollment (K-12)` minus `Enrollment (Ages 5-17)` without using absolute value.\nThe full street address is derived from the `Street` column in the `schools` table, not concatenated with other address components.",
            "The `School` column in the `schools` table corresponds to the `School Name` in the `frpm` table.\nThe full street address is derived from the `Street` column in the `schools` table, not concatenated with other address components."
        ]
    },
    "173": {
        "reason": "To solve the question, we need to address two parts:\n1. Determine how often account number 3 requests an account statement to be released.\n2. Identify the purpose (k_symbol) of debiting a total of 3539.\n\nFor the first part, we need to look at the `account` table to find the `frequency` of account number 3.\n\nFor the second part, we need to aggregate the `amount` in the `order` table by `k_symbol` and filter for the total amount of 3539 to find the purpose (k_symbol).",
        "sql": "-- Part 1: Frequency of account number 3\nSELECT frequency\nFROM account\nWHERE account_id = 3;\n\n-- Part 2: Purpose of debiting 3539 in total\nSELECT k_symbol, SUM(amount) AS total_amount\nFROM `order`\nGROUP BY k_symbol\nHAVING SUM(amount) = 3539;",
        "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
        "evidence": [
            "k_symbol refers to the purpose of payments",
            "The `order` table contains transaction details including `k_symbol` and `amount`, which are relevant for analyzing payment purposes and totals.\nThe `account` table holds the `frequency` attribute, which indicates how often an account operates.\nJoining `account` with aggregated `order` data allows linking account frequency to transaction purposes.",
            "The `order` table includes `account_id` to link transactions to specific accounts, enabling analysis of transaction purposes per account.\nAggregating `amount` by both `account_id` and `k_symbol` allows filtering for specific totals tied to an account.\nJoining `account` with aggregated `order` data ensures frequency and transaction purposes are linked for a specific account.",
            "The `order` table's `account_id` links transactions to specific accounts, enabling analysis of transaction purposes per account.\nAggregating `amount` by both `account_id` and `k_symbol` allows filtering for specific totals tied to an account.\nJoining `account` with aggregated `order` data ensures frequency and transaction purposes are linked for a specific account."
        ]
    },
    "1271": {
        "reason": "To solve the question, we need to find the number of distinct patients who have a normal anti-SSA result and came to the hospital before the year 2000. Here's the step-by-step reasoning:\n\n1. **Identify normal anti-SSA results**: The `SSA` column in the `Laboratory` table indicates normal results with values like 'negative' or '0'.\n2. **Filter patients who came before 2000**: The `Date` column in the `Laboratory` table is used to filter records before the year 2000.\n3. **Count distinct patients**: We need to count the distinct `ID` values from the `Laboratory` table that meet the above criteria.\n\nCombining these steps, we will query the `Laboratory` table for patients with normal anti-SSA results (`SSA` IN ('negative', '0')) and a `Date` before '2000-01-01', then count the distinct `ID` values.",
        "sql": "SELECT COUNT(DISTINCT ID) \nFROM Laboratory \nWHERE (SSA = 'negative' OR SSA = '0') \nAND Date < '2000-01-01';",
        "question": "How many patients with a normal anti-SSA came to the hospital before 2000?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '2000'",
        "evidence": [
            "normal anti-SSA refers to SSA IN('-','+-'); came to the hospital before 2000 refers to YEAR(`First Date`) < 2000; Should compute the number of distinct ones",
            "The `SSA` column in the `Laboratory` table uses values like 'negative' or '0' to indicate normal results, not '-' or '+-'.\nThe `Date` column in the `Laboratory` table is used for filtering by year, not the `First Date` column in the `Patient` table."
        ]
    },
    "493": {
        "reason": "To find the parent code for the set \"Commander 2014 Oversized\", we need to query the `sets` table. The `sets` table contains a column named `parentCode` which holds the parent code for each set. We will filter the records where the `name` column matches \"Commander 2014 Oversized\" and then retrieve the `parentCode` for that record.",
        "sql": "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized';",
        "question": "For the set \"Commander 2014 Oversized\" , give its parent code.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized'",
        "evidence": [
            "the set \"Commander 2014 Oversized\" refers to name = 'Commander 2014 Oversized';"
        ]
    },
    "574": {
        "reason": "To find the user who has the website URL listed as 'http://stackoverflow.com', we need to query the `users` table. The `users` table contains a column named `WebsiteUrl` which stores the website URL of each user. We will filter the records where `WebsiteUrl` is equal to 'http://stackoverflow.com' and retrieve the `DisplayName` of the user.",
        "sql": "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com';",
        "question": "Which user has the website URL listed at 'http://stackoverflow.com'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com'",
        "evidence": [
            "\"http://stackoverflow.com\" is the WebsiteUrl; user refers to DisplayName"
        ]
    },
    "811": {
        "reason": "To solve the question, we need to find the alignment and superpowers of the superhero named 'Atom IV'. Here's the step-by-step reasoning:\n\n1. **Identify the superhero**: First, we need to locate the superhero with the name 'Atom IV' in the `superhero` table.\n2. **Retrieve alignment**: Once we have the superhero's ID, we can join the `superhero` table with the `alignment` table to get the alignment details.\n3. **Retrieve superpowers**: We also need to join the `superhero` table with the `hero_power` and `superpower` tables to get the list of superpowers associated with 'Atom IV'.\n4. **Combine results**: The final query will combine these joins to return both the alignment and superpowers in a single result set.",
        "sql": "SELECT a.alignment, GROUP_CONCAT(sp.power_name, ', ') AS superpowers\nFROM superhero sh\nJOIN alignment a ON sh.alignment_id = a.id\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Atom IV'\nGROUP BY a.alignment;",
        "question": "Give the alignment and superpowers of the superhero named Atom IV.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T4.alignment, T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN alignment AS T4 ON T1.alignment_id = T4.id WHERE T1.superhero_name = 'Atom IV'",
        "evidence": [
            "superpowers refers to power_name;"
        ]
    },
    "670": {
        "reason": "To find the date when the youngest user made their first post, we need to follow these steps:\n1. Identify the youngest user by finding the user with the highest age (assuming 'Age' is stored as a positive number).\n2. Find the earliest post made by this user by checking the 'CreationDate' in the 'posts' table.\n3. Combine these steps to retrieve the desired date.",
        "sql": "SELECT MIN(p.CreaionDate) AS FirstPostDate\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.Age = (SELECT MIN(Age) FROM users WHERE Age IS NOT NULL);",
        "question": "What is the date when the youngest user made his or her first post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "evidence": [
            "the youngest user refers to MIN(Age); first post refers to MIN(CreaionDate);"
        ]
    },
    "660": {
        "reason": "To find the owner user ID of the most valuable post, we need to determine what makes a post 'most valuable.' Typically, this could be based on the highest score, highest view count, or a combination of factors. For this query, we will assume the most valuable post is the one with the highest score. We will query the `posts` table to find the post with the maximum score and then retrieve its `OwnerUserId`.",
        "sql": "SELECT OwnerUserId FROM posts WHERE Score = (SELECT MAX(Score) FROM posts);",
        "question": "What is the owner user id of the most valuable post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT OwnerUserId FROM posts WHERE FavoriteCount = ( SELECT MAX(FavoriteCount) FROM posts )",
        "evidence": [
            "the most valuable post refers to MAX(FavoriteCount);"
        ]
    },
    "910": {
        "reason": "To find the location coordinates of the Silverstone Circuit, we need to query the `circuits` table. The `circuits` table contains columns `lat` (latitude) and `lng` (longitude), which represent the coordinates. We will filter the rows where the `name` column matches 'Silverstone Circuit' to get the specific coordinates.",
        "sql": "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit';",
        "question": "What's the location coordinates of Silverstone Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit'",
        "evidence": [
            "location coordinates refers to (lat, lng); Silverstone Circuit refers to circuits.name = 'Silverstone Circuit'"
        ]
    },
    "1496": {
        "reason": "To solve the question, we need to find the client segment with the least consumption in September 2013. The steps are as follows:\n1. Filter the `yearmonth` table for records where the `Date` is '201309' (September 2013).\n2. Join the filtered `yearmonth` table with the `customers` table on `CustomerID` to link consumption data to customer segments.\n3. Group the results by `Segment` from the `customers` table.\n4. Sum the `Consumption` for each segment.\n5. Order the results by the summed consumption in ascending order to find the segment with the least consumption.\n6. Limit the result to 1 to get the segment with the least consumption.",
        "sql": "SELECT c.Segment, SUM(ym.Consumption) AS TotalConsumption\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY TotalConsumption ASC\nLIMIT 1;",
        "question": "Which client segment consumed the least in September 2013?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "evidence": [
            "September 2013 refers to yearmonth.date = '201309'",
            "The query should group by customer segments to find the segment with the least consumption.\nThe join between customers and yearmonth tables links consumption data to segments.\nOrdering by summed consumption in ascending order identifies the least consuming segment.",
            "The query should group by individual customers to accurately reflect their consumption before aggregating by segment.\nThe join between customers and yearmonth tables must link individual customer IDs to their consumption data.",
            "The query must group by individual customer IDs before aggregating consumption by segment to ensure accurate segment-level consumption totals.\nThe join between customers and yearmonth tables should link individual customer IDs to their consumption data for precise filtering and aggregation."
        ]
    },
    "449": {
        "reason": "To solve the question, we need to find the language of the card that has an 'azorius' watermark and also list out the type of this card. Here's the step-by-step reasoning:\n\n1. **Identify the card with the 'azorius' watermark**: The `cards` table contains a `watermark` column, which we can filter to find cards with the 'azorius' watermark.\n\n2. **Retrieve the card's UUID**: Once we have the card(s) with the 'azorius' watermark, we need their UUID to join with the `foreign_data` table to find the language.\n\n3. **Join with the `foreign_data` table**: The `foreign_data` table contains the `language` column, which we need to determine the language of the card. We'll join this table with the `cards` table using the `uuid` column.\n\n4. **Retrieve the card's type**: The `cards` table also contains a `type` column, which we can directly include in our query to list the type of the card.\n\n5. **Final query**: Combine all these steps into a single SQL query that filters for the 'azorius' watermark, joins with the `foreign_data` table, and selects the language and type of the card.",
        "sql": "SELECT fd.language, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'azorius';",
        "question": "What is the language of the card that has azorius watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.language, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'azorius'",
        "evidence": [
            ""
        ]
    },
    "529": {
        "reason": "To solve the question, we need to find the names of sets that do not have a Japanese translation but do have a Korean translation. Here's the step-by-step reasoning:\n\n1. **Identify sets with Korean translations**: We need to query the `set_translations` table for entries where the `language` is 'Korean'.\n2. **Exclude sets with Japanese translations**: We need to ensure that the same sets do not have any entries in the `set_translations` table where the `language` is 'Japanese'.\n3. **Retrieve the names of these sets**: Finally, we will join the results with the `sets` table to get the names of the qualifying sets.\n\nWe will use a subquery to first find sets with Korean translations and then exclude those that also have Japanese translations. The final query will join these results with the `sets` table to fetch the names.",
        "sql": "SELECT s.name\nFROM sets s\nWHERE s.code IN (\n    SELECT st.setCode\n    FROM set_translations st\n    WHERE st.language = 'Korean'\n)\nAND s.code NOT IN (\n    SELECT st.setCode\n    FROM set_translations st\n    WHERE st.language = 'Japanese'\n);",
        "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
        "evidence": [
            "names of sets refers to name; doesn't have Japanese translation refers to language not like '%Japanese%'; have Korean translation refers to language = 'Korean'",
            "To identify sets without Japanese translations, ensure the condition excludes any set with a Japanese translation in the set_translations table.\nTo confirm sets with Korean translations, verify the presence of at least one Korean translation entry in the set_translations table.",
            "To identify sets without Japanese translations, ensure the condition excludes any set with a Japanese translation in the set_translations table.\nTo confirm sets with Korean translations, verify the presence of at least one Korean translation entry in the set_translations table."
        ]
    },
    "465": {
        "reason": "To determine if there is a Korean version of the card \"Ancestor's Chosen\", we need to follow these steps:\n1. Identify the card \"Ancestor's Chosen\" in the `cards` table by filtering on the `name` column.\n2. Join the `cards` table with the `sets` table using the `setCode` column to link the card to its set.\n3. Join the `sets` table with the `set_translations` table to check for translations in Korean (language = 'Korean').\n4. If any rows are returned from the join with `set_translations` where the language is Korean, it means a Korean version exists.\n5. Use a conditional check (e.g., `CASE WHEN COUNT(...) > 0 THEN 'YES' ELSE 'NO' END`) to return a binary result indicating the existence of a Korean version.",
        "sql": "SELECT CASE WHEN COUNT(st.translation) > 0 THEN 'YES' ELSE 'NO' END AS has_korean_version\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode AND st.language = 'Korean'\nWHERE c.name = 'Ancestor''s Chosen';",
        "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "evidence": [
            "set of cards with \"Ancestor''s Chosen\" in it refers to name = 'Ancestor''s Chosen'; Korean version refers to language = 'Korean'",
            "The `set_translations` table contains translations for sets, not individual cards, and links to the `sets` table via `setCode`.\nTo find translations for a specific card, join `cards` with `sets` via `setCode`, then join with `set_translations` for language-specific translations.",
            "The `set_translations` table provides translations for sets, not individual cards, and requires joining with `cards` via `setCode` to link translations to specific cards.\nTo determine the existence of a Korean version, check for non-null translations in the `set_translations` table where the language is 'Korean'.\nAggregation functions like `SUM` can be used to count occurrences and return a binary result (e.g., 'YES' or 'NO')."
        ]
    },
    "1068": {
        "reason": "To solve the question, we need to find the average overall rating of players who are taller than 170 cm from the years 2010 to 2015. Here's the step-by-step reasoning:\n\n1. **Filter Players by Height**: First, we need to identify players whose height is greater than 170 cm. This involves querying the `Player` table.\n\n2. **Filter Player Attributes by Date**: Next, we need to consider only the player attributes recorded between 2010 and 2015. This involves filtering the `Player_Attributes` table based on the `date` field.\n\n3. **Join Tables**: We need to join the `Player` table with the `Player_Attributes` table to link the players' height with their overall ratings.\n\n4. **Calculate Average Overall Rating**: Finally, we calculate the average overall rating for the filtered players. This involves summing the `overall_rating` values and dividing by the count of records, ensuring floating-point division for accuracy.\n\nThe query will use explicit `>=` and `<=` operators for clarity and consistency with the schema tips provided.",
        "sql": "SELECT SUM(pa.overall_rating) / CAST(COUNT(pa.id) AS REAL) AS average_overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height > 170\nAND strftime('%Y', pa.date) >= '2010'\nAND strftime('%Y', pa.date) <= '2015';",
        "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
        "evidence": [
            "from 2010 to 2015 refers to strftime('%Y', date) >= '2010' AND <= '2015'; average overall rating = SUM(t2.overall_rating)/ COUNT(t2.id); higher than 170 refers to Player.height > 170;",
            "The `date` field in `Player_Attributes` should be filtered inclusively for the years 2010 to 2015 using `>=` and `<=` operators.\nThe average calculation should explicitly cast the sum to REAL to ensure floating-point division.",
            "The `BETWEEN` operator is inclusive, but explicit `>=` and `<=` should be used for clarity and consistency with the schema.\nThe average calculation should use explicit division of sum by count to ensure precision.",
            "The `Player_Attributes` table contains multiple records per player, so averaging requires explicit sum and count operations to avoid incorrect aggregation.\nThe `height` filter in the `Player` table must be applied before joining to ensure only relevant players are included."
        ]
    },
    "1344": {
        "reason": "To find the notes of the fundraising on 2019/9/14, I need to query the `income` table. The question specifies that the source is 'Fundraising' and the date_received is '2019-09-14'. The `income` table contains the `notes` column, which holds the information we need. I will filter the records based on the source and date_received to retrieve the notes.",
        "sql": "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14';",
        "question": "What was the notes of the fundraising on 2019/9/14?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'",
        "evidence": [
            "fundraising on 2019/9/14 refers to source = 'Fundraising' where date_received = '2019-09-14'"
        ]
    },
    "1201": {
        "reason": "To solve the question, we need to find the percentage of female patients (SEX = 'F') among those who were born in 1980 and diagnosed with RA (Diagnosis = 'RA'). The steps are as follows:\n1. Filter patients born in 1980 using the `Birthday` field in the `Patient` table.\n2. Further filter these patients to include only those diagnosed with RA using the `Diagnosis` field in the `Patient` table.\n3. Count the total number of patients meeting these criteria.\n4. Count the number of female patients (SEX = 'F') among them.\n5. Calculate the percentage by dividing the count of female patients by the total count and multiplying by 100.",
        "sql": "SELECT (SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_women\nFROM Patient\nWHERE strftime('%Y', Birthday) = '1980' AND Diagnosis = 'RA';",
        "question": "What percentage of patients who were born in 1980 and were diagnosed with RA are women?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE Diagnosis = 'RA' AND STRFTIME('%Y', Birthday) = '1980'",
        "evidence": [
            "born in 1980 refers to YEAR(BIRTHDAY) = '1980'; 'RA' refers to Diagnosis='RA' ; women refers to SEX = 'F'; calculation = DIVIDE(SUM(SEX = 'F'), COUNT(SEX)) * 100",
            "The `Diagnosis` field in the `Patient` table is used to filter patients with 'RA'. The `SEX` field in the `Patient` table identifies female patients as 'F'. The `Birthday` field in the `Patient` table is used to filter patients born in 1980, requiring conversion to year format."
        ]
    },
    "516": {
        "reason": "To solve the question, we need to find the number of cards illustrated by Volkan Ba\u01f5a (artist = 'Volkan Ba\u01f5a') that have foreign language data in French (language = 'French'). This involves joining the `cards` table with the `foreign_data` table where the artist is 'Volkan Ba\u01f5a' and the language is 'French'. We then count the distinct card IDs to avoid duplicates.",
        "sql": "SELECT COUNT(DISTINCT c.id) \nFROM cards c \nJOIN foreign_data fd ON c.uuid = fd.uuid \nWHERE c.artist = 'Volkan Ba\u01f5a' AND fd.language = 'French';",
        "question": "How many cards did Volkan Ba\u00c7\u00b5a illustrated whose foreign language is in French?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.id) FROM ( SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Ba\u01f5a' AND T2.language = 'French' GROUP BY T1.id ) AS T3",
        "evidence": [
            "Volkan Ba\u00c7\u00b5a refers to artist = 'Volkan Ba\u01f5a'; foreign language is in French refers to language = 'French'"
        ]
    },
    "10": {
        "reason": "To solve the question, we need to find the school with the highest average reading score in the SAT test and then retrieve its FRPM count for students aged 5-17. The steps are as follows:\n1. Identify the school with the highest average reading score from the `satscores` table.\n2. Join this result with the `frpm` table to get the FRPM count for students aged 5-17.\n3. Use the `CDSCode` (or `cds` in `satscores`) as the common key for joining the tables.\n4. Order the `satscores` table by `AvgScrRead` in descending order and limit to 1 to get the top school.\n5. Join this result with the `frpm` table to fetch the required FRPM count.",
        "sql": "SELECT f.\"FRPM Count (Ages 5-17)\"\nFROM satscores s\nJOIN frpm f ON s.cds = f.CDSCode\nORDER BY s.AvgScrRead DESC\nLIMIT 1;",
        "question": "For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1",
        "evidence": [
            "",
            "To retrieve the top record by a specific metric, use ORDER BY with DESC and LIMIT 1 instead of a subquery with MAX.\nJoins should be performed before filtering to ensure all relevant data is available for sorting."
        ]
    },
    "186": {
        "reason": "To solve the question, we need to calculate the percentage of male clients who request weekly statements. The steps are as follows:\n1. Identify clients who have accounts with a weekly issuance frequency ('POPLATEK TYDNE').\n2. Filter these clients to only include males (gender = 'M').\n3. Calculate the total number of clients who request weekly statements.\n4. Calculate the number of male clients who request weekly statements.\n5. Compute the percentage by dividing the count of male clients by the total count of clients and multiplying by 100.\n\nThe tables involved are:\n- `client` for client details (gender).\n- `account` for account details (frequency).\n- `disp` to link clients to their accounts.\n\nThe query will join these tables to get the required data.",
        "sql": "SELECT \n    (COUNT(DISTINCT CASE WHEN c.gender = 'M' THEN c.client_id END) * 100.0 / \n    COUNT(DISTINCT c.client_id)) AS percentage_male_clients_weekly\nFROM \n    client c\nJOIN \n    disp d ON c.client_id = d.client_id\nJOIN \n    account a ON d.account_id = a.account_id\nWHERE \n    a.frequency = 'POPLATEK TYDNE';",
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "evidence": [
            "Percentage of male clients = [count(male clients who requested weekly statements / count(clients who requested weekly statements)] * 100%; Male means gender = 'M'; 'POPLATEK TYDNE' stands for weekly issuance",
            "The `frequency` column in the `account` table indicates the statement issuance frequency, where 'POPLATEK TYDNE' represents weekly issuance.\nTo link clients to their accounts, the `disp` table serves as a bridge between `client` and `account` tables.\nThe `district` table is involved when joining `client` and `account` through their shared `district_id`.",
            "The `district` table is not directly required for linking clients to accounts; the `disp` table already provides this connection.\nThe `client` and `account` tables are linked via the `disp` table, which maps `client_id` to `account_id`.\nAggregation should use `SUM` and `COUNT` directly for percentage calculation, avoiding `DISTINCT` unless necessary.",
            "The `district` table is not required for linking clients to accounts; the `disp` table already provides this connection.\nAggregation should use `SUM` and `COUNT` directly for percentage calculation, avoiding `DISTINCT` unless necessary.\nThe `client` and `account` tables are linked via the `disp` table, which maps `client_id` to `account_id`."
        ]
    },
    "1272": {
        "reason": "To solve the question, we need to find the first patient with an abnormal anti-SSA result who came to the hospital. The steps are as follows:\n1. Identify patients with abnormal anti-SSA results from the Laboratory table (where SSA is not 'negative' or '0').\n2. Join this with the Patient table to get the 'First Date' of each patient.\n3. Find the patient with the earliest 'First Date' among these patients.\n4. Return the ID of this patient.",
        "sql": "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.SSA NOT IN ('negative', '0')\nORDER BY p.`First Date` ASC\nLIMIT 1;",
        "question": "Which patient is the first patient with an abnormal anti-SSA to come to the hospital? Please give his or her ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` IS NOT NULL AND T2.SSA NOT IN ('negative', '0') ORDER BY T1.`First Date` ASC LIMIT 1",
        "evidence": [
            "first patient refers to ID with MIN(`First Date`); abnormal anti-SSA refers to SSA NOT IN('negative', '0');"
        ]
    },
    "1166": {
        "reason": "To solve the question, we need to identify the youngest patient who has undergone a medical examination and then retrieve their symptoms and diagnosis. The steps are as follows:\n1. Identify the youngest patient by sorting the `Patient` table by `Birthday` in descending order and selecting the top record.\n2. Join the `Patient` table with the `Examination` table to get the examination details of the youngest patient.\n3. Ensure that the `Symptoms` field in the `Examination` table is not NULL (as per the requirement for symptoms observed).\n4. Retrieve the diagnosis from the `Patient` table (as per the tip provided).\n5. Use the correct table aliases to avoid ambiguity in column references.",
        "sql": "SELECT p.Diagnosis, e.Symptoms\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE e.Symptoms IS NOT NULL\nORDER BY p.Birthday DESC\nLIMIT 1;",
        "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T2.Symptoms, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Symptoms IS NOT NULL ORDER BY T1.Birthday DESC LIMIT 1",
        "evidence": [
            "The larger the birthday value, the younger the person is, and vice versa; symptoms observed refers to the symptoms is not NULL",
            "To identify the youngest patient, sorting by birthday in descending order and limiting to one record is more reliable than using MAX(Birthday).\nSymptoms observed must be non-NULL, and the diagnosis should come from the Patient table, not the Examination table.",
            "The diagnosis should be retrieved from the Examination table, not the Patient table, as it pertains to the examination results.\nWhen joining tables, ensure the correct table aliases are used to avoid ambiguity in column references.",
            "The diagnosis should be retrieved from the Patient table, not the Examination table, as it pertains to the patient's overall diagnosis.\nWhen joining tables, ensure the correct table aliases are used to avoid ambiguity in column references."
        ]
    },
    "1409": {
        "reason": "To find the total expense used on 8/20/2019, I need to sum the `cost` column from the `expense` table where the `expense_date` is '2019-08-20'. The `expense` table contains the relevant information, including the `cost` and `expense_date` columns. The query will involve filtering the records for the specified date and then summing the costs.",
        "sql": "SELECT SUM(cost) AS total_expense FROM expense WHERE expense_date = '2019-08-20';",
        "question": "Mention the total expense used on 8/20/2019.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20'",
        "evidence": [
            "total expense refers SUM(cost) where expense_date = '2019-08-20'"
        ]
    },
    "1237": {
        "reason": "To solve the question, we need to identify outpatients with low hemoglobin levels (HGB < 10). The steps are as follows:\n1. Identify outpatients by checking the `Admission` field in the `Patient` table where it equals '-'.\n2. For these outpatients, retrieve their hemoglobin levels (HGB) from the `Laboratory` table.\n3. Filter outpatients with HGB < 10.\n4. Return the distinct IDs and their corresponding sex from the `Patient` table for these filtered outpatients.",
        "sql": "SELECT DISTINCT p.ID, p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Admission = '-' AND l.HGB < 10;",
        "question": "Among all outpatients, list out those have low hemoglobin level. State the different IDs and their sex.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HGB < 10 AND T1.Admission = '-'",
        "evidence": [
            "outpatients refers to Admission = '-'; low hemoglobin level refers to HBG < 10;"
        ]
    },
    "697": {
        "reason": "To find the reputation and view count of the user with the display name 'Jarrod Dixon', we need to query the `users` table. The `users` table contains columns for `Reputation` and `Views`, which are the metrics we are interested in. We will filter the records by the `DisplayName` column to match 'Jarrod Dixon'.",
        "sql": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "evidence": [
            ""
        ]
    },
    "378": {
        "reason": "To solve the question, we need to identify foiled cards that are incredibly powerful when paired with non-foiled cards. The tips provided indicate that \"incredibly powerful\" refers to cards where both `cardKingdomFoilId` and `cardKingdomId` are not null. Additionally, we need to ensure the cards are foiled (`hasFoil = 1`). The query should list the IDs of such cards.",
        "sql": "SELECT id FROM cards WHERE hasFoil = 1 AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
        "question": "What are the foiled cards that are incredibly powerful when paired with non foiled cards? List the IDs.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "evidence": [
            "Incredibly powerful refers to both cardKingdomFoilId and cardKingdomId IS NOT Null;"
        ]
    },
    "424": {
        "reason": "To solve the question, we need to calculate the proportion of cards that do not have a text box (i.e., `isTextless = 1`) and have a normal layout (i.e., `layout = 'normal'`). The proportion is calculated by dividing the count of such cards by the total count of all cards, then multiplying by 100 to get a percentage. The result should be cast to `REAL` for accurate division. The query will use `SUM` with a `CASE` statement to count the matching conditions and `ELSE 0` for non-matching rows.",
        "sql": "SELECT (SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS proportion\nFROM cards;",
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "evidence": [
            "do not have a text box refers to isTextless = 1; proportion refers to DIVIDE(COUNT(Textless = 1 and layout = 'normal'),COUNT(Textless))*100",
            "The proportion calculation should include all cards in the denominator, not just those with `isTextless = 1`.\nThe `CASE` statement should use `SUM` to count matching conditions and `ELSE 0` for non-matching rows.\nThe result should be cast to `REAL` for accurate division."
        ]
    },
    "1490": {
        "reason": "To solve the question, we need to calculate the percentage of LAM customers who consumed more than 46.73. The steps are as follows:\n1. Identify all LAM customers from the `customers` table where the `Segment` is 'LAM'.\n2. For each LAM customer, check their consumption in the `yearmonth` table to see if it exceeds 46.73.\n3. Count the total number of LAM customers and the number of LAM customers who consumed more than 46.73.\n4. Calculate the percentage by dividing the count of LAM customers who consumed more than 46.73 by the total number of LAM customers, then multiply by 100.\n5. Ensure the division is done as floating-point to avoid integer division issues.",
        "sql": "SELECT (CAST(COUNT(CASE WHEN y.Consumption > 46.73 THEN 1 END) AS FLOAT) / COUNT(*)) * 100 AS Percentage\nFROM customers c\nJOIN yearmonth y ON c.CustomerID = y.CustomerID\nWHERE c.Segment = 'LAM';",
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "evidence": [
            "Percentage of LAM customer consumed more than 46.73 = (Total no. of LAM customers who consumed more than 46.73 / Total no. of LAM customers) * 100.",
            "To calculate percentages, ensure the numerator and denominator are cast to compatible types (e.g., FLOAT) to avoid integer division.\nThe IIF function can be used for conditional counting, simplifying the logic for filtering records.\nJoining tables requires matching the correct columns (CustomerID) to ensure accurate aggregation."
        ]
    },
    "930": {
        "reason": "To solve the question, we need to find the Formula 1 race where Lewis Hamilton achieved the highest rank. The highest rank is indicated by the minimum value in the `rank` column of the `results` table, where `rank = 1` is the best possible rank. We will follow these steps:\n1. Identify Lewis Hamilton's driver ID from the `drivers` table by matching his full name (forename and surname).\n2. Join the `results` table with the `races` table to get the race details where Lewis Hamilton participated.\n3. Filter the results to find where Lewis Hamilton's `rank` is 1 (highest rank).\n4. Retrieve the race name from the `races` table for these results.",
        "sql": "SELECT r.name AS race_name\nFROM results res\nJOIN drivers d ON res.driverId = d.driverId\nJOIN races r ON res.raceId = r.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' AND res.rank = 1;",
        "question": "In which Formula_1 race did Lewis Hamilton rank the highest?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE raceId IN ( SELECT raceId FROM results WHERE rank = 1 AND driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) )",
        "evidence": [
            "rank the highest refers to min(rank); Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
            "The `rank` column in the `results` table indicates the driver's rank in a race, with lower values representing higher ranks.\nTo find the highest rank, filter for the minimum `rank` value in the `results` table.\nThe `races` table contains the names of the races, which can be linked to the `results` table via `raceId`.",
            "The `rank` column in the `results` table uses lower values to indicate higher ranks, with 1 being the highest possible rank.\nTo find the highest rank, filter for `rank = 1` in the `results` table.\nThe `races` table can be linked to the `results` table via `raceId` to retrieve the race name."
        ]
    },
    "654": {
        "reason": "To solve the question, we need to find the display name and location of the user who owned the excerpt post with the 'hypothesis-testing' tag. Here's the step-by-step reasoning:\n\n1. First, identify the tag with the name 'hypothesis-testing' in the `tags` table.\n2. From the `tags` table, get the `ExcerptPostId` for this tag.\n3. Use the `ExcerptPostId` to find the corresponding post in the `posts` table.\n4. From the `posts` table, get the `OwnerUserId` of the post.\n5. Use the `OwnerUserId` to find the user's details (display name and location) in the `users` table.\n\nThis involves joining the `tags`, `posts`, and `users` tables to retrieve the required information.",
        "sql": "SELECT u.DisplayName, u.Location\nFROM tags t\nJOIN posts p ON t.ExcerptPostId = p.Id\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE t.TagName = 'hypothesis-testing';",
        "question": "Mention the display name and location of the user who owned the excerpt post with hypothesis-testing tag.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.DisplayName, T3.Location FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id INNER JOIN users AS T3 ON T3.Id = T2.OwnerUserId WHERE T1.TagName = 'hypothesis-testing'",
        "evidence": [
            "user who owned the excerpt post with hypothesis-testing tag refers to OwnerUserId WHERE TagName = 'hypothesis-testing';"
        ]
    },
    "300": {
        "reason": "To find the atoms that comprise the molecule with `molecule_id` 'TR186', we need to query the `atom` table. The `atom` table contains the `atom_id` and `molecule_id` columns, where `molecule_id` links each atom to its respective molecule. Since the question asks for the atoms in 'TR186', we will filter the `atom` table for rows where `molecule_id` is 'TR186' and return the `atom_id` of those atoms.",
        "sql": "SELECT atom_id FROM atom WHERE molecule_id = 'TR186';",
        "question": "What atoms comprise TR186?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id = 'TR186'",
        "evidence": [
            "TR186 is a molecule id",
            "The `atom` table includes `atom_id` and `element` columns, but the query may only require `atom_id` for identifying atoms.\nTable aliases like `T` can be used for clarity in SQL queries.",
            "The query requires only the `atom_id` column from the `atom` table, not the `element` column.\nTable aliases like `T` are optional but can improve query readability."
        ]
    },
    "237": {
        "reason": "To solve the question, we need to determine which molecule the atom with `atom_id` TR001_10 belongs to and whether this molecule is carcinogenic. The steps are as follows:\n1. Join the `atom` table with the `molecule` table using the `molecule_id` field to link the atom to its molecule.\n2. Filter the `atom` table for the atom with `atom_id` TR001_10.\n3. Retrieve the `molecule_id` and `label` from the `molecule` table for the matched molecule.\n4. Use the `IIF` function to check if the `label` is '+', indicating carcinogenicity, and return 'Yes' or 'No' accordingly.",
        "sql": "SELECT a.molecule_id, IIF(m.label = '+', 'Yes', 'No') AS is_carcinogenic\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.atom_id = 'TR001_10';",
        "question": "Which molecule does the atom TR001_10 belong to? Please state whether this molecule is carcinogenic or not.",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T2.molecule_id , IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'",
        "evidence": [
            "TR001_10 is the atom id; label = '+' mean molecules are carcinogenic",
            "The `IIF` function is used to conditionally return values based on a boolean expression, simplifying the logic for determining carcinogenic status.",
            "The `atom` table links to the `molecule` table via `molecule_id`, allowing retrieval of molecule details for a given atom.\nThe `label` field in the `molecule` table determines carcinogenic status, with '+' indicating carcinogenicity.\nThe `IIF` function simplifies conditional logic for displaying carcinogenic status.",
            "The `atom` table connects to the `molecule` table via `molecule_id`, enabling retrieval of molecule details for a specific atom.\nThe `label` field in the `molecule` table indicates carcinogenicity, with '+' as the marker.\nTable aliases like `T1` and `T2` can be used for clarity in joins and filtering."
        ]
    },
    "1525": {
        "reason": "To solve the question, we need to determine the percentage of customers who used EUR on the specific date 2012-08-25. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: We need data from the `customers` table (for the `Currency` field) and the `transactions_1k` table (for the `Date` field and to identify transactions on 2012-08-25).\n\n2. **Filter transactions for the specific date**: We will filter the `transactions_1k` table to include only transactions that occurred on 2012-08-25.\n\n3. **Join with the `customers` table**: We will join the filtered transactions with the `customers` table to access the `Currency` field.\n\n4. **Count total customers on the date**: We will count the total number of unique customers who made transactions on 2012-08-25.\n\n5. **Count customers who used EUR**: We will count the number of unique customers who used EUR on the same date.\n\n6. **Calculate the percentage**: We will divide the count of EUR users by the total count of customers and multiply by 100 to get the percentage.\n\n7. **Use `CAST` for accurate division**: To ensure the division is accurate, we will cast the counts to `FLOAT` before performing the division.",
        "sql": "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN c.Currency = 'EUR' THEN t.CustomerID END) AS FLOAT) / \n     CAST(COUNT(DISTINCT t.CustomerID) AS FLOAT)) * 100 AS Percentage_EUR_Customers\nFROM \n    transactions_1k t\nJOIN \n    customers c ON t.CustomerID = c.CustomerID\nWHERE \n    t.Date = '2012-08-25';",
        "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
        "evidence": [
            "'2012/8/25' can be represented by '2012-08-25'",
            "The `Currency` field is in the `customers` table, not the `transactions_1k` table, requiring a join to access it.\nTo calculate percentages, use conditional aggregation with `IIF` or `CASE` to count specific cases directly.\nThe `Date` field in `transactions_1k` should be filtered directly for the specific date.",
            "To calculate percentages, use `SUM(IIF(condition, 1, 0))` for counting specific cases directly.\nThe `Date` field in `transactions_1k` should be filtered directly for the specific date.",
            "To ensure accurate percentage calculation, use `CAST` to convert counts to `FLOAT` before division.\nWhen joining tables for filtering, ensure the join condition links the correct fields to avoid mismatches."
        ]
    },
    "207": {
        "reason": "To find elements in a double bond, we need to identify atoms that are part of a bond where the `bond_type` is '='. The steps are as follows:\n1. Join the `bond` table with the `connected` table to find bonds of type '=' and the atoms involved in these bonds.\n2. Join the result with the `atom` table to get the elements of the atoms involved in these double bonds.\n3. Ensure the correct molecular context by joining via `molecule_id`.\n4. Filter for bonds where `bond_type` is '='.\n5. Select the distinct elements from the `atom` table to avoid duplicates.",
        "sql": "SELECT DISTINCT a.element\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '=';",
        "question": "What elements are in a double type bond?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
        "evidence": [
            "double type bond refers to bond_type = '=';",
            "Double bonds are identified by `bond_type = '='` in the `bond` table.\nTo find elements in double bonds, join `atom` and `bond` via `molecule_id` to ensure correct molecule context.\nThe `connected` table links atoms to bonds, but the join must filter for atoms directly involved in the bond.",
            "To identify elements in a bond, join the `atom` table with the `bond` table via `molecule_id` to ensure the correct molecular context.\nThe `connected` table links atoms to bonds, but the join must filter for atoms directly involved in the bond by matching `atom_id` in `connected` with `atom_id` in `atom`.",
            "To ensure correct molecular context, join the `atom` and `bond` tables via `molecule_id`.\nThe `connected` table links atoms to bonds, but the join must filter for atoms directly involved in the bond by matching `atom_id` in `connected` with `atom_id` in `atom`."
        ]
    },
    "363": {
        "reason": "To solve the question, we need to find the number of cards that meet two conditions: \n1. Their legal status is 'Restricted' (as per the `legalities` table).\n2. They are found in a starter deck (i.e., `isStarter = 1` in the `cards` table).\n\nWe will join the `cards` table with the `legalities` table to filter cards based on these conditions. The `status` field in the `legalities` table is case-sensitive, so we must match 'Restricted' exactly. Additionally, we need to count distinct card IDs to avoid duplicates from multiple legalities entries for the same card.",
        "sql": "SELECT COUNT(DISTINCT c.id) \nFROM cards c \nJOIN legalities l ON c.uuid = l.uuid \nWHERE l.status = 'Restricted' AND c.isStarter = 1;",
        "question": "How many cards of legalities whose status is restricted are found in a starter deck?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isStarter = 1",
        "evidence": [
            "restricted refers to status = 'restricted'; found in the starter deck refers to isStarter = 1;",
            "The `status` field in the `legalities` table is case-sensitive, requiring exact matches like 'Restricted'.\nCounting distinct card IDs ensures no duplicates from multiple legalities entries for the same card."
        ]
    }
}