{
    "51": {
        "reason": "To solve the question, we need to find the school with the lowest average reading score (`AvgScrRead`) from the `satscores` table. We also need to retrieve the mailing street address (`MailStreet`) and the school's name (`School`) from the `schools` table. The steps are as follows:\n1. Join the `satscores` table with the `schools` table using the `CDSCode` (or `cds` in `satscores`) as the common key.\n2. Filter out NULL values in the `AvgScrRead` column to ensure accurate results.\n3. Order the results by `AvgScrRead` in ascending order to find the lowest score.\n4. Limit the result to 1 to get only the school with the lowest score.\n5. Select the `MailStreet` and `School` columns from the `schools` table.",
        "sql": "SELECT s.MailStreet, s.School\nFROM satscores sat\nJOIN schools s ON sat.cds = s.CDSCode\nWHERE sat.AvgScrRead IS NOT NULL\nORDER BY sat.AvgScrRead ASC\nLIMIT 1;",
        "question": "In which mailing street address can you find the school that has the lowest average score in reading? Also give the school's name.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "evidence": [
            "",
            "The `AvgScrRead` column in the `satscores` table can contain NULL values, which should be excluded to ensure accurate results.\nJoining `satscores` with `schools` requires filtering out NULL values in the `AvgScrRead` column to avoid incorrect ordering."
        ]
    },
    "134": {
        "reason": "To solve the question, we need to find the branch (district) where the largest number of crimes were committed in 1996, and then determine how many accounts were opened in that district. Here's the step-by-step reasoning:\n\n1. **Identify the district with the most crimes in 1996**: The `district` table contains crime-related columns (A15 and A16). Column A15 represents the number of crimes in 1995, and A16 represents the number of crimes in 1996. We need to find the district with the highest value in A16.\n\n2. **Find accounts opened in that district**: Once we have the district_id of the district with the most crimes in 1996, we can query the `account` table to count the number of accounts opened in that district.\n\n3. **Combine the queries**: First, find the district_id with the highest A16 value, then use this district_id to count the accounts in the `account` table.",
        "sql": "WITH max_crime_district AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A16 DESC\n    LIMIT 1\n)\nSELECT COUNT(*) AS accounts_opened\nFROM account\nWHERE district_id = (SELECT district_id FROM max_crime_district);",
        "question": "In the branch where the largest number of crimes were committed in 1996, how many accounts were opened?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY T1.A16 ORDER BY T1.A16 DESC LIMIT 1",
        "evidence": [
            "A16 stands for no. of committed crimes 1996"
        ]
    },
    "908": {
        "reason": "To find the race with the most laps, we need to analyze the `lapTimes` table, which records lap details for each race. The `lap` column in this table indicates the number of laps in a race. By joining the `lapTimes` table with the `races` and `circuits` tables, we can retrieve the race name, year, and circuit location. The query will sort the results by the `lap` column in descending order and limit the output to the top result to identify the race with the most laps.",
        "sql": "SELECT r.name AS race_name, r.year, c.location AS circuit_location, MAX(lt.lap) AS max_laps\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nGROUP BY lt.raceId\nORDER BY max_laps DESC\nLIMIT 1;",
        "question": "What is the most laps f1 races had? Name the race, year and circuit location where the races with most laps was hosted.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T3.lap, T2.name, T2.year, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId INNER JOIN lapTimes AS T3 ON T3.raceId = T2.raceId ORDER BY T3.lap DESC LIMIT 1",
        "evidence": [
            "",
            "The `lapTimes` table records lap details for each race, including the lap number, which can be used to determine the maximum laps in a race.\nTo find the race with the most laps, join the `lapTimes` table with `races` and `circuits` to retrieve race and circuit details.\nThe `results` table's `laps` column may not always reflect the total laps in a race, as it records laps completed by individual drivers.",
            "The `lapTimes` table's `lap` column directly indicates the number of laps in a race, and sorting by this column in descending order reveals the race with the most laps.\nTo retrieve race details, join `lapTimes` with `races` and `circuits` without aggregation, as the highest lap value alone identifies the target race.\nThe `results` table's `laps` column is not required for this query, as it tracks individual driver laps rather than the total race laps.",
            "The `lapTimes` table's `lap` column directly indicates the number of laps in a race, and sorting by this column in descending order reveals the race with the most laps.\nTo retrieve race details, join `lapTimes` with `races` and `circuits` without aggregation, as the highest lap value alone identifies the target race.\nThe `results` table's `laps` column is not required for this query, as it tracks individual driver laps rather than the total race laps."
        ]
    },
    "425": {
        "reason": "To solve the question, we need to find card numbers that meet two conditions: 1) they don't have multiple faces on a single card (indicated by the `side` column being null), and 2) they have the subtypes 'Angel' and 'Wizard'. The `subtypes` column stores values as a comma-separated list, so we need to ensure the exact matching of combined subtypes. The query will filter cards where `side` is null and the `subtypes` column contains both 'Angel' and 'Wizard'.",
        "sql": "SELECT number FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%';",
        "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
        "evidence": [
            "don't have multiple faces on a single card side is null",
            "The `subtypes` column stores values as a comma-separated list, requiring exact matching for combined subtypes.\nThe `side` column being null indicates a single-face card.",
            "The `subtypes` column requires exact matching for combined subtypes, not partial matches.\nThe `side` column being null indicates a single-face card.",
            "The `subtypes` column requires exact matching for combined subtypes, not partial matches.\nThe `side` column being null indicates a single-face card."
        ]
    },
    "463": {
        "reason": "To solve the question, we need to find the number of translations for the set of cards that include \"Angel of Mercy\" in their name. Here's the step-by-step reasoning:\n\n1. **Identify the relevant card(s)**: First, we need to find the card(s) with \"Angel of Mercy\" in their name. This involves querying the `cards` table where the `name` column contains \"Angel of Mercy\".\n\n2. **Link to translations**: Once we have the card(s), we need to find their translations. The translations are stored in the `set_translations` table, which is linked to the `sets` table via the `setCode` column. However, the `cards` table is linked to the `sets` table via the `setCode` column as well.\n\n3. **Count distinct translations**: We need to count the distinct translations for the set(s) associated with the card(s) identified in step 1. This involves joining the `cards`, `sets`, and `set_translations` tables and counting the distinct `translation` values where the `translation` is not null.\n\n4. **Filter and count**: Finally, we filter the results to ensure we only count valid translations (i.e., where `translation IS NOT NULL`) and then count the distinct translations.",
        "sql": "SELECT COUNT(DISTINCT st.translation) AS translation_count\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode\nWHERE c.name LIKE '%Angel of Mercy%' AND st.translation IS NOT NULL;",
        "question": "How many translations are there for the set of cards with \"Angel of Mercy\" in it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT translation) FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Angel of Mercy' ) AND translation IS NOT NULL",
        "evidence": [
            "set of cards with \"Angel of Mercy\" in it refers to name = 'Angel of Mercy'",
            "To count distinct translations, use COUNT(DISTINCT translation) to avoid duplicates.\nEnsure translations are not null by adding a condition translation IS NOT NULL."
        ]
    },
    "1503": {
        "reason": "To solve the question, we need to list the product descriptions of products bought in transactions where the currency is Euro (EUR). The steps are as follows:\n1. Identify transactions where the customer's currency is 'EUR' by joining the `transactions_1k` table with the `customers` table on `CustomerID`.\n2. Join the resulting table with the `products` table on `ProductID` to get the product descriptions.\n3. Select the `ProductID` and `Description` fields from the `products` table to ensure uniqueness and clarity.\n4. Filter the results to only include transactions where the customer's currency is 'EUR'.",
        "sql": "SELECT p.ProductID, p.Description\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE c.Currency = 'EUR';",
        "question": "Please list the product description of the products bought in transactions in euro.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ProductID, T3.Description FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Currency = 'EUR'",
        "evidence": [
            "",
            "The `Currency` field in the `customers` table uses 'EUR' as the value for Euro, not 'Euro'.",
            "The `ProductID` field is required in the result to uniquely identify products, not just their descriptions."
        ]
    },
    "868": {
        "reason": "To find the location coordinates (latitude and longitude) of the Malaysian Grand Prix, we need to:\n1. Identify the race named 'Malaysian Grand Prix' in the `races` table.\n2. Join the `races` table with the `circuits` table to get the circuit details, including the location coordinates (`lat` and `lng`).\n3. Select the `lat` and `lng` columns from the `circuits` table for the identified race.",
        "sql": "SELECT c.lat, c.lng\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Malaysian Grand Prix';",
        "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix'",
        "evidence": [
            "location coordinates refers to (lat, lng); Malaysian Grand Prix refers to races.name = 'Malaysian Grand Prix'"
        ]
    },
    "1455": {
        "reason": "To solve the question, we need to identify the budget that allowed the most money for 'Water, chips, cookies'. This involves the following steps:\n1. Filter the `expense` table for records where `expense_description` is 'Water, chips, cookies'.\n2. For these records, find the maximum `cost` value.\n3. Identify the `link_to_budget` associated with this maximum cost.\n4. Retrieve the corresponding budget details from the `budget` table using the `link_to_budget`.\n\nThe query will join the `expense` and `budget` tables to fetch the relevant budget information.",
        "sql": "SELECT b.budget_id, b.category, b.amount, b.spent, b.remaining, b.event_status\nFROM budget b\nJOIN expense e ON b.budget_id = e.link_to_budget\nWHERE e.expense_description = 'Water, chips, cookies'\nORDER BY e.cost DESC\nLIMIT 1;",
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "evidence": [
            "budget allowed refers to expense_description; expense_description = 'Water, chips, cookies'; most money refers to MAX(cost)",
            "The `expense_description` field in the `expense` table is used to filter records for specific items like 'Water, chips, cookies'.\nThe `cost` field in the `expense` table determines the highest expense amount for the specified items.\nThe `link_to_budget` field in the `expense` table connects to the `budget` table to identify the relevant budget.",
            "The `expense_description` field in the `expense` table is used to filter records for specific items like 'Water, chips, cookies'.\nThe `cost` field in the `expense` table determines the highest expense amount for the specified items.\nThe `link_to_budget` field in the `expense` table connects to the `budget` table to identify the relevant budget."
        ]
    },
    "957": {
        "reason": "To solve the question, we need to find the number of Italian drivers who haven't finished a race. The steps are as follows:\n1. Identify Italian drivers from the `drivers` table by filtering on `nationality = 'Italian'`.\n2. Join the `drivers` table with the `results` table using `driverId` to get race results for these drivers.\n3. Filter the results where the `time` is null, indicating the driver did not finish the race.\n4. Count the distinct `driverId` values to get the number of unique Italian drivers who haven't finished a race.",
        "sql": "SELECT COUNT(DISTINCT d.driverId) AS italian_drivers_not_finished\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE d.nationality = 'Italian' AND r.time IS NULL;",
        "question": "How many Italian drivers haven't finished the race?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Italian' AND T1.time IS NULL",
        "evidence": [
            "haven't finished the race refers to time is null;",
            "The `results` table records race outcomes, and a null `time` indicates a driver did not finish. Nationality is stored in the `drivers` table.",
            "The `results` table links to `drivers` via `driverId`, and filtering for null `time` identifies unfinished races. Nationality is stored in the `drivers` table.",
            "The `results` table links to `drivers` via `driverId`, and filtering for null `time` identifies unfinished races. Nationality is stored in the `drivers` table."
        ]
    },
    "1253": {
        "reason": "To solve the question, we need to find the patient with the highest Ig A value within the normal range (80 to 500) and then retrieve their diagnosis. The steps are as follows:\n1. Filter the Laboratory table to include only records where Ig A (IGA) is within the normal range (80 to 500).\n2. Order these records by IGA in descending order to get the highest value first.\n3. Limit the result to the top record to get the patient with the highest Ig A.\n4. Join this result with the Patient table to retrieve the diagnosis for the identified patient.\n5. Return the diagnosis.",
        "sql": "SELECT p.Diagnosis\nFROM Patient p\nJOIN (\n    SELECT ID\n    FROM Laboratory\n    WHERE IGA BETWEEN 80 AND 500\n    ORDER BY IGA DESC\n    LIMIT 1\n) l ON p.ID = l.ID;",
        "question": "For the patient who has the highest Ig A within the normal range, what is his or her diagnosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT patientData.Diagnosis FROM Patient AS patientData INNER JOIN Laboratory AS labData ON patientData.ID = labData.ID WHERE labData.IGA BETWEEN 80 AND 500 ORDER BY labData.IGA DESC LIMIT 1",
        "evidence": [
            "highest Ig A within the normal range refers to MAX(IGA BETWEEN 80 AND 500);",
            "The highest value within a range requires ordering by the attribute and limiting to the top result, not equality to the maximum.\nNormal range filtering should be applied before ordering to ensure only valid values are considered."
        ]
    },
    "448": {
        "reason": "To solve the question, we need to find the foreign name of the card that has the 'abzan' watermark and list its type. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `cards` table contains the watermark and type information, while the `foreign_data` table contains the foreign names of the cards.\n2. **Filter cards with the 'abzan' watermark**: We need to query the `cards` table for entries where the `watermark` column is 'abzan'.\n3. **Join with the `foreign_data` table**: Since the foreign names are stored in the `foreign_data` table, we need to join it with the `cards` table using the `uuid` column to retrieve the foreign name.\n4. **Select the required columns**: The query should return the foreign name (`foreign_data.name`) and the card type (`cards.type`).\n5. **Ensure uniqueness**: Use `DISTINCT` to avoid duplicate entries in the result.\n\nThe final SQL query will join these tables and filter for the 'abzan' watermark.",
        "sql": "SELECT DISTINCT fd.name AS foreign_name, c.type AS card_type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'abzan';",
        "question": "Name the foreign name of the card that has abzan watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'abzan'",
        "evidence": [
            "",
            "The `foreign_data` table may contain multiple entries for the same card, so using `DISTINCT` ensures unique results.\nThe `type` column in the `cards` table provides the card type, which should be included in the output.",
            "The `foreign_data` table stores foreign names linked to cards via the `uuid` column, requiring a join to retrieve the foreign name.\nThe `type` column in the `cards` table must be included to fulfill the requirement of listing the card type.\nThe `watermark` column in the `cards` table is used to filter cards with the specified watermark.",
            "The `foreign_data` table stores foreign names linked to cards via the `uuid` column, requiring a join to retrieve the foreign name.\nThe `type` column in the `cards` table must be included to fulfill the requirement of listing the card type.\nThe `watermark` column in the `cards` table is used to filter cards with the specified watermark."
        ]
    },
    "381": {
        "reason": "To list the names of artists for cards in Chinese Simplified, we need to identify the cards that have foreign data entries in the 'Chinese Simplified' language. The steps are as follows:\n1. Join the 'cards' table with the 'foreign_data' table where the 'uuid' matches.\n2. Filter the 'foreign_data' table for entries where the 'language' is 'Chinese Simplified'.\n3. Select the 'artist' field from the 'cards' table for these matching entries.\n4. Ensure the results are distinct to avoid duplicates.",
        "sql": "SELECT DISTINCT c.artist\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Chinese Simplified';",
        "question": "List down the name of artists for cards in Chinese Simplified.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
        "evidence": [
            "Chinese Simplified' is the language;"
        ]
    },
    "676": {
        "reason": "To solve the question, we need to list all display names of users who are adults. According to the tips provided, adults are defined as users where the age is between 19 and 65. The relevant table for this query is the `users` table, which contains the `DisplayName` and `Age` columns. The query will filter the users based on the age range and return their display names.",
        "sql": "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65;",
        "question": "Please list all display names of users who are adults.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65",
        "evidence": [
            "adults refer to users where Age BETWEEN 19 and 65;"
        ]
    },
    "1348": {
        "reason": "To solve the question, we need to find out how many budgets for the event named \"November Meeting\" have exceeded their allocated amount. The steps are as follows:\n1. Identify the event_id for \"November Meeting\" from the event table.\n2. Use this event_id to find all budgets linked to this event in the budget table.\n3. For each budget, check if the spent amount is greater than the amount allocated (i.e., spent > amount).\n4. Count the number of such budgets where the condition is true.",
        "sql": "SELECT COUNT(*) \nFROM budget \nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'November Meeting') \nAND spent > amount;",
        "question": "For all the budgets for \"November Meeting\", how many of them had exceeded the budget?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.event_id) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Meeting' AND T1.remaining < 0",
        "evidence": [
            "'November Meeting' is an event name; remaining < 0 means the cost had exceeded the budget"
        ]
    },
    "1453": {
        "reason": "To solve the question, we need to list the names of events where the parking cost is less than the average parking cost across all events. Here's the step-by-step reasoning:\n\n1. **Identify Parking Expenses**: First, we need to find all expenses related to parking. This is done by joining the `expense` table with the `budget` table where the `budget.category` is 'Parking'.\n\n2. **Calculate Average Parking Cost**: Next, we calculate the average cost of all parking expenses. This involves summing all parking costs and dividing by the count of parking expenses.\n\n3. **Filter Events with Less Than Average Parking Cost**: We then filter events where the total parking cost for the event is less than the calculated average parking cost.\n\n4. **Retrieve Event Names**: Finally, we retrieve the names of these events from the `event` table.\n\nThe query will involve joins between the `event`, `budget`, and `expense` tables, as well as subqueries to calculate the average parking cost and filter events accordingly.",
        "sql": "WITH ParkingExpenses AS (\n    SELECT e.link_to_event, SUM(e.cost) AS total_parking_cost\n    FROM expense e\n    JOIN budget b ON e.link_to_budget = b.budget_id\n    WHERE b.category = 'Parking'\n    GROUP BY e.link_to_event\n),\nAverageParkingCost AS (\n    SELECT AVG(cost) AS avg_cost\n    FROM expense e\n    JOIN budget b ON e.link_to_budget = b.budget_id\n    WHERE b.category = 'Parking'\n)\nSELECT e.event_name\nFROM event e\nJOIN ParkingExpenses pe ON e.event_id = pe.link_to_event\nJOIN AverageParkingCost ap ON 1=1\nWHERE pe.total_parking_cost < ap.avg_cost;",
        "question": "List the name of events with less than average parking cost.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T2.category = 'Parking' AND T3.cost < (SELECT AVG(cost) FROM expense)",
        "evidence": [
            "name of events refers to event_name; less than average parking cost refers to cost < DIVIDE(SUM(cost), COUNT(event_id)) where category = 'Parking'",
            "parking cost is stored in the expense table, not the budget table; the budget table links to expenses via budget_id.",
            "The average parking cost is calculated across all expenses, not just those linked to parking budgets. Parking expenses are filtered by the budget category 'Parking'.",
            "The average parking cost is calculated from all expenses, not just those linked to parking budgets. Parking expenses are filtered by the budget category 'Parking'."
        ]
    },
    "686": {
        "reason": "To solve the question, we need to identify the total number of posts with views above the average view count. The steps are as follows:\n1. Calculate the average view count across all posts using the `AVG(ViewCount)` function.\n2. Filter the posts where the `ViewCount` is greater than this average.\n3. Count the number of such posts to get the total number.\n\nThe query will use a subquery to compute the average view count and then compare each post's `ViewCount` against this average.",
        "sql": "SELECT COUNT(*) AS TotalPostsAboveAverageViews\nFROM posts\nWHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "question": "Identify the total number of posts with views above average.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "evidence": [
            "views above average refer to ViewCount > AVG(ViewCount);",
            "The query should return individual post IDs rather than a count of posts to identify specific posts with above-average views.",
            "The query should return individual post IDs to identify specific posts with above-average views, not just a count of such posts.",
            "The query should return individual post IDs to identify specific posts with above-average views, not just a count of such posts."
        ]
    },
    "824": {
        "reason": "To identify superheroes who can control wind and list their names in alphabetical order, we need to follow these steps:\n1. Identify the `power_name` 'Wind Control' in the `superpower` table to get its `id`.\n2. Use the `hero_power` table to find all `hero_id` values associated with this power.\n3. Join the `superhero` table with the results from the previous step to get the names of these superheroes.\n4. Order the results alphabetically by `superhero_name`.",
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Wind Control'\nORDER BY s.superhero_name ASC;",
        "question": "Identify superheroes who can control wind and list their names in alphabetical order.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Wind Control' ORDER BY T1.superhero_name",
        "evidence": [
            "superheroes refers to superhero_name; can control wind refers to power_name = 'Wind Control';"
        ]
    },
    "1059": {
        "reason": "To solve the question, we need to list player names whose height is greater than 180. The height information is stored in the `Player` table under the `height` column. The query will involve selecting the `player_name` from the `Player` table where the `height` is greater than 180.",
        "sql": "SELECT player_name FROM Player WHERE height > 180;",
        "question": "Please list player names which are higher than 180.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE height > 180",
        "evidence": [
            "height>180;"
        ]
    },
    "1449": {
        "reason": "To solve the question, we need to find the names and majors of members who had expenses exceeding $100. This involves joining the `member` table with the `expense` table to filter for expenses with a cost greater than 100. Additionally, we need to join the `major` table to get the major names for these members. The steps are:\n1. Join the `member` table with the `expense` table on `member_id`.\n2. Filter the results where the `cost` in the `expense` table is greater than 100.\n3. Join the result with the `major` table to get the major names.\n4. Select the `first_name`, `last_name`, and `major_name` columns.",
        "sql": "SELECT m.first_name, m.last_name, ma.major_name\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE e.cost > 100;",
        "question": "What is the name and major of members who had to spend more than a hundred dollars on an expense?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.first_name, T1.last_name, T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE T3.cost > 100",
        "evidence": [
            "full name refers to first_name, last_name; major of members refers to major_name; spend more than a hundred dollars on an expense refers to cost > 100"
        ]
    },
    "101": {
        "reason": "To solve the question, we need to find the accounts with the earliest trading date in the year 1995 from the `trans` table. The steps are as follows:\n1. Filter the `trans` table to include only records from the year 1995.\n2. Order these records by the `date` column in ascending order to get the earliest date first.\n3. Use the `LIMIT` clause to retrieve only the earliest record(s).\n4. Select the `account_id` from these records to identify the accounts with the earliest trading date in 1995.",
        "sql": "SELECT account_id FROM trans WHERE strftime('%Y', date) = '1995' ORDER BY date ASC LIMIT 1;",
        "question": "List out the accounts who have the earliest trading date in 1995 ?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1",
        "evidence": [
            "",
            "The `trans` table contains the trading dates, and the earliest date can be directly queried without joining the `account` table. The `ORDER BY` and `LIMIT` clauses are used to retrieve the earliest record.",
            "The `trans` table records trading dates, and the earliest date in a specific year can be retrieved using `ORDER BY` and `LIMIT` without needing a subquery or additional filtering."
        ]
    },
    "160": {
        "reason": "To solve the question, we need to find the number of weekly issuance accounts that have a loan of under 200,000. Here's the step-by-step reasoning:\n\n1. **Identify weekly issuance accounts**: The `account` table has a column `frequency` where the value 'POPLATEK TYDNE' indicates weekly issuance.\n2. **Find accounts with loans under 200,000**: The `loan` table contains loan information, including the `amount` column. We need to filter loans where `amount` is less than 200,000.\n3. **Join the tables**: We need to join the `account` table with the `loan` table on `account_id` to find accounts that meet both criteria (weekly issuance and loan under 200,000).\n4. **Count the distinct accounts**: Finally, we count the distinct `account_id` values to get the number of such accounts.",
        "sql": "SELECT COUNT(DISTINCT a.account_id) AS weekly_accounts_with_loan_under_200000\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND l.amount < 200000;",
        "question": "Among the weekly issuance accounts, how many have a loan of under 200000?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.amount < 200000",
        "evidence": [
            "frequency = 'POPLATEK TYDNE' stands for weekly issuance"
        ]
    },
    "1291": {
        "reason": "To solve the question, we need to count the number of distinct male patients who have at least one laboratory test result where both albumin (ALB) and total protein (TP) levels are within the normal range. The normal range for albumin is between 3.5 and 5.5, and for total protein, it is between 6.0 and 8.5. We will join the `Patient` table with the `Laboratory` table to filter for male patients and then check for the normal levels in the laboratory results.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' \nAND L.ALB > 3.5 AND L.ALB < 5.5 \nAND L.TP BETWEEN 6.0 AND 8.5;",
        "question": "How many male patients have a normal level of both albumin and total protein?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M'  AND T2.ALB > 3.5 AND T2.ALB < 5.5 AND T2.TP BETWEEN 6.0 AND 8.5",
        "evidence": [
            "male refers to Sex = 'M'; normal level of both albumin and total protein refers to ALB > 3.5 and ALB < 5.5 AND TP between 6.0 and 8.5;",
            "The `Laboratory` table contains multiple test records per patient, so filtering for normal levels requires ensuring the latest test results are considered.",
            "The `Laboratory` table contains multiple test records per patient, but the query does not require filtering for the latest test results; it only needs to check if any test meets the criteria.",
            "The query requires counting distinct male patients with any test meeting the criteria for normal albumin and total protein levels, not just the latest test."
        ]
    },
    "1462": {
        "reason": "To find the category and the budgeted amount for the 'January Speaker' event, we need to follow these steps:\n1. Identify the event_id of the 'January Speaker' event from the 'event' table.\n2. Use this event_id to find the corresponding budget record in the 'budget' table.\n3. Retrieve the 'category' and 'amount' fields from the budget record associated with the event.\n\nThe query will involve joining the 'event' and 'budget' tables to link the event name to its budget details.",
        "sql": "SELECT b.category, b.amount\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'January Speaker';",
        "question": "What category was budgeted for the 'January Speaker' event and how much was the amount budgeted for that category?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category, T2.amount FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'January Speaker'",
        "evidence": [
            "amount budgeted refers to amount, 'January Speaker' is the event name;"
        ]
    },
    "177": {
        "reason": "To solve the question, we need to follow these steps:\n1. Identify the account associated with client number 4 by joining the `client`, `disp`, and `account` tables.\n2. Find the transaction with ID 851 for this account from the `trans` table.\n3. Retrieve the balance after this transaction to determine the sum.\n4. Check the gender of the client (from the `client` table) to determine if the account owner is a man or a woman.\n\nThe query will involve joining multiple tables to gather the required information.",
        "sql": "SELECT \n    t.balance AS sum_after_transaction,\n    c.gender AS account_owner_gender\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    client c ON d.client_id = c.client_id\nWHERE \n    c.client_id = 4\n    AND t.trans_id = 851;",
        "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
        "evidence": [
            ""
        ]
    },
    "987": {
        "reason": "To solve the question, we need to find the average fastest lap time of the top 10 drivers in the 2006 United States Grand Prix. Here's the step-by-step reasoning:\n\n1. **Identify the race**: First, we need to find the raceId for the 2006 United States Grand Prix from the `races` table.\n2. **Identify the top 10 drivers**: We need to determine the top 10 drivers based on their finishing positions in the race. This can be found in the `results` table, where the `raceId` matches the identified race and the `position` is within the top 10.\n3. **Extract fastest lap times**: For these top 10 drivers, we need to retrieve their fastest lap times from the `results` table.\n4. **Calculate the average**: Finally, we calculate the average of these fastest lap times.\n\nThe query will involve joining the `races` and `results` tables to filter the relevant data and then computing the average.",
        "sql": "SELECT AVG(fastestLapTime) AS average_fastest_lap_time\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE year = 2006 AND name = 'United States Grand Prix')\nAND position <= 10\nAND fastestLapTime IS NOT NULL;",
        "question": "What is the average fastest lap time of the top 10 drivers in the 2006 United States Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.fastestLapTime) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank < 11 AND T2.year = 2006 AND T2.name = 'United States Grand Prix'",
        "evidence": [
            "top 10 refers to rank <11; AVG(fastestLapTime);"
        ]
    },
    "218": {
        "reason": "To solve the question, we need to determine the percentage of carcinogenic-type molecules (label = '+') that do not contain fluorine (element = 'f'). Here's the step-by-step reasoning:\n\n1. **Identify carcinogenic molecules**: Filter the `molecule` table for molecules where `label = '+'`.\n2. **Check for fluorine-containing molecules**: Join the `molecule` table with the `atom` table to identify molecules that contain fluorine (element = 'f').\n3. **Count total carcinogenic molecules**: Count the distinct `molecule_id` values from the filtered carcinogenic molecules.\n4. **Count carcinogenic molecules without fluorine**: Subtract the count of carcinogenic molecules with fluorine from the total count of carcinogenic molecules.\n5. **Calculate the percentage**: Divide the count of carcinogenic molecules without fluorine by the total count of carcinogenic molecules and multiply by 100.\n\nWe will use conditional aggregation and joins to ensure the calculations are consistent and accurate.",
        "sql": "SELECT \n    (COUNT(DISTINCT m.molecule_id) - COUNT(DISTINCT CASE WHEN a.element = 'f' THEN m.molecule_id END)) * 100.0 / \n    COUNT(DISTINCT m.molecule_id) AS percentage\nFROM \n    molecule m\nLEFT JOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = '+'",
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "evidence": [
            "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;",
            "To calculate percentages, ensure the numerator and denominator are derived from the same dataset to maintain consistency. Use conditional aggregation (CASE WHEN) to filter specific criteria directly within the calculation.",
            "To determine if a molecule contains fluorine, join the atom table with the molecule table and filter by element = 'f'.\nEnsure the percentage calculation uses the same dataset for both numerator and denominator by joining tables consistently.\nUse DISTINCT to avoid counting duplicate molecules when aggregating.",
            "To calculate percentages, ensure the numerator and denominator are derived from the same dataset by joining tables consistently. Use conditional aggregation (CASE WHEN) to filter specific criteria directly within the calculation."
        ]
    },
    "1443": {
        "reason": "To solve the question, we need to retrieve the event ID, location, and status of events that were conducted between November 2019 and March 2020. The `event_date` column in the `event` table stores the date of the event, which we will use to filter the events within the specified date range. The date format in the database is not specified, but we will assume it is in a standard format (e.g., YYYY-MM-DD) for comparison. We will use the `BETWEEN` operator to filter events within the date range from '2019-11-01' to '2020-03-31'.",
        "sql": "SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';",
        "question": "Give the event ID, location, and status of events conducted from November 2019 to March 2020.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT event_id, location, status FROM event WHERE date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-11-01' AND '2020-03-31'",
        "evidence": [
            "event_date BETWEEN '2019-11-01' and '2020-03-31'"
        ]
    },
    "307": {
        "reason": "To solve the question, we need to find the elements of the atoms involved in the bond with the ID `TR000_2_3`. The `connected` table links atoms via bonds, and the `atom` table contains the element information for each atom. We will join the `connected` table with the `atom` table to retrieve the elements of the atoms connected by the bond `TR000_2_3`. Since the `connected` table includes both `atom_id` and `atom_id2`, we will join it with the `atom` table once, focusing on either `atom_id` or `atom_id2` to avoid redundancy. The query will filter the results to only include the bond with the ID `TR000_2_3`.",
        "sql": "SELECT a.element FROM connected c JOIN atom a ON c.atom_id = a.atom_id WHERE c.bond_id = 'TR000_2_3' UNION SELECT a.element FROM connected c JOIN atom a ON c.atom_id2 = a.atom_id WHERE c.bond_id = 'TR000_2_3';",
        "question": "Name the atoms' elements that form bond TR000_2_3.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3'",
        "evidence": [
            "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
            "The `connected` table links atoms via a bond, but only one atom's element is required for the query.\nTo retrieve elements of atoms involved in a bond, join `connected` with `atom` once, not twice.",
            "The `connected` table includes both `atom_id` and `atom_id2`, but the query only requires the element of one atom linked to the bond.\nTo retrieve elements of atoms involved in a bond, join `connected` with `atom` once, focusing on either `atom_id` or `atom_id2`."
        ]
    },
    "838": {
        "reason": "To find the full name of the superhero named 'Alien', we need to query the `superhero` table where the `superhero_name` is 'Alien'. The `full_name` column in the `superhero` table contains the full name of the superhero. The query will filter the `superhero` table for the record where `superhero_name` is 'Alien' and return the `full_name`.",
        "sql": "SELECT full_name FROM superhero WHERE superhero_name = 'Alien';",
        "question": "Provide the full name of the superhero named Alien.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT full_name FROM superhero WHERE superhero_name = 'Alien'",
        "evidence": [
            ""
        ]
    },
    "328": {
        "reason": "To solve the question, we need to list all elements with double bonds in the molecule TR024. The steps are as follows:\n1. Identify the molecule TR024 in the `molecule` table.\n2. Join the `atom` table with the `bond` table using the `molecule_id` to find atoms in TR024 that are part of double bonds.\n3. Filter the bonds to only include those with `bond_type = '='` (double bonds).\n4. Retrieve the `element` column from the `atom` table for these atoms.\n\nThe query will involve joining the `atom` and `bond` tables on `molecule_id` and filtering for the specific molecule and bond type.",
        "sql": "SELECT DISTINCT a.element\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.molecule_id = 'TR024' AND b.bond_type = '=';",
        "question": "List all the elements with double bond, consisted in molecule TR024.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='",
        "evidence": [
            "double bond refers to bond_type = '='; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
            "To identify elements with specific bond types, join the `atom` and `bond` tables directly via `molecule_id`.\nDouble bonds are filtered using `bond_type = '='` in the `bond` table."
        ]
    },
    "1019": {
        "reason": "To find the average lap time in milliseconds of all lap records set on circuits in Italy, we need to:\n1. Identify circuits located in Italy from the `circuits` table.\n2. Join the `circuits` table with the `races` table to find races held on these circuits.\n3. Join the `races` table with the `lapTimes` table to get lap times for these races.\n4. Calculate the average of the `milliseconds` column from the `lapTimes` table for these records.",
        "sql": "SELECT AVG(l.milliseconds) AS average_lap_time_ms\nFROM lapTimes l\nJOIN races r ON l.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Italy';",
        "question": "What is the average lap time in milliseconds of all the lap records set on the various circuits in Italy?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy'",
        "evidence": [
            "average = AVG(milliseconds)"
        ]
    },
    "728": {
        "reason": "To solve the question, we need to rank superheroes from Marvel Comics by the popularity of their eye colors, starting with the most common color. Here's the step-by-step reasoning:\n\n1. **Identify Marvel Comics superheroes**: Filter superheroes where the `publisher_id` corresponds to 'Marvel Comics' in the `publisher` table.\n2. **Count superheroes per eye color**: Group the filtered superheroes by their `eye_colour_id` and count the number of superheroes in each group.\n3. **Rank eye colors by popularity**: Use the `RANK()` window function to assign a rank to each eye color based on the count of superheroes in descending order.\n4. **Join with the `colour` table**: To get the actual color names instead of IDs.\n5. **Order the results**: Display the results starting with the most common eye color (highest count).",
        "sql": "SELECT \n    c.colour AS eye_color,\n    COUNT(s.id) AS superhero_count,\n    RANK() OVER (ORDER BY COUNT(s.id) DESC) AS popularity_rank\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    colour c ON s.eye_colour_id = c.id\nWHERE \n    p.publisher_name = 'Marvel Comics'\nGROUP BY \n    s.eye_colour_id, c.colour\nORDER BY \n    superhero_count DESC;",
        "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
        "evidence": [
            "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; most common color refers to COUNT(superhero.id) DESC;",
            "The ranking of eye colors requires the use of a window function like RANK() to assign a rank based on the count of superheroes per eye color.\nThe query must include the RANK() function to order the results by the count of superheroes in descending order."
        ]
    },
    "327": {
        "reason": "To solve the question, we need to identify non-carcinogenic molecules that consist of more than 5 atoms. Here's the step-by-step reasoning:\n\n1. **Identify non-carcinogenic molecules**: These are molecules where the `label` is '-' in the `molecule` table.\n2. **Count atoms per molecule**: For each molecule, count the number of atoms in the `atom` table.\n3. **Filter molecules with more than 5 atoms**: Only include molecules where the count of atoms is greater than 5.\n4. **Combine the conditions**: Join the `molecule` table with the `atom` table, filter for non-carcinogenic molecules, group by `molecule_id`, and apply the count condition.\n\nThe final SQL query will involve:\n- Joining the `molecule` and `atom` tables.\n- Filtering for `label = '-'`.\n- Grouping by `molecule_id`.\n- Using `HAVING COUNT(atom_id) > 5` to ensure the molecule has more than 5 atoms.",
        "sql": "SELECT m.molecule_id, m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '-'\nGROUP BY m.molecule_id, m.label\nHAVING COUNT(a.atom_id) > 5;",
        "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
        "evidence": [
            "label = '-' means molecules are non-carcinogenic; molecules consisted more than 5 atoms refers to COUNT(molecule_id) > 5",
            "The `molecule_id` is the primary key in the `molecule` table and is used to link atoms in the `atom` table.\nNon-carcinogenic molecules are identified by `label = '-'` in the `molecule` table.\nCounting atoms per molecule requires grouping by `molecule_id` and filtering for counts greater than 5.",
            "The `molecule_id` in the `atom` table links atoms to their respective molecules, allowing aggregation of atom counts per molecule.\nNon-carcinogenic molecules are filtered using `label = '-'` in the `molecule` table.\nSubqueries can be used to structure the aggregation and filtering steps clearly.",
            "The `molecule_id` in the `atom` table links atoms to their respective molecules, allowing aggregation of atom counts per molecule.\nNon-carcinogenic molecules are filtered using `label = '-'` in the `molecule` table.\nSubqueries can be used to structure the aggregation and filtering steps clearly."
        ]
    },
    "630": {
        "reason": "To find the name of tags used by John Salvatier, we need to follow these steps:\n1. Identify the user with the display name 'John Salvatier' in the `users` table to get their `Id`.\n2. Use this `Id` to find all posts owned by this user in the `posts` table.\n3. Extract the `Tags` from these posts, which contain the tags used by the user.\n4. Since the `Tags` field in the `posts` table is a text field containing multiple tags, we might need to parse it to get individual tag names.\n5. Alternatively, if the tags are stored in a normalized form in the `tags` table, we can join the `posts` table with the `tags` table to get the tag names.\n\nGiven the schema, the `Tags` field in the `posts` table is a text field, so we will directly extract and display the tags from the posts owned by John Salvatier.",
        "sql": "SELECT DISTINCT p.Tags\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'John Salvatier';",
        "question": "What is the name of tags used by John Salvatier's?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'John Salvatier'",
        "evidence": [
            "DisplayName = 'John Salvatier';"
        ]
    },
    "276": {
        "reason": "To solve the question, we need to find the atom IDs of the first and second atoms involved in triple bonds. The steps are as follows:\n1. Identify bonds with `bond_type = '#'` (triple bonds) from the `bond` table.\n2. Use the `connected` table to find the pairs of atoms (`atom_id` and `atom_id2`) connected by these triple bonds.\n3. Join the `bond` and `connected` tables on `bond_id` to filter for triple bonds.\n4. Select the `atom_id` and `atom_id2` from the `connected` table for these bonds.",
        "sql": "SELECT c.atom_id, c.atom_id2\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '#';",
        "question": "Write down the atom IDs of the first and second atoms of triple bond type molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "evidence": [
            "first atom refers to atom_id; second atom refers to atom_id2; triple bond refers to bond_type = '#';"
        ]
    },
    "1069": {
        "reason": "To find the football player with the shortest height, we need to query the `Player` table. The `height` column in this table stores the height of each player. By ordering the players by their height in ascending order and limiting the result to the first row, we can identify the player with the shortest height. The `player_name` column will be included in the result to display the name of the player.",
        "sql": "SELECT player_name FROM Player ORDER BY height ASC LIMIT 1;",
        "question": "Which football player has the shortest height?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM player ORDER BY height ASC LIMIT 1",
        "evidence": [
            "shortest height refers to MIN(height);",
            "To retrieve the player with the shortest height, use ORDER BY with ASC and LIMIT 1 to ensure only the smallest value is returned.",
            "The `player_name` column is sufficient for identifying the player with the shortest height, eliminating the need to include the `height` column in the result set."
        ]
    },
    "1066": {
        "reason": "To find the passing class of the CLB team, we need to follow these steps:\n1. Identify the team_api_id of the team with the short name 'CLB' from the Team table.\n2. Use this team_api_id to query the Team_Attributes table for the buildUpPlayPassingClass attribute.\n3. Ensure the result is distinct to avoid duplicates.\n\nThe query will join the Team and Team_Attributes tables to fetch the required information.",
        "sql": "SELECT DISTINCT ta.buildUpPlayPassingClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_short_name = 'CLB';",
        "question": "What is the passing class of CLB team?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'CLB'",
        "evidence": [
            "passing class refers to buildUpPlayPassingClass; CLB refers to team_short_name = 'CLB';",
            "The `buildUpPlayPassingClass` attribute is stored in the `Team_Attributes` table and linked to teams via `team_api_id`.\nTo ensure uniqueness, use `DISTINCT` when querying attributes to avoid duplicate results."
        ]
    },
    "756": {
        "reason": "To find the number of bad superheroes, we need to identify superheroes whose `alignment_id` corresponds to 'Bad' in the `alignment` table. The steps are:\n1. Join the `superhero` table with the `alignment` table to match superheroes with their alignment.\n2. Filter the results where the `alignment` is 'Bad'.\n3. Count the number of such superheroes.",
        "sql": "SELECT COUNT(*) AS bad_superheroes_count\nFROM superhero\nWHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'Bad');",
        "question": "How many bad superheroes are there?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Bad'",
        "evidence": [
            "bad superheroes refers to alignment_id = Bad"
        ]
    },
    "1216": {
        "reason": "To solve the question, we need to find all male patients with albumin (ALB) values not within the specified range (ALB <= 3.5 or ALB >= 5.5). The steps are as follows:\n1. Join the `Patient` table with the `Laboratory` table to access both the patient's sex and albumin values.\n2. Filter for male patients (SEX = 'M') and albumin values outside the range.\n3. Ensure distinct patient IDs to avoid duplicates.\n4. Sort the results by the patient's birthday in descending order.",
        "sql": "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.SEX = 'M' AND (l.ALB <= 3.5 OR l.ALB >= 5.5)\nORDER BY p.Birthday DESC;",
        "question": "Sort in descending order all patients by birthday for male patient with albumin not within range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5) ORDER BY T1.Birthday DESC",
        "evidence": [
            "male = SEX = 'M'; albumin not within range refers to ALB < = 3.5 or ALB > = 5.5",
            "The query requires distinct patient IDs to avoid duplicates when joining tables.\nSorting by birthday in descending order should be applied to the final distinct patient list.",
            "The query should only return distinct patient IDs to avoid duplicates, as specified in the target SQL.\nThe sorting by birthday in descending order must be applied to the distinct patient IDs."
        ]
    },
    "1389": {
        "reason": "To find the event with the lowest cost, we need to follow these steps:\n1. **Understand the relationships**: The cost is stored in the `expense` table, which is linked to the `budget` table via `link_to_budget`. The `budget` table is then linked to the `event` table via `link_to_event`.\n2. **Join the tables**: We need to join the `expense`, `budget`, and `event` tables to connect the cost to the event name.\n3. **Find the lowest cost**: Instead of using `MIN(cost)` directly, we can sort the expenses by cost in ascending order and limit the result to 1 row to get the event with the lowest cost.\n4. **Return the event name**: The query should return the `event_name` from the `event` table corresponding to the lowest cost.",
        "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nORDER BY ex.cost ASC\nLIMIT 1;",
        "question": "Which event has the lowest cost?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
        "evidence": [
            "event refers to event_name; lowest cost means MIN(cost)",
            "To find the lowest cost, use ORDER BY with LIMIT 1 instead of a subquery with MIN.\nThe link between event and expense is indirect via budget, requiring a two-step join.\nThe query should return only one row with the event_name corresponding to the lowest cost."
        ]
    },
    "1128": {
        "reason": "To determine which country's players have the heaviest average weights, we need to follow these steps:\n1. **Link Players to Countries**: The `Player` table contains player weights, but it doesn't directly link to countries. The `Match` table connects players to countries via `country_id`.\n2. **Avoid Duplication**: To avoid counting the same player multiple times, we will use a single player reference per match (e.g., `home_player_1`).\n3. **Calculate Average Weight**: We will calculate the average weight of players for each country.\n4. **Identify the Heaviest Average**: We will find the country with the highest average player weight.\n\nThe query will join the `Player` table with the `Match` table to associate players with their countries, then group by country to calculate the average weight, and finally order the results to find the heaviest average.",
        "sql": "SELECT c.name AS country_name, AVG(p.weight) AS average_weight\nFROM Player p\nJOIN Match m ON p.player_api_id = m.home_player_1\nJOIN Country c ON m.country_id = c.id\nGROUP BY c.name\nORDER BY average_weight DESC\nLIMIT 1;",
        "question": "Which country's players have the heaviest average weights?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id GROUP BY t1.name ORDER BY AVG(t3.weight) DESC LIMIT 1",
        "evidence": [
            "heaviest average weights refers to MAX(AVG(weight))",
            "To associate players with their countries, use the direct link between `Player` and `Match` via player IDs in the `Match` table.\nThe `Match` table connects to `Country` through `country_id`, allowing aggregation by country.\nFor average weight calculations, focus on a single player reference per match to avoid duplication.",
            "To avoid duplication, use a single player reference per match (e.g., `home_player_1`) rather than all player positions.\nThe `Match` table directly links to `Country` via `country_id`, simplifying the join path for country association.",
            "To calculate the heaviest average weight, ensure the join path correctly links `Player` to `Country` via `Match` without omitting intermediate steps.\nThe `Match` table serves as the bridge between `Player` and `Country`, requiring explicit joins to both tables.\nAggregation by country must include all relevant player references to avoid missing data."
        ]
    },
    "486": {
        "reason": "To find the percentage of cards with a converted mana cost of 7 in the set Coldsnap, we need to follow these steps:\n1. Identify the total number of cards in the Coldsnap set.\n2. Identify the number of cards in the Coldsnap set with a converted mana cost of 7.\n3. Calculate the percentage by dividing the number of cards with a converted mana cost of 7 by the total number of cards in the set, then multiplying by 100.\n\nThe query will involve joining the `cards` table with the `sets` table to filter cards by the set code 'Coldsnap' (assuming the set code is 'CSP' or similar).",
        "sql": "SELECT \n    (COUNT(CASE WHEN c.convertedManaCost = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards c\nJOIN \n    sets s ON c.setCode = s.code\nWHERE \n    s.code = 'CSP';",
        "question": "What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "evidence": [
            "converted mana cost of 7 refers to convertedManaCost = 7; card set Coldsnap refers to name = 'Coldsnap'; percentage = DIVIDE(SUM(convertedManaCost = 7), SUM(convertedManaCost))*100"
        ]
    },
    "1048": {
        "reason": "To find the overall rating of the football player Gabriel Tamas in the year 2011, we need to follow these steps:\n1. Identify the player_api_id of Gabriel Tamas from the Player table.\n2. Use this player_api_id to find his attributes in the Player_Attributes table for the year 2011.\n3. Extract the overall_rating from the Player_Attributes table for the specified year.\n\nThe query will involve joining the Player and Player_Attributes tables and filtering for the specific player and year.",
        "sql": "SELECT pa.overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Gabriel Tamas' AND strftime('%Y', pa.date) = '2011';",
        "question": "What is the overall rating of the football player Gabriel Tamas in year 2011?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Gabriel Tamas' AND strftime('%Y', t2.date) = '2011'",
        "evidence": [
            "in year 2011 refers to strftime('%Y', date) = '2011';"
        ]
    },
    "1203": {
        "reason": "To solve the question, we need to find the number of female patients (SEX = 'F') who have white blood cell (WBC) counts below 3.5. The steps are as follows:\n1. Join the `Patient` table with the `Laboratory` table on the `ID` field to link patient information with their laboratory results.\n2. Filter the results to include only female patients (SEX = 'F').\n3. Further filter the results to include only those records where the WBC value is below 3.5.\n4. Count the distinct patient IDs to ensure each patient is counted only once, even if they have multiple laboratory entries meeting the criteria.",
        "sql": "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p \nJOIN Laboratory l ON p.ID = l.ID \nWHERE p.SEX = 'F' AND l.WBC < 3.5;",
        "question": "How many patients who were female got white blood cells that were below 3.5?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC < 3.5 AND T1.SEX = 'F'",
        "evidence": [
            "female refers to SEX = 'F'; white blood cells that were below 3.5 refers to WBC < 3.5",
            "The `Laboratory` table contains multiple entries per patient, so joining with `Patient` requires ensuring each patient is counted only once.\nThe `WBC` field in the `Laboratory` table is of type REAL, allowing for decimal comparisons like < 3.5.\nThe `SEX` field in the `Patient` table uses 'F' to denote female patients.",
            "The `Laboratory` table contains multiple entries per patient, so joining with `Patient` requires ensuring each patient is counted only once.\nThe `WBC` field in the `Laboratory` table is of type REAL, allowing for decimal comparisons like < 3.5.\nThe `SEX` field in the `Patient` table uses 'F' to denote female patients."
        ]
    },
    "1210": {
        "reason": "To solve the question, we need to calculate the average index of lactate dehydrogenase (LDH) for all patients where the LDH value is within the normal range (LDH < 500). The LDH values are stored in the Laboratory table. We will use the AVG function to compute the average of LDH values that meet the condition (LDH < 500). The query will filter the Laboratory table to include only records where LDH is less than 500 and then compute the average of these values.",
        "sql": "SELECT AVG(LDH) AS average_LDH FROM Laboratory WHERE LDH < 500;",
        "question": "What is the average index of the lactate dehydrogenase (LDH) for all patients with lactate dehydrogenase (LDH) within the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(LDH) FROM Laboratory WHERE LDH < 500",
        "evidence": [
            "average index of the lactate dehydrogenase (LDH) refers to AVG(LDH); (LDH) within the normal range refers to LDH < 500"
        ]
    },
    "385": {
        "reason": "To find the ruling of the card \"Beacon of Immortality\", we need to query the `rulings` table. However, the `rulings` table references the `cards` table via the `uuid` column. Therefore, we first need to find the `uuid` of the card \"Beacon of Immortality\" from the `cards` table. Once we have the `uuid`, we can use it to retrieve the ruling text from the `rulings` table. The steps are:\n1. Query the `cards` table to get the `uuid` of the card with the name \"Beacon of Immortality\".\n2. Use this `uuid` to query the `rulings` table for the ruling text.",
        "sql": "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Beacon of Immortality';",
        "question": "Write down the ruling of Beacon of Immortality.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "evidence": [
            "Beacon of Immortality' is the name of card;"
        ]
    },
    "946": {
        "reason": "To solve the question, we need to retrieve the coordinates (latitude and longitude) of circuits located in the USA. The schema indicates that the `circuits` table contains the relevant columns: `lat` (latitude), `lng` (longitude), and `country`. The question specifies that the country should be 'USA'. Therefore, the query should select the `lat` and `lng` columns from the `circuits` table where the `country` column is 'USA'.",
        "sql": "SELECT lat, lng FROM circuits WHERE country = 'USA';",
        "question": "Please list the location coordinates of the US circuits.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT lat, lng FROM circuits WHERE country = 'USA'",
        "evidence": [
            "location coordinates refers to (lat, lng); the US refers to country = 'USA';",
            "The query should focus solely on retrieving the coordinates (lat, lng) without additional columns like name."
        ]
    },
    "817": {
        "reason": "To solve the question, we need to find the race of blue-haired male superheroes. Here's the step-by-step reasoning:\n\n1. **Identify the required tables**: We need data from the `superhero`, `colour`, `gender`, and `race` tables.\n2. **Join the tables**:\n   - Join `superhero` with `colour` to filter by hair colour (blue).\n   - Join `superhero` with `gender` to filter by gender (male).\n   - Join `superhero` with `race` to retrieve the race of the superhero.\n3. **Filter conditions**:\n   - Hair colour must be 'blue' (exact case match).\n   - Gender must be 'male' (exact case match).\n4. **Retrieve the race**: Select the `race` from the `race` table.\n5. **Use table aliases**: For clarity, use aliases like `s` for `superhero`, `c` for `colour`, `g` for `gender`, and `r` for `race`.",
        "sql": "SELECT r.race\nFROM superhero s\nJOIN colour c ON s.hair_colour_id = c.id\nJOIN gender g ON s.gender_id = g.id\nJOIN race r ON s.race_id = r.id\nWHERE c.colour = 'blue' AND g.gender = 'male';",
        "question": "Give the race of the blue-haired male superhero.",
        "db_id": "superhero",
        "res": 0,
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T2.colour = 'Blue' AND T4.gender = 'Male'",
        "evidence": [
            "blue-haired refers to colour.colour = 'blue' WHERE hair_colour_id = colour.id; male refers to gender = 'male';",
            "The query must join the superhero table with colour, race, and gender tables to filter by hair colour and gender, then retrieve the race.",
            "The query requires table aliases for clarity and consistency in joins. The filter condition for colour should match the exact case of the stored value (e.g., 'Blue' vs 'blue').",
            "The filter condition for colour and gender must match the exact case of the stored values (e.g., 'Blue' vs 'blue', 'Male' vs 'male'). Table aliases should be used consistently for clarity in joins."
        ]
    },
    "1394": {
        "reason": "To find the number of members in the Student_Club who have a major in 'Physics Teaching', we need to:\n1. Identify the major_id for 'Physics Teaching' from the 'major' table.\n2. Join the 'member' table with the 'major' table using the link_to_major field.\n3. Count the number of members where the major_name is 'Physics Teaching'.",
        "sql": "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Physics Teaching';",
        "question": "How many members of the Student_Club have major in 'Physics Teaching'?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Physics Teaching'",
        "evidence": [
            "'Physics Teaching' is the major_name;"
        ]
    },
    "505": {
        "reason": "To find the Simplified Chinese translation of the set \"Mirrodin\", we need to query the `set_translations` table. The `set_translations` table contains translations for set names in different languages. We will filter the records where the `language` is 'Chinese Simplified' and the `setCode` corresponds to the set \"Mirrodin\". To get the `setCode` for \"Mirrodin\", we first query the `sets` table where the `name` is 'Mirrodin' and then use the `code` from that result to filter the `set_translations` table.",
        "sql": "SELECT st.translation FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE st.language = 'Chinese Simplified' AND s.name = 'Mirrodin';",
        "question": "Show the Simplified Chinese translation of the name of the set \"Mirrodin\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT code FROM sets WHERE name = 'Mirrodin' ) AND language = 'Chinese Simplified'",
        "evidence": [
            "Simplified Chinese translation refers to language = 'Chinese Simplified'; name of the set \"Mirrodin\" refers to name = 'Mirrodin'"
        ]
    },
    "204": {
        "reason": "To solve the question, we need to count the number of carcinogenic molecules among the first 100 molecules in number order. According to the tips, the first 100 molecules have molecule_id values between 'TR000' and 'TR099', and a molecule is carcinogenic if its label is '+'. Therefore, the query should filter molecules where molecule_id is between 'TR000' and 'TR099' and label is '+', then count them.",
        "sql": "SELECT COUNT(*) FROM molecule WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND label = '+';",
        "question": "Of the first 100 molecules in number order, how many are carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'",
        "evidence": [
            "first 100 molecules in number order refers to molecule_id between 'TR000' and 'TR099'; label = '+' means molecules are carcinogenic"
        ]
    },
    "391": {
        "reason": "To solve the question, we need to identify Artifact cards that are black in color and have foreign language translations. Here's the step-by-step reasoning:\n\n1. **Identify Artifact cards**: The `cards` table has a column `originalType` which should be 'Artifact' for Artifact cards.\n2. **Filter for black color**: The `cards` table also has a `colors` column which should contain 'B' for black color.\n3. **Check for foreign language translations**: The `foreign_data` table contains information about foreign language translations. We need to join the `cards` table with the `foreign_data` table to ensure the card has at least one foreign language entry.\n4. **Retrieve card names**: The question asks for the names of the cards, so we will select the `name` column from the `cards` table.\n\nCombining these steps, we will query the `cards` table, filter for Artifact cards with black color, and join with the `foreign_data` table to ensure foreign language presence.",
        "sql": "SELECT DISTINCT c.name\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.originalType = 'Artifact'\nAND c.colors = 'B';",
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "evidence": [
            "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data",
            "The query should focus on retrieving only the card names, not all columns, to match the target output.\nForeign language presence is confirmed by joining with the foreign_data table, but no additional filter on language is needed beyond the join."
        ]
    },
    "1126": {
        "reason": "To find the names of players who came from Belgium, we need to follow these steps:\n1. Identify the country_id for Belgium from the Country table.\n2. Use this country_id to filter matches in the Match table where the country is Belgium.\n3. Extract the player_api_id of the home_player_1 from these matches (as per the tip, only home_player_1 is used).\n4. Join the Player table with these player_api_id values to get the player names.\n\nThe query will involve joining the Country, Match, and Player tables to achieve this.",
        "sql": "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Match m ON p.player_api_id = m.home_player_1\nJOIN Country c ON m.country_id = c.id\nWHERE c.name = 'Belgium';",
        "question": "State the name of players who came from Belgium.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Belgium'",
        "evidence": [
            "name of players refers to player_name; Belgium is name of country",
            "Players are linked to matches via their player_api_id in the Match table, not through teams. The country_id in the Match table directly links to the Country table, bypassing the need for League or Team tables.",
            "The Match table links players to countries via country_id, but only home_player_1 is used in the correct query, not all player positions."
        ]
    },
    "1465": {
        "reason": "To determine which budget category the expense 'Posters' falls under, we need to follow these steps:\n1. Identify the expense 'Posters' in the `expense` table using the `expense_description` column.\n2. Retrieve the `link_to_budget` associated with this expense.\n3. Use the `link_to_budget` to find the corresponding budget record in the `budget` table.\n4. Extract the `category` from the budget record to determine the category of the expense.",
        "sql": "SELECT b.category\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nWHERE e.expense_description = 'Posters';",
        "question": "Which budget category does the expense 'Posters' fall to?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Posters'",
        "evidence": [
            "'Posters' refers to expense description"
        ]
    },
    "952": {
        "reason": "To find which constructors have been ranked 1, we need to look at the `results` table, which includes a `rank` column indicating the rank of a constructor in a race. We will query the `results` table to find all entries where the `rank` is 1. Then, we will join this with the `constructors` table to get the names of these constructors. The query will filter for `rank = 1` and return the distinct constructor names to avoid duplicates.",
        "sql": "SELECT DISTINCT c.name\nFROM constructors c\nJOIN results r ON c.constructorId = r.constructorId\nWHERE r.rank = 1;",
        "question": "Which constructors have been ranked 1?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.rank = 1",
        "evidence": [
            "",
            "The `results` table includes a `rank` column that indicates the rank of a constructor in a race, which can be used to identify top-ranked constructors.\nThe `constructorStandings` table tracks standings over time, while the `results` table captures race-specific rankings."
        ]
    },
    "138": {
        "reason": "To solve the question, we need to find the branch (district) where the second-highest number of crimes were committed in 1995 (A15 column in the district table) and then count the number of male clients in that district. Here's the step-by-step reasoning:\n\n1. Identify the district with the second-highest number of crimes in 1995 (A15 column).\n2. Use this district_id to find all clients (from the client table) who are male (gender = 'M') and belong to this district.\n3. Count the number of such male clients.\n\nThe SQL query will involve:\n- Subquery to find the district_id with the second-highest A15 value.\n- Joining the client table to filter male clients in this district.\n- Counting the results.",
        "sql": "WITH SecondHighestCrimeDistrict AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A15 DESC\n    LIMIT 1 OFFSET 1\n)\nSELECT COUNT(*) AS male_clients_count\nFROM client\nWHERE gender = 'M' AND district_id = (SELECT district_id FROM SecondHighestCrimeDistrict);",
        "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
        "evidence": [
            "Male refers to gender = 'M'; A15 stands for no. of commited crimes 1995"
        ]
    },
    "420": {
        "reason": "To solve the question, we need to count the number of cards that meet three specific conditions: they are oversized, reprinted, and printed for promotions. These conditions correspond to the columns `isOversized`, `isReprint`, and `isPromo` in the `cards` table. All three columns are of type INTEGER with a default value of 0, and a value of 1 indicates that the condition is true. Therefore, we need to count the rows where all three columns have a value of 1.",
        "sql": "SELECT COUNT(*) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1;",
        "question": "How many cards are oversized, reprinted, and printed for promotions?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1",
        "evidence": [
            "are oversized refers to isOversized = 1; reprinted refers to isReprint = 1; printed for promotions refers to isPromo = 1"
        ]
    },
    "472": {
        "reason": "To solve the question, we need to find the number of sets in the block \"Ice Age\" that have an Italian translation. This involves two main steps:\n1. Identify all sets in the \"Ice Age\" block from the `sets` table.\n2. Check which of these sets have an Italian translation in the `set_translations` table (where `language` is 'Italian' and `translation` is not null).\n\nWe will join the `sets` and `set_translations` tables to filter the sets in the \"Ice Age\" block and then count those with Italian translations.",
        "sql": "SELECT COUNT(DISTINCT s.code) AS italian_translated_sets_count\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Ice Age' AND st.language = 'Italian' AND st.translation IS NOT NULL;",
        "question": "Among the sets in the block \"Ice Age\", how many of them have an Italian translation?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block = 'Ice Age' AND T2.language = 'Italian' AND T2.translation IS NOT NULL",
        "evidence": [
            "sets in the block \"Ice Age\" refers to block = 'Ice Age'; Italian translation refers to language = 'Italian' and translation is not null"
        ]
    },
    "1189": {
        "reason": "To solve the question, we need to follow these steps:\n1. Identify patients with Thrombosis level 2 (Thrombosis = 2) and ANA Pattern 'S'.\n2. Calculate the average level of `aCL IgM` for these patients.\n3. Determine the threshold for 20% higher than this average.\n4. Count the number of patients whose `aCL IgM` level is above this threshold.\n\nThe query will involve filtering the Examination table for the specified conditions, calculating the average, and then counting the qualifying patients.",
        "sql": "WITH FilteredPatients AS (\n    SELECT ID, `aCL IgM`\n    FROM Examination\n    WHERE Thrombosis = 2 AND `ANA Pattern` = 'S'\n),\nAverageIgM AS (\n    SELECT AVG(`aCL IgM`) AS avg_igm\n    FROM FilteredPatients\n)\nSELECT COUNT(*) AS PatientCount\nFROM FilteredPatients, AverageIgM\nWHERE `aCL IgM` > (avg_igm * 1.2);",
        "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')",
        "evidence": [
            "thrombosis level 2 refers to Thrombosis = 2; ANA pattern of only S refers to ANA = 'S'; average anti-Cardiolip in antibody (IgM) refers to AVG(`aCL IgM`); calculation = MULTIPLY(AVG + AVG, 0.2)",
            "The `ANA Pattern` column, not `ANA`, stores the pattern value 'S'.\nThe calculation for 20% higher than average should use the average from the same filtered subset (Thrombosis = 2 and `ANA Pattern` = 'S')."
        ]
    },
    "1362": {
        "reason": "To find the number of cities in Orange County, Virginia, we need to query the `zip_code` table. The `zip_code` table contains columns for `county` and `state`, which we can use to filter the data. Specifically, we need to count the distinct `city` values where the `county` is 'Orange County' and the `state` is 'Virginia'.",
        "sql": "SELECT COUNT(DISTINCT city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia';",
        "question": "How many cities are there in Orange County, Virginia?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia'",
        "evidence": [
            "Orange County is the county name, Virginia is the state name"
        ]
    },
    "392": {
        "reason": "To solve the question, we need to find 3 cards with a rarity of 'uncommon' and list their names in ascending order of their ruling dates. Here's the step-by-step reasoning:\n\n1. **Filter by Rarity**: First, we need to select cards from the `cards` table where the `rarity` is 'uncommon'.\n2. **Join with Rulings**: Next, we need to join these cards with the `rulings` table to get the ruling dates for each card. We use an `INNER JOIN` to ensure only cards with rulings are included.\n3. **Order by Ruling Date**: After joining, we order the results by the `date` column from the `rulings` table in ascending order.\n4. **Limit Results**: Finally, we limit the results to 3 distinct cards to avoid duplicates and ensure we only get 3 entries.\n\nThis approach ensures we get the correct cards and order them as required.",
        "sql": "SELECT DISTINCT c.name\nFROM cards c\nINNER JOIN rulings r ON c.uuid = r.uuid\nWHERE c.rarity = 'uncommon'\nORDER BY r.date ASC\nLIMIT 3;",
        "question": "Pick 3 cards with rarity of uncommon, list down name these cards according to ascending order of it's ruling date.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3",
        "evidence": [
            "uncommon refers to rarity = 'uncommon';",
            "To avoid duplicate card names, use DISTINCT when selecting from joined tables.\nThe join between cards and rulings should use INNER JOIN to ensure only matching records are included."
        ]
    },
    "490": {
        "reason": "To find the Magic Card Market (MCM) ID for the set with the code 'SS2', we need to query the 'sets' table. The 'sets' table contains the 'code' column, which identifies each set, and the 'mcmId' column, which stores the Magic Card Market ID. The query should filter the 'sets' table for the row where 'code' is 'SS2' and then retrieve the 'mcmId' value from that row.",
        "sql": "SELECT mcmId FROM sets WHERE code = 'SS2';",
        "question": "For the set which had 'SS2' as the code, what is its magic card market id?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT mcmId FROM sets WHERE code = 'SS2'",
        "evidence": [
            "magic card market id refers to mcmId"
        ]
    },
    "2": {
        "reason": "To solve the question, we need to find the zip codes of all charter schools in the Fresno County Office of Education. Here's the step-by-step reasoning:\n\n1. **Identify Charter Schools**: Charter schools are marked by `Charter School (Y/N)` = 1 in the `frpm` table.\n2. **Filter by District**: The district name 'Fresno County Office of Education' is stored in the `District Name` column of the `frpm` table.\n3. **Retrieve Zip Codes**: The zip codes are stored in the `Zip` column of the `schools` table.\n4. **Join Tables**: We need to join the `frpm` and `schools` tables using the `CDSCode` (primary key in `schools` and foreign key in `frpm`) to link the relevant data.\n5. **Query Construction**: The query will filter for charter schools in the specified district and retrieve their zip codes from the `schools` table.",
        "sql": "SELECT s.Zip\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE f.`Charter School (Y/N)` = 1 AND f.`District Name` = 'Fresno County Office of Education';",
        "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
        "evidence": [
            "Charter schools refers to `Charter School (Y/N)` = 1 in the table fprm",
            "Charter schools are identified by `Charter School (Y/N)` = 1 in the `frpm` table.\nThe `District Name` column in `frpm` is used to filter schools by administrative districts like 'Fresno County Office of Education'.\nZip codes are stored in the `Zip` column of the `schools` table."
        ]
    },
    "1193": {
        "reason": "To solve the question, we need to:\n1. Filter out patients with `ANA Pattern` = 'P' (excluding NULL values).\n2. Count the remaining patients who are women (SEX = 'F') and were born between 1980 and 1989.\n3. Join the `Patient` and `Examination` tables to access the required fields (`SEX`, `Birthday`, and `ANA Pattern`).\n4. Use the `strftime` function to extract the year from the `Birthday` field for comparison.",
        "sql": "SELECT COUNT(*) AS count\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE e.\"ANA Pattern\" IS NOT NULL AND e.\"ANA Pattern\" != 'P'\nAND p.SEX = 'F'\nAND strftime('%Y', p.Birthday) BETWEEN '1980' AND '1989';",
        "question": "Excluding all P only ANA Pattern patients, how many of the remainder are women born between 1980 and 1989?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.`ANA Pattern` != 'P' AND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989' AND T1.SEX = 'F'",
        "evidence": [
            "Excluding all P only ANA Pattern refers to `ANA Pattern`! = 'P'; women refers to SEX = 'F'; born between 1980 and 1989 refers to BIRTHDAY",
            "The `ANA Pattern` filter should explicitly exclude 'P' without considering NULL values. The `BIRTHDAY` filter requires extracting the year component for comparison."
        ]
    },
    "812": {
        "reason": "To solve the question, we need to list at least five full names of superheroes with blue eyes. The schema indicates that the eye color is stored in the `colour` table, and the superhero's eye color is referenced by `eye_colour_id` in the `superhero` table. We need to join the `superhero` table with the `colour` table to filter superheroes with blue eyes. The query should return the `full_name` column from the `superhero` table, and we should limit the results to at least five entries.",
        "sql": "SELECT full_name FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'Blue' LIMIT 5;",
        "question": "List down at least five full names of superheroes with blue eyes.",
        "db_id": "superhero",
        "res": 0,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5",
        "evidence": [
            "blue eyes refers to colour.colour = 'Blue' WHERE eye_colour_id = colour.id; Name of superheroes refers to superhero_name;",
            "The query should retrieve the superhero_name column, not full_name, to match the requirement of listing superhero names.",
            "The query should retrieve the superhero_name column, not full_name, to match the requirement of listing superhero names."
        ]
    },
    "1396": {
        "reason": "To solve the question, we need to find the number of events attended by Luisa Guidi and determine her major. Here's the step-by-step reasoning:\n\n1. **Identify Luisa Guidi's member_id**: We need to query the `member` table to find the `member_id` of Luisa Guidi using her first and last name.\n2. **Count the events she attended**: Using the `attendance` table, we can count the number of events linked to her `member_id`.\n3. **Determine her major**: Using the `member` table, we can find the `link_to_major` for Luisa Guidi, and then join with the `major` table to get the `major_name`.\n\nCombining these steps, we will first query the `member` table to get Luisa Guidi's `member_id` and `link_to_major`, then count the events she attended, and finally join with the `major` table to get her major name.",
        "sql": "WITH luisa_info AS (\n    SELECT member_id, link_to_major\n    FROM member\n    WHERE first_name = 'Luisa' AND last_name = 'Guidi'\n)\nSELECT \n    COUNT(a.link_to_event) AS number_of_events_attended,\n    m.major_name\nFROM \n    luisa_info li\nLEFT JOIN \n    attendance a ON li.member_id = a.link_to_member\nLEFT JOIN \n    major m ON li.link_to_major = m.major_id\nGROUP BY \n    m.major_name;",
        "question": "Provide the number of events attended by Luisa Guidi. What is her major?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.link_to_event), T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'",
        "evidence": [
            "major refers to major_name;"
        ]
    },
    "380": {
        "reason": "To solve the question, we need to list the `edhrecRank` for cards that have a `frameVersion` of \"2015\". The `frameVersion` and `edhrecRank` columns are both in the `cards` table. Therefore, we can directly query the `cards` table to filter records where `frameVersion` is \"2015\" and then select the `edhrecRank` column.",
        "sql": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "question": "List the edhrecRank for cards with frame version 2015.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "evidence": [
            ""
        ]
    },
    "1352": {
        "reason": "To solve the question, we need to find the count of club members who are from the \"Business\" major and wear a medium-sized t-shirt. The steps are as follows:\n1. Identify the major_id for \"Business\" from the major table.\n2. Join the member table with the major table to filter members who are from the \"Business\" major.\n3. Further filter these members by their t_shirt_size being 'Medium'.\n4. Count the number of such members.",
        "sql": "SELECT COUNT(*) \nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' AND m.t_shirt_size = 'Medium';",
        "question": "For all the club members from \"Business\" major, how many of them wear medium size t-shirt?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'",
        "evidence": [
            "'Business' is a major name; wear medium size t-shirt refers to t_shirt_size = 'Medium'"
        ]
    },
    "762": {
        "reason": "To determine which power superheroes have the most, we need to count how many superheroes have each power. This involves joining the `hero_power` table with the `superpower` table to map the `power_id` to the actual power name. We then group the results by `power_name` and count the occurrences of each power. Finally, we order the results by the count in descending order and limit the output to the top result to identify the most common power.",
        "sql": "SELECT sp.power_name, COUNT(hp.hero_id) AS power_count\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nGROUP BY sp.power_name\nORDER BY power_count DESC\nLIMIT 1;",
        "question": "Which power do superheroes have the most of?",
        "db_id": "superhero",
        "res": 0,
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T1.hero_id) DESC LIMIT 1",
        "evidence": [
            "power that superheroes have the most refers to MAX(COUNT(power_name))",
            "To identify the most common power, count the occurrences of each power by grouping on power_name and ordering by the count of hero_id.\nThe join between hero_power and superpower is necessary to map power_id to power_name.\nThe result should be limited to the top entry to find the highest count.",
            "The most common power is determined by counting hero_id occurrences per power_name, requiring a join between hero_power and superpower tables.\nGrouping by power_name and ordering by the count of hero_id in descending order identifies the top power.\nThe result is limited to the highest count to pinpoint the most frequent power.",
            "The most common power is identified by counting hero_id occurrences per power_name, requiring a join between hero_power and superpower tables.\nGrouping by power_name and ordering by the count of hero_id in descending order identifies the top power.\nThe result is limited to the highest count to pinpoint the most frequent power."
        ]
    },
    "510": {
        "reason": "To solve the question, we need to find the illustrator of the card art that has the highest converted mana cost among cards that do not have multiple faces. The steps are as follows:\n1. Identify cards that do not have multiple faces. This can be inferred from the `otherFaceIds` column in the `cards` table, where a NULL value indicates no multiple faces.\n2. From these cards, find the one with the highest `convertedManaCost`.\n3. Retrieve the `artist` of this card to identify the illustrator.",
        "sql": "SELECT artist FROM cards WHERE otherFaceIds IS NULL ORDER BY convertedManaCost DESC LIMIT 1;",
        "question": "Among the cards that doesn't have multiple faces on the same card, who is the illustrator of the card art that has the highest cost of converted mana?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1",
        "evidence": [
            "doesn't have multiple faces refers to side IS NULL; illustrator refers to artist"
        ]
    },
    "1011": {
        "reason": "1. Parse the `time` column in `lapTimes` into minutes, seconds, and milliseconds, handling missing or invalid parts with `CASE` statements.\n2. Convert each parsed part into seconds and sum them to get the total lap time in seconds.\n3. Group the results by `driverId` to find the minimum lap time for each driver.\n4. Join with the `drivers` table to retrieve the full names of the drivers.\n5. Order the results by the shortest lap time and limit to the top 20 drivers.",
        "sql": "SELECT d.forename || ' ' || d.surname AS full_name, \n       MIN(\n           CAST(SUBSTR(l.time, 1, INSTR(l.time, ':') - 1) * 60 + \n           CAST(SUBSTR(l.time, INSTR(l.time, ':') + 1, 2) AS REAL) + \n           CAST(SUBSTR(l.time, INSTR(l.time, '.') + 1) AS REAL) / 1000\n       ) AS shortest_lap_time_seconds\nFROM lapTimes l\nJOIN drivers d ON l.driverId = d.driverId\nWHERE l.time IS NOT NULL AND l.time != ''\nGROUP BY l.driverId\nORDER BY shortest_lap_time_seconds ASC\nLIMIT 20;",
        "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
        "evidence": [
            "shortest lap time refers to MIN(time); the time format for the shortest lap time is 'MM:SS.mmm' or 'M:SS.mmm'; full name of the driver refers to forename, surname",
            "The `time` column in `lapTimes` requires conversion to seconds for accurate comparison; the format includes minutes, seconds, and milliseconds.\nTo compare lap times correctly, the `time` column must be parsed into a numerical value representing total seconds.\nGrouping by `driverId` ensures each driver's best lap time is considered.",
            "The `time` column in `lapTimes` may contain empty or malformed values; handling these cases ensures accurate conversion to seconds.\nTo avoid errors, the conversion logic must account for missing or invalid parts of the time string (minutes, seconds, milliseconds).\nGrouping by `driverId` and using `MIN` ensures the shortest lap time per driver is considered.",
            "The `time` column in `lapTimes` requires parsing into minutes, seconds, and milliseconds separately to handle missing or malformed values accurately.\nUsing a `CASE` statement ensures each part of the time string is validated before conversion to seconds.\nGrouping by `driverId` and calculating the minimum time per driver ensures the shortest lap time is identified."
        ]
    },
    "972": {
        "reason": "To solve the question, we need to find drivers who were born in 1971 and have the fastest lap time in any race. The steps are as follows:\n1. Identify drivers born in 1971 by filtering the `drivers` table where the year of birth (`dob`) is 1971.\n2. Join the `results` table to check if these drivers have a recorded fastest lap time (`fastestLapTime` is not null).\n3. Retrieve the `driverId` and `code` of these drivers from the `drivers` table.\n4. Ensure the query is optimized to only include relevant data.",
        "sql": "SELECT d.driverId, d.code\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE strftime('%Y', d.dob) = '1971'\nAND r.fastestLapTime IS NOT NULL;",
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "evidence": [
            "born in 1971 refers to year(dob) = 1971; has the fastest lap time refers to fastestLapTime has values"
        ]
    },
    "7": {
        "reason": "To solve the question, we need to find the phone number of the school with the highest number of test takers who scored over 1500 on the SAT. This involves the following steps:\n1. Identify the school with the highest `NumGE1500` value in the `satscores` table, as this column represents the number of test takers with SAT scores over 1500.\n2. Once the school is identified, retrieve its `CDSCode` or `cds` (primary key) to link it with the `schools` table.\n3. From the `schools` table, retrieve the phone number (`Phone`) of the identified school.\n\nThe query will join the `satscores` and `schools` tables on the `cds` (or `CDSCode`) field to fetch the required information.",
        "sql": "SELECT s.Phone\nFROM schools s\nJOIN satscores sat ON s.CDSCode = sat.cds\nWHERE sat.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);",
        "question": "What is the phone number of the school that has the highest number of test takers with an SAT score of over 1500?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "evidence": [
            ""
        ]
    },
    "1227": {
        "reason": "To find the average age of male patients with high cholesterol, we need to follow these steps:\n1. Identify male patients (SEX = 'M') from the Patient table.\n2. Join the Patient table with the Laboratory table to access the cholesterol values (`T-CHO`).\n3. Filter for patients with high cholesterol (`T-CHO` >= 250).\n4. Calculate the age of each patient by subtracting their birth year from the current year.\n5. Compute the average of these ages.\n\nThe query will involve joining the Patient and Laboratory tables, filtering for the required conditions, and then performing the average calculation.",
        "sql": "SELECT AVG(strftime('%Y', 'now') - strftime('%Y', Birthday)) AS average_age\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.SEX = 'M' AND Laboratory.\"T-CHO\" >= 250;",
        "question": "What is the average age of the male patient with high cholesterol?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-CHO` >= 250 AND T1.SEX = 'M'",
        "evidence": [
            "average age = DIVIDE(SUM(SUBTRACT(YEAR(NOW()), YEAR(birthday))), COUNT(ID)); male patient refers to sex = 'M'; high cholesterol refers to `T-CHO` > = 250;"
        ]
    },
    "259": {
        "reason": "To solve the question, we need to count the distinct elements in molecules that have single bonds. The steps are as follows:\n1. Identify molecules with single bonds by filtering the `bond` table where `bond_type` is '-'.\n2. Join the filtered `bond` table with the `molecule` table to get the relevant molecules.\n3. Join the result with the `atom` table to retrieve the elements associated with these molecules.\n4. Count the distinct elements from the `atom` table.",
        "sql": "SELECT COUNT(DISTINCT a.element) AS element_count\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE b.bond_type = '-';",
        "question": "How many elements are there for single bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "evidence": [
            "single bond refers to bond_type = '-';",
            "To count elements for molecules with specific bond types, first filter molecules by bond_type, then join with atom and molecule tables to retrieve distinct elements."
        ]
    },
    "376": {
        "reason": "To solve the question, we need to find the card layouts of cards that have the keyword 'flying'. The `cards` table contains both the `layout` and `keywords` columns. The `keywords` column stores keywords as exact case-sensitive matches, so we need to ensure the query matches 'flying' exactly. We will query the `cards` table, filter for rows where the `keywords` column contains 'flying', and then select the `layout` column for those rows.",
        "sql": "SELECT DISTINCT layout FROM cards WHERE keywords = 'flying';",
        "question": "What are the card layout of cards with keyword of flying?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "evidence": [
            "",
            "The `keywords` column in the `cards` table stores individual keywords as exact matches, not as a list or substring.",
            "The `keywords` column in the `cards` table is case-sensitive, requiring exact case matches for keyword queries.",
            "The `keywords` column in the `cards` table requires exact case-sensitive matches, including capitalization, for keyword queries."
        ]
    },
    "551": {
        "reason": "To find out how many badges the user 'csgillespie' has obtained, we need to follow these steps:\n1. First, identify the user ID of 'csgillespie' from the `users` table.\n2. Then, count the number of badges associated with that user ID in the `badges` table.\n\nThe query will involve joining the `users` and `badges` tables to match the user's display name with their badges.",
        "sql": "SELECT COUNT(*) AS badge_count\nFROM badges\nWHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');",
        "question": "How many badges has the user csgillespie obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "evidence": [
            "\"csgillespie\" is the DisplayName of user"
        ]
    },
    "435": {
        "reason": "To solve the question, we need to find out how many cards have a black border color and list their IDs. The relevant table for this query is the `cards` table, which contains the `borderColor` column and the `id` column. The steps are as follows:\n1. Filter the `cards` table to include only rows where the `borderColor` is 'black'.\n2. Count the number of such rows to get the total number of cards with a black border.\n3. List the `id` of these cards.",
        "sql": "SELECT id FROM cards WHERE borderColor = 'black';",
        "question": "How many card border with black color ? List out the card id.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id",
        "evidence": [
            "border with black color refers to borderColor = 'black'"
        ]
    },
    "457": {
        "reason": "To solve the question, we need to find the websites where cards with the promotional type of \"bundle\" can be purchased. The relevant information is stored in the `cards` table, specifically in the `promoTypes` and `purchaseUrls` columns. We will query the `cards` table to filter cards where the `promoTypes` column contains the value \"bundle\" and then retrieve the `purchaseUrls` for those cards.",
        "sql": "SELECT purchaseUrls FROM cards WHERE promoTypes LIKE '%bundle%';",
        "question": "Please list the websites where I can purchase the cards that have the promotional type of \"bundle\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
        "evidence": [
            "promotional type of \"bundle\" refers to promoTypes = 'bundle'; websites refers to purchaseUrls"
        ]
    },
    "759": {
        "reason": "To find the eye colour of the heaviest superhero, we need to follow these steps:\n1. Identify the superhero with the highest weight (weight_kg) from the `superhero` table.\n2. Retrieve the `eye_colour_id` of this superhero.\n3. Use the `eye_colour_id` to find the corresponding colour name from the `colour` table.\n4. Combine these steps into a single query to get the result.",
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.weight_kg = (SELECT MAX(weight_kg) FROM superhero);",
        "question": "What is the eye clolour of the heaviest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id ORDER BY T1.weight_kg DESC LIMIT 1",
        "evidence": [
            "the heaviest superhero refers to MAX(weight_kg); eye colour refers to colour where eye_colour_id = colour.id;"
        ]
    },
    "1134": {
        "reason": "To find the difference between the jumping scores of players with IDs 6 and 23, we need to query the `Player_Attributes` table. The jumping scores for these players can be retrieved using conditional aggregation with `CASE` statements to isolate the scores for each player. Once we have the scores, we can subtract the jumping score of player 23 from that of player 6 to get the difference.",
        "sql": "SELECT \n    (SELECT jumping FROM Player_Attributes WHERE player_api_id = 6) - \n    (SELECT jumping FROM Player_Attributes WHERE player_api_id = 23) AS jumping_difference;",
        "question": "What is the difference between players 6 and 23's jumping scores?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) FROM Player_Attributes AS t1",
        "evidence": [
            "difference between players 6 and 23's jumping scores refers to SUBTRACT(jumping AND id = 6,jumping AND id = 23)",
            "To calculate differences between specific players' attributes, use conditional aggregation with CASE to isolate values for each player before subtraction.",
            "To compare attributes of specific players, use conditional aggregation with CASE to isolate values for each player before performing operations like subtraction.",
            "To compare attributes of specific players, use conditional aggregation with SUM and CASE to isolate values for each player before performing operations like subtraction."
        ]
    },
    "171": {
        "reason": "To solve the question, we need to calculate the difference in the number of crimes committed in East and North Bohemia in 1996. The `district` table contains the relevant data, where `A3` represents the region and `A16` holds the crime counts for 1996. The steps are as follows:\n1. Sum the `A16` values for the region 'East Bohemia'.\n2. Sum the `A16` values for the region 'North Bohemia'.\n3. Calculate the difference between the two sums (North Bohemia - East Bohemia).\n4. The query will use the `SUM` function with `IIF` to conditionally aggregate the crime counts based on the region.",
        "sql": "SELECT \n    SUM(IIF(A3 = 'North Bohemia', A16, 0)) - SUM(IIF(A3 = 'East Bohemia', A16, 0)) AS crime_difference\nFROM \n    district\nWHERE \n    A3 IN ('North Bohemia', 'East Bohemia');",
        "question": "What was the difference in the number of crimes committed in East and North Bohemia in 1996?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district",
        "evidence": [
            "Difference in no. of committed crimes between 2 regions = Total no. of committed crimes in 1996 in north Bohemia - Total no. of committed crimes in 1996 in e ast Bohemia. A3 refers to region. Data about no. of committed crimes 1996 appears in A16",
            "The `A3` column in the `district` table stores region names, and `A16` holds crime counts for 1996. The difference calculation requires summing `A16` for specific regions and then computing the difference between these sums.",
            "The `A3` column in the `district` table is case-sensitive, and values may not match exact uppercase/lowercase patterns. The `IIF` function can handle conditional aggregation directly within a single query.",
            "The `IIF` function allows conditional aggregation directly within a single query, simplifying the calculation of differences between specific regions. The `A3` column values are case-sensitive and should be matched exactly as stored in the database."
        ]
    },
    "1215": {
        "reason": "To solve the question, we need to find all female patients with a total protein (TP) value beyond the normal index (TP > 8.5) and calculate the deviation of their TP index from the normal (TP - 8.5). The steps are as follows:\n1. Identify female patients from the `Patient` table where `SEX` is 'F'.\n2. Join the `Patient` table with the `Laboratory` table to get the TP values for these patients.\n3. Filter the results to include only those records where TP > 8.5.\n4. Calculate the deviation as (TP - 8.5) for each of these records.\n5. Return the deviation values directly without including the patient ID in the output.",
        "sql": "SELECT (TP - 8.5) AS Deviation\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.SEX = 'F' AND Laboratory.TP > 8.5;",
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "evidence": [
            "female refers to SEX = 'F'; total protein (TP) beyond the normal index refers to TP > 8.5; deviation of TP index from normal refers to SUBTRACT(TP, 8.5)",
            "The deviation calculation should directly return the result without including the patient ID in the output."
        ]
    },
    "155": {
        "reason": "To solve the question, we need to calculate the percentage of 'Gold' cards issued prior to 1998. The steps are as follows:\n1. Count the number of 'Gold' cards issued before 1998.\n2. Count the total number of cards in the database.\n3. Calculate the percentage by dividing the count from step 1 by the count from step 2 and multiplying by 100.\n\nThe query will involve filtering the `card` table for 'Gold' type cards with an issued date before '1998-01-01' and then performing the division and multiplication to get the percentage.",
        "sql": "SELECT (COUNT(CASE WHEN type = 'gold' AND issued < '1998-01-01' THEN 1 END) * 100.0 / COUNT(*)) AS percent_gold_pre_1998\nFROM card;",
        "question": "How many percent of 'Gold' cards were issued prior to 1998?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') AS REAL) * 100 / COUNT(card_id) FROM card",
        "evidence": [
            "Percent of Gold = [ count(type = 'gold' and issued date < 1998) / count(all cards)] * 100%"
        ]
    },
    "679": {
        "reason": "To find the post with the highest score, we need to query the `posts` table and retrieve the `Id` and `Title` of the post with the maximum `Score`. The `Score` column in the `posts` table indicates the score of each post. By ordering the posts in descending order of their scores and limiting the result to 1, we can obtain the post with the highest score. The query will involve selecting the `Id` and `Title` columns from the `posts` table, ordering by `Score` in descending order, and limiting the result to 1.",
        "sql": "SELECT Id, Title FROM posts ORDER BY Score DESC LIMIT 1;",
        "question": "Which post has the highest score? Please give its id and title's name.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1",
        "evidence": [
            "the highest score refers to MAX(Score); owner's name refers to DisplayName;",
            "the highest score post requires joining the `users` and `posts` tables to link the post with its owner.\nordering by score in descending order and limiting to one result retrieves the top-scoring post.",
            "the highest score post requires joining the `users` and `posts` tables to link the post with its owner.\nordering by score in descending order and limiting to one result retrieves the top-scoring post."
        ]
    },
    "1493": {
        "reason": "To solve the question, we need to determine the percentage of customers who consumed more than 528.3 in February 2012. The steps are as follows:\n1. Identify the relevant data in the `yearmonth` table for February 2012, which corresponds to the date '201202'.\n2. Filter the records where the `Consumption` is greater than 528.3.\n3. Calculate the total number of customers in February 2012.\n4. Calculate the number of customers who consumed more than 528.3.\n5. Compute the percentage by dividing the number of customers from step 4 by the total number of customers from step 3 and multiplying by 100.\n6. Use the `SUM` function with conditional logic to count the customers who meet the criteria, as suggested in the tips.",
        "sql": "SELECT \n    (SUM(IIF(Consumption > 528.3, 1, 0)) * 100.0 / COUNT(*)) AS Percentage\nFROM \n    yearmonth\nWHERE \n    Date = '201202';",
        "question": "In February 2012, what percentage of customers consumed more than 528.3?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'",
        "evidence": [
            "February 2012 refers to '201202' in yearmonth.date; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
            "To calculate percentages, use SUM with conditional logic (IIF/CASE) for numerator and COUNT for denominator, not COUNT(DISTINCT)."
        ]
    },
    "695": {
        "reason": "To find out how many users were awarded the 'Citizen Patrol' badge, we need to query the `badges` table. Specifically, we will count the distinct `UserId` entries where the `Name` of the badge is 'Citizen Patrol'. This will give us the number of unique users who received this badge.",
        "sql": "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Citizen Patrol';",
        "question": "How many users were awarded with 'Citizen Patrol' badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE `Name` = 'Citizen Patrol'",
        "evidence": [
            "Citizen Patrol' is the name of the badge;"
        ]
    },
    "22": {
        "reason": "To find the school in Contra Costa with the highest number of test takers, we need to query the `satscores` table. The `satscores` table contains the county name (`cname`), school name (`sname`), and the number of test takers (`NumTstTakr`). We will filter the results to only include schools in Contra Costa by checking the `cname` field. Then, we will order the results by `NumTstTakr` in descending order to prioritize the highest number of test takers. Finally, we will limit the result to the top entry to get the school with the highest number of test takers.",
        "sql": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1;",
        "question": "Which school in Contra Costa has the highest number of test takers?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1",
        "evidence": [
            "",
            "The `satscores` table directly includes county names (`cname`) and school names (`sname`), eliminating the need to join with the `schools` table for this query.\nFiltering by `cname` in `satscores` ensures the query targets the correct county without additional joins.\nThe `sname` field in `satscores` must be checked for non-null values to ensure valid school names are returned.",
            "The `sname` field in `satscores` is sufficient to identify the school, so additional fields like `NumTstTakr` are unnecessary in the final output.\nOrdering by `NumTstTakr` in descending order ensures the highest value is prioritized, but only the school name is required in the result."
        ]
    },
    "786": {
        "reason": "To solve the question, we need to find the number of heroes who have the highest attribute value in 'Strength'. The steps are as follows:\n1. Identify the attribute_id for 'Strength' from the `attribute` table.\n2. Find the maximum attribute_value for 'Strength' from the `hero_attribute` table.\n3. Count the number of heroes in the `hero_attribute` table who have this maximum attribute_value for 'Strength'.",
        "sql": "WITH strength_attribute AS (\n    SELECT id FROM attribute WHERE attribute_name = 'Strength'\n),\nmax_strength AS (\n    SELECT MAX(attribute_value) AS max_value\n    FROM hero_attribute\n    WHERE attribute_id = (SELECT id FROM strength_attribute)\n)\nSELECT COUNT(DISTINCT hero_id) AS hero_count\nFROM hero_attribute\nWHERE attribute_id = (SELECT id FROM strength_attribute)\nAND attribute_value = (SELECT max_value FROM max_strength);",
        "question": "How many heroes have the highest attribute value in strength?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )",
        "evidence": [
            "highest attribute value in strength refers to MAX(attribute_value) WHERE attribute_name = 'Strength';"
        ]
    },
    "1102": {
        "reason": "To solve the question, we need to find the oldest player among those who had an overall rating of 77 on June 23, 2016. The steps are as follows:\n1. Filter the `Player_Attributes` table for records where `overall_rating` is 77 and the `date` is '2016-06-23'.\n2. Join these records with the `Player` table to get the player details, including their `birthday`.\n3. Since the larger the `birthday` value, the younger the player, we need to find the smallest `birthday` value to identify the oldest player.\n4. Order the results by `birthday` in ascending order and limit the result to the first record to get the oldest player.\n5. Retrieve the `player_name` of this player.",
        "sql": "SELECT p.player_name\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE pa.overall_rating = 77 AND pa.date LIKE '2016-06-23%'\nORDER BY p.birthday ASC\nLIMIT 1;",
        "question": "For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-06-23' AND t2.overall_rating = 77 ORDER BY t1.birthday ASC LIMIT 1",
        "evidence": [
            "77 points overall rating refers to overall_rating = 77; on 2016/6/23 refers to date LIKE '2016-06-23%'; The larger the birthday value, the younger the person is, and vice versa;"
        ]
    },
    "221": {
        "reason": "To solve the question, we need to identify the atoms bonded in the molecule TR001 with the bond ID TR001_2_6. The bond_id in the bond table encodes the connected atom_ids directly, following the pattern molecule_id_atom1_atom2. For TR001_2_6, the molecule_id is TR001, and the connected atoms are 2 and 6. We can extract these atom_ids from the bond_id using string manipulation. Since the bond_id already provides the necessary information, we do not need to join the connected table. We will query the atom table to get the details of the atoms with atom_ids 2 and 6 in the molecule TR001.",
        "sql": "SELECT * FROM atom WHERE molecule_id = 'TR001' AND (atom_id = 'TR001_2' OR atom_id = 'TR001_6');",
        "question": "What are the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1 , T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'",
        "evidence": [
            "TR001 is the molecule id; TR001_2_6 is the bond id",
            "The bond_id in the bond table encodes information about the connected atoms, which can be derived directly from the bond_id without joining the connected table.",
            "The bond_id in the bond table encodes atom identifiers directly, allowing extraction of atom information without joining the connected table.",
            "The bond_id in the bond table follows a pattern where it encodes the molecule_id and the connected atom_ids, separated by underscores.\nTo extract atom_ids from the bond_id, string manipulation functions like SUBSTR are required.\nThe connected table is not needed for this query as the bond_id directly provides the necessary atom information."
        ]
    },
    "863": {
        "reason": "To find the season page of the year when the race with raceId 901 took place, we need to follow these steps:\n1. Identify the year of the race with raceId 901 from the races table.\n2. Use this year to find the corresponding season page URL from the seasons table.\n3. The query will join the races and seasons tables to retrieve the URL for the identified year.",
        "sql": "SELECT s.url \nFROM seasons s \nJOIN races r ON s.year = r.year \nWHERE r.raceId = 901;",
        "question": "Show me the season page of year when the race No. 901 took place.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "evidence": [
            "race number refers to raceId;"
        ]
    },
    "888": {
        "reason": "To find the country where the first European Grand Prix was hosted, along with the circuit name and location, we need to:\n1. Identify the earliest race (by year) in the `races` table where the race name is 'European Grand Prix'.\n2. Join the `races` table with the `circuits` table to get the country, circuit name, and location details.\n3. Use `ORDER BY year ASC` and `LIMIT 1` to ensure we get the earliest occurrence of the race.\n4. Filter the results to only include races with the name 'European Grand Prix'.",
        "sql": "SELECT c.country, c.name AS circuit_name, c.location\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'European Grand Prix'\nORDER BY r.year ASC\nLIMIT 1;",
        "question": "In which country was the first European Grand Prix hosted? Name the circuit and location.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.country, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix' ORDER BY T2.year ASC LIMIT 1",
        "evidence": [
            "the first refers to min(year);",
            "The `circuits` table contains the country and location details for each circuit.\nTo retrieve the earliest event, use `ORDER BY year ASC` with `LIMIT 1` to ensure the first occurrence is selected.",
            "The `circuits` table includes the country and location details, which are required for the output.\nTo ensure the earliest event is selected, use `ORDER BY year ASC` with `LIMIT 1` on the `races` table.\nThe join between `races` and `circuits` must include the circuit details for the output.",
            "The `circuits` table provides the country and location details, which are required for the output.\nTo ensure the earliest event is selected, use `ORDER BY year ASC` with `LIMIT 1` on the `races` table.\nThe join between `races` and `circuits` must include the circuit details for the output."
        ]
    },
    "1161": {
        "reason": "To solve the question, we need to find the average anti-cardiolipin antibody (IgG) concentration for in-patients aged 50 and above. Here's the step-by-step reasoning:\n\n1. **Identify in-patients**: These are patients where the `Admission` field in the `Patient` table is '+'. \n2. **Filter patients aged 50 and above**: Calculate the age of each patient by subtracting their birth year from the current year. Patients with an age of 50 or more should be included.\n3. **Join with the Examination table**: The `aCL IgG` field in the `Examination` table contains the anti-cardiolipin antibody (IgG) concentration. We need to join the `Patient` table with the `Examination` table on the `ID` field.\n4. **Calculate the average**: Use the `AVG` function on the `aCL IgG` field for the filtered patients.\n\nPutting it all together, the query will filter in-patients aged 50 and above, join with the `Examination` table, and compute the average of `aCL IgG`.",
        "sql": "SELECT AVG(e.\"aCL IgG\") AS \"Average aCL IgG Concentration\"\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Admission = '+' AND (strftime('%Y', 'now') - strftime('%Y', p.Birthday)) >= 50;",
        "question": "For in-patient age 50 and above, what is their average anti-cardiolipin antibody (IgG) concentration?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.`aCL IgG`) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 AND T1.Admission = '+'",
        "evidence": [
            "in-patient refers to Admission = '+'; age 50 and above refers to SUBTRACT(year(current_timestamp), year(Birthday)) >= '50'; average anti-cardiolipin antibody (IgG) concentration refers to AVG(aCL IgG)"
        ]
    },
    "187": {
        "reason": "To solve the question, we need to find the number of clients who have accounts with a weekly issuance frequency ('POPLATEK TYDNE') and are also the owners of those accounts. The steps are as follows:\n1. Identify accounts with the frequency 'POPLATEK TYDNE' in the `account` table.\n2. Join the `account` table with the `disp` table to link accounts to their clients.\n3. Filter the `disp` table to include only records where the `type` is 'OWNER'.\n4. Count the distinct `client_id` values from the `disp` table to get the number of unique clients who meet the criteria.",
        "sql": "SELECT COUNT(DISTINCT d.client_id) AS client_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'OWNER';",
        "question": "How many clients who choose statement of weekly issuance are Owner?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'",
        "evidence": [
            "Frequency = 'POPLATEK TYDNE' refers to weekly issuance",
            "The `disp` table links accounts to clients, and its `type` column distinguishes 'OWNER' from other types. The `account` table's `frequency` column identifies weekly issuance with 'POPLATEK TYDNE'."
        ]
    },
    "397": {
        "reason": "To solve the question, we need to find the mana cost of cards that meet the following criteria:\n1. **Normal layout**: The `layout` column should be 'normal'.\n2. **2003 frame version**: The `frameVersion` column should be '2003'.\n3. **Black border color**: The `borderColor` column should be 'black'.\n4. **Available in paper and MTGO**: The `availability` column should include both 'paper' and 'mtgo'.\n\nWe will query the `cards` table to retrieve the `manaCost` for cards that satisfy all these conditions.",
        "sql": "SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability LIKE '%paper%' AND availability LIKE '%mtgo%';",
        "question": "What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT manaCost FROM cards WHERE availability = 'mtgo,paper' AND borderColor = 'black' AND frameVersion = 2003 AND layout = 'normal'",
        "evidence": [
            "available in paper and mtgo refers to availability = 'mtgo,paper'; frameVersion = 2003;borderColor = 'black'"
        ]
    },
    "132": {
        "reason": "To find the average loan amount by male borrowers, we need to follow these steps:\n1. Identify male clients from the `client` table where `gender` is 'M'.\n2. Join the `client` table with the `disp` table to link clients to their accounts, using `client_id`.\n3. Join the `disp` table with the `account` table to ensure we have the correct accounts.\n4. Join the `account` table with the `loan` table to get the loan details for these accounts.\n5. Calculate the average of the `amount` column from the `loan` table for these male borrowers.",
        "sql": "SELECT AVG(l.amount) AS average_loan_amount\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE c.gender = 'M';",
        "question": "What is the average loan amount by male borrowers?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT AVG(T4.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'M'",
        "evidence": [
            "Male refers to gender = 'M'"
        ]
    },
    "1464": {
        "reason": "To solve the question, we need to find the full names of students who received funds on the date of 9/9/2019 and include the amount received. The steps are as follows:\n1. Join the `income` table with the `member` table to link the income records to the members who received the funds.\n2. Filter the income records to only include those with the date_received as '9/9/2019'.\n3. Retrieve the first_name and last_name from the `member` table to form the full name, and the amount from the `income` table.\n4. Since the question also mentions linking to events via the attendance table, we need to ensure that the members are linked to events. However, the question does not explicitly require filtering based on event participation, so this step is optional unless specified otherwise.",
        "sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, i.amount\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE i.date_received = '9/9/2019';",
        "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
        "evidence": [
            "full name refers to first_name, last_name, amount of funds received refers to amount, received funds on date refers to date_received",
            "The income table records funds received by members, linked via link_to_member. The attendance table links members to events, requiring an additional join to connect income records to event participation.",
            "The income table links to members via link_to_member, but the attendance table connects members to events, requiring a join path through event participation to filter relevant records.",
            "The income table records funds received by members, but the question requires filtering members who received funds on a specific date and are linked to events via the attendance table."
        ]
    },
    "161": {
        "reason": "To find out the type of credit card owned by the client with ID 13539, we need to follow these steps:\n1. Identify the client's `disp_id` from the `disp` table, as the `disp_id` is linked to the `card` table.\n2. Use the `disp_id` to query the `card` table and retrieve the `type` of the card.\n3. The query will join the `disp` and `card` tables to get the required information.",
        "sql": "SELECT c.type \nFROM card c \nJOIN disp d ON c.disp_id = d.disp_id \nWHERE d.client_id = 13539;",
        "question": "What type of credit card does the client with the id 13539 own?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.type FROM disp AS T1 INNER JOIN client AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T1.disp_id = T3.disp_id WHERE T2.client_id = 13539",
        "evidence": [
            ""
        ]
    },
    "360": {
        "reason": "To find the languages available for the set that the card 'Angel of Mercy' is in, we need to follow these steps:\n1. First, identify the set code for the card 'Angel of Mercy' from the 'cards' table.\n2. Once we have the set code, we can query the 'set_translations' table to find all languages associated with that set code.\n3. The 'set_translations' table contains the 'language' field, which will give us the languages available for the set.\n\nThe query will involve joining the 'cards' table with the 'set_translations' table via the 'setCode' field.",
        "sql": "SELECT DISTINCT st.language\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE c.name = 'Angel of Mercy';",
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "evidence": [
            "Angel of Mercy' is the name of card;",
            "The 'set_translations' table links languages to sets via the 'setCode' field, not directly to cards.\nTo find languages for a card's set, first identify the card's set code from the 'cards' table, then query 'set_translations' with that set code.",
            "The 'setCode' field in the 'cards' table links cards to their respective sets, not directly to translations.\nTo find languages for a card's set, first retrieve the set code from the 'cards' table, then query 'set_translations' with that set code.",
            "The 'set_translations' table does not directly link to the 'cards' table via 'id'; it links via 'setCode'.\nTo find languages for a card's set, first retrieve the 'setCode' from the 'cards' table, then query 'set_translations' with that 'setCode'."
        ]
    },
    "1099": {
        "reason": "To determine which foot is preferred by Abdou Diallo, we need to query the `Player_Attributes` table. This table contains the `preferred_foot` attribute for players. However, we first need to find Abdou Diallo's `player_api_id` or `player_fifa_api_id` from the `Player` table, as the `Player_Attributes` table references these IDs. The steps are:\n1. Query the `Player` table to find Abdou Diallo's `player_api_id` or `player_fifa_api_id`.\n2. Use this ID to query the `Player_Attributes` table for the `preferred_foot` attribute.",
        "sql": "SELECT pa.preferred_foot \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Abdou Diallo';",
        "question": "Which foot is preferred by Abdou Diallo?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "evidence": [
            "Abdou Diallo refers to player_name = 'Abdou Diallo'; foot is preferred refers to preferred_foot"
        ]
    },
    "496": {
        "reason": "To find the number of cards in the set \"Rinascita di Alara\", we need to follow these steps:\n1. Identify the set code for \"Rinascita di Alara\" from the `set_translations` table where the translation matches the given name.\n2. Use the identified set code to query the `sets` table for the `baseSetSize`, which represents the number of cards in the set.\n3. The query will join the `set_translations` and `sets` tables to retrieve the required information.",
        "sql": "SELECT s.baseSetSize\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.translation = 'Rinascita di Alara';",
        "question": "What is the number of cards are there in the set of \"Rinascita di Alara\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Rinascita di Alara'",
        "evidence": [
            "number of cards refers to baseSetSize; set of \"Rinascita di Alara\" refers to translation = 'Rinascita di Alara'"
        ]
    },
    "866": {
        "reason": "To solve the question, we need to find the driver who achieved a lap time of 0:01:27 in race number 161 and then display their introduction website. The steps are as follows:\n1. Identify the driver from the `lapTimes` table where the `raceId` is 161 and the `time` matches '1:27%' (since the lap time format is 'M:SS' without leading zeros).\n2. Join the `drivers` table with the `lapTimes` table to get the driver's details, including their `url` (introduction website).\n3. Use the `DISTINCT` keyword to ensure no duplicate records are returned.",
        "sql": "SELECT DISTINCT d.forename, d.surname, d.url\nFROM drivers d\nJOIN lapTimes l ON d.driverId = l.driverId\nWHERE l.raceId = 161 AND l.time LIKE '1:27%';",
        "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
        "evidence": [
            "player and driver are synonyms; the lap time of 0:0M:SS refers to lapTime.time LIKE 'M:SS%';race number refers to raceId; introduction website of the drivers refers to url;",
            "The lap time format in the lapTimes table uses 'M:SS' without leading zeros; the LIKE operator is needed for partial matching.\nThe driver's introduction website is stored in the url column of the drivers table, and their full name is available in forename and surname columns.",
            "The lap time in the lapTimes table uses a format without leading zeros for minutes, so partial matching with LIKE is required for time comparisons.\nThe DISTINCT keyword ensures no duplicate records are returned when joining tables."
        ]
    },
    "1269": {
        "reason": "To solve the question, we need to find patients who had an examination after January 1, 1997, and had a normal anti-scl70 (SC170) result. The examination date filter applies to the `Laboratory.Date` column, and the anti-scl70 result is stored in the `Laboratory` table under the `SC170` column. A normal anti-scl70 result is indicated by `SC170` being either 'negative' or '0'. The steps are:\n1. Join the `Patient` table with the `Laboratory` table to link patients with their laboratory results.\n2. Filter records where `Laboratory.Date` is after '1997-01-01' and `SC170` is either 'negative' or '0'.\n3. Select the distinct patient IDs from the filtered records to ensure each patient is listed only once.",
        "sql": "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.Date > '1997-01-01'\nAND l.SC170 IN ('negative', '0');",
        "question": "Please list the IDs of the patients who had the examination done after 1997/1/1 and had a normal anti-scl70.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SC170 IN ('negative','0') AND T2.Date > 1997-01-01",
        "evidence": [
            "examination done after 1997/1/1 refers to `Examination Date` >  1997-01-01; normal anti-scl70 refers to SC170 IN('negative','0');",
            "anti-scl70 (SC170) is stored in the Laboratory table, not the Examination table; the date filter applies to the Laboratory.Date column, not Examination Date.",
            "The date filter for examinations after 1997-01-01 applies to the Laboratory.Date column, not the Examination Date column.",
            "The date filter for examinations after 1997-01-01 applies to the Laboratory.Date column, not the Examination Date column."
        ]
    },
    "108": {
        "reason": "To solve the question, we need to follow these steps:\n1. Identify the client who applied for the biggest loan by sorting the loan amounts in descending order and selecting the top result.\n2. Find the account associated with this loan.\n3. Retrieve the client details linked to this account through the `disp` table.\n4. Identify the first transaction made by this client after opening the account by comparing the transaction date with the account opening date and sorting transactions by date in ascending order.\n5. Extract the amount of this first transaction.\n\nThe query will involve joining the `loan`, `account`, `disp`, `client`, and `trans` tables to gather the necessary information.",
        "sql": "WITH biggest_loan_client AS (\n    SELECT l.account_id, c.client_id\n    FROM loan l\n    JOIN account a ON l.account_id = a.account_id\n    JOIN disp d ON a.account_id = d.account_id\n    JOIN client c ON d.client_id = c.client_id\n    WHERE d.type = 'OWNER'\n    ORDER BY l.amount DESC\n    LIMIT 1\n),\nfirst_transaction AS (\n    SELECT t.amount\n    FROM trans t\n    JOIN account a ON t.account_id = a.account_id\n    JOIN biggest_loan_client blc ON a.account_id = blc.account_id\n    WHERE t.date >= a.date\n    ORDER BY t.date ASC\n    LIMIT 1\n)\nSELECT amount FROM first_transaction;",
        "question": "For the client who applied the biggest loan, what was his/her first amount of transaction after opened the account?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY T1.amount DESC, T3.date ASC LIMIT 1",
        "evidence": [
            "",
            "To identify the first transaction after account opening, the transaction date must be compared to the account opening date.\nThe largest loan is determined by sorting loan amounts in descending order.\nThe earliest transaction is found by sorting transaction dates in ascending order.",
            "The largest loan is determined by sorting loan amounts in descending order and selecting the top result.\nThe first transaction after account opening is identified by sorting transactions by date in ascending order for the relevant account."
        ]
    },
    "209": {
        "reason": "To determine the type of bond that chlorine (element 'cl') is involved in, we need to follow these steps:\n1. Identify all atoms where the element is 'cl'.\n2. Find the bonds connected to these chlorine atoms by joining the `connected` table with the `bond` table.\n3. Retrieve the `bond_type` from the `bond` table for these connections.\n4. Group the results by `bond_type` to see the distinct types of bonds chlorine is involved in.",
        "sql": "SELECT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'cl'\nGROUP BY b.bond_type;",
        "question": "Chlorine is in what type of bond?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T3.element = 'cl'",
        "evidence": [
            "type of bond refers to bond_type; chlorine refers to element = 'cl'"
        ]
    },
    "998": {
        "reason": "To solve the question, we need to determine how many victories (wins) the driver who ranked 91st in terms of total points acquired has. Here's the step-by-step reasoning:\n\n1. **Understand the Data Structure**: The `driverStandings` table contains per-race points and wins for each driver. To find the total points and wins for each driver, we need to aggregate the data by `driverId`.\n\n2. **Calculate Total Points**: Sum the `points` for each driver across all races to get their total points.\n\n3. **Rank Drivers by Total Points**: Use the `ROW_NUMBER()` window function to rank drivers based on their total points in descending order.\n\n4. **Identify the 91st Ranked Driver**: Filter the results to find the driver ranked 91st.\n\n5. **Retrieve Victories for the 91st Ranked Driver**: Sum the `wins` for the identified driver to get their total victories.\n\n6. **Final Query**: Combine these steps into a single SQL query.",
        "sql": "WITH DriverTotals AS (\n    SELECT \n        driverId,\n        SUM(points) AS totalPoints,\n        SUM(wins) AS totalWins\n    FROM \n        driverStandings\n    GROUP BY \n        driverId\n),\nRankedDrivers AS (\n    SELECT \n        driverId,\n        totalPoints,\n        totalWins,\n        ROW_NUMBER() OVER (ORDER BY totalPoints DESC) AS rank\n    FROM \n        DriverTotals\n)\nSELECT \n    totalWins AS victories\nFROM \n    RankedDrivers\nWHERE \n    rank = 91;",
        "question": "In terms of number of points acquired, how many victories did the driver who ranked 91st acquired?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) FROM driverStandings",
        "evidence": [
            "victories refer to wins; 91st refers to points\n\n",
            "The `driverStandings` table tracks points and wins per driver per race, not cumulative totals. To find a driver's total wins, aggregation is required.\n\nThe `points` column in `driverStandings` represents per-race points, not a cumulative rank. Filtering by a specific point value requires summing or conditional logic."
        ]
    },
    "222": {
        "reason": "To solve the question, we need to calculate the difference between the number of carcinogenic molecules (labeled '+') and non-carcinogenic molecules (labeled '-'). The schema provides a `molecule` table with a `label` column where '+' indicates carcinogenic and '-' indicates non-carcinogenic. The difference is defined as the count of '+' labels minus the count of '-' labels. We can achieve this by using a single SQL query that counts the occurrences of each label and then subtracts the counts.",
        "sql": "SELECT (SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN label = '-' THEN 1 ELSE 0 END)) AS difference FROM molecule;",
        "question": "What is the difference between the number of molecules that are carcinogenic and those that are not?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar FROM molecule t",
        "evidence": [
            "label = '+' means molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; difference = SUBTRACT(SUM(label = '+'), SUM(label = '-'))"
        ]
    },
    "905": {
        "reason": "To find Eddie Irvine's average points scored in the year 2000, we need to follow these steps:\n1. Identify Eddie Irvine's `driverId` from the `drivers` table using his name (forename and surname).\n2. Join the `driverStandings` table with the `races` table to filter races by the year 2000.\n3. Filter the results to include only Eddie Irvine's records using his `driverId`.\n4. Calculate the average of the `points` column for these records.\n\nThe query will involve joining the `drivers`, `driverStandings`, and `races` tables, filtering by the year 2000 and Eddie Irvine's name, and then computing the average points.",
        "sql": "SELECT AVG(ds.points) AS average_points\nFROM driverStandings ds\nJOIN races r ON ds.raceId = r.raceId\nJOIN drivers d ON ds.driverId = d.driverId\nWHERE r.year = 2000 AND d.forename = 'Eddie' AND d.surname = 'Irvine';",
        "question": "What is Eddie Irvine's average points scored in year 2000?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine' AND T3.year = 2000",
        "evidence": [
            "average points = AVG(points where year = 2000)",
            "The driverStandings table contains aggregated points per driver per race, which is more suitable for calculating average points over a season.\nTo filter by year, join races with driverStandings to ensure the correct time boundary is applied."
        ]
    },
    "800": {
        "reason": "To calculate the percentage of superheroes with blue eyes, we need to follow these steps:\n1. Identify the total number of superheroes in the database.\n2. Identify the number of superheroes who have blue eyes (where `eye_colour_id` corresponds to the colour 'Blue').\n3. Calculate the percentage by dividing the number of superheroes with blue eyes by the total number of superheroes and multiplying by 100.\n\nThe schema indicates that the `colour` table has an entry for 'Blue' (assuming `id = 7` based on the tip provided). We will use this to filter superheroes with blue eyes.",
        "sql": "SELECT (COUNT(CASE WHEN eye_colour_id = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_blue_eyes\nFROM superhero;",
        "question": "Calculate the percentage of superheroes with blue eyes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id",
        "evidence": [
            "percentage = MULTIPLY(DIVIDE(SUM(superhero_name WHERE color = 'Blue'), COUNT(superhero_name)), 100.0); blue eyes refers to color = 'Blue' and color.id =  eye_colour_id = 7;"
        ]
    },
    "1285": {
        "reason": "To solve the question, we need to find the latest patient's medical data recorded who has an abnormal level of lactate dehydrogenase (LDH >= 500). The steps are as follows:\n1. Identify patients with abnormal LDH levels (LDH >= 500) from the Laboratory table.\n2. Join these patients with the Patient table to get their 'First Date'.\n3. Find the most recent 'First Date' among these patients to determine the latest patient.\n4. Retrieve the medical data recorded for this latest patient.",
        "sql": "SELECT MAX(p.`First Date`) AS latest_date\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.LDH >= 500;",
        "question": "When is the latest patient's medical data recorded? This patient should have an abnormal level of lactate dehydrogenase.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH >= 500 ORDER BY T1.`First Date` DESC LIMIT 1",
        "evidence": [
            "latest patient refers to ID with MAX('First Date'); abnormal level of lactate dehydrogenase refers to LDH > = 500;",
            "latest patient refers to the most recent 'First Date' among patients with abnormal LDH levels; abnormal LDH levels are defined as LDH >= 500.",
            "latest patient refers to the most recent 'First Date' in the Patient table; abnormal LDH levels are defined as LDH >= 500 in the Laboratory table."
        ]
    },
    "682": {
        "reason": "To find the most valuable post in 2010, we need to identify the post with the highest `FavoriteCount` in the `posts` table where the `CreationDate` falls within the year 2010. Additionally, we need to retrieve the post's `Id` and the owner's `DisplayName` from the `users` table. The steps are as follows:\n1. Filter the `posts` table to include only posts created in 2010.\n2. From these posts, select the one with the maximum `FavoriteCount`.\n3. Join the result with the `users` table to get the owner's `DisplayName` using the `OwnerUserId` as the linking key.\n4. Return the post's `Id` and the owner's `DisplayName`.",
        "sql": "SELECT p.Id, u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE strftime('%Y', p.CreationDate) = '2010'\nORDER BY p.FavoriteCount DESC\nLIMIT 1;",
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "evidence": [
            "the most valuable post in 2015 refers to MAX(FavoriteCount) where year(CreationDate) = 2010;",
            "The `CreationDate` in the `users` table refers to when the user account was created, not the post creation date. The `posts` table contains the `CreationDate` for posts.",
            "The `CreationDate` in the `users` table refers to the user account creation date, not the post creation date. The `posts` table contains the `CreationDate` for posts.",
            "The `CreationDate` in the `users` table refers to the user account creation date, not the post creation date. The `posts` table contains the `CreationDate` for posts.\nTo identify the most valuable post, focus on the `FavoriteCount` in the `posts` table and filter by the post's `CreationDate`.\nThe join between `posts` and `users` should use `OwnerUserId` to link the post to its owner."
        ]
    },
    "1": {
        "reason": "To solve the question, we need to find the lowest three eligible free rates for students aged 5-17 in continuation schools. The eligible free rate is calculated as `Free Meal Count (Ages 5-17)` divided by `Enrollment (Ages 5-17)`. The steps are as follows:\n1. Filter the `frpm` table to include only continuation schools by checking the `Educational Option Type` column for the exact value 'Continuation School'.\n2. Calculate the eligible free rate for each school by dividing `Free Meal Count (Ages 5-17)` by `Enrollment (Ages 5-17)`.\n3. Exclude any rows where the calculated rate is null to ensure accurate results.\n4. Order the results by the calculated rate in ascending order to get the lowest rates.\n5. Limit the results to the top three rows to get the lowest three rates.",
        "sql": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` AS eligible_free_rate\nFROM frpm\nWHERE `Educational Option Type` = 'Continuation School'\nAND `Free Meal Count (Ages 5-17)` IS NOT NULL\nAND `Enrollment (Ages 5-17)` IS NOT NULL\nORDER BY eligible_free_rate ASC\nLIMIT 3;",
        "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3",
        "evidence": [
            "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
            "Continuation schools are identified by the `Educational Option Type` column, not the `School Type` column.\nThe calculation for eligible free rates should exclude null results to ensure accurate ordering.\nThe query should directly compute and order by the rate without intermediate column aliases.",
            "The `Educational Option Type` column uses exact matching for continuation schools, not pattern matching.\nThe query should filter for non-null results of the calculated rate directly, not its components.\nThe ordering should use the calculated rate expression directly, not an alias.",
            "The `Educational Option Type` column uses the exact value 'Continuation School' for filtering continuation schools.\nThe query should filter for non-null results of the calculated rate directly, not its components.\nThe ordering should use the calculated rate expression directly, not an alias."
        ]
    },
    "1330": {
        "reason": "To find the college that offers the major Tyler Hewitt took, we need to follow these steps:\n1. Identify Tyler Hewitt in the `member` table using his first and last name.\n2. Retrieve the `link_to_major` for Tyler Hewitt from the `member` table.\n3. Use the `link_to_major` to find the corresponding major in the `major` table.\n4. From the `major` table, retrieve the `college` associated with the major.\n\nThe query will join the `member` and `major` tables to fetch the required information.",
        "sql": "SELECT m.college\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Tyler' AND mb.last_name = 'Hewitt';",
        "question": "What college offers the major that Tyler Hewitt took?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'",
        "evidence": [
            ""
        ]
    },
    "882": {
        "reason": "To find the year of the first Singapore Grand Prix, we need to identify the earliest race in the 'races' table where the 'name' column contains 'Singapore Grand Prix'. We can achieve this by querying the 'races' table for the minimum 'year' where the 'name' matches the pattern 'Singapore Grand Prix'.",
        "sql": "SELECT MIN(year) AS first_year FROM races WHERE name LIKE '%Singapore Grand Prix%';",
        "question": "Which year was the first Singapore Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT year FROM races WHERE name = 'Singapore Grand Prix' ORDER BY year ASC LIMIT 1",
        "evidence": [
            "the first race refers to race happened in min(year);"
        ]
    },
    "515": {
        "reason": "To solve the question, we need to find the oldest mythic card and its legal play formats. Here's the step-by-step reasoning:\n\n1. **Identify the oldest mythic card**: \n   - Filter the `cards` table for cards with `rarity = 'mythic'` and non-null `originalReleaseDate`.\n   - Order the results by `originalReleaseDate` in ascending order and limit to 1 to get the oldest card.\n\n2. **Retrieve the legal play formats for this card**:\n   - Join the `legalities` table with the result from step 1 using the `uuid` of the oldest mythic card.\n   - Filter for `status = 'Legal'` to get only the legal formats.\n\n3. **Combine the results**:\n   - The query will return the `originalReleaseDate` of the oldest mythic card and the `format` from the `legalities` table where the status is 'Legal'.",
        "sql": "SELECT c.originalReleaseDate, l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic' AND c.originalReleaseDate IS NOT NULL AND l.status = 'Legal'\nORDER BY c.originalReleaseDate ASC\nLIMIT 1;",
        "question": "When was the oldest mythic card released and what are its legal play formats?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate LIMIT 1",
        "evidence": [
            "the oldest card refers to MIN(originalReleaseDate); mythic card refers to rarity = 'mythic'; legal play refers to status = 'legal'; play format refers to format",
            "Ensure filtering for non-null `originalReleaseDate` to accurately determine the oldest card. Legal play formats require `status = 'Legal'` (case-sensitive).",
            "To find the oldest card, use `ORDER BY originalReleaseDate ASC` with `LIMIT 1` instead of `MIN(originalReleaseDate)` for direct retrieval. Legal formats must be filtered by `status = 'Legal'` in the same query."
        ]
    },
    "1318": {
        "reason": "To find the event with the highest attendance, we need to count the number of attendees for each event. This involves joining the `event` table with the `attendance` table to get the event names and their corresponding attendance counts. We then group the results by `event_name` and count the `link_to_event` entries in the `attendance` table. Finally, we order the results by the count in descending order and limit the output to the top result to identify the event with the highest attendance.",
        "sql": "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nGROUP BY e.event_name\nORDER BY COUNT(a.link_to_event) DESC\nLIMIT 1;",
        "question": "What is the event that has the highest attendance of the students from the Student_Club?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_name ORDER BY COUNT(T2.link_to_event) DESC LIMIT 1",
        "evidence": [
            "event with highest attendance refers to MAX(COUNT(link_to_event))",
            "To identify the event with the highest attendance, group by `event_name` and count the `link_to_event` in the `attendance` table.\nThe `ORDER BY` clause should directly reference the count of attendees to sort events by attendance.\nThe `SELECT` clause should only include the `event_name` to match the output requirement."
        ]
    },
    "1110": {
        "reason": "To find the build-up play passing class for \"FC Lorient\" on 2010/2/22, we need to follow these steps:\n1. Identify the team_api_id for \"FC Lorient\" from the Team table.\n2. Use this team_api_id to find the corresponding Team_Attributes record for the date 2010-02-22.\n3. Retrieve the buildUpPlayPassingClass from the Team_Attributes table for this record.",
        "sql": "SELECT ta.buildUpPlayPassingClass \nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE t.team_long_name = 'FC Lorient' AND ta.date LIKE '2010-02-22%';",
        "question": "Tell the build Up play passing class for \"FC Lorient\" on 2010/2/22.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'FC Lorient' AND t2.`date` LIKE '2010-02-22%'",
        "evidence": [
            "\"FC Lorient\" refers to team_long_name = 'FC Lorient'; on 2010/2/22 refers to date LIKE '2010-02-22%';"
        ]
    },
    "1281": {
        "reason": "To solve the question, we need to find the youngest patient among those who have an abnormal level of glutamic oxaloacetic transaminase (GOT >= 60). The steps are as follows:\n1. Identify patients with GOT >= 60 from the Laboratory table.\n2. Join these patients with the Patient table to get their birth dates.\n3. Since the larger the birthday value, the younger the person is, we need to find the maximum birthday value among these patients.\n4. Retrieve the birth date of the youngest patient.",
        "sql": "SELECT MAX(p.Birthday) AS YoungestBirthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GOT >= 60;",
        "question": "Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60 ORDER BY T1.Birthday DESC LIMIT 1",
        "evidence": [
            "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; The larger the birthday value, the younger the person is, and vice versa;"
        ]
    },
    "367": {
        "reason": "To find the names of the artists who illustrated the card art in Phyrexian, we need to identify cards that have a Phyrexian language entry in the `foreign_data` table. The `foreign_data` table contains information about cards in different languages, including Phyrexian. We can join the `cards` table with the `foreign_data` table where the language is 'Phyrexian' and then retrieve the artist names from the `cards` table.",
        "sql": "SELECT DISTINCT c.artist FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Phyrexian';",
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "evidence": [
            "Phyrexian' is the language; name of artists refers to artist;"
        ]
    },
    "387": {
        "reason": "To find the cards for the set OGW and their colors, we need to query the `cards` table where the `setCode` is 'OGW'. The `cards` table contains the `setCode` field, which directly links to the set. Additionally, the `colors` field in the `cards` table stores the color information for each card. Therefore, the query will select the `name` and `colors` fields from the `cards` table where `setCode` equals 'OGW'.",
        "sql": "SELECT name, colors FROM cards WHERE setCode = 'OGW';",
        "question": "What are the cards for set OGW? State the colour for these cards.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT id, colors FROM cards WHERE id IN ( SELECT id FROM set_translations WHERE setCode = 'OGW' )",
        "evidence": [
            "set OGW refers to setCode = 'OGW';",
            "The `set_translations` table links set codes to translations, but the `cards` table does not directly store set codes. To find cards for a specific set, join or subquery with `set_translations` is required.",
            "The `cards` table includes a `setCode` field, but the relationship between cards and sets is not directly stored in the `set_translations` table. To link cards to a specific set, use the `setCode` field in the `cards` table.",
            "The `set_translations` table maps set codes to translations but does not directly link to card IDs. To find cards for a specific set, use the `setCode` field in the `cards` table."
        ]
    },
    "513": {
        "reason": "To solve the question, we need to identify the set with the highest total number of cards among sets whose expansion type is 'Commander'. The question specifies that we should include promotional and related supplemental products but exclude Alchemy modifications. The schema provides a table called 'sets' which contains the relevant fields: 'type' (to filter for 'Commander') and 'totalSetSize' (to determine the highest number of cards). The steps are as follows:\n1. Filter the 'sets' table to include only rows where 'type' is 'Commander'.\n2. From the filtered rows, select the set with the maximum 'totalSetSize'.\n3. Retrieve the 'id' of this set.",
        "sql": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1;",
        "question": "Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1",
        "evidence": [
            "expansion type refers to type where type = 'commander'; totalSetSize: The total number of cards in the set, including promotional and related supplemental products but excluding Alchemy modifications; highest total number of cards refers to MAX(totalSetSize)"
        ]
    },
    "753": {
        "reason": "To solve the question, we need to find superheroes with a height between 170 cm and 190 cm and no eye color. The steps are as follows:\n1. Identify the superheroes with height_cm BETWEEN 170 AND 190.\n2. Among these, filter those with no eye color, which is indicated by eye_colour_id referencing a colour with colour = 'No Colour'.\n3. Join the superhero table with the colour table to check the eye color condition.\n4. Return the superhero_name from the filtered results.",
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.height_cm BETWEEN 170 AND 190\nAND c.colour = 'No Colour';",
        "question": "Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'",
        "evidence": [
            "height from 170 to 190 refers to height_cm BETWEEN 170 AND 190; no eye color refers to colour = 'No Colour'"
        ]
    },
    "1041": {
        "reason": "To solve the question, we need to follow these steps:\n1. Identify teams with a normal build-up play dribbling class in 2014. This involves filtering the `Team_Attributes` table for records where `buildUpPlayDribblingClass` is 'Normal' and the year extracted from the `date` field is 2014.\n2. Calculate the average `chanceCreationPassing` for these teams. This average will be used as a dynamic threshold.\n3. Filter the teams to include only those with `chanceCreationPassing` less than the calculated average.\n4. List the team names (`team_long_name`) in descending order of `chanceCreationPassing`.\n\nThe query will involve joining the `Team` and `Team_Attributes` tables to get the team names and their attributes. The average will be calculated in a subquery to ensure it is dynamic and based on the filtered dataset.",
        "sql": "WITH NormalDribblingTeams AS (\n    SELECT \n        t.team_long_name,\n        ta.chanceCreationPassing\n    FROM \n        Team_Attributes ta\n    JOIN \n        Team t ON ta.team_api_id = t.team_api_id\n    WHERE \n        ta.buildUpPlayDribblingClass = 'Normal'\n        AND SUBSTR(ta.date, 1, 4) = '2014'\n),\nAverageChanceCreation AS (\n    SELECT \n        AVG(chanceCreationPassing) AS avg_chance_creation\n    FROM \n        NormalDribblingTeams\n)\nSELECT \n    team_long_name,\n    chanceCreationPassing\nFROM \n    NormalDribblingTeams\nWHERE \n    chanceCreationPassing < (SELECT avg_chance_creation FROM AverageChanceCreation)\nORDER BY \n    chanceCreationPassing DESC;",
        "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
        "evidence": [
            "normal build-up play dribbling class refers to buildUpPlayDribblingClass = 'Normal'; in 2014 refers to date > = '2014-01-01 00:00:00' AND date < = '2014-01-31 00:00:00'; names of the teams refers to team_long_name; less than average chance creation passing = DIVIDE(SUM(chanceCreationPassing), COUNT(id)) > chanceCreationPassing;",
            "The average chance creation passing should be calculated only for teams with normal build-up play dribbling class in 2014, not all teams. The date filter for 2014 should use SUBSTR to extract the year.",
            "The average chance creation passing must be calculated dynamically for teams with normal build-up play dribbling class in 2014, not pre-filtered. The comparison should use the calculated average directly in the WHERE clause.",
            "The average chance creation passing must be calculated dynamically for teams with normal build-up play dribbling class in 2014, not pre-filtered. The comparison should use the calculated average directly in the WHERE clause."
        ]
    },
    "856": {
        "reason": "To find the time of the races held on the Sepang International Circuit, we need to follow these steps:\n1. Identify the circuitId of the Sepang International Circuit from the circuits table.\n2. Use this circuitId to find all races held at this circuit in the races table.\n3. Retrieve the time of these races from the races table.",
        "sql": "SELECT r.time \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.name = 'Sepang International Circuit';",
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "evidence": [
            ""
        ]
    },
    "27": {
        "reason": "To solve the question, we need to find the average writing score for schools that were either opened after 1991 or closed before 2000. The steps are as follows:\n1. Identify schools from the `schools` table that meet the criteria: `OpenDate` after 1991 or `ClosedDate` before 2000.\n2. Use the `strftime` function to extract the year from `OpenDate` and `ClosedDate` for comparison.\n3. Join these schools with the `satscores` table to get their average writing scores (`AvgScrWrite`).\n4. Include the school names (`sname` from `satscores` or `School` from `schools`) and the communication number (`Phone` from `schools`).\n5. Use a `LEFT JOIN` to ensure schools without SAT scores are still included, and handle NULL values for the writing scores.",
        "sql": "SELECT \n    COALESCE(satscores.sname, schools.School) AS SchoolName,\n    satscores.AvgScrWrite AS AverageWritingScore,\n    schools.Phone AS CommunicationNumber\nFROM \n    schools\nLEFT JOIN \n    satscores ON schools.CDSCode = satscores.cds\nWHERE \n    (strftime('%Y', schools.OpenDate) > '1991' OR strftime('%Y', schools.ClosedDate) < '2000')\n    AND (schools.OpenDate IS NOT NULL OR schools.ClosedDate IS NOT NULL);",
        "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
        "evidence": [
            "Communication number refers to phone number.",
            "The `OpenDate` and `ClosedDate` fields in the `schools` table are of type DATE, requiring date-specific functions like `strftime` for year comparisons.\nA LEFT JOIN ensures all qualifying schools are included, even if they lack SAT score data.",
            "The `strftime` function is necessary for extracting year components from `OpenDate` and `ClosedDate` fields to compare against specific years.\nLEFT JOIN ensures inclusion of all qualifying schools, even those without SAT score data, while NULL handling for scores is optional.",
            "The `Phone` field in the `schools` table represents the communication number, and it should be included regardless of whether the school has SAT score data.\nThe `LEFT JOIN` ensures all qualifying schools are included, even if they lack SAT score data, and NULL handling for scores is optional."
        ]
    },
    "456": {
        "reason": "To find the list of all types for the card \"Molimo, Maro-Sorcerer\", we need to query the `cards` table where the `name` column matches \"Molimo, Maro-Sorcerer\". The types of the card are stored in the `subtypes` and `supertypes` columns. We will combine these columns to get the complete list of types for the card.",
        "sql": "SELECT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';",
        "question": "What's the list of all types for the card \"Molimo, Maro-Sorcerer\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'",
        "evidence": [
            "card \"Molimo, Maro-Sorcerer\" refers to name = 'Molimo, Maro-Sorcerer'; list of all types refers to subtypes,supertypes"
        ]
    },
    "291": {
        "reason": "To solve the question, we need to count the number of chemical compounds (molecules) in the database that are identified as carcinogenic. According to the tips, molecules with the label '+' are carcinogenic. The steps are as follows:\n1. Query the `molecule` table to filter rows where the `label` is '+', indicating carcinogenic molecules.\n2. Count the number of such rows to get the total number of carcinogenic chemical compounds.",
        "sql": "SELECT COUNT(*) FROM molecule WHERE label = '+';",
        "question": "How many chemical compounds in the database are identified as carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
        "evidence": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "542": {
        "reason": "To find the total number of comments for all posts owned by 'csgillespie', we need to follow these steps:\n1. Identify the user 'csgillespie' in the `users` table to get their `Id`.\n2. Use this `Id` to find all posts owned by 'csgillespie' in the `posts` table.\n3. For each of these posts, sum the `CommentCount` from the `posts` table to get the total number of comments.\n\nThe query will join the `users` and `posts` tables to achieve this.",
        "sql": "SELECT SUM(p.CommentCount) AS TotalComments\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';",
        "question": "What is the total number of comments of all the posts owned by csgillespie?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.CommentCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "evidence": [
            "\"csgillespie\" is the DisplayName of user; total number of comments refers to Sum(CommentCount)"
        ]
    },
    "1154": {
        "reason": "To solve the question, we need to retrieve the sex and birthday of the patient with ID '163109' from the Patient table. Additionally, we need to find the examination date and symptoms from the Examination table for the same patient. The query involves joining the Patient and Examination tables on the ID field to get all the required information in one result set.",
        "sql": "SELECT p.SEX, p.Birthday, e.\"Examination Date\", e.Symptoms\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.ID = 163109;",
        "question": "State the sex and birthday of patient ID '163109'. When was the examination taken and what symptom does the patient had.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.SEX, T1.Birthday, T2.`Examination Date`, T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = 163109",
        "evidence": [
            "When was the examination taken refers to `Examination Date`"
        ]
    },
    "126": {
        "reason": "To calculate the percentage of accounts from the 'Decin' district that were opened in 1993, we need to follow these steps:\n1. Identify the district_id for 'Decin' from the district table.\n2. Count the total number of accounts opened in 1993.\n3. Count the number of accounts opened in 1993 from the 'Decin' district.\n4. Calculate the percentage by dividing the count from step 3 by the count from step 2 and multiplying by 100.\n\nThe query will involve joining the account and district tables to filter accounts by district and date.",
        "sql": "WITH decin_accounts AS (\n    SELECT COUNT(*) AS decin_count\n    FROM account\n    JOIN district ON account.district_id = district.district_id\n    WHERE district.A2 = 'Decin'\n    AND strftime('%Y', account.date) = '1993'\n),\ntotal_1993_accounts AS (\n    SELECT COUNT(*) AS total_count\n    FROM account\n    WHERE strftime('%Y', account.date) = '1993'\n)\nSELECT (decin_count * 100.0 / total_count) AS percentage\nFROM decin_accounts, total_1993_accounts;",
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "evidence": [
            "A2 contains the information about district."
        ]
    },
    "898": {
        "reason": "To find the youngest Japanese driver and their age, we need to:\n1. Filter drivers by nationality 'Japanese'.\n2. Calculate their age by subtracting their birth year (extracted from `dob`) from the current year (extracted from `CURRENT_TIMESTAMP`).\n3. Order the results by `dob` in descending order to find the youngest driver.\n4. Limit the result to the first row to get the youngest driver.\n5. Display the driver's name and calculated age.",
        "sql": "SELECT forename || ' ' || surname AS name, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob) AS age FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1;",
        "question": "How old is the youngest Japanese driver? What is his name?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
        "evidence": [
            "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);",
            "The age calculation requires the current timestamp to ensure accuracy; the youngest driver is determined by the latest date of birth (dob) in descending order.",
            "The age calculation should use `CURRENT_TIMESTAMP` for accurate results; the youngest driver is identified by the latest `dob` in descending order.",
            "The `STRFTIME` function is used to extract the year from `dob` and `CURRENT_TIMESTAMP` for accurate age calculation; the youngest driver is identified by the latest `dob` in descending order."
        ]
    },
    "514": {
        "reason": "To solve the question, we need to find the top 10 cards with the highest unconverted mana cost in the 'duel' format. The steps are as follows:\n1. Identify cards that are legal in the 'duel' format by querying the `legalities` table where `format = 'duel'`.\n2. Join the results with the `cards` table to get the unconverted mana cost (`manaCost`) and other relevant details.\n3. Order the results by `manaCost` in descending order to get the highest values first.\n4. Limit the results to the top 10 cards.\n5. Ensure distinct card names to avoid duplicates.",
        "sql": "SELECT DISTINCT c.name, c.manaCost\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'duel'\nORDER BY c.manaCost DESC\nLIMIT 10;",
        "question": "In duels, what are the top 10 cards with the highest uncoverted mana cost?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 0, 10",
        "evidence": [
            "duels refer to format = 'duel'; the highest uncoverted mana cost refers to MAX(manaCost)",
            "The `manaCost` column in the `cards` table stores the unconverted mana cost, not `convertedManaCost`.\nTo filter cards for the 'duel' format, use a subquery with `legalities` table where `format = 'duel'`.\nDISTINCT ensures no duplicate card names are returned.",
            "The `manaCost` column in the `cards` table should be used for ordering, but the query must filter cards by their `uuid` in the `legalities` table where `format = 'duel'`.\nSubqueries are more efficient for filtering based on conditions in related tables.\nDISTINCT ensures unique card names, but the primary filtering should occur in the subquery.",
            "The `manaCost` column in the `cards` table should be used for ordering, but the query must filter cards by their `uuid` in the `legalities` table where `format = 'duel'`.\nSubqueries are more efficient for filtering based on conditions in related tables.\nDISTINCT ensures unique card names, but the primary filtering should occur in the subquery."
        ]
    },
    "975": {
        "reason": "To determine the year with the lowest speed of lap time, we need to analyze the lap times recorded in the `lapTimes` table. The tip suggests that the lowest speed corresponds to the maximum lap time (`Max(time)`). Here's the step-by-step reasoning:\n\n1. **Identify the relevant table**: The `lapTimes` table contains the lap time data, including `raceId`, `driverId`, `lap`, and `time`.\n2. **Link to the `races` table**: The `raceId` in `lapTimes` can be joined with the `races` table to get the `year` of the race.\n3. **Find the slowest lap time**: We need to find the maximum lap time (`Max(time)`) across all records in the `lapTimes` table.\n4. **Determine the year**: Once the slowest lap time is identified, we can retrieve the corresponding year from the `races` table.\n\nThis involves joining the `lapTimes` and `races` tables, grouping by year, and then finding the year with the maximum lap time.",
        "sql": "SELECT r.year\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nGROUP BY r.year\nORDER BY MAX(lt.time) DESC\nLIMIT 1;",
        "question": "Which year has the lowest speed of lap time?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId ORDER BY T1.time DESC LIMIT 1",
        "evidence": [
            "lowest speed of lap time refers to Max(time);"
        ]
    },
    "477": {
        "reason": "To determine which artists (Jeremy Jarvis, Aaron Miller, or Chippy) have designed a card in the set 'Coldsnap', we need to follow these steps:\n1. Identify the set 'Coldsnap' in the `sets` table to get its `code`.\n2. Join the `cards` table with the `sets` table using the `setCode` field to find all cards in the 'Coldsnap' set.\n3. Filter the results to include only cards where the `artist` is one of the three specified artists (Jeremy Jarvis, Aaron Miller, or Chippy).\n4. Select the distinct `artist` names from the filtered results to avoid duplicates.\n\nThe query will involve joining the `cards` and `sets` tables and filtering based on the artist names and set code.",
        "sql": "SELECT DISTINCT c.artist\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Coldsnap'\nAND c.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy');",
        "question": "Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (T2.name = 'Coldsnap' AND T1.artist = 'Chippy') OR (T2.name = 'Coldsnap' AND T1.artist = 'Aaron Miller') OR (T2.name = 'Coldsnap' AND T1.artist = 'Jeremy Jarvis') GROUP BY T1.artist",
        "evidence": [
            "card set Coldsnap refers to name = 'Coldsnap'; Jeremy Jarvis, Aaron Miller or Chippy are the name of artists which refers to artist IN ('Jeremy Jarvis', 'Aaron Miller','Chippy');"
        ]
    },
    "1295": {
        "reason": "To solve the question, we need to identify patients who meet two conditions: 1) their total bilirubin (`T-BIL`) is over the normal range (>= 2.0), and 2) their ANA examination shows a peripheral pattern (ANA Pattern contains 'P'). The steps to achieve this are:\n\n1. **Filter patients with elevated bilirubin**: Query the `Laboratory` table for records where `T-BIL` >= 2.0.\n2. **Filter patients with peripheral ANA pattern**: Query the `Examination` table for records where `ANA Pattern` contains 'P'.\n3. **Join the results**: Ensure the patients from both conditions are the same by joining the filtered results on the patient `ID`.\n4. **Count distinct patients**: Count the unique patient IDs from the joined results to avoid duplicates.\n5. **Ensure referential integrity**: Join with the `Patient` table to confirm the IDs are valid and to count distinct patients accurately.",
        "sql": "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.`T-BIL` >= 2.0\nAND E.`ANA Pattern` LIKE '%P%';",
        "question": "Among the patients whose total bilirubin is over the normal range, how many of them have a peripheral pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` >= 2 AND T3.`ANA Pattern` LIKE '%P%'",
        "evidence": [
            "total bilirubin is over the normal range refers to `T-BIL` > = 2.0; peripheral pattern is observed in the sheet of ANA examination refers to that ANA Pattern contains 'P';",
            "The `T-BIL` column in the Laboratory table stores total bilirubin values, and the threshold for over the normal range is >= 2.0.\nThe `ANA Pattern` column in the Examination table indicates peripheral patterns when it contains 'P'.\nThe query requires counting distinct patients meeting both conditions, not just filtering records.",
            "The query requires joining the Patient table to ensure all referenced IDs are valid and to count distinct patients.\nThe join should include the Patient table to maintain referential integrity and avoid counting invalid IDs.\nCounting distinct patients is achieved by referencing the Patient table directly in the final count.",
            "The `T-BIL` column in the Laboratory table must be filtered for values >= 2.0 to identify patients with elevated total bilirubin.\nThe `ANA Pattern` column in the Examination table must be checked for the presence of 'P' to identify peripheral patterns.\nCounting distinct patients requires referencing the Patient table directly to ensure unique patient IDs are considered."
        ]
    },
    "860": {
        "reason": "To solve the question, we need to find the nationality of the driver who had a Q2 time of '0:01:40' in the qualifying race with raceId 355. The steps are as follows:\n1. Identify the driverId from the qualifying table where raceId is 355 and q2 time is '0:01:40'.\n2. Use the driverId to look up the driver's nationality in the drivers table.\n3. Join the qualifying table with the drivers table to retrieve the nationality of the identified driver.",
        "sql": "SELECT d.nationality \nFROM drivers d \nJOIN qualifying q ON d.driverId = q.driverId \nWHERE q.raceId = 355 AND q.q2 = '0:01:40';",
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "evidence": [
            "race number refers to raceId;",
            "q2 time in qualifying table may use partial matching for time values.\nraceId is the primary key for identifying races in the qualifying table.",
            "q2 time in qualifying table may require partial matching for time values, such as using LIKE with a wildcard.\ndistinct is used to ensure unique results when joining tables.",
            "q2 time in qualifying table may require partial matching for time values, such as using LIKE with a wildcard.\ndistinct is used to ensure unique results when joining tables."
        ]
    },
    "790": {
        "reason": "To calculate the difference between Emil Blonsky's weight and Charles Chandler's weight, we need to:\n1. Identify the superhero entries for Emil Blonsky and Charles Chandler in the `superhero` table.\n2. Retrieve their respective weights (`weight_kg`).\n3. Subtract Charles Chandler's weight from Emil Blonsky's weight to find the difference.\n\nThe query will involve joining the `superhero` table with itself to compare the weights of the two individuals.",
        "sql": "SELECT (e.weight_kg - c.weight_kg) AS weight_difference\nFROM superhero e, superhero c\nWHERE e.full_name = 'Emil Blonsky'\nAND c.full_name = 'Charles Chandler';",
        "question": "Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky' ) - ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler' ) AS CALCULATE",
        "evidence": [
            "difference = SUBTRACT(SUM(weight_kg WHERE full_name = 'Emil Blonsky'), SUM(weight_kg WHERE full_name = 'Charles Chandler')); Emil Blonsky is the full name of superhero; Charles Chandler is the full name of superhero;"
        ]
    },
    "1208": {
        "reason": "To solve the question, we need to find male patients (SEX = 'M') who have a history of ALT glutamic pyruvic transaminase (GPT) exceeding the normal range (GPT >= 60). The steps are as follows:\n1. Identify male patients from the Patient table.\n2. Join the Patient table with the Laboratory table to access GPT values.\n3. Filter records where GPT >= 60.\n4. Ensure the patients are male (SEX = 'M').\n5. Return the distinct IDs of these patients to avoid duplicates.",
        "sql": "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.GPT >= 60;",
        "question": "Provide IDs for male patients with ALT glutamic pylvic transaminase (GPT) that have history of ALT glutamic pylvic transaminase (GPT) exceed the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.GPT >= 60",
        "evidence": [
            "male refers to SEX = 'M'; ALT glutamic pylvic transaminase (GPT) exceed the normal range refers to GPT > = 60"
        ]
    },
    "258": {
        "reason": "To find the bond types for atoms with the element Tin (Sn), we need to follow these steps:\n1. Identify all atoms with the element 'sn' (Tin) in the `atom` table.\n2. For each of these atoms, find the bonds they are involved in by joining the `connected` table.\n3. Retrieve the bond types from the `bond` table for these bonds.\n4. The query will involve joining the `atom`, `connected`, and `bond` tables to get the required information.",
        "sql": "SELECT DISTINCT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'sn';",
        "question": "What are the bond type for atoms with element Tin?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "evidence": [
            "element Tin refers to element = 'sn'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#'"
        ]
    },
    "1368": {
        "reason": "To find out what the person with the phone number \"809-555-3360\" majors in, we need to follow these steps:\n1. Identify the member with the phone number \"809-555-3360\" in the `member` table.\n2. Retrieve the `link_to_major` field for this member, which references the `major_id` in the `major` table.\n3. Join the `member` table with the `major` table using the `link_to_major` field to get the major details.\n4. Select the `major_name` from the `major` table for the identified member.",
        "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.phone = '809-555-3360';",
        "question": "What does the person with the phone number \"809-555-3360\" major in?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.phone = '809-555-3360'",
        "evidence": [
            "major in refers to major_name"
        ]
    },
    "1025": {
        "reason": "To find the league with the most goals in the 2016 season, we need to:\n1. Filter matches from the 2016 season (season = '2015/2016').\n2. Calculate the total goals for each match by summing the home_team_goal and away_team_goal.\n3. Group the results by league_id to aggregate the total goals per league.\n4. Join the Match table with the League table to get the league names.\n5. Order the results by the total goals in descending order to find the league with the highest total goals.\n6. Limit the result to 1 to get the top league.",
        "sql": "SELECT l.name \nFROM Match m \nJOIN League l ON m.league_id = l.id \nWHERE m.season = '2015/2016' \nGROUP BY m.league_id \nORDER BY SUM(m.home_team_goal + m.away_team_goal) DESC \nLIMIT 1;",
        "question": "Give the name of the league had the most goals in the 2016 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' GROUP BY t2.name ORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC LIMIT 1",
        "evidence": [
            "league that had the most goals refers to MAX(SUM(home_team_goal, away_team_goal)); 2016 season refers to season = '2015/2016';",
            "The league name is retrieved directly from the League table, not through an intermediate join. Grouping by league name ensures the correct aggregation of goals per league.",
            "The aggregation of goals should be directly used in the ORDER BY clause to determine the league with the highest total goals. The SELECT clause can focus solely on the league name."
        ]
    },
    "1341": {
        "reason": "To find the location for the event named \"Spring Budget Review\", I need to query the `event` table. The `event_name` column contains the name of the event, and the `location` column contains the location. I will filter the `event` table for the row where `event_name` is \"Spring Budget Review\" and retrieve the `location` value.",
        "sql": "SELECT location FROM event WHERE event_name = 'Spring Budget Review';",
        "question": "Give the location for \"Spring Budget Review\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT location FROM event WHERE event_name = 'Spring Budget Review'",
        "evidence": [
            "'Spring Budget Review' is an event name;"
        ]
    },
    "1307": {
        "reason": "To solve the question, we need to identify patients who meet two conditions: \n1. They have an abnormal level of red blood cells (RBC), which is defined as RBC \u2264 3.5 or RBC \u2265 6.0.\n2. They are followed at the outpatient clinic, which is indicated by Admission = '-' in the Patient table.\n\nWe will join the Patient and Laboratory tables to check these conditions. The query will filter patients based on their RBC levels and Admission status.",
        "sql": "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE (L.RBC <= 3.5 OR L.RBC >= 6.0) AND P.Admission = '-';",
        "question": "Please list the patient's ID if he or she has an abnormal level of red blood cell and is followed at the outpatient clinic.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RBC <= 3.5 OR T2.RBC >= 6) AND T1.Admission = '-'",
        "evidence": [
            "RBC < = 3.5 or RBC > = 6.0 means the patient has an abnormal level of red blood cell; 3.5 < RBC < 6.0 means the patient has a normal level of red blood cell; followed at the outpatient clinic refers to Admission = '-';"
        ]
    },
    "1049": {
        "reason": "To find the number of matches in the 2015/2016 season held in the Scotland Premier League, we need to:\n1. Identify the league_id for the Scotland Premier League from the League table.\n2. Count the number of matches in the Match table where the league_id matches the identified league_id and the season is '2015/2016'.",
        "sql": "SELECT COUNT(*) \nFROM \"Match\" \nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Scotland Premier League') \nAND season = '2015/2016';",
        "question": "How many matches in the 2015/2016 season were held in Scotland Premier League\n?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' AND t1.name = 'Scotland Premier League'",
        "evidence": [
            "Scotland Premier League refers to League.name = 'Scotland Premier League';"
        ]
    },
    "879": {
        "reason": "To find the nationality of the driver who set the fastest lap speed, we need to follow these steps:\n1. Identify the driver with the fastest lap speed from the `results` table. The `fastestLapSpeed` column in the `results` table contains this information.\n2. Once we have the `driverId` of this driver, we can join the `results` table with the `drivers` table to retrieve the driver's nationality.\n3. The query will involve selecting the `nationality` from the `drivers` table where the `driverId` matches the one found in the `results` table with the highest `fastestLapSpeed`.",
        "sql": "SELECT d.nationality \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nWHERE r.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results);",
        "question": "For the driver who set the fastest lap speed, what is his nationality?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "evidence": [
            "the fastest lap speed refers to (MAX) fastestLapSpeed;"
        ]
    },
    "499": {
        "reason": "To find the number of translations for the set \"Tenth Edition\", we need to query the `set_translations` table. The `set_translations` table contains translations linked to sets via the `setCode` column. The set \"Tenth Edition\" is referenced by its name in the `sets` table, so we first need to find the `code` for \"Tenth Edition\" in the `sets` table. Once we have the `code`, we can count the distinct translations in the `set_translations` table where the `setCode` matches the found `code` and the `translation` is not NULL.",
        "sql": "SELECT COUNT(DISTINCT translation) AS translation_count FROM set_translations WHERE setCode = (SELECT code FROM sets WHERE name = 'Tenth Edition') AND translation IS NOT NULL;",
        "question": "How many translations of the name of the set \"Tenth Edition\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL",
        "evidence": [
            "translations of the name refers to translation; translation is not NULL; set \"Salvat 2011\" refers to name = 'Tenth Edition'",
            "Translations are stored in the set_translations table, linked to sets via the setCode column. Distinct translations must be counted to avoid duplicates. Non-null translations are required for valid results."
        ]
    },
    "445": {
        "reason": "To solve the question, we need to find the language and flavor text of the card that has a 'colorpie' watermark. Additionally, we need to list the type of this card. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `cards` table contains the watermark information, and the `foreign_data` table contains the language and flavor text for cards in different languages.\n\n2. **Filter cards with 'colorpie' watermark**: We need to query the `cards` table to find cards where the `watermark` field is 'colorpie'.\n\n3. **Join with `foreign_data` table**: Once we have the card(s) with the 'colorpie' watermark, we join the `cards` table with the `foreign_data` table using the `uuid` field to retrieve the language and flavor text.\n\n4. **Select the required fields**: We need to select the `language` and `flavorText` from the `foreign_data` table, and the `type` from the `cards` table.\n\n5. **Ensure uniqueness**: Since the `foreign_data` table may contain multiple entries for the same card in different languages, we use `DISTINCT` to avoid duplicates.\n\n6. **Final query**: The query will join the `cards` and `foreign_data` tables, filter for 'colorpie' watermark, and select the required fields.",
        "sql": "SELECT DISTINCT fd.language, fd.flavorText, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'colorpie';",
        "question": "What is the language and flavor text of the card that has colorpie watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T2.language, T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'colorpie'",
        "evidence": [
            "",
            "The `foreign_data` table may contain multiple entries for the same card in different languages, so `DISTINCT` is needed to avoid duplicates.\nThe `type` field is not required in the output, so it should be excluded from the selection.",
            "The `type` field from the `cards` table is not required in the output, so it should be excluded from the selection.\nThe `foreign_data` table contains language-specific data, so joining it with the `cards` table is necessary to retrieve the relevant flavor text and language.",
            "The `type` field from the `cards` table is not required in the output, so it should be excluded from the selection.\nThe `foreign_data` table contains language-specific data, so joining it with the `cards` table is necessary to retrieve the relevant flavor text and language."
        ]
    },
    "1213": {
        "reason": "To solve the question, we need to find the patient born on April 1st, 1982, and then check if their ALP (alkaline phosphatase) is within the normal range (ALP < 300). The steps are as follows:\n1. Query the `Patient` table to find the ID of the patient born on April 1st, 1982.\n2. Join the `Patient` table with the `Laboratory` table to retrieve the ALP value for this patient.\n3. Use a `CASE` statement to determine if the ALP is within the normal range (normal if ALP < 300, abnormal otherwise).\n4. Ensure we are checking the latest ALP value by ordering the results by date in descending order and limiting to the first record.",
        "sql": "SELECT p.ID, \n       CASE \n           WHEN l.ALP < 300 THEN 'normal'\n           ELSE 'abnormal'\n       END AS ALP_status\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Birthday = '1982-04-01'\nORDER BY l.Date DESC\nLIMIT 1;",
        "question": "Name the ID of the patient who is born on the April 1st, 1982. Is his/her alkaliphophatase (ALP) within normal range?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T1.ID , CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1982-04-01'",
        "evidence": [
            "alkaliphophatase (ALP) within normal range refers to ALP < 300",
            "The `Laboratory` table contains multiple entries per patient, so joining without filtering for the latest or a specific date may return multiple ALP values.\nThe `CASE` statement in SQL can directly output 'normal' or 'abNormal' without additional column aliases.",
            "The `Laboratory` table contains multiple entries per patient, so joining without filtering for the latest or a specific date may return multiple ALP values.\nThe `CASE` statement in SQL can directly output 'normal' or 'abNormal' without additional column aliases."
        ]
    },
    "1294": {
        "reason": "To solve the question, we need to find patients whose creatinine level (CRE) is normal (CRE < 1.5) and whose anti-Cardiolipin antibody concentration level (aCL IgA) is the highest. The steps are as follows:\n1. Identify patients with normal creatinine levels (CRE < 1.5) from the Laboratory table.\n2. From these patients, find the one with the highest aCL IgA value from the Examination table.\n3. Since the question asks for the patient's ID, we will join the Laboratory and Examination tables on the patient ID to filter and retrieve the required data.\n4. Use ORDER BY and LIMIT to find the highest aCL IgA value.",
        "sql": "SELECT l.ID \nFROM Laboratory l \nJOIN Examination e ON l.ID = e.ID \nWHERE l.CRE < 1.5 \nORDER BY e.`aCL IgA` DESC \nLIMIT 1;",
        "question": "Please list the patient's ID whose creatinine level is normal and whose anti Cardiolipin antibody concentration level is the highest.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.CRE < 1.5 ORDER BY T2.`aCL IgA` DESC LIMIT 1",
        "evidence": [
            "creatinine level is normal refers to CRE < 1.5; anti Cardiolipin antibody concentration level is the highest refers to MAX(aCL IgA);",
            "To find the highest value, use ORDER BY with DESC and LIMIT 1 instead of a subquery with MAX.\nJoining tables directly without referencing the Patient table suffices when only Laboratory and Examination data are needed."
        ]
    },
    "144": {
        "reason": "To solve the question, we need to calculate the average amount of credit card transactions made by account holders in a month during the year 2021. Here's the step-by-step reasoning:\n\n1. **Identify Credit Card Transactions**: The `trans` table contains transaction details, and the `operation` column with value 'VYBER KARTOU' indicates credit card transactions.\n\n2. **Filter by Year**: We need to filter transactions from the year 2021 using the `date` column in the `trans` table.\n\n3. **Link to Account Holders with Credit Cards**: The `card` table identifies credit card holders. To link transactions to these holders, we need to join the `trans` table with the `account` table, then join the `account` table with the `disp` table (which links accounts to clients), and finally join the `disp` table with the `card` table to ensure the transactions are from credit card holders.\n\n4. **Calculate Monthly Average**: Group the transactions by month and calculate the average amount for each month in 2021.\n\n5. **Final Output**: The query should return the average transaction amount for each month in 2021.",
        "sql": "SELECT \n    strftime('%m', t.date) AS month,\n    AVG(t.amount) AS average_amount\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    card c ON d.disp_id = c.disp_id\nWHERE \n    t.operation = 'VYBER KARTOU'\n    AND strftime('%Y', t.date) = '2021'\nGROUP BY \n    month\nORDER BY \n    month;",
        "question": "How much is the average amount in credit card made by account holders in a month, in year 2021?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT AVG(T4.amount) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE STRFTIME('%Y', T4.date) = '1998' AND T4.operation = 'VYBER KARTOU'",
        "evidence": [
            "Operation = 'VYBER KARTOU' refers to credit card withdrawn",
            "The `card` table links to `disp` and `account` tables, which are necessary to identify account holders with credit cards.\nTransactions with operation 'VYBER KARTOU' must be linked to accounts via the `disp` and `card` tables to ensure they are credit card transactions.\nThe `trans` table records the transaction details, including the amount and operation type, which are required for calculating the average.",
            "The `card` table must be joined to `disp` and `account` to identify credit card holders, but the `trans` table should be linked directly to `account` for transaction details.\nThe `operation` column in `trans` filters credit card transactions, but the join path must ensure only account holders with credit cards are included.\nThe `date` column in `trans` is used to filter transactions by year, but the join sequence must prioritize linking `card` to `account` first.",
            "The `card` table must be joined to `disp` and `account` to identify credit card holders, but the `trans` table should be linked directly to `account` for transaction details.\nThe `operation` column in `trans` filters credit card transactions, but the join path must ensure only account holders with credit cards are included.\nThe `date` column in `trans` is used to filter transactions by year, but the join sequence must prioritize linking `card` to `account` first."
        ]
    },
    "14": {
        "reason": "To solve the question, we need to list the top five schools with the highest enrollment for ages 5-17. The enrollment data is stored in the `frpm` table, while the NCES school identification number is stored in the `schools` table. We will join these two tables using the `CDSCode` field, which is common in both tables. The result will be sorted by `Enrollment (Ages 5-17)` in descending order and limited to five rows to get the top schools.",
        "sql": "SELECT s.NCESSchool, f.\"Enrollment (Ages 5-17)\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nORDER BY f.\"Enrollment (Ages 5-17)\" DESC\nLIMIT 5;",
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "evidence": [
            "",
            "The `NCESSchool` field in the `schools` table uniquely identifies schools by their NCES school identification number.\nTo retrieve the top schools by enrollment, join the `frpm` and `schools` tables using the `CDSCode` as the linking field.\nSorting by `Enrollment (Ages 5-17)` in descending order ensures the highest values appear first.",
            "The `NCESSchool` field in the `schools` table is the primary identifier for NCES school numbers and must be selected directly from the `schools` table.\nJoining `frpm` and `schools` tables via `CDSCode` ensures accurate linkage for enrollment data retrieval.\nSorting by `Enrollment (Ages 5-17)` in descending order and limiting to five rows retrieves the top schools.",
            "The `NCESSchool` field in the `schools` table is the primary identifier for NCES school numbers and must be selected directly from the `schools` table.\nJoining `frpm` and `schools` tables via `CDSCode` ensures accurate linkage for enrollment data retrieval.\nSorting by `Enrollment (Ages 5-17)` in descending order and limiting to five rows retrieves the top schools."
        ]
    },
    "556": {
        "reason": "To find the average number of badges obtained by users with over 200 views, we need to follow these steps:\n1. Identify users who have more than 200 views from the `users` table.\n2. For each of these users, count the number of badges they have obtained from the `badges` table.\n3. Calculate the average of these counts to get the desired result.\n\nThe query will involve joining the `users` and `badges` tables, filtering users with views > 200, grouping by user, counting badges per user, and then averaging these counts.",
        "sql": "SELECT AVG(badge_count) AS average_badges\nFROM (\n    SELECT u.Id, COUNT(b.Id) AS badge_count\n    FROM users u\n    LEFT JOIN badges b ON u.Id = b.UserId\n    WHERE u.Views > 200\n    GROUP BY u.Id\n) AS user_badges;",
        "question": "What is the average number of badges obtained by a user with over 200 views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Views > 200",
        "evidence": [
            "user with over 200 views refers to Views > 200; average number of badges = Divide (Count(Id), Count(DisplayName))"
        ]
    },
    "1202": {
        "reason": "To solve the question, we need to find the number of male patients who underwent testing between 1995 and 1997, were diagnosed with Behcet disease, and did not stay in the hospital. The steps are as follows:\n1. Identify male patients (SEX = 'M') from the Patient table.\n2. Join the Patient table with the Examination table to filter patients who underwent testing between 1995 and 1997 (`Examination Date` between '1995-01-01' and '1997-12-31').\n3. Filter these patients for those diagnosed with Behcet disease (Diagnosis = 'Behcet').\n4. Ensure these patients did not stay in the hospital (Admission = '-').\n5. Count the distinct patients who meet all these criteria.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'M'\nAND E.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31'\nAND E.Diagnosis = 'Behcet'\nAND P.Admission = '-';",
        "question": "How many male patients who underwent testing between 1995 and 1997 and were subsequently diagnosed with Behcet disease did not stay in the hospital for treatment?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'Behcet' AND T1.SEX = 'M' AND STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1995' AND '1997' AND T1.Admission = '-'",
        "evidence": [
            "male refers to SEX = 'M'; underwent testing between 1995 and 1997 refers to `Examination Date` between '1995' and '1997'; Behcet refers to diagnosis; did not stay in the hospital refers to Admission = '-'"
        ]
    },
    "835": {
        "reason": "To solve the question, we need to identify the percentage of 'good' superheroes among all superheroes in Marvel Comics. Here's the step-by-step reasoning:\n\n1. **Identify Marvel Comics superheroes**: We need to filter superheroes whose `publisher_id` corresponds to 'Marvel Comics' in the `publisher` table.\n2. **Identify 'good' superheroes**: We need to filter superheroes whose `alignment_id` corresponds to 'good' in the `alignment` table.\n3. **Calculate the percentage**: Divide the count of 'good' Marvel Comics superheroes by the total count of Marvel Comics superheroes and multiply by 100 to get the percentage.\n\nWe will join the `superhero` table with the `publisher` and `alignment` tables to achieve this.",
        "sql": "SELECT \n    (COUNT(CASE WHEN a.alignment = 'Good' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_good\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    alignment a ON s.alignment_id = a.id\nWHERE \n    p.publisher_name = 'Marvel Comics';",
        "question": "Among all superheroes in Marvel Comics, identify the percentage of 'good' superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics'",
        "evidence": [
            "Marvel Comics refers to publisher_name = 'Marvel Comics'; percentage = MULTIPLY(DIVIDE(SUM(alignment = 'Good' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100.0); good superheroes refers to alignment = 'Good';"
        ]
    },
    "1373": {
        "reason": "To find out how many members' hometowns are from Maryland state, we need to:\n1. Join the `member` table with the `zip_code` table using the `zip` column in `member` and `zip_code` column in `zip_code`.\n2. Filter the results where the `state` column in the `zip_code` table is 'Maryland'.\n3. Count the number of distinct members who meet this condition.",
        "sql": "SELECT COUNT(DISTINCT m.member_id) \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE z.state = 'Maryland';",
        "question": "How many of the members' hometowns are from Maryland state?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.member_id) FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T1.state = 'Maryland'",
        "evidence": [
            ""
        ]
    },
    "1427": {
        "reason": "To solve the question, we need to find the budget categories of events that meet the following criteria:\n1. The event is located at 'MU 215'.\n2. The event type is 'Guest Speaker'.\n3. The budget spent for the event is 0.\n\nWe will achieve this by:\n- Joining the `event` table with the `budget` table to link events to their budgets.\n- Filtering the events based on the location ('MU 215') and type ('Guest Speaker').\n- Further filtering the budgets where the spent amount is 0.\n- Selecting the distinct budget categories to avoid duplicates.",
        "sql": "SELECT DISTINCT b.category\nFROM event e\nINNER JOIN budget b ON e.event_id = b.link_to_event\nWHERE e.location = 'MU 215' AND e.type = 'Guest Speaker' AND b.spent = 0;",
        "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
        "evidence": [
            "budget category refers to category; events located at refers to location; type = 'Guest Speaker'; 0 budget spent refers to spent = 0; ",
            "The DISTINCT keyword ensures unique results when multiple records might share the same category and type. The INNER JOIN explicitly links events to their budgets, ensuring only matching pairs are included.",
            "The SELECT clause should include both the budget category and the event type to align with the query's intent of displaying these attributes together.",
            "The query requires displaying both the budget category and event type, not just the category. The join between event and budget tables ensures the correct linkage for filtering and selection."
        ]
    },
    "1060": {
        "reason": "To find the number of players born after 1990, we need to query the `Player` table and filter the records where the `birthday` field is after the year 1990. The `birthday` field is stored as text, so we can use the `strftime` function to extract the year from the date and compare it with 1990. We will then count the number of such players.",
        "sql": "SELECT COUNT(*) FROM Player WHERE strftime('%Y', birthday) > '1990';",
        "question": "How many players were born after 1990?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990'",
        "evidence": [
            "born after 1990 refers to strftime('%Y', birthday) = '1990';"
        ]
    },
    "869": {
        "reason": "To solve the question, we need to find the constructor with the highest points in race No. 9 and then retrieve its introduction website. The steps are as follows:\n1. Identify the constructor with the highest points in race No. 9 from the `constructorResults` table.\n2. Use the `constructorId` obtained from the first step to fetch the constructor's website URL from the `constructors` table.\n3. Combine these steps into a single query to get the desired result.",
        "sql": "SELECT c.url\nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nWHERE cr.raceId = 9\nORDER BY cr.points DESC\nLIMIT 1;",
        "question": "For the constructor which got the highest point in the race No. 9 , what is its introduction website?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.url FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 9 ORDER BY T1.points DESC LIMIT 1",
        "evidence": [
            "race number refers to raceId; constructor which got the highest point refers to MAX(constructorResults.points); introduction website of the constructor refers to url;"
        ]
    },
    "1089": {
        "reason": "To find the number of matches held in Belgium during the 2008/2009 season, we need to:\n1. Identify the country_id for Belgium from the `Country` table.\n2. Use this country_id to filter matches in the `Match` table where the `season` is '2008/2009' and the `country_id` matches the one for Belgium.\n3. Count the number of such matches.",
        "sql": "SELECT COUNT(*) AS number_of_matches\nFROM Match\nWHERE season = '2008/2009'\nAND country_id = (SELECT id FROM Country WHERE name = 'Belgium');",
        "question": "How many matches in the 2008/2009 season were held in Belgium?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Belgium' AND t2.season = '2008/2009'",
        "evidence": [
            "Belgium refers to Country.name = 'Belgium';"
        ]
    },
    "446": {
        "reason": "To solve the question, we need to calculate the percentage of cards with a converted Mana Cost (CMC) of 10 in the set that includes the card named 'Abyssal Horror'. The steps are as follows:\n1. Identify the set code for the card 'Abyssal Horror' by querying the `cards` table where the `name` is 'Abyssal Horror' and extracting the `setCode`.\n2. Use the identified `setCode` to filter cards in the `cards` table that belong to the same set.\n3. Calculate the total number of cards in the set.\n4. Calculate the number of cards in the set with a CMC of 10.\n5. Compute the percentage by dividing the count of cards with CMC 10 by the total count of cards in the set and multiplying by 100.",
        "sql": "WITH target_set AS (\n    SELECT setCode FROM cards WHERE name = 'Abyssal Horror' LIMIT 1\n),\ntotal_cards AS (\n    SELECT COUNT(*) AS total FROM cards WHERE setCode = (SELECT setCode FROM target_set)\n),\ncmc_10_cards AS (\n    SELECT COUNT(*) AS cmc_10_count FROM cards WHERE setCode = (SELECT setCode FROM target_set) AND convertedManaCost = 10\n)\nSELECT (cmc_10_count * 100.0 / total) AS percentage\nFROM total_cards, cmc_10_cards;",
        "question": "What is percentage of the cards with a converted Mana Cost of 10 in set of Abyssal Horror?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'",
        "evidence": [
            "set of Abyssal Horror refers to name = 'Abyssal Horror'; percentage refers to DIVIDE(COUNT(convertedManaCost = 16),COUNT(convertedManaCost))*100",
            "The set name 'Abyssal Horror' refers to a card name, not a set name. Percentage calculation requires filtering cards by name and joining with the sets table.",
            "The percentage calculation requires filtering cards by name and joining with the sets table to ensure accurate set identification. The convertedManaCost filter should be applied to the same set as the card name.",
            "The percentage calculation should focus on cards with a specific name, not a set. The convertedManaCost filter applies to the same card name, not the set."
        ]
    },
    "887": {
        "reason": "To solve the question, we need to identify races in the year 2017 that were not hosted in the year 2000. The key is to compare race names across these two years. Here's the step-by-step reasoning:\n\n1. First, retrieve all race names from the year 2017.\n2. Then, retrieve all race names from the year 2000.\n3. Finally, filter out the races from 2017 that have the same name as any race in 2000.\n\nThis ensures we only get races unique to 2017 and not hosted in 2000.",
        "sql": "SELECT r2017.name \nFROM races r2017 \nWHERE r2017.year = 2017 \nAND r2017.name NOT IN (\n    SELECT r2000.name \n    FROM races r2000 \n    WHERE r2000.year = 2000\n);",
        "question": "Name the races in year 2017 that are not hosted in year 2000.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE year = 2017 AND name NOT IN ( SELECT name FROM races WHERE year = 2000 )",
        "evidence": [
            "not hosted means not in;",
            "The question involves comparing race names across different years, not circuit IDs.\nTo exclude races hosted in another year, filter by race names directly, not circuit IDs."
        ]
    },
    "216": {
        "reason": "To identify all connected atoms with a triple bond, we need to follow these steps:\n1. Understand that a triple bond is represented by `bond_type = '#'` in the `bond` table.\n2. The `connected` table links atoms (`atom_id` and `atom_id2`) via a `bond_id`, which references the `bond` table.\n3. We need to join the `connected` table with the `bond` table on `bond_id` to filter for bonds where `bond_type = '#'`.\n4. The result should include the pairs of connected atoms (`atom_id` and `atom_id2`) that are linked by a triple bond.",
        "sql": "SELECT c.atom_id, c.atom_id2\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '#';",
        "question": "Identify all connected atoms with a triple bond.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "evidence": [
            "triple bond refers to bond_type = '#';",
            "The `connected` table links atoms via `bond_id`, which references the `bond` table.\nTo filter for specific bond types, join the `bond` table with the `connected` table using `bond_id`.\nThe query should focus on retrieving atom pairs (`atom_id` and `atom_id2`) linked by the specified bond type."
        ]
    },
    "1052": {
        "reason": "To solve the question, we need to find the number of players whose weight is under 130 and whose preferred foot in attacking is 'left'. The steps are as follows:\n1. Join the `Player` table with the `Player_Attributes` table to access both the weight and preferred foot attributes.\n2. Filter the players where the weight is less than 130.\n3. Further filter the players where the preferred foot is 'left'.\n4. Count the distinct player IDs to ensure no duplicates are counted, as a player may have multiple entries in the `Player_Attributes` table.",
        "sql": "SELECT COUNT(DISTINCT p.player_api_id) \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE p.weight < 130 AND pa.preferred_foot = 'left';",
        "question": "Among all the players whose weight is under 130, how many of them preferred foot in attacking is left?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.weight < 130 AND t2.preferred_foot = 'left'",
        "evidence": [
            "weight < 130; preferred foot in attacking refers to preferred_foot; preferred_foot = 'left';",
            "The `Player` table contains unique player identifiers, and `Player_Attributes` may have multiple entries per player; counting distinct player IDs ensures no duplicates."
        ]
    },
    "41": {
        "reason": "To solve the question, we need to identify virtual schools that are among the top 5 in their respective counties based on average reading scores. Here's the step-by-step reasoning:\n\n1. **Identify Virtual Schools**: Filter schools where `Virtual = 'F'` in the `schools` table to get exclusively virtual schools.\n2. **Join with SAT Scores**: Link the `schools` table with the `satscores` table using the `CDSCode` (from `schools`) and `cds` (from `satscores`) to access the average reading scores (`AvgScrRead`).\n3. **Rank Schools by County**: Use the `RANK()` function to rank schools within each county based on their average reading scores. This ensures that ties in scores receive the same rank.\n4. **Filter Top 5**: Select only those schools where the rank is 5 or less within their respective counties.\n5. **Output School Names**: Return the names of these top-ranked virtual schools.\n\nThe query will involve a subquery or a Common Table Expression (CTE) to handle the ranking and filtering efficiently.",
        "sql": "WITH RankedSchools AS (\n    SELECT \n        s.School AS SchoolName,\n        s.County AS County,\n        ss.AvgScrRead AS AverageReadingScore,\n        RANK() OVER (PARTITION BY s.County ORDER BY ss.AvgScrRead DESC) AS Rank\n    FROM \n        schools s\n    JOIN \n        satscores ss ON s.CDSCode = ss.cds\n    WHERE \n        s.Virtual = 'F'\n)\nSELECT \n    SchoolName\nFROM \n    RankedSchools\nWHERE \n    Rank <= 5\nORDER BY \n    County, Rank;",
        "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
        "evidence": [
            "Exclusively virtual refers to Virtual = 'F'; respective counties means PARTITION BY County",
            "Virtual schools are identified by `Virtual = 'F'` in the `schools` table. The ranking of schools by average reading scores is partitioned by county to ensure top 5 selection per county.",
            "The `RANK()` function ensures ties in scores receive the same rank, unlike `ROW_NUMBER()`, which assigns unique ranks regardless of ties. Virtual schools are filtered using `Virtual = 'F'` in the `schools` table.",
            "The `satscores` table contains the average reading scores (`AvgScrRead`), which is the key metric for ranking. The join between `satscores` and `schools` must ensure the correct linkage via `CDSCode` and `cds`."
        ]
    },
    "1275": {
        "reason": "To solve the question, we need to find the number of male patients who have normal levels of both anti-centromere (CENTROMEA) and anti-SSB (SSB). The steps are as follows:\n1. Identify patients with normal levels of CENTROMEA (CENTROMEA IN('negative', '0')).\n2. Identify patients with normal levels of SSB (SSB IN('negative', '0')).\n3. Ensure these patients are male (SEX = 'M').\n4. Count the distinct number of such patients.\n\nThe query will involve joining the `Patient` table with the `Laboratory` table to filter based on the criteria.",
        "sql": "SELECT COUNT(DISTINCT P.ID) AS MalePatientsWithNormalLevels\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.CENTROMEA IN('negative', '0')\nAND L.SSB IN('negative', '0')\nAND P.SEX = 'M';",
        "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
        "evidence": [
            "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;",
            "normal level of anti-centromere refers to CENTROMEA IN('negative', '0'); normal level of anti-SSB refers to SSB IN('negative', '0'); male refers to SEX = 'M';"
        ]
    },
    "1436": {
        "reason": "To solve the question, we need to find members who have paid more than $50 (i.e., cost > 50 in the expense table) and then link these members to the events they attended. The steps are as follows:\n1. Identify members in the expense table where the cost is greater than 50.\n2. Use the link_to_member field in the expense table to join with the member table to get member details.\n3. Join the member table with the attendance table to find the events these members attended.\n4. Finally, join the attendance table with the event table to get the event details.\n5. Return the event_id (link_to_event) for these members.",
        "sql": "SELECT DISTINCT a.link_to_event\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nWHERE e.cost > 50;",
        "question": "Please provide links to events for members who have paid more than 50 dollar.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T1.cost > 50",
        "evidence": [
            "have paid more than 50 dollar refers to cost > 50"
        ]
    },
    "394": {
        "reason": "To solve the question, we need to find the count of white-bordered cards that are also considered powerful. According to the tips provided:\n1. White-bordered cards are identified by the condition `borderColor = 'white'`.\n2. Powerful cards are identified by the condition `cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL`.\n\nWe will query the `cards` table to count the number of rows that satisfy both conditions.",
        "sql": "SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
        "question": "How many white bordered cards are powerful?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "evidence": [
            "white bordered cards refer to borderColor = 'white'; powerful cards refers to cardKingdomFoilId is not null AND cardKingdomId is not null (replace)"
        ]
    },
    "1002": {
        "reason": "To solve the question, we need to find the youngest racer, their nationality, and the name of the first race they participated in. Here's the step-by-step reasoning:\n\n1. **Identify the youngest racer**: We can find the youngest racer by sorting the `drivers` table by the `dob` (date of birth) in descending order and selecting the first record. This ensures we get the most recent date of birth.\n\n2. **Retrieve the racer's full name and nationality**: The `drivers` table contains the `forename`, `surname`, and `nationality` fields, which we can use to get the full name and nationality of the youngest racer.\n\n3. **Find the first race the racer participated in**: The `driverStandings` table links drivers to races. To find the earliest race, we can join the `driverStandings` table with the `races` table and filter for the youngest racer's `driverId`. We then sort by `raceId` in ascending order and limit to the first result to get the earliest race.\n\n4. **Combine the results**: We will join the `drivers` table with the `driverStandings` and `races` tables to get all the required information in a single query.",
        "sql": "SELECT \n    d.forename || ' ' || d.surname AS full_name,\n    d.nationality,\n    r.name AS first_race_name\nFROM \n    drivers d\nJOIN \n    driverStandings ds ON d.driverId = ds.driverId\nJOIN \n    races r ON ds.raceId = r.raceId\nWHERE \n    d.driverId = (\n        SELECT driverId \n        FROM drivers \n        ORDER BY dob DESC \n        LIMIT 1\n    )\nORDER BY \n    r.raceId ASC\nLIMIT 1;",
        "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
        "evidence": [
            "full name refers to forename+surname; Youngest racer = MAX(dob)",
            "To find the first race a driver participated in, use the `driverStandings` table as it records initial participation. The `results` table may not capture the earliest race due to filtering or missing data.",
            "To identify the youngest racer, sorting by date of birth in descending order and limiting to one result is more reliable than using MAX(dob).\nThe `driverStandings` table links drivers to races, but the earliest race participation may not correspond to the minimum `raceId` due to data gaps or non-sequential race entries.\nUsing `ORDER BY` with `LIMIT 1` ensures the most recent date of birth is selected without relying on subqueries.",
            "To ensure the youngest racer is accurately identified, sorting by `dob` in descending order and limiting to one result is more reliable than using `MAX(dob)`.\nThe `driverStandings` table links drivers to races, but the earliest race participation may not correspond to the minimum `raceId` due to data gaps or non-sequential race entries.\nUsing `ORDER BY` with `LIMIT 1` ensures the most recent date of birth is selected without relying on subqueries."
        ]
    },
    "354": {
        "reason": "To solve the question, we need to find out how many types of cards the artist Aaron Boyd has illustrated. The steps are as follows:\n1. Identify all cards where the artist is 'Aaron Boyd'.\n2. For these cards, count the distinct types (using the 'type' column in the 'cards' table).\n3. The result will give the number of unique card types illustrated by Aaron Boyd.",
        "sql": "SELECT COUNT(DISTINCT type) AS numberOfCardTypes FROM cards WHERE artist = 'Aaron Boyd';",
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "evidence": [
            "Aaron Boyd' is artist;",
            "The 'cards' table includes a 'type' column for card types, not a 'types' column. Counting distinct values in 'type' is required.",
            "The 'type' column in the 'cards' table represents the card type, and counting occurrences directly without distinct is required for the total number of types.",
            "The 'type' column in the 'cards' table represents individual card types, and counting occurrences directly without distinct is required for the total number of types."
        ]
    },
    "426": {
        "reason": "To find the top three sets that don't appear in Magic: The Gathering Online (MTGO), we need to query the `sets` table where the `mtgoCode` is NULL or empty, as this indicates the set is not available on MTGO. We then order the results by the set name in alphabetical order and limit the output to the top three sets.",
        "sql": "SELECT name FROM sets WHERE mtgoCode IS NULL OR mtgoCode = '' ORDER BY name ASC LIMIT 3;",
        "question": "Please provide top three sets that don't appear in Magic: The Gathering Online, along with their names in in alphabetical order.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3",
        "evidence": [
            "don't appear in Magic: The Gathering Online refers to mtgoCode is NULL or mtgoCode = ''"
        ]
    },
    "352": {
        "reason": "To calculate the percentage of cards available in Chinese Simplified, we need to follow these steps:\n1. **Numerator**: Count the number of distinct card IDs from the 'foreign_data' table where the language is 'Chinese Simplified'.\n2. **Denominator**: Count the total number of distinct card IDs from the 'cards' table.\n3. **Percentage Calculation**: Divide the numerator by the denominator and multiply by 100 to get the percentage.\n\nWe will use an INNER JOIN between 'cards' and 'foreign_data' to ensure we only consider cards that have entries in the 'foreign_data' table. The numerator will be the count of distinct card IDs where the language is 'Chinese Simplified', and the denominator will be the count of all distinct card IDs in the 'cards' table.",
        "sql": "SELECT (COUNT(DISTINCT CASE WHEN fd.language = 'Chinese Simplified' THEN c.id END) * 100.0 / COUNT(DISTINCT c.id)) AS percentage\nFROM cards c\nLEFT JOIN foreign_data fd ON c.uuid = fd.uuid;",
        "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
        "evidence": [
            "Chinese Simplified' is the language; percentage = Divide(Sum(id where language = 'Chinese Simplified'), Count(id)) *100",
            "The percentage calculation should consider all cards in the 'cards' table as the denominator, not just those in 'foreign_data'.\nJoining 'cards' with 'foreign_data' ensures the denominator includes all cards, not just those with foreign data entries.",
            "The percentage calculation requires counting distinct card IDs from the 'cards' table as the denominator, not UUIDs, to ensure accurate representation of all cards.\nAn INNER JOIN between 'cards' and 'foreign_data' ensures only cards with foreign data entries are considered for the numerator.\nThe numerator should use a conditional sum to count only entries with the specified language.",
            "The percentage calculation should use an INNER JOIN to ensure only cards with foreign data entries are considered for both numerator and denominator.\nThe numerator should count occurrences of the specified language directly, not distinct card IDs.\nThe denominator should count all card IDs from the 'cards' table to represent the total available cards."
        ]
    },
    "1506": {
        "reason": "To solve the question, we need to find the product descriptions of transactions that occurred in gas stations located in the Czech Republic. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `transactions_1k` table contains transaction details, including `GasStationID` and `ProductID`. The `gasstations` table contains information about gas stations, including their `Country`. The `products` table contains product descriptions.\n\n2. **Filter gas stations in the Czech Republic**: We need to join the `transactions_1k` table with the `gasstations` table to filter transactions where the `Country` is 'CZE' (Czech Republic).\n\n3. **Retrieve product descriptions**: After filtering the transactions, we join the result with the `products` table to get the `Description` of the products involved in these transactions.\n\n4. **Final query**: The query will involve joining the three tables (`transactions_1k`, `gasstations`, and `products`) and filtering for the Czech Republic.",
        "sql": "SELECT p.Description\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE g.Country = 'CZE';",
        "question": "Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.Description FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Country = 'CZE'",
        "evidence": [
            "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; "
        ]
    },
    "123": {
        "reason": "To solve the question, we need to find the account ID, district, and region for loans with an amount greater than USD 300,000. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `loan` table contains loan amounts, the `account` table links loans to accounts, and the `district` table provides district and region information.\n2. **Join the tables**: We need to join the `loan` table with the `account` table using `account_id`, and then join the result with the `district` table using `district_id`.\n3. **Filter the data**: We will filter the loans where the `amount` is greater than 300,000.\n4. **Select the required columns**: The columns to select are `account_id` from the `account` table, `A2` (district name) and `A3` (region) from the `district` table.\n\nThis will give us the desired result.",
        "sql": "SELECT a.account_id, d.A2 AS district, d.A3 AS region\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.amount > 300000;",
        "question": "Provide the account ID, district and region for loan amount greater than USD300,000.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.amount > 300000",
        "evidence": [
            "A2 contains district names and A3 contains region names."
        ]
    },
    "1425": {
        "reason": "To solve the question, we need to find the number of majors in the College of Agriculture and Applied Sciences that are under the department of School of Applied Sciences, Technology and Education. We will query the `major` table, filtering for records where the `college` is 'College of Agriculture and Applied Sciences' and the `department` is 'School of Applied Sciences, Technology and Education'. The result will be the count of such records.",
        "sql": "SELECT COUNT(*) FROM major WHERE college = 'College of Agriculture and Applied Sciences' AND department = 'School of Applied Sciences, Technology and Education';",
        "question": "In the College of Agriculture and Applied Sciences, how many majors are under the department of School of Applied Sciences, Technology and Education?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(major_id) FROM major WHERE department = 'School of Applied Sciences, Technology and Education' AND college = 'College of Agriculture and Applied Sciences'",
        "evidence": [
            ""
        ]
    },
    "984": {
        "reason": "To find the website of the constructor with the most total wins, we need to:\n1. Join the `constructors` table with the `constructorStandings` table to access both the constructor's name and their wins.\n2. Since the `wins` column in `constructorStandings` already represents cumulative wins per constructor, we can directly use it without aggregation.\n3. Order the results by the `wins` column in descending order to find the constructor with the highest number of wins.\n4. Limit the result to 1 to get only the top constructor.\n5. Select the `url` column from the `constructors` table to get the website of the constructor.",
        "sql": "SELECT c.url\nFROM constructors c\nJOIN constructorStandings cs ON c.constructorId = cs.constructorId\nORDER BY cs.wins DESC\nLIMIT 1;",
        "question": "What is the website of the constructor who tallied the most total wins.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1",
        "evidence": [
            "introduction website refers to url;",
            "The `constructorStandings` table records wins per race, not cumulative wins; summing wins is unnecessary.\nTo find the constructor with the most wins, use the `wins` column directly without aggregation.\nJoining `constructors` and `constructorStandings` allows retrieving the constructor's URL.",
            "The `wins` column in `constructorStandings` already represents cumulative wins per constructor, eliminating the need for aggregation.\nTo retrieve the constructor with the highest wins, directly use the `wins` column without summing.\nJoining `constructors` and `constructorStandings` allows accessing the constructor's URL."
        ]
    },
    "1290": {
        "reason": "To solve the question, we need to find the examination date of the patient whose albumin (ALB) level is the highest within the normal range (3.5 < ALB < 5.5). The steps are as follows:\n1. Filter the Laboratory table to include only records where ALB is within the normal range (3.5 < ALB < 5.5).\n2. Order these records by ALB in descending order to find the highest ALB value.\n3. Select the top record (highest ALB) and retrieve its Date (examination date).\n4. Since the question asks for the examination date, we will return the Date from the Laboratory table.",
        "sql": "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1;",
        "question": "What is the examination date of the patient whose albumin is the highest in the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1",
        "evidence": [
            "examination date refers to Date; albumin is the highest in the normal range refers to MAX(ALB > 3.5 and ALB < 5.5);",
            "albumin (ALB) values are stored in the Laboratory table, not the Examination table. the highest ALB within the normal range is determined by filtering and ordering in the Laboratory table.",
            "the examination date for albumin levels is stored in the Laboratory table, not the Examination table. the highest albumin value within the normal range is determined by filtering and ordering directly in the Laboratory table.",
            "the normal range for albumin (ALB) is defined as values greater than 3.5 and less than 5.5, not including the boundary values."
        ]
    },
    "794": {
        "reason": "To find the fastest hero, we need to identify the superhero with the highest attribute value for 'Speed'. This involves joining the `superhero` table with the `hero_attribute` and `attribute` tables. The `attribute` table will help us filter for the 'Speed' attribute, and the `hero_attribute` table will provide the corresponding values. We will then order the results by the attribute value in descending order and limit the result to the top record to get the fastest hero.",
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nORDER BY ha.attribute_value DESC\nLIMIT 1;",
        "question": "Which hero was the fastest?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
        "evidence": [
            "which hero refers to superhero_name; fastest refers to MAX(attribute_value) WHERE attribute_name = 'Speed';",
            "To find the fastest hero, the query must directly order by the attribute_value for 'Speed' without grouping, as grouping is unnecessary for retrieving a single record with the highest value."
        ]
    },
    "447": {
        "reason": "To solve the question, we need to find the code of sets that have the type 'expansion commander'. The 'type' column in the 'sets' table specifies the category of the set. Since the question asks for sets with the exact type 'expansion commander', we will query the 'sets' table and filter the results where the 'type' column matches 'expansion commander'. The result will be the 'code' of these sets.",
        "sql": "SELECT code FROM sets WHERE type = 'expansion commander';",
        "question": "Give the code of sets have expansion commander type?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
        "evidence": [
            "code of sets refers to setCode",
            "The 'type' column in the 'sets' table specifies the category of the set, such as 'expansion' or 'commander'.\nTo join 'sets' with 'set_translations', use the 'code' column in 'sets' and 'setCode' in 'set_translations'.\nFiltering for a specific set type requires exact matching in the WHERE clause.",
            "The 'type' column in the 'sets' table can contain multiple values, and filtering requires exact matching for specific types like 'commander'.\nJoining 'sets' with 'set_translations' involves matching 'code' in 'sets' to 'setCode' in 'set_translations'.",
            "The 'type' column in the 'sets' table may contain single values like 'commander', not concatenated terms like 'expansion commander'.\nJoining 'sets' with 'set_translations' requires matching 'code' in 'sets' to 'setCode' in 'set_translations'."
        ]
    },
    "730": {
        "reason": "To solve the question, we need to list superheroes from Marvel Comics who have the superpower 'Super Strength'. This involves the following steps:\n1. Identify the publisher 'Marvel Comics' in the `publisher` table.\n2. Identify the superpower 'Super Strength' in the `superpower` table.\n3. Join the `superhero` table with the `publisher` table to filter superheroes from Marvel Comics.\n4. Join the `superhero` table with the `hero_power` and `superpower` tables to filter superheroes with 'Super Strength'.\n5. Combine these conditions to get the final list of superheroes.",
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE p.publisher_name = 'Marvel Comics'\nAND sp.power_name = 'Super Strength';",
        "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
        "evidence": [
            "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; super power of \"Super Strength\" refers to power_name = 'Super Strength';"
        ]
    },
    "926": {
        "reason": "To find the fastest lap time ever in a race for Lewis Hamilton, we need to:\n1. Identify Lewis Hamilton's driverId from the drivers table using his name (forename and surname).\n2. Join the results table with the drivers table to filter results for Lewis Hamilton.\n3. Find the minimum value of the fastestLapTime column in the results table for Lewis Hamilton.\n4. Ensure the query handles the time format correctly to determine the minimum time.",
        "sql": "SELECT MIN(r.fastestLapTime) AS fastest_lap_time\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "question": "What's the fastest lap time ever in a race for Lewis Hamilton?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.fastestLapTime FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "evidence": [
            "fastest lap time ever refers to min(fastestLapTime)"
        ]
    },
    "642": {
        "reason": "To determine how many posts were created on 21st July 2010, we need to query the `postHistory` table, as it records the creation events of posts. The `CreationDate` column in this table can be filtered to match the specific date. Since the `postHistory` table includes all revisions, we need to ensure we count only the initial creation events. The `PostHistoryTypeId` column can help identify creation events, but if not specified, we can assume the first entry for a `PostId` is the creation event. For simplicity, we will count all entries in `postHistory` where the `CreationDate` falls on 21st July 2010, as the tip suggests using the `date()` function for precise date matching.",
        "sql": "SELECT COUNT(*) AS post_count FROM postHistory WHERE date(CreationDate) = '2010-07-21';",
        "question": "How many posts were created on 21st July, 2010?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'",
        "evidence": [
            "created on 21st July, 2010 refers to CreationDate BETWEEN '2010-07-21 00:00:00' and '2012-07-21 23:59:59';",
            "The `postHistory` table tracks revisions and changes to posts, including creation events, and its `CreationDate` column can be used to filter by specific dates.\nTo count posts created on a specific date, the `postHistory` table should be queried, not the `posts` table, as it records the actual creation events.\nThe `date()` function can be used to extract the date part from a datetime column for precise date matching.",
            "The `postHistory` table records all revisions, including the initial creation of posts, and its `Id` column uniquely identifies each entry.\nCounting distinct `PostId` values in `postHistory` may include multiple revisions of the same post, whereas counting `Id` ensures each revision is treated as a separate event."
        ]
    },
    "1174": {
        "reason": "To solve the question, we need to calculate the average age of patients as of the year 1999 who were examined in the laboratory during October 1991. The steps are as follows:\n1. Identify patients who had laboratory examinations in October 1991 by filtering the `Laboratory` table for dates between '1991-10-01' and '1991-10-30'.\n2. Join these patients with the `Patient` table to access their birth dates.\n3. Calculate the age of each patient as of 1999 by subtracting the year of their birth date from 1999.\n4. Compute the average of these ages.",
        "sql": "SELECT AVG(1999 - strftime('%Y', Birthday)) AS average_age\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Laboratory.Date BETWEEN '1991-10-01' AND '1991-10-30';",
        "question": "What is the average age of patients as of year 1999 examined in the laboratory for the October of the year 1991?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG('1999'  - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "evidence": [
            "average age of patients as of year 1999 refers to AVG(SUBTRACT('1999', year(Birthday))); October of 1991 refers to Date BETWEEN '1991-10-01' AND '1991-10-30'",
            "The date range for October 1991 should include only up to '1991-10-30' to cover the entire month without overlapping into November.\nThe calculation of age as of 1999 involves subtracting the year of the patient's birthday from the literal year 1999, not using a function like strftime.",
            "The query requires joining the Laboratory and Patient tables to access both examination dates and patient birthdays.\nThe age calculation should directly subtract the year of the birthday from the literal year 1999, not using a function like strftime for the subtraction."
        ]
    },
    "700": {
        "reason": "To solve the question, we need to identify the number of posts that offer a bounty amount over 30. The `votes` table contains information about bounties, including the `BountyAmount` column. We will query the `votes` table to count the number of records where `BountyAmount` is greater than or equal to 30. The `PostId` in the `votes` table links to the `posts` table, but since we only need the count of such posts, we don't need to join with the `posts` table for this specific query.",
        "sql": "SELECT COUNT(*) AS NumberOfPostsWithBountyOver30 FROM votes WHERE BountyAmount >= 30;",
        "question": "Identify the number of posts that offer a bounty amount over 30.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM votes WHERE BountyAmount >= 30",
        "evidence": [
            "bounty amount over 30 refers to BountyAmount > = 30;"
        ]
    },
    "919": {
        "reason": "To find out which circuit was used for the 2009 Spanish Grand Prix, we need to query the `races` table. The `races` table contains information about races, including the year, name, and the circuitId (which links to the `circuits` table). We can filter the races by the year 2009 and the name 'Spanish Grand Prix', then join the result with the `circuits` table to get the circuit's name.",
        "sql": "SELECT c.name AS circuit_name FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2009 AND r.name = 'Spanish Grand Prix';",
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "evidence": [
            ""
        ]
    },
    "814": {
        "reason": "To solve the question, we need to find the skin colour of superheroes who have an attribute value of 100. This involves joining multiple tables:\n1. The `hero_attribute` table to filter superheroes with an attribute value of 100.\n2. The `superhero` table to get the skin colour ID of these superheroes.\n3. The `colour` table to translate the skin colour ID into the actual skin colour name.\n\nThe steps are:\n- Join `hero_attribute` with `superhero` on `hero_id`.\n- Filter records where `attribute_value` is 100.\n- Join the result with the `colour` table on `skin_colour_id` to get the skin colour name.\n- Select the `colour` field from the `colour` table.",
        "sql": "SELECT c.colour\nFROM hero_attribute ha\nJOIN superhero s ON ha.hero_id = s.id\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE ha.attribute_value = 100;",
        "question": "List the skin colour of the superheroes with 100 attribute value.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id WHERE T3.attribute_value = 100",
        "evidence": [
            "skin colour refers to colour.colour where skin_colour_id = colour.id; 100 attribute value refers to attribute_value = 100;"
        ]
    },
    "940": {
        "reason": "To solve the question, we need to identify drivers who finished the 2008 Chinese Grand Prix and then determine how many of them have participated in other Formula 1 races. Here's the step-by-step reasoning:\n\n1. **Identify the raceId for the 2008 Chinese Grand Prix**: We need to find the raceId from the `races` table where the year is 2008 and the name is 'Chinese Grand Prix'.\n\n2. **Find drivers who finished the race**: Using the `results` table, we look for entries where the raceId matches the one found in step 1 and the `time` field is not NULL (indicating they finished the race).\n\n3. **Count participation in other races**: For each driver identified in step 2, we count how many times they appear in the `results` table (excluding the 2008 Chinese Grand Prix) to determine their participation in other races.\n\n4. **Filter drivers with participation in other races**: We filter the list to include only those drivers who have participated in at least one other race (COUNT(raceId) > 0).\n\n5. **Count the number of such drivers**: Finally, we count the number of drivers who meet the criteria.",
        "sql": "WITH chinese_gp_2008 AS (\n    SELECT raceId\n    FROM races\n    WHERE year = 2008 AND name = 'Chinese Grand Prix'\n),\nfinished_drivers AS (\n    SELECT driverId\n    FROM results\n    WHERE raceId = (SELECT raceId FROM chinese_gp_2008) AND time IS NOT NULL\n),\nparticipated_drivers AS (\n    SELECT r.driverId\n    FROM results r\n    JOIN finished_drivers fd ON r.driverId = fd.driverId\n    WHERE r.raceId != (SELECT raceId FROM chinese_gp_2008)\n    GROUP BY r.driverId\n    HAVING COUNT(r.raceId) > 0\n)\nSELECT COUNT(*) AS num_drivers\nFROM participated_drivers;",
        "question": "Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )",
        "evidence": [
            "COUNT(raceID) > 0 reveals that this driver participated in races; drivers who finished the race refers to time has value."
        ]
    },
    "1178": {
        "reason": "To determine the gender of the first AORTITIS diagnosed patient, we need to follow these steps:\n1. Identify all patients with a Diagnosis of 'AORTITIS' in the Patient table.\n2. Among these patients, find the one with the earliest 'First Date' (excluding NULL values).\n3. Retrieve the SEX (gender) of this patient.\n\nThe query will involve filtering the Patient table for 'AORTITIS' diagnoses, ordering by 'First Date' in ascending order, and selecting the first record's SEX.",
        "sql": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1;",
        "question": "What was the gender of the first AORTITIS diagnosed patient?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
        "evidence": [
            "gender means SEX; 'AORTITIS' refers to Diagnosis;",
            "The 'First Date' column in the Patient table can contain NULL values, which should be excluded when determining the earliest date."
        ]
    },
    "46": {
        "reason": "To solve the question, we need to identify state special schools (DOC = 31) with the highest number of enrollees in grades 1 through 12 (K-12). The steps are as follows:\n1. Join the `schools` table with the `frpm` table using the `CDSCode` column to link them.\n2. Filter the results to include only state special schools by checking `DOC = 31` in the `schools` table.\n3. Sort the results by the `Enrollment (K-12)` column in descending order to find the highest number of enrollees.\n4. Limit the results to the top entry to get the school with the highest enrollment.",
        "sql": "SELECT s.School, s.District, s.County, f.\"Enrollment (K-12)\"\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.DOC = 31\nORDER BY f.\"Enrollment (K-12)\" DESC\nLIMIT 1;",
        "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "evidence": [
            "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12",
            "State special schools are identified by DOC = 31 in the schools table.\nThe enrollment data for grades 1 through 12 is stored in the `Enrollment (K-12)` column of the frpm table.\nTo find the highest number of enrollees, order by `Enrollment (K-12)` in descending order and limit to the top result.",
            "The `DOC` column in the `schools` table uses integer values, not strings, for filtering.\nThe `Enrollment (K-12)` column in the `frpm` table should be referenced directly for sorting.\nThe join between `frpm` and `schools` should use the `CDSCode` column as the linking key.",
            "The `DOC` column in the `schools` table uses integer values for filtering, not strings.\nThe `Enrollment (K-12)` column in the `frpm` table should be referenced directly for sorting.\nThe join between `frpm` and `schools` should use the `CDSCode` column as the linking key."
        ]
    },
    "1322": {
        "reason": "To solve the question, we need to find out how many events attended by more than 10 members are meetings. The steps are as follows:\n1. Identify events attended by more than 10 members by joining the `event` and `attendance` tables, grouping by `event_id`, and filtering with `HAVING COUNT(link_to_member) > 10`.\n2. From these events, filter those where the `type` is 'Meeting'.\n3. Count the number of such events.",
        "sql": "SELECT COUNT(*) AS meeting_event_count\nFROM (\n    SELECT e.event_id\n    FROM event e\n    JOIN attendance a ON e.event_id = a.link_to_event\n    GROUP BY e.event_id\n    HAVING COUNT(a.link_to_member) > 10\n) AS popular_events\nJOIN event e2 ON popular_events.event_id = e2.event_id\nWHERE e2.type = 'Meeting';",
        "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
        "evidence": [
            "meetings events refers to type = 'Meeting'; attended by more than 10 members refers to COUNT(event_id) > 10",
            "To filter events by type, use the WHERE clause with the type column. To count attendees per event, use GROUP BY with HAVING for aggregate conditions. The EXCEPT operator excludes events of a specific type from the result.",
            "To count events attended by more than 10 members, join the `event` and `attendance` tables, group by `event_id`, and filter with `HAVING COUNT(link_to_member) > 10`.\nTo exclude events of a specific type, use the `EXCEPT` operator with a subquery filtering by `type`.\nThe `EXCEPT` operator removes rows from the first query that appear in the second query.",
            "To count events of a specific type, filter the results directly in the WHERE clause rather than using EXCEPT. The HAVING clause should apply to the count of attendees, not the event type."
        ]
    },
    "1243": {
        "reason": "To solve the question, we need to calculate the percentage of female patients older than 55 years who have an abnormal prothrombin time (PT >= 14). The steps are as follows:\n1. Identify all patients older than 55 years by comparing their birth year with the current year.\n2. From this subset, count the number of female patients (SEX = 'F') who have an abnormal PT (PT >= 14).\n3. Calculate the total number of patients older than 55 years to use as the denominator for the percentage.\n4. Divide the count of female patients with abnormal PT by the total count of patients older than 55 years and multiply by 100 to get the percentage.\n5. Ensure the join between the Patient and Laboratory tables includes all relevant records for accurate aggregation.",
        "sql": "SELECT \n    (CAST(SUM(CASE WHEN P.SEX = 'F' AND L.PT >= 14 THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100 AS percentage\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 55;",
        "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
        "evidence": [
            "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; ",
            "The percentage calculation should include all patients older than 55 years, not just those with abnormal PT, to ensure the denominator reflects the correct population.\nThe join between Patient and Laboratory tables must ensure all relevant records are included for accurate aggregation.\nThe CAST function ensures precise division by converting integer counts to REAL for percentage calculation.",
            "The denominator for percentage calculation should include all patients older than 55 years, not just those with abnormal PT, to reflect the correct population.\nThe join between Patient and Laboratory tables must ensure all relevant records are included for accurate aggregation.\nThe COUNT(*) function is used to include all patients meeting the age criteria in the denominator."
        ]
    },
    "1038": {
        "reason": "To solve the question, we need to determine the top 5 leagues based on the total number of goals scored in all seasons combined. The steps are as follows:\n1. **Identify the relevant tables**: The `Match` table contains the goals scored by home and away teams, and the `League` table contains the league names.\n2. **Calculate total goals per league**: For each match, sum the `home_team_goal` and `away_team_goal` to get the total goals for that match. Then, group these totals by the `league_id`.\n3. **Join with the `League` table**: To get the league names, join the results with the `League` table.\n4. **Order the results**: Sort the leagues in ascending order of total goals.\n5. **Limit the results**: Return only the top 5 leagues.",
        "sql": "SELECT l.name AS league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM Match m\nJOIN League l ON m.league_id = l.id\nGROUP BY m.league_id\nORDER BY total_goals ASC\nLIMIT 5;",
        "question": "List the top 5 leagues in ascending order of the number of goals made in all seasons combined.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name, SUM(t2.home_team_goal) + SUM(t2.away_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id GROUP BY t1.name ORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC LIMIT 5",
        "evidence": [
            "number of goals made in all seasons combine = SUM(home_team_goal, away_team_goal);"
        ]
    },
    "113": {
        "reason": "To find the birthday of the client who applied for a loan of 98832 USD on 1996/1/3, we need to follow these steps:\n1. Identify the loan record with the specified amount and date in the `loan` table.\n2. Use the `account_id` from the loan record to find the corresponding account in the `account` table.\n3. From the `account` table, use the `account_id` to find the associated client in the `disp` table (since `disp` links accounts to clients).\n4. From the `disp` table, use the `client_id` to find the client's details in the `client` table.\n5. Retrieve the `birth_date` from the `client` table for the identified client.",
        "sql": "SELECT c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.amount = 98832 AND l.date = '1996-01-03';",
        "question": "For the client who applied 98832 USD loan in 1996/1/3, when was his/her birthday?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.birth_date FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T1.date = '1996-01-03' AND T1.amount = 98832",
        "evidence": [
            ""
        ]
    },
    "15": {
        "reason": "To find the active district with the highest average score in Reading, we need to follow these steps:\n1. Identify active districts by filtering the `schools` table where `StatusType` indicates an active status.\n2. Join the `schools` table with the `satscores` table using the `CDSCode` and `cds` columns to access the average reading scores.\n3. Filter the `satscores` table to include only records where the average reading score (`AvgScrRead`) is available.\n4. Group the results by the district name to calculate the average reading score per district.\n5. Order the results by the average reading score in descending order to find the highest score.\n6. Limit the result to 1 to get the district with the highest average reading score.",
        "sql": "SELECT s.District, AVG(sc.AvgScrRead) AS AvgReadingScore\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.StatusType = 'Active' AND sc.AvgScrRead IS NOT NULL\nGROUP BY s.District\nORDER BY AvgReadingScore DESC\nLIMIT 1;",
        "question": "Which active district has the highest average score in Reading?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1",
        "evidence": [
            "",
            "The `rtype` filter is unnecessary for identifying districts; the `District` column in the `schools` table already distinguishes districts.\nThe `GROUP BY` clause is redundant when seeking a single highest value; ordering and limiting suffice.",
            "The `AvgScrRead` column in `satscores` directly provides the average reading score, eliminating the need for aggregation.\nThe `District` column in `schools` identifies districts, and filtering by `StatusType` ensures only active districts are considered.",
            "The `AvgScrRead` column in `satscores` directly provides the average reading score, eliminating the need for aggregation.\nThe `GROUP BY` clause is unnecessary when seeking a single highest value; ordering and limiting suffice."
        ]
    },
    "1476": {
        "reason": "To solve the question, we need to calculate the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: \n   - `customers` table contains customer information, including the currency they use (CZK or EUR).\n   - `yearmonth` table contains consumption data for customers by date.\n   - `transactions_1k` table links customers to gas stations and products, but we don't need it directly for this question.\n\n2. **Filter data for 2012**: \n   - The `yearmonth` table has a `Date` column, which we can filter to include only dates from 2012.\n\n3. **Group consumption by currency**: \n   - Join the `customers` table with the `yearmonth` table on `CustomerID`.\n   - Filter customers by currency (CZK or EUR).\n   - Sum the `Consumption` for each currency group.\n\n4. **Calculate the difference**: \n   - Subtract the total consumption of EUR-paying customers from the total consumption of CZK-paying customers.\n\n5. **Output the result**: \n   - The final query will return the difference in consumption between the two currency groups.",
        "sql": "SELECT \n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'CZK' AND ym.Date LIKE '2012%') -\n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'EUR' AND ym.Date LIKE '2012%') AS ConsumptionDifference;",
        "question": "What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(T1.Currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.Currency = 'EUR', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2012'",
        "evidence": [
            "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year; Difference in Consumption = CZK customers consumption in 2012 - EUR customers consumption in 2012"
        ]
    },
    "1042": {
        "reason": "To solve the question, we need to:\n1. Identify the leagues where the average goals scored by the home team are higher than the average goals scored by the away team during the 2009/2010 season.\n2. Calculate the average goals for home and away teams for each league in the specified season.\n3. Filter the leagues where the home team's average goals are greater than the away team's.\n4. Join the `Match` table with the `League` table to get the league names.\n5. Group the results by league and apply the necessary filtering conditions.",
        "sql": "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2009/2010'\nGROUP BY l.name\nHAVING AVG(m.home_team_goal) > AVG(m.away_team_goal);",
        "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0",
        "evidence": [
            "name of league refers to League.name; average goals by the home team is higher than the away team = AVG(home_team_goal) > AVG(away_team_goal); AVG(xx_goal) = SUM(xx_goal) / COUNT(DISTINCT Match.id); 2009/2010 season refers to season = '2009/2010'"
        ]
    },
    "374": {
        "reason": "To solve the question, we need to find the count of black border cards that are only available on MTGO. The schema provides a table `cards` with columns `borderColor` and `availability`. The tip specifies that black border cards refer to `borderColor = 'black'` and available on MTGO refers to `availability = 'mtgo'`. Therefore, the query should count the rows in the `cards` table where `borderColor` is 'black' and `availability` is 'mtgo'.",
        "sql": "SELECT COUNT(*) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo';",
        "question": "How many black border cards are only available on mtgo?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE availability = 'mtgo' AND borderColor = 'black'",
        "evidence": [
            "black border card refers to borderColor = black; available on mtgo refers to availability = mtgo;\n\nadd quotes for string = 'black' and = 'mtgo'"
        ]
    },
    "93": {
        "reason": "To solve the question, we need to find the number of male customers living in North Bohemia with an average salary greater than 8000. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables and columns**:\n   - The `client` table contains information about customers, including their gender (`gender`) and district (`district_id`).\n   - The `district` table contains region information (`A3`) and average salary (`A11`).\n   - We need to join these tables to filter customers based on their district and region.\n\n2. **Filter conditions**:\n   - Gender should be 'M' (male).\n   - Region (`A3`) should be 'North Bohemia' (case-insensitive).\n   - Average salary (`A11`) should be greater than 8000.\n\n3. **Count the customers**:\n   - Count the `client_id` entries that meet the above conditions.\n\n4. **Join the tables**:\n   - Join the `client` table with the `district` table on `district_id` to access the region and salary information.\n\n5. **Final query**:\n   - Filter the joined data based on the conditions and count the results.",
        "sql": "SELECT COUNT(client.client_id) AS male_customers_in_north_bohemia\nFROM client\nJOIN district ON client.district_id = district.district_id\nWHERE client.gender = 'M'\n  AND LOWER(district.A3) = 'north bohemia'\n  AND district.A11 > 8000;",
        "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
        "evidence": [
            "Male means that gender = 'M'; A3 refers to region; A11 pertains to average salary.",
            "The region name in the district table is case-sensitive, requiring exact matching for filtering. The count should explicitly reference the client_id column for clarity.",
            "The region name in the district table is case-insensitive, requiring exact matching for filtering. The count should reference the client_id column without DISTINCT for clarity."
        ]
    },
    "776": {
        "reason": "To find the hero name and race of Charles Chandler, we need to query the `superhero` table for the record where `full_name` is 'Charles Chandler'. The `superhero` table contains the `superhero_name` and `race_id` fields. To get the actual race name, we need to join the `superhero` table with the `race` table using the `race_id` field. The query will select the `superhero_name` from the `superhero` table and the `race` from the `race` table where the `full_name` matches 'Charles Chandler'.",
        "sql": "SELECT s.superhero_name, r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.full_name = 'Charles Chandler';",
        "question": "Provide the hero name and race of Charles Chandler.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.full_name = 'Charles Chandler'",
        "evidence": [
            "hero name refers to superhero_name; Charles Chandler is the full name of superhero;"
        ]
    },
    "402": {
        "reason": "To solve the question, we need to calculate the percentage of Story Spotlight cards that do not have a text box. The criteria for such cards are `isStorySpotlight = 1` and `isTextless = 0`. The steps are as follows:\n1. Count the total number of cards in the database.\n2. Count the number of cards that meet the criteria (`isStorySpotlight = 1` and `isTextless = 0`).\n3. Calculate the percentage by dividing the count from step 2 by the total count from step 1 and multiplying by 100.\n4. Additionally, list the IDs of the cards that meet the criteria.\n\nThe query will use conditional aggregation to count the relevant cards and calculate the percentage in a single step. A separate query will list the IDs of the qualifying cards.",
        "sql": "-- Query to calculate the percentage of Story Spotlight cards without a text box\nSELECT \n    (SUM(CASE WHEN isStorySpotlight = 1 AND isTextless = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards;\n\n-- Query to list the IDs of Story Spotlight cards without a text box\nSELECT \n    id\nFROM \n    cards\nWHERE \n    isStorySpotlight = 1 AND isTextless = 0;",
        "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
        "evidence": [
            "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 0; Percentage = DIVIDE(SUM(count(id) where isStorylight = 1 AND isTextless = 0 ), SUM(count(id))) * 100",
            "The percentage calculation should focus on cards where `isStorySpotlight = 1` and exclude those with `isTextless = 1`.\nThe `GROUP_CONCAT` function is unnecessary for listing IDs; a simple selection suffices.",
            "The percentage calculation should use a conditional sum to count only cards meeting the criteria (`isStorySpotlight = 1` and `isTextless = 0`).\nThe query should filter for `isStorySpotlight = 1` before applying the conditional logic for `isTextless`.",
            "The percentage calculation should directly use conditional aggregation within a single query to count cards meeting the criteria (`isStorySpotlight = 1` and `isTextless = 0`).\nListing IDs requires a separate query without aggregation to avoid unnecessary grouping."
        ]
    },
    "1259": {
        "reason": "To solve the question, we need to find the diseases of patients who meet two conditions: 1) born after 1985-1-1, and 2) have a normal Rheumatoid Factor (RA IN('-', '+-')). The steps are as follows:\n1. Identify patients born after 1985-1-1 by filtering the `Patient` table where `Birthday` is greater than or equal to '1985-01-01'.\n2. Join the `Patient` table with the `Laboratory` table to check for patients with a normal Rheumatoid Factor (RA IN('-', '+-')).\n3. Retrieve the `Diagnosis` field from the `Patient` table for these patients.\n4. Ensure the query is valid SQLite syntax and uses the provided tips.",
        "sql": "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Birthday >= '1985-01-01'\nAND l.RA IN('-', '+-');",
        "question": "Please list the diseases of the patients born after 1985-1-1 and have a normal Rhuematoid Factor.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > '1985-01-01'",
        "evidence": [
            "diseases refers to Diagnosis; born after 1985/1/1 refers to YEAR(Birthday) > = 1985; normal Rhuematoid Factor refers to RA IN('-', '+-');"
        ]
    },
    "1133": {
        "reason": "To solve the question, we need to count the number of football players who were born after the 1990s and have the first name \"Aaron\". The `Player` table contains the relevant columns: `player_name` for the name and `birthday` for the birth year. We will filter players whose names start with \"Aaron\" (using `LIKE 'Aaron%'`) and whose birthdays are after the year 1990 (using `birthday > '1990'`). The query will then count these players.",
        "sql": "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Aaron%' AND birthday > '1990';",
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "evidence": [
            "first name \"Aaron\" refers to player_name LIKE 'Aaron%'; born after the 1990s refers to birthday > '1990'",
            "The `birthday` column in the `Player` table should be compared to the year '1990' directly, not a specific date like '1990-12-31'."
        ]
    },
    "5": {
        "reason": "To solve the question, we need to find the number of schools that are exclusively virtual (Virtual = 'F') and have an average SAT Math score greater than 400. The steps are as follows:\n1. Join the `satscores` table with the `schools` table using the `cds` (in `satscores`) and `CDSCode` (in `schools`) fields to get the virtual status of the schools.\n2. Filter the results to include only schools where the `Virtual` field is 'F' (exclusively virtual) and the `AvgScrMath` field is greater than 400.\n3. Count the number of such schools.",
        "sql": "SELECT COUNT(*) \nFROM satscores \nJOIN schools ON satscores.cds = schools.CDSCode \nWHERE schools.Virtual = 'F' AND satscores.AvgScrMath > 400;",
        "question": "How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.School) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' AND T1.AvgScrMath > 400",
        "evidence": [
            "Exclusively virtual refers to Virtual = 'F'"
        ]
    },
    "673": {
        "reason": "To solve the question, we need to find the average number of posts voted by the oldest users. Here's the step-by-step reasoning:\n\n1. **Identify the oldest users**: The oldest users are those whose `Age` equals the maximum `Age` in the `users` table. We can find these users by querying the `users` table where `Age` is equal to the maximum `Age`.\n\n2. **Find votes by the oldest users**: Once we have the oldest users, we need to find all the votes (`PostId`) associated with these users. This involves joining the `votes` table with the filtered `users` table on the `UserId`.\n\n3. **Calculate the average number of posts voted**: Finally, we calculate the average of the `PostId` values from the votes made by the oldest users. This gives us the average number of posts voted by them.\n\nPutting it all together, the query will:\n- Subquery to find the maximum `Age` from the `users` table.\n- Filter the `users` table to get the oldest users.\n- Join with the `votes` table to get their votes.\n- Calculate the average of `PostId` from these votes.",
        "sql": "SELECT AVG(v.PostId) AS average_posts_voted\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE u.Age = (SELECT MAX(Age) FROM users);",
        "question": "What is the average number of posts voted by the oldest users?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(PostId) FROM votes WHERE UserId IN ( SELECT Id FROM users WHERE Age = ( SELECT MAX(Age) FROM users ) )",
        "evidence": [
            "average number of posts voted refers to AVG(PostId) FROM votes; the oldest users refer to MAX(Age);",
            "To calculate the average number of posts voted, use AVG(PostId) directly from the votes table without intermediate counts.\nThe oldest users are identified by their Ids where Age equals the maximum Age in the users table.",
            "To compute the average number of posts voted, directly use AVG(PostId) from the votes table without intermediate counts or grouping.\nThe oldest users are identified by their Ids where Age equals the maximum Age in the users table, and their votes are filtered directly in the WHERE clause."
        ]
    },
    "1240": {
        "reason": "To solve the question, we need to find the average hematocrit level (HCT) from laboratory examinations in 1991 where the HCT is lower than the normal range (HCT < 29). The steps are as follows:\n1. Filter the laboratory examinations to include only those from 1991 by checking if the Date column starts with '1991'.\n2. Further filter these records to include only those where HCT is less than 29.\n3. Calculate the average of the HCT values from the filtered records.",
        "sql": "SELECT AVG(HCT) AS average_hematocrit_below_normal \nFROM Laboratory \nWHERE Date LIKE '1991%' AND HCT < 29;",
        "question": "From laboratory examinations in 1991, what is the average hematoclit level that is lower than the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.HCT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HCT < 29 AND STRFTIME('%Y', T2.Date) = '1991'",
        "evidence": [
            "laboratory examinations in 1991 refers to Date like '1991%'; average hematoclit level = AVG(HCT); hematoclit level that is lower than the normal range refers to HCT < 29;"
        ]
    },
    "1399": {
        "reason": "To determine if Maya Mclean attended the 'Women's Soccer' event, we need to follow these steps:\n1. Identify Maya Mclean's member_id by querying the member table where first_name is 'Maya' and last_name is 'Mclean'.\n2. Identify the event_id for the 'Women's Soccer' event by querying the event table where event_name is 'Women's Soccer'.\n3. Check the attendance table for a record where link_to_member matches Maya's member_id and link_to_event matches the event_id of 'Women's Soccer'.\n4. If such a record exists, Maya attended the event; otherwise, she did not.\n\nThe query will join the member, event, and attendance tables to verify attendance.",
        "sql": "SELECT \n    CASE \n        WHEN COUNT(*) > 0 THEN 'Yes, Maya Mclean attended the Women''s Soccer event.'\n        ELSE 'No, Maya Mclean did not attend the Women''s Soccer event.'\n    END AS attendance_status\nFROM attendance a\nJOIN member m ON a.link_to_member = m.member_id\nJOIN event e ON a.link_to_event = e.event_id\nWHERE m.first_name = 'Maya' AND m.last_name = 'Mclean'\nAND e.event_name = 'Women''s Soccer';",
        "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
        "evidence": [
            "Maya Mclean is the full name; full name refers to first_name, last_name; 'Women's Soccer' is an event_name",
            "The attendance table links members to events via member_id and event_id, requiring joins to member and event tables for verification.\nThe result should directly reflect the event_name from the event table when checking attendance.\nFull name matching involves combining first_name and last_name from the member table.",
            "The result should directly reflect the event_name from the event table when checking attendance.\nFull name matching involves combining first_name and last_name from the member table.",
            "The result should directly reflect the event_name from the event table when checking attendance.\nFull name matching involves combining first_name and last_name from the member table."
        ]
    },
    "330": {
        "reason": "To solve the question, we need to calculate the percentage of carcinogenic molecules that have both hydrogen atoms and triple bonds. The steps are as follows:\n1. Identify molecules that have at least one hydrogen atom (element = 'h').\n2. Identify molecules that have at least one triple bond (bond_type = '#').\n3. Ensure the molecules are carcinogenic (label = '+').\n4. Calculate the percentage by dividing the count of carcinogenic molecules with hydrogen and triple bonds by the total count of molecules with hydrogen and triple bonds, then multiplying by 100.\n5. The query should directly filter for these conditions in the WHERE clause, avoiding subqueries for clarity and efficiency.",
        "sql": "SELECT \n    (SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM \n    molecule m\nJOIN \n    atom a ON m.molecule_id = a.molecule_id\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nWHERE \n    a.element = 'h' AND b.bond_type = '#';",
        "question": "Calculate the percentage of carcinogenic molecules with triple bonded Hidrogen atoms.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T2.element = 'h'",
        "evidence": [
            "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) * 100.0 where element = 'h' AND bond_type = '#';",
            "The query must ensure the molecule has both hydrogen atoms and triple bonds, not just connections between hydrogen atoms via triple bonds. The join between `molecule`, `atom`, and `bond` should directly filter for these conditions.",
            "The query must directly filter for molecules with both hydrogen atoms and triple bonds in the WHERE clause, not through separate subqueries. The percentage calculation should use SUM and COUNT directly on the filtered results."
        ]
    },
    "361": {
        "reason": "To solve the question, we need to find the number of cards that have a restricted status in the legalities table and also have text boxes (i.e., are not textless). The steps are as follows:\n1. Join the `cards` table with the `legalities` table on the `uuid` field to link cards with their legal status.\n2. Filter the results to include only cards where the `status` in the `legalities` table is 'Restricted' (case-sensitive).\n3. Further filter the results to include only cards where `isTextless` is 0 (indicating they have text boxes).\n4. Count the distinct card IDs to avoid duplicates and get the final count.",
        "sql": "SELECT COUNT(DISTINCT c.id) \nFROM cards c \nJOIN legalities l ON c.uuid = l.uuid \nWHERE l.status = 'Restricted' AND c.isTextless = 0;",
        "question": "How many cards of legalities whose status is restricted have text boxes?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isTextless = 0",
        "evidence": [
            "restricted refers to status = 'restricted'; have text boxes refers to is Textless = 0;",
            "restricted status is case-sensitive and must match 'Restricted' exactly; distinct counts are needed to avoid duplicates when joining tables."
        ]
    },
    "411": {
        "reason": "To find the artist of the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\", we need to follow these steps:\n1. The text is in German, so it is likely stored in the `foreign_data` table under the `flavorText` column.\n2. We need to join the `foreign_data` table with the `cards` table on the `uuid` field to access the artist information.\n3. The search should be case-insensitive and allow partial matches, so we use the `LIKE` operator with wildcards.\n4. We will use `DISTINCT` to ensure unique results in case there are multiple matches.\n5. The query will filter the `foreign_data` table for the given text and then retrieve the corresponding artist from the `cards` table.",
        "sql": "SELECT DISTINCT c.artist\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.flavorText LIKE '%Das perfekte Gegenmittel zu einer dichten Formation%'",
        "question": "To which artist does the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\" belong?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
        "evidence": [
            "",
            "The `foreign_data` table contains translated text fields, such as `flavorText`, which may include the target text instead of the `cards` table.\nJoining `cards` with `foreign_data` on `uuid` allows accessing translated text fields.\nUsing `LIKE` with wildcards ensures partial matches for the target text in `foreign_data`.",
            "The `flavorText` column in `foreign_data` is case-insensitive and may contain partial matches, requiring `LIKE` with wildcards for flexible searching.\nUsing `DISTINCT` ensures unique results when multiple records match the search criteria."
        ]
    },
    "71": {
        "reason": "To find the district code for the school that does not offer a magnet program in the city of Fresno, we need to follow these steps:\n1. Identify the school(s) in the city of Fresno from the `schools` table.\n2. Filter these schools to exclude those that offer a magnet program (i.e., where `Magnet` is not equal to 1).\n3. Join the filtered schools with the `frpm` table to retrieve the district code for the identified school(s).\n4. Ensure the query returns the `District Code` from the `frpm` table.",
        "sql": "SELECT f.`District Code`\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.City = 'Fresno' AND s.Magnet != 1;",
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "evidence": [
            "When magent is equal to 0 in the database, it means ths school doesn't offer a magnet program."
        ]
    },
    "1360": {
        "reason": "To solve the question, we need to determine the percentage of the budget allocated for 'Parking' compared to the total budget for the event named 'November Speaker'. Here's the step-by-step reasoning:\n\n1. **Identify the event**: First, we need to find the `event_id` for the event named 'November Speaker' from the `event` table.\n2. **Retrieve the budget for 'Parking'**: Using the `event_id`, we will query the `budget` table to get the `amount` allocated for the category 'Parking'.\n3. **Retrieve the total budget for the event**: Using the same `event_id`, we will sum all the `amount` values in the `budget` table for the event.\n4. **Calculate the percentage**: Finally, we will calculate the percentage of the 'Parking' budget relative to the total budget for the event.\n\nThe SQL query will join the `event` and `budget` tables to achieve this.",
        "sql": "SELECT \n    (b1.amount * 100.0 / SUM(b2.amount)) AS percentage\nFROM \n    event e\nJOIN \n    budget b1 ON e.event_id = b1.link_to_event\nJOIN \n    budget b2 ON e.event_id = b2.link_to_event\nWHERE \n    e.event_name = 'November Speaker' AND b1.category = 'Parking'\nGROUP BY \n    b1.amount;",
        "question": "What percentage was the budget for Parking to the total budget for the \"November Speaker\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Speaker'",
        "evidence": [
            "DIVDE(SUM( amount where category = 'Parking' and event_name = 'November Speaker'), COUNT(event_name = 'November Speaker)) * 100"
        ]
    },
    "1079": {
        "reason": "To find the tallest player, we need to query the `Player` table and order the results by the `height` column in descending order. The tallest player will be the first result in this ordered list. We can then limit the result to 1 to get only the tallest player. The `player_name` column will give us the name of the tallest player.",
        "sql": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;",
        "question": "Which player is the tallest?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "evidence": [
            "tallest player refers to MAX(height);",
            "To retrieve the tallest player, ordering by height in descending order and limiting to one result is more efficient than using a subquery with MAX.",
            "The `player_name` column alone is sufficient to identify the tallest player, as the height is only used for ordering."
        ]
    },
    "1100": {
        "reason": "To find the highest overall rating received by Dorlan Pabon, we need to:\n1. Identify the player_api_id of Dorlan Pabon from the Player table.\n2. Use this player_api_id to query the Player_Attributes table for all records related to Dorlan Pabon.\n3. From these records, find the maximum value of the overall_rating attribute.\n\nThe query will involve joining the Player and Player_Attributes tables to ensure we are looking at the correct player.",
        "sql": "SELECT MAX(pa.overall_rating) AS highest_overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Dorlan Pabon';",
        "question": "What is the highest overall rating received by Dorlan Pabon?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT MAX(t2.overall_rating) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Dorlan Pabon'",
        "evidence": [
            "Dorlan Pabon refers to T2.player_name = 'Dorlan Pabon'; highest overall rating refers to MAX(overall_rating)"
        ]
    },
    "47": {
        "reason": "To solve the question, we need to find the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980. The steps are as follows:\n1. Identify schools in Alameda County (County = 'Alameda').\n2. Filter schools that are under the Elementary School District (DOC = '52').\n3. Filter schools that opened in 1980 (OpenDate between '1980-01-01' and '1980-12-31').\n4. Count the number of such schools.\n5. Divide the count by 12 to get the monthly average.",
        "sql": "SELECT COUNT(*) / 12.0 AS monthly_average\nFROM schools\nWHERE County = 'Alameda'\n  AND DOC = '52'\n  AND strftime('%Y', OpenDate) = '1980';",
        "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
        "evidence": [
            "Elementary School District refers to DOC = 52; Monthly average number of schools that opened in 1980 = count(schools that opened in 1980) / 12"
        ]
    },
    "96": {
        "reason": "To solve the question, we need to find the number of customers who have chosen a weekly issuance (frequency = 'POPLATEK TYDNE') and are also Owners (type = 'OWNER') in the disp table. Here's the step-by-step reasoning:\n\n1. Identify the relevant tables: \n   - `account` (to filter accounts with weekly issuance).\n   - `disp` (to filter owners).\n   - `client` (to count unique customers).\n\n2. Join these tables:\n   - Join `account` with `disp` on `account_id`.\n   - Join `disp` with `client` on `client_id`.\n\n3. Apply the filters:\n   - `account.frequency = 'POPLATEK TYDNE'` (weekly issuance).\n   - `disp.type = 'OWNER'` (owner type).\n\n4. Count the distinct `client_id` to get the number of unique customers.",
        "sql": "SELECT COUNT(DISTINCT c.client_id) AS customer_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'OWNER';",
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK TYDNE'",
        "evidence": [
            "'POPLATEK TYDNE' stands for weekly issuance"
        ]
    },
    "166": {
        "reason": "To solve the question, we need to find the number of accounts from the Jesenik district. The steps are as follows:\n1. Identify the district_id for Jesenik from the district table, where the district name is stored in column A2.\n2. Use this district_id to filter accounts in the account table.\n3. Count the number of accounts that match this district_id.",
        "sql": "SELECT COUNT(*) \nFROM account \nWHERE district_id = (SELECT district_id FROM district WHERE A2 = 'Jesenik');",
        "question": "How many of the accounts are from Jesenik district?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A2 = 'Jesenik'",
        "evidence": [
            ""
        ]
    },
    "1147": {
        "reason": "To find the player with the greatest overall strength, we need to identify the highest `overall_rating` in the `Player_Attributes` table. This can be achieved by using the `MAX(overall_rating)` function. Once we have the maximum rating, we can join the `Player_Attributes` table with the `Player` table to retrieve the player's name. The query will ensure that only distinct players are returned, and a subquery will be used to filter for the highest rating.",
        "sql": "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);",
        "question": "Please name one player whose overall strength is the greatest.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = ( SELECT MAX(overall_rating) FROM Player_Attributes)",
        "evidence": [
            "overall strength is the greatest refers to MAX(overall_rating)",
            "The `overall_rating` in `Player_Attributes` represents a player's strength, and the greatest value can be found using `MAX(overall_rating)`.\nTo ensure only distinct players are returned, use `DISTINCT` in the query.\nA subquery with `MAX(overall_rating)` is needed to filter for the highest rating."
        ]
    },
    "146": {
        "reason": "To solve the question, we need to identify female account holders who own credit cards and also have loans. Here's the step-by-step reasoning:\n\n1. **Identify Female Clients**: Start by filtering clients from the `client` table where `gender` is 'F'.\n2. **Link Clients to Accounts**: Use the `disp` table to link these female clients to their accounts. The `disp` table connects `client_id` to `account_id`.\n3. **Check for Loans**: Ensure these accounts have entries in the `loan` table by joining the `account` table with the `loan` table on `account_id`.\n4. **Check for Credit Cards**: Ensure these clients have credit cards by joining the `disp` table with the `card` table on `disp_id`.\n5. **Combine Conditions**: The final query must combine all these conditions to filter for female clients with both loans and credit cards.",
        "sql": "SELECT DISTINCT c.client_id, c.gender, c.birth_date, c.district_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nJOIN card cd ON d.disp_id = cd.disp_id\nWHERE c.gender = 'F';",
        "question": "Who are the female account holders who own credit cards and also have loans?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T5 ON T2.account_id = T5.account_id INNER JOIN loan AS T3 ON T5.account_id = T3.account_id INNER JOIN card AS T4 ON T2.disp_id = T4.disp_id WHERE T1.gender = 'F'",
        "evidence": [
            "Female refers to gender = 'F'",
            "The `disp` table links clients to accounts and also connects to the `card` table via `disp_id`.\nTo ensure a client has a loan, the `account` table must link to the `loan` table via `account_id`.\nThe `card` table's `type` column is not required for filtering in this context.",
            "The `disp` table serves as the central link between clients, accounts, and cards, ensuring all required connections are established.\nTo confirm a client has a loan, the `account` table must be linked to the `loan` table via `account_id`.\nThe `client` table's `gender` column is used to filter for female account holders.",
            "The `card` table's `type` column is not required for filtering in this context, as the question does not specify a card type.\nThe `disp` table links clients to accounts and cards, ensuring all required connections are established without additional filtering.\nThe `loan` table must be linked to the `account` table to confirm the presence of loans."
        ]
    },
    "320": {
        "reason": "To find the type of the bond connecting two atoms (TR000_1 and TR000_2), we need to follow these steps:\n1. Identify the bond_id in the `connected` table that links the two atoms (TR000_1 and TR000_2).\n2. Use the bond_id to query the `bond` table to retrieve the bond_type.\n\nThe query will join the `connected` table with the `bond` table to get the bond_type for the specified atoms.",
        "sql": "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR000_1' AND c.atom_id2 = 'TR000_2') OR (c.atom_id = 'TR000_2' AND c.atom_id2 = 'TR000_1');",
        "question": "What is the type of the bond which is presenting the connection between two atoms TR000_1 and TR000_2?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'",
        "evidence": [
            "type of bond refers to bond_type; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ]
    },
    "578": {
        "reason": "To solve the question, we need to find the user who made a post with the title 'Understanding what Dassault iSight is doing?' and then retrieve their reputation. This involves two main steps:\n1. Identify the post with the given title in the `posts` table and retrieve the `OwnerUserId` (the user who made the post).\n2. Use the `OwnerUserId` to find the corresponding user in the `users` table and retrieve their `Reputation`.",
        "sql": "SELECT u.DisplayName, u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Understanding what Dassault iSight is doing?';",
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "evidence": [
            "\"Understanding what Dassault iSight is doing?\" is the Title of post; user refers to DisplayName;"
        ]
    },
    "881": {
        "reason": "To solve the question, we need to determine the race completion rate for drivers who participated in the race on 1983-07-16. The steps are as follows:\n1. Identify the race(s) that occurred on 1983-07-16 by querying the `races` table.\n2. For each identified race, retrieve the list of drivers who participated by querying the `results` table.\n3. For each driver, determine their completion status by checking the `status` field in the `results` table. A completed race typically has a status indicating completion (e.g., \"Finished\").\n4. Calculate the completion rate by dividing the number of drivers who completed the race by the total number of drivers who participated.\n5. Return the completion rate as a percentage.\n\nThe query will involve joining the `races`, `results`, and `status` tables to gather the necessary information.",
        "sql": "WITH race_on_date AS (\n    SELECT raceId FROM races WHERE date = '1983-07-16'\n),\ndriver_participation AS (\n    SELECT r.driverId, s.status\n    FROM results r\n    JOIN race_on_date rod ON r.raceId = rod.raceId\n    JOIN status s ON r.statusId = s.statusId\n),\ncompletion_stats AS (\n    SELECT \n        COUNT(*) AS total_drivers,\n        SUM(CASE WHEN status = 'Finished' THEN 1 ELSE 0 END) AS completed_drivers\n    FROM driver_participation\n)\nSELECT \n    (completed_drivers * 100.0 / total_drivers) AS completion_rate_percentage\nFROM completion_stats;",
        "question": "For the drivers who took part in the race in 1983/7/16, what's their race completion rate?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'",
        "evidence": [
            "DIVIDE(COUNT(driverid when time has value ), (COUNT(driverid )) as percentage; in 1983/7/16 refers to when date = '1983-07-16'"
        ]
    },
    "1379": {
        "reason": "To determine how many meeting events were held in 2020, we need to query the `event` table. The question specifies that meeting events are identified by the `type` column being 'Meeting' and the events held in 2020 are identified by the year in the `event_date` column. We will use the `COUNT` function to count the number of such events. The `WHERE` clause will filter events where `type` is 'Meeting' and the `event_date` contains '2020' (assuming the date is stored in a format like 'YYYY-MM-DD').",
        "sql": "SELECT COUNT(*) FROM event WHERE type = 'Meeting' AND event_date LIKE '%2020%';",
        "question": "How many meeting events were held in 2020?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(event_id) FROM event WHERE type = 'Meeting' AND SUBSTR(event_date, 1, 4) = '2020'",
        "evidence": [
            "meeting events refers to type = 'Meeting'; held in 2020 refers to YEAR(event_date) = 2020"
        ]
    },
    "822": {
        "reason": "To solve the question, we need to find the number of green-skinned villains in the superhero universe. The steps are as follows:\n1. Identify villains by checking the `alignment` table where `alignment` is 'Bad'.\n2. Identify green-skinned superheroes by checking the `colour` table where `colour` is 'Green' and linking it to the `skin_colour_id` in the `superhero` table.\n3. Join the `superhero` table with the `alignment` and `colour` tables to filter for green-skinned villains.\n4. Count the number of such superheroes.",
        "sql": "SELECT COUNT(*) AS green_skinned_villains\nFROM superhero\nJOIN alignment ON superhero.alignment_id = alignment.id\nJOIN colour ON superhero.skin_colour_id = colour.id\nWHERE alignment.alignment = 'Bad' AND colour.colour = 'Green';",
        "question": "How many green-skinned villains are there in the superhero universe?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "evidence": [
            "green-skinned refers to colour.colour = 'Green' WHERE skin_colour_id = colour.id; villains refers to alignment = 'Bad';"
        ]
    },
    "253": {
        "reason": "To solve the question, we need to retrieve the distinct elements of atoms involved in triple bonds. The schema includes tables for atoms, bonds, and connections between atoms. The `bond` table has a `bond_type` column, where a triple bond is indicated by `'#'`. The `connected` table links atoms to bonds, and the `atom` table contains the element information for each atom.\n\n1. First, identify all bonds with `bond_type = '#'` in the `bond` table.\n2. Join these bonds with the `connected` table to find the atoms involved in these triple bonds.\n3. Join the `connected` table with the `atom` table to get the element information for these atoms.\n4. Finally, select the distinct elements from the `atom` table to avoid duplicates.\n\nThe query will involve joining the `bond`, `connected`, and `atom` tables, filtering for triple bonds, and selecting distinct elements.",
        "sql": "SELECT DISTINCT a.element\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a ON c.atom_id = a.atom_id\nWHERE b.bond_type = '#';",
        "question": "List the elements of all the triple bonds.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.element FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T1.bond_type = '#'",
        "evidence": [
            "triple bond refers to bond_type = '#';",
            "The query should retrieve distinct elements from atoms involved in triple bonds, not pairs of elements.\nTriple bonds involve atoms connected via a single bond_id, so joining to atom once suffices."
        ]
    },
    "1101": {
        "reason": "To solve the question, we need to find the average number of goals made by Parma as the away team while playing in Italy. Here's the step-by-step reasoning:\n\n1. **Identify Parma's team ID**: We need to find the `team_api_id` for Parma from the `Team` table.\n2. **Filter matches in Italy**: We need to identify matches where the league is in Italy. This involves joining the `Match` table with the `League` and `Country` tables to filter matches by country name (Italy).\n3. **Filter matches where Parma is the away team**: Using the `team_api_id` from step 1, filter matches where Parma is the away team (`away_team_api_id`).\n4. **Calculate the average goals**: For these filtered matches, calculate the average of `away_team_goal` (since Parma is the away team).\n\nCombining these steps, we will join the necessary tables and apply the filters to get the desired result.",
        "sql": "SELECT AVG(m.away_team_goal) AS average_goals\nFROM Match m\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nJOIN League l ON m.league_id = l.id\nJOIN Country c ON l.country_id = c.id\nWHERE t.team_long_name = 'Parma' AND c.name = 'Italy';",
        "question": "What is the average number of goals made by Parma as the away team while playing in Italy?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) FROM \"Match\" AS T1 INNER JOIN TEAM AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN Country AS T3 ON T1.country_id = T3.id WHERE T2.team_long_name = 'Parma' AND T3.name = 'Italy'",
        "evidence": [
            "Parma refers to team_long_name = 'Parma'; average number of goals refers to AVG(away_team_goal)"
        ]
    },
    "176": {
        "reason": "To solve the question, we need to determine the amount of debt that client number 992 has and assess their payment status. Here's the step-by-step reasoning:\n\n1. **Identify the client's account(s):** Client number 992 is associated with one or more accounts through the `disp` table, where `client_id` is linked to `account_id`.\n2. **Find the loan(s) associated with the account(s):** Using the `account_id` from the `disp` table, we can query the `loan` table to find the loan amount and payment status.\n3. **Retrieve the loan details:** The `loan` table contains the `amount` (debt) and `status` (payment status) for each loan.\n4. **Filter for client 992:** We need to ensure the query is specific to client 992 by joining the `client`, `disp`, `account`, and `loan` tables.\n\nFinal SQL query will join these tables and filter for client 992 to retrieve the loan amount and payment status.",
        "sql": "SELECT l.amount AS debt_amount, l.status AS payment_status\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.client_id = 992;",
        "question": "What is the amount of debt that client number 992 has, and how is this client doing with payments?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.amount, T4.status FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 on T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 992",
        "evidence": [
            ""
        ]
    },
    "636": {
        "reason": "To solve the question, we need to find the number of negative comments (score < 60) that Neil McGuigan received on his posts. The steps are as follows:\n1. Identify Neil McGuigan's user ID from the `users` table using his display name ('Neil McGuigan').\n2. Find all posts where Neil McGuigan is the owner (using the `OwnerUserId` from the `posts` table).\n3. For each of these posts, count the number of comments with a score less than 60 in the `comments` table.\n4. Sum these counts to get the total number of negative comments on Neil McGuigan's posts.",
        "sql": "SELECT COUNT(*) AS NegativeCommentCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'Neil McGuigan' AND c.Score < 60;",
        "question": "How many negative comments did Neil McGuigan get in his posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T1.DisplayName = 'Neil McGuigan' AND T3.Score < 60",
        "evidence": [
            "Negative comment refers to score < 60; DisplayName = 'Neil McGuigan';"
        ]
    },
    "1096": {
        "reason": "To calculate the average overall rating of Pietro Marino, we need to follow these steps:\n1. Identify Pietro Marino's player_api_id from the Player table using his name.\n2. Use this player_api_id to find all his entries in the Player_Attributes table.\n3. Calculate the average of the overall_rating column for these entries.",
        "sql": "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Pietro Marino');",
        "question": "Calculate the average overall rating of Pietro Marino.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Pietro Marino'",
        "evidence": [
            "Pietro Marino refers to player_name = 'Pietro Marino'; average overall rating AVG(T1.overall_rating)"
        ]
    },
    "263": {
        "reason": "To solve the question, we need to find the percentage of chlorine atoms (`element = 'cl'`) among all atoms in molecules that have single bonds (`bond_type = '-'`). The steps are as follows:\n1. Identify all molecules that have single bonds by querying the `bond` table where `bond_type = '-'`.\n2. For these molecules, count the total number of atoms and the number of chlorine atoms by joining the `atom` table with the filtered molecules.\n3. Calculate the percentage of chlorine atoms by dividing the count of chlorine atoms by the total count of atoms and multiplying by 100.\n4. Ensure the result is presented as a percentage.",
        "sql": "SELECT \n    (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS chlorine_percentage\nFROM \n    atom a\nJOIN \n    molecule m ON a.molecule_id = m.molecule_id\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nWHERE \n    b.bond_type = '-';",
        "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "evidence": [
            "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'"
        ]
    },
    "1036": {
        "reason": "To solve the question, we need to identify teams with above-average build-up play passing in 2012. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `Team_Attributes` table contains the `buildUpPlayPassing` attribute, and the `Team` table contains the `team_long_name`.\n2. **Filter for the year 2012**: The `date` column in `Team_Attributes` will be used to filter records from 2012.\n3. **Calculate the average build-up play passing**: We need to compute the average `buildUpPlayPassing` value for all teams in 2012.\n4. **Filter teams with above-average build-up play passing**: Compare each team's `buildUpPlayPassing` value to the calculated average.\n5. **Join the `Team` table to get the team's long name**: The `team_api_id` or `team_fifa_api_id` can be used to join the `Team` table.\n\nFinally, we will select the `team_long_name` from the `Team` table for teams that meet the criteria.",
        "sql": "SELECT t.team_long_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE strftime('%Y', ta.date) = '2012'\nAND ta.buildUpPlayPassing > (\n    SELECT AVG(buildUpPlayPassing)\n    FROM Team_Attributes\n    WHERE strftime('%Y', date) = '2012'\n);",
        "question": "List the long name of teams with above-average build-up play passing in 2012.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t4.team_long_name FROM Team_Attributes AS t3 INNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTR(t3.`date`, 1, 4) = '2012' AND t3.buildUpPlayPassing > ( SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE STRFTIME('%Y',t2.`date`) = '2012')",
        "evidence": [
            "long name of teams refers to team_long_name; build-up play passing refers to buildUpPlayPassing; above-average build-up play passing = buildUpPlayPassing > DIVIDE(SUM(buildUpPlayPassing), COUNT(team_long_name) WHERE buildUpPlayPassing IS NOT NULL); in 2012 refers to strftime('%Y', date) = '2012'; "
        ]
    },
    "484": {
        "reason": "To solve the question, we need to find the Italian names of the cards in the set 'Coldsnap' with the highest converted mana cost. Here's the step-by-step reasoning:\n\n1. **Identify the set code for 'Coldsnap'**: The set name 'Coldsnap' is stored in the `sets` table under the column `name`, and the set code is stored under `code`. We need to query the `sets` table to find the `code` for 'Coldsnap'.\n\n2. **Find the highest converted mana cost in the set**: The `cards` table contains the `convertedManaCost` column. We need to find the maximum value of this column for cards in the 'Coldsnap' set.\n\n3. **Retrieve cards with the highest converted mana cost**: Using the set code from step 1 and the highest converted mana cost from step 2, we can filter the `cards` table to get the relevant cards.\n\n4. **Get Italian names for these cards**: The Italian names are stored in the `foreign_data` table under the column `name` when the `language` is 'Italian'. We need to join the `cards` table with the `foreign_data` table to retrieve the Italian names.\n\n5. **Combine the results**: The final query will join the `sets`, `cards`, and `foreign_data` tables to get the Italian names of the cards in 'Coldsnap' with the highest converted mana cost.",
        "sql": "WITH ColdsnapSet AS (\n    SELECT code FROM sets WHERE name = 'Coldsnap'\n),\nMaxManaCost AS (\n    SELECT MAX(c.convertedManaCost) AS max_cost\n    FROM cards c\n    JOIN ColdsnapSet cs ON c.setCode = cs.code\n)\nSELECT fd.name AS italian_name\nFROM cards c\nJOIN ColdsnapSet cs ON c.setCode = cs.code\nJOIN MaxManaCost mmc ON c.convertedManaCost = mmc.max_cost\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Italian';",
        "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
        "evidence": [
            "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'; highest converted mana cost refers to MAX(convertedManaCost)",
            "The set name 'Coldsnap' is stored in the `sets` table under the column `name`, and the set code is stored under `code`.\nTo find the highest converted mana cost, sorting in descending order and selecting the top result is more efficient than using a subquery with MAX.\nItalian names are stored in the `foreign_data` table under the column `name` when the `language` is 'Italian'.",
            "The `setCode` column in the `cards` table links to the `code` column in the `sets` table, enabling direct filtering by set name.\nTo retrieve the highest converted mana cost, sorting in descending order and selecting the top result is more efficient than using a subquery with MAX.\nItalian names are stored in the `foreign_data` table under the column `name` when the `language` is 'Italian'.",
            "The `setCode` column in the `cards` table directly links to the `code` column in the `sets` table, enabling filtering by set name without intermediate steps.\nTo retrieve the highest converted mana cost, sorting in descending order and selecting the top result is more efficient than using a subquery with MAX.\nItalian names are stored in the `foreign_data` table under the column `name` when the `language` is 'Italian'."
        ]
    },
    "117": {
        "reason": "To find the percentage of loan amounts that have been fully paid with no issues, we need to follow these steps:\n1. Identify the total loan amount from the `loan` table.\n2. Identify the loan amount where the status is 'A' (indicating the loan was fully paid with no issues).\n3. Calculate the percentage by dividing the amount from step 2 by the total amount from step 1 and multiplying by 100.\n\nThe query will sum the `amount` column for all loans and for loans with status 'A', then compute the percentage.",
        "sql": "SELECT (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0 / SUM(amount)) AS percentage_paid_no_issue\nFROM loan;",
        "question": "What is the percentage of loan amount that has been fully paid with no issue.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
        "evidence": [
            "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%"
        ]
    },
    "230": {
        "reason": "To solve the question, we need to find the elements of the atoms and the label of the molecule with the ID 'TR060'. The steps are as follows:\n1. First, we need to identify the molecule with the ID 'TR060' from the `molecule` table to get its label.\n2. Then, we need to find all atoms associated with this molecule by joining the `atom` table with the `molecule` table on the `molecule_id` field.\n3. Finally, we will select the `element` from the `atom` table and the `label` from the `molecule` table for the molecule 'TR060'.",
        "sql": "SELECT a.element, m.label FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR060';",
        "question": "What are the elements of the toxicology and label of molecule TR060?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'",
        "evidence": [
            "TR060 is the molecule id; "
        ]
    },
    "301": {
        "reason": "To find the bond type of `TR007_4_19`, we need to identify the `bond_type` associated with the bond ID `TR007_4_19` in the `bond` table. The `bond` table contains the `bond_id` and `bond_type` columns, so we can directly query this table for the given bond ID.",
        "sql": "SELECT bond_type FROM bond WHERE bond_id = 'TR007_4_19';",
        "question": "What is the bond type of TR007_4_19?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_type FROM bond AS T WHERE T.bond_id = 'TR007_4_19'",
        "evidence": [
            "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ]
    },
    "836": {
        "reason": "To find the total number of superheroes that have 'John' as their first name, we need to analyze the `superhero` table. The `full_name` column in this table likely contains the full names of the superheroes. We can use the `LIKE` operator to search for names that start with 'John' (e.g., 'John%'). The query will count the number of rows where the `full_name` starts with 'John'.",
        "sql": "SELECT COUNT(*) FROM superhero WHERE full_name LIKE 'John%';",
        "question": "What is the total number of superheroes that have John as their first name?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name LIKE 'John%'",
        "evidence": [
            "have John as their first name refers to full_name LIKE 'John%';"
        ]
    },
    "39": {
        "reason": "To solve the question, we need to find the average number of test takers from schools in Fresno that opened between January 1, 1980, and December 31, 1980. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `schools` table contains information about schools, including their opening dates and locations (County). The `satscores` table contains the number of test takers (`NumTstTakr`).\n\n2. **Filter schools in Fresno**: The `County` column in the `schools` table can be used to filter schools located in Fresno.\n\n3. **Filter schools opened in 1980**: The `OpenDate` column in the `schools` table can be used to filter schools that opened between January 1, 1980, and December 31, 1980.\n\n4. **Join the tables**: The `CDSCode` in the `schools` table corresponds to the `cds` column in the `satscores` table. We need to join these tables to get the number of test takers for the filtered schools.\n\n5. **Calculate the average**: Use the `AVG` function on the `NumTstTakr` column from the `satscores` table to find the average number of test takers.\n\n6. **Final query**: Combine all these steps into a single SQL query.",
        "sql": "SELECT AVG(s.NumTstTakr) AS average_test_takers\nFROM schools sc\nJOIN satscores s ON sc.CDSCode = s.cds\nWHERE sc.County = 'Fresno'\nAND sc.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';",
        "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T2.County = 'Fresno'",
        "evidence": [
            "between 1/1/1980 and 12/31/1980 means the year = 1980"
        ]
    },
    "103": {
        "reason": "To find the client who issued their card on 1994/3/3, we need to follow these steps:\n1. Identify the card issued on 1994/3/3 from the `card` table.\n2. Link the card to its owner via the `disp` table, which connects the card to a client.\n3. Retrieve the client ID from the `client` table.\n\nThe query will join the `card`, `disp`, and `client` tables to find the client ID where the card's issued date is 1994/3/3.",
        "sql": "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.issued = '1994-03-03';",
        "question": "Which client issued his/her card in 1994/3/3, give his/her client id.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.issued = '1994-03-03'",
        "evidence": [
            ""
        ]
    },
    "1342": {
        "reason": "To find the cost for the \"Posters\" on 2019/9/4, we need to query the `expense` table. The `expense_description` column contains the item \"Posters\", and the `expense_date` column should match the date \"2019-09-04\" (formatted as YYYY-MM-DD). The query will filter for these conditions and return the `cost` of the expense.",
        "sql": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04';",
        "question": "What was the cost for the \"Posters\" on 2019/9/4?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04'",
        "evidence": [
            "'Poster' is an event description; on 2019/9/14 refers to event_date = '2019-09-04'",
            "The 'expense_description' column in the 'expense' table directly records specific items like 'Posters'.\nThe 'expense_date' column in the 'expense' table captures the date of the expense, not the event date."
        ]
    },
    "485": {
        "reason": "To find the ruling date for the card 'Reminisce', we need to follow these steps:\n1. First, locate the card 'Reminisce' in the 'cards' table to get its UUID, as the 'rulings' table references cards by UUID.\n2. Once we have the UUID, we can query the 'rulings' table for the 'date' associated with that UUID.\n3. The query will join the 'cards' and 'rulings' tables on the UUID to retrieve the ruling date for 'Reminisce'.",
        "sql": "SELECT r.date FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Reminisce';",
        "question": "When was the ruling for the card 'Reminisce' created?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Reminisce'",
        "evidence": [
            "Reminisce refers to name = 'Reminisce'; when created is the date"
        ]
    },
    "931": {
        "reason": "To find the fastest lap speed among all drivers in the 2009 Spanish Grand Prix, we need to follow these steps:\n1. Identify the raceId for the 2009 Spanish Grand Prix from the `races` table.\n2. Use the `results` table to find the fastest lap speed for each driver in that race.\n3. Retrieve the maximum value of the `fastestLapSpeed` column from the `results` table for the identified race.\n\nThe query will join the `races` and `results` tables to filter for the specific race and then find the maximum fastest lap speed.",
        "sql": "SELECT MAX(r.fastestLapSpeed) AS fastest_lap_speed\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 2009 AND rc.name = 'Spanish Grand Prix';",
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "evidence": [
            "the fastest lap speed among all refers to max(fastestLapSpeed); Spanish Grand Prix refers to races.name = 'Spanish Grand Prix';"
        ]
    },
    "1417": {
        "reason": "To solve the question, we need to list the types of events that have a remaining budget of more than 30 USD. This involves querying the `event` table and joining it with the `budget` table to filter events based on the remaining budget. The steps are:\n1. Join the `event` table with the `budget` table using the `event_id` as the linking key.\n2. Filter the results to include only those records where the `remaining` field in the `budget` table is greater than 30.\n3. Select the `type` field from the `event` table to list the types of events that meet the criteria.",
        "sql": "SELECT DISTINCT e.type\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.remaining > 30;",
        "question": "List out the type of events which have remaining budget more than 30 USD.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 30",
        "evidence": [
            "remaining budget more than 30 USD refers to remaining > 30"
        ]
    },
    "0": {
        "reason": "To find the highest eligible free rate for K-12 students in Alameda County, we need to:\n1. Filter the `frpm` table to include only schools in Alameda County by checking the `County Name` column.\n2. From these schools, select the maximum value of the `Percent (%) Eligible Free (K-12)` column.\n3. The query will return the highest eligible free rate for K-12 students in Alameda County.",
        "sql": "SELECT MAX(`Percent (%) Eligible Free (K-12)`) AS HighestEligibleFreeRate\nFROM frpm\nWHERE `County Name` = 'Alameda';",
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "evidence": [
            "Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`"
        ]
    },
    "227": {
        "reason": "To find the percentage of molecules that are carcinogenic, we need to count the total number of molecules and the number of molecules labeled as '+'. The percentage is then calculated by dividing the count of carcinogenic molecules by the total number of molecules and multiplying by 100. The result should be formatted to three decimal places. The schema provides a `molecule` table with a `label` column where '+' indicates carcinogenic molecules.",
        "sql": "SELECT ROUND((SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(molecule_id)), 3) AS percentage\nFROM molecule;",
        "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3) FROM molecule t",
        "evidence": [
            "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent"
        ]
    },
    "106": {
        "reason": "To solve the question, we need to find the biggest transaction amount made by a client whose card was opened on 1996/10/21. Here's the step-by-step reasoning:\n\n1. **Identify the client**: First, we need to find the client(s) who have a card issued on 1996/10/21. This involves joining the `card` table with the `disp` table (to link the card to a client) and then the `client` table.\n\n2. **Find transactions**: Once we have the client(s), we need to find their transactions. This involves joining the `account` table (to link the client's account) with the `trans` table.\n\n3. **Filter transactions**: We need to filter transactions made by the identified client(s).\n\n4. **Find the maximum amount**: Finally, we need to find the maximum transaction amount from the filtered transactions.\n\nThe query will involve multiple joins and a subquery to ensure we only consider transactions from the client(s) with the specified card issue date.",
        "sql": "SELECT MAX(t.amount) AS biggest_transaction_amount\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN card cd ON d.disp_id = cd.disp_id\nWHERE cd.issued = '1996-10-21';",
        "question": "What is the biggest amount of transaction that the client whose card was opened in 1996/10/21 made?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.amount FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 on T2.account_id = T3.account_id JOIN trans AS T4 on T3.account_id = T4.account_id WHERE T1.issued = '1996-10-21' ORDER BY T4.amount DESC LIMIT 1",
        "evidence": [
            ""
        ]
    },
    "833": {
        "reason": "To find the superhero known as Charles Chandler, we need to query the `superhero` table where the `full_name` column matches 'Charles Chandler'. The query will retrieve the `superhero_name` from the `superhero` table for this specific full name.",
        "sql": "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';",
        "question": "Name the superhero, otherwise known as Charles Chandler.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler'",
        "evidence": [
            "name the superhero refers to superhero_name; Charles Chandler is the full name of superhero;"
        ]
    },
    "82": {
        "reason": "To solve the question, we need to find the grade span offered by the school with the highest longitude. The steps are as follows:\n1. Identify the school with the highest longitude value (considering absolute values if necessary).\n2. Retrieve the `GSoffered` column for that school from the `schools` table.\n3. Since the `Longitude` column may contain negative values, we should use the absolute value to determine the highest longitude.\n4. Use `ORDER BY ABS(Longitude) DESC LIMIT 1` to efficiently find the school with the highest longitude.\n5. Select the `GSoffered` column for this school.",
        "sql": "SELECT GSoffered FROM schools ORDER BY ABS(Longitude) DESC LIMIT 1;",
        "question": "What is the grade span offered in the school with the highest longitude?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
        "evidence": [
            "the highest longitude refers to the school with the maximum absolute longitude value.",
            "The grade span offered by a school is directly available in the `GSoffered` column of the `schools` table, not in the `frpm` table.",
            "The `Longitude` column in the `schools` table may contain negative values, so the highest absolute longitude should be considered for determining the farthest school.",
            "The `ORDER BY` clause with `DESC` and `LIMIT 1` is more efficient for retrieving the top record by a specific column value than using a subquery with `MAX`."
        ]
    },
    "410": {
        "reason": "To solve the question, we need to find cards that meet the following criteria:\n1. The artist is 'Erica Yang'.\n2. The card is legal in the 'pauper' format (as indicated by the `format` column in the `legalities` table).\n3. The card is available in paper (as indicated by the `availability` column in the `cards` table).\n\nWe will join the `cards` table with the `legalities` table to filter for cards that are legal in the 'pauper' format. Then, we will further filter these cards to ensure they are available in paper and have 'Erica Yang' as the artist. Finally, we will retrieve the ID of such cards.",
        "sql": "SELECT c.id\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.artist = 'Erica Yang'\n  AND l.format = 'pauper'\n  AND c.availability = 'paper';",
        "question": "Is there any card from Erica Yang artist in pauper format and available in paper? If so, indicate its ID.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper'",
        "evidence": [
            "available in paper refers to availability = 'paper'",
            "The `status` column in the `legalities` table is not required to filter for cards legal in a specific format; the `format` column alone suffices."
        ]
    },
    "765": {
        "reason": "To count the number of heroes with the 'stealth' power, we need to:\n1. Join the `hero_power` table with the `superpower` table on the `power_id` field to match heroes with their powers.\n2. Filter the results to only include rows where the `power_name` is exactly 'Stealth' (case-sensitive).\n3. Count the distinct `hero_id` values in the filtered results to get the number of unique heroes with the 'stealth' power.",
        "sql": "SELECT COUNT(DISTINCT hero_id) AS stealth_hero_count\nFROM hero_power\nJOIN superpower ON hero_power.power_id = superpower.id\nWHERE superpower.power_name = 'Stealth';",
        "question": "How many heroes have stealth power?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'",
        "evidence": [
            "stealth power refers to power_name = 'stealth';",
            "To count heroes with a specific power, join the `hero_power` and `superpower` tables on `power_id` and filter by the power name.",
            "The `power_name` in the `superpower` table is case-sensitive, so filtering requires exact matching of the string 'Stealth'.",
            "The `power_name` in the `superpower` table is case-sensitive, and the exact string 'Stealth' must be used for filtering."
        ]
    },
    "566": {
        "reason": "To find the reputation points of the owner user of post No. 65041, we need to follow these steps:\n1. Identify the `OwnerUserId` of the post with `Id = 65041` from the `posts` table.\n2. Use this `OwnerUserId` to query the `users` table and retrieve the `Reputation` of the user.",
        "sql": "SELECT u.Reputation\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Id = 65041;",
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "evidence": [
            "post no. 65041 refers to Id = '65041'; reputation point refers to Reputation"
        ]
    },
    "309": {
        "reason": "To solve the question, we need to:\n1. Identify all atoms (`atom_id`) that belong to the molecule with `molecule_id` = 'TR346'.\n2. Count the distinct bond types (`bond_type`) associated with the molecule 'TR346'.\n\nSteps:\n- First, query the `atom` table to find all `atom_id` values where `molecule_id` is 'TR346'.\n- Then, join the `bond` table with the `molecule` table (or directly use the `bond` table) to count the distinct `bond_type` values for the molecule 'TR346'.\n- The results should be combined to show the list of atom IDs and the count of distinct bond types for the molecule.",
        "sql": "SELECT a.atom_id, COUNT(DISTINCT b.bond_type) AS bond_type_count\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.molecule_id = 'TR346'\nGROUP BY a.atom_id;",
        "question": "List out the atom id that belongs to the TR346 molecule and how many bond type can be created by this molecule?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type),T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR000' GROUP BY T1.atom_id, T2.bond_type",
        "evidence": [
            "",
            "To count distinct bond types per molecule, ensure the join between `atom` and `bond` tables is based on the `molecule_id` field.\nGrouping by `atom_id` alone may not correctly reflect the relationship between atoms and bond types.",
            "To count distinct bond types per molecule, ensure the join between `atom` and `bond` tables is based on the `molecule_id` field.\nGrouping by `atom_id` alone may not correctly reflect the relationship between atoms and bond types.\nInclude the `molecule_id` in the GROUP BY clause to ensure accurate aggregation of bond types per molecule.",
            "To count distinct bond types per molecule, ensure the join between `atom` and `bond` tables includes the `molecule_id` field in the GROUP BY clause.\nThe `atom_id` alone does not uniquely identify bond types, so grouping by both `atom_id` and `molecule_id` is necessary for accurate aggregation."
        ]
    },
    "960": {
        "reason": "To find the average of the fastest lap speed in the 2009 Spanish Grand Prix race, we need to follow these steps:\n1. Identify the raceId for the 2009 Spanish Grand Prix from the `races` table.\n2. Use the `results` table to find the fastest lap speeds for all drivers in that race.\n3. Calculate the average of the `fastestLapSpeed` values from the `results` table for the identified race.\n\nThe query will involve joining the `races` and `results` tables to filter the results for the specific race and then computing the average of the `fastestLapSpeed` column.",
        "sql": "SELECT AVG(CAST(fastestLapSpeed AS REAL)) AS average_fastest_lap_speed\nFROM results\nJOIN races ON results.raceId = races.raceId\nWHERE races.year = 2009 AND races.name = 'Spanish Grand Prix';",
        "question": "What is the average of fastest lap speed in the 2009 Spanish Grand Prix race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "evidence": [
            "Spanish Grand Prix is the name of race refers to name = 'Spanish Grand Prix'; average fastest lap speed refers to avg(fastestLapSpeed);"
        ]
    },
    "224": {
        "reason": "To solve the question, we need to find all bond IDs where the atom ID 2 is the same as the atom ID 2 in the bond connected to TR000_2. Here's the step-by-step reasoning:\n\n1. First, identify the atom ID 2 for the bond connected to TR000_2. This involves querying the `connected` table for records where `atom_id` or `atom_id2` is TR000_2.\n2. Once we have the atom ID 2, we then find all bond IDs in the `connected` table where `atom_id2` matches the atom ID 2 from the previous step.\n3. The result will give us the bond IDs that have the same atom ID 2 as TR000_2.",
        "sql": "SELECT DISTINCT c1.bond_id\nFROM connected c1\nJOIN connected c2 ON c1.atom_id2 = c2.atom_id2\nWHERE c2.atom_id = 'TR000_2' OR c2.atom_id2 = 'TR000_2';",
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "evidence": [
            "TR000_2 is the atom id; atom ID 2 refers to atom_id2"
        ]
    },
    "88": {
        "reason": "To solve the question, we need to find the school with the highest number of test takers who received SAT scores of at least 1500 (NumGE1500) and then retrieve the administrator's email address for that school. Here's the step-by-step reasoning:\n\n1. Identify the school with the highest `NumGE1500` from the `satscores` table.\n2. Use the `CDSCode` of this school to join with the `schools` table to get the administrator's email address (`AdmEmail1`).\n3. Also, retrieve the school name (`sname` from `satscores` or `School` from `schools`).\n\nThe query will involve:\n- Selecting the school with the maximum `NumGE1500`.\n- Joining the `satscores` table with the `schools` table on `CDSCode`.\n- Retrieving the administrator's email and the school name.",
        "sql": "SELECT s.AdmEmail1, sc.sname\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);",
        "question": "What is the administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500?Provide the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.AdmEmail1, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "evidence": [
            ""
        ]
    },
    "1123": {
        "reason": "To find the players with the highest potential, we need to query the `Player_Attributes` table, which contains the `potential` attribute for each player. The steps are as follows:\n1. Identify the maximum potential value in the `Player_Attributes` table.\n2. Retrieve all players who have this maximum potential value.\n3. Join the `Player` table to get the names of these players.",
        "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes);",
        "question": "What is the name of players with the highest potential?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.potential DESC LIMIT 1",
        "evidence": [
            "highest potential refers to MAX(potential)"
        ]
    },
    "1190": {
        "reason": "To solve the question, we need to calculate the percentage of patients with proteinuria levels (`U-PRO`) within the normal range (0 < `U-PRO` < 30) who also have uric acid levels (UA) below the normal range (UA <= 6.5). The steps are as follows:\n1. Count the total number of patients with `U-PRO` within the normal range.\n2. Count the number of patients within this group who also have UA <= 6.5.\n3. Calculate the percentage by dividing the count from step 2 by the count from step 1 and multiplying by 100.\n4. Use aggregate functions directly on the filtered dataset for efficiency, as suggested in the tips.",
        "sql": "SELECT (COUNT(CASE WHEN UA <= 6.5 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM Laboratory\nWHERE `U-PRO` > 0 AND `U-PRO` < 30;",
        "error": "something went wrong, tool did not call.",
        "question": "What percentage of patients with a proteinuria level within the normal range have a uric acid level below the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Laboratory WHERE `U-PRO` > 0 AND `U-PRO` < 30",
        "evidence": [
            "proteinuria level within the normal range refers to `U-PRO` > 0 AND `U-PRO` < 30; uric acid level below the normal range refers to UA < = 6.5; calculation = MULTIPLY(DIVIDE(UA < = 6.5, `U-PRO` > 0 AND `U-PRO` < 30)\uff0c100)",
            "The `U-PRO` column in the Laboratory table represents proteinuria levels, with normal range defined as values between 0 and 30.\nThe UA column in the Laboratory table represents uric acid levels, with values <= 6.5 considered below the normal range.\nTo calculate percentages, use aggregate functions directly on the filtered dataset without subqueries for efficiency.",
            "The `U-PRO` column in the Laboratory table represents proteinuria levels, with normal range defined as values between 0 and 30.\nThe UA column in the Laboratory table represents uric acid levels, with values <= 6.5 considered below the normal range.\nTo calculate percentages, use aggregate functions directly on the filtered dataset without subqueries for efficiency."
        ]
    },
    "36": {
        "reason": "To solve the question, we need to find the school with the highest number of students scoring 1500 or more on the SAT (NumGE1500) and then retrieve the full names of its administrators. The steps are as follows:\n1. Identify the school with the highest NumGE1500 from the satscores table.\n2. Join the satscores table with the schools table using the CDSCode and cds fields to link the data.\n3. Retrieve the full names of the administrators (AdmFName1, AdmLName1, AdmFName2, AdmLName2, AdmFName3, AdmLName3) from the schools table for the identified school.\n4. The query will sort the satscores table by NumGE1500 in descending order and limit the result to the top row to get the school with the highest number of students scoring 1500 or more.",
        "sql": "SELECT \n    s.AdmFName1 || ' ' || s.AdmLName1 AS Administrator1,\n    s.AdmFName2 || ' ' || s.AdmLName2 AS Administrator2,\n    s.AdmFName3 || ' ' || s.AdmLName3 AS Administrator3\nFROM \n    satscores sc\nJOIN \n    schools s ON sc.cds = s.CDSCode\nORDER BY \n    sc.NumGE1500 DESC\nLIMIT 1;",
        "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "evidence": [
            "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500",
            "The highest number of students scoring 1500 or more on the SAT is determined by sorting the satscores table by NumGE1500 in descending order.\nTo retrieve administrator details, the satscores table must be joined with the schools table using the CDSCode and cds fields.\nFull names of administrators are stored as separate first and last name fields in the schools table.",
            "The highest number of students scoring 1500 or more on the SAT is determined by the maximum value in the NumGE1500 column of the satscores table.\nAdministrator details are stored in separate fields for first and last names in the schools table, requiring no concatenation for retrieval.\nThe join between satscores and schools uses the CDSCode and cds fields to link the tables.",
            "The highest number of students scoring 1500 or more on the SAT is determined by the maximum value in the NumGE1500 column of the satscores table.\nAdministrator details are stored in separate fields for first and last names in the schools table, requiring no concatenation for retrieval.\nThe join between satscores and schools uses the CDSCode and cds fields to link the tables."
        ]
    },
    "1144": {
        "reason": "To solve the question, we need to find the player with the heaviest weight from the `Player` table, and then retrieve their finishing rate (`finishing`) and curve score (`curve`) from the `Player_Attributes` table. The steps are as follows:\n1. Identify the player with the maximum weight in the `Player` table.\n2. Use the `player_api_id` of this player to fetch their attributes from the `Player_Attributes` table.\n3. Retrieve the `finishing` and `curve` attributes for this player.",
        "sql": "SELECT p.player_name, pa.finishing AS finishing_rate, pa.curve AS curve_score\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.weight = (SELECT MAX(weight) FROM Player)\nLIMIT 1;",
        "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
        "evidence": [
            "finishing rate refer to finishing; curve score refer to curve; heaviest weight refers to MAX(weight)",
            "To retrieve attributes for a single player, use a subquery to first identify the player and then fetch their attributes. The `LIMIT 1` clause ensures only the top result is returned.",
            "To fetch attributes for a single player, use a subquery with `ORDER BY` and `LIMIT` to identify the target player first, then retrieve their attributes.",
            "To retrieve specific attributes for a single player, use a subquery with `ORDER BY` and `LIMIT` to identify the target player first, then fetch their attributes directly from the relevant table."
        ]
    },
    "1152": {
        "reason": "To solve the question, we need to calculate the ratio of outpatient to inpatient follow-up treatments among all patients diagnosed with 'SLE'. The steps are as follows:\n1. Identify all patients with Diagnosis = 'SLE' in the Patient table.\n2. For these patients, count the number of inpatients (Admission = '+') and outpatients (Admission = '-').\n3. Calculate the ratio of outpatients to inpatients by dividing the count of outpatients by the count of inpatients.\n4. Use floating-point division (1.0) to ensure the result is accurate.\n5. The query will use CASE statements within SUM to count admissions conditionally for efficiency.",
        "sql": "SELECT \n    SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) * 1.0 / \n    SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS outpatient_to_inpatient_ratio\nFROM \n    Patient\nWHERE \n    Diagnosis = 'SLE';",
        "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
        "evidence": [
            "'SLE' diagnosed patient means Diagnosis = 'SLE'; inpatient refers to Admission = '+'; outpatient refers to Admission = '-'; calculation =  DIVIDE(COUNT(ID) where Diagnosis = 'SLE' and Admission = '+', COUNT(ID) where Diagnosis = 'SLE' and Admission = '-')",
            "The ratio calculation requires summing conditional counts directly rather than using subqueries for each group.\nUse CASE statements within SUM to count admissions conditionally for a single pass over the data.",
            "The ratio calculation should divide the count of inpatients by the count of outpatients, not the reverse.\nUse floating-point division (1.0) to ensure accurate ratio results.",
            "The ratio calculation should divide the count of inpatients by the count of outpatients, not the reverse.\nUse floating-point division (1.0) to ensure accurate ratio results."
        ]
    },
    "669": {
        "reason": "To determine when 'chl' cast its first vote in a post, we need to follow these steps:\n1. Identify the user 'chl' in the `users` table by matching the `DisplayName` field.\n2. Retrieve the `Id` of the user 'chl' from the `users` table.\n3. Use this `Id` to find all votes cast by 'chl' in the `votes` table.\n4. From these votes, find the earliest (minimum) `CreationDate` to determine the first vote.\n\nThe query will join the `users` and `votes` tables to achieve this.",
        "sql": "SELECT MIN(v.CreationDate) AS FirstVoteDate\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE u.DisplayName = 'chl';",
        "question": "When did 'chl' cast its first vote in a post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.CreationDate FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl' ORDER BY T2.CreationDate LIMIT 1",
        "evidence": [
            "DisplayName = 'chl'; cast its first vote refers to MIN(CreationDate);"
        ]
    },
    "802": {
        "reason": "To find the tallest superhero, we need to identify the superhero with the maximum height in centimeters (`height_cm`). The `superhero` table contains the `height_cm` column, and we can use the `ORDER BY` clause to sort the superheroes by their height in descending order. By limiting the result to the first record, we can retrieve the tallest superhero. The `superhero_name` column will give us the name of the superhero.",
        "sql": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;",
        "question": "Who is the tallest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "evidence": [
            "who refers to superhero_name; tallest superhero refers to MAX(height_cm);",
            "To retrieve the top record by a specific column value, use ORDER BY with DESC and LIMIT 1 instead of a subquery with MAX."
        ]
    },
    "1482": {
        "reason": "1. Join `customers` and `yearmonth` tables on `CustomerID` to link segments with consumption data. 2. Filter records by year prefixes (2012, 2013) and `Currency` = 'EUR'. 3. Group results by `Segment` (SME, LAM, KAM). 4. Calculate percentage increase for each segment using the formula: ((2013 consumption - 2012 consumption) / 2012 consumption) * 100.",
        "sql": "",
        "error": "something went wrong, tool did not call.",
        "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
        "evidence": [
            "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
            "The `yearmonth` table tracks consumption by customer and date, where the `Date` field can be filtered by year prefix. The `customers` table links to `yearmonth` via `CustomerID` and includes the `Segment` field for grouping.",
            "The `Currency` field in the `customers` table must be filtered to include only records where `Currency` is 'EUR' to ensure the analysis is specific to EUR payments.",
            "The `yearmonth` table's `Date` field can be filtered by year prefix to isolate data for specific years. The `customers` table's `Segment` field is used to group results by SME, LAM, and KAM segments. The percentage increase calculation requires comparing consumption values between two years for each segment."
        ]
    },
    "966": {
        "reason": "To determine how many drivers participated in race ID number 18, we need to count the number of unique drivers recorded in the `driverStandings` table for that specific race. The `driverStandings` table is appropriate for this query as it directly tracks driver participation and standings per race. We will filter the records where `raceId` equals 18 and count the distinct `driverId` values.",
        "sql": "SELECT COUNT(DISTINCT driverId) AS participant_count FROM driverStandings WHERE raceId = 18;",
        "question": "How many driver participated in race ID number 18?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18",
        "evidence": [
            "",
            "The `driverStandings` table tracks driver participation and standings per race, while the `results` table records detailed race outcomes. For counting participants, `driverStandings` is more appropriate as it directly reflects race entries."
        ]
    },
    "651": {
        "reason": "To find the related post title of \"How to tell if something happened in a data set which monitors a value over time\", we need to follow these steps:\n1. Identify the `PostId` of the post with the given title from the `posts` table.\n2. Use the `postLinks` table to find the `RelatedPostId` linked to this `PostId`.\n3. Retrieve the title of the related post from the `posts` table using the `RelatedPostId`.\n\nThe query will involve joining the `posts` table with the `postLinks` table to fetch the required information.",
        "sql": "SELECT p2.Title AS RelatedPostTitle\nFROM posts p1\nJOIN postLinks pl ON p1.Id = pl.PostId\nJOIN posts p2 ON pl.RelatedPostId = p2.Id\nWHERE p1.Title = 'How to tell if something happened in a data set which monitors a value over time';",
        "question": "Provide the related post title of \"How to tell if something happened in a data set which monitors a value over time\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Title FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN posts AS T3 ON T1.RelatedPostId = T3.Id WHERE T2.Title = 'How to tell if something happened in a data set which monitors a value over time'",
        "evidence": [
            ""
        ]
    },
    "427": {
        "reason": "To find the languages available in the set known as Archenemy with the code ARC, we need to query the `set_translations` table. This table contains the `language` field, which lists the languages for each set. The `setCode` field in `set_translations` references the `code` field in the `sets` table. We will join these tables to filter for the set with the code 'ARC' and retrieve the distinct languages available for this set.",
        "sql": "SELECT DISTINCT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.code = 'ARC';",
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "evidence": [
            "known as Archenemy refers to mcmName = 'Archenemy'; having the code ARC refers to setCode = 'ARC'"
        ]
    },
    "1067": {
        "reason": "To solve the question, we need to identify teams with a build-up play passing attribute greater than 70 and list their short names. The relevant tables are `Team` and `Team_Attributes`. The `Team_Attributes` table contains the `buildUpPlayPassing` attribute, and the `Team` table contains the `team_short_name` field. We will join these tables on the `team_api_id` to match the team attributes with their respective short names.",
        "sql": "SELECT t.team_short_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE ta.buildUpPlayPassing > 70;",
        "question": "Which teams have build up play passing more than 70? Please list their short names.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayPassing > 70",
        "evidence": [
            "build up play passing refers to buildUpPlayPassing; buildUpPlayPassing > 70; short names refers to team_short_name;"
        ]
    },
    "336": {
        "reason": "To solve the question, we need to find the number of molecules with triple bonds that are not carcinogenic. The steps are as follows:\n1. Identify molecules with triple bonds by checking the `bond` table where `bond_type` is '#'.\n2. Join the `bond` table with the `molecule` table to get the `label` of these molecules.\n3. Filter the results to include only molecules where the `label` is '-', indicating they are non-carcinogenic.\n4. Count the distinct `molecule_id` values from the filtered results to get the number of such molecules.",
        "sql": "SELECT COUNT(DISTINCT b.molecule_id) \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.bond_type = '#' AND m.label = '-';",
        "question": "in molecules with triple bonds, how many of them are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND T1.label = '-'",
        "evidence": [
            "triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "310": {
        "reason": "To solve the question, we need to find the number of molecules that have a double bond type (`bond_type = '='`) and, among these molecules, how many are labeled as carcinogenic (`label = '+'`). Here's the step-by-step reasoning:\n\n1. **Identify molecules with double bonds**: We need to join the `bond` table with the `molecule` table on `molecule_id` and filter for `bond_type = '='`.\n2. **Count distinct molecules with double bonds**: This gives the total number of molecules that have at least one double bond.\n3. **Identify carcinogenic molecules among these**: From the result of step 1, filter for `label = '+'` in the `molecule` table.\n4. **Count distinct carcinogenic molecules**: This gives the number of molecules that are both carcinogenic and have at least one double bond.\n\nThe query will use `COUNT(DISTINCT molecule_id)` to ensure each molecule is counted only once, even if it has multiple double bonds.",
        "sql": "SELECT \n    COUNT(DISTINCT b.molecule_id) AS total_molecules_with_double_bonds,\n    COUNT(DISTINCT CASE WHEN m.label = '+' THEN b.molecule_id END) AS carcinogenic_molecules_with_double_bonds\nFROM \n    bond b\nJOIN \n    molecule m ON b.molecule_id = m.molecule_id\nWHERE \n    b.bond_type = '=';",
        "question": "How many molecules have a double bond type and among these molecule, how many are labeled as carcinogenic compound?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id), SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '='",
        "evidence": [
            "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic;",
            "The `bond` table contains bond types, and filtering for `bond_type = '='` identifies double bonds. The `molecule` table holds labels, where `label = '+'` indicates carcinogenic compounds. Joining these tables directly on `molecule_id` links bonds to their respective molecules.",
            "The `bond` table must be joined with the `molecule` table to link bond types to molecule labels. Filtering for `bond_type = '='` identifies double bonds, and `label = '+'` marks carcinogenic compounds. Aggregating counts directly in the main query avoids unnecessary subqueries.",
            "The `SUM(CASE WHEN ... THEN 1 ELSE 0 END)` pattern is used to count rows meeting a condition, while `COUNT(DISTINCT CASE WHEN ... THEN ... END)` counts distinct values meeting the condition.\nTo count molecules with a specific label, use `SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT CASE WHEN ... THEN ... END)`."
        ]
    },
    "398": {
        "reason": "To solve the question, we need to find the total unconverted mana cost of all cards created by the artist 'Rob Alexander'. The `manaCost` column in the `cards` table stores textual representations of mana costs, which cannot be directly summed. However, the `convertedManaCost` column provides a numerical value representing the total mana cost of each card. Therefore, we can sum the `convertedManaCost` values for all cards where the `artist` is 'Rob Alexander'.",
        "sql": "SELECT SUM(convertedManaCost) AS total_unconverted_mana_cost FROM cards WHERE artist = 'Rob Alexander';",
        "question": "What is the  unconverted mana do all the cards created by Rob Alexander cost in total?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
        "evidence": [
            "unconverted mana refer to manaCost; Rob Alexander refer to artist",
            "The `manaCost` column stores textual representations of mana costs, not numerical values, so aggregation functions like SUM cannot be directly applied.",
            "The `manaCost` column in the `cards` table contains textual representations of mana costs, which cannot be directly aggregated or converted to numerical values for summation.",
            "The `manaCost` column in the `cards` table stores textual representations of mana costs, which cannot be aggregated numerically but can be retrieved as-is for display or further processing."
        ]
    },
    "136": {
        "reason": "To solve the question, we need to find the number of loans per account that meet the following criteria:\n1. The loan amount is at least 250,000.\n2. The loan was issued between 1/1/1995 and 12/31/1997.\n3. The account associated with the loan has a monthly statement issuance (frequency = 'POPLATEK MESICNE').\n\nWe will follow these steps:\n1. Join the `loan` table with the `account` table to filter accounts with monthly issuance.\n2. Filter loans based on the amount (>= 250,000) and date range (between 1/1/1995 and 12/31/1997).\n3. Group the results by `account_id` to count the number of loans per account.\n4. Count the distinct accounts that meet the criteria.",
        "sql": "SELECT COUNT(DISTINCT l.account_id) AS number_of_accounts\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nWHERE l.amount >= 250000\nAND l.date BETWEEN '1995-01-01' AND '1997-12-31'\nAND a.frequency = 'POPLATEK MESICNE';",
        "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
        "evidence": [
            "Frequency = 'POPLATEK MESICNE' stands for monthly issurance",
            "The `status` column in the `loan` table is not required for filtering approved loans in this context.\nCounting loans per account involves aggregating by `account_id` to ensure accurate grouping.",
            "The query requires counting distinct accounts meeting the criteria, not loans per account.\nFiltering by loan amount and date must be applied to the `loan` table.\nThe `account` table is used to filter by frequency."
        ]
    },
    "434": {
        "reason": "To solve the question, we need to find the number of sets that are available only in Japanese and not in Magic: The Gathering Online (MTGO). This involves the following steps:\n1. Identify sets that are available in Japanese by checking the `set_translations` table where the language is 'Japanese'.\n2. Exclude sets that are available in MTGO by checking the `sets` table where `mtgoCode` is not null (since MTGO sets have an `mtgoCode`).\n3. Count the distinct sets that meet both criteria.",
        "sql": "SELECT COUNT(DISTINCT s.code) \nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Japanese'\nAND s.mtgoCode IS NULL;",
        "question": "How many sets are available just in Japanese and not in Magic: The Gathering Online?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.language = 'Japanese'  AND (T1.mtgoCode IS NULL OR T1.mtgoCode = '')",
        "evidence": [
            "Japanese refers to language = 'Japanese'; not in Magic: The Gathering Online refers to mtgoCode is null or mtgoCode = ''"
        ]
    },
    "1502": {
        "reason": "To solve the question, we need to identify the chains of gas stations where transactions were made in euros. The steps are as follows:\n1. Identify transactions where the currency is 'EUR' (euro). This information is in the `customers` table under the `Currency` column.\n2. Join the `transactions_1k` table with the `customers` table to filter transactions in euros.\n3. Join the result with the `gasstations` table to get the `ChainID` of the gas stations involved in these transactions.\n4. Group the results by `ChainID` to list the unique chains.",
        "sql": "SELECT DISTINCT g.ChainID\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE c.Currency = 'EUR';",
        "question": "Please list the chains of the gas stations with transactions in euro.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.ChainID FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN gasstations AS T3 ON T1.GasStationID = T3.GasStationID WHERE T2.Currency = 'EUR'",
        "evidence": [
            ""
        ]
    },
    "1437": {
        "reason": "To solve the question, we need to identify members who were approved for expenses between 1/10/2019 and 11/19/2019. The steps are as follows:\n1. Filter the `expense` table for records where `approved` is 'true' and `expense_date` falls between '2019-01-10' and '2019-11-19'.\n2. Join the filtered `expense` table with the `member` table to get member details.\n3. Join the result with the `attendance` table to find the events these members attended.\n4. Finally, select the `link_to_member` (member ID) and `link_to_event` (event ID) from the joined tables to identify the member-event pairs.",
        "sql": "SELECT DISTINCT a.link_to_member, a.link_to_event\nFROM attendance a\nJOIN member m ON a.link_to_member = m.member_id\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.approved = 'true' AND e.expense_date BETWEEN '2019-01-10' AND '2019-11-19';",
        "question": "Which members who were approved from 1/10/2019 to 11/19/2019? Please identify the member who attended the event and the link to their event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.link_to_member, T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true'",
        "evidence": [
            "approved from 1/10/2019 to 11/19/2019 refers to approved = 'true' and expense_date BETWEEN '2019-01-10' and '2019-11-19'",
            "The `expense_date` field may require date formatting to ensure accurate comparison, as it might store dates in a non-standard format.\nThe query should use `DISTINCT` to avoid duplicate member-event pairs when joining tables.\nThe target output focuses on member and event links, not detailed member or event attributes."
        ]
    },
    "1319": {
        "reason": "To find out which college the vice president of the Student Club is from, we need to follow these steps:\n1. Identify the member who holds the position of 'Vice President' in the `member` table.\n2. Retrieve the `link_to_major` for this member, which links to the `major` table.\n3. From the `major` table, retrieve the `college` associated with the major of the vice president.\n4. Combine these steps in a query to get the desired result.",
        "sql": "SELECT m.college\nFROM member AS mem\nJOIN major AS m ON mem.link_to_major = m.major_id\nWHERE mem.position = 'Vice President';",
        "question": "Which college is the vice president of the Student_Club from?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position LIKE 'vice president'",
        "evidence": [
            "Vice President is a position of the Student Club"
        ]
    },
    "1062": {
        "reason": "To solve the question, we need to find players who had an overall rating of over 80 between the years 2008 and 2010. The steps are as follows:\n1. Identify the relevant tables: `Player_Attributes` for the ratings and dates, and `Player` for the player names.\n2. Filter the `Player_Attributes` table for records where `overall_rating` is greater than 80 and the `date` falls between 2008 and 2010.\n3. Join the filtered `Player_Attributes` table with the `Player` table to get the player names.\n4. Ensure distinct player names are returned to avoid duplicates if a player had multiple ratings over 80 in the specified period.",
        "sql": "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating > 80\nAND pa.date BETWEEN '2008-01-01' AND '2010-12-31';\n",
        "question": "Which players had an overall rating of over 80 from 2008 to 2010? Please list player names.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating > 80 AND SUBSTR(t2.`date`, 1, 4) BETWEEN '2008' AND '2010'",
        "evidence": [
            "overall_rating > 80; from 2008 to 2010 refers to strftime('%Y', date) BETWEEN '2008' AND '2010';"
        ]
    },
    "571": {
        "reason": "To solve the question, we need to compare the number of posts and votes for user No. 24 (UserId = 24). The steps are as follows:\n1. Count the number of posts where the OwnerUserId is 24.\n2. Count the number of votes where the UserId is 24.\n3. Calculate the ratio of posts to votes by dividing the count of posts by the count of votes.\n4. Ensure we count distinct votes to avoid duplicates.\n\nThe query will join the `posts` and `votes` tables to gather the necessary data.",
        "sql": "SELECT \n    (SELECT COUNT(*) FROM posts WHERE OwnerUserId = 24) AS post_count,\n    (SELECT COUNT(DISTINCT Id) FROM votes WHERE UserId = 24) AS vote_count,\n    CASE \n        WHEN (SELECT COUNT(DISTINCT Id) FROM votes WHERE UserId = 24) = 0 THEN NULL\n        ELSE (SELECT COUNT(*) FROM posts WHERE OwnerUserId = 24) * 1.0 / (SELECT COUNT(DISTINCT Id) FROM votes WHERE UserId = 24)\n    END AS posts_to_votes_ratio;",
        "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
        "evidence": [
            "user no. 24 refers to UserId = OwnerUserId = '24'; times of his/her post than votes = Divide (Count(post.Id), Count(votes.Id))",
            "To compare posts and votes for a user, join the posts and votes tables on OwnerUserId and UserId respectively.\nCount distinct votes to avoid duplicates when calculating the ratio.",
            "To compare posts and votes for a user, join the posts and votes tables on OwnerUserId and UserId respectively.\nCount distinct votes to avoid duplicates when calculating the ratio."
        ]
    },
    "503": {
        "reason": "To find the expansion type for the set containing the card \"Samite Pilgrim\", we need to follow these steps:\n1. First, locate the card \"Samite Pilgrim\" in the `cards` table to get its `setCode`.\n2. Then, use the `setCode` to query the `sets` table to find the `type` of the set.\n\nThe query will involve joining the `cards` table with the `sets` table based on the `setCode`.",
        "sql": "SELECT s.type \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Samite Pilgrim';",
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "evidence": [
            "expansion type refers to type; card \"Samite Pilgrim\" refers to name = 'Samite Pilgrim'"
        ]
    },
    "416": {
        "reason": "To solve the question, we need to find the percentage of cards without power that are in French. Here's the step-by-step reasoning:\n\n1. **Identify cards without power**: These are cards where the `power` field is either `NULL` or `'*'`.\n\n2. **Filter cards with French translations**: We need to join the `cards` table with the `foreign_data` table where the `language` is `'French'`.\n\n3. **Calculate the percentage**:\n   - Count the number of cards without power that have French translations.\n   - Count the total number of cards without power.\n   - Divide the first count by the second count and multiply by 100 to get the percentage.\n\n4. **Use conditional aggregation**:\n   - For the numerator, use `SUM(CASE WHEN foreign_data.language = 'French' THEN 1 ELSE 0 END)`.\n   - For the denominator, use `COUNT(*)` of cards without power.\n\n5. **Ensure accurate division**: Cast the counts to `REAL` to avoid integer division.\n\n6. **Join tables appropriately**: Use an `INNER JOIN` between `cards` and `foreign_data` to ensure only cards with French translations are considered.",
        "sql": "SELECT \n    (SUM(CASE WHEN foreign_data.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards\nINNER JOIN \n    foreign_data ON cards.uuid = foreign_data.uuid\nWHERE \n    cards.power IS NULL OR cards.power = '*';",
        "question": "What percentage of cards without power are in French?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power = '*'",
        "evidence": [
            "in French refers to language = 'French'; cards without power refers to power IS NULL OR power = '*'; percentage = DIVIDE(COUNT(language = 'French' and power is NULL or power = '*'), COUNT( power is NULL or power = '*'))*100",
            "To calculate percentages, use SUM(CASE WHEN condition THEN 1 ELSE 0 END) for conditional counts and CAST to REAL for accurate division.\nEnsure joins are INNER when filtering for specific related records, not LEFT, to exclude unmatched rows.",
            "To filter for specific language records, use INNER JOIN with foreign_data to ensure only cards with matching translations are included.\nFor percentage calculations, ensure the denominator counts only the filtered subset of cards (those without power)."
        ]
    },
    "260": {
        "reason": "To solve the question, we need to calculate the total number of atoms in molecules that have triple bonds and contain either phosphorus ('p') or bromine ('br'). Here's the step-by-step reasoning:\n\n1. **Identify molecules with triple bonds**: We need to find all `molecule_id`s from the `bond` table where `bond_type` is '#' (triple bond).\n2. **Filter atoms in these molecules**: From the `atom` table, we need to find all atoms where the `molecule_id` matches those identified in step 1 and the `element` is either 'p' (phosphorus) or 'br' (bromine).\n3. **Count the atoms**: Finally, we count the number of such atoms.\n\nThe query will involve joining the `bond` and `atom` tables to filter the relevant molecules and atoms, and then counting the results.",
        "sql": "SELECT COUNT(a.atom_id) AS total_atoms\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE b.bond_type = '#' AND (a.element = 'p' OR a.element = 'br');",
        "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
        "evidence": [
            "triple bond refers to bond_type = '#'; phosphorus refers to element = 'p'; bromine refers to element = 'br'"
        ]
    },
    "1085": {
        "reason": "To determine which player performs the best in crossing actions among Alexis, Ariel Borysiuk, and Arouna Kone, we need to:\n1. Identify the player_api_id for each of these players from the Player table.\n2. Retrieve their crossing attribute values from the Player_Attributes table.\n3. Compare the crossing values to determine the highest performer.\n\nThe query will join the Player and Player_Attributes tables to fetch the crossing attribute for each player.",
        "sql": "SELECT p.player_name, pa.crossing\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone')\nORDER BY pa.crossing DESC\nLIMIT 1;",
        "question": "Which of these players performs the best in crossing actions, Alexis, Ariel Borysiuk or Arouna Kone?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name, t2.crossing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY t2.crossing DESC LIMIT 1",
        "evidence": [
            "player who perform best in crossing actions refers to MAX(crossing);"
        ]
    },
    "1479": {
        "reason": "To solve the question, we need to find the year with the highest consumption of gas paid in CZK. Here's the step-by-step reasoning:\n\n1. **Filter by Currency**: First, we need to filter the `customers` table to include only those customers who use CZK as their currency.\n2. **Join Tables**: Join the `yearmonth` table with the filtered `customers` table to get consumption data for customers using CZK.\n3. **Extract Year**: Extract the year component from the `Date` field in the `yearmonth` table.\n4. **Aggregate Consumption**: Sum the `Consumption` values for each year.\n5. **Order and Limit**: Order the results by the summed consumption in descending order and limit the result to the top year.\n\nThe query will involve joining the `customers` and `yearmonth` tables, filtering for CZK currency, grouping by year, and summing the consumption.",
        "sql": "SELECT SUBSTR(y.Date, 1, 4) AS Year, SUM(y.Consumption) AS TotalConsumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Currency = 'CZK'\nGROUP BY Year\nORDER BY TotalConsumption DESC\nLIMIT 1;",
        "question": "Which year recorded the most consumption of gas paid in CZK?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "evidence": [
            "The first 4 strings of the Date values in the yearmonth table can represent year.",
            "The `yearmonth` table tracks consumption data linked to customers, and the `customers` table specifies the currency used for transactions.\nTo aggregate consumption by year, the `Date` field in `yearmonth` must be grouped by its year component.\nThe highest consumption is determined by summing the `Consumption` values and ordering the results in descending order.",
            "The `yearmonth` table's `Date` field can be grouped by its year component to aggregate consumption data by year.\nThe `customers` table's `Currency` field is used to filter transactions by currency type.\nThe highest consumption is determined by summing the `Consumption` values and ordering the results in descending order.",
            "The `yearmonth` table's `Date` field must be grouped by its year component to aggregate consumption data by year.\nThe `customers` table's `Currency` field is used to filter transactions by currency type.\nThe highest consumption is determined by summing the `Consumption` values and ordering the results in descending order."
        ]
    },
    "53": {
        "reason": "To solve the question, we need to find the number of test takers at schools whose mailing city address is in Fresno. The steps are as follows:\n1. Identify the schools with a mailing city of 'Fresno' from the `schools` table.\n2. Use the `CDSCode` of these schools to join with the `satscores` table to retrieve the number of test takers (`NumTstTakr`) for each school.\n3. Sum the number of test takers across all identified schools to get the total count.",
        "sql": "SELECT SUM(s.NumTstTakr) AS TotalTestTakers\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE sc.MailCity = 'Fresno';",
        "question": "How many test takers are there at the school/s whose mailing city address is in Fresno?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'",
        "evidence": [
            "",
            "The `satscores` table contains individual school records with test taker counts, not aggregated sums.\nTo retrieve specific school data, avoid aggregation unless explicitly required.",
            "The `satscores` table provides individual school test taker counts, and the query should return these counts without aggregation unless specified otherwise.",
            "The query should return individual school test taker counts without aggregation unless explicitly required."
        ]
    },
    "478": {
        "reason": "To find card number 4 in the set Coldsnap, we need to:\n1. Identify the set code for Coldsnap from the `sets` table.\n2. Join the `cards` table with the `sets` table using the `setCode` field in `cards` and the `code` field in `sets`.\n3. Filter the results to only include cards where the `number` field is '4' (as a string, per the schema) and the set name is 'Coldsnap'.\n4. Select the card's name from the `cards` table.",
        "sql": "SELECT c.name \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.number = '4' AND s.name = 'Coldsnap';",
        "question": "What is card number 4 in the set Coldsnap?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.number = 4",
        "evidence": [
            "card set Coldsnap refers to name = 'Coldsnap'; card number 4 refers to number = 4",
            "The `setCode` field in the `cards` table links to the `code` field in the `sets` table, not directly to the set name.\nTo filter by set name, join the `cards` table with the `sets` table using `setCode` and `code`.\nThe `number` field in the `cards` table should be compared as an integer, not a string.",
            "The `number` field in the `cards` table should be compared as an integer, not a string, to ensure accurate filtering.\nTo retrieve specific card details, explicitly select the desired fields (e.g., `name`) rather than using a wildcard.",
            "The `number` field in the `cards` table should be compared directly as a string, not cast to an integer, to match the schema's data type.\nTo retrieve only the card name, explicitly select the `name` field from the `cards` table, avoiding unnecessary columns."
        ]
    },
    "767": {
        "reason": "To find the average of superheroes with no skin colour, we need to follow these steps:\n1. Identify the condition for \"no skin colour\" which is `skin_colour_id = 1` (as per the tip provided).\n2. Count the total number of superheroes in the `superhero` table.\n3. Count the number of superheroes where `skin_colour_id = 1`.\n4. Calculate the average by dividing the total count of superheroes by the count of superheroes with no skin colour.\n5. The query will involve joining the `superhero` table with the `colour` table to ensure the condition is correctly applied.",
        "sql": "SELECT COUNT(*) * 1.0 / SUM(CASE WHEN skin_colour_id = 1 THEN 1 ELSE 0 END) AS average_no_skin_colour\nFROM superhero;",
        "question": "What is the average of superheroes with no skin colour?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id",
        "evidence": [
            "average = DIVIDE(COUNT(superhero.id), SUM(skin_colour_id = 1)); no skin colour refers to skin_colour_id WHERE colour.id = 1;"
        ]
    },
    "583": {
        "reason": "To solve the question, we need to find the total score of posts edited by a user with the display name \"Yevgeny\" and include the user's website URL. Here's the step-by-step reasoning:\n\n1. **Identify the user**: First, we need to find the user with the display name \"Yevgeny\" in the `users` table to get their `Id` and `WebsiteUrl`.\n2. **Find edited posts**: Using the `posts` table, we need to find all posts where the `LastEditorUserId` matches the `Id` of the user \"Yevgeny\".\n3. **Calculate total score**: Sum the `Score` of all these posts to get the total score.\n4. **Include website URL**: Ensure the result includes the `WebsiteUrl` of the user \"Yevgeny\".\n\nCombining these steps, we will join the `users` and `posts` tables, filter for the user \"Yevgeny\", and aggregate the scores of their edited posts.",
        "sql": "SELECT SUM(p.Score) AS TotalScore, u.WebsiteUrl\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE u.DisplayName = 'Yevgeny';\n",
        "question": "What is the total score of the posts edited by Yevgeny and include the user's website URL.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.Score), T2.WebsiteUrl FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Yevgeny' GROUP BY T2.WebsiteUrl",
        "evidence": [
            "\"Yevgeny\" is the DisplayName; edited refers to LastEditorUserId"
        ]
    },
    "1448": {
        "reason": "To solve the question, we need to find the name and date of events where expenses for pizza were more than $50 but less than $100. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The question involves `event` (for event details), `expense` (for expense details), and `budget` (to link expenses to events).\n\n2. **Filter expenses for pizza**: The `expense` table has a column `expense_description` where we can filter for entries containing \"pizza\".\n\n3. **Filter cost range**: The `expense` table also has a `cost` column, which we need to filter for values greater than 50 and less than 100.\n\n4. **Link expenses to events**: The `expense` table links to the `budget` table via `link_to_budget`, and the `budget` table links to the `event` table via `link_to_event`. We need to join these tables to get the event details.\n\n5. **Select required fields**: Finally, we need to select the `event_name` and `event_date` from the `event` table for the filtered events.",
        "sql": "SELECT e.event_name, e.event_date\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.expense_description LIKE '%pizza%'\nAND ex.cost > 50\nAND ex.cost < 100;",
        "question": "Find the name and date of events with expenses for pizza that were more than fifty dollars but less than a hundred dollars.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name, T1.event_date FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.expense_description = 'Pizza' AND T3.cost > 50 AND T3.cost < 100",
        "evidence": [
            "name of event refers to event_name; date of event refers to event_date; expenses for pizza refers to expense_description = 'Pizza' where cost > 50 and cost < 100"
        ]
    },
    "1512": {
        "reason": "To find the customer who paid the most on 2012-08-25, we need to:\n1. Filter the transactions_1k table to include only transactions that occurred on 2012-08-25.\n2. Group these transactions by CustomerID.\n3. Sum the Price column for each customer to calculate the total payment.\n4. Order the results by the total payment in descending order.\n5. Limit the result to the top customer to identify the highest-paying customer.\n\nThe query will directly return the CustomerID of the highest-paying customer.",
        "sql": "SELECT CustomerID\nFROM transactions_1k\nWHERE Date = '2012-08-25'\nGROUP BY CustomerID\nORDER BY SUM(Price) DESC\nLIMIT 1;",
        "question": "Which customer paid the most in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "evidence": [
            "'2012/8/25' can be represented by '2012-08-25'",
            "The total payment calculation should use the Price column directly, not the product of Amount and Price.\nGrouping by CustomerID and ordering by the sum of Price identifies the highest-paying customer.",
            "The SELECT clause should directly return the CustomerID without additional columns to match the requirement of identifying the customer.\nThe ORDER BY clause can directly reference the aggregate function SUM(Price) without aliasing it."
        ]
    },
    "502": {
        "reason": "To find the release date for the set \"Ola de fr\u00edo\", we need to understand that \"Ola de fr\u00edo\" is a translation of a set name. The schema includes a table called `set_translations` which links set codes to their translations in different languages. The `sets` table contains the release date for each set, identified by its code. Therefore, the steps are:\n1. Query the `set_translations` table to find the set code where the translation is \"Ola de fr\u00edo\".\n2. Use the set code obtained from the first step to query the `sets` table for the release date of that set.",
        "sql": "SELECT s.releaseDate \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Ola de fr\u00edo';",
        "question": "What is the release date for the set \"Ola de fr\u00edo\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.releaseDate FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Ola de fr\u00edo'",
        "evidence": [
            "release date is the date of card set being released; set \"Ola de fr\u00edo\" refers to translation = 'Ola de fr\u00edo'"
        ]
    },
    "158": {
        "reason": "To find the district ID of the account that placed the order with the ID 33333, we need to follow these steps:\n1. Locate the order with `order_id = 33333` in the `order` table to get the `account_id` associated with this order.\n2. Use the `account_id` to find the corresponding account in the `account` table, which contains the `district_id`.\n3. Retrieve the `district_id` from the `account` table.\n\nThe query will join the `order` and `account` tables to link the order ID to the district ID.",
        "sql": "SELECT a.district_id\nFROM account a\nJOIN `order` o ON a.account_id = o.account_id\nWHERE o.order_id = 33333;",
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "evidence": [
            ""
        ]
    },
    "572": {
        "reason": "To find the number of views for the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer', we need to query the `posts` table. The `posts` table contains the `Title` and `ViewCount` columns, which are relevant to this question. We will filter the posts by the exact title and retrieve the `ViewCount` for that post.",
        "sql": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';",
        "question": "How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'",
        "evidence": [
            "\"Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer\" is the Title of post; views refers to ViewCount"
        ]
    },
    "479": {
        "reason": "To solve the question, we need to find the number of cards in the 'Coldsnap' set with a converted mana cost higher than 5 and an unknown power. The steps are as follows:\n1. Identify the 'Coldsnap' set by its name in the 'sets' table.\n2. Join the 'cards' table with the 'sets' table using the 'setCode' field to filter cards from the 'Coldsnap' set.\n3. Filter cards where the 'convertedManaCost' is greater than 5.\n4. Further filter cards where the 'power' is either '*' or NULL (unknown power).\n5. Count the number of such cards.",
        "sql": "SELECT COUNT(*) \nFROM cards \nJOIN sets ON cards.setCode = sets.code \nWHERE sets.name = 'Coldsnap' \nAND cards.convertedManaCost > 5 \nAND (cards.power = '*' OR cards.power IS NULL);",
        "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
        "evidence": [
            "card set Coldsnap refers to name = 'Coldsnap'; converted mana cost higher than 5 refers to convertedManaCost > 5; unknown power refers to power = '*' or T1.power is null"
        ]
    },
    "724": {
        "reason": "To solve the question, we need to find superheroes with blue eyes and blond hair. This involves querying the `superhero` table and joining it with the `colour` table twice: once for eye colour and once for hair colour. The steps are as follows:\n1. Join the `superhero` table with the `colour` table for eye colour (where `eye_colour_id` matches `colour.id` and `colour.colour` is 'Blue').\n2. Join the `superhero` table again with the `colour` table for hair colour (where `hair_colour_id` matches `colour.id` and `colour.colour` is 'Blond').\n3. Select the `superhero_name` from the filtered results.",
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id AND eye_colour.colour = 'Blue'\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id AND hair_colour.colour = 'Blond';\n",
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "evidence": [
            "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; blond hair refers to colour = 'Blond' and hair_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'"
        ]
    },
    "604": {
        "reason": "To solve the question, we need to find the average up votes and the average age of users who have created more than 10 posts. Here's the step-by-step reasoning:\n\n1. **Identify users with more than 10 posts**: We need to count the number of posts each user has created by grouping the `posts` table by `OwnerUserId` and filtering for users with a count greater than 10.\n\n2. **Calculate average up votes and age**: For these users, we will then calculate the average of the `UpVotes` and `Age` fields from the `users` table.\n\n3. **Join tables**: We will join the `users` table with the filtered list of users from the `posts` table to get the required data.\n\n4. **Aggregate results**: Finally, we will compute the averages for the filtered users.",
        "sql": "SELECT AVG(u.UpVotes) AS average_up_votes, AVG(u.Age) AS average_user_age\nFROM users u\nJOIN (\n    SELECT OwnerUserId, COUNT(*) AS post_count\n    FROM posts\n    GROUP BY OwnerUserId\n    HAVING COUNT(*) > 10\n) p ON u.Id = p.OwnerUserId;",
        "question": "What is the average of the up votes and the average user age for users creating more than 10 posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.UpVotes), AVG(T1.Age) FROM users AS T1 INNER JOIN ( SELECT OwnerUserId, COUNT(*) AS post_count FROM posts GROUP BY OwnerUserId HAVING post_count > 10) AS T2 ON T1.Id = T2.OwnerUserId",
        "evidence": [
            "creating more than 10 post refers to Count (UserId) > 10; average of the up votes = Divide (Sum(UpVotes), Count (UserId)); average age = Divide (Sum(Age), Count(UserId))"
        ]
    },
    "267": {
        "reason": "To solve the question, we need to list the bond types for molecules with IDs ranging from TR000 to TR050. The bond types are stored in the `bond` table, and the molecule IDs are stored in the `molecule` table. Since the `bond` table has a foreign key `molecule_id` referencing the `molecule` table, we can join these two tables to retrieve the bond types for the specified range of molecule IDs. The query will filter the `molecule_id` in the `bond` table to be between TR000 and TR050.",
        "sql": "SELECT b.bond_type FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE m.molecule_id BETWEEN 'TR000' AND 'TR050';",
        "question": "List down the bond type for molecules from molecule id TR000 to TR050.",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'",
        "evidence": [
            "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
            "The `molecule_id` in the `bond` table is a foreign key referencing the `molecule` table, ensuring data integrity. To retrieve bond types for specific molecules, a join between the `molecule` and `bond` tables is necessary.",
            "The `molecule_id` in the `bond` table is a foreign key referencing the `molecule` table, so joining these tables ensures accurate retrieval of bond types for specific molecules. Filtering on the `molecule` table's `molecule_id` guarantees the correct range of molecules is considered.",
            "The `molecule_id` column in the `bond` table is a foreign key referencing the `molecule` table, so joining these tables ensures accurate retrieval of bond types for specific molecules. Filtering on the `molecule` table's `molecule_id` guarantees the correct range of molecules is considered."
        ]
    },
    "621": {
        "reason": "To find the names of badges obtained by users with the lowest reputation, we need to follow these steps:\n1. Identify the users with the lowest reputation from the `users` table.\n2. Join these users with the `badges` table to find the badges they have obtained.\n3. Extract the names of these badges.\n\nThe query will first find the minimum reputation value, then find users with that reputation, and finally join with the `badges` table to get the badge names.",
        "sql": "SELECT DISTINCT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Reputation = (SELECT MIN(Reputation) FROM users);",
        "question": "What are the name of badges that users who have the lowest reputation obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
        "evidence": [
            "lowest reputation refers to Min(Reputation); user refers to UserId"
        ]
    },
    "627": {
        "reason": "To determine how many users are adults, we need to count the number of users in the `users` table where the `Age` falls between 19 and 65, inclusive. The schema defines an adult as a user with an age in this range. The query will involve filtering the `users` table based on the `Age` column and then counting the results.",
        "sql": "SELECT COUNT(*) AS adult_users_count FROM users WHERE Age BETWEEN 19 AND 65;",
        "question": "How many users were adult?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "evidence": [
            "adult refers to user where Age BETWEEN 19 and 65;"
        ]
    },
    "521": {
        "reason": "To solve the question, we need to find the status of a specific card in the legacy play format. The card must meet the following criteria:\n1. Its frame style version is 1997.\n2. It is illustrated by D. Alexander Gregory.\n3. It has sensitive content or is associated with Wizards of the Coast.\n\nWe will break this down into steps:\n1. Identify cards with frame version '1997' from the `cards` table.\n2. Filter these cards to those illustrated by D. Alexander Gregory (using the `artist` field).\n3. Further filter these cards to those with sensitive content (`hasContentWarning = 1`) or associated with Wizards of the Coast (this might require checking the `flavorText` or other fields, but the schema does not explicitly indicate this, so we will focus on `hasContentWarning`).\n4. Join the filtered cards with the `legalities` table to find their status in the 'legacy' format.\n\nThe query will involve joining the `cards` and `legalities` tables and applying the necessary filters.",
        "sql": "SELECT l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.frameVersion = '1997'\nAND c.artist = 'D. Alexander Gregory'\nAND (c.hasContentWarning = 1 OR c.flavorText LIKE '%Wizards of the Coast%')\nAND l.format = 'legacy';",
        "question": "Among the cards whose version of frame style is 1997, what is the status of the card illustrated by D. Alexander Gregory in legacy play format that has sensitive content or Wizards of the Coast?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.frameVersion = 1997 AND T1.hasContentWarning = 1 AND T1.artist = 'D. Alexander Gregory' AND T2.format = 'legacy'",
        "evidence": [
            "version of frame style is 1997 refers to frameVersion = '1997'; illustrated by D. Alexander Gregory refers to artist = 'D. Alexander Gregory'; sensitive content refers to hasContentWarning = 1; legacy play format refers to format = 'legacy'; status of the card refers to status"
        ]
    },
    "1471": {
        "reason": "To find the ratio of customers who pay in EUR against customers who pay in CZK, we need to:\n1. Count the number of customers who pay in EUR.\n2. Count the number of customers who pay in CZK.\n3. Calculate the ratio by dividing the count of EUR customers by the count of CZK customers.\n\nWe will query the `customers` table to get these counts based on the `Currency` column.",
        "sql": "SELECT \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'EUR') * 1.0 / \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'CZK') AS ratio_EUR_to_CZK;",
        "question": "What is the ratio of customers who pay in EUR against customers who pay in CZK?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) AS ratio FROM customers",
        "evidence": [
            "ratio of customers who pay in EUR against customers who pay in CZK = count(Currency = 'EUR') / count(Currency = 'CZK')."
        ]
    },
    "732": {
        "reason": "To find the publisher that published the slowest superhero, we need to follow these steps:\n1. Identify the attribute related to speed in the `attribute` table. This is likely an attribute named 'Speed' or similar.\n2. Join the `hero_attribute` table with the `attribute` table to filter for the 'Speed' attribute.\n3. Find the superhero with the lowest `attribute_value` for 'Speed'.\n4. Join the `superhero` table with the `publisher` table to get the publisher's name for the identified superhero.\n5. Return the publisher's name.",
        "sql": "SELECT p.publisher_name\nFROM publisher p\nJOIN superhero s ON p.id = s.publisher_id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nORDER BY ha.attribute_value ASC\nLIMIT 1;",
        "question": "Which publisher published the slowest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed' ORDER BY T3.attribute_value LIMIT 1",
        "evidence": [
            "the slowest superhero refers to attribute_name = 'Speed' where MIN(attribute_value); publisher refers to publisher_name"
        ]
    },
    "575": {
        "reason": "To find the badge name that the user 'SilentGhost' obtained, we need to follow these steps:\n1. First, identify the user ID of 'SilentGhost' from the `users` table.\n2. Then, use this user ID to query the `badges` table to find all badges associated with this user.\n3. Finally, retrieve the `Name` column from the `badges` table for the user 'SilentGhost'.",
        "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'SilentGhost';",
        "question": "What is the badge name that user 'SilentGhost' obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'SilentGhost'",
        "evidence": [
            "\"SilentGhost\" is the DisplayName of user;"
        ]
    },
    "1267": {
        "reason": "To solve the question, we need to find the number of patients with normal anti-SM who do not have thrombosis. Here's the step-by-step reasoning:\n\n1. **Identify Normal Anti-SM**: The `SM` attribute in the `Laboratory` table represents anti-SM values. Normal values are indicated by 'negative' or '0'.\n\n2. **Identify No Thrombosis**: The `Thrombosis` attribute in the `Examination` table indicates whether a patient has thrombosis. A value of `0` means no thrombosis.\n\n3. **Join Tables**: We need to join the `Examination` and `Laboratory` tables on the `ID` field to access both `SM` and `Thrombosis` attributes.\n\n4. **Filter Conditions**: Filter the joined data to include only patients with normal anti-SM (`SM` = 'negative' or '0') and no thrombosis (`Thrombosis` = 0).\n\n5. **Count Patients**: Count the distinct `ID` values from the filtered results to get the number of such patients.\n\nThe query will join the tables, apply the filters, and count the distinct patient IDs.",
        "sql": "SELECT COUNT(DISTINCT e.ID) AS Patients_Count\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE (l.SM = 'negative' OR l.SM = '0') AND e.Thrombosis = 0;",
        "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
        "evidence": [
            "normal anti-SM refers to SM IN('-', '+-'); SM = 'negative' means '-'; SM = '0' means '+-'; SM = '1' means '+'; does not have thrombosis refers to Thrombosis = 0;",
            "The SM attribute is located in the Laboratory table, not the Examination table.\nTo filter patients without thrombosis, the Thrombosis attribute in the Examination table must be used.\nJoining the Examination and Laboratory tables is necessary to access both SM and Thrombosis attributes.",
            "The SM attribute in the Laboratory table uses 'negative' and '0' to represent normal anti-SM values, not '-' and '+-'.\nTo count patients, the query should use the Examination table as the primary table for joining to ensure all relevant records are included.",
            "The SM attribute in the Laboratory table uses 'negative' and '0' to represent normal anti-SM values.\nTo count patients, the query should use the Examination table as the primary table for joining to ensure all relevant records are included.\nThe join condition should ensure both tables are linked by the ID field."
        ]
    },
    "797": {
        "reason": "To find superheroes with blue eyes and brown hair, we need to:\n1. Identify the `colour` IDs for 'Blue' (eyes) and 'Brown' (hair).\n2. Join the `superhero` table with the `colour` table twice: once for eye colour and once for hair colour.\n3. Filter the results where the eye colour is 'Blue' and the hair colour is 'Brown'.\n4. Return the `superhero_name` of the matching superheroes.",
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id\nWHERE eye_colour.colour = 'Blue' AND hair_colour.colour = 'Brown';",
        "question": "Which superheroes have blue eyes with brown hair?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'",
        "evidence": [
            "which superheroes refers to superhero_name; blue eyes refers to color = 'Blue' and color.id = eye_colour_id; brown hair refers to color = 'Brown' and color.id = hair_colour_id;"
        ]
    },
    "666": {
        "reason": "To solve the question, we need to find the most valuable post among those voted by user 1465. The value of a post can be determined by its score, which is stored in the `posts` table. The `votes` table records the votes cast by users, including user 1465. We will join the `votes` and `posts` tables to find the posts voted by user 1465 and then identify the one with the highest score.",
        "sql": "SELECT p.Id \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE v.UserId = 1465 \nORDER BY p.Score DESC \nLIMIT 1;",
        "question": "Among the posts that were voted by user 1465, what is the id of the most valuable post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Id FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 1465 ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "evidence": [
            "user 1465 refers to UserId = 1465; the most valuable post refers to MAX(FavoriteCount);"
        ]
    },
    "84": {
        "reason": "To solve the question, we need to identify the two most common first names among school administrators and the districts they administer. The steps are as follows:\n1. Focus on the `AdmFName1` column in the `schools` table, as it is the primary source of administrator first names.\n2. Count the occurrences of each first name in `AdmFName1` to determine the most common names.\n3. Limit the results to the top two most common names.\n4. For these two names, retrieve the associated districts from the `District` column in the `schools` table.\n5. Ensure distinct results to avoid duplicates when combining names with districts.",
        "sql": "WITH CommonNames AS (\n    SELECT AdmFName1, COUNT(*) AS NameCount\n    FROM schools\n    WHERE AdmFName1 IS NOT NULL\n    GROUP BY AdmFName1\n    ORDER BY NameCount DESC\n    LIMIT 2\n)\nSELECT DISTINCT s.AdmFName1, s.District\nFROM schools s\nJOIN CommonNames cn ON s.AdmFName1 = cn.AdmFName1\nORDER BY cn.NameCount DESC;",
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "evidence": [
            "",
            "The `AdmFName1` column in the `schools` table is the primary field for administrator first names, while `AdmFName2` and `AdmFName3` are secondary fields.\nTo identify the most common first names, focus on `AdmFName1` as it is the primary source of administrator names.\nThe `District` column in the `schools` table provides the district information for each administrator.",
            "The `AdmFName1` column should be analyzed separately to identify the most common names before joining with district information.\nTo ensure distinct results, use `DISTINCT` when combining names with districts to avoid duplicates.\nA subquery can efficiently isolate the top names before associating them with districts."
        ]
    },
    "357": {
        "reason": "To find the promotion type of the card 'Duress', we need to query the `cards` table. The `promoTypes` column in this table contains the promotion types for each card. Since the question specifies the card name 'Duress', we will filter the `cards` table for rows where the `name` column equals 'Duress' and then select the `promoTypes` column. Additionally, we should ensure that the `promoTypes` column is not NULL to get valid promotion types.",
        "sql": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL;",
        "question": "What type of promotion is of card 'Duress'?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL",
        "evidence": [
            "card Duress refers to name = 'Duress'; type of promotion refers to promoTypes;",
            "The `promoTypes` column in the `cards` table may contain NULL values; filtering for non-NULL values ensures only valid promotion types are returned."
        ]
    },
    "1191": {
        "reason": "To solve the question, we need to calculate the percentage of male patients who first presented to the hospital in 1981 and were diagnosed with BEHCET. The steps are as follows:\n1. Identify male patients (SEX = 'M') who first presented in 1981 (YEAR(`First Date`) = '1981').\n2. From this subset, count how many were diagnosed with BEHCET (Diagnosis = 'BEHCET').\n3. Calculate the total number of male patients who first presented in 1981.\n4. Divide the count from step 2 by the total from step 3 and multiply by 100 to get the percentage.\n\nThe query will involve joining the `Patient` table with itself to filter the required conditions and then performing the calculations.",
        "sql": "SELECT \n    (SUM(CASE WHEN p.Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient p\nWHERE \n    p.SEX = 'M' AND \n    strftime('%Y', p.`First Date`) = '1981';",
        "question": "What percentage of male patients who first presented to the hospital in 1981 were diagnosed with BEHCET?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE STRFTIME('%Y', `First Date`) = '1981' AND SEX = 'M'",
        "evidence": [
            "male refers to SEX = 'M'; first presented to the hospital in 1981 refers to YEAR(`FIRST DATE`) = '1981'; BEHCET refers to diagnosis; calculation = DIVIDE(SUM(DIAGNOSIS = 'BEHCET') where YEAR(`FIRST DATE`) = '1981', MULTIPLY(COUNT(YEAR(`FIRST DATE`) = '1981')), 100)"
        ]
    },
    "1043": {
        "reason": "To find the short name of the football team Queens Park Rangers, we need to query the `Team` table where the `team_long_name` is 'Queens Park Rangers'. The `team_short_name` column in the `Team` table will give us the desired short name.",
        "sql": "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers';",
        "question": "What is the short name of the football team Queens Park Rangers?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers'",
        "evidence": [
            "short name of the football team refers to team_short_name; Queens Park Rangers refers to team_long_name = 'Queens Park Rangers';"
        ]
    },
    "1406": {
        "reason": "To find the budget with the highest amount in the 'Food' category, we need to query the `budget` table. The steps are as follows:\n1. Filter the budgets where the `category` is 'Food'.\n2. Use the `MAX(amount)` function to find the highest budgeted amount in this category.\n3. Retrieve the details of the budget(s) that match this highest amount.\n\nThe query will first find the maximum amount in the 'Food' category and then use this value to filter the budgets.",
        "sql": "SELECT * FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food');",
        "question": "Among the budgets for Food, which one has the highest budgeted amount?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget )",
        "evidence": [
            "MAX(amount) where category = 'Food'",
            "The `MAX(amount)` function should be applied globally across all budgets, not restricted to the 'Food' category, to ensure the highest amount is identified correctly.",
            "The `MAX(amount)` function should be applied globally across all budgets to identify the highest amount, not restricted to the 'Food' category.",
            "The `MAX(amount)` function should be applied globally across all budgets to identify the highest amount, not restricted to the 'Food' category."
        ]
    },
    "727": {
        "reason": "To find the publisher of Sauron, we need to follow these steps:\n1. Identify the superhero record for Sauron in the `superhero` table.\n2. Retrieve the `publisher_id` associated with Sauron's record.\n3. Join the `superhero` table with the `publisher` table to get the publisher's name using the `publisher_id`.\n\nThe query will filter the `superhero` table for the superhero_name 'Sauron' and then join it with the `publisher` table to fetch the publisher's name.",
        "sql": "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Sauron';",
        "question": "Who is the publisher of Sauron?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Sauron'",
        "evidence": [
            "the publisher refers to publisher_name; Sauron refers to superhero_name = 'Sauron'"
        ]
    },
    "476": {
        "reason": "To solve the question, we need to find the names of the cards in the set 'Coldsnap' with the highest converted mana cost. Here's the step-by-step reasoning:\n\n1. **Identify the set 'Coldsnap'**: The `sets` table contains the set information, and we need to filter for the set with the name 'Coldsnap' to get its `code`.\n2. **Join the `cards` table with the `sets` table**: The `cards` table has a `setCode` column that links to the `code` column in the `sets` table. This join will allow us to filter cards belonging to the 'Coldsnap' set.\n3. **Find the highest converted mana cost**: We need to sort the cards in descending order of their `convertedManaCost` and limit the results to the top value(s).\n4. **Retrieve the card names**: Finally, we will select the `name` column from the `cards` table for the cards with the highest `convertedManaCost` in the 'Coldsnap' set.",
        "sql": "SELECT c.name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Coldsnap'\nORDER BY c.convertedManaCost DESC\nLIMIT 1;",
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "evidence": [
            "card set Coldsnap refers to name = 'Coldsnap'",
            "The `setCode` column in the `cards` table directly links to the `code` column in the `sets` table, enabling direct filtering by set name.\nTo find the highest value, sorting in descending order and limiting to the top result is more efficient than calculating the maximum separately.",
            "To retrieve the highest value efficiently, sorting in descending order and limiting to the top result is preferred over subqueries for maximum calculation.\nJoining the `cards` and `sets` tables directly ensures accurate filtering by set name."
        ]
    },
    "681": {
        "reason": "To solve the question, we need to find users whose posts had over 20,000 views in the year 2011. The steps are as follows:\n1. Identify the relevant tables: `users` (for display names) and `posts` (for views and creation dates).\n2. Filter posts from the year 2011 with more than 20,000 views.\n3. Join these posts with the `users` table to get the display names of the users who created these posts.\n4. Ensure the query is structured to return only the display names of these users.",
        "sql": "SELECT DISTINCT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ViewCount > 20000\nAND strftime('%Y', p.CreaionDate) = '2011';",
        "question": "Please list the users' display names whose posts had over 20000 views in 2011.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2011' AND T2.ViewCount > 20000",
        "evidence": [
            "had over 20000 views in 2011 refers to ViewCount > 20000 where YEAR(CreationDate) = 2011;"
        ]
    },
    "1176": {
        "reason": "To find the anti-nucleus antibody (ANA) concentration level for the patient with ID 3605340 on the date 1996/12/2, we need to query the `Examination` table. The `Examination` table contains the `ANA` column, which stores the ANA concentration level. We will filter the records by the patient ID and the examination date to get the specific result.",
        "sql": "SELECT `ANA` FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02';",
        "question": "What was the anti-nucleus antibody concentration level for the patient id 3605340 on 1996/12/2?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT ANA FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02'",
        "evidence": [
            "anti-nucleus antibody refers to ANA; 1996/12/2 refers to `Examination Date` = '1996-12-02'"
        ]
    },
    "483": {
        "reason": "To solve the question, we need to find the Italian text rulings of all cards in the set 'Coldsnap'. Here's the step-by-step reasoning:\n\n1. **Identify the set 'Coldsnap'**: The `sets` table contains information about sets, and we need to find the set with the name 'Coldsnap' to get its `code`.\n\n2. **Link cards to the set 'Coldsnap'**: The `cards` table has a `setCode` field that links cards to their respective sets. We will filter cards where `setCode` matches the `code` of the 'Coldsnap' set.\n\n3. **Retrieve Italian rulings**: The `foreign_data` table contains translated text, including rulings, linked to cards via `uuid`. We need to filter for entries where `language` is 'Italian'.\n\n4. **Combine the data**: Join the `sets`, `cards`, and `foreign_data` tables to get the Italian text rulings for all cards in the 'Coldsnap' set.\n\n5. **Ensure uniqueness**: Use `DISTINCT` to avoid duplicate entries in the results.",
        "sql": "SELECT DISTINCT fd.text AS italian_ruling\nFROM sets s\nJOIN cards c ON s.code = c.setCode\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE s.name = 'Coldsnap' AND fd.language = 'Italian' AND fd.text IS NOT NULL;",
        "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
        "evidence": [
            "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'",
            "The `foreign_data` table contains translated text, including rulings, linked to cards via `uuid`.\nThe `sets` table's `code` field is used to link cards to their respective sets via `setCode` in the `cards` table.\nFiltering for Italian text requires checking the `language` field in the `foreign_data` table.",
            "The `rulings` table contains card rulings, while the `foreign_data` table holds translated text, including rulings, linked to cards via `uuid`.\nTo retrieve rulings, the `foreign_data` table must be used instead of the `rulings` table for translated content.\nThe `DISTINCT` keyword ensures unique results when fetching translated rulings."
        ]
    },
    "1155": {
        "reason": "To solve the question, we need to find patients whose LDH (Lactate Dehydrogenase) levels are beyond the normal range (LDH > 500). The relevant data is stored in the `Laboratory` table, which includes the `ID` of the patient and the `LDH` value. We also need to retrieve the patient's `SEX` and `Birthday` from the `Patient` table. The steps are as follows:\n\n1. Join the `Laboratory` table with the `Patient` table on the `ID` field to link the LDH data with the patient's personal details.\n2. Filter the records where `LDH` is greater than 500.\n3. Select the required fields: `ID`, `SEX`, and `Birthday` from the `Patient` table.",
        "sql": "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.LDH > 500;",
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "evidence": [
            "LDH beyond normal range refers to LDH > '500';"
        ]
    },
    "892": {
        "reason": "To find the driver with the most points scored, we need to aggregate the points across all races for each driver. The `driverStandings` table records points per race, so we will sum the points for each driver. Then, we will join this result with the `drivers` table to get the full name of the driver. Finally, we will order the results by the total points in descending order and limit the result to the top driver.",
        "sql": "SELECT d.forename || ' ' || d.surname AS full_name, SUM(ds.points) AS total_points\nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nGROUP BY ds.driverId\nORDER BY total_points DESC\nLIMIT 1;",
        "question": "State the driver with the most points scored. Find his full name with that points.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
        "evidence": [
            "the most points scored refers to max(points); Full name of the driver refers to drivers.forename and drivers.surname;",
            "The `driverStandings` table records points per race, so aggregating points requires summing them across races for each driver. The `MAX` function alone does not aggregate points across multiple races.",
            "The `driverStandings` table records points per race, but the highest points for a single race may not represent the driver with the most points overall. To find the driver with the highest points in a single race, no aggregation is needed.",
            "The `driverStandings` table records points per race, but the highest points for a single race may not represent the driver with the most points overall. To find the driver with the highest points in a single race, no aggregation is needed."
        ]
    },
    "995": {
        "reason": "To find the average score of Lewis Hamilton among all the Turkish Grand Prix, we need to follow these steps:\n1. Identify Lewis Hamilton's driverId from the drivers table using his name (forename and surname).\n2. Identify all races named 'Turkish Grand Prix' from the races table.\n3. Join the driverStandings table with the races table to filter standings for the Turkish Grand Prix.\n4. Filter the driverStandings for Lewis Hamilton using his driverId.\n5. Calculate the average of the points he scored in these races using the AVG function.",
        "sql": "SELECT AVG(ds.points) AS average_score\nFROM driverStandings ds\nJOIN races r ON ds.raceId = r.raceId\nJOIN drivers d ON ds.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND r.name = 'Turkish Grand Prix';",
        "question": "What is the average score of Lewis Hamilton among all the Turkish Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T3.name = 'Turkish Grand Prix'",
        "evidence": [
            "Average score = AVG(points)",
            "The driverStandings table contains aggregated points for drivers per race, which is more suitable for calculating average scores.\nTo filter races by name, use exact matching (e.g., =) instead of pattern matching (e.g., LIKE) for precision."
        ]
    },
    "859": {
        "reason": "To find Bruno Senna's Q1 result in the qualifying race No. 354, we need to follow these steps:\n1. Identify Bruno Senna's driverId from the drivers table using his surname 'Senna' and forename 'Bruno'.\n2. Use the qualifying table to find the Q1 result for the driverId identified in step 1 and the raceId 354.",
        "sql": "SELECT q.q1\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE d.forename = 'Bruno' AND d.surname = 'Senna' AND q.raceId = 354;",
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "evidence": [
            "race number refers to raceId; Bruno Senna refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;"
        ]
    },
    "550": {
        "reason": "To solve the question, we need to find the most popular tag and then determine the post from which this tag's excerpt is taken. The steps are as follows:\n1. Identify the most popular tag by finding the tag with the highest count in the `tags` table.\n2. Once the most popular tag is identified, use its `ExcerptPostId` to find the corresponding post in the `posts` table.\n3. Retrieve the body of the post using the `ExcerptPostId`.",
        "sql": "SELECT p.Body \nFROM posts p \nJOIN tags t ON p.Id = t.ExcerptPostId \nWHERE t.Count = (SELECT MAX(Count) FROM tags);",
        "question": "From which post is the most popular tag excerpted from? Please give the body of the post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Body FROM posts WHERE id = ( SELECT ExcerptPostId FROM tags ORDER BY Count DESC LIMIT 1 )",
        "evidence": [
            "most popular tag refers to Max(Count); excerpt from refer to ExcerptPostId"
        ]
    },
    "801": {
        "reason": "To find the ratio between male and female superheroes, we need to:\n1. Count the number of male superheroes by filtering the `superhero` table where `gender_id` corresponds to 'Male' in the `gender` table.\n2. Count the number of female superheroes similarly by filtering for 'Female'.\n3. Calculate the ratio of male to female superheroes by dividing the count of male superheroes by the count of female superheroes.\n4. Ensure we join the `superhero` table with the `gender` table to map the `gender_id` to the actual gender names.",
        "sql": "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Male')) * 1.0 /\n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female')) AS male_to_female_ratio;",
        "question": "Find the ratio between male superheroes and female superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id",
        "evidence": [
            "ratio = DIVIDE(SUM(gender_id = 1) / SUM(gender_id = 2)); male superheroes refers to gender = 'Female'; female superheroes refers to gender = 'Male';"
        ]
    },
    "212": {
        "reason": "To solve the question, we need to find the least numerous element in non-carcinogenic molecules. Here's the step-by-step reasoning:\n\n1. **Identify non-carcinogenic molecules**: These are molecules where the `label` is '-', as per the tips.\n2. **Count distinct molecules for each element**: For each element, count the number of distinct non-carcinogenic molecules that contain it. This is because the tip specifies that we should count distinct molecules, not just the total occurrences of the element.\n3. **Find the least numerous element**: The element with the smallest count of distinct non-carcinogenic molecules is the answer.\n4. **Return only the element**: The query should return the element itself, not the count.\n\nWe will join the `molecule` table with the `atom` table to filter non-carcinogenic molecules and then group by the element to count distinct molecules. Finally, we will order by the count and limit to the first result to get the least numerous element.",
        "sql": "SELECT a.element\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '-'\nGROUP BY a.element\nORDER BY COUNT(DISTINCT m.molecule_id)\nLIMIT 1;",
        "question": "Which element is the least numerous in non-carcinogenic molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
        "evidence": [
            "label = '-' means molecules are non-carcinogenic; least numerous refers to MIN(COUNT(element));",
            "To determine the least numerous element, count distinct molecules containing each element, not just the total occurrences of the element.",
            "The query should return only the element, not the count, as the target SQL focuses on the element itself."
        ]
    },
    "154": {
        "reason": "To find the number of male clients in the 'Hl.m. Praha' district, we need to:\n1. Identify the district_id for 'Hl.m. Praha' from the district table.\n2. Use this district_id to filter clients in the client table who are male (gender = 'M').\n3. Count the number of such clients.",
        "sql": "SELECT COUNT(*) \nFROM client \nWHERE gender = 'M' AND district_id = (SELECT district_id FROM district WHERE A2 = 'Hl.m. Praha');",
        "question": "How many male clients in 'Hl.m. Praha' district?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'",
        "evidence": [
            "District data appears in the A2; Male means that gender = 'M'"
        ]
    },
    "1258": {
        "reason": "To solve the question, we need to find the number of distinct patients who meet two conditions:\n1. They have a normal Rheumatoid Factor (RA in ('-', '+-')).\n2. They have a positive measure of degree of coagulation (KCT = '+').\n\nWe will join the `Patient` table with the `Examination` table to check these conditions. The `Examination` table contains the `KCT` field for coagulation and the `Laboratory` table contains the `RA` field for Rheumatoid Factor. However, since the `RA` field is in the `Laboratory` table, we need to ensure we are checking the correct records for each patient.\n\nThe steps are:\n1. Join the `Patient` table with the `Examination` table to filter patients with KCT = '+'.\n2. Join the result with the `Laboratory` table to filter patients with RA in ('-', '+-').\n3. Count the distinct patient IDs that satisfy both conditions.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nJOIN Laboratory L ON P.ID = L.ID\nWHERE E.KCT = '+' AND L.RA IN ('-', '+-');",
        "question": "How many patients with a normal Rhuematoid Factor has a positive measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T3.KCT = '+'",
        "evidence": [
            "normal Rhuematoid Factor refers TO RA IN('-', '+-'); positive measure of degree of coagulation refers to KCT = '+'; Should compute the number of distinct ones"
        ]
    },
    "708": {
        "reason": "To solve the question, we need to find the creation date and age of users who have commented with a website. The comments table contains the text of comments, and the users table contains the creation date and age of users. We need to join these tables to get the required information. The tip mentions that a website is indicated by the presence of 'http://' in the comment text. Therefore, we will filter comments that contain 'http://' and then join with the users table to retrieve the creation date and age of those users.",
        "sql": "SELECT u.CreationDate, u.Age\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text LIKE '%http://%';",
        "question": "List the creation date and age of the user that commented with webiste.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.CreationDate, T2.Age FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.text LIKE '%http://%'",
        "evidence": [
            "commented with webiste refers to the value contains 'http://'"
        ]
    },
    "1511": {
        "reason": "To solve the question, we need to find the average total price of transactions for customers who paid in euros. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `customers` table contains the `Currency` column to filter customers who paid in euros ('EUR'). The `transactions_1k` table contains the `Price` column, which represents the total price per transaction.\n\n2. **Filter customers by currency**: We need to join the `customers` table with the `transactions_1k` table to filter transactions where the customer's currency is 'EUR'.\n\n3. **Calculate the average total price**: After filtering, we will calculate the average of the `Price` column for these transactions.\n\n4. **Ensure accurate linking**: Although the `gasstations` table is not directly referenced in the query intent, it is required to link transactions to their respective gas stations, as per the schema tips. However, since the question does not involve gas station details, we can omit it in this query.\n\n5. **Final query**: The query will join `customers` and `transactions_1k`, filter for 'EUR' currency, and compute the average price.",
        "sql": "SELECT AVG(t.Price) AS AverageTotalPrice\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE c.Currency = 'EUR';",
        "question": "For the customers who paid in the euro, what is their average total price of the transactions?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Currency = 'EUR'",
        "evidence": [
            "",
            "The `gasstations` table is required to link transactions to their respective gas stations, even if not directly mentioned in the query intent.\nThe `Price` column in `transactions_1k` already represents the total price per transaction, eliminating the need to calculate it as `Amount * Price`.",
            "The `gasstations` table must be included in the join to ensure accurate linking of transactions to their respective gas stations, even if not directly referenced in the query intent.\nThe `Currency` column in the `customers` table uses 'EUR' as the value for euros, not 'euro'."
        ]
    },
    "304": {
        "reason": "To list all carcinogenic molecules and their elements, we need to:\n1. Identify carcinogenic molecules by filtering the `molecule` table where `label = '+'`.\n2. Join the `molecule` table with the `atom` table to get the elements associated with each molecule.\n3. Use the `DISTINCT` keyword to ensure each combination of molecule and element is unique.\n4. Select the `molecule_id` and `element` columns to display the required information.",
        "sql": "SELECT DISTINCT m.molecule_id, a.element\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+';",
        "question": "List all carcinogenic molecules and their elements.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "evidence": [
            "label = '+' mean molecules are carcinogenic; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
            "The `DISTINCT` keyword ensures unique combinations of molecule_id and element are returned, avoiding duplicates.\nJoining the `atom` and `molecule` tables links elements to their respective molecules.\nFiltering by `label = '+'` isolates carcinogenic molecules."
        ]
    },
    "1230": {
        "reason": "To solve the question, we need to list all outpatient patients (where Admission = '-') who have a normal range of creatinine phosphokinase (CPK < 250). The query should return distinct patient IDs. We will join the Patient and Laboratory tables to filter out the required records. The steps are:\n1. Join the Patient and Laboratory tables on the ID field.\n2. Filter records where Admission = '-' (outpatient) and CPK < 250 (normal range).\n3. Select distinct IDs from the filtered records.",
        "sql": "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Admission = '-' AND l.CPK < 250;",
        "question": "List all outpatient within normal range of creatinine phosphokinase. Give me the distinct ids.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CPK < 250 AND T1.Admission = '-'",
        "evidence": [
            "outpatient refers to Admission = '-'; normal range of creatinine phosphokinase refers to CPK < 250;"
        ]
    },
    "321": {
        "reason": "To find the molecule that contains both atom IDs \"TR000_2\" and \"TR000_4\", we need to follow these steps:\n1. Check the `connected` table to see if there is a bond between these two atoms.\n2. If such a bond exists, the `bond_id` in the `connected` table will link to the `bond` table, which contains the `molecule_id`.\n3. The `molecule_id` will then give us the molecule that contains both atoms.\n4. We will join the `connected` table with the `bond` table to retrieve the `molecule_id`.",
        "sql": "SELECT b.molecule_id\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR000_2' AND c.atom_id2 = 'TR000_4') OR (c.atom_id = 'TR000_4' AND c.atom_id2 = 'TR000_2');",
        "question": "What is the molecule of atom id \"TR000_2\" and atom id 2 \"TR000_4\"?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'",
        "evidence": [
            "",
            "The `connected` table links atoms via bonds, indicating molecular structure through `atom_id`, `atom_id2`, and `bond_id`.\nTo find molecules for specific atom pairs, query the `connected` table joined with `bond` to verify bond existence.\nThe `molecule_id` is derived from the `bond` table, not directly from the `atom` table."
        ]
    },
    "492": {
        "reason": "To find the expansion type of the set \"From the Vault: Lore\", we need to query the `sets` table. The `sets` table contains a column named `type` which stores the expansion type of each set. We will filter the records in the `sets` table where the `name` column matches \"From the Vault: Lore\" and then retrieve the `type` column for that set.",
        "sql": "SELECT type FROM sets WHERE name = 'From the Vault: Lore';",
        "question": "For the set \"From the Vault: Lore\", what is its expansion type?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT type FROM sets WHERE name LIKE '%FROM the Vault: Lore%'",
        "evidence": [
            "set \"From the Vault refers to name which contains 'From the Vault: Lore'; expansion type refers to type"
        ]
    },
    "145": {
        "reason": "To solve the question, we need to identify account holders who have credit card transactions (operation = 'VYBER KARTOU') in 1998 where the transaction amount is less than the average transaction amount for all transactions in 1998. The steps are as follows:\n1. Calculate the average transaction amount for all transactions in 1998.\n2. Filter transactions in 1998 where the operation is 'VYBER KARTOU' and the amount is less than the calculated average.\n3. Retrieve the account holder identification numbers (account_id) from these filtered transactions.",
        "sql": "WITH avg_transaction_1998 AS (\n    SELECT AVG(amount) AS avg_amount\n    FROM trans\n    WHERE strftime('%Y', date) = '1998'\n)\nSELECT DISTINCT t.account_id\nFROM trans t, avg_transaction_1998 a\nWHERE t.operation = 'VYBER KARTOU'\n  AND strftime('%Y', t.date) = '1998'\n  AND t.amount < a.avg_amount;",
        "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
        "evidence": [
            "Operation = 'VYBER KARTOU' refers to credit card withdrawal",
            "The operation 'VYBER KARTOU' in the trans table identifies credit card transactions.\nThe average transaction amount is calculated from all transactions in 1998, not just credit card transactions.\nAccount holder identification is directly linked to the account_id in the trans table."
        ]
    },
    "1001": {
        "reason": "1. Identify the `circuitId` for Marina Bay Street Circuit from the `circuits` table.\n2. Filter races in 2008 at this circuit using the `races` table.\n3. Join `qualifying` with `drivers` to retrieve driver details, ensuring `q3` is not null.\n4. Parse `q3` times into numerical values for accurate ranking and sort to find the fastest time.\n5. Limit results to the top-ranked driver.",
        "sql": "SELECT d.forename || ' ' || d.surname AS full_name\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nJOIN races r ON q.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Marina Bay Street Circuit'\n  AND r.year = 2008\n  AND q.position = 1\n  AND q.q3 IS NOT NULL\nORDER BY q.q3 ASC\nLIMIT 1;",
        "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
        "evidence": [
            "Ranked 1st in the 3rd qualifying race refer to MIN(q3); 2008 is the year of race; full name of racer = forename, surname",
            "The `q3` time in the `qualifying` table is stored as a text string and requires parsing to compare numerical values for ranking.\nTo identify the 3rd qualifying race, filter for non-null `q3` values and sort by parsed time to determine the fastest.\nThe `position` column in `qualifying` does not directly indicate Q3 ranking; instead, the fastest `q3` time determines the 1st rank.",
            "The `position` column in `qualifying` does not directly reflect Q3 ranking; the fastest `q3` time determines the 1st rank.\nTo compare `q3` times numerically, parse the text format into seconds for accurate sorting.\nThe 3rd qualifying race is identified by filtering for non-null `q3` values and sorting by parsed time.",
            "The `position` column in `qualifying` does not reflect Q3 ranking; the fastest `q3` time determines the 1st rank.\nTo compare `q3` times numerically, parse the text format into seconds for accurate sorting.\nThe 3rd qualifying race is identified by filtering for non-null `q3` values and sorting by parsed time."
        ]
    },
    "721": {
        "reason": "To find the number of superheroes with blue eyes, we need to:\n1. Identify the `colour` record where `colour` is 'Blue' to get its `id`.\n2. Use this `id` to filter superheroes in the `superhero` table where `eye_colour_id` matches the `id` of the 'Blue' colour.\n3. Count the number of such superheroes.",
        "sql": "SELECT COUNT(*) AS blue_eyed_superheroes\nFROM superhero\nWHERE eye_colour_id = (SELECT id FROM colour WHERE colour = 'Blue');",
        "question": "How many superheroes have blue eyes?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue'",
        "evidence": [
            "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id;"
        ]
    },
    "351": {
        "reason": "To find all cards that have alternative language data in Japanese, we need to query the `foreign_data` table where the `language` column is 'Japanese'. Since the `foreign_data` table references the `cards` table via the `uuid` column, we can join these two tables to get the card names. The query will select the `name` column from the `cards` table where there is a matching entry in the `foreign_data` table with `language` set to 'Japanese'.",
        "sql": "SELECT DISTINCT c.name FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Japanese';",
        "question": "Name all the cards which have alternative language in Japanese.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'",
        "evidence": [
            "Japanese' is the language;"
        ]
    },
    "217": {
        "reason": "To identify all atoms connected to the atoms of the TR181 molecule, we need to follow these steps:\n1. First, find all atoms that belong to the TR181 molecule by querying the `atom` table where `molecule_id` is 'TR181'.\n2. Then, use the `connected` table to find all atoms connected to these TR181 atoms. Since the `connected` table records pairs in a directed manner, we need to check both directions (atom_id to atom_id2 and vice versa) to ensure we capture all connections.\n3. Finally, retrieve the details of these connected atoms from the `atom` table.",
        "sql": "SELECT DISTINCT a2.*\nFROM atom a1\nJOIN connected c ON a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2\nJOIN atom a2 ON (a2.atom_id = c.atom_id OR a2.atom_id = c.atom_id2) AND a2.atom_id != a1.atom_id\nWHERE a1.molecule_id = 'TR181';",
        "question": "Identify all the atoms that are connected to the atoms of the TR181 molecule.",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T1.molecule_id = 'TR181'",
        "evidence": [
            "TR181 molecule refers to molecule_id = 'TR181'",
            "The `connected` table records pairs of atoms linked by bonds, where `atom_id` and `atom_id2` represent the connected atoms. To find connections, only one direction of the pair needs to be checked.",
            "The `connected` table records pairs of atoms in a directed manner, so only one direction (atom_id to atom_id2) needs to be checked for connections. To find all connected atoms, the query should focus on the `atom_id` column in the `connected` table.",
            "The `connected` table records pairs of atoms in a directed manner, so only one direction (atom_id to atom_id2) needs to be checked for connections. To find all connected atoms, the query should focus on the `atom_id` column in the `connected` table."
        ]
    },
    "143": {
        "reason": "To find accounts that have gold credit cards, we need to follow these steps:\n1. Identify the `card` table to find all cards of type 'gold'.\n2. Join the `card` table with the `disp` table to link the card to its associated account via the `disp_id`.\n3. Finally, select the `account_id` from the `disp` table to get the accounts associated with gold credit cards.",
        "sql": "SELECT DISTINCT d.account_id\nFROM card c\nJOIN disp d ON c.disp_id = d.disp_id\nWHERE c.type = 'gold';",
        "question": "What are the accounts that have gold credit cards?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.account_id FROM disp AS T2  INNER JOIN card AS T1 ON T1.disp_id = T2.disp_id  WHERE T1.type = 'gold'",
        "evidence": [
            ""
        ]
    },
    "932": {
        "reason": "To find the years in which Lewis Hamilton participated in Formula 1 races, we need to follow these steps:\n1. Identify Lewis Hamilton's driverId from the drivers table using his name (forename and surname).\n2. Use the driverId to find all races he participated in from the results table.\n3. Extract the unique years from the races table based on the raceIds found in the results table.\n4. Return the list of distinct years.",
        "sql": "SELECT DISTINCT r.year\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';\n",
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "evidence": [
            ""
        ]
    },
    "487": {
        "reason": "To solve the question, we need to calculate the percentage of incredibly powerful cards in the set 'Coldsnap'. Here's the step-by-step reasoning:\n\n1. **Identify the set 'Coldsnap'**: The set name is stored in the `sets` table, so we need to filter the `sets` table where `name` is 'Coldsnap'.\n2. **Join with the `cards` table**: The `cards` table contains the card details, and the `setCode` in the `cards` table corresponds to the `code` in the `sets` table. We join these tables to get all cards in the 'Coldsnap' set.\n3. **Identify incredibly powerful cards**: These are cards where both `cardKingdomFoilId` and `cardKingdomId` are not null.\n4. **Calculate the percentage**: Divide the count of incredibly powerful cards by the total number of cards in 'Coldsnap' and multiply by 100 to get the percentage.\n5. **Ensure accurate division**: Cast the counts to REAL to avoid integer division issues.\n\nThe final SQL query will join the `sets` and `cards` tables, filter for 'Coldsnap', and perform the percentage calculation.",
        "sql": "SELECT \n    (CAST(COUNT(CASE WHEN c.cardKingdomFoilId IS NOT NULL AND c.cardKingdomId IS NOT NULL THEN 1 END) AS REAL) / \n     CAST(COUNT(*) AS REAL)) * 100 AS percentage_incredibly_powerful\nFROM \n    cards c\nJOIN \n    sets s ON c.setCode = s.code\nWHERE \n    s.name = 'Coldsnap';",
        "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "evidence": [
            "card set Coldsnap refers to name = 'Coldsnap'; foil is incredibly powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null; the percentage of incredibly powerful cards in the set refers to DIVIDE(SUM(incredibly powerful), SUM(name = 'Coldsnap'))*100",
            "The set name 'Coldsnap' is stored in the `sets` table, not directly in the `cards` table. To filter cards by set name, join the `cards` table with the `sets` table using `setCode` and `code`.\nIncredibly powerful cards are identified by non-null values in both `cardKingdomFoilId` and `cardKingdomId` fields.\nPercentage calculations require casting to REAL for accurate division results."
        ]
    },
    "867": {
        "reason": "To solve the question, we need to find the driver who set the fastest lap speed in race No. 933 and then determine their nationality. Here's the step-by-step reasoning:\n\n1. **Identify the driver with the fastest lap speed in race No. 933**:\n   - The `results` table contains information about race results, including the `fastestLapSpeed` and `raceId`.\n   - We need to filter the `results` table for `raceId = 933` and find the row with the highest `fastestLapSpeed`.\n\n2. **Retrieve the driver's nationality**:\n   - Once we have the `driverId` of the driver with the fastest lap speed, we can join the `drivers` table to get their nationality (`nationality` field).\n\n3. **Combine the queries**:\n   - Use a subquery or a join to link the `results` and `drivers` tables based on the `driverId`.\n   - The final query will return the nationality of the driver who set the fastest lap speed in race No. 933.",
        "sql": "SELECT d.nationality\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE r.raceId = 933\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;",
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "evidence": [
            "fastest lap speed refers to MAX(fastestLapSpeed);"
        ]
    },
    "1473": {
        "reason": "To find the average monthly consumption of customers in the SME segment for the year 2013, we need to follow these steps:\n1. Identify customers in the SME segment from the `customers` table.\n2. Filter the `yearmonth` table for records where the `Date` falls within the year 2013 (i.e., the first 4 characters of `Date` are '2013').\n3. Calculate the average consumption for these customers over the filtered period.\n4. Divide the average consumption by 12 to get the average monthly consumption.\n\nThe query will join the `customers` and `yearmonth` tables, filter for SME customers and the year 2013, and then compute the required average.",
        "sql": "SELECT AVG(Consumption) / 12 AS AverageMonthlyConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Segment = 'SME' AND SUBSTR(ym.Date, 1, 4) = '2013';",
        "question": "What was the average monthly consumption of customers in SME for the year 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.Consumption) / 12 FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME'",
        "evidence": [
            "Average Monthly consumption = AVG(Consumption) / 12; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year."
        ]
    },
    "1063": {
        "reason": "To find Aaron Doran's potential score, we need to follow these steps:\n1. Identify Aaron Doran's `player_api_id` from the `Player` table using his name (`player_name`).\n2. Use this `player_api_id` to query the `Player_Attributes` table for his `potential` score.\n3. Since the question does not specify the need for the latest record, we can directly retrieve the `potential` score without filtering by date.",
        "sql": "SELECT pa.potential\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Aaron Doran';",
        "question": "What is Aaron Doran's potential score?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
        "evidence": [
            "potential score refers to potential;",
            "The `potential` score is stored in the `Player_Attributes` table and linked to the `Player` table via `player_api_id`.",
            "The `Player_Attributes` table contains multiple records per player, so filtering by the latest date ensures the most recent `potential` score is retrieved.",
            "The `potential` score is directly retrievable from the `Player_Attributes` table without requiring sorting by date, as the question does not specify the need for the latest record."
        ]
    },
    "1364": {
        "reason": "To find Amy Firth's hometown, we need to determine the city, county, and state associated with her zip code. The steps are as follows:\n1. Locate Amy Firth in the `member` table using her first and last name.\n2. Retrieve her zip code from the `member` table.\n3. Use the zip code to query the `zip_code` table for the corresponding city, county, and state.\n4. Combine these details to form her hometown.",
        "sql": "SELECT z.city, z.county, z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Amy' AND m.last_name = 'Firth';",
        "question": "Where is Amy Firth's hometown?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.city, T2.county, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Amy' AND T1.last_name = 'Firth'",
        "evidence": [
            "hometown refers to city, county, state"
        ]
    },
    "1412": {
        "reason": "To solve the question, we need to find the types of expenses incurred by members who wear an X-Large t-shirt size. The steps are as follows:\n1. Identify members with `t_shirt_size = 'X-Large'` from the `member` table.\n2. Link these members to their expenses in the `expense` table using the `link_to_member` field.\n3. Retrieve the `expense_description` from the `expense` table for these members.\n4. Ensure the query joins the `member` and `expense` tables correctly to filter and fetch the required data.",
        "sql": "SELECT DISTINCT e.expense_description\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE m.t_shirt_size = 'X-Large';",
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "evidence": [
            "kind of expenses refers to expense_description; t_shirt_size = 'X-Large'"
        ]
    },
    "105": {
        "reason": "To solve the question, we need to find the district ID of the branch where an account was opened, given that a loan was approved on 1994/8/25. The steps are as follows:\n1. Identify the loan record with the date '1994-08-25' in the `loan` table.\n2. From the loan record, get the `account_id` associated with the loan.\n3. Use the `account_id` to find the corresponding account in the `account` table.\n4. From the account record, retrieve the `district_id` which indicates where the account was opened.\n5. Return the `district_id` as the result.",
        "sql": "SELECT a.district_id\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.date = '1994-08-25';",
        "question": "There was a loan approved in 1994/8/25, where was that account opened, give the district Id of the branch.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'",
        "evidence": [
            ""
        ]
    },
    "609": {
        "reason": "To solve the question, we need to count the number of posts that have a score of 10. The `posts` table contains the `Score` column, which stores the score of each post. We will query the `posts` table and count the rows where the `Score` column equals 10.",
        "sql": "SELECT COUNT(*) FROM posts WHERE Score = 10;",
        "question": "How many posts have a score of 10 on the list?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score = 10",
        "evidence": [
            "score of 10 refers to Score = 10; post refers to Id"
        ]
    },
    "1460": {
        "reason": "To solve the question, we need to find the full name of the member who spent money on items described as 'Water, Veggie tray, supplies' and include the cost of these expenses. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The question involves the `member` table (for member details like first and last name), the `expense` table (for expense details like description and cost), and the `budget` table (to link expenses to events if needed). However, the question does not require event details, so we can focus on `member` and `expense`.\n\n2. **Filter expenses**: We need to filter the `expense` table for records where `expense_description` exactly matches 'Water, Veggie tray, supplies'.\n\n3. **Join tables**: Join the `expense` table with the `member` table using the `link_to_member` field in `expense` and `member_id` in `member` to get the member's first and last name.\n\n4. **Select required fields**: Select the `first_name` and `last_name` from the `member` table and the `cost` from the `expense` table.\n\n5. **Output the result**: The query will return the full name (first and last name) of the member and the cost of the specified expenses.",
        "sql": "SELECT m.first_name, m.last_name, e.cost\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.expense_description = 'Water, Veggie tray, supplies';",
        "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.first_name, T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
        "evidence": [
            "full name refers to first_name, last name; spent money for refers expense description; expense_description = 'Water, Veggie tray, supplies'",
            "full name can be represented by separate first_name and last_name fields; expense_description filters should match exact string values; cost is directly available in the expense table.",
            "full name can be represented by separate first_name and last_name fields without concatenation; expense_description filters should match exact string values; cost is directly available in the expense table."
        ]
    },
    "1358": {
        "reason": "To find the first member who paid their dues, we need to look at the `income` table, which records payments received from members. The `income` table includes a `date_received` field, which we can use to determine the earliest payment. We will join the `income` table with the `member` table to get the full name of the member who made the earliest payment. The query will order the results by `date_received` in ascending order and limit the result to the first record.",
        "sql": "SELECT m.first_name, m.last_name\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nORDER BY i.date_received ASC\nLIMIT 1;",
        "question": "Who was the first one paid his/her dues? Tell the full name.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.source = 'Dues' ORDER BY T2.date_received LIMIT 1",
        "evidence": [
            "full name refers to first_name, last_name; first paid dues refers to MIN(received_date) where source = 'Dues'"
        ]
    },
    "954": {
        "reason": "To calculate the race completion percentage of Japanese drivers from 2007 to 2009, we need to follow these steps:\n1. Identify all Japanese drivers from the `drivers` table where `nationality` is 'Japanese'.\n2. Find all races from 2007 to 2009 in the `races` table.\n3. Join the `results` table with the filtered `drivers` and `races` to get the results for Japanese drivers in the specified years.\n4. Count the total number of races completed by Japanese drivers (where `time` is not null) and the total number of races they participated in.\n5. Calculate the percentage by dividing the completed races by the total races and multiplying by 100.\n\nThe query will involve joins between `drivers`, `races`, and `results` tables, and filtering based on nationality and year range.",
        "sql": "SELECT \n    (COUNT(CASE WHEN r.time IS NOT NULL THEN 1 END) * 100.0 / COUNT(*)) AS race_completion_percentage\nFROM \n    results r\nJOIN \n    drivers d ON r.driverId = d.driverId\nJOIN \n    races rc ON r.raceId = rc.raceId\nWHERE \n    d.nationality = 'Japanese'\n    AND rc.year BETWEEN 2007 AND 2009;",
        "question": "Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.raceId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009",
        "evidence": [
            "from 2007 to 2009 refers to year between 2007 and 2009; race completion refers to time is not null; percentage = Divide(COUNT(DriverID where time is not null and year between 2007 and 2009),Count (DriverID where year between 2007 and 2009))*100; "
        ]
    },
    "596": {
        "reason": "To find users with the most comments, we need to:\n1. Group the comments by `UserId` and count the number of comments each user has made.\n2. Order the results in descending order of comment count to identify the top users.\n3. Join the results with the `badges` table to retrieve the badge names associated with these users.\n4. Limit the results to the top users (e.g., top 10) to focus on the most active commenters.\n\nThe query will involve:\n- Aggregating comments by `UserId`.\n- Joining with the `badges` table to get badge names.\n- Ordering and limiting the results.",
        "sql": "SELECT u.Id, u.DisplayName, COUNT(c.Id) AS CommentCount, b.Name AS BadgeName\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nLEFT JOIN badges b ON u.Id = b.UserId\nGROUP BY u.Id, u.DisplayName\nORDER BY CommentCount DESC\nLIMIT 10;",
        "question": "Which users have posted the most comments. List out the user's badge?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT Name FROM badges AS T1 INNER JOIN comments AS T2 ON T1.UserId = t2.UserId GROUP BY T2.UserId ORDER BY COUNT(T2.UserId) DESC LIMIT 1",
        "evidence": [
            "user with the most comments refers to UserId where Max(Count(Id)",
            "To find users with the most comments, group comments by UserId and count occurrences, then join with badges to retrieve associated badge names.",
            "To retrieve badges for users with the most comments, join the badges table with the comments table on UserId and group by UserId.\nThe highest comment count is determined by ordering the grouped results in descending order and limiting to the top result.",
            "To retrieve the badge name for users with the most comments, join the badges table with the comments table on UserId and group by UserId.\nThe highest comment count is determined by ordering the grouped results in descending order and limiting to the top result."
        ]
    },
    "588": {
        "reason": "To find the total number of comments posted by user ID 13, we need to query the `comments` table where the `UserId` column matches 13. The `COUNT` function will be used to count the number of such records.",
        "sql": "SELECT COUNT(*) AS TotalComments FROM comments WHERE UserId = 13;",
        "question": "Give the total number of comments posted by user ID 13.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13",
        "evidence": [
            ""
        ]
    },
    "594": {
        "reason": "To find the user who created post ID 1 and their reputation, we need to join the `posts` table with the `users` table. The `posts` table contains the `OwnerUserId` field, which links to the `Id` field in the `users` table. By joining these tables on this relationship, we can retrieve the user's details, including their reputation, for the specified post ID.",
        "sql": "SELECT u.DisplayName, u.Reputation FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.Id = 1;",
        "question": "Which user created post ID 1 and what is the reputation of this user?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T2.Id, T2.Reputation FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.PostId = 1",
        "evidence": [
            "",
            "The `comments` table contains a `UserId` field that links to the `users` table, allowing retrieval of user details for comments on a post.\nTo find user details for a specific post, the `comments` table can be queried using the `PostId` field.",
            "The `posts` table contains an `OwnerUserId` field that directly links to the `users` table, providing the creator of a post.\nTo retrieve user details for a post, the `posts` and `users` tables should be joined using the `OwnerUserId` and `Id` fields.",
            "The `comments` table links to the `users` table via the `UserId` field, enabling retrieval of user details for comments on a specific post.\nTo find user details for a post, the `comments` table should be queried using the `PostId` field, not the `posts` table."
        ]
    },
    "1223": {
        "reason": "To solve the question, we need to compare the number of male and female patients with creatinine (CRE) levels not within the normal range (CRE >= 1.5). The steps are as follows:\n1. Join the `Patient` and `Laboratory` tables to get the relevant patient records.\n2. Filter the records where CRE >= 1.5.\n3. Count the number of male (SEX = 'M') and female (SEX = 'F') patients separately.\n4. Compare the counts to determine if there are more male patients than female patients.\n5. Return 'True' if the count of male patients is greater, otherwise 'False'.",
        "sql": "SELECT \n    CASE \n        WHEN SUM(CASE WHEN P.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN P.SEX = 'F' THEN 1 ELSE 0 END) \n        THEN 'True' \n        ELSE 'False' \n    END AS result\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    L.CRE >= 1.5;",
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "evidence": [
            "creatinine (CRE) not within the normal range refers to CRE > = 1.5; male refers to Sex = 'M'; female refers to Sex = 'F'; calculation = (SUM(SEX = 'M') > SUM(SEX = 'F')) where CRE > = 1.5",
            "To compare counts of male and female patients, use conditional aggregation (SUM with CASE) instead of subqueries for efficiency and clarity.\nEnsure the join between Patient and Laboratory tables includes all relevant records for the condition CRE >= 1.5.",
            "To compare counts of male and female patients, use a single CASE statement to directly return 'True' or 'False' based on the comparison.\nEnsure the query returns a boolean result by wrapping the comparison in a CASE expression."
        ]
    },
    "1122": {
        "reason": "To find the name of the strongest player, we need to identify the player with the highest `overall_rating` in the `Player_Attributes` table. This involves joining the `Player_Attributes` table with the `Player` table to get the player's name. The steps are:\n1. Find the maximum `overall_rating` in the `Player_Attributes` table.\n2. Join the `Player_Attributes` table with the `Player` table to match the player's ID with their name.\n3. Filter the results to only include the player(s) with the maximum `overall_rating`.\n4. Retrieve the player's name.",
        "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);",
        "question": "State the name of the most strongest player.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)",
        "evidence": [
            "strongest players refers to player has MAX(overall_rating)"
        ]
    },
    "1000": {
        "reason": "To determine which racetrack hosted the most recent race and its full location, we need to follow these steps:\n1. Identify the most recent race by sorting the `races` table by `date` in descending order and limiting the result to one.\n2. Join the `races` table with the `circuits` table to get the racetrack's name and full location (combination of `location` and `country` fields from the `circuits` table).\n3. Select the `name` of the racetrack and concatenate `location` and `country` to form the full location.",
        "sql": "SELECT c.name AS racetrack, c.location || ', ' || c.country AS full_location\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nORDER BY r.date DESC\nLIMIT 1;",
        "question": "Which racetrack hosted the most recent race? Indicate the full location.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1",
        "evidence": [
            "full location refers to location+country; most recent race = MAX(date)\n\n",
            "The most recent race is determined by the latest date in the `races` table, requiring sorting by date in descending order and limiting to one result.\nFull location is derived from the `circuits` table, combining `location` and `country` fields.",
            "The `races` table must be sorted by `date` in descending order to identify the most recent race, and the result should be limited to one entry.\nFull location is derived from the `circuits` table, combining `location` and `country` fields.",
            "The `races` table must be joined with the `circuits` table to retrieve the full location, which is stored in the `location` field of the `circuits` table.\nThe most recent race is identified by sorting the `races` table by `date` in descending order and limiting to one result."
        ]
    },
    "1515": {
        "reason": "To determine the segment of the customer at the specific time '2012/8/23 21:20:00', we need to follow these steps:\n1. Identify the transaction(s) that occurred at the exact time '2012/8/23 21:20:00' from the `transactions_1k` table.\n2. From the identified transaction(s), extract the `CustomerID` involved.\n3. Use the `CustomerID` to query the `customers` table and retrieve the `Segment` of the customer.\n\nThe query will involve joining the `transactions_1k` table with the `customers` table based on the `CustomerID` and filtering for the specific date and time.",
        "sql": "SELECT c.Segment\nFROM customers c\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE t.Date = '2012-08-23' AND t.Time = '21:20:00';",
        "question": "What segment did the customer have at 2012/8/23 21:20:00?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.date = '2012-08-23' AND T1.time = '21:20:00'",
        "evidence": [
            "'2012/8/23' can be represented by '2012-08-23'"
        ]
    },
    "659": {
        "reason": "To solve the question, we need to find the number of tags where the post count (stored in the `Count` column of the `tags` table) is between 5,000 and 7,000. The query involves filtering the `tags` table based on the `Count` column and then counting the number of rows that meet the condition.",
        "sql": "SELECT COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000;",
        "question": "How many tags have post count between 5,000 to 7,000?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM tags WHERE Count BETWEEN 5000 AND 7000",
        "evidence": [
            "post count between 5,000 to 7,000 refers to Count BETWEEN 5000 and 7000;"
        ]
    },
    "184": {
        "reason": "To find the number of female customers with a junior credit card, we need to follow these steps:\n1. Identify female customers from the `client` table where `gender` is 'F'.\n2. Join the `client` table with the `disp` table to link clients to their accounts.\n3. Join the `disp` table with the `card` table to find the type of card associated with the account.\n4. Filter the results to only include cards where `type` is 'junior' (assuming 'junior' is the correct type).\n5. Count the distinct female clients who meet these criteria.",
        "sql": "SELECT COUNT(DISTINCT c.client_id) AS female_junior_card_holders\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE c.gender = 'F' AND ca.type = 'junior';",
        "question": "How many female customers have a junior credit card?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "evidence": [
            "Female refers to gender = 'F'"
        ]
    },
    "920": {
        "reason": "To find all the years that the Silverstone Circuit was used in a Formula 1 race, we need to:\n1. Identify the circuitId for Silverstone Circuit from the circuits table.\n2. Use this circuitId to find all races held at Silverstone Circuit in the races table.\n3. Extract the unique years from these races to list all the years the circuit was used.",
        "sql": "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit';",
        "question": "Please list all the years that Silverstone Circuit was used in a Formula_1 race.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "evidence": [
            ""
        ]
    },
    "599": {
        "reason": "To solve the question, we need to address two parts:\n1. Retrieve the `PostHistoryTypeId` values for the post with `PostId` 3720 from the `postHistory` table.\n2. Count the number of unique users who have commented on the post with `PostId` 3720 from the `comments` table.\n\nFor the first part, we will query the `postHistory` table filtering by `PostId = 3720` and selecting the `PostHistoryTypeId` column.\nFor the second part, we will query the `comments` table filtering by `PostId = 3720`, then count the distinct `UserId` values to get the number of unique users who commented.\n\nThese two parts can be combined into a single query using subqueries or joins, but since they are independent, we will use subqueries for clarity.",
        "sql": "SELECT \n    (SELECT GROUP_CONCAT(PostHistoryTypeId) FROM postHistory WHERE PostId = 3720) AS PostHistoryTypeIds,\n    (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS UniqueCommentUsers;",
        "question": "What are the post history type IDs for post ID 3720 and how many unique users have commented on the post?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory AS T1 WHERE T1.PostId = 3720",
        "evidence": [
            "",
            "To combine results from multiple tables, use subqueries or joins to merge data in a single query.\nThe `postHistory` table contains `PostHistoryTypeId` for specific posts, while `comments` tracks user interactions.\nAggregating distinct counts of users requires filtering by the post ID in the relevant table.",
            "The `postHistory` table may contain multiple entries for a single post, each with its own `PostHistoryTypeId`, requiring retrieval of all relevant rows.\nCounting distinct users in the `comments` table involves filtering by the post ID and aggregating unique user IDs.",
            "The `postHistory` table may contain multiple entries for a single post, each with its own `PostHistoryTypeId`, requiring retrieval of all relevant rows.\nCounting distinct users in the `comments` table involves filtering by the post ID and aggregating unique user IDs.\nTo combine results from multiple tables, use subqueries or joins to merge data in a single query."
        ]
    },
    "1194": {
        "reason": "To solve the question, we need to find the sex of a patient who meets two conditions: \n1. Diagnosed with PSS in a medical examination (from the Examination table).\n2. Had specific laboratory results (C-reactive protein 2+, creatinine 1, and LDH 123) in the Laboratory table.\n\nSteps:\n1. Identify the patient ID(s) from the Examination table where the Diagnosis is 'PSS'.\n2. From the Laboratory table, find the patient ID(s) where CRP is '2+', CRE is 1, and LDH is 123.\n3. Join these results with the Patient table to get the sex of the patient(s) who meet both conditions.",
        "sql": "SELECT p.SEX\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nJOIN Laboratory l ON p.ID = l.ID\nWHERE e.Diagnosis = 'PSS'\nAND l.CRP = '2+'\nAND l.CRE = 1\nAND l.LDH = 123;",
        "question": "What sex is the patient who in a medical examination was diagnosed with PSS and in a laboratory examination had a blood level of C-reactive protein de 2+, createnine 1 and LDH 123?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T3.ID = T2.ID WHERE T2.Diagnosis = 'PSS' AND T3.CRP = '2+' AND T3.CRE = 1.0 AND T3.LDH = 123",
        "evidence": [
            "PSS' refers to diagnosis; blood level of C-reactive protein de 2+refers to CRP > 2; createnine 1 refers to CRE = 1; LDH 123 refers to LDH = 123"
        ]
    },
    "1386": {
        "reason": "To find the total expense for the Yearly Kickoff, we need to follow these steps:\n1. Identify the event_id for the Yearly Kickoff from the event table.\n2. Use the event_id to find the corresponding budget_id in the budget table.\n3. Sum all the costs from the expense table where the link_to_budget matches the budget_id found in step 2.",
        "sql": "SELECT SUM(e.cost) AS total_expense\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Yearly Kickoff';",
        "question": "What is the total expense for the Yearly Kickoff?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'Yearly Kickoff'",
        "evidence": [
            "'Yearly Kickoff' is an event name; total expense refers to SUM(cost)"
        ]
    },
    "962": {
        "reason": "To solve the question, we need to calculate the percentage of drivers who were born before 1985 and completed more than 50 laps in races held between 2000 and 2005. The steps are as follows:\n1. Join the `results`, `races`, and `drivers` tables to get the necessary data.\n2. Filter the races to include only those held between 2000 and 2005.\n3. Filter the drivers to include only those born before 1985.\n4. Filter the results to include only those with more than 50 laps.\n5. Use conditional aggregation to count the drivers who meet all criteria (numerator) and the total number of drivers in the specified races (denominator).\n6. Calculate the percentage by dividing the numerator by the denominator and multiplying by 100.",
        "sql": "SELECT \n    (COUNT(DISTINCT CASE WHEN strftime('%Y', d.dob) < '1985' AND r.laps > 50 THEN d.driverId END) * 100.0 / \n    COUNT(DISTINCT d.driverId)) AS percentage\nFROM \n    results r\nJOIN \n    races rc ON r.raceId = rc.raceId\nJOIN \n    drivers d ON r.driverId = d.driverId\nWHERE \n    rc.year BETWEEN 2000 AND 2005;",
        "error": "something went wrong, tool did not call.",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "evidence": [
            "born before 1985 refers to year(dob)<1985; in 2000 to 2005 refers to year between 2000 and 2005; percentage = Divide(COUNT(driverId where year (dob) <1985 and laps >50),COUNT(DriverID where year between 2000 and 2005) *100;",
            "The percentage calculation requires counting drivers meeting specific criteria within the same query, not using separate subqueries.\nFiltering for laps > 50 should be applied directly in the main query, not in a subquery.\nThe join between results, races, and drivers must include all conditions in a single pass.",
            "The percentage calculation should use a single query with conditional aggregation (IIF or CASE) to count drivers meeting both criteria in one pass.\nJoining results, races, and drivers must include all filtering conditions directly in the main query.\nThe denominator for the percentage should count all drivers in the specified races, not just those meeting the criteria.",
            "The percentage calculation should use a single pass with conditional counting (IIF or CASE) to evaluate both criteria (birth year and laps) simultaneously.\nThe denominator for the percentage should count all drivers in the specified races, not just those meeting the criteria.\nJoining results, races, and drivers must include all filtering conditions directly in the main query."
        ]
    },
    "1347": {
        "reason": "To find the hometown county for \"Adela O'Gallagher\", we need to follow these steps:\n1. Locate the member record for \"Adela O'Gallagher\" in the `member` table to get her ZIP code.\n2. Use the ZIP code to look up the corresponding county in the `zip_code` table.\n3. Join the `member` and `zip_code` tables on the ZIP code to retrieve the county information.",
        "sql": "SELECT z.county\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Adela' AND m.last_name = 'O''Gallagher';",
        "question": "Tell the hometown county for \"Adela O'Gallagher\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'",
        "evidence": [
            "hometown county refers to county"
        ]
    },
    "170": {
        "reason": "To solve the question, we need to find the number of credit card withdrawals recorded after 1995. The key points are:\n1. The operation 'VYBER KARTOU' indicates a credit card withdrawal.\n2. The date must be after 1995.\n3. The relevant table is `trans`, which contains the `operation` and `date` columns.\n\nSteps:\n1. Filter the `trans` table for records where `operation` is 'VYBER KARTOU'.\n2. Further filter these records to include only those where the `date` is after '1995-12-31'.\n3. Count the number of such records.",
        "sql": "SELECT COUNT(*) AS credit_card_withdrawals_after_1995\nFROM trans\nWHERE operation = 'VYBER KARTOU' AND date > '1995-12-31';",
        "question": "How many credit card withdrawals were recorded after 1995?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
        "evidence": [
            "Operation = 'VYBER KARTOU' means credit card withdrawals"
        ]
    },
    "26": {
        "reason": "To solve the question, we need to find high schools in Monterey with more than 800 free or reduced-price meals for ages 5-17. Here's the step-by-step reasoning:\n\n1. **Identify High Schools**: Filter schools where `School Type` in the `frpm` table is 'High Schools (Public)'.\n2. **Filter by County**: Use the `County` field in the `schools` table to filter for 'Monterey'.\n3. **Meal Count Condition**: Check the `Free Meal Count (Ages 5-17)` field in the `frpm` table for values greater than 800.\n4. **Join Tables**: Join the `frpm` and `schools` tables on the `CDSCode` field to combine the required information.\n5. **Select Fields**: Retrieve the school name (`School`), street address (`Street`), city (`City`), state (`State`), and zip code (`Zip`) from the `schools` table.\n6. **Final Query**: Construct the SQL query to fetch the required data.",
        "sql": "SELECT s.School, s.Street, s.City, s.State, s.Zip\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE f.`School Type` = 'High Schools (Public)'\nAND s.County = 'Monterey'\nAND f.`Free Meal Count (Ages 5-17)` > 800;",
        "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
        "evidence": [
            "Full communication address should include Street, City, State and zip code if any.",
            "The `School Type` field in the `frpm` table can be used to filter high schools directly, avoiding assumptions about grade levels.\nThe `Free Meal Count (Ages 5-17)` field in the `frpm` table should be used for filtering meal counts, not `FRPM Count (Ages 5-17)`.",
            "The `County` field in the `schools` table should be used for filtering by county, not the `County Name` field in the `frpm` table.\nThe `School Type` field in the `frpm` table requires an exact match for filtering, such as 'High Schools (Public)'."
        ]
    },
    "768": {
        "reason": "To find the number of superheroes published by Dark Horse Comics, we need to:\n1. Identify the publisher_id for 'Dark Horse Comics' in the publisher table.\n2. Count the number of superheroes in the superhero table where the publisher_id matches the one found in step 1.",
        "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Dark Horse Comics');",
        "question": "How many superheroes were published by Dark Horse Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Dark Horse Comics'",
        "evidence": [
            "published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';"
        ]
    },
    "914": {
        "reason": "To find out how many drivers don't have a code, we need to query the `drivers` table and count the rows where the `code` column is NULL or an empty string. The SQL query will use the `COUNT` function to count these rows.",
        "sql": "SELECT COUNT(*) FROM drivers WHERE code IS NULL OR code = '';",
        "question": "How many drivers don't have a code?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) - COUNT(CASE WHEN code IS NOT NULL THEN code END) FROM drivers",
        "evidence": [
            "don't have a code refers to code is null"
        ]
    },
    "754": {
        "reason": "To find the superpower of the hero with ID 56, we need to follow these steps:\n1. Identify the hero in the `superhero` table with `id = 56`.\n2. Join the `hero_power` table to link the hero's ID with their superpowers.\n3. Join the `superpower` table to get the names of the superpowers associated with the hero.\n4. Retrieve the `power_name` from the `superpower` table for the hero with ID 56.",
        "sql": "SELECT sp.power_name \nFROM superhero sh \nJOIN hero_power hp ON sh.id = hp.hero_id \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE sh.id = 56;",
        "question": "What is the superpower of hero ID 56?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 56",
        "evidence": [
            "superpower refers to hero_power"
        ]
    },
    "1273": {
        "reason": "To solve the question, we need to find the number of distinct patients who meet two conditions: \n1. They have a normal anti-SSB (SSB is either 'negative' or '0' in the Laboratory table).\n2. They are diagnosed with SLE (Diagnosis = 'SLE' in the Patient table).\n\nWe will join the Patient and Laboratory tables to check these conditions. The Examination table is not relevant here because the SSB condition is checked in the Laboratory table, and the Diagnosis for SLE is stored in the Patient table.\n\nThe steps are:\n1. Join the Patient and Laboratory tables on the ID field.\n2. Filter records where the Patient.Diagnosis is 'SLE' and the Laboratory.SSB is either 'negative' or '0'.\n3. Count the distinct patient IDs to avoid duplicates.",
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.Diagnosis = 'SLE' AND (L.SSB = 'negative' OR L.SSB = '0');",
        "question": "How many patients have a normal anti-SSB and are diagnosed with SLE in the examination?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Diagnosis = 'SLE'",
        "evidence": [
            "normal anti-SSB refers to SSB IN('-', '+-'); '-' is expressed as 'negative' and '+-' is expressed as '0' in the database ; diagnosed with SLE refers to Diagnosis = 'SLE'; Should compute the number of distinct ones",
            "The SSB condition is checked in the Laboratory table, not the Examination table. The Examination table does not contain SSB data.",
            "The Patient table contains the Diagnosis field, not the Examination table. The SSB condition is checked in the Laboratory table, where 'negative' and '0' represent normal values.",
            "The SSB field in the Laboratory table uses 'negative' and '0' to represent normal values, not '-' or '+-'.\nThe Diagnosis field for SLE is stored in the Patient table, not the Examination table.\nThe query must count distinct patient IDs to avoid duplicates."
        ]
    },
    "1510": {
        "reason": "To solve the question, we need to find the average total price of transactions that occurred in gas stations located in the Czech Republic. Here's the step-by-step reasoning:\n\n1. **Identify the relevant tables**: The `transactions_1k` table contains transaction details, including the `GasStationID` and `Price`. The `gasstations` table contains information about gas stations, including their `Country`.\n\n2. **Filter gas stations in the Czech Republic**: We need to join the `transactions_1k` table with the `gasstations` table to filter transactions where the `Country` is 'CZE' (Czech Republic).\n\n3. **Calculate the average price**: After filtering the transactions, we calculate the average of the `Price` column.\n\n4. **SQL Query**: The query will involve joining the two tables, applying the filter, and then using the `AVG` function to compute the average price.",
        "sql": "SELECT AVG(t.Price) AS AveragePrice\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE';",
        "question": "What is the average total price of the transactions taken place in gas stations in the Czech Republic?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE'",
        "evidence": [
            "Gas station in the Czech Republic implies that Country = 'CZE'",
            "The `Price` column in `transactions_1k` already represents the total price per transaction, so no multiplication with `Amount` is needed."
        ]
    },
    "1246": {
        "reason": "To solve the question, we need to find the number of patients with an abnormal activated partial prothrombin time (APTT) who do not have thrombosis. Here's the step-by-step reasoning:\n\n1. **Identify abnormal APTT**: The `Laboratory` table contains the `APTT` column. We need to define what constitutes an abnormal APTT. For this query, we'll assume an abnormal APTT is when the value is outside the normal range (e.g., less than 25 or greater than 35 seconds).\n\n2. **Check for thrombosis**: The `Examination` table contains the `Thrombosis` column, which indicates whether a patient has thrombosis (1 for yes, 0 for no).\n\n3. **Join tables**: We need to join the `Laboratory` and `Examination` tables on the `ID` column to correlate APTT values with thrombosis status.\n\n4. **Filter and count**: Filter for patients with abnormal APTT and no thrombosis (Thrombosis = 0), then count these patients.\n\n5. **Final query**: The query will join the tables, apply the filters, and count the results.",
        "sql": "SELECT COUNT(DISTINCT L.ID) \nFROM Laboratory L\nJOIN Examination E ON L.ID = E.ID\nWHERE (L.APTT < 25 OR L.APTT > 35) AND E.Thrombosis = 0;",
        "question": "For the patients with an abnormal activated partial prothrom bin time, how many of them does not have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T3.Thrombosis = 0 AND T2.APTT > 45",
        "evidence": [
            "abnormal activated partial prothrom bin time refers to APTT > 45; does not have thrombosis refers to Thrombosis = 0; Only count ones without repetitive."
        ]
    },
    "251": {
        "reason": "To find the least common element of all carcinogenic molecules, we need to follow these steps:\n1. Identify carcinogenic molecules by filtering the `molecule` table where `label = '+'`.\n2. Join the filtered `molecule` table with the `atom` table to get all atoms belonging to these carcinogenic molecules.\n3. Count the distinct `molecule_id` for each `element` in the `atom` table to determine how many distinct carcinogenic molecules each element appears in.\n4. Order the results by the count of distinct molecules in ascending order to find the least common element.\n5. Limit the result to the first row to get the least common element.",
        "sql": "SELECT a.element, COUNT(DISTINCT a.molecule_id) AS molecule_count\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+'\nGROUP BY a.element\nORDER BY molecule_count ASC\nLIMIT 1;",
        "question": "What is the least common element of all carcinogenic molecules?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "evidence": [
            "label = '+' mean molecules are carcinogenic",
            "To identify the least common element, count distinct molecules per element rather than total atom occurrences.\nThe `DISTINCT` keyword ensures each molecule is counted only once per element.\nOrdering by the count of distinct molecules reveals the least common element.",
            "The `molecule` table must be the primary table in the join to ensure filtering by `label` is applied first.\nSubqueries can be used to structure the query for clarity and correctness.\nThe `ORDER BY` clause should directly reference the aggregate function for accurate sorting.",
            "The `molecule` table should be the primary table in the join to ensure filtering by `label` is applied first.\nSubqueries can structure the query for clarity and correctness.\nThe `ORDER BY` clause should directly reference the aggregate function for accurate sorting."
        ]
    },
    "190": {
        "reason": "To solve the question, we need to find the number of clients born in 1920 who reside in East Bohemia. The steps are as follows:\n1. Identify the `district_id` for East Bohemia from the `district` table.\n2. Filter clients in the `client` table who were born in 1920 (using the `birth_date` column).\n3. Join the `client` table with the `district` table to ensure the clients are from East Bohemia.\n4. Count the number of such clients.",
        "sql": "SELECT COUNT(*) \nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE strftime('%Y', c.birth_date) = '1920' \nAND d.A3 = 'east Bohemia';",
        "question": "How many clients who were born in 1920 stay in east Bohemia?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.birth_date) = '1920' AND T2.A3 = 'east Bohemia'",
        "evidence": [
            "East Bohemia appears in the column A3, which refers to the region."
        ]
    },
    "701": {
        "reason": "To solve the question, we need to follow these steps:\n1. Identify the most influential user, which is the user with the highest reputation.\n2. Find all posts posted by this user.\n3. Calculate the percentage of these posts that have a score above 50.\n\nThe steps involve:\n- Querying the `users` table to find the user with the highest reputation.\n- Using this user's ID to filter posts in the `posts` table.\n- Counting the total posts by this user and the posts with a score above 50.\n- Calculating the percentage by dividing the count of high-score posts by the total posts and multiplying by 100.",
        "sql": "WITH most_influential_user AS (\n    SELECT Id\n    FROM users\n    ORDER BY Reputation DESC\n    LIMIT 1\n),\nuser_posts AS (\n    SELECT Id, Score\n    FROM posts\n    WHERE OwnerUserId = (SELECT Id FROM most_influential_user)\n),\ntotal_posts AS (\n    SELECT COUNT(*) AS total\n    FROM user_posts\n),\nhigh_score_posts AS (\n    SELECT COUNT(*) AS high_score\n    FROM user_posts\n    WHERE Score > 50\n)\nSELECT (high_score * 100.0 / total) AS percentage\nFROM high_score_posts, total_posts;",
        "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
        "evidence": [
            "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));"
        ]
    },
    "662": {
        "reason": "To solve the question, we need to find the number of posts that meet the following criteria:\n1. The posts have votes.\n2. The votes were created in 2011.\n3. The votes have a bounty of 50.\n\nWe will approach this step by step:\n1. Join the `posts` table with the `votes` table to link posts with their votes.\n2. Filter the votes to only include those created in 2011 and with a bounty of 50.\n3. Count the distinct posts that meet these criteria.",
        "sql": "SELECT COUNT(DISTINCT p.Id) \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE strftime('%Y', v.CreationDate) = '2011' \nAND v.BountyAmount = 50;",
        "question": "How many posts with votes that were created in 2011 have a bounty of 50?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.BountyAmount = 50 AND STRFTIME('%Y', T2.CreationDate) = '2011'",
        "evidence": [
            "created in 2012 refers YEAR(CreationDate) = 2011; BountyAmount = 50;"
        ]
    },
    "933": {
        "reason": "To find Lewis Hamilton's final rank in the 2008 Chinese Grand Prix, we need to follow these steps:\n1. Identify Lewis Hamilton's driverId from the drivers table using his name (forename and surname).\n2. Identify the raceId for the 2008 Chinese Grand Prix from the races table using the year (2008) and the race name (Chinese Grand Prix).\n3. Query the results table to find his final rank (positionOrder) for the identified raceId and driverId.",
        "sql": "SELECT r.positionOrder \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' \nAND ra.year = 2008 AND ra.name = 'Chinese Grand Prix';",
        "question": "What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.positionOrder FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.name = 'Chinese Grand Prix' AND T1.year = 2008",
        "evidence": [
            "Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; final rank refers to positionOrder; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';"
        ]
    },
    "610": {
        "reason": "To find the names of badges obtained by users with the highest reputation, we need to follow these steps:\n1. Identify the user(s) with the highest reputation from the `users` table. This can be done by sorting the users by `Reputation` in descending order and limiting the result to the top user.\n2. Join the `users` table with the `badges` table using the `UserId` to retrieve the badges associated with the highest reputation user.\n3. Select the `Name` column from the `badges` table to get the names of the badges.\n\nThe query will ensure that only the badges of the user with the highest reputation are returned.",
        "sql": "SELECT b.Name \nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Reputation = (SELECT MAX(Reputation) FROM users);",
        "question": "What are the name of badge that users who have the highest reputation obtained?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T2.name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1",
        "evidence": [
            "highest reputation refers to Max(Reputation); user refers to UserId",
            "To retrieve the latest or highest value, ordering by the relevant column and limiting results is often used instead of subqueries.\nThe highest reputation can be identified by sorting users by reputation in descending order and limiting to the top result.\nJoining tables directly and filtering by sorted results ensures the correct user is linked to their badges.",
            "To retrieve the highest reputation user, sorting by reputation in descending order and limiting to the top result is more efficient than using a subquery.\nJoining users and badges directly ensures the correct linkage for badge retrieval.",
            "To link users and badges, an inner join ensures only matching records are included, avoiding null results.\nSorting users by reputation in descending order and limiting to the top result directly retrieves the highest reputation user.\nSelecting badge names from the joined result ensures the output is specific to the highest reputation user."
        ]
    },
    "319": {
        "reason": "To determine how many elements are contained in the bond with `bond_id` TR001_3_4, we need to follow these steps:\n1. Identify the atoms connected by the bond with `bond_id` TR001_3_4 from the `connected` table.\n2. Retrieve the elements of these atoms from the `atom` table.\n3. Count the distinct elements to find out how many unique elements are involved in the bond.\n\nThe query will join the `connected` table with the `atom` table twice (once for each atom in the bond) to get the elements of both atoms, and then count the distinct elements.",
        "sql": "SELECT COUNT(DISTINCT a1.element) AS element_count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_3_4';",
        "question": "How many elements are contained in bond_id TR001_3_4?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.element) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_3_4'",
        "evidence": [
            "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "1470": {
        "reason": "To solve the question, we need to find the number of gas stations in CZE (Czech Republic) that offer Premium gas. The `gasstations` table contains information about gas stations, including their country and segment. The segment 'Premium' indicates the type of gas offered. We will filter the gas stations by country 'CZE' and segment 'Premium', then count the results.",
        "sql": "SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium';",
        "question": "How many gas stations in CZE has Premium gas?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium'",
        "evidence": [
            ""
        ]
    },
    "1397": {
        "reason": "To solve the question, we need to calculate the average amount spent on food for events that are in the past (i.e., events with status 'Closed'). The steps are as follows:\n1. Identify all budgets linked to events with status 'Closed'.\n2. Filter these budgets to only include those with the category 'Food'.\n3. Calculate the average of the 'spent' column for these budgets.\n4. The result will give the average spending on food for past events.",
        "sql": "SELECT AVG(spent) AS average_food_spending\nFROM budget\nWHERE category = 'Food' AND link_to_event IN (SELECT event_id FROM event WHERE status = 'Closed');",
        "question": "On average, how much did the Student_Club spend on food for the typical event in the past?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(spent) / COUNT(spent) FROM budget WHERE category = 'Food' AND event_status = 'Closed'",
        "evidence": [
            "DIVIDE(SUM(spent), COUNT(spent)) where category = 'Food'; 'event in the past' means event_status = 'Closed'"
        ]
    },
    "316": {
        "reason": "To solve the question, we need to identify molecules that contain the element \"c\" and are not carcinogenic. The steps are as follows:\n1. First, find all atoms with the element \"c\" and retrieve their associated `molecule_id`.\n2. Then, join these `molecule_id`s with the `molecule` table to check if their `label` is \"-\", indicating they are non-carcinogenic.\n3. Finally, return the distinct `molecule_id`s that meet both criteria.",
        "sql": "SELECT DISTINCT a.molecule_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'c' AND m.label = '-';",
        "question": "Among the molecules which contain \"c\" element, which of them are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
        "evidence": [
            "label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1457": {
        "reason": "To solve the question, we need to find members who spent more than the average cost on each expense. Here's the step-by-step reasoning:\n\n1. **Calculate the average cost of all expenses**: This will be used as a benchmark to compare individual expenses.\n2. **Identify members with expenses exceeding the average cost**: We need to join the `member` table with the `expense` table to link expenses to members.\n3. **Retrieve the full name and contact number of these members**: The full name is a combination of `first_name` and `last_name` from the `member` table, and the contact number is the `phone` field.\n4. **Ensure uniqueness**: Use `DISTINCT` to avoid duplicate entries if a member has multiple expenses exceeding the average.\n\nKey points:\n- The `expense` table is linked to the `member` table via `link_to_member`.\n- The average cost is calculated across all expenses.\n- The query filters expenses where the `cost` is greater than the calculated average.",
        "sql": "SELECT DISTINCT m.first_name || ' ' || m.last_name AS full_name, m.phone AS contact_number\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost > (SELECT AVG(cost) FROM expense);",
        "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
        "evidence": [
            "full name refers to first_name, last_name; contact number refers to phone; had spent more than average on each expense refers to cost > AVG(cost)",
            "Expenses are linked to budgets via the link_to_budget field in the expense table, requiring a join with the budget table for accurate expense context.\nThe DISTINCT keyword ensures unique member records are returned when multiple expenses meet the criteria.\nThe subquery for average cost calculation must mirror the join conditions of the main query to maintain consistency.",
            "The average cost calculation must include the same join conditions as the main query to ensure consistency in filtering expenses linked to budgets.\nFull name and contact details are retrieved from the member table, which is linked to expenses via the link_to_member field.",
            "The subquery for average cost calculation must include the same join conditions as the main query to ensure consistency in filtering expenses linked to budgets and members.\nFull name and contact details are retrieved from the member table, which is linked to expenses via the link_to_member field."
        ]
    },
    "1251": {
        "reason": "To solve the question, we need to find the number of patients with an Ig G (IGG) level higher than normal, which is defined as IGG >= 2000. The steps are as follows:\n1. Identify the relevant table: The Laboratory table contains the IGG field.\n2. Filter records where IGG >= 2000.\n3. Ensure we count distinct patient IDs to avoid duplicates, as a patient might have multiple laboratory tests.\n4. Join with the Patient table to validate the patient IDs, though this is not strictly necessary for counting distinct IDs in the Laboratory table.\n5. The Examination table is not needed for this query, as it does not contain IGG data.",
        "sql": "SELECT COUNT(DISTINCT ID) AS PatientCount FROM Laboratory WHERE IGG >= 2000;",
        "question": "How many patients with an Ig G higher than normal?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
        "evidence": [
            "Ig G higher than normal refers to IGG >= 2000; Should consider DISTINCT in the final result;",
            "The query requires joining Patient, Laboratory, and Examination tables to ensure all relevant patient data is included. Distinct patient IDs must be counted to avoid duplicates.",
            "The Examination table contains additional patient data that may be relevant for filtering or validation, even if not directly used in the current query.",
            "The query requires joining Patient and Laboratory tables to ensure all patient records are validated against the primary key in Patient. The Examination table is not necessary for filtering but may be included for completeness."
        ]
    },
    "535": {
        "reason": "To solve the question, we need to identify users who have more than 100 upvotes and then count how many of these users also have more than 1 downvote. The steps are as follows:\n1. Filter users from the `users` table where `UpVotes` > 100.\n2. From this filtered list, count the number of users where `DownVotes` > 1.",
        "sql": "SELECT COUNT(*) AS UserCount\nFROM users\nWHERE UpVotes > 100 AND DownVotes > 1;",
        "question": "Among the users who have more than 100 upvotes, how many of them have more then 1 downvotes?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Upvotes > 100 AND Downvotes > 1",
        "evidence": [
            "more than 100 upvotes refers to Upvotes > 100; more than 1 downvotes refers to Downvotes > 1"
        ]
    },
    "689": {
        "reason": "To solve the question, we need to identify the display name and location of the user who last edited the post with ID 183. The steps are as follows:\n1. From the `posts` table, find the post with `Id = 183` and retrieve its `LastEditorUserId` (the user who last edited the post).\n2. Using the `LastEditorUserId`, query the `users` table to get the `DisplayName` and `Location` of the user.\n3. The query will join the `posts` and `users` tables to fetch the required information.",
        "sql": "SELECT u.DisplayName, u.Location\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE p.Id = 183;",
        "question": "Identify the display name and location of the user, who was the last to edit the post with ID 183.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T2.DisplayName, T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 183 ORDER BY T1.LastEditDate DESC LIMIT 1",
        "evidence": [
            "last to edit refers to MAX(LastEditDate);",
            "The `LastEditorUserId` column in the `posts` table identifies the user who last edited the post, not the `OwnerUserId`.\nTo retrieve the latest edit, sorting by `LastEditDate` in descending order and limiting to one result ensures the most recent edit is captured.",
            "The `OwnerUserId` column in the `posts` table identifies the original owner of the post, not the last editor.\nTo capture the latest edit, sorting by `LastEditDate` in descending order and limiting to one result ensures the most recent edit is captured.",
            "The `OwnerUserId` column in the `posts` table identifies the original owner, while `LastEditorUserId` identifies the last editor.\nTo capture the latest edit, sorting by `LastEditDate` in descending order ensures the most recent edit is prioritized."
        ]
    },
    "968": {
        "reason": "To find the reference name of Robert Kubica, we need to query the `drivers` table where the forename is 'Robert' and the surname is 'Kubica'. The reference name is stored in the `driverRef` column of the `drivers` table.",
        "sql": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';",
        "question": "What is reference name of Robert Kubica?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica'",
        "evidence": [
            "reference name refers to driverRef;"
        ]
    },
    "375": {
        "reason": "To list all card IDs with a converted mana cost of 0, we need to query the `cards` table and filter for rows where the `convertedManaCost` column equals 0. The `id` column in the `cards` table represents the card ID, so we will select this column for the output.",
        "sql": "SELECT id FROM cards WHERE convertedManaCost = 0;",
        "question": "List down all the card IDs with converted mana cost of 0.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE convertedManaCost = 0",
        "evidence": [
            "converted mana cost of 0 refers to covertedManaCost = 0;"
        ]
    }
}