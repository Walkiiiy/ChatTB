{
    "488": {
        "question": "What's the code for the set which was released on 2017/7/14?",
        "db_id": "card_games",
        "ground_truth": "SELECT code FROM sets WHERE releaseDate = '2017-07-14' GROUP BY releaseDate, code",
        "amends": [],
        "rules": [
            "released on 2017/7/14 refers to releaseDate = '2017-07-14'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM sets WHERE releaseDate = '2017-07-14';"
        ],
        "rule_sql": []
    },
    "314": {
        "question": "How many single bonds are there in the list?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '-'",
        "amends": [],
        "rules": [
            "single bond refers to bond_type = '-';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS single_bond_count FROM bond WHERE bond_type = '-';"
        ],
        "rule_sql": []
    },
    "1296": {
        "question": "What is the anti-nucleus antibody concentration of the patient whose total bilirubin is the highest in the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T3.ANA FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` < 2.0 ORDER BY T2.`T-BIL` DESC LIMIT 1",
        "amends": [
            "Do join `Patient` table instead of omitting it, connecting through `T1.ID = T2.ID` and `T1.ID = T3.ID` instead of directly joining `Examination` to `Laboratory`. Do filter with `T-BIL < 2.0` instead of an equality comparison to a subquery maximum. Do use `ORDER BY T-BIL DESC` instead of a subquery to find the maximum value. Do select `T3.ANA` from the properly joined `Examination` table instead of `e.ANA` from an incomplete join structure. The amended query now correctly retrieves the patient examination record with the highest T-BIL value below 2.0 through proper table relationships and ordering."
        ],
        "rules": [
            "1) When joining Patient, Laboratory, and Examination tables: link rows where T1.ID = T2.ID and T1.ID = T3.ID, keeping only matching pairs (inner match). 2) When filtering for values in the normal range of total bilirubin: include only rows where T2.\"T-BIL\" < 2.0. 3) When finding the highest value within a filtered set: order rows by T2.\"T-BIL\" in descending direction and keep the first row. 4) When selecting anti-nucleus antibody concentration: output the value from T3.ANA. 5) Output columns (ordered): T3.ANA"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.ANA\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE l.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory WHERE `T-BIL` < 2.0)\nLIMIT 1;",
            "SELECT T3.ANA \nFROM Laboratory T1 \nJOIN Patient T2 ON T1.ID = T2.ID \nJOIN Examination T3 ON T1.ID = T3.ID \nWHERE T1.\"T-BIL\" < 2.0 \nORDER BY T1.\"T-BIL\" DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T3.ANA\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" < 2.0\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;"
        ]
    },
    "792": {
        "question": "What is Abomination's superpower?",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Abomination'",
        "amends": [],
        "rules": [
            "Abomination refers to superhero_name = 'Abomination'; superpower refers to power_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Abomination';"
        ],
        "rule_sql": []
    },
    "552": {
        "question": "Please list the names of the badges obtained by csgillespie.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'csgillespie';"
        ],
        "rule_sql": []
    },
    "136": {
        "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
        "amends": [
            "Do count `T1.account_id` instead of `COUNT(*)` to ensure accurate counting of specific account relationships. Do use table aliases `T1` and `T2` instead of `a` and `l` for consistency. Do remove the `AND l.status = 'approved'` filter instead of keeping it, as the right query does not include this status condition. Do remove the `AS loan_count` alias instead of including it since the right query returns an unnamed count. The amended query now correctly matches the RIGHT_SQL's behavior by focusing on the account relationships and date/amount/frequency conditions without the additional status filter.",
            "Do use the exact string literal `'POPLATEK MESICNE'` for the frequency filter instead of `'monthly statement issuance'` to match the correct data values. Do maintain the same join condition `T1.account_id = T2.account_id` with an explicit `INNER JOIN` instead of just `JOIN` for clarity. Do keep all other elements including the `COUNT` aggregate on `T1.account_id`, the date range filter on `T2.date`, and the amount filter `T2.amount >= 250000` unchanged. The amended query now correctly filters by the proper frequency value while preserving the original join logic and filtering conditions."
        ],
        "rules": [
            "1) When the question asks for loans per account: count the number of unique T1.account_id values instead of counting all rows. 2) When combining loan and account tables: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match). 3) When the question specifies a date range between 1/1/1995 and 12/31/1997: filter T2.date to include dates from '1995-01-01' through '1997-12-31' inclusive. 4) When the question specifies loans of at least 250,000: filter T2.amount to include values \u2265 250000. 5) When the question mentions monthly statement issuance: filter T1.frequency to exactly match 'POPLATEK MESICNE'. 6) When producing output: do not include any alias for the count result. 7) When handling loan status: do not filter by T2.status as the question does not require checking approval status. Output columns (ordered): count of T1.account_id",
            "1) When the question mentions a date range between 1/1/1995 and 12/31/1997: filter T2.date to include dates from '1995-01-01' through '1997-12-31' inclusive. 2) When the question specifies loans with amount of at least 250,000: filter T2.amount to include values greater than or equal to 250000. 3) When the question refers to accounts that chose monthly statement issuance: filter T1.frequency to exactly match the literal value 'POPLATEK MESICNE'. 4) When combining account and loan tables for shared entities: link rows where T1.account_id equals T2.account_id and keep only matching pairs (inner match). 5) When counting loans per account: compute the number of rows using T1.account_id as the counting key. Output columns (ordered): COUNT(T1.account_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS loan_count\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nWHERE a.frequency = 'POPLATEK MESICNE'\nAND l.date BETWEEN '1995-01-01' AND '1997-12-31'\nAND l.amount >= 250000\nAND l.status = 'approved';",
            "SELECT COUNT(T1.account_id) \nFROM account T1 \nJOIN loan T2 ON T1.account_id = T2.account_id \nWHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' \nAND T2.amount >= 250000 \nAND T1.frequency = 'monthly statement issuance'",
            "SELECT COUNT(T1.account_id)\nFROM account T1\nINNER JOIN loan T2 ON T1.account_id = T2.account_id\nWHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31'\nAND T2.amount >= 250000\nAND T1.frequency = 'POPLATEK MESICNE'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT account.account_id)\nFROM account\nINNER JOIN loan ON account.account_id = loan.account_id\nWHERE loan.date BETWEEN '1995-01-01' AND '1997-12-31'\nAND loan.amount >= 250000\nAND account.frequency = 'POPLATEK MESICNE'"
        ]
    },
    "598": {
        "question": "What is the percentage difference of student badges given during 2010 and 2011?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) AS REAL) * 100 / COUNT(Id) - CAST(SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) AS REAL) * 100 / COUNT(Id) FROM badges WHERE Name = 'Student'",
        "amends": [
            "Do use a single query with conditional aggregation instead of multiple CTEs and cross joins. Do calculate percentages directly with `SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) * 100 / COUNT(Id)` instead of separate counts for each year. Do apply the `Name = 'Student'` filter once in the main query instead of duplicating it across multiple CTEs. Do remove the unnecessary CTE structure and cross join operations that could produce incorrect Cartesian products. Do use proper casting with `CAST(... AS REAL)` instead of implicit type conversions. The amended query now correctly calculates the percentage difference between Student badges in 2010 and 2011 using a single efficient aggregation.",
            "Do cast the `SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0))` as `REAL` instead of using integer division, and do cast the `SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0))` as `REAL` instead of integer division to ensure proper percentage calculation. Do remove the alias `percentage_difference` instead of keeping it, and do remove the parentheses grouping around the entire expression instead of having them. Do maintain the same `WHERE Name = 'Student'` filter instead of changing it. The amended query now correctly handles floating-point division for accurate percentage difference calculation and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for percentage difference between two years: compute the difference between the percentage of Student badges in 2010 and the percentage of Student badges in 2011.\n2) When filtering for Student badges: apply the condition Name = 'Student' to all badge records.\n3) When calculating percentages by year: for each year (2010 and 2011), compute the ratio of Student badges to total badges in that year using conditional counting.\n4) When handling year filtering: use the exact year literals '2010' and '2011' with the Date field to identify records from those years.\n5) When performing percentage calculations: use proper numeric casting to ensure accurate division results.\n6) When computing aggregates: use a single aggregation pass instead of multiple separate queries to avoid Cartesian product issues.\n7) Output columns (ordered): percentage_difference",
            "1) When calculating percentage differences between years: cast year-specific counts as REAL instead of using integer division to ensure proper percentage calculation.\n2) When the question asks for percentage difference between two specific years (2010 and 2011): compute (REAL count for 2010) minus (REAL count for 2011) divided by appropriate denominators.\n3) When filtering for specific badge types: maintain the exact literal filter Name = 'Student' with case-sensitive matching.\n4) When formatting output expressions: remove parentheses grouping around the entire percentage difference expression and remove any output column aliases.\n5) Output columns (ordered): the computed percentage difference expression without alias"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH \nbadges_2010 AS (\n    SELECT COUNT(*) AS count_2010\n    FROM badges\n    WHERE Name = 'Student' AND strftime('%Y', Date) = '2010'\n),\nbadges_2011 AS (\n    SELECT COUNT(*) AS count_2011\n    FROM badges\n    WHERE Name = 'Student' AND strftime('%Y', Date) = '2011'\n),\ntotal_badges_2010 AS (\n    SELECT COUNT(*) AS total_2010\n    FROM badges\n    WHERE strftime('%Y', Date) = '2010'\n),\ntotal_badges_2011 AS (\n    SELECT COUNT(*) AS total_2011\n    FROM badges\n    WHERE strftime('%Y', Date) = '2011'\n)\nSELECT \n    ((b2010.count_2010 * 100.0 / t2010.total_2010) - (b2011.count_2011 * 100.0 / t2011.total_2011)) AS percentage_difference\nFROM \n    badges_2010 b2010, \n    badges_2011 b2011, \n    total_badges_2010 t2010, \n    total_badges_2011 t2011;",
            "SELECT \n    (SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) * 100.0 / COUNT(Id) - \n    (SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) * 100.0 / COUNT(Id)) AS percentage_difference\nFROM badges\nWHERE Name = 'Student'",
            "SELECT \n    (CAST(SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) AS REAL) * 100.0 / COUNT(Id) - \n     CAST(SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) AS REAL) * 100.0 / COUNT(Id)) \nFROM badges \nWHERE Name = 'Student'"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN strftime('%Y', Date) = '2010' AND Name = 'Student' THEN 1 ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN strftime('%Y', Date) = '2010' THEN 1 ELSE 0 END), 0) * 100) - \n    (CAST(SUM(CASE WHEN strftime('%Y', Date) = '2011' AND Name = 'Student' THEN 1 ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN strftime('%Y', Date) = '2011' THEN 1 ELSE 0 END), 0) * 100)\nFROM badges\nWHERE strftime('%Y', Date) IN ('2010', '2011')"
        ]
    },
    "712": {
        "question": "What is the post ID and the comments commented in the post titled by \"Group differences on a five point Likert item\"?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Id, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'Group differences on a five point Likert item'",
        "amends": [],
        "rules": [
            "Title = 'Group differences on a five point Likert item';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Id AS PostId, c.Text AS CommentText\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE p.Title = 'Group differences on a five point Likert item';"
        ],
        "rule_sql": []
    },
    "1089": {
        "question": "How many matches in the 2008/2009 season were held in Belgium?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Belgium' AND t2.season = '2008/2009'",
        "amends": [],
        "rules": [
            "Belgium refers to Country.name = 'Belgium';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS number_of_matches\nFROM Match\nWHERE season = '2008/2009'\nAND country_id = (SELECT id FROM Country WHERE name = 'Belgium');"
        ],
        "rule_sql": []
    },
    "261": {
        "question": "Write down bond id for molecules that are carcinogenic.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_id\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE m.label = '+';"
        ],
        "rule_sql": []
    },
    "434": {
        "question": "How many sets are available just in Japanese and not in Magic: The Gathering Online?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.language = 'Japanese'  AND (T1.mtgoCode IS NULL OR T1.mtgoCode = '')",
        "amends": [],
        "rules": [
            "Japanese refers to language = 'Japanese'; not in Magic: The Gathering Online refers to mtgoCode is null or mtgoCode = ''"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT s.code) \nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Japanese'\nAND s.mtgoCode IS NULL;"
        ],
        "rule_sql": []
    },
    "750": {
        "question": "What is the average weight of all female superheroes?",
        "db_id": "superhero",
        "ground_truth": "SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'",
        "amends": [],
        "rules": [
            "female refers to gender = 'Female'; average weight refers to AVG(weight_kg)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(s.weight_kg) AS average_weight\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Female';"
        ],
        "rule_sql": []
    },
    "931": {
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the fastest lap speed among all refers to max(fastestLapSpeed); Spanish Grand Prix refers to races.name = 'Spanish Grand Prix';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(r.fastestLapSpeed) AS fastest_lap_speed\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 2009 AND rc.name = 'Spanish Grand Prix';"
        ],
        "rule_sql": []
    },
    "1313": {
        "question": "How many students in the Student_Club are from the College of Engineering?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.college = 'College of Engineering'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT m.member_id) \nFROM member m \nJOIN major maj ON m.link_to_major = maj.major_id \nWHERE maj.college = 'College of Engineering';"
        ],
        "rule_sql": []
    },
    "202": {
        "question": "How many triple type bonds are there?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '#'",
        "amends": [],
        "rules": [
            "triple type bonds refers to bond_type = '#'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM bond WHERE bond_type = '#';"
        ],
        "rule_sql": []
    },
    "731": {
        "question": "How many superheroes did DC Comics publish?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics'",
        "amends": [],
        "rules": [
            "superheroes that DC Comics published refers to publisher_name = 'DC Comics'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'DC Comics');"
        ],
        "rule_sql": []
    },
    "1120": {
        "question": "Sum up the away team goal scored by both Daan Smith and Filipe Ferreira.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT SUM(t2.away_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_5 WHERE t1.player_name IN ('Daan Smith', 'Filipe Ferreira')",
        "amends": [
            "Do use a direct `INNER JOIN` between `Player` and `match` tables instead of a CTE with multiple OR conditions. Do join specifically on `t1.player_api_id = t2.away_player_5` instead of checking all 11 away player positions with OR conditions. Do filter the player names directly in the `WHERE` clause instead of using a separate CTE. Do remove the unnecessary CTE structure and multiple player position checks instead of keeping the complex OR logic. Do reference the joined table directly with `t2.away_team_goal` instead of using a CTE intermediate result. The amended query now correctly matches the intended behavior by focusing only on the specific away_player_5 position for the given players."
        ],
        "rules": [
            "1) When the question asks to sum goals for specific players: filter Player table rows where player_name equals 'Daan Smith' or 'Filipe Ferreira' exactly as written. 2) When combining Player and Match tables: link rows where T1.player_api_id equals T2.away_player_5 exactly as specified in the join condition. 3) When calculating the total sum: add up all T2.away_team_goal values from the matching rows. 4) When handling player positions: only consider the away_player_5 position, not all 11 away player positions. 5) When structuring the query: avoid using CTEs and instead use direct table joins with filtering in the WHERE clause. Output columns (ordered): SUM(T2.away_team_goal) AS total_away_goals"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH player_ids AS (\n    SELECT player_api_id\n    FROM Player\n    WHERE player_name IN ('Daan Smith', 'Filipe Ferreira')\n),\naway_matches AS (\n    SELECT m.away_team_goal\n    FROM Match m\n    JOIN player_ids p ON \n        m.away_player_1 = p.player_api_id OR\n        m.away_player_2 = p.player_api_id OR\n        m.away_player_3 = p.player_api_id OR\n        m.away_player_4 = p.player_api_id OR\n        m.away_player_5 = p.player_api_id OR\n        m.away_player_6 = p.player_api_id OR\n        m.away_player_7 = p.player_api_id OR\n        m.away_player_8 = p.player_api_id OR\n        m.away_player_9 = p.player_api_id OR\n        m.away_player_10 = p.player_api_id OR\n        m.away_player_11 = p.player_api_id\n)\nSELECT SUM(away_team_goal) AS total_away_goals\nFROM away_matches;",
            "SELECT SUM(m.away_team_goal) AS total_away_goals\nFROM Match m\nINNER JOIN Player p ON p.player_api_id = m.away_player_5\nWHERE p.player_name IN ('Daan Smith', 'Filipe Ferreira')"
        ],
        "rule_sql": [
            "SELECT SUM(m.away_team_goal) AS total_away_goals\nFROM Player p\nJOIN Match m ON p.player_api_id = m.away_player_5\nWHERE p.player_name IN ('Daan Smith', 'Filipe Ferreira')"
        ]
    },
    "93": {
        "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
        "amends": [
            "Do use `COUNT(T1.client_id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do reference the table as `T1` and `T2` instead of `c` and `d` for consistent aliasing. Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do change the case of the region filter to `'north Bohemia'` (lowercase 'n') instead of `'North Bohemia'` to match the actual data format. The amended query now correctly counts male customers from the north Bohemia district with high salary thresholds while maintaining the same logical behavior."
        ],
        "rules": [
            "1) When counting customers: use COUNT(T1.client_id) instead of COUNT(*) to count specific non-null values rather than all rows.\n2) When referencing tables: use T1 for the client table and T2 for the district table for consistent aliasing.\n3) When joining tables: use INNER JOIN instead of JOIN to explicitly specify the join type.\n4) When filtering by region: use 'north Bohemia' (lowercase 'n') instead of 'North Bohemia' to match the actual data format.\n5) When counting male customers from north Bohemia with high salary: filter where T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000.\nOutput columns (ordered): COUNT(T1.client_id) AS male_customers_north_bohemia_high_salary"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS male_customers_north_bohemia_high_salary\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.gender = 'M' AND d.A3 = 'North Bohemia' AND d.A11 > 8000;",
            "SELECT COUNT(T1.client_id) \nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'M' \nAND LOWER(T2.A3) = 'north bohemia' \nAND T2.A11 > 8000;"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.client_id) AS male_customers_north_bohemia_high_salary\nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'M' \nAND T2.A3 = 'north Bohemia' \nAND T2.A11 > 8000"
        ]
    },
    "1259": {
        "question": "Please list the diseases of the patients born after 1985-1-1 and have a normal Rhuematoid Factor.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > '1985-01-01'",
        "amends": [],
        "rules": [
            "diseases refers to Diagnosis; born after 1985/1/1 refers to YEAR(Birthday) > = 1985; normal Rhuematoid Factor refers to RA IN('-', '+-');"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Birthday >= '1985-01-01'\nAND l.RA IN('-', '+-');"
        ],
        "rule_sql": []
    },
    "347": {
        "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
        "amends": [
            "Do use `INNER JOIN` instead of `LEFT JOIN` to ensure only matching records are returned. Do reference the joined table as `T2` instead of `r` for the text column. Do use table aliases `T1` and `T2` consistently throughout the query instead of mixing aliased and non-aliased references. Do remove the column alias `ruling_text` for the text column instead of keeping it. The amended query now correctly returns only cards that have corresponding rulings, matching the RIGHT_SQL's behavior.",
            "Do select `T1.id` and `T1.hasContentWarning` instead of `T1.name`, `T1.artist`, and the CASE expression for property_status. Do remove the entire CASE expression checking for NULL or empty power, toughness, manaCost, and convertedManaCost instead of including it. Do change the artist filter to `Stephen Daniele` instead of `Stephen Daniel` to match the correct spelling. Do keep the `INNER JOIN` on `T1.uuid = T2.uuid` unchanged. The amended query now correctly selects only the required columns and uses the proper artist name filter, matching the RIGHT_SQL's behavior.",
            "Do maintain the same column selection order `T1.id, T2.text, T1.hasContentWarning` instead of reordering to `T1.id, T1.hasContentWarning, T2.text`. Do add the explicit table alias `AS T1` instead of omitting it. The join condition, table sources, and WHERE filter remain identical with no changes needed to the INNER JOIN on `T1.uuid = T2.uuid` or the artist filter. The amended query now correctly matches the RIGHT_SQL's behavior with identical column output and logic."
        ],
        "rules": [
            "1) When joining cards and rulings tables: use INNER JOIN to ensure only matching records are returned, linking rows where T1.uuid = T2.uuid exactly. 2) When the question asks for cards illustrated by Stephen Daniel: filter T1.artist to exactly match 'Stephen Daniele' (case-sensitive). 3) When describing the text of the ruling: include T2.text column without any alias. 4) When checking for missing or degraded properties: include T1.hasContentWarning column to indicate content warnings. 5) When selecting output columns: include T1.id, T2.text, and T1.hasContentWarning in that order. 6) When using table aliases: consistently use T1 for cards table and T2 for rulings table throughout the query. Output columns (ordered): T1.id, T2.text, T1.hasContentWarning",
            "1) When the question asks for cards illustrated by Stephen Daniel: filter rows where T1.artist equals 'Stephen Daniele' exactly (matching the correct spelling).\n2) When combining cards and rulings tables: link rows where T1.uuid equals T2.uuid exactly and keep only matching pairs (inner match).\n3) When describing card properties: select T1.id and T1.hasContentWarning instead of name, artist, or property status case expressions.\n4) When checking for missing or degraded properties: do not include case expressions checking for NULL or empty power, toughness, manaCost, or convertedManaCost values.\n5) Output columns (ordered): T1.id, T1.hasContentWarning, T2.text",
            "1) When the question asks for cards illustrated by Stephen Daniel: filter rows where T1.artist equals 'Stephen Daniele' exactly. 2) When combining cards and rulings tables: link rows where T1.uuid equals T2.uuid exactly and keep only matching pairs (inner match). 3) When describing card properties: include T1.id, T2.text, and T1.hasContentWarning in the output. 4) When checking for missing or degraded properties: include T1.hasContentWarning to indicate content warning status. 5) Output columns (ordered): T1.id, T2.text, T1.hasContentWarning"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.id, r.text AS ruling_text, c.hasContentWarning\nFROM cards c\nLEFT JOIN rulings r ON c.uuid = r.uuid\nWHERE c.artist = 'Stephen Daniele';\n",
            "SELECT T1.name, T1.artist, T2.text, \n       CASE \n           WHEN T1.power IS NULL OR T1.power = '' THEN 'Missing power' \n           WHEN T1.toughness IS NULL OR T1.toughness = '' THEN 'Missing toughness' \n           WHEN T1.manaCost IS NULL OR T1.manaCost = '' THEN 'Missing mana cost' \n           WHEN T1.convertedManaCost IS NULL THEN 'Missing converted mana cost' \n           ELSE 'No missing or degraded properties' \n       END AS property_status\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniel';",
            "SELECT T1.id, T1.hasContentWarning, T2.text\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele';",
            "SELECT T1.id, T2.text, T1.hasContentWarning\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele';"
        ],
        "rule_sql": [
            "SELECT T1.id, T2.text, T1.hasContentWarning\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele';"
        ]
    },
    "71": {
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "amends": [],
        "rules": [
            "When magent is equal to 0 in the database, it means ths school doesn't offer a magnet program."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.`District Code`\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.City = 'Fresno' AND s.Magnet != 1;"
        ],
        "rule_sql": []
    },
    "858": {
        "question": "Which country is the constructor which got 1 point in the race No. 24 from?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 24 AND T1.points = 1",
        "amends": [],
        "rules": [
            "race number refers to raceId;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.nationality \nFROM constructors c \nJOIN constructorResults cr ON c.constructorId = cr.constructorId \nWHERE cr.raceId = 24 AND cr.points = 1;"
        ],
        "rule_sql": []
    },
    "968": {
        "question": "What is reference name of Robert Kubica?",
        "db_id": "formula_1",
        "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica'",
        "amends": [],
        "rules": [
            "reference name refers to driverRef;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';"
        ],
        "rule_sql": []
    },
    "655": {
        "question": "Write down the related posts titles and link type IDs of the post \"What are principal component scores?\".",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T3.Title, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId INNER JOIN posts AS T3 ON T2.RelatedPostId = T3.Id WHERE T1.Title = 'What are principal component scores?'",
        "amends": [],
        "rules": [
            "Title = 'What are principal component scores?';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Title, pl.LinkTypeId\nFROM postLinks pl\nJOIN posts p ON pl.RelatedPostId = p.Id\nWHERE pl.PostId = (SELECT Id FROM posts WHERE Title = 'What are principal component scores?');"
        ],
        "rule_sql": []
    },
    "1499": {
        "question": "What is the biggest monthly consumption of the customers who use euro as their currency?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUM(T2.Consumption) / 12 AS MonthlyConsumption FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY MonthlyConsumption DESC LIMIT 1",
        "amends": [
            "Do calculate `SUM(T2.Consumption) / 12` as `MonthlyConsumption` instead of `MAX(ym.Consumption)` as `BiggestMonthlyConsumption`. Do use `INNER JOIN` with aliases `T1` and `T2` instead of `JOIN` with aliases `c` and `ym`. Do filter on `T1.Currency = 'EUR'` instead of `c.Currency = 'euro'`. Do add `GROUP BY T1.CustomerID` instead of omitting grouping. Do add `ORDER BY MonthlyConsumption DESC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly calculates average monthly consumption per customer rather than finding the single maximum consumption value."
        ],
        "rules": [
            "1) When the question asks for \"biggest monthly consumption\": calculate the average monthly consumption per customer by summing T2.Consumption and dividing by 12, then find the maximum value. 2) When filtering by currency: use the exact literal 'EUR' instead of 'euro' for T1.Currency comparisons. 3) When calculating consumption per customer: group results by T1.CustomerID to get individual customer totals. 4) When finding the maximum value: order results by MonthlyConsumption in descending order and take only the top result. 5) When combining customer and consumption data: use an inner join where T1.CustomerID equals T2.CustomerID to match customer records with their consumption data. Output columns (ordered): MonthlyConsumption"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(ym.Consumption) AS BiggestMonthlyConsumption\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Currency = 'euro';",
            "SELECT SUM(T2.Consumption) / 12 AS MonthlyConsumption\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY T1.CustomerID\nORDER BY MonthlyConsumption DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT MAX(MonthlyConsumption) AS MonthlyConsumption\nFROM (\n    SELECT \n        c.CustomerID,\n        SUM(ym.Consumption) / 12 AS MonthlyConsumption\n    FROM \n        customers c\n    INNER JOIN \n        yearmonth ym ON c.CustomerID = ym.CustomerID\n    WHERE \n        c.Currency = 'EUR'\n    GROUP BY \n        c.CustomerID\n) AS customer_consumption"
        ]
    },
    "1500": {
        "question": "Please list the product description of the products consumed in September, 2013.",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "amends": [],
        "rules": [
            "September 2013 refers to 201309; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.Description\nFROM products p\nJOIN transactions_1k t ON p.ProductID = t.ProductID\nJOIN yearmonth ym ON t.CustomerID = ym.CustomerID AND ym.Date = '201309';"
        ],
        "rule_sql": []
    },
    "1126": {
        "question": "State the name of players who came from Belgium.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Belgium'",
        "amends": [
            "Do use `INNER JOIN` on `t1.id = t2.country_id` instead of joining through `League` and `Country` tables with separate joins. Do join `Player` directly on `t2.home_player_1 = t3.player_api_id` instead of checking against all 22 player position columns. Do remove the `DISTINCT` modifier instead of keeping it since the direct join eliminates duplicates. Do simplify the `WHERE` clause to filter directly on `t1.name = 'Belgium'` instead of the multi-table join approach. The amended query now correctly identifies players who were the home player 1 in matches from Belgium, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for players from a specific country: filter players based on matches associated with that country using the exact literal 'Belgium'.\n2) When joining Player and Country tables: use an inner join where t1.id = t2.country_id to connect players to their country associations.\n3) When identifying player participation in matches: use direct equality comparison t2.home_player_1 = t3.player_api_id instead of checking against multiple player position columns.\n4) When filtering by country name: use the exact literal comparison t1.name = 'Belgium' with proper case and punctuation.\n5) When selecting player names: avoid using DISTINCT modifier since the direct join structure naturally eliminates duplicates.\nOutput columns (ordered): t3.player_name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Match m ON p.player_api_id IN (\n    m.home_player_1, m.home_player_2, m.home_player_3, m.home_player_4, m.home_player_5,\n    m.home_player_6, m.home_player_7, m.home_player_8, m.home_player_9, m.home_player_10, m.home_player_11,\n    m.away_player_1, m.away_player_2, m.away_player_3, m.away_player_4, m.away_player_5,\n    m.away_player_6, m.away_player_7, m.away_player_8, m.away_player_9, m.away_player_10, m.away_player_11\n)\nJOIN League l ON m.league_id = l.id\nJOIN Country c ON l.country_id = c.id\nWHERE c.name = 'Belgium';",
            "SELECT DISTINCT p.player_name\nFROM Player p\nINNER JOIN Match m ON p.player_api_id = m.home_player_1\nINNER JOIN Country c ON m.country_id = c.id\nWHERE c.name = 'Belgium'"
        ],
        "rule_sql": [
            "SELECT t3.player_name\nFROM Country t1\nINNER JOIN Match t2 ON t1.id = t2.country_id\nINNER JOIN Player t3 ON t2.home_player_1 = t3.player_api_id\nWHERE t1.name = 'Belgium'\nUNION\nSELECT t3.player_name\nFROM Country t1\nINNER JOIN Match t2 ON t1.id = t2.country_id\nINNER JOIN Player t3 ON t2.away_player_1 = t3.player_api_id\nWHERE t1.name = 'Belgium'"
        ]
    },
    "1252": {
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT p.ID)` to count all matching rows rather than distinct patient IDs. Do use `T2.IGG BETWEEN 900 AND 2000` instead of separate `l.IGG > 900 AND l.IGG < 2000` conditions for inclusive range checking. Do join `Examination AS T3 ON T3.ID = T2.ID` instead of `ON p.ID = e.ID` to properly connect the examination to the laboratory record rather than directly to the patient. Do remove the unnecessary `DISTINCT` modifier from the count instead of keeping it. The amended query now correctly matches the behavior of counting patients with laboratory results in the specified IGG range who have associated examination records with symptoms present."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs.\n2) When checking for normal Ig G levels (900-2000 range): use T2.IGG BETWEEN 900 AND 2000 for inclusive range checking.\n3) When connecting examination records to laboratory records: join Examination AS T3 ON T3.ID = T2.ID to properly link examination to laboratory rather than directly to patient.\n4) When counting: remove unnecessary DISTINCT modifier from the count.\n5) When combining tables for shared entities: link rows where T3.ID = T2.ID and keep only matching pairs (inner match).\n6) When checking for symptoms: ensure T3.Symptoms IS NOT NULL to identify patients with symptoms present.\nOutput columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.IGG > 900 AND l.IGG < 2000 AND e.Symptoms IS NOT NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nJOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.IGG BETWEEN 900 AND 2000\nAND T3.Symptoms IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nJOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.IGG BETWEEN 900 AND 2000\nAND T3.Symptoms IS NOT NULL"
        ]
    },
    "391": {
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "amends": [
            "Do select only `T1.name` instead of `c.*` to return specific columns rather than all columns from the cards table. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity, though both are equivalent. Do reference tables as `T1` and `T2` with aliases instead of `c` and `fd` for consistent naming. Do remove the condition `fd.language IS NOT NULL` instead of keeping it, as this filter was unnecessarily restricting results. The amended query now correctly returns only distinct card names matching the artifact type and black color criteria without the extraneous language filter.",
            "Do use `originalType = 'Artifact'` instead of `types LIKE '%Artifact%'` for exact type matching. Do use `colors = 'B'` instead of `colors LIKE '%B%'` for exact color value comparison. Do keep the `DISTINCT` selection, `INNER JOIN` on `T1.uuid = T2.uuid`, and table aliases unchanged as they match the correct logic. The amended query now correctly filters for exact artifact type and single black color instead of pattern matching, ensuring precise results that match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for Artifact cards: filter rows where T1.originalType equals 'Artifact' exactly. 2) When the question specifies black color: filter rows where T1.colors equals 'B' exactly. 3) When combining T1 and T2 for cards with foreign data: link rows where T1.uuid equals T2.uuid exactly and keep only matching pairs (inner match). 4) When the question asks for distinct card names: return only unique values of T1.name. 5) When selecting output columns: return only T1.name instead of all columns from T1. 6) When handling foreign language translation: do not filter on T2.language being not null, as this unnecessarily restricts results. Output columns (ordered): T1.name",
            "1) When the question asks for Artifact cards: filter rows where T1.originalType equals exactly 'Artifact'. 2) When the question asks for black color cards: filter rows where T1.colors equals exactly 'B'. 3) When the question asks for cards with foreign language translation: combine T1 and T2 where T1.uuid equals T2.uuid and keep only matching pairs. 4) When the question asks for distinct card names: return unique values of T1.name. 5) Output columns (ordered): T1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.*\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.originalType = 'Artifact'\n  AND c.colors = 'B'\n  AND fd.language IS NOT NULL;",
            "SELECT DISTINCT T1.name \nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.types LIKE '%Artifact%' \nAND T1.colors LIKE '%B%'",
            "SELECT DISTINCT T1.name\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.originalType = 'Artifact'\nAND T1.colors = 'B'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.originalType = 'Artifact'\nAND T1.colors = 'B';"
        ]
    },
    "1061": {
        "question": "How many players whose first names are Adam and weigh more than 170?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE weight > 170 AND player_name LIKE 'Adam%'",
        "amends": [],
        "rules": [
            "team names refers to team_long_name; speed class refers to buildUpPlaySpeedClass; buildUpPlaySpeedClass = 'Fast';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Adam%' AND weight > 170;"
        ],
        "rule_sql": []
    },
    "200": {
        "question": "Find the triple-bonded molecules which are carcinogenic.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'",
        "amends": [
            "Do select only `T2.molecule_id` instead of including both `m.molecule_id` and `m.label`. Do use `INNER JOIN` instead of `JOIN` (which are equivalent, but the explicit keyword is preferred). Do use table aliases `T1` and `T2` instead of `b` and `m` for consistency. Do maintain the same join condition `T1.molecule_id = T2.molecule_id` instead of changing it. Do keep the same WHERE filters `T1.bond_type = '#'` and `T2.label = '+'` instead of modifying them. The amended query now correctly returns only molecule IDs that have both the specified bond type and label, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for triple-bonded molecules: filter rows where T1.bond_type equals '#' exactly. 2) When the question asks for carcinogenic molecules: filter rows where T2.label equals '+' exactly. 3) When combining bond and molecule tables: link rows where T1.molecule_id equals T2.molecule_id and keep only matching pairs (inner match). 4) When selecting output columns: include only T2.molecule_id as the result. Output columns (ordered): T2.molecule_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = '#' AND m.label = '+';",
            "SELECT T2.molecule_id\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#' AND T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT T2.molecule_id FROM bond T1 INNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'"
        ]
    },
    "42": {
        "question": "What is the type of education offered in the school who scored the highest average in Math?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.EdOpsName FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 1",
        "amends": [
            "Do use `T2.EdOpsName` with table alias instead of `s.EdOpsName` without alias. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use table aliases `T1` and `T2` instead of `sc` and `s`. Do remove the subquery with `MAX(AvgScrMath)` instead of keeping it. Do add `ORDER BY T1.AvgScrMath DESC` instead of omitting ordering. Do add `LIMIT 1` instead of using equality comparison with maximum value. The amended query now correctly retrieves the top school by math score using proper ordering and limiting instead of potentially returning multiple rows with the same maximum score value."
        ],
        "rules": [
            "1) When the question asks for the highest average in Math: rank rows by T1.AvgScrMath in descending order and keep the first 1 row.\n2) When combining T1 and T2 for shared entities: link rows where T1.cds = T2.CDSCode; keep only matching pairs (inner match).\n3) When the question asks for \"type of education offered\": output T2.EdOpsName.\n4) When handling table aliases: use T1 for satscores and T2 for schools.\n5) When the question implies ordering ties: break ties using the canonical key if shown in the amends.\nOutput columns (ordered): T2.EdOpsName"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.EdOpsName\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nWHERE sc.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores);",
            "SELECT T2.EdOpsName \nFROM satscores T1 \nINNER JOIN schools T2 ON T1.cds = T2.CDSCode \nORDER BY T1.AvgScrMath DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.EdOpsName\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 1"
        ]
    },
    "51": {
        "question": "In which mailing street address can you find the school that has the lowest average score in reading? Also give the school's name.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "amends": [
            "Do add `WHERE T1.AvgScrRead IS NOT NULL` instead of omitting it to exclude null average reading scores from consideration. Do use table aliases `T1` and `T2` instead of full table names for better readability. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. The amended query now correctly filters out null values before ordering, ensuring the lowest non-null average reading score is selected, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the lowest average score in reading: filter out rows where T1.AvgScrRead is null before ordering. 2) When combining T1 (satscores) and T2 (schools) for shared entities: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match). 3) When ordering by average reading score to find the lowest: sort rows by T1.AvgScrRead in ascending order and keep the first row. 4) When the question asks for mailing street address and school name: include both T2.MailStreet and T2.School in the output. Output columns (ordered): T2.MailStreet, T2.School"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.MailStreet, s.School\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY sc.AvgScrRead ASC\nLIMIT 1;",
            "SELECT T2.MailStreet, T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.MailStreet, T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;"
        ]
    },
    "974": {
        "question": "State the racing year which has the fastest lap time?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `res` and `r` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do select `T2.year` instead of `r.year` to maintain consistent alias usage. Do keep the `WHERE T1.fastestLapTime IS NOT NULL` filter unchanged. Do remove the `ORDER BY res.fastestLapTime ASC LIMIT 1` clause instead of keeping it, as the right query returns all qualifying records rather than just the single fastest lap. The amended query now matches RIGHT_SQL's behavior of returning all years where fastest lap times were recorded rather than just the year of the single fastest lap."
        ],
        "rules": [
            "1) When the question asks for racing years with fastest lap times: select T2.year from the races table. 2) When combining results and races tables: link rows where T1.raceId equals T2.raceId using an inner match. 3) When filtering for recorded fastest lap times: include only rows where T1.fastestLapTime is not null. 4) When the question asks for all qualifying years rather than just the fastest: return all matching records without ordering or limiting. Output columns (ordered): T2.year"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT r.year FROM results res JOIN races r ON res.raceId = r.raceId WHERE res.fastestLapTime IS NOT NULL ORDER BY res.fastestLapTime ASC LIMIT 1;",
            "SELECT T2.year\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T1.fastestLapTime IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT T2.year \nFROM results T1 \nINNER JOIN races T2 ON T1.raceId = T2.raceId \nWHERE T1.fastestLapTime IS NOT NULL \nORDER BY T1.fastestLapTime ASC \nLIMIT 1"
        ]
    },
    "1387": {
        "question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
        "db_id": "student_club",
        "ground_truth": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
        "amends": [],
        "rules": [
            "name of students means the full name; full name refers to first_name, last_name;'Yearly Kickoff' is an event name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Yearly Kickoff';"
        ],
        "rule_sql": []
    },
    "867": {
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [],
        "rules": [
            "fastest lap speed refers to MAX(fastestLapSpeed);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.nationality\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE r.raceId = 933\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "963": {
        "question": "How many French drivers who obtain the laptime less than 02:00.00?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 on T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120",
        "amends": [
            "Do use `COUNT(T1.driverId)` without DISTINCT instead of `COUNT(DISTINCT d.driverId)` to count all qualifying rows rather than unique drivers. Do reference tables as `T1` and `T2` with explicit aliases instead of `d` and `l` for clarity. Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do convert the time string using `CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000` instead of directly comparing `milliseconds` to properly parse the time format. Do remove the alias `AS french_drivers_with_fast_lap` instead of keeping it since the result column is not named in the target query. The amended query now correctly handles time conversion from string format and counts all qualifying lap time records rather than distinct drivers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting French drivers with laptimes less than 02:00.00: use COUNT(T1.driverId) without DISTINCT to count all qualifying rows rather than unique drivers.\n2) When joining drivers and laptimes tables: use INNER JOIN between T1 and T2 where T1.driverId = T2.driverId to keep only matching pairs.\n3) When filtering by nationality: use T1.nationality = 'French' with exact case and spacing.\n4) When comparing laptime to 02:00.00: convert the time string using CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000 instead of directly comparing milliseconds to properly parse the time format.\n5) When producing output: do not include column aliases like AS french_drivers_with_fast_lap since the result column is not named in the target query.\nOutput columns (ordered): COUNT(T1.driverId)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT d.driverId) AS french_drivers_with_fast_lap\nFROM drivers d\nJOIN lapTimes l ON d.driverId = l.driverId\nWHERE d.nationality = 'French' AND l.milliseconds < 120000;",
            "SELECT COUNT(T1.driverId)\nFROM drivers T1\nINNER JOIN lapTimes T2 ON T1.driverId = T2.driverId\nWHERE T1.nationality = 'French'\nAND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120.0"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.driverId) \nFROM drivers T1 \nINNER JOIN laptimes T2 ON T1.driverId = T2.driverId \nWHERE T1.nationality = 'French' \nAND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120.0"
        ]
    },
    "915": {
        "question": "Which country is the oldest driver from?",
        "db_id": "formula_1",
        "ground_truth": "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1",
        "amends": [],
        "rules": [
            "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality FROM drivers WHERE dob = (SELECT MIN(dob) FROM drivers);"
        ],
        "rule_sql": []
    },
    "376": {
        "question": "What are the card layout of cards with keyword of flying?",
        "db_id": "card_games",
        "ground_truth": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it, as the query logic ensures uniqueness through the exact match condition. Do use exact equality comparison `keywords = 'Flying'` instead of the pattern matching `LIKE '%flying%'` to precisely match the literal string value rather than performing a case-insensitive substring search. Do capitalize the string literal `'Flying'` instead of using lowercase `'flying'` to match the exact case of the stored data. The amended query now correctly retrieves cards with exactly the 'Flying' keyword rather than any card containing 'flying' as a substring, ensuring precise matching behavior."
        ],
        "rules": [
            "1) When the question asks for card layout of cards with keyword of flying: use exact equality comparison keywords = 'Flying' instead of pattern matching to precisely match the literal string value. 2) When matching string literals: capitalize the string literal exactly as 'Flying' instead of using lowercase to match the exact case of the stored data. 3) When ensuring uniqueness in results: remove DISTINCT modifier as the query logic ensures uniqueness through the exact match condition. 4) Output columns (ordered): layout"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%flying%';",
            "SELECT layout FROM cards WHERE keywords = 'Flying';"
        ],
        "rule_sql": [
            "SELECT layout FROM cards WHERE keywords = 'Flying';"
        ]
    },
    "180": {
        "question": "Please provide a list of clients who were born between 1983 and 1987 and whose account branch is in East Bohemia, along with their IDs.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.client_id, T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id and T4.account_id = T3.account_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'",
        "amends": [
            "Do select both `client_id` and `account_id` instead of only `client_id`. Do join `district` directly to `client` via `district_id` instead of through the account-disposition chain. Do use `INNER JOIN` with `T1.district_id = T2.district_id` instead of joining district through account. Do add the join condition `T4.account_id = T3.account_id` to the account join instead of only joining on district_id. Do filter on `T2.A3 = 'east Bohemia'` instead of `di.A2 = 'East Bohemia'` with corrected case sensitivity. Do use `STRFTIME('%Y', T1.birth_date)` to extract year and compare against string years '1983' to '1987' instead of date range filtering with `BETWEEN` on full dates. The amended query now correctly handles the district filtering through proper table relationships and year extraction for birth date comparison."
        ],
        "rules": [
            "1) When the question asks for clients born between 1983 and 1987: extract the year from T1.birth_date using STRFTIME('%Y', T1.birth_date) and compare against string years '1983' to '1987' inclusive.\n2) When the question asks for clients whose account branch is in East Bohemia: filter on T2.A3 = 'east Bohemia' with exact case sensitivity.\n3) When combining client and district tables: link rows where T1.district_id = T2.district_id using INNER JOIN to keep only matching pairs.\n4) When combining account and disposition tables: add the join condition T4.account_id = T3.account_id to properly link these tables.\n5) When selecting output columns: include both client_id and account_id instead of only client_id.\n6) Output columns (ordered): T1.client_id, T4.account_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE c.birth_date BETWEEN '1983-01-01' AND '1987-12-31'\nAND di.A2 = 'East Bohemia';",
            "SELECT T1.client_id, T3.account_id\nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nINNER JOIN disp T4 ON T1.client_id = T4.client_id\nINNER JOIN account T3 ON T4.account_id = T3.account_id\nWHERE STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'\nAND T2.A3 = 'east Bohemia';"
        ],
        "rule_sql": [
            "SELECT T1.client_id, T4.account_id\nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nINNER JOIN disp T3 ON T1.client_id = T3.client_id\nINNER JOIN account T4 ON T3.account_id = T4.account_id\nWHERE STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'\nAND T2.A3 = 'east Bohemia';"
        ]
    },
    "1307": {
        "question": "Please list the patient's ID if he or she has an abnormal level of red blood cell and is followed at the outpatient clinic.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RBC <= 3.5 OR T2.RBC >= 6) AND T1.Admission = '-'",
        "amends": [],
        "rules": [
            "RBC < = 3.5 or RBC > = 6.0 means the patient has an abnormal level of red blood cell; 3.5 < RBC < 6.0 means the patient has a normal level of red blood cell; followed at the outpatient clinic refers to Admission = '-';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE (L.RBC <= 3.5 OR L.RBC >= 6.0) AND P.Admission = '-';"
        ],
        "rule_sql": []
    },
    "694": {
        "question": "Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T3.Text, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T2.Title = 'Analysing wind data with R' ORDER BY T1.CreationDate DESC LIMIT 10",
        "amends": [
            "Do join `users` with `posts` on `T1.Id = T2.OwnerUserId` instead of directly joining `comments` with `users`, and then join `comments` with `posts` on `T2.Id = T3.PostId` instead of using a subquery. Do filter on `T2.Title` directly in the WHERE clause instead of using a subquery to find the PostId. Do order by `T1.CreationDate` instead of `c.CreationDate` to sort by user creation date rather than comment creation date. Do use table aliases `T1`, `T2`, and `T3` consistently instead of mixed aliasing. The amended query now correctly retrieves comments for the specific post by joining through the proper relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for comments to a specific post by title: filter posts using the exact literal 'Analysing wind data with R' for T2.Title. 2) When combining users, posts, and comments tables: link T1 (users) to T2 (posts) where T1.Id equals T2.OwnerUserId, then link T2 to T3 (comments) where T2.Id equals T3.PostId, keeping only matching pairs. 3) When ordering results by creation date: sort by T1.CreationDate in descending order to get the latest entries. 4) When limiting results to the top K items: keep the first 10 rows after sorting. 5) When selecting output columns: include T3.Text and T1.DisplayName. Output columns (ordered): T3.Text, T1.DisplayName"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.Text, u.DisplayName\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE c.PostId = (SELECT Id FROM posts WHERE Title = 'Analysing wind data with R')\nORDER BY c.CreationDate DESC\nLIMIT 10;",
            "SELECT T3.Text, T1.DisplayName\nFROM users T1\nJOIN posts T2 ON T1.Id = T2.OwnerUserId\nJOIN comments T3 ON T2.Id = T3.PostId\nWHERE T2.Title = 'Analysing wind data with R'\nORDER BY T1.CreationDate DESC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT c.Text, u.DisplayName\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nJOIN users u ON c.UserId = u.Id\nWHERE p.Title = 'Analysing wind data with R'\nORDER BY c.CreationDate DESC\nLIMIT 10"
        ]
    },
    "101": {
        "question": "List out the accounts who have the earliest trading date in 1995 ?",
        "db_id": "financial",
        "ground_truth": "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1",
        "amends": [
            "Do select only `account_id` instead of multiple columns including `account_id`, `district_id`, `frequency`, and `date`. Do query from `trans` table only instead of joining `account` and `trans` tables. Do use a simple `WHERE` filter with `STRFTIME('%Y', date) = '1995'` instead of a subquery to find the minimum date and additional join conditions. Do add `ORDER BY date ASC LIMIT 1` to get the earliest transaction instead of using a subquery to find the minimum date. Do remove the unnecessary table join and multiple column selection instead of keeping the complex structure. The amended query now correctly returns the account_id of the earliest transaction from 1995, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for accounts with the earliest trading date in a specific year: select only the account_id column from the trans table instead of multiple columns from joined tables. 2) When filtering for transactions from a specific year (1995): use STRFTIME('%Y', date) = '1995' to filter rows to only those from the year 1995. 3) When finding the earliest transaction: order rows by date in ascending order and take the first row using LIMIT 1 instead of using subqueries to find minimum dates. 4) When the question asks for accounts with specific transaction properties: query from the trans table directly instead of joining with account table when account information is not needed. 5) Output columns (ordered): account_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.account_id, a.district_id, a.frequency, a.date\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nWHERE t.date = (SELECT MIN(date) FROM trans WHERE strftime('%Y', date) = '1995')\nAND strftime('%Y', t.date) = '1995';",
            "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1"
        ]
    },
    "972": {
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "amends": [],
        "rules": [
            "born in 1971 refers to year(dob) = 1971; has the fastest lap time refers to fastestLapTime has values"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverId, d.code\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE strftime('%Y', d.dob) = '1971'\nAND r.fastestLapTime IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "292": {
        "question": "Identify the atoms belong to the molecule with ID between TR010 to TR050 that contain the element carbon.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'c'",
        "amends": [
            "Do select only `atom_id` instead of including `molecule_id` and `element` in the SELECT list. Do remove the JOIN with `molecule` table instead of keeping it. Do use `BETWEEN 'TR010' AND 'TR050'` for molecule_id filtering instead of `substr(m.molecule_id, 3, 3) >= 10 AND substr(m.molecule_id, 3, 3) <= 50`. Do apply the molecule_id filter directly to the atom table instead of through a joined table. Do use table alias `T` instead of `a`. The amended query now correctly filters atom records by molecule_id range and element without unnecessary joins or column selections.",
            "Do use table alias `T` for the `atom` table instead of omitting it. Do reference `T.atom_id` in the SELECT list instead of just `atom_id`. Do change the element filter to `T.element = 'c'` instead of `element = 'carbon'` to match the correct value format. Do maintain the same `BETWEEN 'TR010' AND 'TR050'` predicate on `T.molecule_id` as in the original query. The amended query now correctly uses table aliasing and the proper element value format while preserving the same filtering logic."
        ],
        "rules": [
            "1) When the question asks for atoms belonging to molecules with IDs in a specific range: filter the atom table using the exact molecule_id range specified in the question with BETWEEN 'TR010' AND 'TR050'.\n2) When the question specifies atoms containing a particular element: filter for atoms where the element column equals exactly 'carbon' (not 'c').\n3) When selecting output columns for atom identification: include only the atom_id column to identify the atoms, not additional columns like molecule_id or element.\n4) When the schema shows that molecule filtering can be done directly on the atom table: apply molecule_id filters directly to the atom table without joining to the molecule table.\n5) When using table aliases: use the alias T for the atom table as specified in the amends.\n6) Output columns (ordered): T.atom_id",
            "1) When the question asks for atoms belonging to molecules with IDs in a specific range: filter rows where T.molecule_id is between 'TR010' and 'TR050' inclusive. 2) When the question specifies atoms containing the element carbon: filter rows where T.element equals 'c' exactly. 3) When selecting output columns: include T.atom_id in the result set. 4) When using table references: always use the alias T for the atom table. 5) Output columns (ordered): T.atom_id"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.atom_id, a.molecule_id, a.element\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE substr(m.molecule_id, 3, 3) >= 10 AND substr(m.molecule_id, 3, 3) <= 50\nAND a.element = 'c';",
            "SELECT atom_id FROM atom WHERE molecule_id BETWEEN 'TR010' AND 'TR050' AND element = 'carbon'",
            "SELECT T.atom_id FROM atom T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'c'"
        ],
        "rule_sql": [
            "SELECT T.atom_id FROM atom T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'carbon'"
        ]
    },
    "707": {
        "question": "Among the posts with views ranging from 100 to 150, what is the comment with the highest score?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Text FROM comments WHERE PostId IN ( SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150 ) ORDER BY Score DESC LIMIT 1",
        "amends": [
            "Do select only `Text` instead of including `Id`, `Score`, `CreationDate`, and `UserDisplayName`. Do remove the explicit `JOIN` with `posts` table instead of keeping it. Do use a subquery with `PostId IN` instead of a table join. Do keep the `ViewCount BETWEEN 100 AND 150` filter but move it to the subquery instead of the main WHERE clause. Do maintain `ORDER BY Score DESC` and `LIMIT 1` without changes. The amended query now correctly returns only the comment text from posts with the specified view count range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the comment with the highest score among posts with views ranging from 100 to 150: select only the Text column from comments instead of including Id, Score, CreationDate, and UserDisplayName. 2) When filtering comments based on posts with specific view counts: use a subquery with PostId IN instead of an explicit JOIN with the posts table. 3) When applying the view count range filter: use ViewCount BETWEEN 100 AND 150 in the subquery instead of the main WHERE clause. 4) When ordering results to find the highest score: maintain ORDER BY Score DESC and LIMIT 1 without changes. 5) Output columns (ordered): Text"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Id, c.Text, c.Score, c.CreationDate, c.UserDisplayName\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.ViewCount BETWEEN 100 AND 150\nORDER BY c.Score DESC\nLIMIT 1;",
            "SELECT Text\nFROM comments\nWHERE PostId IN (\n    SELECT Id\n    FROM posts\n    WHERE ViewCount BETWEEN 100 AND 150\n)\nORDER BY Score DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Text FROM comments WHERE PostId IN (SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150) ORDER BY Score DESC LIMIT 1;"
        ]
    },
    "1264": {
        "question": "Among the patients have blood clots in veins, how many of them have a normal level of complement 4?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C4 > 10 AND T1.Diagnosis = 'APS'",
        "amends": [
            "Do use `T1.ID` as the count column instead of `P.ID`. Do join only `Laboratory AS T2` instead of joining both `Examination` and `Laboratory` tables. Do remove the `Examination` table and its `Thrombosis = 1` condition instead of including them. Do add filter `T1.Diagnosis = 'APS'` instead of omitting it. Do use `INNER JOIN` with alias `T2` instead of `JOIN` with alias `L`. Do reference `T2.C4 > 10` instead of `L.C4 > 10`. The amended query now correctly counts patients with APS diagnosis who have elevated C4 levels, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for patients with blood clots in veins: filter T1 using T1.Diagnosis = 'APS' exactly as specified. 2) When counting patients with a normal level of complement 4: use T2.C4 > 10 as the condition for normal C4 levels. 3) When combining patient and laboratory data: link rows where T1.ID = T2.ID using inner match only. 4) When counting distinct patients: use T1.ID as the counting key. 5) Output columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nJOIN Laboratory L ON P.ID = L.ID\nWHERE E.Thrombosis = 1 AND L.C4 > 10;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'APS' \nAND T2.C4 > 10"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'APS' \nAND T2.C4 > 10"
        ]
    },
    "473": {
        "question": "Is the set of cards with Adarkar Valkyrie only available outside the United States?",
        "db_id": "card_games",
        "ground_truth": "SELECT IIF(isForeignOnly = 1, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Adarkar Valkyrie'",
        "amends": [
            "Do use `IIF(isForeignOnly = 1, 'YES', 'NO')` instead of selecting `s.isForeignOnly` directly to transform the boolean value into human-readable text. Do use `INNER JOIN` with explicit table aliases `T2` for sets and `T1` for cards instead of implicit aliases `s` and `c`. Do specify the join condition as `T2.code = T1.setCode` instead of `c.setCode = s.code` to maintain the same logical relationship but with clearer table reference. Do reference the card name filter as `T1.name` instead of `c.name` to match the explicit alias convention. The amended query now correctly transforms the boolean flag into a readable 'YES'/'NO' response while maintaining the same join logic and filtering behavior."
        ],
        "rules": [
            "1) When the question asks about card availability outside a specific country: use IIF(T2.isForeignOnly = 1, 'YES', 'NO') to transform the boolean value into human-readable text. 2) When joining cards and sets tables: use INNER JOIN with T1 for cards and T2 for sets, linking rows where T2.code = T1.setCode. 3) When filtering for a specific card name: use T1.name = 'Adarkar Valkyrie' with exact case and spacing. 4) When handling boolean flags: do not output raw boolean values but convert them to 'YES'/'NO' text responses. 5) When using table aliases: maintain T1 for cards and T2 for sets consistently throughout the query. Output columns (ordered): IIF(T2.isForeignOnly = 1, 'YES', 'NO')"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.isForeignOnly \nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE c.name = 'Adarkar Valkyrie';",
            "SELECT IIF(T2.isForeignOnly = 1, 'YES', 'NO') AS is_available_outside_us\nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Adarkar Valkyrie';"
        ],
        "rule_sql": [
            "SELECT IIF(T2.isForeignOnly = 1, 'YES', 'NO') \nFROM cards T1 \nINNER JOIN sets T2 ON T2.code = T1.setCode \nWHERE T1.name = 'Adarkar Valkyrie'"
        ]
    },
    "753": {
        "question": "Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.",
        "db_id": "superhero",
        "ground_truth": "SELECT DISTINCT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'",
        "amends": [],
        "rules": [
            "height from 170 to 190 refers to height_cm BETWEEN 170 AND 190; no eye color refers to colour = 'No Colour'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.height_cm BETWEEN 170 AND 190\nAND c.colour = 'No Colour';"
        ],
        "rule_sql": []
    },
    "1119": {
        "question": "How many home team goal have been scored by Aaron Lennon?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_9 WHERE t1.player_name = 'Aaron Lennon'",
        "amends": [
            "Do use `INNER JOIN` on `t1.player_api_id = t2.away_player_9` instead of multiple `OR` conditions across all home players. Do reference `away_player_9` instead of checking all home player positions. Do remove the alias `total_home_goals` instead of keeping it. Do use table aliases `t1` and `t2` instead of single-letter aliases. The amended query now correctly matches the RIGHT_SQL's behavior by focusing on the specific away player position rather than incorrectly checking all home player positions.",
            "Do use `SUM(t2.home_team_goal)` instead of `COUNT(*)` to sum goals instead of counting matches. Do specify `Player AS t1` instead of omitting the alias keyword. Do reference `match AS t2` instead of `Match t2` with proper casing and alias syntax. Do remove the condition `t2.away_team_goal > 0` instead of keeping it, as the sum should include all matches regardless of goal count. The amended query now correctly sums home team goals for matches where Aaron Lennon played as away player 9, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for home team goals scored by a specific player: use the exact player name literal 'Aaron Lennon' to filter players. 2) When combining Player and Match tables: link rows where t1.player_api_id equals t2.away_player_9 using an inner match. 3) When counting home team goals: sum the values from t2.home_team_goal column. 4) When the amends specify table aliases: use t1 for Player table and t2 for Match table. 5) When the amends show a specific player position reference: use away_player_9 instead of checking multiple home player positions. 6) Output columns (ordered): the sum of t2.home_team_goal",
            "1) When the question asks for \"how many home team goals\" for a specific player: use SUM(t2.home_team_goal) instead of COUNT(*) to sum the actual goal values rather than counting matches.\n2) When referencing the Player table: use the exact alias syntax \"Player AS t1\" with proper casing and the AS keyword.\n3) When referencing the Match table: use the exact alias syntax \"match AS t2\" with proper lowercase casing and the AS keyword.\n4) When filtering for a specific player name: use the exact literal 'Aaron Lennon' with proper casing and quotes.\n5) When joining Player and Match tables: link rows where t1.player_api_id equals t2.away_player_9 exactly as specified.\n6) When summing goals: do not apply conditions like t2.away_team_goal > 0, as the sum should include all matches regardless of goal count.\nOutput columns (ordered): SUM(t2.home_team_goal)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(M.home_team_goal) AS total_home_goals\nFROM Match M\nJOIN Player P ON (M.home_player_1 = P.player_api_id OR M.home_player_2 = P.player_api_id OR M.home_player_3 = P.player_api_id OR M.home_player_4 = P.player_api_id OR M.home_player_5 = P.player_api_id OR M.home_player_6 = P.player_api_id OR M.home_player_7 = P.player_api_id OR M.home_player_8 = P.player_api_id OR M.home_player_9 = P.player_api_id OR M.home_player_10 = P.player_api_id OR M.home_player_11 = P.player_api_id)\nWHERE P.player_name = 'Aaron Lennon';",
            "SELECT COUNT(*) \nFROM Match t2\nINNER JOIN Player t1 ON t1.player_api_id = t2.away_player_9\nWHERE t1.player_name = 'Aaron Lennon' AND t2.away_team_goal > 0",
            "SELECT SUM(t2.home_team_goal) \nFROM Player AS t1 \nINNER JOIN Match AS t2 ON t1.player_api_id = t2.away_player_9 \nWHERE t1.player_name = 'Aaron Lennon'"
        ],
        "rule_sql": [
            "SELECT SUM(t2.home_team_goal) \nFROM Player AS t1 \nINNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_9 \nWHERE t1.player_name = 'Aaron Lennon'"
        ]
    },
    "1457": {
        "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
        "amends": [
            "Do select individual columns `first_name`, `last_name`, and `phone` instead of concatenating them as `full_name` and aliasing `phone` as `contact_number`. Do add `DISTINCT` to eliminate duplicate rows instead of omitting it. Do add `INNER JOIN` with `budget` table on `T1.link_to_budget = T2.budget_id` instead of omitting this table entirely. Do change the subquery to include the same joins with `budget` and `member` tables on `T1.link_to_budget = T2.budget_id` and `T3.member_id = T1.link_to_member` instead of using a simple `AVG(cost) FROM expense` without joins. The amended query now correctly matches the RIGHT_SQL's behavior by properly joining all required tables in both the main query and subquery to ensure accurate filtering based on the average cost calculation."
        ],
        "rules": [
            "1) When the question asks for full name and contact number: select individual columns \"first_name\", \"last_name\", and \"phone\" instead of concatenating them as a single column.\n2) When eliminating duplicate rows from the result: add DISTINCT to the selection.\n3) When combining tables for expense analysis: perform an INNER JOIN between expense table (T1) and budget table (T2) where T1.link_to_budget = T2.budget_id.\n4) When calculating average cost for comparison: include the same joins with budget and member tables in the subquery using T1.link_to_budget = T2.budget_id and T3.member_id = T1.link_to_member instead of using a simple average from expense table alone.\n5) When filtering expenses that exceed average cost: compare expense cost against the properly calculated average that considers all required table relationships.\nOutput columns (ordered): first_name, last_name, phone"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, m.phone AS contact_number\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost > (SELECT AVG(cost) FROM expense);",
            "SELECT DISTINCT m.first_name, m.last_name, m.phone\nFROM expense e\nINNER JOIN budget b ON e.link_to_budget = b.budget_id\nINNER JOIN member m ON e.link_to_member = m.member_id\nWHERE e.cost > (\n    SELECT AVG(e2.cost)\n    FROM expense e2\n    INNER JOIN budget b2 ON e2.link_to_budget = b2.budget_id\n    INNER JOIN member m2 ON e2.link_to_member = m2.member_id\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT m.first_name, m.last_name, m.phone\nFROM member m\nINNER JOIN expense e ON m.member_id = e.link_to_member\nINNER JOIN budget b ON e.link_to_budget = b.budget_id\nWHERE e.cost > (\n    SELECT AVG(e2.cost)\n    FROM expense e2\n    INNER JOIN budget b2 ON e2.link_to_budget = b2.budget_id\n    INNER JOIN member m2 ON e2.link_to_member = m2.member_id\n);"
        ]
    },
    "1031": {
        "question": "At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT DATETIME() - T2.birthday age FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.`date`) >= '2013' AND STRFTIME('%Y',t1.`date`) <= '2015' AND t1.sprint_speed >= 97",
        "amends": [
            "Do use `DATETIME() - T2.birthday` for age calculation instead of complex strftime arithmetic with birthday comparison. Do remove the `GROUP BY` clause instead of keeping unnecessary grouping when using `DISTINCT`. Do change from `JOIN` to explicit `INNER JOIN` instead of implicit join syntax. Do use `STRFTIME('%Y',t1.date) >= '2013' AND STRFTIME('%Y',t1.date) <= '2015'` for date range filtering instead of `BETWEEN '2013' AND '2015'`. Do add `DISTINCT` to eliminate duplicates instead of relying on GROUP BY for deduplication. Do simplify the SELECT list to only include the calculated age instead of selecting both player_name and age. The amended query now correctly calculates player ages and filters by sprint speed within the specified date range while eliminating duplicates."
        ],
        "rules": [
            "1) When calculating player age: use DATETIME() - T2.birthday instead of complex date arithmetic functions. 2) When eliminating duplicate results: use DISTINCT instead of GROUP BY for deduplication purposes. 3) When joining tables: use explicit INNER JOIN syntax instead of implicit join syntax. 4) When filtering by year range 2013 to 2015: use STRFTIME('%Y', t1.date) >= '2013' AND STRFTIME('%Y', t1.date) <= '2015' instead of BETWEEN operator. 5) When selecting output columns: include only the calculated age instead of both player name and age. 6) When filtering for sprint speed: use t1.sprint_speed >= 97 to find players with sprint speed no less than 97. Output columns (ordered): (DATETIME() - T2.birthday)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    p.player_name,\n    (strftime('%Y', 'now') - strftime('%Y', p.birthday)) - (strftime('%m-%d', 'now') < strftime('%m-%d', p.birthday)) AS current_age\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    pa.sprint_speed >= 97\n    AND strftime('%Y', pa.date) BETWEEN '2013' AND '2015'\nGROUP BY \n    p.player_api_id, p.player_name;",
            "SELECT DISTINCT (DATETIME() - T2.birthday) AS age\nFROM Player_Attributes T1\nINNER JOIN Player T2 ON T1.player_api_id = T2.player_api_id\nWHERE T1.sprint_speed >= 97\nAND STRFTIME('%Y', T1.date) >= '2013' \nAND STRFTIME('%Y', T1.date) <= '2015'"
        ],
        "rule_sql": [
            "SELECT DISTINCT (DATETIME() - T2.birthday) \nFROM Player_Attributes AS t1 \nINNER JOIN Player AS T2 ON t1.player_api_id = T2.player_api_id \nWHERE t1.sprint_speed >= 97 \nAND STRFTIME('%Y', t1.date) >= '2013' \nAND STRFTIME('%Y', t1.date) <= '2015'"
        ]
    },
    "337": {
        "question": "List the element and bond type included in the molecule with molecule ID of TR002.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.element, T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR002'",
        "amends": [],
        "rules": [
            "TR002 is the molecule id"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.element, b.bond_type\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.molecule_id = 'TR002';\n"
        ],
        "rule_sql": []
    },
    "12": {
        "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
        "db_id": "california_schools",
        "ground_truth": "SELECT MAX(CAST(T1.`Free Meal Count (Ages 5-17)` AS REAL) / T1.`Enrollment (Ages 5-17)`) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3",
        "amends": [],
        "rules": [
            "Excellence rate = NumGE1500 / NumTstTakr; Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(f.`Free Meal Count (Ages 5-17)` / f.`Enrollment (Ages 5-17)`) AS highest_eligible_free_rate\nFROM satscores s\nJOIN frpm f ON s.cds = f.CDSCode\nWHERE (s.NumGE1500 * 1.0 / s.NumTstTakr) > 0.3;"
        ],
        "rule_sql": []
    },
    "1168": {
        "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Date, STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday),T2.Birthday FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL ORDER BY T2.Birthday ASC LIMIT 1",
        "amends": [
            "Do use `T1.Date` and `STRFTIME('%Y', T2.\\`First Date\\`) - STRFTIME('%Y', T2.Birthday)` with explicit `T2.Birthday` instead of `L.Date AS \"Laboratory Work Date\"` and `(strftime('%Y', P.\"First Date\") - strftime('%Y', P.Birthday) AS \"Age at Initial Arrival\"`. Do use table aliases `Laboratory AS T1` and `Patient AS T2` instead of `Patient P` and `Laboratory L`. Do use `INNER JOIN` instead of `JOIN` while keeping the same `ON T1.ID = T2.ID` condition. Do add `T2.Birthday IS NOT NULL` filter instead of omitting it. Do change the subquery `(SELECT MIN(Birthday) FROM Patient WHERE Diagnosis = 'SJS')` to a direct `ORDER BY T2.Birthday ASC LIMIT 1` approach instead of the complex subquery comparison. Do remove the `DESC` ordering and use `ASC` instead to get the oldest patient. The amended query now correctly finds the oldest SJS patient with valid birthday data instead of potentially returning incorrect results from the subquery comparison.",
            "Do add `T2.Birthday` to the SELECT list instead of omitting it, as the RIGHT_SQL includes this column explicitly while the WRONG_SQL only calculates the age difference without selecting the actual birthday value used in the ORDER BY clause."
        ],
        "rules": [
            "1) When the question asks about the oldest patient with a specific diagnosis: find the patient with the earliest birthday among those with the exact diagnosis literal 'SJS' and ensure birthday data is available (T2.Birthday IS NOT NULL).\n2) When combining laboratory and patient data: link rows where T1.ID = T2.ID exactly and keep only matching pairs (inner match).\n3) When calculating age at initial arrival: compute the difference in years between STRFTIME('%Y', T2.\\\"First Date\\\") and STRFTIME('%Y', T2.Birthday) using the exact column tokens.\n4) When retrieving laboratory work date: use T1.Date as the exact column token for the laboratory work completion date.\n5) When handling date calculations: use the exact format STRFTIME('%Y', column) for year extraction as shown in the amends.\n6) Output columns (ordered): T1.Date, STRFTIME('%Y', T2.\\\"First Date\\\") - STRFTIME('%Y', T2.Birthday)",
            "1) When the question asks for the oldest patient: rank patients by T2.Birthday in ascending order and keep the first 1 row.\n2) When the question asks for the date of medical laboratory work: include T1.Date in the output columns.\n3) When the question asks for the patient's age at initial arrival: compute the difference between the year of T2.\"First Date\" and the year of T2.Birthday as \"Age at Initial Arrival\".\n4) When the question specifies SJS patients: filter rows where T2.Diagnosis equals 'SJS' exactly.\n5) When calculating age: ensure T2.Birthday is not null before computing age differences.\n6) When combining Laboratory and Patient tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match).\n7) When the question asks for both the date and birthday: include both T1.Date and T2.Birthday in the output columns.\nOutput columns (ordered): T1.Date, T2.Birthday, \"Age at Initial Arrival\""
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    L.Date AS \"Laboratory Work Date\",\n    (strftime('%Y', P.\"First Date\") - strftime('%Y', P.Birthday) AS \"Age at Initial Arrival\"\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.Diagnosis = 'SJS'\n    AND P.Birthday = (SELECT MIN(Birthday) FROM Patient WHERE Diagnosis = 'SJS')\nORDER BY \n    L.Date DESC\nLIMIT 1;",
            "SELECT \n    T1.Date,\n    STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday) AS \"Age at Initial Arrival\"\nFROM \n    Laboratory AS T1\nINNER JOIN \n    Patient AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.Diagnosis = 'SJS' \n    AND T2.Birthday IS NOT NULL\nORDER BY \n    T2.Birthday ASC\nLIMIT 1;",
            "SELECT \n    T1.Date,\n    STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday) AS \"Age at Initial Arrival\",\n    T2.Birthday\nFROM \n    Laboratory AS T1\nINNER JOIN \n    Patient AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.Diagnosis = 'SJS' \n    AND T2.Birthday IS NOT NULL\nORDER BY \n    T2.Birthday ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \n    T1.Date, \n    T2.Birthday, \n    (STRFTIME('%Y', T2.\"First Date\") - STRFTIME('%Y', T2.Birthday)) AS \"Age at Initial Arrival\"\nFROM \n    Laboratory T1\nINNER JOIN \n    Patient T2 ON T1.ID = T2.ID\nWHERE \n    T2.Diagnosis = 'SJS' \n    AND T2.Birthday IS NOT NULL\nORDER BY \n    T2.Birthday ASC\nLIMIT 1"
        ]
    },
    "516": {
        "question": "How many cards did Volkan Ba\u00c7\u00b5a illustrated whose foreign language is in French?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T3.id) FROM ( SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Ba\u01f5a' AND T2.language = 'French' GROUP BY T1.id ) AS T3",
        "amends": [],
        "rules": [
            "Volkan Ba\u00c7\u00b5a refers to artist = 'Volkan Ba\u01f5a'; foreign language is in French refers to language = 'French'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.id) \nFROM cards c \nJOIN foreign_data fd ON c.uuid = fd.uuid \nWHERE c.artist = 'Volkan Ba\u01f5a' AND fd.language = 'French';"
        ],
        "rule_sql": []
    },
    "1082": {
        "question": "Please list the leagues from Germany.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Germany'",
        "amends": [],
        "rules": [
            "Germany refers to Country.name = 'Germany';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE c.name = 'Germany';"
        ],
        "rule_sql": []
    },
    "26": {
        "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
        "amends": [
            "Do select `T1.School Name` instead of `s.School` as \"School Name\" and use table aliases `T1` and `T2` instead of `s` and `f`. Do join `frpm AS T1` with `schools AS T2` instead of `schools s` with `frpm f`, maintaining the same `ON T1.CDSCode = T2.CDSCode` join condition. Do filter on `T2.County = 'Monterey'` instead of `s.County = 'Monterey'` and use `T1.Free Meal Count (Ages 5-17) > 800` instead of `f.FRPM Count (Ages 5-17) > 800`. Do add the new filter `T1.School Type = 'High Schools (Public)'` instead of omitting it, and do remove the filter `f.High Grade LIKE '%12%'` instead of keeping it. The amended query now correctly filters for high schools using the school type column instead of pattern matching on grade levels and uses the proper column name for free meal counts.",
            "Do use backticks for column names like `School Name` instead of double quotes, and maintain the same column order in the SELECT list with `State` before `Zip` instead of after it. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do move the `School Type` filter to the end of the WHERE clause instead of keeping it in the middle position. The amended query now correctly matches the RIGHT_SQL's behavior with proper identifier quoting and logical clause ordering."
        ],
        "rules": [
            "1) When the question asks for high schools: filter for rows where T1.\"School Type\" = 'High Schools (Public)'.\n2) When the question mentions Monterey county: filter for rows where T2.County = 'Monterey'.\n3) When the question asks for schools with more than 800 free or reduced price meals: filter for rows where T1.\"Free Meal Count (Ages 5-17)\" > 800.\n4) When combining frpm and schools tables: link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match).\n5) When the question asks for school names and communication addresses: output T1.\"School Name\", T2.Street, T2.City, T2.State, T2.Zip.\nOutput columns (ordered): T1.\"School Name\", T2.Street, T2.City, T2.State, T2.Zip",
            "1) When the question asks for high schools in Monterey: filter T2.County to exactly 'Monterey' and T1.\"School Type\" to exactly 'High Schools (Public)'.\n2) When the question specifies more than 800 free or reduced price meals for ages 15-17: filter T1.\"Free Meal Count (Ages 5-17)\" to values greater than 800.\n3) When combining frpm and schools tables: link rows where T1.CDSCode equals T2.CDSCode using inner match.\n4) When outputting communication address: include T1.\"School Name\", T2.Street, T2.City, T2.State, T2.Zip in that exact order.\n5) When using identifier delimiters: use double quotes for column names like \"School Name\" and \"Free Meal Count (Ages 5-17)\".\n6) When ordering WHERE clause conditions: place the \"School Type\" filter at the end of the clause.\nOutput columns (ordered): T1.\"School Name\", T2.Street, T2.City, T2.State, T2.Zip"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.School AS \"School Name\", s.Street, s.City, s.State, s.Zip\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.County = 'Monterey'\n  AND f.\"High Grade\" LIKE '%12%'\n  AND f.\"FRPM Count (Ages 5-17)\" > 800;",
            "SELECT T1.\"School Name\", T2.Street, T2.City, T2.Zip, T2.State\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Monterey'\nAND T1.\"School Type\" = 'High Schools (Public)'\nAND T1.\"Free Meal Count (Ages 5-17)\" > 800;",
            "SELECT \n    T1.`School Name` AS \"School Name\",\n    T2.Street,\n    T2.City,\n    T2.State,\n    T2.Zip\nFROM \n    frpm AS T1\nINNER JOIN \n    schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE \n    T2.County = 'Monterey'\n    AND T1.`Free Meal Count (Ages 5-17)` > 800\n    AND T1.`School Type` = 'High Schools (Public)'"
        ],
        "rule_sql": [
            "SELECT T1.\"School Name\", T2.Street, T2.City, T2.State, T2.Zip\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Monterey'\nAND T1.\"Free Meal Count (Ages 5-17)\" > 800\nAND T1.\"School Type\" = 'High Schools (Public)'"
        ]
    },
    "277": {
        "question": "What are the toxicology elements associated with bond ID TR000_1_2?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR000_1_2'",
        "amends": [
            "Do select only `T1.element` instead of selecting both `a1.element` and `a2.element` with aliases. Do use `INNER JOIN` with `T1.atom_id = T2.atom_id` instead of joining twice with `c.atom_id = a1.atom_id` and `c.atom_id2 = a2.atom_id`. Do remove the second table alias `a2` and the second join condition entirely instead of including them. Do use table aliases `T1` and `T2` instead of `a1`, `a2`, and `c`. Do filter on `T2.bond_id` in the WHERE clause instead of `c.bond_id`. The amended query now correctly retrieves only the element from the first atom involved in the specified bond connection, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for toxicology elements associated with a specific bond ID: filter rows where T2.bond_id equals the exact literal 'TR000_1_2'.\n2) When combining the connected table (T2) with the atom table (T1): link rows where T1.atom_id equals T2.atom_id exactly and keep only matching pairs (inner match).\n3) When selecting elements from the atom table: output only T1.element without creating duplicate aliases for the same column.\n4) When using table aliases: use T1 for the atom table and T2 for the connected table consistently throughout the query.\n5) Output columns (ordered): T1.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR000_1_2';",
            "SELECT T1.element \nFROM connected T2 \nINNER JOIN atom T1 ON T2.atom_id = T1.atom_id \nWHERE T2.bond_id = 'TR000_1_2'"
        ],
        "rule_sql": [
            "SELECT T1.element FROM atom T1 INNER JOIN connected T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR000_1_2'"
        ]
    },
    "936": {
        "question": "Which was the fastest lap for Lewis Hamilton in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008 AND T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "amends": [
            "Do reference `fastestLap` instead of `fastestLapTime` in the SELECT list. Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `ra`, and `d` for clarity. Do specify `INNER JOIN` explicitly instead of just `JOIN` for both joins. Do correct the join condition from `r.driverId = d.driverId` to `T1.driverId = T3.driverId` to maintain proper table reference alignment. Do reorder the WHERE clause predicates to match the logical grouping of race conditions and driver conditions. The amended query now correctly retrieves the fastest lap data with proper table relationships and filtering conditions."
        ],
        "rules": [
            "1) When the question asks for \"fastest lap\" and the schema contains both \"fastestLapTime\" and \"fastestLap\" columns: use \"fastestLap\" (not \"fastestLapTime\") as the output column.\n2) When joining multiple tables for this question: use table aliases T1 for results, T2 for races, and T3 for drivers as specified in the amends.\n3) When combining driver information with results: link rows where T1.driverId equals T3.driverId exactly.\n4) When filtering for Lewis Hamilton: use both T3.forename = 'Lewis' and T3.surname = 'Hamilton' conditions.\n5) When filtering for the 2008 Australian Grand Prix: use both T2.year = 2008 and T2.name = 'Australian Grand Prix' conditions.\n6) When the question asks for \"the fastest lap\": select only the minimum value of T1.fastestLap among the filtered results.\nOutput columns (ordered): T1.fastestLap"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.fastestLapTime\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nJOIN races ra ON r.raceId = ra.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND ra.year = 2008 AND ra.name = 'Australian Grand Prix';",
            "SELECT T1.fastestLap\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nINNER JOIN drivers T3 ON T1.driverId = T3.driverId\nWHERE T2.year = 2008 \nAND T2.name = 'Australian Grand Prix' \nAND T3.forename = 'Lewis' \nAND T3.surname = 'Hamilton';"
        ],
        "rule_sql": [
            "SELECT MIN(T1.fastestLap) AS fastestLap\nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nJOIN drivers T3 ON T1.driverId = T3.driverId\nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\nAND T2.year = 2008 AND T2.name = 'Australian Grand Prix';"
        ]
    },
    "72": {
        "question": "How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1.`Academic Year` BETWEEN 2014 AND 2015",
        "amends": [],
        "rules": [
            "State Special School means EdOpsCode = 'SSS'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.\"Enrollment (Ages 5-17)\" \nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.EdOpsCode = 'SSS' \nAND s.City = 'Fremont' \nAND f.\"Academic Year\" = '2014-2015';"
        ],
        "rule_sql": []
    },
    "356": {
        "question": "How many cards have infinite power?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(*) FROM cards WHERE power = '*'",
        "amends": [],
        "rules": [
            "infinite power refers to power = '*';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE power = '*';"
        ],
        "rule_sql": []
    },
    "1124": {
        "error": "something went wrong, tool did not call.",
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "amends": [],
        "rules": [
            "tend to be attacking when their mates were doing attack moves refers to attacking_work_rate = 'high';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.attacking_work_rate = 'high';"
        ],
        "rule_sql": []
    },
    "1308": {
        "question": "Among the patients who have a normal platelet level, how many of them have other symptoms observed?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 100 AND T2.PLT < 400 AND T1.Diagnosis IS NOT NULL",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do reference `T2.PLT` instead of `L.PLT` in the WHERE clause to match the table alias change. Do reference `T1.Diagnosis` instead of `P.Diagnosis` to maintain alias consistency. The amended query now correctly counts all patient records meeting the criteria rather than distinct patient IDs, matching the RIGHT_SQL's behavior.",
            "Do change the PLT filter to `PLT > 100 AND PLT < 400` instead of `PLT BETWEEN 150 AND 450` to use open intervals rather than closed range boundaries. The amended query now correctly counts patients with platelet counts strictly between 100 and 400 rather than the inclusive 150-450 range, matching the intended logic."
        ],
        "rules": [
            "1) When counting patients who meet specific criteria: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs.\n2) When joining tables Patient and Laboratory: use INNER JOIN with the exact key equality T1.ID = T2.ID and keep only matching pairs.\n3) When referencing platelet level criteria: use T2.PLT > 100 AND T2.PLT < 400 to identify normal platelet levels.\n4) When checking for other symptoms: use T1.Diagnosis IS NOT NULL to identify patients with observed symptoms.\n5) When using table aliases: maintain T1 for Patient table and T2 for Laboratory table consistently throughout the query.\nOutput columns (ordered): COUNT(T1.ID)",
            "1) When the question asks about patients with normal platelet level: filter Laboratory records where PLT > 100 AND PLT < 400 to use open intervals rather than inclusive range boundaries. 2) When counting patients who have other symptoms observed: count distinct Patient.ID values where Diagnosis is not null. 3) When combining Patient and Laboratory tables: link rows where Patient.ID = Laboratory.ID and keep only matching pairs (inner match). 4) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.PLT > 100 AND L.PLT < 400 \nAND P.Diagnosis IS NOT NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.PLT BETWEEN 150 AND 450\nAND T1.Diagnosis IS NOT NULL",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.PLT > 100 AND T2.PLT < 400\nAND T1.Diagnosis IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.PLT > 100 AND T2.PLT < 400\nAND T1.Diagnosis IS NOT NULL"
        ]
    },
    "23": {
        "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
        "amends": [
            "Do select `T1.School` and `T1.Street` instead of `f.School Name`, `s.Street`, `s.City`, `s.State`, and `s.Zip`. Do use table aliases `T1` for `schools` and `T2` for `frpm` instead of `s` and `f`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use the join condition `T1.CDSCode = T2.CDSCode` instead of `f.CDSCode = s.CDSCode`. Do reference the calculation as `T2.Enrollment (K-12)` - `T2.Enrollment (Ages 5-17)` instead of `f.Enrollment (K-12)` - `f.Enrollment (Ages 5-17)`. The amended query now correctly selects only the school name and street columns from the appropriate tables with proper table aliasing and join specification."
        ],
        "rules": [
            "1) When the question asks for school names and street addresses: select T1.School and T1.Street as output columns. 2) When combining schools and frpm tables: link rows where T1.CDSCode = T2.CDSCode using an inner match. 3) When calculating enrollment difference between K-12 and ages 5-17: compute T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\". 4) When filtering for enrollment difference greater than 30: keep only rows where (T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\") > 30. 5) Output columns (ordered): T1.School, T1.Street"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.`School Name`, s.Street, s.City, s.State, s.Zip\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE (f.`Enrollment (K-12)` - f.`Enrollment (Ages 5-17)`) > 30;",
            "SELECT T1.School, T1.Street\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE ABS(T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\") > 30;"
        ],
        "rule_sql": [
            "SELECT T1.School, T1.Street\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE (T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\") > 30"
        ]
    },
    "922": {
        "question": "What time did the the 2010's Formula_1 race took place on the Abu Dhabi Circuit?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.date, T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2010 AND T2.name = 'Abu Dhabi Grand Prix'",
        "amends": [
            "Do select both `date` and `time` columns instead of only `time`. Do use table alias `T2` for races instead of `r`. Do use table alias `T1` for circuits instead of `c`. Do change the join condition to `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId`. Do filter on `T2.name = 'Abu Dhabi Grand Prix'` instead of `c.name = 'Abu Dhabi'`. Do remove the explicit JOIN keyword and use INNER JOIN syntax instead. The amended query now correctly retrieves both date and time for races matching the specific Grand Prix name in 2010."
        ],
        "rules": [
            "1) When the question asks for both date and time information: include both T2.date and T2.time columns in the output.\n2) When joining races and circuits tables: use T2 for races and T1 for circuits as the canonical aliases.\n3) When combining races and circuits tables: link rows where T2.circuitID = T1.circuitId exactly and keep only matching pairs (inner match).\n4) When filtering for races in the 2010's: use T2.year = 2010 to select races from the year 2010.\n5) When filtering for the Abu Dhabi Circuit: use T1.name = 'Abu Dhabi Grand Prix' exactly as specified, including the full name and proper capitalization.\n6) When handling text literals: preserve the exact string 'Abu Dhabi Grand Prix' with proper spacing and capitalization.\n7) Output columns (ordered): T2.date, T2.time"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT r.time \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE r.year = 2010 AND c.name = 'Abu Dhabi';",
            "SELECT T2.date, T2.time FROM races T2 INNER JOIN circuits T1 ON T2.circuitId = T1.circuitId WHERE T2.year = 2010 AND T2.name = 'Abu Dhabi Grand Prix'"
        ],
        "rule_sql": [
            "SELECT T2.date, T2.time\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T2.year = 2010\nAND T1.name = 'Abu Dhabi Grand Prix'"
        ]
    },
    "1325": {
        "question": "What is the most expensive item that was spent in support of club events?",
        "db_id": "student_club",
        "ground_truth": "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1",
        "amends": [
            "Do select only `expense_description` instead of selecting both `expense_description` and `MAX(cost)` with an alias. Do remove the `WHERE` filter with `LIKE` patterns instead of keeping the restrictive club event conditions. Do add `ORDER BY cost DESC` instead of omitting any ordering. Do add `LIMIT 1` instead of using aggregation to find the maximum. The amended query now correctly returns the single most expensive expense description by sorting costs in descending order and limiting to one result, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the \"most expensive item\": find the row with the highest cost value by ordering all rows by cost in descending order and keeping only the first row. 2) When selecting output columns: include only the expense_description column that describes the item. 3) When no specific filtering conditions are mentioned in the question: do not apply any WHERE clause filters based on expense_description patterns. 4) Output columns (ordered): expense_description"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT expense_description, MAX(cost) AS most_expensive_cost FROM expense WHERE expense_description LIKE '%club event%' OR expense_description LIKE '%support of club%';",
            "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1;"
        ]
    },
    "737": {
        "question": "What is Copycat's race?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'Copycat'",
        "amends": [],
        "rules": [
            "Copycat is the superhero_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.superhero_name = 'Copycat';"
        ],
        "rule_sql": []
    },
    "777": {
        "question": "What is the gender of Agent 13 hero?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'",
        "amends": [],
        "rules": [
            "Agent 13 hero refers to superhero_name = 'Agent 13';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT g.gender\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE s.superhero_name = 'Agent 13';"
        ],
        "rule_sql": []
    },
    "1516": {
        "question": "How many transactions were paid in CZK in the morning of 2012/8/26?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-26' AND T1.Time < '13:00:00' AND T2.Currency = 'CZK'",
        "amends": [],
        "rules": [
            "'2012/8/26' can be represented by '2012-08-26'; The morning refers to the time before '13:00:00'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NumberOfTransactions\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-26'\n  AND t.Time < '13:00:00'\n  AND c.Currency = 'CZK';"
        ],
        "rule_sql": []
    },
    "1528": {
        "question": "What is the percentage of \"premium\" against the overall segment in Country = \"SVK\"?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations",
        "amends": [
            "Do use `SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0))` instead of `COUNT(CASE WHEN Segment = 'premium' THEN 1 END)` to properly count only Slovakian premium stations. Do add `Country = 'SVK'` condition to the premium segment counting instead of filtering it in WHERE clause. Do use `SUM(IIF(Country = 'SVK', 1, 0))` as denominator instead of `COUNT(*)` to count only Slovakian stations. Do add explicit `CAST` to `FLOAT` instead of implicit conversion. Do remove the `WHERE` clause filter instead of keeping it since country filtering is now handled within the conditional sums. Do change case sensitivity from `'premium'` to `'Premium'` to match the correct segment value. The amended query now correctly calculates the percentage of premium stations specifically within Slovakia rather than filtering first and then calculating percentages."
        ],
        "rules": [
            "1) When the question asks for percentage of a specific segment within a specific country: compute the ratio of (stations matching both the country and segment) divided by (stations matching the country only), multiplying by 100 and casting to float.\n2) When handling country filtering for Slovakia: use the exact literal \"SVK\" for country comparisons.\n3) When handling segment values: use the exact literal \"Premium\" (with capital P) for segment comparisons, not \"premium\".\n4) When counting stations: count using the value 1 for matching conditions and 0 for non-matching conditions within conditional sums.\n5) When computing ratios: ensure both numerator and denominator count only stations from the specified country \"SVK\".\n6) When performing calculations: explicitly cast to float type to ensure proper numeric precision.\n7) Output columns (ordered): premium_percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN Segment = 'premium' THEN 1 END) * 100.0 / COUNT(*)) AS premium_percentage\nFROM \n    gasstations\nWHERE \n    Country = 'SVK';",
            "SELECT \n    CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100.0 / \n    CAST(SUM(IIF(Country = 'SVK', 1, 0)) AS FLOAT) AS Percentage\nFROM gasstations"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN Segment = 'Premium' THEN 1 ELSE 0 END) AS FLOAT) * 100.0 / \n    CAST(COUNT(*) AS FLOAT) AS premium_percentage\nFROM gasstations\nWHERE Country = 'SVK'"
        ]
    },
    "1224": {
        "question": "What is the highest total bilirubin level recorded? List out the patient details with ID, sex and birthday with that index.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T2.`T-BIL`, T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-BIL` DESC LIMIT 1",
        "amends": [
            "Do select `T-BIL` first instead of `ID` first in the column list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with `p` and `l`. Do remove the subquery filter for maximum `T-BIL` value instead of keeping it, and instead add `ORDER BY T-BIL DESC LIMIT 1` to get the single row with the highest value. Do add explicit table aliases `AS T1` and `AS T2` instead of omitting them. The amended query now correctly retrieves the patient with the highest T-BIL value by sorting and limiting rather than using a potentially problematic subquery approach that could return multiple rows if there are ties for maximum value."
        ],
        "rules": [
            "1) When the question asks for the highest value of a column: sort rows by that column in descending order and keep only the first row. 2) When combining tables Patient and Laboratory: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match). 3) When the question asks for patient details with ID, sex and birthday: include columns T1.ID, T1.SEX, and T1.Birthday in the output. 4) When the question asks for the highest total bilirubin level: include column T2.\"T-BIL\" in the output. 5) Output columns (ordered): T2.\"T-BIL\", T1.ID, T1.SEX, T1.Birthday"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, p.SEX, p.Birthday, l.`T-BIL`\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory);",
            "SELECT T2.\"T-BIL\", T1.ID, T1.SEX, T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.\"T-BIL\", T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;"
        ]
    },
    "1056": {
        "question": "What is the name of the football league in the country of Netherlands?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Netherlands'",
        "amends": [],
        "rules": [
            "name of the football league refers to League.name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE c.name = 'Netherlands';"
        ],
        "rule_sql": []
    },
    "573": {
        "question": "Write the contents of comments with a score of 17.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Text FROM comments WHERE Score = 17",
        "amends": [],
        "rules": [
            "score of 17 refers to Score = 17; contents of comments refers to Text"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Text FROM comments WHERE Score = 17;"
        ],
        "rule_sql": []
    },
    "1422": {
        "question": "State the category of events were held at MU 215.",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "amends": [
            "Do join `budget AS T2` on `T1.event_id = T2.link_to_event` instead of querying only the `event` table. Do select `T2.category` instead of `type` from the event table. Do add the `INNER JOIN` condition instead of omitting the table relationship entirely. Do keep the `DISTINCT` modifier and `WHERE` filter on `T1.location = 'MU 215'` as they were correctly implemented. The amended query now correctly retrieves distinct categories from the joined budget table rather than types from the event table alone, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for categories of events held at a specific location: select distinct T2.category from the budget table instead of type from the event table. 2) When combining event and budget tables: link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match). 3) When filtering by location 'MU 215': use the exact literal 'MU 215' with T1.location. 4) When selecting distinct values: return only unique category values from the results. 5) Output columns (ordered): T2.category"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT type FROM event WHERE location = 'MU 215';",
            "SELECT DISTINCT T2.category\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.location = 'MU 215'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.category \nFROM event T1 \nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event \nWHERE T1.location = 'MU 215'"
        ]
    },
    "142": {
        "question": "Which accounts placed orders for household payment in Pisek?",
        "db_id": "financial",
        "ground_truth": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.k_symbol = 'SIPO' AND T3.A2 = 'Pisek'",
        "amends": [
            "Do use `trans` table as the primary source instead of `order` table for filtering by `k_symbol`. Do join `account` on `trans.account_id = account.account_id` instead of joining `order` with `account` on the same column. Do maintain the same join with `district` on `account.district_id = district.district_id` instead of the original join condition. Do keep the same WHERE filter conditions for `k_symbol = 'SIPO'` and `A2 = 'Pisek'` but apply them to the correct tables. Do preserve the `DISTINCT` selection of `account_id` from the correct table. The amended query now correctly filters transactions by k_symbol instead of orders and returns the expected account results matching the right SQL's behavior."
        ],
        "rules": [
            "1) When filtering for household payment transactions: use the trans table with condition trans.k_symbol = 'SIPO' instead of the order table.\n2) When joining account information to transactions: link trans.account_id to account.account_id using exact equality.\n3) When filtering accounts by district location: join account.district_id to district.district_id using exact equality and filter for district.A2 = 'Pisek'.\n4) When selecting unique accounts: return distinct account_id values from the trans table.\n5) Output columns (ordered): trans.account_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT o.account_id\nFROM `order` o\nJOIN account a ON o.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE o.k_symbol = 'SIPO' AND d.A2 = 'Pisek';",
            "SELECT DISTINCT account.account_id\nFROM trans\nJOIN account ON trans.account_id = account.account_id\nJOIN district ON account.district_id = district.district_id\nWHERE trans.k_symbol = 'SIPO'\nAND district.A2 = 'Pisek'"
        ],
        "rule_sql": [
            "SELECT DISTINCT trans.account_id\nFROM trans\nJOIN account ON trans.account_id = account.account_id\nJOIN district ON account.district_id = district.district_id\nWHERE trans.k_symbol = 'SIPO'\nAND district.A2 = 'Pisek';"
        ]
    },
    "32": {
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "db_id": "california_schools",
        "ground_truth": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "amends": [
            "Do cast `FRPM Count (K-12)` as `REAL` in the division instead of using integer division. Do reference the table as `T1` instead of `f` and `T2` instead of `s` for the join. Do filter on `T2.SOC = 66` instead of `s.DOC = '66'` with proper numeric comparison instead of string comparison. Do remove the explicit column selection and aliases `School Name`, `FRPM Count (K-12)`, `Enrollment (K-12)`, and `Eligible Rate` instead of including them, focusing only on the calculated division result. The amended query now correctly handles numeric division and filtering while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the top 5 schools by highest free or reduced price meal count: rank rows by T1.\"FRPM Count (K-12)\" in descending order and keep the first 5 rows.\n2) When filtering schools by ownership code 66: include only rows where T2.SOC = 66 using numeric comparison.\n3) When calculating eligible free or reduced price meal rate: compute (T1.\"FRPM Count (K-12)\" / T1.\"Enrollment (K-12)\") using real number division.\n4) When combining frpm and schools tables: link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match).\n5) When handling numeric values: use real number division instead of integer division for rate calculations.\n6) When the question asks for a rate calculation: output only the calculated division result without additional columns.\nOutput columns (ordered): (T1.\"FRPM Count (K-12)\" / T1.\"Enrollment (K-12)\")"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    f.`School Name`,\n    f.`FRPM Count (K-12)`,\n    f.`Enrollment (K-12)`,\n    (f.`FRPM Count (K-12)` / f.`Enrollment (K-12)`) AS `Eligible Rate`\nFROM \n    frpm f\nJOIN \n    schools s ON f.CDSCode = s.CDSCode\nWHERE \n    s.DOC = '66'\nORDER BY \n    f.`FRPM Count (K-12)` DESC\nLIMIT 5;",
            "SELECT CAST(T1.\"FRPM Count (K-12)\" AS REAL) / T1.\"Enrollment (K-12)\" \nFROM frpm T1 \nJOIN schools T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.SOC = 66 \nORDER BY T1.\"FRPM Count (K-12)\" DESC \nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT (f.\"FRPM Count (K-12)\" / f.\"Enrollment (K-12)\") AS eligible_rate\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.SOC = 66\nORDER BY f.\"FRPM Count (K-12)\" DESC\nLIMIT 5"
        ]
    },
    "1521": {
        "question": "For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'",
        "amends": [],
        "rules": [
            "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; '2012/8/26' can be represented by '2012-08-26'; during 8:00-9:00 can be represented as Time BETWEEN '08:00:00' AND '09:00:00'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-26' \nAND t.Time BETWEEN '08:00:00' AND '09:00:00'\nAND g.Country = 'CZE';"
        ],
        "rule_sql": []
    },
    "1420": {
        "question": "State the name of major that Vice President has joined.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Vice President'",
        "amends": [],
        "rules": [
            "name of major refers to major_name; 'Vice President' is position of Student Club"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'Vice President';"
        ],
        "rule_sql": []
    },
    "46": {
        "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "amends": [
            "Do select only `School` instead of including `CDSCode`, `District`, `County`, and `Enrollment (K-12)`. Do use `INNER JOIN` with aliases `T1` and `T2` instead of `JOIN` with aliases `s` and `f`. Do join on `T1.CDSCode = T2.CDSCode` instead of `s.CDSCode = f.CDSCode`. Do filter with `T2.DOC = 31` instead of `s.DOC = '31'`, removing the string quotes. Do order by `T1.Enrollment (K-12)` instead of `f.Enrollment (K-12)`. Do limit to `1` result instead of `10`. The amended query now correctly returns only the top school by enrollment for the specified DOC code.",
            "Do select `T2.School` instead of `T1.School` to retrieve the school name from the correct table. Do use backticks for `Enrollment (K-12)` instead of double quotes to properly handle the column name with special characters. The amended query now correctly returns the school name from the schools table while maintaining the same join logic, filter condition, and sorting behavior to identify the school with the highest enrollment where DOC equals 31."
        ],
        "rules": [
            "1) When the question asks for state special schools: filter rows where T2.DOC equals 31 exactly. 2) When combining T1 and T2 for shared entities: link rows where T1.CDSCode equals T2.CDSCode exactly; keep only matching pairs (inner match). 3) When the question mentions \"highest number of enrollees\": rank rows by T1.\"Enrollment (K-12)\" in descending order and keep the first 1 row. 4) When selecting output columns: include only T1.School from the result set. 5) Output columns (ordered): T1.School",
            "1) When the question asks for state special schools: filter rows where T2.DOC equals 31 exactly as shown in the amends.\n2) When combining tables frpm and schools: link rows where T1.CDSCode equals T2.CDSCode exactly as shown in the amends and keep only matching pairs (inner match).\n3) When the question asks for \"highest number of enrollees\": rank rows by T1.`Enrollment (K-12)` in descending order and keep the first 1 row.\n4) When retrieving school names: use T2.School to get the school name from the schools table, not T1.School.\n5) When handling column names with special characters: use backticks for T1.`Enrollment (K-12)` to properly reference the column with parentheses and spaces.\nOutput columns (ordered): T2.School"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.CDSCode, s.School, s.District, s.County, f.\"Enrollment (K-12)\"\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.DOC = '31'\nORDER BY f.\"Enrollment (K-12)\" DESC\nLIMIT 10;",
            "SELECT T1.School\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.DOC = 31\nORDER BY T1.\"Enrollment (K-12)\" DESC\nLIMIT 1;",
            "SELECT T2.School\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.DOC = 31\nORDER BY T1.`Enrollment (K-12)` DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.School\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.DOC = '31'\nORDER BY T1.\"Enrollment (K-12)\" DESC\nLIMIT 1;"
        ]
    },
    "150": {
        "question": "How many accounts in North Bohemia has made a transaction with the partner's bank being AB?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.bank = 'AB' AND T1.A3 = 'north Bohemia'",
        "amends": [
            "Do use `COUNT(T2.account_id)` without DISTINCT instead of `COUNT(DISTINCT t.account_id)` to count all matching rows rather than unique accounts. Do join tables in the order `district \u2192 account \u2192 trans` instead of `trans \u2192 account \u2192 district` to properly filter by district first. Do reference `T3.bank` and `T1.A3` in the WHERE clause instead of `t.bank` and `d.A3` to match the new table aliases. Do use case-insensitive comparison `'north Bohemia'` instead of `'North Bohemia'` to match the actual data format. The amended query now correctly counts all transactions from AB bank in the north Bohemia district rather than unique accounts with such transactions."
        ],
        "rules": [
            "1) When the question asks for \"accounts\" that made transactions: count all matching rows using T2.account_id rather than counting distinct accounts. 2) When joining tables for district-based filtering: link tables in the order district \u2192 account \u2192 trans with T1 as district, T2 as account, and T3 as trans. 3) When filtering by district name: use case-insensitive comparison 'north Bohemia' instead of 'North Bohemia' for T1.A3. 4) When filtering by partner's bank: use T3.bank = 'AB' to identify transactions with the partner's bank being AB. 5) When combining tables: link T1 and T2 where T1.district_id = T2.district_id, and link T2 and T3 where T2.account_id = T3.account_id, keeping only matching pairs (inner match). 6) Output columns (ordered): COUNT(T2.account_id) AS account_count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT t.account_id) AS account_count\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE d.A3 = 'North Bohemia' AND t.bank = 'AB';",
            "SELECT COUNT(T2.account_id) \nFROM district T1 \nJOIN account T2 ON T1.district_id = T2.district_id \nJOIN trans T3 ON T2.account_id = T3.account_id \nWHERE T1.A3 = 'north Bohemia' AND T3.bank = 'AB'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.account_id) AS account_count\nFROM district T1\nJOIN account T2 ON T1.district_id = T2.district_id\nJOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T1.A3 = 'north Bohemia'\nAND T3.bank = 'AB';"
        ]
    },
    "1091": {
        "question": "How many matches were held in the Belgium Jupiler League in April, 2009?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND SUBSTR(t2.`date`, 1, 7) = '2009-04'",
        "amends": [],
        "rules": [
            "Belgium Jupiler League refers to League.name = 'Belgium Jupiler League'; in April, 2009 refers to SUBSTR(`date`, 1, 7);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS number_of_matches\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Belgium Jupiler League')\nAND date LIKE '2009-04-%';"
        ],
        "rule_sql": []
    },
    "1429": {
        "question": "What is the name of the social event that was attended by the vice president of the Student_Club located at 900 E. Washington St.?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.event_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T3.position = 'Vice President' AND T2.location = '900 E. Washington St.' AND T2.type = 'Social'",
        "amends": [],
        "rules": [
            "name of social event refers to event_name where type = 'Social'; 'Vice President' is position; located at refers to location"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nWHERE m.position = 'Vice President'\nAND e.type = 'Social'\nAND e.location = '900 E. Washington St.';"
        ],
        "rule_sql": []
    },
    "927": {
        "question": "Which driver created the fastest lap speed in a Formula_1 race? Please give both his forename and surname.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "596": {
        "question": "Which users have posted the most comments. List out the user's badge?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Name FROM badges AS T1 INNER JOIN comments AS T2 ON T1.UserId = t2.UserId GROUP BY T2.UserId ORDER BY COUNT(T2.UserId) DESC LIMIT 1",
        "amends": [
            "Do select only `Name` instead of multiple columns including `u.Id`, `u.DisplayName`, and `CommentCount`. Do use `INNER JOIN` between `badges` and `comments` instead of joining `users` to both tables separately. Do join on `T1.UserId = T2.UserId` instead of joining both tables to `users` via `u.Id = c.UserId` and `u.Id = b.UserId`. Do group by `T2.UserId` instead of grouping by `u.Id` and `u.DisplayName`. Do order by `COUNT(T2.UserId)` descending instead of ordering by `CommentCount` descending. Do limit to `1` result instead of limiting to `10` results. The amended query now correctly finds the badge name for the user with the most comments by directly joining badges and comments tables."
        ],
        "rules": [
            "1) When the question asks for users with the most comments: rank users by comment count in descending order and keep only the top 1 user.\n2) When joining badges and comments tables: link rows where T1.UserId = T2.UserId exactly and keep only matching pairs (inner match).\n3) When grouping results: organize by T2.UserId and compute the count of comments per user.\n4) When ordering results: sort by the count of T2.UserId in descending order.\n5) When limiting results: return only 1 row instead of 10.\n6) When selecting output columns: choose only the Name column from badges instead of multiple columns including user identifiers and comment counts.\nOutput columns (ordered): T1.Name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.Id, u.DisplayName, COUNT(c.Id) AS CommentCount, b.Name AS BadgeName\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nLEFT JOIN badges b ON u.Id = b.UserId\nGROUP BY u.Id, u.DisplayName\nORDER BY CommentCount DESC\nLIMIT 10;",
            "SELECT b.Name\nFROM badges b\nINNER JOIN comments c ON b.UserId = c.UserId\nGROUP BY b.UserId\nORDER BY COUNT(c.UserId) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT b.Name \nFROM badges b\nINNER JOIN comments c ON b.UserId = c.UserId\nGROUP BY c.UserId\nORDER BY COUNT(c.UserId) DESC\nLIMIT 1;"
        ]
    },
    "903": {
        "question": "How many times did Michael Schumacher won from races hosted in Sepang International Circuit?",
        "db_id": "formula_1",
        "ground_truth": "SELECT SUM(T2.wins) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId INNER JOIN circuits AS T4 ON T4.circuitId = T3.circuitId WHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher' AND T4.name = 'Sepang International Circuit'",
        "amends": [
            "Do use `SUM(T2.wins)` instead of `COUNT(*)` to aggregate actual win counts from standings data rather than counting individual race results. Do join `driverStandings AS T2` instead of `results r` to access pre-calculated win statistics rather than raw position data. Do reference `T2.wins` column instead of filtering `r.position = 1` to directly use the aggregated win count. Do remove the `r.position = 1` filter condition instead of keeping it since the win count is now sourced from standings data. Do maintain the same join structure with drivers, races, and circuits tables but with different table aliases (T1, T3, T4 instead of d, ra, c). The amended query now correctly calculates Michael Schumacher's total wins at Sepang International Circuit using the driver standings data instead of attempting to count individual race results."
        ],
        "rules": [
            "1) When the question asks for win counts of a specific driver at a specific circuit: use the pre-calculated wins column from driver standings data (T2.wins) instead of counting individual race results.\n2) When aggregating win counts: sum the wins column (SUM(T2.wins)) rather than counting rows.\n3) When joining tables for driver-circuit win analysis: link driver standings (T2) to drivers (T1) using driverId, to races using raceId, and to circuits (T4) using circuitId.\n4) When filtering for a specific driver: use exact name literals 'Michael' for forename and 'Schumacher' for surname from the drivers table (T1.forename = 'Michael' AND T1.surname = 'Schumacher').\n5) When filtering for a specific circuit: use exact circuit name literal 'Sepang International Circuit' from the circuits table (T4.name = 'Sepang International Circuit').\n6) When using driver standings data: do not apply position filters since wins are already pre-aggregated in the standings table.\n7) Output columns (ordered): SUM(T2.wins) as win_count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS win_count\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nJOIN races ra ON r.raceId = ra.raceId\nJOIN circuits c ON ra.circuitId = c.circuitId\nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher'\nAND c.name = 'Sepang International Circuit'\nAND r.position = 1;",
            "SELECT SUM(T2.wins) AS total_wins\nFROM drivers AS T1\nJOIN driverStandings AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nJOIN circuits AS T4 ON T3.circuitId = T4.circuitId\nWHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher'\nAND T4.name = 'Sepang International Circuit';"
        ],
        "rule_sql": [
            "SELECT SUM(T2.wins) AS win_count\nFROM driverStandings T2\nJOIN drivers T1 ON T2.driverId = T1.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nJOIN circuits T4 ON T3.circuitId = T4.circuitId\nWHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher'\nAND T4.name = 'Sepang International Circuit'"
        ]
    },
    "594": {
        "question": "Which user created post ID 1 and what is the reputation of this user?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Id, T2.Reputation FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.PostId = 1",
        "amends": [
            "Do select `T2.Id` and `T2.Reputation` instead of `u.DisplayName` and `u.Reputation`. Do join from `comments AS T1` instead of `posts p`. Do use `INNER JOIN users AS T2` instead of `JOIN users u`. Do join on `T1.UserId = T2.Id` instead of `p.OwnerUserId = u.Id`. Do filter with `T1.PostId = 1` instead of `p.Id = 1`. The amended query now correctly retrieves user information from comments rather than posts for the specified post ID."
        ],
        "rules": [
            "1) When the question asks about a user who created content for post ID 1: use comments table as T1 instead of posts table.\n2) When joining users table to comments: use INNER JOIN with alias T2 for users table.\n3) When linking comments to users: match rows where T1.UserId equals T2.Id exactly.\n4) When filtering for post ID 1: use T1.PostId = 1 as the filter condition.\n5) When selecting user information: output T2.Id and T2.Reputation columns.\nOutput columns (ordered): T2.Id, T2.Reputation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName, u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Id = 1;",
            "SELECT T2.Id, T2.Reputation \nFROM comments AS T1 \nINNER JOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T1.PostId = 1"
        ],
        "rule_sql": [
            "SELECT T2.Id, T2.Reputation \nFROM comments AS T1 \nINNER JOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T1.PostId = 1"
        ]
    },
    "1464": {
        "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select separate `first_name` and `last_name` columns instead of concatenating them as `full_name`. Do add joins to `event` and `attendance` tables instead of omitting them, specifically using `INNER JOIN` on `event_id = link_to_event` and `INNER JOIN` on `member_id = link_to_member` to properly connect the relationships. Do change the date format to `'2019-09-09'` instead of `'9/9/2019'` for proper date handling. Do reference tables with aliases `T3` and `T4` instead of `m` and `i` for consistency. The amended query now correctly filters income records for members who attended events on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for full names of students: output separate first_name and last_name columns instead of concatenating them as full_name.\n2) When filtering by date '9/9/2019': use the date format '2019-09-09' instead of '9/9/2019' for proper date handling.\n3) When eliminating duplicate rows: use DISTINCT to ensure each row appears only once.\n4) When combining member and income tables: link rows where T3.member_id = T4.link_to_member using an inner join.\n5) When connecting to event and attendance tables: add INNER JOIN on event_id = link_to_event and INNER JOIN on member_id = link_to_member to properly establish relationships.\n6) When referencing tables: use aliases T3 for member and T4 for income instead of m and i for consistency.\n7) Output columns (ordered): T3.first_name, T3.last_name, T4.amount"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, i.amount\nFROM member m\nJOIN income i ON m.member_id = i.link_to_member\nWHERE i.date_received = '9/9/2019';",
            "SELECT DISTINCT T3.first_name, T3.last_name, i.amount\nFROM income i\nINNER JOIN member T3 ON i.link_to_member = T3.member_id\nINNER JOIN attendance a ON T3.member_id = a.link_to_member\nINNER JOIN event e ON a.link_to_event = e.event_id\nWHERE i.date_received = '2019-09-09';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount\nFROM member T3\nINNER JOIN income T4 ON T3.member_id = T4.link_to_member\nWHERE T4.date_received = '2019-09-09'"
        ]
    },
    "1300": {
        "question": "What is the disease name of the patient who has the highest level of triglyceride within the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 ORDER BY T2.TG DESC LIMIT 1",
        "amends": [],
        "rules": [
            "disease name referse to Diagnosis; highest level of triglyceride within the normal range refers to MAX(TG < 200);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.Diagnosis\nFROM Laboratory l\nJOIN Examination e ON l.ID = e.ID\nWHERE l.TG < 200\nORDER BY l.TG DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "186": {
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "db_id": "financial",
        "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "amends": [
            "Do calculate the percentage using `CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id)` instead of `(COUNT(CASE WHEN c.gender = 'M' THEN 1 END) * 100.0 / COUNT(*))` to properly handle boolean aggregation and client counting. Do join `district AS T3` on `T1.district_id = T3.district_id` instead of omitting the district table entirely. Do add an additional join condition `T2.account_id = T4.account_id` to the `disp` table join instead of only joining on `T1.client_id = T4.client_id`. Do reference `T2.frequency` in the WHERE clause instead of `a.frequency` to align with the new table aliases. The amended query now correctly calculates the percentage of male clients by properly joining through the district relationship and ensuring accurate account-client linkages.",
            "Do use `INNER JOIN` for all table connections instead of mixing join types. Do join `district AS T3` before `account AS T2` instead of the reverse order, establishing proper district-based relationships. Do change the WHERE filter to `POPLATEK TYDNE` instead of `WEEKLY STATEMENT` to match the correct frequency condition. Do remove the alias `percentage_male_weekly_statements` instead of keeping it, as the right query returns an unnamed expression. The amended query now correctly filters for the specified account frequency and maintains proper join relationships through the district table.",
            "Do join `account AS T2` directly on `T2.district_id = T3.district_id` instead of joining through `disp AS T4` first, and do combine the `T2.account_id = T4.account_id` condition with the client join as `T1.client_id = T4.client_id AND T2.account_id = T4.account_id` instead of having separate join clauses. The amended query now correctly establishes the relationship between account and district directly while maintaining the proper connection through the disposition table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating percentages with gender conditions: use CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) instead of case-based counting to properly handle boolean aggregation and client counting.\n2) When joining client and district tables: include district AS T3 and join on T1.district_id = T3.district_id to establish the district relationship.\n3) When joining disp table: add the condition T2.account_id = T4.account_id in addition to T1.client_id = T4.client_id to ensure accurate account-client linkages.\n4) When filtering by frequency: reference T2.frequency instead of account table frequency to align with the correct table aliases.\n5) When counting clients: use T1.client_id as the counting key instead of generic counting to ensure accurate client-based calculations.\nOutput columns (ordered): percentage_male_clients",
            "1) When joining tables for client-account relationships: use INNER JOIN for all table connections to maintain proper relationships through the district table. 2) When filtering for account frequency: use the exact literal 'POPLATEK TYDNE' instead of 'WEEKLY STATEMENT' to match the correct frequency condition. 3) When computing percentage of male clients: calculate (number of rows where T1.gender = 'M') divided by (total number of rows) and multiply by 100. 4) When the query returns an aggregate expression: do not assign an alias to the result. 5) When establishing district-based relationships: join district AS T3 before account AS T2 to maintain proper join order. Output columns (ordered): the unnamed percentage expression",
            "1) When the question asks for percentage of male clients requesting weekly statements: compute (number of male clients with weekly statements) divided by (total clients with weekly statements) multiplied by 100.\n2) When identifying male clients: filter rows where T1.gender equals exactly 'M'.\n3) When identifying weekly statement requests: filter rows where T2.frequency equals exactly 'POPLATEK TYDNE'.\n4) When combining client and account tables: link rows where T1.client_id = T4.client_id AND T2.account_id = T4.account_id through the disposition table.\n5) When combining account and district tables: link rows where T2.district_id = T3.district_id directly.\n6) When counting clients: use T1.client_id as the counting key for both numerator and denominator.\n7) Output columns (ordered): the percentage value as a single result column"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.gender = 'M' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_male_clients\nFROM \n    account a\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    client c ON d.client_id = c.client_id\nWHERE \n    a.frequency = 'POPLATEK TYDNE';",
            "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) AS percentage_male_weekly_statements\nFROM client AS T1\nJOIN account AS T2 ON T1.district_id = T2.district_id\nJOIN district AS T3 ON T1.district_id = T3.district_id\nJOIN disp AS T4 ON T1.client_id = T4.client_id AND T2.account_id = T4.account_id\nWHERE T2.frequency = 'WEEKLY STATEMENT'",
            "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) \nFROM client AS T1\nINNER JOIN district AS T3 ON T1.district_id = T3.district_id\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id\nINNER JOIN account AS T2 ON T2.account_id = T4.account_id\nWHERE T2.frequency = 'POPLATEK TYDNE'",
            "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) \nFROM client AS T1\nINNER JOIN district AS T3 ON T1.district_id = T3.district_id\nINNER JOIN account AS T2 ON T2.district_id = T3.district_id\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T2.account_id = T4.account_id\nWHERE T2.frequency = 'POPLATEK TYDNE'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.client_id) AS percentage_male_clients\nFROM client AS T1\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id\nINNER JOIN account AS T2 ON T4.account_id = T2.account_id\nINNER JOIN district AS T3 ON T2.district_id = T3.district_id\nWHERE T2.frequency = 'POPLATEK TYDNE';"
        ]
    },
    "1234": {
        "question": "List the patient ID, sex and birthday who has abnormal white blood cell count. Group them by sex and list the patient by age in ascending order.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0 GROUP BY T1.SEX,T1.ID ORDER BY T1.Birthday ASC",
        "amends": [
            "Do add `DISTINCT` instead of omitting it, and do include `T1.ID` in the `GROUP BY` clause instead of grouping only by `T1.SEX`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `p` and `l`. Do reference `T2.WBC` in the WHERE condition instead of `l.WBC`. Do order by `T1.Birthday ASC` instead of calculating age with `(julianday('now') - julianday(p.Birthday)) / 365.25`. The amended query now correctly handles distinct patient records while maintaining proper grouping and ordering semantics.",
            "Do change the WHERE filter to `T2.WBC <= 3.5 OR T2.WBC >= 9.0` instead of `T2.WBC IS NOT NULL` to select patients with abnormal WBC values rather than simply those with any WBC measurement. The amended query now correctly identifies patients with WBC levels outside the normal range (3.5-9.0) instead of including all patients with any WBC measurement, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for patient information with abnormal white blood cell count: use T2.WBC \u2264 3.5 OR T2.WBC \u2265 9.0 as the condition for abnormal values.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner match.\n3) When grouping results by sex: include both T1.SEX and T1.ID in the grouping criteria to ensure distinct patient records.\n4) When ordering patients by age: use T1.Birthday ASC to sort by birthday in ascending order (youngest to oldest).\n5) When selecting patient information: ensure distinct patient records are returned by using DISTINCT on the output columns.\nOutput columns (ordered): T1.ID, T1.SEX, T1.Birthday",
            "1) When the question asks for patients with abnormal white blood cell count: filter rows where T2.WBC <= 3.5 OR T2.WBC >= 9.0 instead of checking for non-null values.\n2) When grouping by sex: organize results by T1.SEX and include T1.ID, T1.SEX, and T1.Birthday in the output.\n3) When ordering by age in ascending order: sort the results by T1.Birthday in ascending order.\n4) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n5) Output columns (ordered): T1.ID, T1.SEX, T1.Birthday"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.WBC <= 3.5 OR l.WBC >= 9.0\nGROUP BY p.SEX\nORDER BY (julianday('now') - julianday(p.Birthday)) / 365.25 ASC;",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.WBC IS NOT NULL\nGROUP BY T1.SEX, T1.ID\nORDER BY T1.Birthday ASC;",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0\nGROUP BY T1.SEX, T1.ID\nORDER BY T1.Birthday ASC"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0\nGROUP BY T1.SEX, T1.ID\nORDER BY T1.Birthday ASC;"
        ]
    },
    "1447": {
        "question": "List the name and location of events that underspend its budget.",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T1.event_name, T1.location FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 0",
        "amends": [],
        "rules": [
            "name of event refers to event_name; underspend its budget refers to remaining > 0"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name, e.location FROM event e JOIN budget b ON e.event_id = b.link_to_event WHERE b.spent < b.amount;"
        ],
        "rule_sql": []
    },
    "1052": {
        "question": "Among all the players whose weight is under 130, how many of them preferred foot in attacking is left?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.weight < 130 AND t2.preferred_foot = 'left'",
        "amends": [
            "Do use `COUNT(DISTINCT t1.id)` instead of `COUNT(*)` to avoid counting duplicate player records. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `t1` and `t2` instead of `p` and `pa` for consistency. Do reference `t1.weight` and `t2.preferred_foot` in the WHERE clause instead of `p.weight` and `pa.preferred_foot` to match the aliased table names. The amended query now correctly counts distinct players rather than all matching rows, ensuring accurate results when players have multiple attribute records."
        ],
        "rules": [
            "1) When counting players: use COUNT(DISTINCT t1.id) instead of COUNT(*) to avoid counting duplicate player records.\n2) When joining tables: use INNER JOIN explicitly for clarity between Player and Player_Attributes tables.\n3) When using table aliases: use t1 for Player table and t2 for Player_Attributes table consistently throughout the query.\n4) When referencing weight: use t1.weight instead of p.weight to match the aliased table name.\n5) When referencing preferred foot: use t2.preferred_foot instead of pa.preferred_foot to match the aliased table name.\n6) When filtering by weight: include condition t1.weight < 130 for players under 130 weight.\n7) When filtering by preferred foot: include condition t2.preferred_foot = 'left' for left-footed players.\n8) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id using inner match.\nOutput columns (ordered): left_footed_players_under_130_weight"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS left_footed_players_under_130_weight\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.weight < 130 AND pa.preferred_foot = 'left';",
            "SELECT COUNT(DISTINCT t1.id) \nFROM Player t1 \nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.weight < 130 AND t2.preferred_foot = 'left';"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT t1.id) AS left_footed_players_under_130_weight\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.weight < 130 AND t2.preferred_foot = 'left'"
        ]
    },
    "278": {
        "question": "How many of the single bond type molecules are non-carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; single bond refers to bond_type = '-';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT b.molecule_id) \nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '-' AND m.label = '-';"
        ],
        "rule_sql": []
    },
    "405": {
        "question": "How many Brazilian Portuguese translated sets are inside the Commander block?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(DISTINCT s.code)` to count set IDs rather than distinct set codes. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `s` and `st` for consistency. Do correct the language filter to `'Portuguese (Brazil)'` instead of `'Portuguese (Brasil)'` to match the proper localization. Do maintain the `T1.block = 'Commander'` filter in the WHERE clause instead of changing its position. The amended query now correctly counts Portuguese Brazilian translated Commander sets by fixing the language specification and counting methodology."
        ],
        "rules": [
            "1) When counting sets: use T1.id as the counting key instead of distinct set codes. 2) When joining tables T1 and T2: use INNER JOIN and link rows where T1.code = T2.setCode exactly. 3) When filtering for language: use the exact literal 'Portuguese (Brazil)' for T2.language. 4) When filtering for block: use the exact literal 'Commander' for T1.block. 5) Output columns (ordered): COUNT(T1.id) AS brazilian_portuguese_translated_sets"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT s.code) AS brazilian_portuguese_translated_sets\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Commander' AND st.language = 'Portuguese (Brasil)'",
            "SELECT COUNT(T1.id) \nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.block = 'Commander' \nAND T2.language = 'Portuguese (Brazil)'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) AS brazilian_portuguese_translated_sets\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.block = 'Commander'\nAND T2.language = 'Portuguese (Brazil)'"
        ]
    },
    "1014": {
        "question": "Please list the lap records for the circuits in Italy.",
        "db_id": "formula_1",
        "ground_truth": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "amends": [
            "Do use a CTE `fastest_lap_times` to convert `FastestLapTime` to seconds instead of directly using `res.time`. Do select only `T1.FastestLapTime as lap_record` instead of multiple columns `circuit_name`, `race_name`, and `lap_record`. Do join `results`, `races`, and `circuits` tables with proper aliases instead of simple joins. Do add a subquery to find the minimum lap time in seconds for Italian circuits instead of filtering by country directly. Do convert the `FastestLapTime` to seconds in the join condition to match against the minimum time instead of ordering by raw time. Do add `LIMIT 1` to return only the fastest lap record instead of ordering all results. Do remove the explicit `ORDER BY` clause since the minimum time logic handles the ordering. The amended query now correctly identifies the absolute fastest lap time record for Italian circuits by properly converting time formats and finding the minimum value."
        ],
        "rules": [
            "1) When the question asks for lap records for circuits in Italy: filter to circuits where T3.country equals 'Italy' exactly. 2) When converting FastestLapTime to seconds: compute time in seconds using the exact conversion method shown in the amends. 3) When finding the fastest lap record: compute the minimum lap time in seconds across all results for Italian circuits. 4) When joining T1 (results), T2 (races), and T3 (circuits): link rows where T1.raceId equals T2.raceId and T2.circuitId equals T3.circuitId. 5) When identifying the absolute fastest lap record: return only the single fastest result using LIMIT 1 equivalent logic. 6) When outputting the result: select only T1.FastestLapTime as lap_record. Output columns (ordered): T1.FastestLapTime"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name AS circuit_name, r.name AS race_name, res.time AS lap_record\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nJOIN results res ON r.raceId = res.raceId\nWHERE c.country = 'Italy'\nAND res.time IS NOT NULL\nORDER BY res.time ASC;",
            "WITH fastest_lap_times AS (\n    SELECT \n        c.circuitId,\n        c.name AS circuit_name,\n        r.name AS race_name,\n        res.FastestLapTime,\n        CAST(SUBSTR(res.FastestLapTime, 1, INSTR(res.FastestLapTime, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(res.FastestLapTime, INSTR(res.FastestLapTime, ':') + 1) AS REAL) AS time_in_seconds\n    FROM results res\n    JOIN races r ON res.raceId = r.raceId\n    JOIN circuits c ON r.circuitId = c.circuitId\n    WHERE c.country = 'Italy'\n    AND res.FastestLapTime IS NOT NULL\n)\nSELECT \n    FastestLapTime as lap_record\nFROM fastest_lap_times\nWHERE time_in_seconds = (\n    SELECT MIN(time_in_seconds)\n    FROM fastest_lap_times\n)\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.FastestLapTime as lap_record\nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nJOIN circuits T3 ON T2.circuitId = T3.circuitId\nWHERE T3.country = 'Italy'\nORDER BY (\n    CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n    CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1) AS REAL)\n) ASC\nLIMIT 1;"
        ]
    },
    "697": {
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';"
        ],
        "rule_sql": []
    },
    "317": {
        "question": "Calculate the percentage of carcinogenic molecules which contain the Chlorine element.",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "amends": [
            "Do use `INNER JOIN` between `atom` and `molecule` instead of `LEFT JOIN` to ensure only molecules with atoms are considered. Do reference the joined tables as `T1` for atom and `T2` for molecule instead of the original table names. Do place the `label = '+'` filter in the `CASE` condition instead of the `WHERE` clause to include all molecules in the denominator calculation. Do use `COUNT()` without `DISTINCT` instead of `COUNT(DISTINCT)` since molecule_id values are already unique within the context. Do calculate the percentage using integer division instead of floating-point multiplication by `100.0`. Do remove the explicit `ELSE NULL` from the `CASE` statement as it's the default behavior. The amended query now correctly calculates the percentage of molecules labeled '+' that contain chlorine atoms by ensuring proper join semantics and accurate denominator inclusion.",
            "Do use `COUNT(T2.molecule_id)` in the denominator instead of `COUNT(CASE WHEN T2.label = '+' THEN T2.molecule_id END)` to count all joined molecules rather than filtering by label again. Do add `ELSE NULL` to the CASE expression instead of omitting it for explicit NULL handling. Do use lowercase `'cl'` instead of `'Cl'` for the element comparison to match case-sensitive requirements. Do remove the WHERE clause filter `T2.label = '+'` instead of keeping it since the label filtering is already handled within the CASE expressions. Do omit the column alias `AS percentage` instead of including it as the query no longer requires named output. The amended query now correctly calculates the percentage of chlorine atoms in positively labeled molecules by counting all molecules in the denominator while maintaining proper case sensitivity and NULL handling.",
            "Do add `ELSE NULL` to the `CASE` expression instead of omitting it, ensuring proper handling of non-matching cases in the conditional count. Do use explicit `AS` aliases for table references `atom AS T1` and `molecule AS T2` instead of implicit aliasing. The amended query now correctly handles NULL values in the CASE expression and maintains the same join logic and aggregation behavior.",
            "Do use the exact same SELECT expression without any formatting changes instead of adding unnecessary line breaks and indentation, as both queries have identical logical structure with the same columns, aggregates, join conditions, and calculations. The amended query now matches RIGHT_SQL's behavior with no functional differences."
        ],
        "rules": [
            "1) When the question asks for percentage of molecules with a specific property: compute (number of molecules satisfying both conditions) divided by (total number of molecules satisfying the base condition) using integer division.\n2) When joining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id using inner join to ensure only molecules with atoms are considered.\n3) When filtering for carcinogenic molecules: use the condition T2.label = '+' exactly as specified.\n4) When checking for Chlorine element: use the condition T1.element = 'cl' exactly as specified (case-sensitive).\n5) When counting molecules: use T2.molecule_id as the counting key since molecule_id values are unique within the context.\n6) When constructing conditional counts: place the label filter in the CASE condition instead of WHERE clause to include all molecules in the denominator calculation.\n7) Output columns (ordered): percentage",
            "1) When counting molecules with a specific label: use COUNT(T2.molecule_id) to count all joined molecules rather than filtering by label again in the denominator.\n2) When handling CASE expressions: add ELSE NULL for explicit NULL handling instead of omitting it.\n3) When comparing element values: use lowercase 'cl' instead of 'Cl' for case-sensitive element comparison.\n4) When filtering by label in both numerator and denominator: remove the WHERE clause filter T2.label = '+' since label filtering is already handled within CASE expressions.\n5) When calculating percentages: compute (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100) / COUNT(T2.molecule_id) for the percentage calculation.\n6) When joining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id to combine the tables.\nOutput columns (ordered): (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100) / COUNT(T2.molecule_id)",
            "1) When counting carcinogenic molecules containing Chlorine: use a CASE expression that returns T2.molecule_id when T2.label = '+' AND T1.element = 'cl', otherwise return NULL. 2) When combining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match). 3) When calculating percentages: compute (count of matching molecules * 100) divided by (total count of molecules), guarding division by zero. 4) When handling table references: use explicit aliases atom AS T1 and molecule AS T2. 5) Output columns (ordered): the calculated percentage value.",
            "1) When the question asks for percentage of carcinogenic molecules containing Chlorine element: compute (count of molecules where T2.label = '+' and T1.element = 'cl') divided by (count of all molecules) multiplied by 100, guarding division by zero.\n2) When identifying carcinogenic molecules: use the exact literal '+' for T2.label.\n3) When identifying Chlorine element: use the exact literal 'cl' for T1.element.\n4) When combining atom table (T1) and molecule table (T2): link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match).\n5) When counting molecules: use T2.molecule_id as the counting key for both numerator and denominator.\n6) Output columns (ordered): the calculated percentage value"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN a.element = 'cl' THEN m.molecule_id END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM \n    molecule m\nLEFT JOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = '+';",
            "SELECT \n    (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'Cl' THEN T2.molecule_id END) * 100) / COUNT(CASE WHEN T2.label = '+' THEN T2.molecule_id END) AS percentage\nFROM \n    atom T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T2.label = '+'",
            "SELECT \n    (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id END) * 100 / COUNT(T2.molecule_id)\nFROM \n    atom T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id;",
            "SELECT \n    (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id)\nFROM \n    atom AS T1\nINNER JOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id;",
            "SELECT (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id)) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id;"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100) / COUNT(T2.molecule_id) AS percentage\nFROM \n    atom AS T1\nINNER JOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id;"
        ]
    },
    "1242": {
        "question": "For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 AND STRFTIME('%Y', T2.Date) = '1984'",
        "amends": [
            "Do select only `ID` instead of including `SEX` and `Birthday` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with single-letter aliases. Do place the `PLT BETWEEN 100 AND 400` filter first in the WHERE clause instead of last. Do calculate age difference using `STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)` instead of current year minus birthday. Do use exact string comparison `STRFTIME('%Y', T2.Date) = '1984'` instead of numeric comparison `YEAR(L.Date) = 1984`. The amended query now correctly filters patients based on their age at the time of the lab test rather than their current age, ensuring the logic matches the intended behavior of finding patients who were under 50 years old when their 1984 lab tests were performed."
        ],
        "rules": [
            "1) When selecting patients for laboratory examinations: include only the ID column in the output, not SEX or Birthday.\n2) When combining Patient and Laboratory tables: use an inner join where T1.ID = T2.ID, with Patient as T1 and Laboratory as T2.\n3) When filtering for laboratory examinations from 1984: use exact string comparison STRFTIME('%Y', T2.Date) = '1984'.\n4) When filtering for normal platelet levels: place the PLT BETWEEN 100 AND 400 condition first in the WHERE clause.\n5) When calculating patient age at time of lab test: compute age as STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) and require this value to be less than 50.\nOutput columns (ordered): T1.ID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT P.ID, P.SEX, P.Birthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE YEAR(L.Date) = 1984\nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) < 50\nAND L.PLT BETWEEN 100 AND 400;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.PLT BETWEEN 100 AND 400\nAND STRFTIME('%Y', T2.Date) = '1984'\nAND (STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) < 50"
        ],
        "rule_sql": [
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.PLT BETWEEN 100 AND 400\nAND STRFTIME('%Y', T2.Date) = '1984'\nAND (STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) < 50"
        ]
    },
    "333": {
        "question": "In the molecule TR008, how many carbons are present?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR008' AND T.element = 'c'",
        "amends": [],
        "rules": [
            "carbon refers to element = 'c'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS carbon_count\nFROM atom\nJOIN molecule ON atom.molecule_id = molecule.molecule_id\nWHERE molecule.molecule_id = 'TR008' AND atom.element = 'c';"
        ],
        "rule_sql": []
    },
    "1506": {
        "question": "Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT DISTINCT T3.Description FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Country = 'CZE'",
        "amends": [],
        "rules": [
            "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Description\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE g.Country = 'CZE';"
        ],
        "rule_sql": []
    },
    "462": {
        "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
        "db_id": "card_games",
        "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
        "amends": [],
        "rules": [
            "Italian is a language which refers to language = 'Italian'; with \"Ancestor's Chosen\" in the card set refers to name = 'Ancestor''s Chosen'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT st.translation AS italian_set_name\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE c.name = 'Ancestor''s Chosen' AND st.language = 'Italian';"
        ],
        "rule_sql": []
    },
    "380": {
        "question": "List the edhrecRank for cards with frame version 2015.",
        "db_id": "card_games",
        "ground_truth": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';"
        ],
        "rule_sql": []
    },
    "1202": {
        "question": "How many male patients who underwent testing between 1995 and 1997 and were subsequently diagnosed with Behcet disease did not stay in the hospital for treatment?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'Behcet' AND T1.SEX = 'M' AND STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1995' AND '1997' AND T1.Admission = '-'",
        "amends": [],
        "rules": [
            "male refers to SEX = 'M'; underwent testing between 1995 and 1997 refers to `Examination Date` between '1995' and '1997'; Behcet refers to diagnosis; did not stay in the hospital refers to Admission = '-'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'M'\nAND E.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31'\nAND E.Diagnosis = 'Behcet'\nAND P.Admission = '-';"
        ],
        "rule_sql": []
    },
    "1192": {
        "question": "List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.`T-BIL` < 2.0 AND T2.Date LIKE '1991-10-%'",
        "amends": [
            "Do select only `T1.ID` instead of multiple columns including `P.SEX`, `P.Birthday`, `P.Description`, `P.First Date`, `P.Admission`, and `P.Diagnosis`. Do use table aliases `T1` and `T2` instead of `P` and `L`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T2.T-BIL` and `T2.Date` in the WHERE clause instead of `L.T-BIL` and `L.Date`. Do use exact pattern matching `1991-10-%` instead of `1991-10%` for the date filter. Do remove the redundant `P.Admission = '-'` condition since it's already implied by the join logic. The amended query now correctly filters patients with admission status '-' who have laboratory results with T-BIL < 2.0 in October 1991, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting patients who underwent laboratory tests: output only T1.ID instead of multiple patient attributes. 2) When joining Patient and Laboratory tables: use INNER JOIN with exact key equality T1.ID = T2.ID. 3) When filtering for October 1991 laboratory tests: use exact pattern matching '1991-10-%' for T2.Date. 4) When filtering for normal bilirubin levels: use T2.T-BIL < 2.0. 5) When the question specifies outpatient clinic follow-up: this is already implied by the admission status '-' condition in the join logic. 6) Output columns (ordered): T1.ID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT P.ID, P.SEX, P.Birthday, P.Description, P.`First Date`, P.Admission, P.Diagnosis\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Admission = '-'\nAND L.Date LIKE '1991-10%'\nAND L.`T-BIL` < 2.0;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '-'\nAND T2.Date LIKE '1991-10-%'\nAND T2.\"T-BIL\" < 2.0"
        ],
        "rule_sql": [
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date LIKE '1991-10-%'\nAND T2.\"T-BIL\" < 2.0\nAND T1.Admission = '-';"
        ]
    },
    "895": {
        "question": "What is the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT AVG(T2.milliseconds) FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.year = 2009 AND T1.name = 'Malaysian Grand Prix'",
        "amends": [],
        "rules": [
            "average lap time = AVG(milliseconds); 'Lewis Hamilton' refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; 'Malaysian Grand Prix' refers to races.name = 'Malaysian Grand Prix'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(l.milliseconds) AS average_lap_time\nFROM lapTimes l\nJOIN races r ON l.raceId = r.raceId\nJOIN drivers d ON l.driverId = d.driverId\nWHERE r.year = 2009 AND r.name = 'Malaysian Grand Prix' AND d.forename = 'Lewis' AND d.surname = 'Hamilton';"
        ],
        "rule_sql": []
    },
    "965": {
        "question": "List out the Id number of races which were hold in 2009.",
        "db_id": "formula_1",
        "ground_truth": "SELECT raceId FROM races WHERE year = 2009",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT raceId FROM races WHERE year = 2009;"
        ],
        "rule_sql": []
    },
    "759": {
        "question": "What is the eye clolour of the heaviest superhero?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id ORDER BY T1.weight_kg DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the heaviest superhero refers to MAX(weight_kg); eye colour refers to colour where eye_colour_id = colour.id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.weight_kg = (SELECT MAX(weight_kg) FROM superhero);"
        ],
        "rule_sql": []
    },
    "801": {
        "question": "Find the ratio between male superheroes and female superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id",
        "amends": [],
        "rules": [
            "ratio = DIVIDE(SUM(gender_id = 1) / SUM(gender_id = 2)); male superheroes refers to gender = 'Female'; female superheroes refers to gender = 'Male';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Male')) * 1.0 /\n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female')) AS male_to_female_ratio;"
        ],
        "rule_sql": []
    },
    "1228": {
        "question": "Provide list of patients and their diagnosis with triglyceride (TG) index greater than 100 of the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG > 300",
        "amends": [],
        "rules": [
            "triglyceride (TG) index greater than 100 of the normal range refers to TG > 300;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TG > 300;"
        ],
        "rule_sql": []
    },
    "1260": {
        "question": "Please list the ID of the patient whose RF is normal and who is older than 60.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60",
        "amends": [
            "Do use `T1.ID` instead of `P.ID` for consistent table alias naming. Do remove `DISTINCT` instead of keeping it since duplicates are handled by the join logic. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T2.RF` directly instead of casting with `CAST(L.RF AS REAL)` since the comparison works with the native type. Do use `DATE('now')` instead of just `'now'` in the strftime function for proper date handling. Do maintain the same join condition `T1.ID = T2.ID` instead of changing it. Do keep the same filter logic for RF values less than 20 and age calculation greater than 60, just with corrected table aliases and date function usage. The amended query now correctly calculates patient age using proper date functions and maintains the intended filtering logic without unnecessary casting or distinct operations.",
            "Do use `T2.RF < 20` instead of `CAST(T2.RF AS REAL) < 20` to avoid unnecessary type casting. Do simplify the age calculation to `STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60` instead of the complex expression with month-day comparison that incorrectly handled leap years and month boundaries. Do remove the redundant parentheses and month-day logic that could produce inaccurate age calculations for patients near their birthday. The amended query now correctly filters patients over 60 years old based on year difference only, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for patient ID: use T1.ID as the output column. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for normal RF values: include only rows where T2.RF < 20. 4) When calculating patient age: compute age as (current year minus birth year) using proper date functions. 5) When filtering for patients older than 60: include only rows where the calculated age is greater than 60. 6) When handling duplicates: do not use DISTINCT since join logic naturally handles uniqueness. Output columns (ordered): T1.ID",
            "1) When filtering for patients with normal RF values: use T2.RF < 20 without type casting. 2) When calculating age for patients older than 60: compute STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60 using year difference only. 3) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID to find matching patient records. 4) When the question asks for patient IDs: output T1.ID as the result. Output columns (ordered): T1.ID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE CAST(L.RF AS REAL) < 20\nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 60;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE CAST(T2.RF AS REAL) < 20\nAND (strftime('%Y', DATE('now')) - strftime('%Y', T1.Birthday)) - (strftime('%m-%d', DATE('now')) < strftime('%m-%d', T1.Birthday)) > 60;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.RF < 20\nAND (STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday)) > 60"
        ],
        "rule_sql": [
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.RF < 20\nAND (STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday)) > 60"
        ]
    },
    "827": {
        "question": "What is the average height of a non-human superhero in Dark Horse Comics?",
        "db_id": "superhero",
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.race != 'Human'",
        "amends": [],
        "rules": [
            "average = AVG(height_cm); non-human superhero refers to race <> 'Human'; Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(s.height_cm) AS average_height\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN race r ON s.race_id = r.id\nWHERE p.publisher_name = 'Dark Horse Comics'\nAND r.race != 'Human';"
        ],
        "rule_sql": []
    },
    "306": {
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select only `molecule_id` and `element` instead of including `label` and `GROUP_CONCAT` aggregation. Do join only `bond` and `atom` tables instead of including the unnecessary `molecule` table. Do use `INNER JOIN` between `bond` and `atom` instead of separate joins to `molecule`. Do remove the `GROUP BY` clause and aggregation instead of grouping by multiple columns. Do remove the `DISTINCT` modifier from the main query instead of keeping it since the join already produces unique combinations. Do eliminate the `GROUP_CONCAT` function instead of aggregating elements into a concatenated string. The amended query now correctly identifies atoms in molecules with specific bond types without unnecessary grouping or table references, matching the RIGHT_SQL's behavior.",
            "Do select `T1.molecule_id` and `T2.element` instead of `a.molecule_id` and `a.element`. Do use `bond AS T1` as the primary table instead of `atom a`. Do `INNER JOIN atom AS T2` on `T1.molecule_id = T2.molecule_id` instead of joining through `connected` and `bond` tables with `a.atom_id = c.atom_id OR a.atom_id = c.atom_id2` and `c.bond_id = b.bond_id`. Do filter with `T1.bond_type = '#'` instead of `b.bond_type = 'triple'`. Do remove the unnecessary `connected` table join and the complex join conditions instead of keeping them. The amended query now correctly identifies atoms in molecules with triple bonds by directly joining bond and atom tables on molecule_id."
        ],
        "rules": [
            "1) When the question asks for molecules with triple bonds: filter bond records where bond_type equals '#' exactly. 2) When combining bond and atom tables for shared molecules: link rows where bond.molecule_id equals atom.molecule_id exactly; keep only matching pairs (inner match). 3) When listing elements contained in molecules: select atom.element for each matching molecule-atom pair. 4) When identifying molecules with specific properties: select molecule_id from the bond table as the canonical identifier. 5) When the question asks for all elements in molecules: do not aggregate or concatenate element values, instead return individual element values per molecule-atom relationship. 6) When querying involves multiple related entities: do not include unnecessary base tables like molecule when bond and atom tables contain all required information. 7) When the join already produces unique molecule-atom-element combinations: do not apply DISTINCT modifier to the main query. Output columns (ordered): bond.molecule_id, atom.element",
            "1) When the question asks for molecules with triple bonds: filter rows where T1.bond_type equals '#' exactly. 2) When combining bond and atom tables: link rows where T1.molecule_id equals T2.molecule_id exactly and keep only matching pairs (inner match). 3) When listing elements contained in molecules: include T2.element for each matching atom. 4) When the question asks for distinct molecules with their elements: output T1.molecule_id and T2.element together. 5) Output columns (ordered): T1.molecule_id, T2.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.molecule_id, m.label, GROUP_CONCAT(DISTINCT a.element) AS elements\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE b.bond_type = '#'\nGROUP BY m.molecule_id, m.label;",
            "SELECT DISTINCT a.molecule_id, a.element\nFROM atom a\nINNER JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nINNER JOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = 'triple'",
            "SELECT T1.molecule_id, T2.element\nFROM bond AS T1\nINNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT bond.molecule_id, atom.element\nFROM bond\nINNER JOIN atom ON bond.molecule_id = atom.molecule_id\nWHERE bond.bond_type = '#'"
        ]
    },
    "568": {
        "question": "Provide the display name of the user who made the vote No.6347.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T2.Id = 6347",
        "amends": [],
        "rules": [
            "vote no. 6347 refers to Id = '6347'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE v.Id = 6347;"
        ],
        "rule_sql": []
    },
    "1241": {
        "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "amends": [
            "Do use `SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END)` as the single expression instead of separate aggregate columns with a subtraction operation. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `Laboratory` table with a subquery. Do remove the `DISTINCT` clause and subquery structure instead of keeping them. Do use inclusive comparisons `<= 100` and `>= 400` instead of exclusive comparisons `< 100` and `> 400` for proper boundary handling. Do eliminate the separate aggregate columns `lower_than_normal` and `higher_than_normal` instead of calculating them individually. The amended query now correctly calculates the difference between low and high platelet counts by joining patient data and using inclusive boundary conditions."
        ],
        "rules": [
            "1) When the question asks about patients with abnormal platelet levels: join Patient as T1 with Laboratory as T2 using T1.ID = T2.ID to combine patient and laboratory data.\n2) When counting patients with lower than normal platelet range: use T2.PLT <= 100 as the condition for lower abnormal range.\n3) When counting patients with higher than normal platelet range: use T2.PLT >= 400 as the condition for higher abnormal range.\n4) When comparing counts of lower vs higher abnormal platelet levels: compute the difference as (count of T2.PLT <= 100) minus (count of T2.PLT >= 400).\n5) When handling platelet level boundaries: use inclusive comparisons (<= and >=) instead of exclusive comparisons (< and >) for proper range inclusion.\n6) When counting distinct patients: use T1.ID as the counting key instead of applying DISTINCT to individual laboratory records.\nOutput columns (ordered): (SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END))"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END) AS lower_than_normal,\n    SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END) AS higher_than_normal,\n    SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END) AS comparison\nFROM \n    (SELECT DISTINCT ID, PLT FROM Laboratory WHERE PLT <= 100 OR PLT >= 400);",
            "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) AS platelet_difference\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.PLT IS NOT NULL AND (T2.PLT <= 100 OR T2.PLT >= 400)"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) AS platelet_comparison\nFROM \n    Patient AS T1\nJOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.PLT <= 100 OR T2.PLT >= 400"
        ]
    },
    "912": {
        "question": "What's the reference name of Marina Bay Street Circuit?",
        "db_id": "formula_1",
        "ground_truth": "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit'",
        "amends": [],
        "rules": [
            "reference name refers to circuitRef; Marina Bay Street Circuit refers to circuits.name = 'Marina Bay Street Circuit'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit';"
        ],
        "rule_sql": []
    },
    "1298": {
        "question": "Among the patients whose total cholesterol is within the normal range, how many of them have a P pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T3.`ANA Pattern` = 'P' AND T2.`T-CHO` < 250",
        "amends": [
            "Do use `COUNT(T1.ID)` without `DISTINCT` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patients. Do specify `INNER JOIN` explicitly instead of just `JOIN` for both joins to clarify join type. Do use table aliases `T1`, `T2`, and `T3` instead of `P`, `L`, and `E` for consistency. Do place the `WHERE` condition `T3.ANA Pattern = 'P'` before `T2.T-CHO < 250` instead of the reverse order, though this is functionally equivalent. Do remove the column alias `AS PatientCount` instead of keeping it since the right query doesn't require it. The amended query now correctly counts all patient records meeting both laboratory and examination criteria without unnecessary distinct filtering."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) without DISTINCT to count all matching rows rather than unique patients.\n2) When joining tables: use INNER JOIN explicitly for both joins to clarify join type.\n3) When using table aliases: use T1 for Patient, T2 for Laboratory, and T3 for Examination for consistency.\n4) When filtering by examination pattern: use the condition T3.\"ANA Pattern\" = 'P' exactly as specified.\n5) When filtering by cholesterol range: use the condition T2.\"T-CHO\" < 250 exactly as specified.\n6) When combining Patient, Laboratory, and Examination tables: link rows where T1.ID = T2.ID and T1.ID = T3.ID using exact key equality and keep only matching pairs (inner match).\n7) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.`T-CHO` < 250 AND E.`ANA Pattern` = 'P';",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T3.\"ANA Pattern\" = 'P'\nAND T2.\"T-CHO\" < 250"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-CHO\" < 250\nAND T3.\"ANA Pattern\" = 'P'"
        ]
    },
    "1369": {
        "question": "Which event has the highest budget amount?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id ORDER BY T1.amount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "event refers to event_name; highest budget amount refers to MAX(amount)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.amount = (SELECT MAX(amount) FROM budget);"
        ],
        "rule_sql": []
    },
    "544": {
        "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'",
        "amends": [],
        "rules": [
            "\"Examples for teaching: Correlation does not mean causation\" is the Title of post; user who last edited refers to LastEditorUserId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName \nFROM posts p \nJOIN users u ON p.LastEditorUserId = u.Id \nWHERE p.Title = 'Examples for teaching: Correlation does not mean causation';"
        ],
        "rule_sql": []
    },
    "1102": {
        "question": "For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-06-23' AND t2.overall_rating = 77 ORDER BY t1.birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "77 points overall rating refers to overall_rating = 77; on 2016/6/23 refers to date LIKE '2016-06-23%'; The larger the birthday value, the younger the person is, and vice versa;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE pa.overall_rating = 77 AND pa.date LIKE '2016-06-23%'\nORDER BY p.birthday ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "466": {
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "amends": [],
        "rules": [
            "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; designed by Adam refers to artist = 'Adam Rex'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT setCode FROM set_translations WHERE translation = 'Hauptset Zehnte Edition') \nAND artist = 'Adam Rex';"
        ],
        "rule_sql": []
    },
    "625": {
        "question": "How many users were from New York?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "amends": [
            "Do use `COUNT(Id)` instead of `COUNT(*)` to count only non-null user IDs. Do use exact equality `Location = 'New York'` instead of pattern matching `LIKE '%New York%'` to avoid counting locations that merely contain 'New York' as a substring. The amended query now correctly counts users specifically located in New York rather than any location containing that text."
        ],
        "rules": [
            "1) When counting users: use COUNT(Id) to count only non-null user IDs instead of COUNT(*) for all rows. 2) When filtering for users from New York: use exact equality Location = 'New York' instead of pattern matching to avoid counting locations that merely contain 'New York' as a substring. 3) Output columns (ordered): COUNT(Id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE Location LIKE '%New York%';",
            "SELECT COUNT(Id) FROM users WHERE Location = 'New York';"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM users WHERE Location = 'New York';"
        ]
    },
    "67": {
        "question": "What is the total amount of Community College District closure in 1989 in the city of San Francisco?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', ClosedDate) = '1989' AND City = 'San Francisco' AND DOCType = 'Community College District'",
        "amends": [
            "Do count `School` column instead of `COUNT(*)` to exclude null values. Do change the filter condition to `DOCType = 'Community College District'` instead of `District LIKE '%Community College%'` for exact matching. The amended query now correctly counts non-null School entries with precise district type filtering."
        ],
        "rules": [
            "1) When counting entities from the schools table: count non-null values of the \"School\" column instead of counting all rows. 2) When filtering for district types: use exact matching with DOCType = 'Community College District' instead of pattern matching with LIKE. 3) When filtering by year from a date column: extract the year component from \"ClosedDate\" and match exactly to '1989'. 4) When filtering by city: use exact matching with City = 'San Francisco'. 5) Output columns (ordered): TotalClosures"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS TotalClosures\nFROM schools\nWHERE strftime('%Y', ClosedDate) = '1989'\nAND City = 'San Francisco'\nAND District LIKE '%Community College%';",
            "SELECT COUNT(School) FROM schools WHERE DOCType = 'Community College District' AND ClosedDate LIKE '1989%' AND City = 'San Francisco'"
        ],
        "rule_sql": [
            "SELECT COUNT(School) AS TotalClosures FROM schools WHERE DOCType = 'Community College District' AND strftime('%Y', ClosedDate) = '1989' AND City = 'San Francisco'"
        ]
    },
    "447": {
        "question": "Give the code of sets have expansion commander type?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
        "amends": [
            "Do select `T2.setCode` instead of `code` and change the source to `sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code` instead of just `sets`. Do use the filter `T1.type = 'commander'` instead of `type = 'expansion' OR type = 'commander'` and remove the `OR` condition. The amended query now correctly joins the translation table and filters for only commander sets instead of both expansion and commander types."
        ],
        "rules": [
            "1) When the question asks for \"code of sets\": select T2.setCode as the output column instead of code from the sets table.\n2) When joining tables for translation purposes: use sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code to combine the tables.\n3) When filtering for commander type sets: use T1.type = 'commander' as the filter condition instead of expansion or commander types.\n4) When handling type filters: do not use OR conditions when only one specific type is required.\n5) Output columns (ordered): T2.setCode"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM sets WHERE type = 'expansion' OR type = 'commander';",
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'"
        ],
        "rule_sql": [
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'"
        ]
    },
    "723": {
        "question": "Among the superheroes with blue eyes, how many of them have the super power of \"Agility\"?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id WHERE T3.power_name = 'Agility' AND T4.colour = 'Blue'",
        "amends": [],
        "rules": [
            "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT s.id) AS count\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id AND c.colour = 'Blue'\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id AND sp.power_name = 'Agility';"
        ],
        "rule_sql": []
    },
    "1039": {
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
        "amends": [],
        "rules": [
            "average number of long shot = DIVIDE(SUM(long_shots), COUNT(player_fifa_api_id));"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(long_shots) AS average_long_shots\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Ahmed Samir Farag');"
        ],
        "rule_sql": []
    },
    "620": {
        "question": "State the number of views of users who obtained the badge on 7/19/2010 7:39:08 PM.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Views FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'",
        "amends": [],
        "rules": [
            "on 7/19/2010 7:39:08 PM refers to Date = '2010-07-19 19:39:08.0'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.Views\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Date = '2010-07-19 19:39:08.0';"
        ],
        "rule_sql": []
    },
    "43": {
        "question": "What is the average math score of the school with the lowest average score for all subjects, and in which county is it located?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.AvgScrMath, T2.County FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath IS NOT NULL ORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC LIMIT 1",
        "amends": [
            "Do select `T1.AvgScrMath` and `T2.County` with table aliases instead of `s.AvgScrMath` and `sc.County` without explicit aliases. Do use `INNER JOIN` with explicit join type instead of just `JOIN`. Do change the join condition from `s.cds = sc.CDSCode` to `T1.cds = T2.CDSCode` with proper table aliases. Do remove the subquery that finds minimum total score and instead add `WHERE T1.AvgScrMath IS NOT NULL` to filter out null values. Do add `ORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC` to sort by total score ascending instead of using a subquery equality condition. Do add `LIMIT 1` to return only the first row instead of potentially multiple rows with the same minimum total score. The amended query now correctly returns the school with the lowest total SAT score while handling null values and ensuring only one result is returned."
        ],
        "rules": [
            "1) When selecting columns from multiple tables: use T1.AvgScrMath and T2.County with explicit table aliases instead of unaliased column references.\n2) When joining tables: use INNER JOIN instead of just JOIN to explicitly specify the join type.\n3) When combining T1 and T2 for shared entities: link rows where T1.cds = T2.CDSCode using the exact key equality shown.\n4) When filtering data: add T1.AvgScrMath IS NOT NULL to exclude rows with null values in the math score column.\n5) When finding the school with the lowest total score: order by T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC instead of using a subquery equality condition.\n6) When returning only one result: add LIMIT 1 to return only the first row instead of potentially multiple rows with the same minimum total score.\nOutput columns (ordered): T1.AvgScrMath, T2.County"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.AvgScrMath, sc.County\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE (s.AvgScrMath + s.AvgScrRead + s.AvgScrWrite) = (\n    SELECT MIN(AvgScrMath + AvgScrRead + AvgScrWrite)\n    FROM satscores\n);",
            "SELECT T1.AvgScrMath, T2.County\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath IS NOT NULL\nORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AvgScrMath, T2.County\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath IS NOT NULL\nORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC\nLIMIT 1"
        ]
    },
    "1532": {
        "question": "Which country had the gas station that sold the most expensive product id No.2 for one unit?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.ProductID = 2 ORDER BY T1.Price DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.ProductID = 2\nORDER BY t.Price DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1105": {
        "question": "How was Francesco Migliore's attacking work rate on 2015/5/1?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.`date` LIKE '2015-05-01%' AND t1.player_name = 'Francesco Migliore'",
        "amends": [
            "Do select only `t2.attacking_work_rate` instead of both `p.player_name` and `pa.attacking_work_rate`. Do use table aliases `t1` and `t2` instead of `p` and `pa`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do place the `date` filter before the `player_name` filter instead of after it. Do use backticks around `date` instead of leaving it unquoted. The amended query now correctly returns only the attacking work rate for the specified player on the given date, matching the RIGHT_SQL's behavior.",
            "Do use `LIKE '2015-05-01%'` for date matching instead of exact string comparison `= '2015/5/1'` to accommodate potential timestamp formats and ensure proper date filtering. The amended query now correctly matches the RIGHT_SQL's behavior with appropriate date handling."
        ],
        "rules": [
            "1) When selecting columns for a specific player's attribute on a date: output only the attribute column (t2.attacking_work_rate) instead of both player name and attribute. 2) When using table aliases: use t1 for the Player table and t2 for the Player_Attributes table. 3) When joining tables: use INNER JOIN explicitly between t1 and t2 where t1.player_api_id equals t2.player_api_id. 4) When ordering filter conditions: place the date filter before the player_name filter. 5) When referencing the date column: use backticks around `date` as the identifier. 6) When filtering by player name: use exact literal 'Francesco Migliore' with proper case and spacing. 7) When filtering by date: use exact date format '2015-05-01' with proper year-month-day order and dashes. Output columns (ordered): t2.attacking_work_rate",
            "1) When the question asks about a player's attribute on a specific date: use the Player table as T1 and Player_Attributes table as T2, linking them where T1.player_api_id equals T2.player_api_id to find matching player records.\n2) When filtering by player name: use the exact literal 'Francesco Migliore' for T1.player_name to identify the specific player.\n3) When filtering by date: use pattern matching LIKE '2015-05-01%' for T2.date instead of exact string comparison to accommodate potential timestamp formats and ensure proper date filtering.\n4) When retrieving attacking work rate: select T2.attacking_work_rate as the output column.\nOutput columns (ordered): T2.attacking_work_rate"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.attacking_work_rate\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Francesco Migliore' AND pa.date LIKE '2015-05-01%';",
            "SELECT t2.attacking_work_rate\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.`date` = '2015/5/1'\nAND t1.player_name = 'Francesco Migliore';",
            "SELECT t2.attacking_work_rate \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t2.`date` LIKE '2015-05-01%' \nAND t1.player_name = 'Francesco Migliore'"
        ],
        "rule_sql": [
            "SELECT t2.attacking_work_rate\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.`date` LIKE '2015-05-01%'\nAND t1.player_name = 'Francesco Migliore'"
        ]
    },
    "785": {
        "question": "Describe the names of neutral alignment superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "amends": [],
        "rules": [
            "names of superheroes refers to superhero_name; neutral alignment refers to alignment = 'Neutral';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero_name FROM superhero WHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'Neutral');"
        ],
        "rule_sql": []
    },
    "1048": {
        "question": "What is the overall rating of the football player Gabriel Tamas in year 2011?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Gabriel Tamas' AND strftime('%Y', t2.date) = '2011'",
        "amends": [],
        "rules": [
            "in year 2011 refers to strftime('%Y', date) = '2011';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pa.overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Gabriel Tamas' AND strftime('%Y', pa.date) = '2011';"
        ],
        "rule_sql": []
    },
    "491": {
        "question": "What's the magic card market name for the set which was released on 2017/6/9?",
        "db_id": "card_games",
        "ground_truth": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "amends": [],
        "rules": [
            "magic card market name refers to mcmName"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';"
        ],
        "rule_sql": []
    },
    "1329": {
        "question": "What county did Sherri Ramsey grew up?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT z.county\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Sherri' AND m.last_name = 'Ramsey';"
        ],
        "rule_sql": []
    },
    "495": {
        "question": "What was the release date for the set which card \"Evacuation\" in it?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Evacuation'",
        "amends": [],
        "rules": [
            "\"Evacuation\" refers to name = 'Evacuation'; release date refers to releaseDate"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.releaseDate \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Evacuation';"
        ],
        "rule_sql": []
    },
    "901": {
        "question": "Name the races along with its circuit name and location for f1 races hosted in September 2005.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.name, T1.name, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2005 AND STRFTIME('%m', T2.date) = '09'",
        "amends": [],
        "rules": [
            "in September 2005 refers to MONTH(date) = 9 and YEAR(date) = 2005"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT races.name AS race_name, circuits.name AS circuit_name, circuits.location\nFROM races\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE races.date BETWEEN '2005-09-01' AND '2005-09-30'"
        ],
        "rule_sql": []
    },
    "52": {
        "question": "What is the total number of schools whose total SAT scores are greater or equal to 1500 whose mailing city is Lakeport?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(T1.cds) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Lakeport' AND (T1.AvgScrRead + T1.AvgScrMath + T1.AvgScrWrite) >= 1500",
        "amends": [],
        "rules": [
            "Total SAT scores can be computed by AvgScrRead + AvgScrMath + AvgScrWrite"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT s.CDSCode) \nFROM schools s \nJOIN satscores sat ON s.CDSCode = sat.cds \nWHERE sat.NumGE1500 > 0 AND s.MailCity = 'Lakeport';"
        ],
        "rule_sql": []
    },
    "1181": {
        "question": "For the patient who got the laboratory test of uric acid level as 8.4 on 1991-10-21, how old was he/she at that time?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UA = 8.4 AND T2.Date = '1991-10-21'",
        "amends": [],
        "rules": [
            "how old at that time refers to SUBTRACT(year(test date), year(Birthday)); uric acid level as 8.4 refers to UA = '8.4'; 1991/10/21 refers to Date = '1991-10-21'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    strftime('%Y', '1991-10-21') - strftime('%Y', p.Birthday) - \n    (CASE \n        WHEN strftime('%m-%d', '1991-10-21') < strftime('%m-%d', p.Birthday) THEN 1 \n        ELSE 0 \n    END) AS Age\nFROM \n    Patient p\nJOIN \n    Laboratory l ON p.ID = l.ID\nWHERE \n    l.UA = 8.4 AND l.Date = '1991-10-21';"
        ],
        "rule_sql": []
    },
    "1034": {
        "question": "List the players' api id who had the highest above average overall ratings in 2010.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_api_id FROM Player_Attributes WHERE SUBSTR(`date`, 1, 4) = '2010' ORDER BY overall_rating DESC LIMIT 1",
        "amends": [
            "Do use `SUBSTR(date, 1, 4)` for year extraction instead of `strftime('%Y', date)` to match the right SQL's date handling approach. Do remove the CTE structure with `AvgRating2010`, `AboveAveragePlayers`, and `MaxAboveAverage` instead of maintaining multiple nested subqueries. Do add `ORDER BY overall_rating DESC LIMIT 1` instead of using complex filtering to find the maximum rating through separate CTEs and equality comparisons. Do simplify the query to a single direct selection from `Player_Attributes` instead of using multiple CTE layers. The amended query now correctly identifies the player with the highest rating in 2010 using a more efficient top-N approach rather than calculating averages and maximums through multiple processing steps."
        ],
        "rules": [
            "1) When extracting year from a date column: use SUBSTR(date, 1, 4) instead of strftime functions for year extraction. 2) When finding the highest value of a column: use ORDER BY column DESC LIMIT 1 instead of calculating maximums through separate CTEs and equality comparisons. 3) When the question asks for \"highest above average overall ratings\": directly select from the main table with year filtering and ordering by rating descending with limit 1, rather than using multiple CTE layers for average calculation and filtering. 4) When simplifying query structure: prefer single direct selection from the main table instead of maintaining multiple nested subqueries and CTEs. Output columns (ordered): player_api_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH AvgRating2010 AS (\n    SELECT AVG(overall_rating) AS avg_rating\n    FROM Player_Attributes\n    WHERE strftime('%Y', date) = '2010'\n),\nAboveAveragePlayers AS (\n    SELECT player_api_id, overall_rating\n    FROM Player_Attributes\n    WHERE strftime('%Y', date) = '2010'\n    AND overall_rating > (SELECT avg_rating FROM AvgRating2010)\n),\nMaxAboveAverage AS (\n    SELECT MAX(overall_rating) AS max_rating\n    FROM AboveAveragePlayers\n)\nSELECT player_api_id\nFROM AboveAveragePlayers\nWHERE overall_rating = (SELECT max_rating FROM MaxAboveAverage);",
            "SELECT player_api_id \nFROM Player_Attributes \nWHERE SUBSTR(date, 1, 4) = '2010' \nORDER BY overall_rating DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_api_id \nFROM Player_Attributes \nWHERE SUBSTR(date, 1, 4) = '2010' \nORDER BY overall_rating DESC \nLIMIT 1"
        ]
    },
    "764": {
        "question": "What are the superpowers of heroes with ID 1?",
        "db_id": "superhero",
        "ground_truth": "SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1",
        "amends": [],
        "rules": [
            "superpowers refers to power_name; heroes with ID 1 refers to hero_id = 1;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name FROM hero_power hp JOIN superpower sp ON hp.power_id = sp.id WHERE hp.hero_id = 1;"
        ],
        "rule_sql": []
    },
    "1374": {
        "question": "How many events did the member with the phone number \"954-555-6240\" attend?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T2.link_to_event) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member WHERE T1.phone = '954-555-6240'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM attendance \nWHERE link_to_member = (SELECT member_id FROM member WHERE phone = '954-555-6240');"
        ],
        "rule_sql": []
    },
    "770": {
        "question": "What is the eyes colour of Abraham Sapien?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Abraham Sapien'",
        "amends": [],
        "rules": [
            "eye colour refers to colour.colour where eye_colour_id = colour.id; Abraham Sapien is the full name of superhero;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour \nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.full_name = 'Abraham Sapien';"
        ],
        "rule_sql": []
    },
    "401": {
        "question": "What percentage of legendary frame effect cards that are only available in online game variations?",
        "db_id": "card_games",
        "ground_truth": "SELECT SUM(CASE WHEN isOnlineOnly = 1 THEN 1.0 ELSE 0 END) / COUNT(id) * 100 FROM cards WHERE frameEffects = 'legendary'",
        "amends": [],
        "rules": [
            "only available in online game variationsrefer to isOnlineOnly =1 ; legendary frame effect cards refer to frameEffects = 'legendary'; percentage refer to DIVIDE(COUNT(isOnlineOnly=1), COUNT(id)) from cards where frameEffects = 'legendary'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN isOnlineOnly = 1 AND frameEffects = 'legendary' THEN 1 END) * 100.0 / \n    COUNT(CASE WHEN frameEffects = 'legendary' THEN 1 END)) AS percentage\nFROM \n    cards\nWHERE \n    frameEffects = 'legendary';"
        ],
        "rule_sql": []
    },
    "846": {
        "question": "Please list the reference names of the drivers who are eliminated in the first period in race number 20.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.driverRef FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 20 ORDER BY T1.q1 DESC LIMIT 5",
        "amends": [],
        "rules": [
            "driver reference name refers to driverRef; first qualifying period refers to q1; drivers who are eliminated in the first qualifying period refers to 5 drivers with MAX(q1); race number refers to raceId;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverRef\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 20 AND q.q1 IS NOT NULL\nORDER BY q.q1 DESC\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "932": {
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT r.year\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';\n"
        ],
        "rule_sql": []
    },
    "60": {
        "question": "What are the websites for all the partially virtual chartered schools located in San Joaquin?",
        "db_id": "california_schools",
        "ground_truth": "SELECT Website FROM schools WHERE County = 'San Joaquin' AND Virtual = 'P' AND Charter = 1",
        "amends": [],
        "rules": [
            "Virtual = 'P' means partially virtual; Charter schools refers to Charter = 1 in the table schools"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Website FROM schools WHERE Virtual = 'P' AND Charter = 1 AND County = 'San Joaquin';"
        ],
        "rule_sql": []
    },
    "82": {
        "question": "What is the grade span offered in the school with the highest longitude?",
        "db_id": "california_schools",
        "ground_truth": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
        "amends": [
            "Do select `GSoffered` instead of `\"Low Grade\", \"High Grade\"` from the `frpm` table. Do remove the `JOIN` with `schools` table and instead query only from `schools` table. Do remove the subquery with `MAX(Longitude)` and instead use `ORDER BY ABS(longitude) DESC` to find the school with maximum absolute longitude. Do add `LIMIT 1` instead of omitting it to return only the top result. Do remove the `WHERE` clause with subquery and instead incorporate the ordering directly in the main query. The amended query now correctly returns the GSoffered value from the school with the maximum absolute longitude instead of attempting to join and filter with complex subqueries."
        ],
        "rules": [
            "1) When the question asks for \"grade span offered\": select the exact column \"GSoffered\" from the schools table.\n2) When the question asks for the school with the \"highest longitude\": order rows by the absolute value of \"Longitude\" in descending direction and keep the first 1 row.\n3) When selecting from a single table: do not perform unnecessary joins with other tables.\n4) When finding maximum values: use ordering with limit instead of subqueries with MAX() functions.\n5) Output columns (ordered): schools.\"GSoffered\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.\"Low Grade\", f.\"High Grade\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.Longitude = (SELECT MAX(Longitude) FROM schools);",
            "SELECT GSoffered FROM schools ORDER BY ABS(Longitude) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT schools.\"GSoffered\" FROM schools ORDER BY ABS(schools.Longitude) DESC LIMIT 1;"
        ]
    },
    "8": {
        "question": "What is the number of SAT test takers of the schools with the highest FRPM count for K-12 students?",
        "db_id": "california_schools",
        "ground_truth": "SELECT NumTstTakr FROM satscores WHERE cds = ( SELECT CDSCode FROM frpm ORDER BY `FRPM Count (K-12)` DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.NumTstTakr\nFROM satscores s\nJOIN frpm f ON s.cds = f.CDSCode\nWHERE f.\"FRPM Count (K-12)\" = (SELECT MAX(\"FRPM Count (K-12)\") FROM frpm);"
        ],
        "rule_sql": []
    },
    "1424": {
        "question": "Among the members, how many of them have an extra large t-shirt size?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(member_id) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large'",
        "amends": [],
        "rules": [
            "among the members refers to position = 'Member'; extra large t-shirt size refers to t_shirt_size = 'X-Large'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large';"
        ],
        "rule_sql": []
    },
    "822": {
        "question": "How many green-skinned villains are there in the superhero universe?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "amends": [],
        "rules": [
            "green-skinned refers to colour.colour = 'Green' WHERE skin_colour_id = colour.id; villains refers to alignment = 'Bad';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS green_skinned_villains\nFROM superhero\nJOIN alignment ON superhero.alignment_id = alignment.id\nJOIN colour ON superhero.skin_colour_id = colour.id\nWHERE alignment.alignment = 'Bad' AND colour.colour = 'Green';"
        ],
        "rule_sql": []
    },
    "703": {
        "question": "Among the tags with tag ID below 15, how many of them have 20 count of posts and below?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM tags WHERE Count <= 20 AND Id < 15",
        "amends": [],
        "rules": [
            "ID below 15 refers to Id < 15; have 20 count of posts and below refers to Count < = 20;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tags WHERE Id < 15 AND Count <= 20;"
        ],
        "rule_sql": []
    },
    "797": {
        "question": "Which superheroes have blue eyes with brown hair?",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'",
        "amends": [],
        "rules": [
            "which superheroes refers to superhero_name; blue eyes refers to color = 'Blue' and color.id = eye_colour_id; brown hair refers to color = 'Brown' and color.id = hair_colour_id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id\nWHERE eye_colour.colour = 'Blue' AND hair_colour.colour = 'Brown';"
        ],
        "rule_sql": []
    },
    "979": {
        "question": "What race number has the most finishers?",
        "db_id": "formula_1",
        "ground_truth": "SELECT raceId FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1",
        "amends": [
            "Do use `COUNT(time IS NOT NULL)` in the ORDER BY clause instead of `COUNT(*) AS finisher_count` in the SELECT list and then ordering by that alias. Do remove the explicit WHERE clause filtering for `time IS NOT NULL` instead of keeping it as a separate filter. Do omit the alias `finisher_count` in the SELECT list instead of including it. The amended query now correctly counts only non-null time values while grouping by raceId and ordering by that count, matching the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(time IS NOT NULL) AS finisher_count` column from the SELECT list instead of including it, as the query only needs to return the raceId. Do keep the `COUNT(time IS NOT NULL)` expression in the ORDER BY clause instead of removing it, maintaining the correct ordering by the count of non-null time values. Do preserve the GROUP BY raceId, WHERE filters (none present), and LIMIT 1 clauses without changes. The amended query now correctly returns only the raceId with the highest count of finishers (non-null time values) while matching the RIGHT_SQL's behavior.",
            "Do remove the `WHERE time IS NOT NULL` filter instead of keeping it, as the aggregate function `COUNT(time IS NOT NULL)` already handles NULL values correctly by counting only non-NULL occurrences. Do maintain the `GROUP BY raceId` clause and `ORDER BY COUNT(time IS NOT NULL) DESC` with `LIMIT 1` to find the race with the most non-NULL time values. The amended query now correctly counts non-NULL time values across all races without prematurely filtering rows, matching the intended behavior."
        ],
        "rules": [
            "1) When counting finishers per race: count only rows where time is not null using COUNT(time IS NOT NULL) instead of using COUNT(*) with a separate filter. 2) When ordering by the count of finishers: use the COUNT(time IS NOT NULL) expression directly in the ORDER BY clause instead of creating an alias in the SELECT list. 3) When the question asks for the race with the most finishers: order the results by the count of finishers in descending order and keep only the top result. 4) When grouping by raceId: organize results by the raceId column and compute aggregates per race. 5) Output columns (ordered): raceId, COUNT(time IS NOT NULL)",
            "1) When the question asks for the race number with the most finishers: count the number of non-null time values per raceId and order by this count in descending order. 2) When counting finishers: use the condition that time is not null to identify finishers. 3) When ranking to find the highest count: take only the first row after ordering by finisher count in descending order. 4) When grouping by raceId: organize results by raceId and compute the count of finishers per group. 5) When outputting results: return only the raceId column without including the count column in the output. 6) Output columns (ordered): raceId",
            "1) When counting non-NULL values of a column: use the aggregate function COUNT(column) which automatically counts only non-NULL occurrences without needing a separate WHERE filter. 2) When finding the entity with the most occurrences of a condition: group by the entity identifier, count the condition occurrences, order by the count in descending order, and take the first result. 3) When the question asks for \"most finishers\" where finishers are represented by non-NULL time values: count non-NULL time values per raceId to determine finisher counts. 4) Output columns (ordered): raceId"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT raceId, COUNT(*) AS finisher_count\nFROM results\nWHERE time IS NOT NULL\nGROUP BY raceId\nORDER BY finisher_count DESC\nLIMIT 1;",
            "SELECT raceId, COUNT(time IS NOT NULL) AS finisher_count FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1;",
            "SELECT raceId FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1;",
            "SELECT raceId FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT raceId FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY COUNT(time) DESC LIMIT 1;"
        ]
    },
    "1167": {
        "question": "For the year that concluded on December 31, 1998, how many male patients on average were tested in the lab each month?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(COUNT(T1.ID) AS REAL) / 12 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.Date) = '1998' AND T1.SEX = 'M'",
        "amends": [
            "Do use `CAST(COUNT(T1.ID) AS REAL)` instead of `COUNT(DISTINCT L.ID)` to count all matching records without deduplication and ensure real number division. Do reference `Patient AS T1` as the primary table instead of `Laboratory L` and join with `Laboratory AS T2` instead of the reverse join direction. Do use `STRFTIME('%Y', T2.Date) = '1998'` instead of `BETWEEN '1998-01-01' AND '1998-12-31'` for proper year extraction from the date field. Do remove the division by `12.0` decimal literal and instead use integer `12` since the CAST to REAL handles the numeric conversion. Do eliminate the redundant alias `average_male_patients_per_month` instead of keeping it. The amended query now correctly calculates the average monthly count of male patients with laboratory records in 1998 without overcounting due to DISTINCT and with proper date handling.",
            "Do use `T1.SEX = 'M'` instead of `T1.SEX = 'male'` for the gender filter. Do keep the same `SELECT` clause with `CAST(COUNT(T1.ID) AS REAL) / 12` and maintain the `INNER JOIN` on `T1.ID = T2.ID`. Do preserve the `WHERE` clause with `STRFTIME('%Y', T2.Date) = '1998'` but ensure the gender condition uses the correct value format. The amended query now correctly filters for male patients using the appropriate 'M' value instead of 'male', matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"how many male patients on average were tested in the lab each month\": compute the average monthly count of male patients with laboratory records by counting all matching records without deduplication and dividing by 12. 2) When counting patients: use T1.ID as the counting key to count all matching records. 3) When filtering by gender: include only rows where T1.SEX equals exactly 'M'. 4) When filtering by year 1998: include only rows where STRFTIME('%Y', T2.Date) equals exactly '1998'. 5) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 6) When performing division for monthly average: divide the count by integer 12 and ensure the result is a real number. 7) Output columns (ordered): the computed average value",
            "1) When filtering for male patients: use T1.SEX = 'M' instead of 'male' as the gender condition value. 2) When counting patients tested in the lab: use T1.ID as the counting key for the average monthly calculation. 3) When filtering for the year 1998: use STRFTIME('%Y', T2.Date) = '1998' to identify tests from that year. 4) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 5) When computing average monthly count: divide the total count by 12 using CAST(COUNT(T1.ID) AS REAL) / 12. Output columns (ordered): the computed average monthly count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT L.ID) / 12.0 AS average_male_patients_per_month\nFROM Laboratory L\nJOIN Patient P ON L.ID = P.ID\nWHERE P.SEX = 'M'\nAND L.Date BETWEEN '1998-01-01' AND '1998-12-31';",
            "SELECT CAST(COUNT(T1.ID) AS REAL) / 12\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'male' AND STRFTIME('%Y', T2.Date) = '1998'",
            "SELECT CAST(COUNT(T1.ID) AS REAL) / 12\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND STRFTIME('%Y', T2.Date) = '1998'"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(T1.ID) AS REAL) / 12 AS average_monthly_count\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND STRFTIME('%Y', T2.Date) = '1998'"
        ]
    },
    "1423": {
        "question": "How many income are received with an amount of 50?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(income_id) FROM income WHERE amount = 50",
        "amends": [],
        "rules": [
            "amount of 50 refers to amount = 50"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM income WHERE amount = 50;"
        ],
        "rule_sql": []
    },
    "172": {
        "question": "How many owner and disponent dispositions are there from account number 1 to account number 10?",
        "db_id": "financial",
        "ground_truth": "SELECT SUM(type = 'OWNER') , SUM(type = 'DISPONENT') FROM disp WHERE account_id BETWEEN 1 AND 10",
        "amends": [
            "Do use conditional aggregation with `SUM(type = 'OWNER')` and `SUM(type = 'DISPONENT')` instead of `COUNT(*) AS count` with `GROUP BY type`. Do remove the `GROUP BY type` clause instead of keeping it, as the conditional sums eliminate the need for grouping. Do return two separate aggregate columns instead of a single count column with type grouping. The amended query now correctly counts OWNER and DISPONENT types separately within the specified account_id range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for counts of specific disposition types \"OWNER\" and \"DISPONENT\": use conditional aggregation with exact literal values 'OWNER' and 'DISPONENT' instead of grouping by type.\n2) When counting specific types within a range of account numbers: apply the account_id range condition using BETWEEN 1 AND 10 to filter rows before aggregation.\n3) When the question requires separate counts for multiple disposition types: return two separate aggregate columns instead of a single grouped result.\n4) When using conditional aggregation for specific type values: do not include GROUP BY clauses as the conditional sums eliminate the need for grouping.\n5) Output columns (ordered): SUM(type = 'OWNER'), SUM(type = 'DISPONENT')"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type, COUNT(*) AS count FROM disp WHERE account_id BETWEEN 1 AND 10 GROUP BY type;",
            "SELECT \n    SUM(CASE WHEN type = 'OWNER' THEN 1 ELSE 0 END) AS owner_count,\n    SUM(CASE WHEN type = 'DISPONENT' THEN 1 ELSE 0 END) AS disponent_count\nFROM disp\nWHERE account_id BETWEEN 1 AND 10;"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN type = 'OWNER' THEN 1 ELSE 0 END) AS owner_count,\n    SUM(CASE WHEN type = 'DISPONENT' THEN 1 ELSE 0 END) AS disponent_count\nFROM disp\nWHERE account_id BETWEEN 1 AND 10;"
        ]
    },
    "503": {
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "db_id": "card_games",
        "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "amends": [],
        "rules": [
            "expansion type refers to type; card \"Samite Pilgrim\" refers to name = 'Samite Pilgrim'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.type \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Samite Pilgrim';"
        ],
        "rule_sql": []
    },
    "446": {
        "question": "What is percentage of the cards with a converted Mana Cost of 10 in set of Abyssal Horror?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'",
        "amends": [
            "Do use a single query with `INNER JOIN` between `cards` and `sets` on `T2.code = T1.setCode` instead of using CTEs with subqueries. Do filter with `WHERE T1.name = 'Abyssal Horror'` instead of filtering sets by name in a separate CTE. Do calculate the percentage using `CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)` instead of separate counts and division with `NULLIF`. Do include `T1.name` in the SELECT list instead of omitting it. The amended query now correctly joins the tables and filters for the specific card name while calculating the percentage of cards with converted mana cost of 10 within that set, matching the RIGHT_SQL's behavior.",
            "Do place the `T1.name` column at the end of the SELECT list instead of at the beginning, maintaining the same calculation expression `CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)` but without the alias `percentage`. Do use explicit table aliasing with `AS T1` instead of implicit `T1` in the FROM clause, while keeping the same `INNER JOIN` on `T2.code = T1.setCode` and identical `WHERE T1.name = 'Abyssal Horror'` filter. The amended query now matches RIGHT_SQL's behavior with identical logic and output structure."
        ],
        "rules": [
            "1) When joining cards and sets tables: link rows where T2.code equals T1.setCode and keep only matching pairs (inner match). 2) When filtering for the set \"Abyssal Horror\": include only rows where T1.name equals 'Abyssal Horror' exactly. 3) When calculating percentage of cards with converted mana cost of 10: compute (number of rows where T1.convertedManaCost equals 10) divided by (total number of rows) multiplied by 100, using T1.id as the counting key. 4) When outputting results: include T1.name in the output columns. Output columns (ordered): T1.name, (CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id))",
            "1) When the question asks for percentage of cards with a specific converted Mana Cost in a set: compute the ratio of cards with convertedManaCost = 10 divided by total cards in the set, multiplied by 100.\n2) When filtering for a specific card name 'Abyssal Horror': apply the condition T1.name = 'Abyssal Horror' exactly as written.\n3) When combining cards and sets tables: link rows where T2.code = T1.setCode using inner match.\n4) When computing percentage: use the calculation CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) without an alias.\n5) When ordering output columns: place the percentage calculation first followed by T1.name.\n6) When using table aliases: explicitly define cards AS T1 in the FROM clause.\nOutput columns (ordered): CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH abyssal_horror_set AS (\n    SELECT code FROM sets WHERE name = 'Abyssal Horror'\n),\ntotal_cards AS (\n    SELECT COUNT(*) AS total FROM cards WHERE setCode = (SELECT code FROM abyssal_horror_set)\n),\ncmc_10_cards AS (\n    SELECT COUNT(*) AS cmc_10 FROM cards WHERE setCode = (SELECT code FROM abyssal_horror_set) AND convertedManaCost = 10\n)\nSELECT (cmc_10 * 100.0 / NULLIF(total, 0)) AS percentage\nFROM total_cards, cmc_10_cards;",
            "SELECT \n    T1.name,\n    CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM \n    cards T1\nINNER JOIN \n    sets T2 ON T2.code = T1.setCode\nWHERE \n    T1.name = 'Abyssal Horror';",
            "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror';"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'"
        ]
    },
    "1116": {
        "question": "List down most tallest players' name.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_name FROM (SELECT player_name, height, DENSE_RANK() OVER (ORDER BY height DESC) as rank FROM Player) WHERE rank = 1",
        "amends": [],
        "rules": [
            "tallest refers to rank based on the height in descending order; Most tallest players refers to rank = 1 "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name FROM Player WHERE height = (SELECT MAX(height) FROM Player);"
        ],
        "rule_sql": []
    },
    "435": {
        "question": "How many card border with black color ? List out the card id.",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id",
        "amends": [],
        "rules": [
            "border with black color refers to borderColor = 'black'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM cards WHERE borderColor = 'black';"
        ],
        "rule_sql": []
    },
    "341": {
        "question": "What are the borderless cards available without powerful foils?",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)",
        "amends": [
            "Do select only `id` instead of all columns with `*`. Do use the correct condition `cardKingdomId IS NULL` in both parts of the OR clause instead of mixing `cardKingdomFoilId IS NULL` with `cardKingdomId IS NULL`. The amended query now correctly identifies borderless cards where either the cardKingdomId is missing in both checks, matching the intended logic.",
            "Do use `cardKingdomId IS NULL` in both conditions of the OR clause instead of having `cardKingdomFoilId IS NULL` as the first condition. Do maintain the same table source `cards` and WHERE filter structure instead of changing the join or grouping logic. The amended query now correctly checks for NULL values in the consistent `cardKingdomId` field in both parts of the OR condition, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for borderless cards: filter rows where borderColor equals 'borderless' exactly. 2) When the question asks for cards available without powerful foils: filter rows where cardKingdomId is null. 3) When selecting columns for output: include only the id column. 4) Output columns (ordered): id",
            "1) When the question asks for borderless cards: filter rows where borderColor equals 'borderless' exactly. 2) When the question asks for cards available without powerful foils: filter rows where cardKingdomId is NULL. 3) When combining multiple conditions for availability: use OR logic between the cardKingdomId IS NULL conditions. 4) Output columns (ordered): id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE borderColor = 'borderless' AND (cardKingdomFoilId IS NULL OR cardKingdomId IS NULL);",
            "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomFoilId IS NULL OR cardKingdomId IS NULL)",
            "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE borderColor = 'borderless' AND cardKingdomId IS NULL;"
        ]
    },
    "608": {
        "question": "State the detailed content of the comment which was created on 7/19/2010 7:25:47 PM.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:16:14.0'",
        "amends": [
            "Do filter by `CreationDate = '2010-07-19 19:16:14.0'` instead of `CreationDate = '2010-07-19 19:25:47.0'` to query comments created at the correct timestamp. The amended query now matches RIGHT_SQL's behavior by selecting comments from the specified date and time."
        ],
        "rules": [
            "1) When the question asks for a comment created at a specific timestamp: filter the comments table using the exact timestamp literal '2010-07-19 19:16:14.0' for the CreationDate column.\n2) When selecting comment content: output the Text column from the comments table.\n3) When handling datetime literals: preserve the exact format 'YYYY-MM-DD HH:MM:SS.0' with 24-hour time representation.\n4) Output columns (ordered): Text"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:25:47.0';",
            "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:16:14.0';"
        ],
        "rule_sql": [
            "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:25:47.0';"
        ]
    },
    "696": {
        "question": "Count the number of posts with a tag specified as 'careers'.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers'",
        "amends": [
            "Do query the `tags` table instead of the `posts` table. Do filter on `TagName = 'careers'` instead of using `LIKE '%careers%'` on a `Tags` column. Do count `Id` values instead of using `COUNT(*)`. Do remove the wildcard pattern matching and instead use exact equality comparison for the tag name. The amended query now correctly counts entries from the tags table where the tag name exactly matches 'careers', matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks to count posts with a specific tag: query the tags table instead of the posts table.\n2) When filtering for a tag name exactly matching 'careers': use exact equality comparison (TagName = 'careers') instead of wildcard pattern matching.\n3) When counting entries from the tags table: count Id values instead of using COUNT(*).\n4) When the tag name is specified as 'careers': preserve the exact literal 'careers' with the same case and punctuation.\n5) Output columns (ordered): COUNT(Id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE Tags LIKE '%careers%';",
            "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers';"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers';"
        ]
    },
    "1490": {
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "amends": [
            "Do use `CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT)` instead of `COUNT(CASE WHEN y.Consumption > 46.73 THEN 1 END)` for proper percentage calculation. Do reference `T1.CustomerID` in `COUNT(T1.CustomerID)` instead of `COUNT(*)` to count only customer records. Do use explicit `INNER JOIN` instead of just `JOIN` for clarity. Do add table aliases `T1` and `T2` instead of using `c` and `y` for better readability. Do remove the multiplication by `100.0` from the numerator and instead multiply the entire expression by `100` after the division. The amended query now correctly calculates the percentage of customers with consumption above 46.73 in the LAM segment.",
            "Do place the multiplication by 100 before the division instead of after it, changing the calculation order to `* 100 / COUNT(T1.CustomerID)` instead of `/ COUNT(T1.CustomerID) * 100` to ensure correct percentage calculation. Do remove the alias `AS Percentage` instead of keeping it since the RIGHT_SQL does not include an explicit column alias. The amended query now correctly calculates the percentage of customers with consumption over 46.73 in the LAM segment."
        ],
        "rules": [
            "1) When the question asks for a percentage of customers with consumption above a specific value: compute (number of customers with consumption > 46.73) divided by (total number of customers) multiplied by 100, using exact literal 46.73.\n2) When counting customers with consumption above 46.73: use CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) to properly count qualifying customers.\n3) When counting total customers: use COUNT(T1.CustomerID) to count only customer records, not all rows.\n4) When combining customer and consumption data: link rows where T1.CustomerID = T2.CustomerID using INNER JOIN to keep only matching pairs.\n5) When filtering for LAM segment customers: include only rows where T1.Segment = 'LAM' using exact literal 'LAM'.\n6) When calculating percentages: perform the division first, then multiply the result by 100 to get the percentage value.\nOutput columns (ordered): Percentage",
            "1) When the question asks for a percentage of customers with consumption over a specific value: compute (number of customers with consumption > 46.73) multiplied by 100 divided by (total number of customers). 2) When the question specifies \"LAM customer\": filter to only include rows where T1.Segment equals exactly 'LAM'. 3) When combining customer and consumption data: link rows where T1.CustomerID equals T2.CustomerID and keep only matching pairs. 4) When counting customers: use T1.CustomerID as the counting key. 5) When calculating percentages: perform multiplication by 100 before division to ensure correct percentage calculation. 6) Output columns (ordered): the calculated percentage value without an explicit alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN y.Consumption > 46.73 THEN 1 END) * 100.0 / COUNT(*) AS Percentage\nFROM \n    customers c\nJOIN \n    yearmonth y ON c.CustomerID = y.CustomerID\nWHERE \n    c.Segment = 'LAM';",
            "SELECT \n    (CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) / COUNT(T1.CustomerID) * 100 AS Percentage\nFROM \n    customers T1\nINNER JOIN \n    yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Segment = 'LAM'",
            "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) \nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM'"
        ],
        "rule_sql": [
            "SELECT (CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100.0 / COUNT(T1.CustomerID)) AS Percentage\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM'"
        ]
    },
    "529": {
        "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
        "db_id": "card_games",
        "ground_truth": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
        "amends": [
            "Do remove the `DISTINCT` modifier instead of keeping it, and do remove the explicit `JOIN` with `set_translations` instead of including it. Do change the `WHERE` clause to use a single subquery with `language = 'Korean' AND language NOT LIKE '%Japanese%'` instead of separate `NOT IN` and `IN` subqueries. Do remove the table alias `s` from the `SELECT` list instead of keeping it, and do simplify the query structure by eliminating the redundant join condition. The amended query now correctly filters for sets with Korean translations that don't contain Japanese text, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for sets with Korean translation but without Japanese translation: filter sets where the language equals 'Korean' exactly and the language does not contain 'Japanese' anywhere in the text.\n2) When selecting set names: output the exact column \"name\" from the sets table without table alias prefix.\n3) When handling text literals: preserve the exact case and spelling of 'Korean' and 'Japanese' as shown in the amends.\n4) When filtering for language conditions: use a single condition combining both language requirements instead of separate subqueries.\n5) When the query structure includes redundant joins: eliminate unnecessary table joins that are not required for the filtering logic.\n6) When the original query uses DISTINCT modifier: remove the DISTINCT modifier unless explicitly required by the question.\nOutput columns (ordered): name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT s.name\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.code NOT IN (\n    SELECT setCode\n    FROM set_translations\n    WHERE language LIKE '%Japanese%'\n)\nAND s.code IN (\n    SELECT setCode\n    FROM set_translations\n    WHERE language = 'Korean'\n);",
            "SELECT name FROM sets WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%')"
        ],
        "rule_sql": [
            "SELECT s.name\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Korean'\nAND s.code NOT IN (\n    SELECT setCode\n    FROM set_translations\n    WHERE language = 'Japanese'\n)"
        ]
    },
    "29": {
        "question": "When did the first-through-twelfth-grade school with the largest enrollment open?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.OpenDate FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "amends": [],
        "rules": [
            "K-12 means First-through-twelfth-grade"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.OpenDate\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nORDER BY f.[Enrollment (K-12)] DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "385": {
        "question": "Write down the ruling of Beacon of Immortality.",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "amends": [],
        "rules": [
            "Beacon of Immortality' is the name of card;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Beacon of Immortality';"
        ],
        "rule_sql": []
    },
    "110": {
        "question": "What is the disposition id of the client who made 5100 USD transaction in 1998/9/2?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.disp_id FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.date='1997-08-20' AND T3.amount = 5100",
        "amends": [
            "Do join `account AS T2` on `T1.account_id = T2.account_id` instead of omitting the account table entirely. Do then join `trans AS T3` on `T2.account_id = T3.account_id` instead of directly joining `trans t` on `t.account_id = d.account_id`. Do filter on `T3.date='1997-08-20'` instead of `'1998-09-02'` while keeping the `T3.amount = 5100` condition. Do select `T1.disp_id` with table alias instead of `d.disp_id`. The amended query now correctly follows the three-table relationship path and uses the proper date filter to match the intended behavior."
        ],
        "rules": [
            "1) When joining tables for client disposition information: link account table as T2 to disposition table T1 using T1.account_id = T2.account_id, then link trans table as T3 to account table T2 using T2.account_id = T3.account_id, keeping only matching pairs (inner match).\n2) When filtering for transactions with amount 5100: include only rows where T3.amount = 5100 exactly.\n3) When filtering for transactions on date 1997-08-20: include only rows where T3.date = '1997-08-20' exactly (not '1998-09-02').\n4) When selecting the disposition id: output T1.disp_id from the disposition table.\n5) Output columns (ordered): T1.disp_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.disp_id\nFROM trans t\nJOIN disp d ON t.account_id = d.account_id\nWHERE t.amount = 5100 AND t.date = '1998-09-02';",
            "SELECT T1.disp_id\nFROM disp AS T1\nJOIN account AS T2 ON T1.account_id = T2.account_id\nJOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T3.amount = 5100\nAND T3.date = '1997-08-20';"
        ],
        "rule_sql": [
            "SELECT T1.disp_id\nFROM disp AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T3.amount = 5100\nAND T3.date = '1997-08-20';"
        ]
    },
    "103": {
        "question": "Which client issued his/her card in 1994/3/3, give his/her client id.",
        "db_id": "financial",
        "ground_truth": "SELECT T2.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.issued = '1994-03-03'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.issued = '1994-03-03';"
        ],
        "rule_sql": []
    },
    "883": {
        "question": "How many races were there in 2005? Name all the races in descending order.",
        "db_id": "formula_1",
        "ground_truth": "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC",
        "amends": [
            "Do select `name` instead of `COUNT(*) AS race_count` to return individual race names rather than a count aggregate. Do remove the separate `COUNT(*)` query entirely instead of executing two separate queries, consolidating into a single query that returns the actual race names. Do maintain the `WHERE year = 2005` filter and `ORDER BY name DESC` sorting from the second query instead of having inconsistent query structures. The amended query now correctly returns the list of race names for 2005 in descending alphabetical order rather than providing an unnecessary count followed by the actual names."
        ],
        "rules": [
            "1) When the question asks for race names instead of a count: return the exact column \"name\" rather than performing a count aggregate. 2) When filtering for races in a specific year: apply the condition year = 2005 using the exact literal value 2005. 3) When ordering race names in descending order: sort the results by the \"name\" column in descending alphabetical order. 4) When consolidating multiple query operations: combine filtering and ordering into a single operation rather than executing separate queries. 5) Output columns (ordered): name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS race_count FROM races WHERE year = 2005;\nSELECT name FROM races WHERE year = 2005 ORDER BY name DESC;",
            "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC;"
        ]
    },
    "207": {
        "question": "What elements are in a double type bond?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
        "amends": [
            "Do use `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of joining through `connected` table with `a.atom_id = c.atom_id OR a.atom_id = c.atom_id2`. Do add `T1.molecule_id = T2.molecule_id` join condition instead of omitting it. Do remove the `JOIN bond b ON c.bond_id = b.bond_id` connection through `connected` table instead of keeping the indirect path. Do change the join structure to directly connect `atom` and `bond` tables via `molecule_id` instead of using the `connected` table as an intermediary. Do keep the `WHERE T2.bond_type = '='` filter instead of changing it. Do maintain `DISTINCT` selection of `element` instead of altering it. The amended query now correctly establishes the relationship between atoms and bonds through their shared molecule context rather than the incorrect atom-level connection through the connected table, matching the RIGHT_SQL's behavior.",
            "Do add `INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id` instead of omitting the connected table join entirely. Do change the table alias from `a` to `T1` and `b` to `T2` instead of using the original aliases. Do add `T3` table reference instead of keeping only two tables. The amended query now correctly includes the necessary join to the connected table to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining atom and bond tables: link rows where T1.molecule_id = T2.molecule_id using an inner match instead of using the connected table as an intermediary.\n2) When filtering for double type bonds: keep only rows where T2.bond_type = '=' exactly as specified.\n3) When selecting distinct elements: return unique values of T1.element from the combined result set.\n4) When the question asks for elements in a specific bond type: use the direct molecule-level relationship between atoms and bonds rather than atom-level connections through intermediate tables.\nOutput columns (ordered): T1.element",
            "1) When the question asks for elements in a double type bond: include the connected table as T3 in addition to atom as T1 and bond as T2. 2) When combining tables for bond information: link T1 (atom) and T2 (bond) where T1.molecule_id = T2.molecule_id. 3) When accessing connected atom data: link T1 (atom) and T3 (connected) where T1.atom_id = T3.atom_id. 4) When filtering for double bonds: use the exact literal '=' for T2.bond_type instead of 'double'. 5) When selecting distinct elements: use T1.element as the output column. Output columns (ordered): T1.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.element\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '=';",
            "SELECT DISTINCT a.element \nFROM atom a\nINNER JOIN bond b ON a.molecule_id = b.molecule_id\nWHERE b.bond_type = '='",
            "SELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id\nWHERE T2.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.element\nFROM atom T1\nJOIN bond T2 ON T1.molecule_id = T2.molecule_id\nJOIN connected T3 ON T1.atom_id = T3.atom_id\nWHERE T2.bond_type = '='"
        ]
    },
    "28": {
        "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
        "amends": [
            "Do use a direct `INNER JOIN` between `frpm` and `schools` instead of a CTE structure. Do reference `T2.School` and `T2.DOC` instead of `l.School` and `l.DOCType`. Do filter with `T2.FundingType = 'Locally funded'` instead of `s.FundingType = 'Local'`. Do calculate the enrollment difference directly in the main query and subquery instead of using a CTE. Do use a correlated subquery for the average calculation instead of a separate CTE with cross join. Do reference the correct column `DOC` instead of `DOCType`. The amended query now correctly filters for locally funded schools and compares each school's enrollment difference against the average of all locally funded schools."
        ],
        "rules": [
            "1) When the question mentions \"locally funded\" schools: filter rows where T2.FundingType equals exactly 'Locally funded'.\n2) When calculating enrollment difference: compute T1.\"Enrollment (K-12)\" minus T1.\"Enrollment (Ages 5-17)\" for each school.\n3) When computing the average difference: calculate the average of enrollment differences across all locally funded schools using a correlated subquery.\n4) When comparing against the average: select schools where their enrollment difference is greater than the average enrollment difference of all locally funded schools.\n5) When referencing school information: use T2.School for school names and T2.DOC for DOC type (not DOCType).\n6) When combining schools and frpm tables: link rows where T1.CDSCode equals T2.CDSCode using an inner join.\n7) Output columns (ordered): T2.School, T2.DOC"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH LocalFundedSchools AS (\n    SELECT \n        s.CDSCode,\n        s.School,\n        s.DOCType,\n        f.\"Enrollment (K-12)\" - f.\"Enrollment (Ages 5-17)\" AS EnrollmentDifference\n    FROM \n        schools s\n    JOIN \n        frpm f ON s.CDSCode = f.CDSCode\n    WHERE \n        s.FundingType = 'Local'\n),\nAverageDifference AS (\n    SELECT \n        AVG(EnrollmentDifference) AS AvgEnrollmentDifference\n    FROM \n        LocalFundedSchools\n)\nSELECT \n    l.School,\n    l.DOCType\nFROM \n    LocalFundedSchools l, AverageDifference a\nWHERE \n    l.EnrollmentDifference > a.AvgEnrollmentDifference;",
            "SELECT T2.School, T2.DOC\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.FundingType = 'Locally funded'\nAND (T1.\"Enrollment (K-12)\" - T1.\"Enrollment (Ages 5-17)\") > (\n    SELECT AVG(T3.\"Enrollment (K-12)\" - T3.\"Enrollment (Ages 5-17)\")\n    FROM frpm T3\n    INNER JOIN schools T4 ON T3.CDSCode = T4.CDSCode\n    WHERE T4.FundingType = 'Locally funded'\n);"
        ],
        "rule_sql": [
            "SELECT T2.School, T2.DOC\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.FundingType = 'Locally funded'\nAND (T1.\"Enrollment (K-12)\" - T1.\"Enrollment (Ages 5-17)\") > (\n    SELECT AVG(T1_inner.\"Enrollment (K-12)\" - T1_inner.\"Enrollment (Ages 5-17)\")\n    FROM frpm T1_inner\n    INNER JOIN schools T2_inner ON T1_inner.CDSCode = T2_inner.CDSCode\n    WHERE T2_inner.FundingType = 'Locally funded'\n)"
        ]
    },
    "153": {
        "question": "How many 'classic' cards are eligible for loan?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'classic' AND T2.type = 'OWNER'",
        "amends": [],
        "rules": [
            "when the account type = 'OWNER', it's eligible for loan"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS classic_cards_eligible_for_loan\nFROM card\nJOIN disp ON card.disp_id = disp.disp_id\nJOIN account ON disp.account_id = account.account_id\nWHERE card.type = 'classic' AND disp.type = 'OWNER';"
        ],
        "rule_sql": []
    },
    "601": {
        "question": "What is the score and the link type ID for post ID 395?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Score, pl.LinkTypeId FROM posts p LEFT JOIN postLinks pl ON p.Id = pl.PostId WHERE p.Id = 395;"
        ],
        "rule_sql": []
    },
    "695": {
        "question": "How many users were awarded with 'Citizen Patrol' badge?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE `Name` = 'Citizen Patrol'",
        "amends": [],
        "rules": [
            "Citizen Patrol' is the name of the badge;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Citizen Patrol';"
        ],
        "rule_sql": []
    },
    "702": {
        "question": "How many posts have a score less than 20?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score < 20",
        "amends": [],
        "rules": [
            "score less than 20 refers to Score < 20;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE Score < 20;"
        ],
        "rule_sql": []
    },
    "7": {
        "question": "What is the phone number of the school that has the highest number of test takers with an SAT score of over 1500?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.Phone\nFROM schools s\nJOIN satscores sat ON s.CDSCode = sat.cds\nWHERE sat.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);"
        ],
        "rule_sql": []
    },
    "1470": {
        "question": "How many gas stations in CZE has Premium gas?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium';"
        ],
        "rule_sql": []
    },
    "1349": {
        "question": "Provide the total number of the budget amount for \"September Speaker\" event.",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'September Speaker'",
        "amends": [],
        "rules": [
            "'September Speaker' is an event name; total number of budget amount refers to SUM(amount)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) AS total_budget_amount\nFROM budget\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'September Speaker');"
        ],
        "rule_sql": []
    },
    "44": {
        "question": "What is the average writing score of the school who has the highest number of test takers whose total SAT sscores are greater or equal to 1500? Indicate the city to where the school is situated.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.AvgScrWrite, T2.City FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.AvgScrWrite, sc.City\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE s.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);"
        ],
        "rule_sql": []
    },
    "899": {
        "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
        "amends": [
            "Do use `DISTINCT` on `T1.name` instead of selecting multiple columns without distinct. Do select only `T1.name` instead of including `circuitId`, `location`, and `country`. Do use `INNER JOIN` with table aliases `T1` and `T2` instead of simple `JOIN` with aliases `c` and `r`. Do join on `T2.circuitID = T1.circuitId` instead of `c.circuitId = r.circuitId`. Do filter using `STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000'` instead of `r.year BETWEEN 1990 AND 2000`. Do group by only `T1.name` instead of grouping by all selected columns. Do keep the same `HAVING COUNT(T2.raceId) = 4` condition. The amended query now correctly filters by year extracted from date strings and returns only distinct circuit names with exactly 4 races in the specified date range."
        ],
        "rules": [
            "1) When the question asks for circuits: select only T1.name with DISTINCT instead of multiple columns. 2) When combining circuits (T1) and races (T2): link rows where T2.circuitID = T1.circuitId and keep only matching pairs. 3) When filtering by year range 1990 to 2000: extract year from T2.date using STRFTIME('%Y', T2.date) and check if it is between '1990' AND '2000'. 4) When grouping results: group by only T1.name instead of multiple columns. 5) When counting races per circuit: count T2.raceId and keep only circuits where the count equals 4. 6) Output columns (ordered): T1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.circuitId, c.name, c.location, c.country, COUNT(r.raceId) AS race_count\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nWHERE r.year BETWEEN 1990 AND 2000\nGROUP BY c.circuitId, c.name, c.location, c.country\nHAVING COUNT(r.raceId) = 4;",
            "SELECT DISTINCT T1.name\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000'\nGROUP BY T1.name\nHAVING COUNT(T2.raceId) = 4"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name\nFROM circuits T1\nJOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000'\nGROUP BY T1.name\nHAVING COUNT(T2.raceId) = 4"
        ]
    },
    "199": {
        "question": "In the molecule containing sodium atoms, how many are non-carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'na' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "non-carcinogenic refers to label = '-'; sodium atoms refers to element = 'na'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE a.element = 'na' AND m.label = '-';"
        ],
        "rule_sql": []
    },
    "913": {
        "question": "In which country can I find the circuit with the highest altitude?",
        "db_id": "formula_1",
        "ground_truth": "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1",
        "amends": [],
        "rules": [
            "highest altitude refers to max(alt)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1507": {
        "question": "Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT DISTINCT T1.Time FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT Time\nFROM transactions_1k\nJOIN gasstations ON transactions_1k.GasStationID = gasstations.GasStationID\nWHERE gasstations.ChainID = 11\nORDER BY Time;"
        ],
        "rule_sql": []
    },
    "154": {
        "question": "How many male clients in 'Hl.m. Praha' district?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'",
        "amends": [],
        "rules": [
            "District data appears in the A2; Male means that gender = 'M'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM client \nWHERE gender = 'M' AND district_id = (SELECT district_id FROM district WHERE A2 = 'Hl.m. Praha');"
        ],
        "rule_sql": []
    },
    "1282": {
        "question": "Please list the top three patients' birthdays with the highest glutamic pylvic transaminase in the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT < 60 ORDER BY T2.GPT DESC LIMIT 3",
        "amends": [
            "Do use `INNER JOIN Laboratory` directly instead of a subquery with `MAX(GPT)` aggregation. Do move the `GPT < 60` filter to the `WHERE` clause instead of keeping it inside a subquery. Do reference `T2.GPT` directly in the `ORDER BY` instead of using `l.MaxGPT` from the subquery. Do remove the unnecessary `GROUP BY` and aggregation entirely instead of maintaining them. The amended query now correctly filters and sorts by individual GPT values below 60 rather than maximum values per patient, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"top three\" by a specific measurement: rank rows by the exact measurement column (T2.GPT) in descending order and keep the first 3 rows.\n2) When filtering for values in the \"normal range\" of glutamic pylvic transaminase: include only rows where T2.GPT < 60 exactly as specified.\n3) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using exact key equality and keep only matching pairs (inner match).\n4) When the question asks for patients' birthdays: output the exact column T1.Birthday.\n5) When ordering by measurement values: use the exact column T2.GPT directly for sorting rather than aggregated values.\nOutput columns (ordered): T1.Birthday"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Birthday\nFROM Patient p\nJOIN (\n    SELECT ID, MAX(GPT) AS MaxGPT\n    FROM Laboratory\n    WHERE GPT < 60\n    GROUP BY ID\n) l ON p.ID = l.ID\nORDER BY l.MaxGPT DESC\nLIMIT 3;",
            "SELECT p.Birthday\nFROM Patient p\nINNER JOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT < 60\nORDER BY l.GPT DESC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GPT < 60\nORDER BY T2.GPT DESC\nLIMIT 3"
        ]
    },
    "973": {
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "amends": [
            "Do select only `driverId` instead of including `forename`, `surname`, `dob`, and `latest_lap_time`. Do join `pitStops` instead of `lapTimes` and use `INNER JOIN` instead of `JOIN`. Do change the join condition to `T1.driverId = T2.driverId` instead of `d.driverId = l.driverId`. Do remove the `GROUP BY` clause and `MAX` aggregation instead of keeping them. Do change the date filter to use `STRFTIME('%Y', T2.dob) < '1982'` instead of `d.dob < '1982-01-01'`. Do order by `T1.time` instead of `latest_lap_time`. The amended query now correctly retrieves Spanish drivers born before 1982 from pit stop records rather than lap times, ordering by pit stop time instead of maximum lap time."
        ],
        "rules": [
            "1) When the question asks for \"top 10\" Spanish drivers: rank rows by T1.time in descending order and keep the first 10 rows.\n2) When the question mentions \"Spanish drivers\": filter rows where T1.nationality equals 'Spanish' exactly.\n3) When the question specifies \"born before 1982\": filter rows where STRFTIME('%Y', T2.dob) < '1982'.\n4) When combining T1 and T2 for shared entities: link rows where T1.driverId = T2.driverId exactly; keep only matching pairs (inner match).\n5) When the question asks for drivers with \"latest lap time\": use T1.time from pitStops table instead of lapTimes table.\n6) When selecting output columns: include only T1.driverId instead of additional columns like forename, surname, or dob.\n7) When handling date comparisons: use STRFTIME('%Y', T2.dob) < '1982' instead of direct date comparisons.\n8) When ordering results: sort by T1.time in descending order instead of using MAX aggregation.\n9) Output columns (ordered): T1.driverId"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverId, d.forename, d.surname, d.dob, MAX(l.time) AS latest_lap_time\nFROM drivers d\nJOIN lapTimes l ON d.driverId = l.driverId\nWHERE d.nationality = 'Spanish' AND d.dob < '1982-01-01'\nGROUP BY d.driverId, d.forename, d.surname, d.dob\nORDER BY latest_lap_time DESC\nLIMIT 10;",
            "SELECT T1.driverId\nFROM pitStops T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982'\nORDER BY T1.time DESC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT p.driverId\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nWHERE d.nationality = 'Spanish'\nAND STRFTIME('%Y', d.dob) < '1982'\nORDER BY p.time DESC\nLIMIT 10"
        ]
    },
    "1049": {
        "question": "How many matches in the 2015/2016 season were held in Scotland Premier League\n?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' AND t1.name = 'Scotland Premier League'",
        "amends": [],
        "rules": [
            "Scotland Premier League refers to League.name = 'Scotland Premier League';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM \"Match\" \nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Scotland Premier League') \nAND season = '2015/2016';"
        ],
        "rule_sql": []
    },
    "619": {
        "question": "How many adults who obtained the badge Supporter?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Supporter' AND T1.Age BETWEEN 19 AND 65",
        "amends": [],
        "rules": [
            "Supporter is the Name of badge; adult refers to Age BETWEEN 19 AND 65"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT u.Id) AS AdultSupporters\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE u.Age BETWEEN 19 AND 65\nAND b.Name = 'Supporter';"
        ],
        "rule_sql": []
    },
    "898": {
        "question": "How old is the youngest Japanese driver? What is his name?",
        "db_id": "formula_1",
        "ground_truth": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
        "amends": [
            "Do calculate age directly as `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob)` instead of using an alias `age` in the SELECT list. Do place the age calculation expression first in the SELECT list instead of after the name columns. Do use `CURRENT_TIMESTAMP` instead of the string literal `'now'` for the current date reference. Do remove the explicit column alias `AS age` instead of keeping it. The amended query now correctly calculates age without aliasing and uses proper timestamp functions to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the youngest driver: order rows by date of birth in descending order and keep the first 1 row.\n2) When the question specifies Japanese nationality: filter rows where nationality equals exactly 'Japanese'.\n3) When calculating age from date of birth: compute STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob) without using an alias.\n4) When the question asks for both age and name: place the age calculation expression first in the output, followed by forename and surname.\n5) Output columns (ordered): STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename, surname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT forename, surname, (strftime('%Y', 'now') - strftime('%Y', dob)) AS age FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1;",
            "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename, surname FROM drivers WHERE nationality = 'Japanese' ORDER BY STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob) ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename, surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1;"
        ]
    },
    "1395": {
        "question": "How many members did attend the event 'Community Theater' in 2019?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Community Theater' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "amends": [],
        "rules": [
            "event 'Community Theater' in 2019 refers to event_name = 'Community Theater' where YEAR(event_date) = 2019"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.link_to_member) AS member_count\nFROM attendance a\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Community Theater' AND strftime('%Y', e.event_date) = '2019';"
        ],
        "rule_sql": []
    },
    "698": {
        "question": "How many comments and answers were left by the users on the post with the title 'Clustering 1D data'?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CommentCount, AnswerCount FROM posts WHERE Title = 'Clustering 1D data'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH target_post AS (\n    SELECT Id FROM posts WHERE Title = 'Clustering 1D data'\n)\nSELECT \n    (SELECT COUNT(*) FROM comments WHERE PostId = (SELECT Id FROM target_post)) AS comment_count,\n    (SELECT COUNT(*) FROM posts WHERE ParentId = (SELECT Id FROM target_post)) AS answer_count;"
        ],
        "rule_sql": []
    },
    "175": {
        "question": "How many accounts have an owner disposition and request for a statement to be generated upon a transaction?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK PO OBRATU'",
        "amends": [],
        "rules": [
            "Frequency = 'POPLATEK PO OBRATU' stands for issuance after transaction"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS account_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nWHERE d.type = 'OWNER' AND a.frequency = 'POPLATEK PO OBRATU';"
        ],
        "rule_sql": []
    },
    "993": {
        "question": "In which location does the Hungaroring circuit located? Also, find the country and coordinates of this circuit?",
        "db_id": "formula_1",
        "ground_truth": "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring'",
        "amends": [
            "Do remove `name` and `location` from the SELECT list instead of including them, and do keep only `country`, `lat`, and `lng` instead of the original five columns. Do maintain the same FROM source `circuits` and WHERE filter `name = 'Hungaroring'` without changes. The amended query now correctly returns only the country and coordinates data for the specified circuit instead of including unnecessary name and location information."
        ],
        "rules": [
            "1) When the question asks for location, country, and coordinates of a specific circuit: select only country, lat, and lng columns from the circuits table. 2) When filtering for a specific circuit by name: use the exact literal 'Hungaroring' with the name column in the WHERE condition. 3) When the question includes location information but the schema shows location is a separate column: do not include the location column in the output if not explicitly requested. 4) Output columns (ordered): country, lat, lng"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location, country, lat, lng FROM circuits WHERE name = 'Hungaroring';",
            "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring';"
        ],
        "rule_sql": [
            "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring';"
        ]
    },
    "621": {
        "question": "What are the name of badges that users who have the lowest reputation obtained?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
        "amends": [],
        "rules": [
            "lowest reputation refers to Min(Reputation); user refers to UserId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Reputation = (SELECT MIN(Reputation) FROM users);"
        ],
        "rule_sql": []
    },
    "1231": {
        "question": "For patient born between 1936-1956, how many male patients have creatinine phosphokinase beyond the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' AND T1.SEX = 'M' AND T2.CPK >= 250",
        "amends": [],
        "rules": [
            "born between 1936-1956 refers to year(Birthday) BETWEEN '1936' AND '1956'; male patients refers to sex = 'M'; creatinine phosphokinase beyond the normal range refers to CPK > = 250; Should consider DISTINCT in the final result;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' \nAND strftime('%Y', P.Birthday) BETWEEN '1936' AND '1956'\nAND L.CPK >= 250;"
        ],
        "rule_sql": []
    },
    "404": {
        "question": "Indicates the name of all the languages into which the set whose number of cards is 309 is translated.",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.baseSetSize = 309",
        "amends": [],
        "rules": [
            "set refer to setCode; number of cards refers to baseSetSize; baseSetsize = 309\n\n"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT st.language\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.totalSetSize = 309;"
        ],
        "rule_sql": []
    },
    "653": {
        "question": "What is the owner's display name of the most popular post?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "amends": [],
        "rules": [
            "Higher view count means the post has higher popularity; the most popular post refers to MAX(ViewCount);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ViewCount = (SELECT MAX(ViewCount) FROM posts);"
        ],
        "rule_sql": []
    },
    "1487": {
        "question": "Which LAM customer used the Euro as their currency and had the highest consumption in October 2013?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date = '201310' AND T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do select only `CustomerID` instead of including `Segment`, `Currency`, and `Consumption`. Do use `INNER JOIN` with explicit aliases `T1` and `T2` instead of simple `JOIN` with `c` and `y`. Do change the currency filter to `EUR` instead of `Euro`. Do add `GROUP BY T1.CustomerID` instead of omitting aggregation. Do order by `SUM(T2.Consumption)` instead of raw `Consumption`. Do remove the direct selection of `Consumption` and instead aggregate it in the ORDER BY clause. The amended query now correctly identifies the customer with the highest total consumption for the given segment and date period rather than returning a single consumption value.",
            "Do use exact equality `T2.Date = '201310'` instead of pattern matching `T2.Date LIKE '2013-10%'` for the date filter. Do maintain the same join condition `T1.CustomerID = T2.CustomerID` with `INNER JOIN` and keep all other elements including the `SUM(T2.Consumption)` aggregation, `GROUP BY T1.CustomerID`, and `LIMIT 1` unchanged. The amended query now correctly filters for the specific month using exact date comparison instead of pattern matching, ensuring precise date handling while maintaining the same logical behavior for identifying the customer with highest consumption."
        ],
        "rules": [
            "1) When the question asks for a customer with specific segment and currency: filter T1.Segment to 'LAM' and T1.Currency to 'EUR' exactly. 2) When combining customer and consumption data: link T1 and T2 where T1.CustomerID = T2.CustomerID using inner match. 3) When the question specifies a time period \"October 2013\": filter T2.Date to '201310' exactly. 4) When computing total consumption for ranking: sum T2.Consumption per T1.CustomerID. 5) When the question asks for \"highest consumption\": rank customers by sum of T2.Consumption in descending order and keep the top 1 row. 6) When outputting results for identification: select only T1.CustomerID. Output columns (ordered): T1.CustomerID",
            "1) When the question mentions \"highest consumption\": rank rows by the sum of T2.Consumption in descending order and keep the first 1 row.\n2) When filtering for a specific month and year: use exact equality comparison T2.Date = '201310' instead of pattern matching.\n3) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match).\n4) When the question asks for LAM customers: filter T1.Segment = 'LAM' using exact literal matching.\n5) When the question asks for Euro currency: filter T1.Currency = 'EUR' using exact literal matching.\n6) When grouping by customer: organize results by T1.CustomerID and compute aggregates per customer.\n7) When computing consumption totals: calculate the sum of T2.Consumption for each customer group.\nOutput columns (ordered): T1.CustomerID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.CustomerID, c.Segment, c.Currency, y.Consumption\nFROM customers c\nJOIN yearmonth y ON c.CustomerID = y.CustomerID\nWHERE c.Segment = 'LAM' AND c.Currency = 'Euro' AND y.Date = '201310'\nORDER BY y.Consumption DESC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' \nAND T1.Currency = 'EUR'\nAND T2.Date LIKE '2013-10%'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' AND T1.Currency = 'EUR' AND T2.Date = '201310'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM'\n  AND T1.Currency = 'EUR'\n  AND T2.Date = '201310'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ]
    },
    "106": {
        "question": "What is the biggest amount of transaction that the client whose card was opened in 1996/10/21 made?",
        "db_id": "financial",
        "ground_truth": "SELECT T4.amount FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 on T2.account_id = T3.account_id JOIN trans AS T4 on T3.account_id = T4.account_id WHERE T1.issued = '1996-10-21' ORDER BY T4.amount DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(t.amount) AS biggest_transaction_amount\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN card cd ON d.disp_id = cd.disp_id\nWHERE cd.issued = '1996-10-21';"
        ],
        "rule_sql": []
    },
    "289": {
        "question": "Is molecule TR151 carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR151'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT label FROM molecule WHERE molecule_id = 'TR151';"
        ],
        "rule_sql": []
    },
    "616": {
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "amends": [
            "Do reference `T1.Score` instead of `c.Score` for column selection. Do use `INNER JOIN` explicitly instead of just `JOIN` for the table join. Do join on `T1.PostId = T2.Id` instead of `c.PostId = p.Id` using different table aliases. Do filter on `T1.CreationDate` instead of `p.CreationDate` to apply the date condition to the comments table rather than the posts table. The amended query now correctly filters comments by their own creation date rather than the post's creation date, matching the intended behavior.",
            "Do use the full timestamp format '2010-07-19 19:19:56.0' instead of the truncated '2010-07-19 19:19:56' to ensure precise datetime matching. The amended query now correctly matches the RIGHT_SQL's behavior with proper timestamp precision."
        ],
        "rules": [
            "1) When selecting the comment's rating score: use T1.Score as the output column.\n2) When joining comments and posts tables: use INNER JOIN to combine T1 and T2 where T1.PostId = T2.Id, keeping only matching pairs.\n3) When filtering for comments created on 7/19/2010 7:19:56 PM: apply the condition to T1.CreationDate with the exact literal value '2010-07-19 19:19:56.0'.\nOutput columns (ordered): T1.Score",
            "1) When the question asks for a comment's rating score of a post created at a specific timestamp: use the exact timestamp format '2010-07-19 19:19:56.0' with full precision including the decimal zero for milliseconds.\n2) When combining comments T1 and posts T2: link rows where T1.PostId equals T2.Id and keep only matching pairs (inner match).\n3) When filtering by creation date: match the exact timestamp '2010-07-19 19:19:56.0' with precise datetime format including milliseconds.\n4) Output columns (ordered): T1.Score"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.Score\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.CreaionDate = '2010-07-19 19:19:56.0';",
            "SELECT T1.Score\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.CreationDate = '2010-07-19 19:19:56'",
            "SELECT T1.Score \nFROM comments T1 \nINNER JOIN posts T2 ON T1.PostId = T2.Id \nWHERE T1.CreationDate = '2010-07-19 19:19:56.0'"
        ],
        "rule_sql": [
            "SELECT T1.Score\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.CreationDate = '2010-07-19 19:19:56.0'"
        ]
    },
    "911": {
        "question": "Which of these circuits is located at a higher latitude, Silverstone Circuit, Hockenheimring or Hungaroring?",
        "db_id": "formula_1",
        "ground_truth": "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1",
        "amends": [
            "Do remove `lat` from the SELECT list instead of including it, as only the `name` column is needed in the final output while still using `lat` for sorting purposes in the ORDER BY clause. The amended query now correctly returns only the circuit name with the highest latitude among the specified circuits, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the highest value among specific options: rank the specified options by the relevant numeric column in descending order and keep only the top result. 2) When the question mentions specific literal values like 'Silverstone Circuit', 'Hockenheimring', or 'Hungaroring': filter to include only rows matching these exact string literals. 3) When sorting by latitude to find the highest value: use the \"lat\" column from the circuits table for ordering in descending direction. 4) When output should only show the name without the sorting column: include only the \"name\" column in the final output while using other columns for sorting purposes. 5) Output columns (ordered): name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, lat FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;",
            "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;"
        ]
    },
    "64": {
        "question": "What is the total number of schools with a mailing city in Hickman belonging to the charter number 00D4?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(*) FROM schools WHERE CharterNum = '00D4' AND MailCity = 'Hickman'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE MailCity = 'Hickman' AND CharterNum = '00D4';"
        ],
        "rule_sql": []
    },
    "1008": {
        "question": "During which lap did Lewis Hamilton take a pit stop during the 2011 Australian Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.lap FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' AND T3.year = 2011 AND T3.name = 'Australian Grand Prix'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.lap\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nJOIN races r ON p.raceId = r.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND r.year = 2011 AND r.name = 'Australian Grand Prix';"
        ],
        "rule_sql": []
    },
    "419": {
        "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
        "amends": [],
        "rules": [
            "color cards with no borders refers to borderColor = 'borderless'; ranked higher than 12000 on EDHRec refers to edhrecRank > 12000"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE borderColor = 'borderless' AND edhrecRank > 12000;"
        ],
        "rule_sql": []
    },
    "454": {
        "question": "Among the cards with a white border color, how many of them have unknown power?",
        "db_id": "card_games",
        "ground_truth": "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE borderColor = 'white'",
        "amends": [
            "Do use `SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific conditions. Do remove the explicit `WHERE` filter `(power = '*' OR power IS NULL)` instead of keeping it, as the counting logic is now handled within the aggregate expression. Do keep the `WHERE borderColor = 'white'` filter unchanged. The amended query now correctly counts cards where power contains asterisks (not just equals exactly '*') or is NULL, while maintaining the border color filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cards with white border color: filter rows where borderColor equals exactly 'white'. 2) When counting cards with unknown power: count rows where power contains asterisk characters (using pattern matching) or where power is missing (NULL). 3) When computing the count of unknown power cards: use conditional counting that sums 1 for rows matching the unknown power condition and 0 otherwise. 4) When handling power values: check for asterisk patterns using pattern matching rather than exact equality with '*'. 5) Output columns (ordered): the count of unknown power cards among white-bordered cards"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE borderColor = 'white' \nAND (power = '*' OR power IS NULL);",
            "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) \nFROM cards \nWHERE borderColor = 'white'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count_unknown_power\nFROM cards\nWHERE borderColor = 'white' \nAND (power LIKE '%*%' OR power IS NULL)"
        ]
    },
    "920": {
        "question": "Please list all the years that Silverstone Circuit was used in a Formula_1 race.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit';"
        ],
        "rule_sql": []
    },
    "361": {
        "question": "How many cards of legalities whose status is restricted have text boxes?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isTextless = 0",
        "amends": [
            "Do use `COUNT(DISTINCT T1.id)` instead of `COUNT(*)` to count distinct card IDs rather than all rows. Do specify table aliases as `T1` and `T2` instead of `c` and `l` for consistency. Do use `INNER JOIN` with explicit table aliases instead of simple `JOIN` with different aliases. Do reference `T2.status = 'Restricted'` instead of `l.status = 'restricted'` to match the exact case-sensitive value. Do reference `T1.isTextless = 0` instead of `c.isTextless = 0` with the proper table alias. The amended query now correctly counts distinct restricted, non-textless cards matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting cards: use COUNT(DISTINCT T1.id) to count distinct card IDs rather than all rows.\n2) When combining cards and legalities tables: use INNER JOIN to link rows where T1.uuid = T2.uuid and keep only matching pairs.\n3) When filtering for restricted legalities: use T2.status = 'Restricted' (exact case-sensitive value).\n4) When filtering for cards with text boxes: use T1.isTextless = 0 to identify non-textless cards.\n5) Output columns (ordered): COUNT(DISTINCT T1.id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.status = 'restricted' AND c.isTextless = 0;",
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T2.status = 'Restricted' AND T1.isTextless = 0"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1 \nINNER JOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Restricted' \nAND T1.isTextless = 0"
        ]
    },
    "118": {
        "question": "For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.",
        "db_id": "financial",
        "ground_truth": "SELECT CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) FROM loan WHERE amount < 100000",
        "amends": [],
        "rules": [
            "Status = 'C' stands for running contract, ok so far; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN l.status = 'C' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    loan l\nJOIN \n    account a ON l.account_id = a.account_id\nWHERE \n    l.amount < 100000;"
        ],
        "rule_sql": []
    },
    "706": {
        "question": "Give the texts commented on the post about linear regression.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title LIKE '%linear regression%'",
        "amends": [],
        "rules": [
            "about linear regression refers to Title contains 'linear regression'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Text \nFROM comments c \nJOIN posts p ON c.PostId = p.Id \nWHERE p.Title LIKE '%linear regression%' OR p.Tags LIKE '%linear regression%';"
        ],
        "rule_sql": []
    },
    "791": {
        "question": "Calculate the average height for each superhero.",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero",
        "amends": [
            "Do use `CAST(SUM(height_cm) AS REAL) / COUNT(id)` instead of `AVG(height_cm) AS average_height` to calculate the average with proper type casting and count by `id` instead of relying on the built-in AVG function. Do remove `superhero_name` from the SELECT list and `GROUP BY superhero_name` instead of grouping by name when calculating an overall average across all superheroes. Do omit the column alias `average_height` instead of including it since the query now returns a single aggregate value. The amended query now correctly calculates the overall average height across all superheroes by summing heights and dividing by count with proper real number casting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating an average across all superheroes: use CAST(SUM(height_cm) AS REAL) / COUNT(id) instead of AVG(height_cm) to ensure proper type casting and count by the canonical key id. 2) When computing an overall average for all superheroes: do not include superhero_name in the SELECT list and do not use GROUP BY superhero_name. 3) When returning a single aggregate value: omit column aliases like average_height. 4) When counting superhero entities: use the canonical key id from the superpower table as the counting key. Output columns (ordered): (single aggregate value)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero_name, AVG(height_cm) AS average_height FROM superhero GROUP BY superhero_name;",
            "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero;"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero;"
        ]
    },
    "145": {
        "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
        "amends": [
            "Do use a simple `SELECT` query instead of a CTE structure. Do select only `account_id` instead of `client_id` through multiple joins. Do join with `account` table on `account_id` instead of joining with `disp` and `client` tables. Do move the `operation` and date filter conditions to the main `WHERE` clause instead of placing them in a CTE. Do calculate the average amount directly in a subquery with the same date filter instead of using a separate CTE. Do remove the `DISTINCT` modifier instead of keeping it. Do reference the same table alias `T1` consistently instead of using different aliases like `cct`. The amended query now correctly filters transactions from 1998 with the specified operation and compares amounts against the average for that year directly.",
            "Do add `INNER JOIN account AS T2 ON T1.account_id = T2.account_id` instead of querying only the `trans` table. Do change the date filter to `STRFTIME('%Y', T1.date) = '1998'` instead of `BETWEEN '1998-01-01' AND '1998-12-31'`. Do change the operation filter to `T1.operation = 'VYBER KARTOU'` instead of `operation = 'credit card'`. Do remove the operation filter from the subquery's `WHERE` clause instead of keeping it, changing `(SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')` instead of `(SELECT AVG(amount) FROM trans WHERE date BETWEEN '1998-01-01' AND '1998-12-31' AND operation = 'credit card')`. Do add table alias `T1` to all column references instead of using unqualified column names. The amended query now correctly joins with the account table, uses proper year extraction, filters for the correct operation type, and calculates the average amount across all 1998 transactions instead of only credit card operations, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for account holder identification numbers: select account_id from the account table.\n2) When filtering for transactions with operation type 'VYBER KARTOU': include only rows where operation equals 'VYBER KARTOU' exactly.\n3) When filtering for transactions in 1998: include only rows where the year part of the date equals 1998.\n4) When comparing amounts against the average: calculate the average amount from transactions meeting the same operation and date conditions, then filter for amounts less than this average.\n5) When joining tables: use the account table and join on account_id to access account holder information.\n6) When selecting output: do not use DISTINCT modifier to return all matching account IDs.\n7) When using table aliases: consistently use T1 for the main transaction table throughout the query.\nOutput columns (ordered): account_id",
            "1) When the question asks for account holder identification numbers: output T2.account_id from the account table.\n2) When filtering transactions by year 1998: use STRFTIME('%Y', T1.date) = '1998' to extract the year from the date column.\n3) When filtering for credit card transactions: use T1.operation = 'VYBER KARTOU' as the exact operation type filter.\n4) When comparing transaction amounts to the average: compute the average amount using (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998') across all 1998 transactions.\n5) When combining transaction and account data: perform an inner join between trans as T1 and account as T2 using T1.account_id = T2.account_id to link related records.\n6) When filtering by amount condition: use T1.amount < (subquery result) to find transactions below the average amount.\nOutput columns (ordered): T2.account_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH credit_card_transactions AS (\n    SELECT account_id, amount\n    FROM trans\n    WHERE operation = 'VYBER KARTOU'\n    AND strftime('%Y', date) = '1998'\n),\naverage_amount AS (\n    SELECT AVG(amount) AS avg_amount\n    FROM credit_card_transactions\n)\nSELECT DISTINCT c.client_id\nFROM credit_card_transactions cct\nJOIN disp d ON cct.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE cct.amount < (SELECT avg_amount FROM average_amount);",
            "SELECT account_id\nFROM trans\nWHERE date BETWEEN '1998-01-01' AND '1998-12-31'\n  AND operation = 'credit card'\n  AND amount < (SELECT AVG(amount) FROM trans WHERE date BETWEEN '1998-01-01' AND '1998-12-31' AND operation = 'credit card')",
            "SELECT T1.account_id\nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1998'\nAND T1.operation = 'VYBER KARTOU'\nAND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')"
        ],
        "rule_sql": [
            "SELECT T2.account_id\nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.operation = 'VYBER KARTOU'\nAND STRFTIME('%Y', T1.date) = '1998'\nAND T1.amount < (\n    SELECT AVG(amount)\n    FROM trans\n    WHERE STRFTIME('%Y', date) = '1998'\n)"
        ]
    },
    "525": {
        "question": "Find the uuid of cards in which the old school format is restricted or banned.",
        "db_id": "card_games",
        "ground_truth": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')",
        "amends": [
            "Do use uppercase status values `'Banned'` and `'Restricted'` in the WHERE clause filter instead of lowercase `'banned'` and `'restricted'` to match the correct case sensitivity in the data. The amended query now correctly filters for the intended status values with proper capitalization, ensuring it matches the RIGHT_SQL's behavior.",
            "Do use lowercase `'oldschool'` for the format comparison instead of `'Old School'` to match the actual data format. Do use explicit `OR` conditions with parentheses `(status = 'Banned' OR status = 'Restricted')` instead of `IN ('Banned', 'Restricted')` to ensure proper boolean logic evaluation. The amended query now correctly filters for the 'oldschool' format and properly handles the banned/restricted status conditions to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cards with old school format that are restricted or banned: filter rows where format equals 'oldschool' and status equals either 'Banned' or 'Restricted'.\n2) When handling text literals for status values: use exact case-sensitive values 'Banned' and 'Restricted' (not lowercase versions).\n3) When selecting output columns: return only the uuid column from the filtered results.\nOutput columns (ordered): uuid",
            "1) When the question asks for cards with old school format restrictions: use the exact literal 'oldschool' (lowercase) for format comparison instead of 'Old School'. 2) When filtering for banned or restricted status: use explicit OR conditions with parentheses (status = 'Banned' OR status = 'Restricted') instead of IN clauses. 3) When querying the legalities table for card restrictions: select the uuid column to identify affected cards. 4) Output columns (ordered): uuid"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'banned' OR status = 'restricted');",
            "SELECT uuid FROM legalities WHERE format = 'Old School' AND status IN ('Banned', 'Restricted')",
            "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')"
        ],
        "rule_sql": [
            "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')"
        ]
    },
    "432": {
        "question": "Which Russian set of cards contains the most cards overall?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Russian' GROUP BY T1.baseSetSize ORDER BY T1.baseSetSize DESC LIMIT 1",
        "amends": [
            "Do select `T1.id` instead of `s.name, s.baseSetSize` and do group by `T1.baseSetSize` instead of omitting grouping. Do use table aliases `T1` and `T2` instead of `s` and `st`, and do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T1.baseSetSize` in ORDER BY instead of `s.baseSetSize`. The amended query now correctly groups by the baseSetSize and selects only the id while maintaining the same filtering logic for Russian language set translations."
        ],
        "rules": [
            "1) When the question asks for \"most cards overall\" in Russian sets: rank sets by T1.baseSetSize in descending order and keep the first 1 row.\n2) When combining T1 and T2 for Russian set translations: link rows where T1.code = T2.setCode and keep only matching pairs (inner match).\n3) When filtering for Russian language: include only rows where T2.language equals exactly 'Russian'.\n4) When grouping by set size: organize results by T1.baseSetSize and compute aggregates per group.\n5) Output columns (ordered): T1.id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name, s.baseSetSize\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Russian'\nORDER BY s.baseSetSize DESC\nLIMIT 1;",
            "SELECT T1.id\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Russian'\nGROUP BY T1.baseSetSize\nORDER BY T1.baseSetSize DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.id\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Russian'\nORDER BY T1.baseSetSize DESC\nLIMIT 1;"
        ]
    },
    "1": {
        "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
        "db_id": "california_schools",
        "ground_truth": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3",
        "amends": [
            "Do remove `School Name` from the SELECT list instead of including it. Do change the WHERE filter to use `Educational Option Type` = 'Continuation School' instead of `School Type` = 'Continuation'. Do replace the `Enrollment (Ages 5-17)` > 0 condition with `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL instead of the enrollment check. Do update the ORDER BY clause to reference the full calculation expression instead of the alias `Eligible Free Rate`. The amended query now correctly filters for continuation schools using the proper column name, ensures valid rate calculations by checking for non-null results rather than just positive enrollment, and maintains consistent expression usage throughout.",
            "Do select the expression `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` instead of selecting `CDSCode` and aliasing the expression as `Eligible Free Rate`. Do use backticks around column names `Free Meal Count (Ages 5-17)` and `Enrollment (Ages 5-17)` instead of double quotes. Do order by the expression `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` instead of ordering by the alias `Percent (%) Eligible Free (Ages 5-17)`. The amended query now correctly calculates and orders by the free meal eligibility rate directly rather than using an aliased column reference."
        ],
        "rules": [
            "1) When the question asks for eligible free rates: compute the ratio of \"Free Meal Count (Ages 5-17)\" divided by \"Enrollment (Ages 5-17)\" as the rate calculation.\n2) When filtering for continuation schools: use the condition \"Educational Option Type\" = 'Continuation School' instead of \"School Type\" = 'Continuation'.\n3) When ensuring valid rate calculations: check that \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" IS NOT NULL rather than checking \"Enrollment (Ages 5-17)\" > 0.\n4) When ordering by the calculated rate: reference the full calculation expression \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" instead of using an alias.\n5) When the question asks for the lowest three rates: order the rates in ascending order and keep the first 3 rows.\n6) When the question asks to list rates without school names: exclude \"School Name\" from the output columns.\nOutput columns (ordered): \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" AS \"Eligible Free Rate\"",
            "1) When the question asks for \"eligible free rates\": compute the expression `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` as the rate value.\n2) When the question specifies \"continuation schools\": filter rows where \"Educational Option Type\" equals exactly 'Continuation School'.\n3) When the question asks for \"lowest three\" rates: order rows by the computed rate `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` in ascending order and keep the first 3 rows.\n4) When computing the rate expression: ensure both `Free Meal Count (Ages 5-17)` and `Enrollment (Ages 5-17)` are not null to avoid division errors.\n5) When selecting output columns: include only the computed rate expression, not the original CDSCode column.\n6) When using column identifiers: use backticks around `Free Meal Count (Ages 5-17)` and `Enrollment (Ages 5-17)` as specified in the amends.\nOutput columns (ordered): `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` AS \"Eligible Free Rate\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    `School Name`,\n    `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` AS `Eligible Free Rate`\nFROM \n    frpm\nWHERE \n    `School Type` = 'Continuation'\n    AND `Enrollment (Ages 5-17)` > 0\nORDER BY \n    `Eligible Free Rate` ASC\nLIMIT 3;",
            "SELECT CDSCode, \"Percent (%) Eligible Free (Ages 5-17)\" AS \"Eligible Free Rate\"\nFROM frpm\nWHERE \"Educational Option Type\" = 'Continuation School' \nAND \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" IS NOT NULL\nORDER BY \"Percent (%) Eligible Free (Ages 5-17)\" ASC\nLIMIT 3;",
            "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` \nFROM frpm \nWHERE `Educational Option Type` = 'Continuation School' \nAND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL \nORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` \nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` AS \"Eligible Free Rate\"\nFROM frpm\nWHERE \"Educational Option Type\" = 'Continuation School'\nAND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL\nORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC\nLIMIT 3"
        ]
    },
    "1529": {
        "question": "What is the amount spent by customer \"38508\" at the gas stations? How much had the customer spent in January 2012?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUM(T1.Price) , SUM(IIF(T3.Date = '201201', T1.Price, 0)) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.CustomerID = '38508'",
        "amends": [
            "Do join `gasstations` and `yearmonth` tables instead of querying `transactions_1k` alone. Do use `SUM(T1.Price)` instead of `SUM(Amount * Price)` for the total amount calculation. Do add `IIF(T3.Date = '201201', T1.Price, 0)` instead of a separate query for January 2012 spending. Do filter by `T1.CustomerID = '38508'` with string comparison instead of numeric comparison. Do remove the `Amount` multiplication and instead use `Price` directly in the aggregation. The amended query now correctly calculates both total spending and January 2012 spending in a single query with proper table joins."
        ],
        "rules": [
            "1) When the question asks for spending by a specific customer at gas stations: filter transactions where T1.CustomerID equals '38508' exactly as a string.\n2) When calculating total amount spent: use SUM(T1.Price) instead of multiplying Amount and Price.\n3) When calculating spending for a specific month (January 2012): use IIF(T3.Date = '201201', T1.Price, 0) to conditionally include only January 2012 transactions.\n4) When combining transaction data with gas station information: join tables using the appropriate keys to ensure only gas station transactions are considered.\n5) When combining transaction data with date information: join with yearmonth table to access the '201201' date format for January 2012 filtering.\n6) When handling customer ID comparisons: use string comparison (T1.CustomerID = '38508') instead of numeric comparison.\n7) Output columns (ordered): TotalAmountSpent, January2012AmountSpent"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "-- Total amount spent by customer 38508 at gas stations\nSELECT SUM(Amount * Price) AS TotalAmountSpent\nFROM transactions_1k\nWHERE CustomerID = 38508;\n\n-- Amount spent by customer 38508 in January 2012\nSELECT SUM(Amount * Price) AS January2012AmountSpent\nFROM transactions_1k\nWHERE CustomerID = 38508 AND Date LIKE '201201%';",
            "SELECT \n    SUM(T1.Price) AS TotalAmountSpent,\n    SUM(IIF(T3.Date = '201201', T1.Price, 0)) AS January2012Spending\nFROM \n    transactions_1k T1\nJOIN \n    gasstations T2 ON T1.GasStationID = T2.GasStationID\nJOIN \n    yearmonth T3 ON T1.CustomerID = T3.CustomerID\nWHERE \n    T1.CustomerID = '38508'"
        ],
        "rule_sql": [
            "SELECT \n    SUM(T1.Price) AS TotalAmountSpent,\n    SUM(IIF(T3.Date = '201201', T1.Price, 0)) AS January2012AmountSpent\nFROM \n    transactions_1k T1\nJOIN \n    gasstations G ON T1.GasStationID = G.GasStationID\nJOIN \n    yearmonth T3 ON T1.CustomerID = T3.CustomerID AND strftime('%Y%m', T1.Date) = T3.Date\nWHERE \n    T1.CustomerID = '38508'"
        ]
    },
    "672": {
        "question": "Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4",
        "amends": [
            "Do use `COUNT(T1.Id)` instead of `COUNT(DISTINCT u.Id) AS UserCount` to count all matching rows rather than distinct user IDs. Do reference tables as `T1` and `T2` instead of `u` and `p` for table aliases. Do use `INNER JOIN` instead of `JOIN` for explicit join type specification. Do remove the `AS UserCount` alias instead of keeping it since the column alias is not needed. The amended query now correctly counts all users from the United Kingdom with posts having at least 4 favorites, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting users from the United Kingdom with posts having at least 4 favorites: use COUNT(T1.Id) to count all matching rows rather than distinct user IDs. 2) When referencing tables: use T1 for the users table and T2 for the posts table as aliases. 3) When combining users and posts tables: use INNER JOIN to link rows where T1.Id = T2.OwnerUserId and keep only matching pairs. 4) When filtering by location: use T1.Location = 'United Kingdom' with exact case and spacing. 5) When filtering by favorite count: use T2.FavoriteCount >= 4 to include posts with 4 or more favorites. 6) Output columns (ordered): COUNT(T1.Id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT u.Id) AS UserCount\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE u.Location = 'United Kingdom' AND p.FavoriteCount >= 4;",
            "SELECT COUNT(T1.Id) \nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.Location = 'United Kingdom' \nAND T2.FavoriteCount >= 4"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4"
        ]
    },
    "990": {
        "question": "What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "amends": [],
        "rules": [
            "the time of the champion shows in the format of \"minutes: seconds.millionsecond\" in which Max(time); constructor reference name refers to constructorRef; website refers to url"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.constructorRef, c.url\nFROM constructors c\nJOIN results r ON c.constructorId = r.constructorId\nJOIN races ra ON r.raceId = ra.raceId\nWHERE ra.year = 2009 AND ra.name = 'Singapore Grand Prix' AND r.positionOrder = 1;"
        ],
        "rule_sql": []
    },
    "262": {
        "question": "Among the single bond molecule id, which molecules are not carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; single bond refers to bond_type = '-';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT b.molecule_id\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '-' AND m.label = '-';"
        ],
        "rule_sql": []
    },
    "1353": {
        "question": "What's Christof Nielson's zip code type?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.type FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Christof' AND T1.last_name = 'Nielson'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT z.type \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE m.first_name = 'Christof' AND m.last_name = 'Nielson';"
        ],
        "rule_sql": []
    },
    "338": {
        "question": "What is the atom ID of double bonded carbon in TR012 molecule?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T2.molecule_id = 'TR012' AND T3.bond_type = '=' AND T1.element = 'c'",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it. Do change the `SELECT` list to reference `T1.atom_id` instead of `a.atom_id`. Do replace the complex join structure with `INNER JOIN molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of joining through `connected` and `bond` tables. Do add `INNER JOIN bond AS T3` on `T2.molecule_id = T3.molecule_id` instead of joining through `connected`. Do change the `WHERE` condition to use `T2.molecule_id = 'TR012'` instead of `m.label = 'TR012'`. Do modify the bond type filter to use `T3.bond_type = '='` instead of `b.bond_type = ' = '` (removing the extra space). Do keep the element filter as `T1.element = 'c'` but with proper table alias. The amended query now correctly filters atoms by molecule ID directly rather than through a complex join path, ensuring proper relationship between molecules and bonds."
        ],
        "rules": [
            "1) When the question asks for atom ID of a specific molecule: filter atoms using T1.molecule_id = 'TR012' instead of joining through connected and bond tables.\n2) When filtering for double bonded carbon atoms: use T3.bond_type = '=' (without spaces) instead of ' = ' with spaces.\n3) When filtering for carbon element: use T1.element = 'c' with exact lowercase letter.\n4) When joining molecule table: use INNER JOIN molecule AS T2 on T1.molecule_id = T2.molecule_id for direct molecule relationship.\n5) When joining bond table: use INNER JOIN bond AS T3 on T2.molecule_id = T3.molecule_id instead of joining through connected table.\n6) When selecting output: use T1.atom_id without DISTINCT modifier.\nOutput columns (ordered): T1.atom_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.atom_id\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = 'TR012' AND a.element = 'c' AND b.bond_type = ' = ';",
            "SELECT T1.atom_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T2.molecule_id = 'TR012'\nAND T3.bond_type = '='\nAND T1.element = 'c'"
        ],
        "rule_sql": [
            "SELECT T1.atom_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T1.molecule_id = 'TR012'\nAND T1.element = 'c'\nAND T3.bond_type = '='"
        ]
    },
    "478": {
        "question": "What is card number 4 in the set Coldsnap?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.number = 4",
        "amends": [
            "Do select only `T1.name` instead of all columns with `*`. Do join `sets AS T2` instead of querying only the `cards` table. Do use `INNER JOIN` with `T2.code = T1.setCode` instead of filtering directly on `setCode`. Do filter on `T2.name = 'Coldsnap'` instead of `setCode = 'Coldsnap'`. Do use numeric comparison `T1.number = 4` instead of string comparison `number = '4'`. The amended query now correctly joins the sets table to filter by set name rather than set code and uses proper data type comparisons."
        ],
        "rules": [
            "1) When the question asks for a specific card number in a named set: join the cards table (T1) with the sets table (T2) using an inner match where T2.code equals T1.setCode. 2) When filtering by set name 'Coldsnap': use the exact literal 'Coldsnap' with T2.name. 3) When filtering by card number 4: use numeric comparison with T1.number equals 4. 4) When selecting output columns: return only T1.name instead of all columns. 5) Output columns (ordered): T1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE setCode = 'Coldsnap' AND number = '4';",
            "SELECT T1.name \nFROM cards AS T1 \nINNER JOIN sets AS T2 ON T2.code = T1.setCode \nWHERE T2.name = 'Coldsnap' AND T1.number = 4"
        ],
        "rule_sql": [
            "SELECT cards.name FROM cards JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap' AND cards.number = '4';"
        ]
    },
    "874": {
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
        "amends": [],
        "rules": [
            "finished second refers to position = 2;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE rc.name = 'San Marino Grand Prix' AND rc.year = 2006 AND r.position = 2;"
        ],
        "rule_sql": []
    },
    "795": {
        "question": "How many superheroes have a neutral alignment?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "amends": [],
        "rules": [
            "neutral alignment refers to alignment_id = 3;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superhero WHERE alignment_id = 3;"
        ],
        "rule_sql": []
    },
    "368": {
        "question": "What is the percentage of borderless cards?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "amends": [],
        "rules": [
            "borderless card refers to borderColor = 'borderless'; percentage = Divide(Count (id) where borderColor = 'borderless', Count(id)) *100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN borderColor = 'borderless' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_borderless_cards FROM cards;"
        ],
        "rule_sql": []
    },
    "945": {
        "question": "How many circuits are there in Adelaide, Australia?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia'",
        "amends": [],
        "rules": [
            "Australia is the country; Melbourne is the location of circuit;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia';"
        ],
        "rule_sql": []
    },
    "1309": {
        "question": "Please list a patient's platelet level if it is within the normal range and if he or she is diagnosed with MCTD.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T2.PLT FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'MCTD' AND T2.PLT BETWEEN 100 AND 400",
        "amends": [
            "Do select only `T2.PLT` instead of selecting both `P.ID` and `L.PLT`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `P` and `L`. Do use `BETWEEN 100 AND 400` for the PLT range condition instead of separate `> 100 AND < 400` conditions. Do remove the selection of patient ID `P.ID` instead of including it in the output. The amended query now correctly returns only platelet values for MCTD patients within the specified range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a patient's platelet level: select only T2.PLT as the output column. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner match. 3) When filtering for patients diagnosed with MCTD: include only rows where T1.Diagnosis equals 'MCTD' exactly. 4) When checking if platelet level is within normal range: include only rows where T2.PLT is between 100 and 400 inclusive. 5) Output columns (ordered): T2.PLT"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, L.PLT\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'MCTD'\nAND L.PLT > 100 AND L.PLT < 400;",
            "SELECT T2.PLT \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'MCTD' \nAND T2.PLT BETWEEN 100 AND 400"
        ],
        "rule_sql": [
            "SELECT T2.PLT\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'MCTD'\nAND T2.PLT BETWEEN 100 AND 400"
        ]
    },
    "192": {
        "question": "What is the average amount of loan which are still on running contract with statement issuance after each transaction?",
        "db_id": "financial",
        "ground_truth": "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'",
        "amends": [
            "Do join `account AS T1` instead of omitting it, and do use `INNER JOIN loan AS T2` instead of joining with `trans t`. Do filter on `T2.status IN ('C', 'D')` instead of filtering on the wrong table's status, and do filter on `T1.frequency = 'POPLATEK PO OBRATU'` instead of filtering on `trans.k_symbol`. Do remove the alias `AS average_loan_amount` instead of keeping it. The amended query now correctly calculates average loan amounts for accounts with the specified frequency and loan status, matching the intended behavior."
        ],
        "rules": [
            "1) When joining account and loan tables: use T1 for account and T2 for loan, linking rows where T1.account_id = T2.account_id and keeping only matching pairs (inner match). 2) When filtering for accounts with frequency 'POPLATEK PO OBRATU': include only rows where T1.frequency = 'POPLATEK PO OBRATU'. 3) When filtering for loans with status 'C' or 'D': include only rows where T2.status IN ('C', 'D'). 4) When calculating average loan amount: compute the average of T2.amount. 5) Output columns (ordered): AVG(T2.amount)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(l.amount) AS average_loan_amount\nFROM loan l\nJOIN trans t ON l.account_id = t.account_id\nWHERE l.status IN ('C', 'D') AND t.k_symbol = 'POPLATEK PO OBRATU';",
            "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.amount) \nFROM account AS T1 \nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id \nWHERE T1.frequency = 'POPLATEK PO OBRATU' \nAND T2.status IN ('C', 'D')"
        ]
    },
    "758": {
        "question": "Provide the hair colour of the human superhero who is 185 cm tall.",
        "db_id": "superhero",
        "ground_truth": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
        "amends": [],
        "rules": [
            "185 cm tall refers to height_cm = 185; human superhero refers to race = 'human'; hair colour refers to colour where hair_colour_id = colour.id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nJOIN colour c ON s.hair_colour_id = c.id\nWHERE r.race = 'Human' AND s.height_cm = 185;"
        ],
        "rule_sql": []
    },
    "1403": {
        "question": "Indicate the name of the closed event whose cost has exceeded the budget the most.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event WHERE T1.event_status = 'Closed' AND T1.remaining < 0 ORDER BY T1.remaining LIMIT 1",
        "amends": [],
        "rules": [
            "closed events refers to event_name where status = 'Closed'; exceed the budget the most refers to MIN(remaining) where remaining < 0"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.status = 'Closed' AND b.remaining < 0\nORDER BY b.remaining ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "775": {
        "question": "What is the percentage of blue female superheroes among all female superheroes?",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.colour = 'Blue' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.gender = 'Female'",
        "amends": [],
        "rules": [
            "percentage = MULTIPLY(DIVIDE(SUM(colour = 'Blue' WHERE gender = 'Female'), COUNT(gender = 'Female')), 100); blue refers to the color = 'Blue' WHERE skin_colour_id = colour.id; female refers to gender = 'Female';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.colour = 'Blue' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_blue_female\nFROM \n    superhero s\nJOIN \n    gender g ON s.gender_id = g.id\nLEFT JOIN \n    colour c ON s.skin_colour_id = c.id\nWHERE \n    g.gender = 'Female';"
        ],
        "rule_sql": []
    },
    "1197": {
        "question": "When was the medical information on patient number 48473 first documented, and what disease did she have?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT `First Date`, Diagnosis FROM Patient WHERE ID = 48473",
        "amends": [],
        "rules": [
            "medical information first documented refers to Description; disease refers to diagnosis; patient number refers to id"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.`First Date`, e.Diagnosis FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE p.ID = 48473 ORDER BY p.`First Date` LIMIT 1;"
        ],
        "rule_sql": []
    },
    "530": {
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "amends": [
            "Do select `frameVersion`, `name`, and a conditional expression instead of separate queries for distinct frame styles, artist cards, and banned cards. Do use `INNER JOIN` on `T1.uuid = T2.uuid` instead of separate queries with different join conditions. Do add filter `T1.artist = 'Allen Williams'` instead of having it as a separate query. Do include conditional logic `IIF(T2.status = 'Banned', T1.name, 'NO')` instead of querying banned cards separately. Do remove the `IS NOT NULL` filter on `frameVersion` since it's now part of the combined result set. The amended query now correctly combines all three original query requirements into a single cohesive result that shows Allen Williams' cards with their frame versions and banned status indication, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for frame styles and cards worked on by Allen Williams: select T1.frameVersion and T1.name from table cards as T1 where T1.artist = 'Allen Williams'.\n2) When combining information about card legality: join T1 (cards) with T2 (legalities) where T1.uuid = T2.uuid using an inner match.\n3) When identifying banned cards: include a conditional expression that returns T1.name when T2.status = 'Banned', otherwise return 'NO'.\n4) When selecting output columns: include frameVersion, name, and the banned status indicator in the result set.\n5) When filtering for Allen Williams' work: apply the condition T1.artist = 'Allen Williams' to restrict results to only his cards.\n6) Output columns (ordered): T1.frameVersion, T1.name, IIF(T2.status = 'Banned', T1.name, 'NO')"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "-- Query to list all distinct frame styles (frameVersion)\nSELECT DISTINCT frameVersion FROM cards WHERE frameVersion IS NOT NULL;\n\n-- Query to list all cards Allen Williams worked on\nSELECT * FROM cards WHERE artist = 'Allen Williams';\n\n-- Query to find any banned cards\nSELECT c.* FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE l.status = 'Banned';",
            "SELECT \n    c.frameVersion, \n    c.name, \n    IIF(l.status = 'Banned', c.name, 'NO') AS banned_status\nFROM \n    cards c\nINNER JOIN \n    legalities l ON c.uuid = l.uuid\nWHERE \n    c.artist = 'Allen Williams'\nGROUP BY \n    c.frameVersion, c.name"
        ],
        "rule_sql": [
            "SELECT T1.frameVersion, T1.name, IIF(T2.status = 'Banned', T1.name, 'NO') \nFROM cards AS T1 \nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid \nWHERE T1.artist = 'Allen Williams'"
        ]
    },
    "988": {
        "question": "List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3",
        "amends": [
            "Do select only `forename` and `surname` instead of including `AVG(p.duration)` with an alias. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with single-letter aliases. Do change the date filter to use `STRFTIME('%Y', T2.dob)` between year strings instead of direct date range comparison with `BETWEEN`. Do group by only `forename` and `surname` instead of including `driverId`. Do order by `AVG(T1.duration)` directly instead of using the alias `avg_pitstop_duration`. The amended query now correctly handles year extraction for date filtering and maintains proper aggregation semantics."
        ],
        "rules": [
            "1) When the question asks for top 3 results: rank rows by the specified metric and keep the first 3 rows.\n2) When the question mentions \"German drivers\": filter rows where T2.nationality equals 'German' exactly.\n3) When the question specifies birth years between 1980-1985: filter rows where STRFTIME('%Y', T2.dob) is between '1980' and '1985' inclusive.\n4) When combining T1 (pitStops) and T2 (drivers): link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match).\n5) When computing average pit stop duration: calculate AVG(T1.duration) per driver.\n6) When grouping by driver attributes: organize results by T2.forename and T2.surname.\n7) When ordering by shortest average duration: sort rows by AVG(T1.duration) in ascending order.\n8) When selecting output columns: include only T2.forename and T2.surname in the results.\nOutput columns (ordered): T2.forename, T2.surname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname, AVG(p.duration) AS avg_pitstop_duration\nFROM drivers d\nJOIN pitStops p ON d.driverId = p.driverId\nWHERE d.nationality = 'German' AND d.dob BETWEEN '1980-01-01' AND '1985-12-31'\nGROUP BY d.driverId, d.forename, d.surname\nORDER BY avg_pitstop_duration ASC\nLIMIT 3;",
            "SELECT T2.forename, T2.surname\nFROM pitStops T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German' \nAND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985'\nGROUP BY T2.forename, T2.surname\nORDER BY AVG(T1.duration)\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT d.forename, d.surname\nFROM drivers d\nJOIN pitStops ps ON d.driverId = ps.driverId\nWHERE d.nationality = 'German'\nAND STRFTIME('%Y', d.dob) BETWEEN '1980' AND '1985'\nGROUP BY d.driverId, d.forename, d.surname\nORDER BY AVG(ps.duration) ASC\nLIMIT 3"
        ]
    },
    "287": {
        "question": "Among all chemical compounds that contain molecule TR047, identify the percent that form a double-bond.",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T WHERE T.molecule_id = 'TR047'",
        "amends": [
            "Do use `COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END)` instead of `SUM(CASE WHEN bond_type = ' = ' THEN 1 ELSE 0 END)` to properly count matching bonds. Do remove the extra spaces around the equals sign in `'='` instead of `' = '` to match the actual bond type format. Do cast the count to `REAL` instead of using `100.0` to ensure floating-point division. Do use explicit table alias `T` with column references instead of unqualified column names. Do count `T.bond_id` instead of `COUNT(*)` to be more precise about what's being counted. The amended query now correctly calculates the percentage of double bonds by properly identifying the bond type and ensuring accurate floating-point arithmetic."
        ],
        "rules": [
            "1) When counting bonds that form a double-bond: use the exact literal '=' (without spaces) for bond_type comparison instead of ' = '.\n2) When calculating percentage of double bonds: count matching bonds using COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) instead of SUM with 1/0 logic.\n3) When performing division for percentage calculation: cast the count to REAL type instead of using 100.0 to ensure floating-point arithmetic.\n4) When referencing columns in the bond table: use explicit table alias T with column references (e.g., T.bond_type, T.bond_id) instead of unqualified column names.\n5) When counting total bonds for percentage calculation: count T.bond_id specifically instead of using COUNT(*) to be precise about what's being counted.\nOutput columns (ordered): percent_double_bonds"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN bond_type = ' = ' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percent_double_bonds\nFROM bond\nWHERE molecule_id = 'TR047';",
            "SELECT \n    (COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) * 100.0 / COUNT(T.bond_id)) AS percent_double_bonds\nFROM \n    bond T\nWHERE \n    T.molecule_id = 'TR047';"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) / COUNT(T.bond_id)) * 100 AS percent_double_bonds\nFROM \n    bond T\nJOIN \n    molecule M ON T.molecule_id = M.molecule_id\nWHERE \n    M.label = 'TR047';"
        ]
    },
    "603": {
        "question": "What is the sum of favourite count gained by user ID 686 in 2011?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT SUM(DISTINCT FavoriteCount) FROM posts WHERE Id IN ( SELECT PostId FROM postHistory WHERE UserId = 686 AND STRFTIME('%Y', CreationDate) = '2011' )",
        "amends": [
            "Do use `SUM(DISTINCT FavoriteCount)` instead of `SUM(FavoriteCount)` to avoid double-counting duplicate values. Do change the source table by filtering `posts` where `Id IN` a subquery instead of directly filtering on `OwnerUserId`. Do replace the direct `WHERE OwnerUserId = 686` condition with a subquery that selects `PostId` from `postHistory` where `UserId = 686` instead. Do correct the table reference from `posts` to `postHistory` for the date filter and fix the column name from `CreaionDate` to `CreationDate` in the subquery. Do remove the alias `AS TotalFavoriteCount` instead of keeping it. The amended query now correctly calculates distinct favorite counts for posts with history entries from the specified user and year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for sum of favorite count for a specific user ID and year: use SUM(DISTINCT FavoriteCount) instead of SUM(FavoriteCount) to avoid double-counting duplicate values.\n2) When filtering for user ID 686: use a subquery that selects PostId from postHistory where UserId = 686 instead of directly filtering on OwnerUserId.\n3) When filtering for year 2011: use strftime('%Y', CreationDate) = '2011' with the correct column name CreationDate (not CreaionDate) in the subquery.\n4) When the source table is posts: filter where Id IN the subquery results from postHistory instead of direct filtering.\n5) When producing output: do not include an alias like AS TotalFavoriteCount.\n6) When combining data from posts and postHistory: link rows where posts.Id IN (subquery results from postHistory with UserId = 686 and year 2011 filter).\nOutput columns (ordered): SUM(DISTINCT FavoriteCount)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(FavoriteCount) AS TotalFavoriteCount FROM posts WHERE OwnerUserId = 686 AND strftime('%Y', CreaionDate) = '2011';",
            "SELECT SUM(DISTINCT p.FavoriteCount) \nFROM posts p \nWHERE p.Id IN (\n    SELECT ph.PostId \n    FROM postHistory ph \n    WHERE ph.UserId = 686 \n    AND strftime('%Y', ph.CreationDate) = '2011'\n)"
        ],
        "rule_sql": [
            "SELECT SUM(DISTINCT FavoriteCount) FROM posts WHERE Id IN (SELECT PostId FROM postHistory WHERE UserId = 686 AND strftime('%Y', CreationDate) = '2011')"
        ]
    },
    "271": {
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "amends": [
            "Do select specific columns `T2.bond_id`, `T2.atom_id2`, and `T1.element AS flag_have_CaCl` instead of a CASE expression that aggregates and checks for element combinations. Do use `INNER JOIN` between `atom AS T1` and `connected AS T2` on `T2.atom_id = T1.atom_id` instead of joining the atom table twice with different aliases. Do move the element filter to the WHERE clause with `(T1.element = 'c1' OR T1.element = 'c')` instead of checking for element combinations in a CASE expression with COUNT DISTINCT. Do remove the second atom join and the complex CASE logic instead of keeping the multi-join aggregation approach. The amended query now correctly filters for specific elements and returns individual records rather than attempting to aggregate and validate element combinations across multiple joins."
        ],
        "rules": [
            "1) When the question asks about bond id TR001_1_8: filter rows where T2.bond_id equals 'TR001_1_8' exactly. 2) When combining atom and connected tables: link rows where T2.atom_id equals T1.atom_id exactly (inner match). 3) When checking for elements chlorine and carbon: filter rows where T1.element equals 'c1' or T1.element equals 'c' exactly. 4) When selecting output columns: include T2.bond_id, T2.atom_id2, and T1.element AS flag_have_CaCl. 5) Output columns (ordered): T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN COUNT(DISTINCT a1.element) = 2 AND 'cl' IN (a1.element, a2.element) AND 'c' IN (a1.element, a2.element) THEN 'Yes'\n        ELSE 'No'\n    END AS has_both_elements\nFROM \n    connected c\nJOIN \n    atom a1 ON c.atom_id = a1.atom_id\nJOIN \n    atom a2 ON c.atom_id2 = a2.atom_id\nWHERE \n    c.bond_id = 'TR001_1_8';",
            "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id\nWHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')"
        ],
        "rule_sql": [
            "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id = 'TR001_1_8'\nAND (T1.element = 'c1' OR T1.element = 'c')"
        ]
    },
    "1380": {
        "question": "What is the total amount of money spent for food?",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(spent) FROM budget WHERE category = 'Food'",
        "amends": [],
        "rules": [
            "total amount of money spent refers to SUM(spent); spent for food refers to category = 'Food'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(spent) AS total_spent_food FROM budget WHERE category = 'Food';"
        ],
        "rule_sql": []
    },
    "967": {
        "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
        "amends": [],
        "rules": [
            "youngest driver refers to Max (year(dob)); Netherlandic and Dutch refer to the same country"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH youngest_drivers AS (\n    SELECT code, nationality\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 3\n)\nSELECT \n    COUNT(*) AS netherlandic_drivers_count\nFROM youngest_drivers\nWHERE nationality IN ('Dutch', 'Netherlandic');"
        ],
        "rule_sql": []
    },
    "1135": {
        "question": "Please provide top five football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential DESC LIMIT 5",
        "amends": [
            "Do select `id` instead of `player_api_id` as the column to return from the query. Do order by `potential DESC` instead of `potential ASC` to sort in descending order rather than ascending order. The amended query now correctly returns the id column with the highest potential values for right-footed players, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"top five football players' IDs\": return exactly 5 rows after ranking by the specified criteria. 2) When the question mentions \"lowest potential players\": rank players by their potential in ascending order (lowest values first). 3) When the question specifies players who \"prefer to use the right foot\": include only rows where preferred_foot equals exactly 'right'. 4) When selecting player identifiers: use the exact column name \"id\" from the Match table rather than \"player_api_id\". 5) Output columns (ordered): id"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_api_id\nFROM Player_Attributes\nWHERE preferred_foot = 'right'\nORDER BY potential ASC\nLIMIT 5;",
            "SELECT id \nFROM Player_Attributes \nWHERE preferred_foot = 'right' \nORDER BY potential DESC \nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT DISTINCT p.id\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.preferred_foot = 'right'\nORDER BY pa.potential ASC\nLIMIT 5"
        ]
    },
    "715": {
        "question": "In comments with score between 1 to 5, list down the display names of the users with 0 down votes.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.DisplayName FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score BETWEEN 1 AND 5 AND T2.DownVotes = 0",
        "amends": [],
        "rules": [
            "DownVotes = 0; Score BETWEEN 1 and 5"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT u.DisplayName\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE c.Score BETWEEN 1 AND 5\nAND u.DownVotes = 0;"
        ],
        "rule_sql": []
    },
    "1068": {
        "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
        "amends": [
            "Do use explicit division with `CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id)` instead of `AVG(pa.overall_rating)` to ensure proper floating-point calculation. Do reference tables as `t1` and `t2` instead of `p` and `pa` for consistent aliasing. Do use explicit `INNER JOIN` instead of just `JOIN` for clarity. Do split the date range into separate conditions `STRFTIME('%Y',t2.date) >= '2010' AND STRFTIME('%Y',t2.date) <= '2015'` instead of `BETWEEN '2010' AND '2015'` to ensure inclusive boundary handling. Do reference `t2.id` in the count instead of relying on implicit averaging behavior. The amended query now correctly calculates the average rating with proper floating-point precision and inclusive date filtering."
        ],
        "rules": [
            "1) When calculating an average with floating-point precision: use explicit division with CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) instead of AVG(t2.overall_rating). 2) When referencing tables in joins: use aliases t1 for the Player table and t2 for the Player_Attributes table. 3) When performing table joins: use explicit INNER JOIN instead of just JOIN for clarity. 4) When filtering by year ranges inclusively: use separate conditions STRFTIME('%Y',t2.date) >= '2010' AND STRFTIME('%Y',t2.date) <= '2015' instead of BETWEEN. 5) When counting entities for averaging: use the canonical key t2.id as the counting identifier. 6) When filtering players by height: use the condition t1.height > 170. 7) When joining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id. Output columns (ordered): average_overall_rating"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(pa.overall_rating) AS average_overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height > 170\nAND strftime('%Y', pa.date) BETWEEN '2010' AND '2015';",
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_rating\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 170\nAND STRFTIME('%Y', t2.date) >= '2010' \nAND STRFTIME('%Y', t2.date) <= '2015'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_overall_rating\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 170\nAND STRFTIME('%Y', t2.date) >= '2010'\nAND STRFTIME('%Y', t2.date) <= '2015'"
        ]
    },
    "5": {
        "question": "How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(DISTINCT T2.School) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' AND T1.AvgScrMath > 400",
        "amends": [],
        "rules": [
            "Exclusively virtual refers to Virtual = 'F'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM satscores \nJOIN schools ON satscores.cds = schools.CDSCode \nWHERE schools.Virtual = 'F' AND satscores.AvgScrMath > 400;"
        ],
        "rule_sql": []
    },
    "445": {
        "question": "What is the language and flavor text of the card that has colorpie watermark? List out the type of this card.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T2.language, T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'colorpie'",
        "amends": [
            "Do use `DISTINCT` to eliminate duplicate rows instead of omitting it. Do select only `language` and `flavorText` columns instead of including `c.type`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do specify the join condition as `T2.uuid = T1.uuid` instead of `c.uuid = fd.uuid`. Do remove the table alias from the `watermark` filter instead of keeping it. The amended query now correctly returns distinct language and flavor text combinations for cards with the specified watermark."
        ],
        "rules": [
            "1) When the question asks for language and flavor text of cards with a specific watermark: select distinct T2.language and T2.flavorText from the foreign_data table (as T2) joined with cards table (as T1). 2) When combining T1 (cards) and T2 (foreign_data) for shared entities: link rows where T2.uuid = T1.uuid exactly and keep only matching pairs (inner match). 3) When filtering for cards with 'colorpie' watermark: apply the condition watermark = 'colorpie' without table aliases. 4) When the question mentions \"language and flavor text\" but not type: exclude the type column from the output. 5) When the question asks for distinct combinations: use distinct selection to eliminate duplicate rows. Output columns (ordered): T2.language, T2.flavorText"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT fd.language, fd.flavorText, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'colorpie';",
            "SELECT DISTINCT T1.language, T1.flavorText\nFROM foreign_data T1\nINNER JOIN cards T2 ON T2.uuid = T1.uuid\nWHERE T2.watermark = 'colorpie'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.language, T2.flavorText\nFROM foreign_data T2\nINNER JOIN cards T1 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'colorpie'"
        ]
    },
    "955": {
        "question": "What is the average time in seconds of champion for each year, before year 1975?",
        "db_id": "formula_1",
        "ground_truth": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
        "amends": [
            "Do use a CTE structure with `time_in_seconds` and `champion_time` instead of a single query. Do calculate time conversion for all positions with `CASE WHEN positionOrder = 1` instead of filtering only position 1 in WHERE. Do use `positionOrder = 1` instead of `position = 1` for champion identification. Do extract time components with different substring positions: `SUBSTR(T1.time, 1, 1)` for hours instead of `SUBSTR(res.time, 1, 2)`, `SUBSTR(T1.time, 3, 2)` for minutes instead of `SUBSTR(res.time, 4, 2)`, `SUBSTR(T1.time, 6, 2)` for seconds instead of `SUBSTR(res.time, 7, 2)`, and `SUBSTR(T1.time, 9)` for milliseconds instead of `SUBSTR(res.time, 10, 3)`. Do add `HAVING AVG(time_seconds) IS NOT NULL` instead of omitting it to filter out null averages. Do use table aliases `T1` and `T2` instead of `res` and `r`. The amended query now correctly handles time format parsing and ensures valid average calculations by excluding null results."
        ],
        "rules": [
            "1) When the question asks for average time in seconds of champion for each year before 1975: calculate time conversion for all positions but only consider rows where T1.positionOrder = 1 for champion identification.\n2) When converting time format from T1.time: extract hours using SUBSTR(T1.time, 1, 1), minutes using SUBSTR(T1.time, 3, 2), seconds using SUBSTR(T1.time, 6, 2), and milliseconds using SUBSTR(T1.time, 9).\n3) When combining T1 and T2 tables: link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match).\n4) When filtering by year: include only rows where T2.year < 1975.\n5) When grouping results: organize by T2.year to get averages per year.\n6) When computing averages: ensure to filter out null results by having AVG(time_seconds) IS NOT NULL.\n7) When handling time conversion: use a CTE structure with time_in_seconds and champion_time calculations instead of a single query.\n8) Output columns (ordered): T2.year, AVG(time_seconds) AS average_time_seconds"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.year, AVG(\n    CAST(SUBSTR(res.time, 1, 2) AS INTEGER) * 3600 +\n    CAST(SUBSTR(res.time, 4, 2) AS INTEGER) * 60 +\n    CAST(SUBSTR(res.time, 7, 2) AS INTEGER) +\n    CAST(SUBSTR(res.time, 10, 3) AS REAL) / 1000\n) AS average_time_seconds\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nWHERE res.position = 1 AND res.time IS NOT NULL AND r.year < 1975\nGROUP BY r.year;",
            "WITH time_in_seconds AS (\n    SELECT \n        T2.year,\n        CASE \n            WHEN T1.positionOrder = 1 THEN\n                CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600 + \n                CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60 + \n                CAST(SUBSTR(T1.time, 6, 2) AS REAL) + \n                CAST(SUBSTR(T1.time, 9) AS REAL) / 1000\n            ELSE NULL\n        END AS time_seconds\n    FROM results T1\n    JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T2.year < 1975\n),\nchampion_time AS (\n    SELECT \n        year,\n        AVG(time_seconds) AS avg_champion_time_seconds\n    FROM time_in_seconds\n    GROUP BY year\n    HAVING AVG(time_seconds) IS NOT NULL\n)\nSELECT \n    year,\n    avg_champion_time_seconds\nFROM champion_time\nORDER BY year;"
        ],
        "rule_sql": [
            "WITH champion_times AS (\n    SELECT \n        r.year,\n        (CAST(SUBSTR(res.time, 1, 1) AS REAL) * 3600 + \n         CAST(SUBSTR(res.time, 3, 2) AS REAL) * 60 + \n         CAST(SUBSTR(res.time, 6, 2) AS REAL) + \n         CAST(SUBSTR(res.time, 9) AS REAL) / 1000) AS time_seconds\n    FROM results res\n    JOIN races r ON res.raceId = r.raceId\n    WHERE res.positionOrder = 1\n    AND r.year < 1975\n    AND res.time IS NOT NULL\n)\nSELECT \n    year,\n    AVG(time_seconds) AS average_time_seconds\nFROM champion_times\nGROUP BY year\nHAVING AVG(time_seconds) IS NOT NULL\nORDER BY year;"
        ]
    },
    "1527": {
        "question": "Which gas station has the highest amount of revenue?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT GasStationID FROM transactions_1k GROUP BY GasStationID ORDER BY SUM(Price) DESC LIMIT 1",
        "amends": [
            "Do select only `GasStationID` instead of including `Country`, `Segment`, and `TotalRevenue` alias. Do use `FROM transactions_1k` alone instead of joining with `gasstations` table. Do aggregate with `SUM(Price)` instead of `SUM(t.Amount * t.Price)`. Do group by only `GasStationID` instead of grouping by multiple columns. Do order by `SUM(Price)` directly instead of ordering by an alias. The amended query now correctly identifies the gas station with highest total price revenue from transactions alone."
        ],
        "rules": [
            "1) When the question asks for the gas station with the highest revenue: compute the sum of Price from transactions_1k for each GasStationID. 2) When grouping by gas stations: organize results by GasStationID only, without including additional columns like Country or Segment. 3) When ranking for highest value: order the results by the sum of Price in descending order. 4) When selecting the top result: take only the first row after ordering. 5) When outputting the result: include only the GasStationID column. 6) Output columns (ordered): GasStationID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT g.GasStationID, g.Country, g.Segment, SUM(t.Amount * t.Price) AS TotalRevenue\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nGROUP BY g.GasStationID, g.Country, g.Segment\nORDER BY TotalRevenue DESC\nLIMIT 1;",
            "SELECT GasStationID FROM transactions_1k GROUP BY GasStationID ORDER BY SUM(Price) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT GasStationID\nFROM transactions_1k\nGROUP BY GasStationID\nORDER BY SUM(Price) DESC\nLIMIT 1;"
        ]
    },
    "756": {
        "question": "How many bad superheroes are there?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Bad'",
        "amends": [],
        "rules": [
            "bad superheroes refers to alignment_id = Bad"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS bad_superheroes_count\nFROM superhero\nWHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'Bad');"
        ],
        "rule_sql": []
    },
    "638": {
        "question": "List all the name of users that obtained the Organizer Badges.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Organizer'",
        "amends": [],
        "rules": [
            "name of users refers to DisplayName; the Organizer Badges refer to badges where Name = 'Organizer';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Organizer';"
        ],
        "rule_sql": []
    },
    "1188": {
        "question": "How many female patients born in 1964 were admitted to the hospital? List them by ID.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT ID FROM Patient WHERE STRFTIME('%Y', Birthday) = '1964' AND SEX = 'F' AND Admission = '+'",
        "amends": [],
        "rules": [
            "female refers to SEX = 'F'; born in 1964 refers to YEAR(Birthday) = 1964; admitted to the hospital refers to Admission = '+'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ID FROM Patient WHERE SEX = 'F' AND strftime('%Y', Birthday) = '1964' AND Admission = '+';"
        ],
        "rule_sql": []
    },
    "198": {
        "question": "On average how many carcinogenic molecules are single bonded?",
        "db_id": "toxicology",
        "ground_truth": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
        "amends": [
            "Do join `bond` with `atom` on `molecule_id` instead of joining `molecule` directly with `bond`. Do add `INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id` instead of omitting the atom table entirely. Do change the join path to `INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id` instead of `JOIN bond b ON m.molecule_id = b.molecule_id`. Do keep the same `WHERE` filters `T1.bond_type = '-' AND T3.label = '+'` instead of changing the filter logic. Do maintain the same `GROUP BY T3.molecule_id` and `COUNT(T1.bond_type)` aggregation instead of altering the grouping or counting. The amended query now correctly incorporates the atom table in the join path to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for carcinogenic molecules: filter molecules where T3.label equals '+' exactly. 2) When counting single bonds: filter bonds where T1.bond_type equals '-' exactly. 3) When joining bond and atom tables: link rows where T1.molecule_id equals T2.molecule_id exactly. 4) When joining with molecule table: link rows where T3.molecule_id equals T2.molecule_id exactly. 5) When grouping for molecule-level counts: organize results by T3.molecule_id. 6) When counting bonds per molecule: compute the number of T1.bond_type values for each group. 7) When computing the average across molecules: calculate the mean of the single bond counts. Output columns (ordered): average_single_bonded"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(single_bond_count) AS average_single_bonded\nFROM (\n    SELECT m.molecule_id, COUNT(b.bond_id) AS single_bond_count\n    FROM molecule m\n    JOIN bond b ON m.molecule_id = b.molecule_id\n    WHERE m.label = '+' AND b.bond_type = '-'\n    GROUP BY m.molecule_id\n);",
            "SELECT AVG(bond_count) AS avg_carcinogenic_single_bonded_molecules\nFROM (\n    SELECT T3.molecule_id, COUNT(T1.bond_type) AS bond_count\n    FROM bond AS T1\n    INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id\n    WHERE T1.bond_type = '-' AND T3.label = '+'\n    GROUP BY T3.molecule_id\n)"
        ],
        "rule_sql": [
            "SELECT AVG(single_bond_count) AS average_single_bonded\nFROM (\n    SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count\n    FROM bond T1\n    JOIN atom T2 ON T1.molecule_id = T2.molecule_id\n    JOIN molecule T3 ON T3.molecule_id = T2.molecule_id\n    WHERE T3.label = '+' AND T1.bond_type = '-'\n    GROUP BY T3.molecule_id\n)"
        ]
    },
    "666": {
        "question": "Among the posts that were voted by user 1465, what is the id of the most valuable post?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Id FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 1465 ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "user 1465 refers to UserId = 1465; the most valuable post refers to MAX(FavoriteCount);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Id \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE v.UserId = 1465 \nORDER BY p.Score DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1084": {
        "question": "Among the players born before the year 1986, how many of them would remain in his position and defense while the team attacked?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(DISTINCT t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.birthday) < '1986' AND t2.defensive_work_rate = 'high'",
        "amends": [],
        "rules": [
            "players born before the year 1986 refers to strftime('%Y', birthday)<'1986'; players who would remain in his position and defense while the team attacked refers to defensive_work_rate = 'high'; Should consider DISTINCT in the final result;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.player_api_id) \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE strftime('%Y', p.birthday) < '1986' \nAND pa.defensive_work_rate = 'high';"
        ],
        "rule_sql": []
    },
    "2": {
        "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it. Do change the column reference from `s.Zip` to `T2.Zip` instead of using the original alias. Do change the table alias from `f` to `T1` and from `s` to `T2` instead of the original aliases. Do change the join from `JOIN` to `INNER JOIN` instead of the implicit join type. Do change the WHERE condition from `f.\"County Name\" = 'Fresno County Office of Education'` to `T1.\"District Name\" = 'Fresno County Office of Education'` instead of using the wrong column name. Do keep the condition `T1.\"Charter School (Y/N)\" = 1` instead of changing it. The amended query now correctly filters by district name instead of county name and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for charter schools: filter rows where T1.\"Charter School (Y/N)\" = 1. 2) When the question specifies \"Fresno County Office of Education\": filter rows where T1.\"District Name\" = 'Fresno County Office of Education'. 3) When combining T1 and T2 for shared entities: link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match). 4) When listing zip codes: output the exact column T2.Zip. 5) When the question does not specify distinct values: do not remove duplicate zip codes. Output columns (ordered): T2.Zip"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT s.Zip\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.\"Charter School (Y/N)\" = 1 AND f.\"County Name\" = 'Fresno County Office of Education';",
            "SELECT T2.Zip\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"District Name\" = 'Fresno County Office of Education'\nAND T1.\"Charter School (Y/N)\" = 1"
        ],
        "rule_sql": [
            "SELECT T2.Zip\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Charter School (Y/N)\" = 1\nAND T1.\"District Name\" = 'Fresno County Office of Education'"
        ]
    },
    "1169": {
        "question": "What is the ratio of male to female patients among all those with abnormal uric acid counts?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for male and female counts. Do calculate counts using `SUM(CASE WHEN ... THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT L.ID)` with separate joins. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of separate joins in CTEs. Do apply the UA threshold conditions directly in the CASE statements (`T2.UA <= 8.0 AND T1.SEX = 'M'` and `T2.UA <= 6.5 AND T1.SEX = 'F'`) instead of filtering in WHERE clauses. Do compute the ratio directly as `CAST(... AS REAL) / SUM(...)` instead of using a CASE statement to handle division by zero, as the original approach would return NULL while the corrected query handles this through division semantics. Do remove the separate male and female count columns and ratio calculation logic, instead performing the division directly in the SELECT clause. The amended query now correctly calculates the male-to-female ratio of abnormal UA values with the appropriate gender-specific thresholds in a single efficient operation.",
            "Do use `<=` comparison operators instead of `>` in both conditional aggregates, changing `T2.UA > 8.0` to `T2.UA <= 8.0` for males and `T2.UA > 6.5` to `T2.UA <= 6.5` for females. Do remove the `NULLIF` function wrapper and denominator protection instead of keeping it, allowing division by zero to return NULL naturally. Do remove the entire WHERE clause filter instead of including it, as the conditional aggregates should operate on the full joined dataset without pre-filtering. Do eliminate the column alias `male_to_female_ratio` instead of specifying it, making the result anonymous. The amended query now correctly calculates the ratio of male to female patients meeting the specified UA threshold criteria without premature filtering."
        ],
        "rules": [
            "1) When calculating the ratio of male to female patients with abnormal uric acid counts: use conditional aggregation with SUM(CASE WHEN ... THEN 1 ELSE 0 END) instead of separate CTEs and COUNT(DISTINCT). 2) When combining Patient and Laboratory tables: use INNER JOIN on T1.ID = T2.ID where T1 represents Patient and T2 represents Laboratory. 3) When identifying male patients with abnormal uric acid: apply the condition T2.UA <= 8.0 AND T1.SEX = 'M' within the aggregation. 4) When identifying female patients with abnormal uric acid: apply the condition T2.UA <= 6.5 AND T1.SEX = 'F' within the aggregation. 5) When computing the ratio: calculate it directly as CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END). 6) When handling division by zero: rely on division semantics rather than explicit CASE statements to handle zero denominators. Output columns (ordered): the computed male-to-female ratio value.",
            "1) When calculating ratios for male to female patients with abnormal uric acid counts: use T1.SEX = 'M' for male patients and T1.SEX = 'F' for female patients with exact case matching.\n2) When determining abnormal uric acid levels: use T2.UA <= 8.0 for male patients and T2.UA <= 6.5 for female patients with exact threshold values.\n3) When computing conditional aggregates: operate on the full joined dataset without pre-filtering using WHERE clauses.\n4) When handling division operations: allow division by zero to return NULL naturally without NULLIF protection.\n5) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using exact key equality and keep only matching pairs (inner match).\n6) When producing output: return the result without column aliases, making it anonymous.\nOutput columns (ordered): (ratio result)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH male_abnormal AS (\n    SELECT COUNT(DISTINCT L.ID) AS male_count\n    FROM Laboratory L\n    JOIN Patient P ON L.ID = P.ID\n    WHERE P.SEX = 'M' AND L.UA <= 8.0\n),\nfemale_abnormal AS (\n    SELECT COUNT(DISTINCT L.ID) AS female_count\n    FROM Laboratory L\n    JOIN Patient P ON L.ID = P.ID\n    WHERE P.SEX = 'F' AND L.UA <= 6.5\n)\nSELECT \n    male_count AS male_patients,\n    female_count AS female_patients,\n    CASE \n        WHEN female_count = 0 THEN NULL\n        ELSE ROUND(CAST(male_count AS REAL) / female_count, 2)\n    END AS male_to_female_ratio\nFROM male_abnormal, female_abnormal;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.UA > 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN T2.UA > 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END), 0) AS male_to_female_ratio\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    (T2.UA > 8.0 AND T1.SEX = 'M') OR (T2.UA > 6.5 AND T1.SEX = 'F');",
            "SELECT \n    CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / \n    SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END)\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID;"
        ]
    },
    "411": {
        "question": "To which artist does the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\" belong?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
        "amends": [
            "Do add `DISTINCT` modifier instead of omitting it to eliminate duplicate artist results. Do change the source table to `cards AS T1` instead of just `cards` and add an `INNER JOIN` with `foreign_data AS T2` on `T1.uuid = T2.uuid` instead of querying a single table. Do change the filter to use `T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'` instead of `text = 'Das perfekte Gegenmittel zu einer dichten Formation'` to perform a case-insensitive pattern match with wildcards rather than an exact string comparison. The amended query now correctly joins the cards and foreign_data tables to access the flavorText field and uses appropriate pattern matching to find the target text."
        ],
        "rules": [
            "1) When the question asks for an artist from a card with specific text: join tables cards AS T1 and foreign_data AS T2 using the exact key equality T1.uuid = T2.uuid to access flavor text information.\n2) When searching for text patterns in flavorText: use case-insensitive pattern matching with wildcards (LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%') instead of exact string comparison.\n3) When returning artist information: use DISTINCT modifier to eliminate duplicate artist results.\n4) When handling identifier delimiters: use exact table aliases T1 and T2 as specified in the join operation.\n5) When combining tables for shared entities: perform inner match using T1.uuid = T2.uuid to keep only matching pairs between cards and foreign_data tables.\nOutput columns (ordered): T1.artist"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist FROM cards WHERE text = 'Das perfekte Gegenmittel zu einer dichten Formation';",
            "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%Das perfekte Gegenmittel zu einer dichten Formation%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.artist FROM cards AS T1 JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%Das perfekte Gegenmittel zu einer dichten Formation%'"
        ]
    }
}