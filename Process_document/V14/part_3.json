{
    "894": {
        "sql": [
            "SELECT d.forename, d.surname, r.name AS race_name, lt.milliseconds AS best_lap_time\nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nJOIN races r ON lt.raceId = r.raceId\nWHERE lt.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes);",
            "SELECT T2.milliseconds, T3.name, d.forename || ' ' || d.surname AS driver_name\nFROM lapTimes T2\nINNER JOIN drivers d ON T2.driverId = d.driverId\nINNER JOIN races T3 ON T2.raceId = T3.raceId\nORDER BY T2.milliseconds ASC\nLIMIT 1;",
            "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T2.raceId = T3.raceId\nORDER BY T2.milliseconds ASC\nLIMIT 1;"
        ],
        "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY T2.milliseconds ASC LIMIT 1",
        "amends": [
            "Do select `T2.milliseconds` as the first column instead of placing it last, and do use `T3.name` without an alias instead of `r.name AS race_name`. Do use `INNER JOIN` consistently instead of just `JOIN`, and do fix the join condition between `drivers` and `lapTimes` to use `T1.driverId = T2.driverId` instead of `lt.driverId = d.driverId`. Do remove the subquery filter that finds the absolute minimum lap time across all races instead of keeping it, and do add `ORDER BY T2.milliseconds ASC LIMIT 1` to get the single fastest lap record instead of potentially returning multiple records with the same minimum time. The amended query now correctly returns only the single fastest lap time with associated driver and race information, matching the RIGHT_SQL's behavior.",
            "Do reference the drivers table as `T1` instead of `d` and select individual columns `T1.forename` and `T1.surname` instead of concatenating them as `driver_name`. Do use `drivers AS T1` in the FROM clause instead of aliasing as `d` and maintain the same join conditions with `T1.driverId = T2.driverId` instead of `T2.driverId = d.driverId`. The ORDER BY and LIMIT clauses remain unchanged with `T2.milliseconds ASC` and `LIMIT 1`. The amended query now correctly selects individual driver name components and uses consistent table aliasing while preserving the core logic of finding the fastest lap time."
        ],
        "rules": [
            "the best lap time refers to min(milliseconds); List the driver refers to drivers.forename and drivers.surname; List the race refers to races.name"
        ]
    },
    "1024": {
        "sql": [
            "SELECT p.player_api_id, p.player_name, pa.crossing\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY pa.crossing DESC\nLIMIT 5;",
            "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5"
        ],
        "question": "Who are the top 5 players who perform better in crossing actions? Indicate their player id.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5",
        "amends": [
            "Do select only `id` instead of `p.player_api_id, p.player_name, pa.crossing` from the `Player_Attributes` table. Do remove the `JOIN` with `Player` table on `p.player_api_id = pa.player_api_id` instead of including it. Do keep `ORDER BY crossing DESC` and `LIMIT 5` as they remain unchanged. The amended query now correctly retrieves only the IDs from Player_Attributes ordered by crossing, matching the intended behavior."
        ],
        "rules": [
            "perform better in crossing actions refers to MAX(crossing)"
        ]
    },
    "712": {
        "sql": [
            "SELECT p.Id AS PostId, c.Text AS CommentText\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE p.Title = 'Group differences on a five point Likert item';"
        ],
        "question": "What is the post ID and the comments commented in the post titled by \"Group differences on a five point Likert item\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Id, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'Group differences on a five point Likert item'",
        "amends": [],
        "rules": [
            "Title = 'Group differences on a five point Likert item';"
        ]
    },
    "1256": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.CRP = '+' AND P.Description IS NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.CRP = '+' AND T1.Description IS NULL"
        ],
        "question": "How many patients with a abnormal C-reactive protein don't have their data recorded?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP = '+' ) AND T1.Description IS NULL",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do maintain the same join condition `ON T1.ID = T2.ID` instead of changing it. Do keep the filter `T2.CRP = '+'` unchanged. Do preserve the `T1.Description IS NULL` condition without modification. The amended query now correctly counts all patient records matching the criteria rather than distinct patient IDs, ensuring the result matches the intended behavior."
        ],
        "rules": [
            "abnormal C-reactive protein refers to CRP ='+'; don't have data recorded refers to Description IS NULL;"
        ]
    },
    "207": {
        "sql": [
            "SELECT DISTINCT a.element\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '=';",
            "SELECT DISTINCT a.element \nFROM atom a\nINNER JOIN bond b ON a.molecule_id = b.molecule_id\nWHERE b.bond_type = '='",
            "SELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id\nWHERE T2.bond_type = '='"
        ],
        "question": "What elements are in a double type bond?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
        "amends": [
            "Do use `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of joining through `connected` table with `a.atom_id = c.atom_id OR a.atom_id = c.atom_id2`. Do add `T1.molecule_id = T2.molecule_id` join condition instead of omitting it. Do remove the `JOIN bond b ON c.bond_id = b.bond_id` connection through `connected` table instead of keeping the indirect path. Do change the join structure to directly connect `atom` and `bond` tables via `molecule_id` instead of using the `connected` table as an intermediary. Do keep the `WHERE T2.bond_type = '='` filter instead of changing it. Do maintain `DISTINCT` selection of `element` instead of altering it. The amended query now correctly establishes the relationship between atoms and bonds through their shared molecule context rather than the incorrect atom-level connection through the connected table, matching the RIGHT_SQL's behavior.",
            "Do add `INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id` instead of omitting the connected table join entirely. Do change the table alias from `a` to `T1` and `b` to `T2` instead of using the original aliases. Do add `T3` table reference instead of keeping only two tables. The amended query now correctly includes the necessary join to the connected table to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "double type bond refers to bond_type = '=';"
        ]
    },
    "269": {
        "sql": [
            "SELECT COUNT(DISTINCT c.bond_id) \nFROM connected c \nJOIN atom a ON c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id \nWHERE a.element = 'i';",
            "SELECT COUNT(T3.bond_id) \nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T1.element = 'i'"
        ],
        "question": "How many bond id have element iodine?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.bond_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T1.element = 'i'",
        "amends": [
            "Do use `COUNT(T3.bond_id)` without `DISTINCT` instead of `COUNT(DISTINCT c.bond_id)` to count all bonds rather than unique ones. Do join `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of omitting the molecule table entirely. Do use `INNER JOIN bond AS T3` on `T2.molecule_id = T3.molecule_id` instead of joining `connected c` with complex `OR` conditions `c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id`. Do filter on `T1.element = 'i'` instead of `a.element = 'i'` while maintaining the same element condition. The amended query now correctly counts bonds in molecules containing iodine atoms by properly traversing the molecule hierarchy rather than using a potentially incorrect connection-based approach."
        ],
        "rules": [
            "iodine refers to element = 'i'"
        ]
    },
    "298": {
        "sql": [
            "SELECT (COUNT(DISTINCT CASE WHEN m.label = '+' AND a.element = 'h' THEN m.molecule_id END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM molecule m\nLEFT JOIN atom a ON m.molecule_id = a.molecule_id;",
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100.0) / \n    COUNT(DISTINCT T2.molecule_id) AS percentage\nFROM \n    atom T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id;",
            "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(*) \nFROM atom T1 \nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id"
        ],
        "question": "Calculate the percentage of molecules containing carcinogenic compounds that element is hydrogen.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "amends": [
            "Do use `INNER JOIN` between `atom` and `molecule` instead of `LEFT JOIN` to ensure only molecules with atoms are considered. Do calculate the percentage using `CAST` to `REAL` instead of implicit floating-point conversion with `100.0`. Do count `CASE` expressions directly instead of using `COUNT(DISTINCT)` to avoid unnecessary deduplication. Do reference tables with aliases `T1` for `atom` and `T2` for `molecule` instead of single-letter aliases. Do place the condition `element = 'h'` before `label = '+'` in the `CASE` expression instead of the reverse order. Do use `ELSE NULL` explicitly in the `CASE` expression instead of relying on implicit NULL behavior. Do remove the multiplication by `100.0` from inside the numerator calculation and instead place it in the division operation. The amended query now correctly calculates the percentage of hydrogen atoms with positive labels among all molecules that have atoms.",
            "Do remove `DISTINCT` from both the numerator and denominator counts instead of keeping them, as the molecule_id values are already unique within their respective contexts. Do use integer division with `/` instead of floating-point division with `* 100.0 /` to maintain proper arithmetic behavior. Do omit the column alias `percentage` instead of including it, as the right query returns an unnamed scalar result. Do use the same join condition `T1.molecule_id = T2.molecule_id` instead of changing it, maintaining the correct relationship between atom and molecule tables. The amended query now correctly calculates the percentage without unnecessary distinct operations and matches the right SQL's behavior."
        ],
        "rules": [
            "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+' and element = 'h'), COUNT(molecule_id)) * 100.0"
        ]
    },
    "895": {
        "sql": [
            "SELECT AVG(l.milliseconds) AS average_lap_time\nFROM lapTimes l\nJOIN races r ON l.raceId = r.raceId\nJOIN drivers d ON l.driverId = d.driverId\nWHERE r.year = 2009 AND r.name = 'Malaysian Grand Prix' AND d.forename = 'Lewis' AND d.surname = 'Hamilton';"
        ],
        "question": "What is the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.milliseconds) FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.year = 2009 AND T1.name = 'Malaysian Grand Prix'",
        "amends": [],
        "rules": [
            "average lap time = AVG(milliseconds); 'Lewis Hamilton' refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; 'Malaysian Grand Prix' refers to races.name = 'Malaysian Grand Prix'"
        ]
    },
    "54": {
        "sql": [
            "SELECT School, MailZip FROM schools WHERE (AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian') OR (AdmFName2 = 'Avetik' AND AdmLName2 = 'Atoian') OR (AdmFName3 = 'Avetik' AND AdmLName3 = 'Atoian');",
            "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian';"
        ],
        "question": "Please specify all of the schools and their related mailing zip codes that are under Avetik Atoian's administration.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian'",
        "amends": [
            "Do use `AND` logical operator instead of `OR` between the name condition pairs. Do remove the additional `OR` conditions for `AdmFName2`/`AdmLName2` and `AdmFName3`/`AdmLName3` instead of including them. Do simplify the `WHERE` clause to only check the first administrator fields instead of checking all three administrator positions. The amended query now correctly filters for records where both the first name and last name match in the primary administrator fields, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "1338": {
        "sql": [
            "SELECT e.expense_id, e.expense_description, e.approved\nFROM event ev\nJOIN budget b ON ev.event_id = b.link_to_event\nJOIN expense e ON b.budget_id = e.link_to_budget\nWHERE ev.event_name = 'October Meeting' AND ev.event_date = '2019-10-08';",
            "SELECT T3.approved\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'"
        ],
        "question": "Was each expense in October Meeting on October 8, 2019 approved?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
        "amends": [
            "Do select only `T3.approved` instead of `e.expense_id, e.expense_description, e.approved`. Do use `INNER JOIN` consistently instead of mixing `JOIN` without explicit type. Do use table aliases `T1`, `T2`, `T3` instead of full table names `ev`, `b`, `e`. Do use `LIKE '2019-10-08%'` for date matching instead of exact equality `= '2019-10-08'` to accommodate potential timestamp values. The amended query now correctly returns only the approved status with proper date filtering that handles potential time components."
        ],
        "rules": [
            "event_name = 'October Meeting' where event_date = '2019-10-08'; approved = True means expenses was approved; approved = False means expenses was not approved"
        ]
    },
    "1447": {
        "sql": [
            "SELECT e.event_name, e.location FROM event e JOIN budget b ON e.event_id = b.link_to_event WHERE b.spent < b.amount;"
        ],
        "question": "List the name and location of events that underspend its budget.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.event_name, T1.location FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 0",
        "amends": [],
        "rules": [
            "name of event refers to event_name; underspend its budget refers to remaining > 0"
        ]
    },
    "404": {
        "sql": [
            "SELECT DISTINCT st.language\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.totalSetSize = 309;"
        ],
        "question": "Indicates the name of all the languages into which the set whose number of cards is 309 is translated.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.baseSetSize = 309",
        "amends": [],
        "rules": [
            "set refer to setCode; number of cards refers to baseSetSize; baseSetsize = 309\n\n"
        ]
    },
    "687": {
        "sql": [
            "WITH highest_score_post AS (\n    SELECT Id\n    FROM posts\n    WHERE Score = (SELECT MAX(Score) FROM posts)\n)\nSELECT COUNT(*) AS comment_count\nFROM comments\nWHERE PostId = (SELECT Id FROM highest_score_post);",
            "SELECT COUNT(T2.Id) AS comment_count\nFROM posts T1\nINNER JOIN comments T2 ON T1.Id = T2.PostId\nGROUP BY T1.Id\nORDER BY SUM(T1.Score) DESC\nLIMIT 1"
        ],
        "question": "How many comments were added to the post with the highest score?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId GROUP BY T1.Id ORDER BY SUM(T1.Score) DESC LIMIT 1",
        "amends": [
            "Do use an `INNER JOIN` between `posts` and `comments` on `T1.Id = T2.PostId` instead of a subquery approach with `WHERE PostId = (SELECT...)`. Do add `GROUP BY T1.Id` to group comments by each post instead of counting all comments without grouping. Do add `ORDER BY SUM(T1.Score) DESC` to order by the sum of post scores instead of finding only the single highest score post. Do add `LIMIT 1` to return only the top result instead of counting comments for all posts. Do remove the CTE `highest_score_post` and its subquery structure instead of maintaining that complex nested approach. Do count `T2.Id` specifically instead of using `COUNT(*)` for more precise counting of comment records. The amended query now correctly identifies the post with the highest total engagement (sum of scores) and counts its comments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "the highest score refers to MAX(Score);"
        ]
    },
    "880": {
        "sql": [
            "WITH paul_driver AS (\n    SELECT driverId FROM drivers WHERE forename = 'Paul' AND surname = 'di Resta'\n),\nspeed_853 AS (\n    SELECT fastestLapSpeed FROM results \n    WHERE raceId = 853 AND driverId = (SELECT driverId FROM paul_driver)\n),\nspeed_854 AS (\n    SELECT fastestLapSpeed FROM results \n    WHERE raceId = 854 AND driverId = (SELECT driverId FROM paul_driver)\n)\nSELECT \n    CASE \n        WHEN (SELECT fastestLapSpeed FROM speed_853) IS NOT NULL AND (SELECT fastestLapSpeed FROM speed_854) IS NOT NULL THEN\n            ((CAST((SELECT fastestLapSpeed FROM speed_853) AS REAL) - CAST((SELECT fastestLapSpeed FROM speed_854) AS REAL)) / \n            CAST((SELECT fastestLapSpeed FROM speed_853) AS REAL)) * 100\n        ELSE NULL\n    END AS percentage_faster;"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
        "amends": [],
        "rules": [
            "Paul di Resta refers to the full name of the driver; Full name of the driver refers to drivers.forename ='Paul' and drivers.surname = 'di Resta'; race number refers to raceId; percentage = DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), (fastestLapSpeed (raceId = 854)) * 100 , (fastestLapSpeed(raceId = 853))"
        ]
    },
    "308": {
        "sql": [
            "SELECT COUNT(DISTINCT c.bond_id) AS bond_count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE a1.element = 'cl' OR a2.element = 'cl';"
        ],
        "question": "How many bonds are created by bonding atoms with chlorine element?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.bond_id) FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T2.element = 'cl'",
        "amends": [],
        "rules": [
            "chlorine refers to element = 'cl'"
        ]
    },
    "1120": {
        "sql": [
            "WITH player_ids AS (\n    SELECT player_api_id\n    FROM Player\n    WHERE player_name IN ('Daan Smith', 'Filipe Ferreira')\n),\naway_matches AS (\n    SELECT m.away_team_goal\n    FROM Match m\n    JOIN player_ids p ON \n        m.away_player_1 = p.player_api_id OR\n        m.away_player_2 = p.player_api_id OR\n        m.away_player_3 = p.player_api_id OR\n        m.away_player_4 = p.player_api_id OR\n        m.away_player_5 = p.player_api_id OR\n        m.away_player_6 = p.player_api_id OR\n        m.away_player_7 = p.player_api_id OR\n        m.away_player_8 = p.player_api_id OR\n        m.away_player_9 = p.player_api_id OR\n        m.away_player_10 = p.player_api_id OR\n        m.away_player_11 = p.player_api_id\n)\nSELECT SUM(away_team_goal) AS total_away_goals\nFROM away_matches;",
            "SELECT SUM(m.away_team_goal) AS total_away_goals\nFROM Match m\nINNER JOIN Player p ON p.player_api_id = m.away_player_5\nWHERE p.player_name IN ('Daan Smith', 'Filipe Ferreira')"
        ],
        "question": "Sum up the away team goal scored by both Daan Smith and Filipe Ferreira.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.away_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_5 WHERE t1.player_name IN ('Daan Smith', 'Filipe Ferreira')",
        "amends": [
            "Do use a direct `INNER JOIN` between `Player` and `match` tables instead of a CTE with multiple OR conditions. Do join specifically on `t1.player_api_id = t2.away_player_5` instead of checking all 11 away player positions with OR conditions. Do filter the player names directly in the `WHERE` clause instead of using a separate CTE. Do remove the unnecessary CTE structure and multiple player position checks instead of keeping the complex OR logic. Do reference the joined table directly with `t2.away_team_goal` instead of using a CTE intermediate result. The amended query now correctly matches the intended behavior by focusing only on the specific away_player_5 position for the given players."
        ],
        "rules": [
            "Daan Smith refers to player_name = 'Daan Smith'; Filipe Ferreira refers to player_name = 'Filipe Ferreira'"
        ]
    },
    "5": {
        "sql": [
            "SELECT COUNT(*) \nFROM satscores \nJOIN schools ON satscores.cds = schools.CDSCode \nWHERE schools.Virtual = 'F' AND satscores.AvgScrMath > 400;"
        ],
        "question": "How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.School) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' AND T1.AvgScrMath > 400",
        "amends": [],
        "rules": [
            "Exclusively virtual refers to Virtual = 'F'"
        ]
    },
    "533": {
        "sql": [
            "SELECT COUNT(*) AS user_count FROM users WHERE LastAccessDate > '2014-09-01';",
            "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'"
        ],
        "question": "How many users last accessed the website after 2014/9/1?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
        "amends": [
            "Do use `COUNT(Id)` instead of `COUNT(*)` to count only non-null user IDs. Do apply `date()` function to `LastAccessDate` instead of comparing the raw datetime value directly, ensuring proper date comparison semantics. Do remove the `AS user_count` alias instead of keeping it, as the right query does not include an alias. End with confirmation that the amended query now correctly counts users with LastAccessDate after September 1, 2014, matching the right SQL's behavior."
        ],
        "rules": [
            "last accessed after 2014/9/1 refers to LastAccessDate > '2014-09-01'"
        ]
    },
    "64": {
        "sql": [
            "SELECT COUNT(*) FROM schools WHERE MailCity = 'Hickman' AND CharterNum = '00D4';"
        ],
        "question": "What is the total number of schools with a mailing city in Hickman belonging to the charter number 00D4?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM schools WHERE CharterNum = '00D4' AND MailCity = 'Hickman'",
        "amends": [],
        "rules": []
    },
    "862": {
        "sql": [
            "SELECT COUNT(*) AS drivers_not_finished\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE name = 'Bahrain Grand Prix' AND year = 2007)\nAND time IS NULL;"
        ],
        "question": "For the Bahrain Grand Prix in 2007, how many drivers not finished the game?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2007 AND T1.name = 'Bahrain Grand Prix' AND T2.time IS NULL",
        "amends": [],
        "rules": [
            "Bahrain Grand Prix refers to races.name = 'Bahrain Grand Prix'; drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL);"
        ]
    },
    "113": {
        "sql": [
            "SELECT c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.amount = 98832 AND l.date = '1996-01-03';"
        ],
        "question": "For the client who applied 98832 USD loan in 1996/1/3, when was his/her birthday?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.birth_date FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T1.date = '1996-01-03' AND T1.amount = 98832",
        "amends": [],
        "rules": []
    },
    "1218": {
        "sql": [
            "WITH FemalePatients AS (\n    SELECT COUNT(*) AS total_female\n    FROM Patient\n    WHERE SEX = 'F'\n),\nHighUAFemalePatients AS (\n    SELECT COUNT(DISTINCT P.ID) AS high_ua_female\n    FROM Patient P\n    JOIN Laboratory L ON P.ID = L.ID\n    WHERE P.SEX = 'F' AND L.UA > 6.5\n)\nSELECT (high_ua_female * 100.0 / total_female) AS percentage\nFROM FemalePatients, HighUAFemalePatients;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(*) AS percentage\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'"
        ],
        "question": "What is the percentage of the female patient whose uric acid (UA) beyond the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F'",
        "amends": [
            "Do use a single query with `INNER JOIN` instead of separate CTEs and a cross join. Do calculate the percentage using `SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END)` instead of counting distinct IDs in a separate CTE. Do apply the `WHERE T1.SEX = 'F'` filter directly instead of filtering in separate CTEs. Do use `CAST(... AS REAL)` for precise division instead of implicit casting with `100.0`. Do remove the unnecessary `DISTINCT` count and cross join between CTEs, instead performing the calculation directly on the joined data. The amended query now correctly calculates the percentage of female patients with high UA values by joining the tables once and using conditional aggregation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "uric acid (UA) beyond the normal range refers to UA > 8.0 and SEX = 'M' or UA > 6.5 and SEX = 'F'; female refers to Sex = 'F'"
        ]
    },
    "214": {
        "sql": [
            "SELECT DISTINCT m.label\nFROM molecule m\nWHERE m.molecule_id NOT IN (\n  SELECT a.molecule_id\n  FROM atom a\n  WHERE a.element = 'tin'\n);"
        ],
        "question": "What type of label is not on molecules with atoms with tin?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "amends": [],
        "rules": [
            "tin refers to element ! = 'sn'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1017": {
        "sql": [
            "SELECT c.lat, c.lng FROM circuits c JOIN races r ON c.circuitId = r.circuitId JOIN results res ON r.raceId = res.raceId WHERE res.fastestLapTime = '1:29.488';",
            "SELECT DISTINCT c.lat, c.lng \nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nJOIN lapTimes lt ON r.raceId = lt.raceId\nWHERE lt.time = '1:29.488';"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "Please list the location coordinates of the circuits whose lap record is 1:29.488.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.lat, T3.lng FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T1.time = '1:29.488'",
        "amends": [
            "Do join `lapTimes` instead of `results` as the source table for lap time data. Do use `time` column instead of `fastestLapTime` to filter for the specific lap time '1:29.488'. Do maintain the same join path from lap times to races to circuits through `raceId` and `circuitId` relationships. Do keep the same output columns `lat` and `lng` from the circuits table. The amended query now correctly identifies circuits based on individual lap time records rather than aggregated fastest lap times from results."
        ],
        "rules": [
            "lap records means the fastest time recorded which refers to time; coordinates are expressed as latitude and longitude which refers to (lat, lng)"
        ]
    },
    "125": {
        "sql": [
            "SELECT \n    d.A2 AS district_name,\n    d.A3 AS state,\n    ((d.A13 - d.A12) / d.A12) * 100 AS unemployment_rate_increment_percentage\nFROM \n    loan l\nJOIN \n    disp dp ON l.account_id = dp.account_id\nJOIN \n    client c ON dp.client_id = c.client_id\nJOIN \n    district d ON c.district_id = d.district_id\nWHERE \n    l.status = 'D'\nGROUP BY \n    d.A2, d.A3, d.A12, d.A13;",
            "SELECT \n    d.A2 AS district_name,\n    d.A3 AS district_state,\n    CAST((d.A13 - d.A12) AS REAL) * 100 / d.A12 AS unemployment_rate_increment_percentage\nFROM \n    loan l\nINNER JOIN \n    account a ON l.account_id = a.account_id\nINNER JOIN \n    district d ON a.district_id = d.district_id\nWHERE \n    l.status = 'Running'",
            "SELECT \n    CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 AS unemployment_rate_increment\nFROM \n    loan T1\nINNER JOIN \n    account T2 ON T1.account_id = T2.account_id\nINNER JOIN \n    district T3 ON T2.district_id = T3.district_id\nWHERE \n    T1.status = 'D'"
        ],
        "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
        "amends": [
            "Do calculate `(A13 - A12) * 100 / A12` instead of `((A13 - A12) / A12) * 100` to ensure proper mathematical precedence. Do join `account` table instead of `disp` and `client` tables, connecting `loan` to `district` through `account.district_id` instead of through `disp.client_id` and `client.district_id`. Do remove the explicit `GROUP BY` clause instead of keeping unnecessary grouping when no aggregation is performed. Do cast `(A13 - A12)` to `REAL` instead of using integer division which could truncate decimal results. Do use `INNER JOIN` consistently instead of mixing `JOIN` without explicit type specification. The amended query now correctly calculates unemployment rate percentage using proper mathematical operations and eliminates unnecessary table joins and grouping.",
            "Do remove `d.A2 AS district_name` and `d.A3 AS district_state` from the SELECT list instead of including them. Do change the unemployment rate calculation to reference `T3.A13` and `T3.A12` instead of `d.A13` and `d.A12` while maintaining the same CAST expression. Do use table aliases `T1` for loan, `T2` for account, and `T3` for district instead of the original table names. Do change the WHERE filter to `T1.status = 'D'` instead of `l.status = 'Running'`. The amended query now correctly calculates the unemployment rate increment percentage for loans with status 'D' while removing unnecessary district information from the output."
        ],
        "rules": [
            "Unemployment increment rate in percentage = [(unemployment rate 2016 - unemployment rate 2015) / unemployment rate 2015] * 100; unemployment rate 2015 appears in the A12; unemployment rate 2016 appears in the A13; Loan contracts which are still running where client are in debt can be presented as status = 'D'"
        ]
    },
    "1237": {
        "sql": [
            "SELECT DISTINCT p.ID, p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Admission = '-' AND l.HGB < 10;"
        ],
        "question": "Among all outpatients, list out those have low hemoglobin level. State the different IDs and their sex.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HGB < 10 AND T1.Admission = '-'",
        "amends": [],
        "rules": [
            "outpatients refers to Admission = '-'; low hemoglobin level refers to HBG < 10;"
        ]
    },
    "795": {
        "sql": [
            "SELECT COUNT(*) FROM superhero WHERE alignment_id = 3;"
        ],
        "question": "How many superheroes have a neutral alignment?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "amends": [],
        "rules": [
            "neutral alignment refers to alignment_id = 3;"
        ]
    },
    "134": {
        "sql": [
            "WITH max_crime_district AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A16 DESC\n    LIMIT 1\n)\nSELECT COUNT(*) AS accounts_opened\nFROM account\nWHERE district_id = (SELECT district_id FROM max_crime_district);"
        ],
        "question": "In the branch where the largest number of crimes were committed in 1996, how many accounts were opened?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY T1.A16 ORDER BY T1.A16 DESC LIMIT 1",
        "amends": [],
        "rules": [
            "A16 stands for no. of committed crimes 1996"
        ]
    },
    "1084": {
        "sql": [
            "SELECT COUNT(DISTINCT p.player_api_id) \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE strftime('%Y', p.birthday) < '1986' \nAND pa.defensive_work_rate = 'high';"
        ],
        "question": "Among the players born before the year 1986, how many of them would remain in his position and defense while the team attacked?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.birthday) < '1986' AND t2.defensive_work_rate = 'high'",
        "amends": [],
        "rules": [
            "players born before the year 1986 refers to strftime('%Y', birthday)<'1986'; players who would remain in his position and defense while the team attacked refers to defensive_work_rate = 'high'; Should consider DISTINCT in the final result;"
        ]
    },
    "671": {
        "sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Autobiographer'\nORDER BY b.Date ASC\nLIMIT 1;"
        ],
        "question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "amends": [],
        "rules": [
            "Autobiographer is the name of the badge; acquired the first refers to MIN(Date);"
        ]
    },
    "723": {
        "sql": [
            "SELECT COUNT(DISTINCT s.id) AS count\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id AND c.colour = 'Blue'\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id AND sp.power_name = 'Agility';"
        ],
        "question": "Among the superheroes with blue eyes, how many of them have the super power of \"Agility\"?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id WHERE T3.power_name = 'Agility' AND T4.colour = 'Blue'",
        "amends": [],
        "rules": [
            "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'"
        ]
    },
    "1291": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' \nAND L.ALB > 3.5 AND L.ALB < 5.5 \nAND L.TP BETWEEN 6.0 AND 8.5;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'male' \nAND T2.ALB BETWEEN 3.5 AND 5.0 \nAND T2.TP BETWEEN 6.0 AND 8.0",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.ALB > 3.5 AND T2.ALB < 5.5\nAND T2.TP BETWEEN 6.0 AND 8.5"
        ],
        "question": "How many male patients have a normal level of both albumin and total protein?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M'  AND T2.ALB > 3.5 AND T2.ALB < 5.5 AND T2.TP BETWEEN 6.0 AND 8.5",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T2.ALB` and `T2.TP` instead of `L.ALB` and `L.TP` to match the table alias change. The amended query now correctly counts all patient records meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior.",
            "Do use `SEX = 'M'` instead of `SEX = 'male'` for the gender filter. Do change the ALB condition to `ALB > 3.5 AND ALB < 5.5` instead of `ALB BETWEEN 3.5 AND 5.0` to expand the upper bound. Do adjust the TP range to `TP BETWEEN 6.0 AND 8.5` instead of `TP BETWEEN 6.0 AND 8.0` to include higher values. The amended query now correctly matches the intended filtering criteria and behavior of the RIGHT_SQL."
        ],
        "rules": [
            "male refers to Sex = 'M'; normal level of both albumin and total protein refers to ALB > 3.5 and ALB < 5.5 AND TP between 6.0 and 8.5;"
        ]
    },
    "1140": {
        "sql": [
            "SELECT p.player_name, pa.sprint_speed, pa.agility, pa.acceleration\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Alexis Blin';",
            "SELECT sprint_speed, agility, acceleration \nFROM Player_Attributes \nWHERE player_api_id IN (\n    SELECT player_api_id \n    FROM Player \n    WHERE player_name = 'Alexis Blin'\n)"
        ],
        "question": "What are Alexis Blin's sprint speed, agility, and acceleration scores?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT sprint_speed, agility, acceleration FROM Player_Attributes WHERE player_api_id IN ( SELECT player_api_id FROM Player WHERE player_name = 'Alexis Blin' )",
        "amends": [
            "Do select only `sprint_speed, agility, acceleration` instead of including `p.player_name` in the SELECT list. Do query from `Player_Attributes` alone instead of joining `Player` and `Player_Attributes` tables. Do use a subquery with `WHERE player_api_id IN` instead of a JOIN operation. Do filter directly in the subquery with `WHERE player_name = 'Alexis Blin'` instead of applying the filter in the main query after the join. The amended query now correctly retrieves only the specified attributes from Player_Attributes for the specific player without unnecessary table joins and column selections."
        ],
        "rules": [
            "Alexis Blin's refers to player_name = 'Alexis Blin'"
        ]
    },
    "871": {
        "sql": [
            "SELECT d.nationality\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nWHERE q.raceId = 347 AND q.q2 = '0:01:15';",
            "SELECT DISTINCT T2.nationality\nFROM qualifying T1\nINNER JOIN drivers T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 347\nAND T1.q2 LIKE '1:15%';"
        ],
        "question": "For the driver who had the Q2 time as 0:01:15 in race No. 347, where is he from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 347 AND T1.q2 LIKE '1:15%'",
        "amends": [
            "Do use `DISTINCT` on `nationality` instead of omitting it to eliminate duplicate nationalities. Do reference `drivers` as `T2` instead of `d` and `qualifying` as `T1` instead of `q` for consistent table aliasing. Do use `INNER JOIN` with `T2.driverId = T1.driverId` instead of `JOIN` with `d.driverId = q.driverId` for explicit join type and corrected column reference order. Do change the filter to `q2 LIKE '1:15%'` instead of `q2 = '0:01:15'` to match time values with varying minute prefixes. Do maintain the `raceId = 347` filter in the WHERE clause instead of changing its position. The amended query now correctly returns distinct nationalities for drivers with qualifying times starting with '1:15' for race 347."
        ],
        "rules": [
            "race number refers to raceId;"
        ]
    },
    "1228": {
        "sql": [
            "SELECT p.ID, p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TG > 300;"
        ],
        "question": "Provide list of patients and their diagnosis with triglyceride (TG) index greater than 100 of the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG > 300",
        "amends": [],
        "rules": [
            "triglyceride (TG) index greater than 100 of the normal range refers to TG > 300;"
        ]
    },
    "260": {
        "sql": [
            "SELECT COUNT(a.atom_id) AS total_atoms\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE b.bond_type = '#' AND (a.element = 'p' OR a.element = 'br');"
        ],
        "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
        "amends": [],
        "rules": [
            "triple bond refers to bond_type = '#'; phosphorus refers to element = 'p'; bromine refers to element = 'br'"
        ]
    },
    "858": {
        "sql": [
            "SELECT c.nationality \nFROM constructors c \nJOIN constructorResults cr ON c.constructorId = cr.constructorId \nWHERE cr.raceId = 24 AND cr.points = 1;"
        ],
        "question": "Which country is the constructor which got 1 point in the race No. 24 from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 24 AND T1.points = 1",
        "amends": [],
        "rules": [
            "race number refers to raceId;"
        ]
    },
    "26": {
        "sql": [
            "SELECT s.School AS \"School Name\", s.Street, s.City, s.State, s.Zip\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.County = 'Monterey'\n  AND f.\"High Grade\" LIKE '%12%'\n  AND f.\"FRPM Count (Ages 5-17)\" > 800;",
            "SELECT T1.\"School Name\", T2.Street, T2.City, T2.Zip, T2.State\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Monterey'\nAND T1.\"School Type\" = 'High Schools (Public)'\nAND T1.\"Free Meal Count (Ages 5-17)\" > 800;",
            "SELECT \n    T1.`School Name` AS \"School Name\",\n    T2.Street,\n    T2.City,\n    T2.State,\n    T2.Zip\nFROM \n    frpm AS T1\nINNER JOIN \n    schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE \n    T2.County = 'Monterey'\n    AND T1.`Free Meal Count (Ages 5-17)` > 800\n    AND T1.`School Type` = 'High Schools (Public)'"
        ],
        "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
        "amends": [
            "Do select `T1.School Name` instead of `s.School` as \"School Name\" and use table aliases `T1` and `T2` instead of `s` and `f`. Do join `frpm AS T1` with `schools AS T2` instead of `schools s` with `frpm f`, maintaining the same `ON T1.CDSCode = T2.CDSCode` join condition. Do filter on `T2.County = 'Monterey'` instead of `s.County = 'Monterey'` and use `T1.Free Meal Count (Ages 5-17) > 800` instead of `f.FRPM Count (Ages 5-17) > 800`. Do add the new filter `T1.School Type = 'High Schools (Public)'` instead of omitting it, and do remove the filter `f.High Grade LIKE '%12%'` instead of keeping it. The amended query now correctly filters for high schools using the school type column instead of pattern matching on grade levels and uses the proper column name for free meal counts.",
            "Do use backticks for column names like `School Name` instead of double quotes, and maintain the same column order in the SELECT list with `State` before `Zip` instead of after it. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do move the `School Type` filter to the end of the WHERE clause instead of keeping it in the middle position. The amended query now correctly matches the RIGHT_SQL's behavior with proper identifier quoting and logical clause ordering."
        ],
        "rules": [
            "Full communication address should include Street, City, State and zip code if any."
        ]
    },
    "1282": {
        "sql": [
            "SELECT p.Birthday\nFROM Patient p\nJOIN (\n    SELECT ID, MAX(GPT) AS MaxGPT\n    FROM Laboratory\n    WHERE GPT < 60\n    GROUP BY ID\n) l ON p.ID = l.ID\nORDER BY l.MaxGPT DESC\nLIMIT 3;",
            "SELECT p.Birthday\nFROM Patient p\nINNER JOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT < 60\nORDER BY l.GPT DESC\nLIMIT 3;"
        ],
        "question": "Please list the top three patients' birthdays with the highest glutamic pylvic transaminase in the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT < 60 ORDER BY T2.GPT DESC LIMIT 3",
        "amends": [
            "Do use `INNER JOIN Laboratory` directly instead of a subquery with `MAX(GPT)` aggregation. Do move the `GPT < 60` filter to the `WHERE` clause instead of keeping it inside a subquery. Do reference `T2.GPT` directly in the `ORDER BY` instead of using `l.MaxGPT` from the subquery. Do remove the unnecessary `GROUP BY` and aggregation entirely instead of maintaining them. The amended query now correctly filters and sorts by individual GPT values below 60 rather than maximum values per patient, matching the intended behavior."
        ],
        "rules": [
            "highest glutamic pylvic transaminase in the normal range refers to MAX(GPT < 60);"
        ]
    },
    "1478": {
        "sql": [
            "SELECT c.Segment, SUM(ym.Consumption) AS TotalConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nGROUP BY c.Segment\nORDER BY TotalConsumption ASC\nLIMIT 1;",
            "SELECT T1.Segment\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nGROUP BY T1.Segment\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;"
        ],
        "question": "Which segment had the least consumption?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Segment ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do reference `Segment` directly in the SELECT list instead of including `SUM(ym.Consumption)` as `TotalConsumption`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with `c` and `ym`. Do place the aggregation `SUM(T2.Consumption)` directly in the ORDER BY clause instead of referencing the alias `TotalConsumption` from the SELECT list. The amended query now correctly identifies the segment with the minimum total consumption by moving the aggregate calculation to the ORDER BY clause where it can properly determine the ordering without relying on a SELECT list alias that isn't available during the sorting phase."
        ],
        "rules": []
    },
    "577": {
        "sql": [
            "SELECT c.Text FROM comments c JOIN users u ON c.UserId = u.Id WHERE u.DisplayName = 'A Lion';"
        ],
        "question": "Write all comments made by user 'A Lion.'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Text FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'A Lion'",
        "amends": [],
        "rules": [
            "\"A Lion\" is the DisplayName of user; comment refers to Text"
        ]
    },
    "37": {
        "sql": [
            "SELECT s.Street, s.City, s.State, s.Zip\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.NumTstTakr > 0\nORDER BY (sc.NumGE1500 * 1.0 / sc.NumTstTakr) ASC\nLIMIT 1;"
        ],
        "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code"
        ]
    },
    "132": {
        "sql": [
            "SELECT AVG(l.amount) AS average_loan_amount\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE c.gender = 'M';"
        ],
        "question": "What is the average loan amount by male borrowers?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT AVG(T4.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'M'",
        "amends": [],
        "rules": [
            "Male refers to gender = 'M'"
        ]
    },
    "249": {
        "sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR144_8_19';",
            "SELECT T2.element \nFROM connected AS T1 \nINNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id \nINNER JOIN molecule AS m ON T2.molecule_id = m.molecule_id \nWHERE m.label = 'TR144_8_19'",
            "SELECT T2.element\nFROM connected AS T1\nINNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.bond_id = 'TR144_8_19'"
        ],
        "question": "What are the elements of the atoms of TR144_8_19?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'",
        "amends": [
            "Do select only `T2.element` instead of both `a1.element` and `a2.element` with aliases. Do use `INNER JOIN` with `atom AS T2` on `T1.atom_id = T2.atom_id` instead of joining two atom tables on different columns. Do remove the second join to `atom a2` on `c.atom_id2 = a2.atom_id` instead of keeping it. Do use table alias `T1` for `connected` instead of `c`. Do remove the unnecessary column aliases `element1` and `element2` instead of including them. The amended query now correctly retrieves only the element from the single relevant atom table based on the atom_id relationship, matching the RIGHT_SQL's behavior.",
            "Do remove the `INNER JOIN molecule AS m ON T2.molecule_id = m.molecule_id` and its associated condition instead of including it. Do change the WHERE filter to use `T1.bond_id = 'TR144_8_19'` instead of `m.label = 'TR144_8_19'`. The amended query now correctly filters by bond_id from the connected table rather than incorrectly joining through molecule to check label, matching the intended behavior."
        ],
        "rules": [
            "TR144_8_19 is the bond id; "
        ]
    },
    "120": {
        "sql": [
            "SELECT a.account_id, a.frequency\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE d.A3 = 'east Bohemia'\nAND a.date BETWEEN '1995-01-01' AND '2000-12-31';"
        ],
        "question": "From Year 1995 to 2000, who are the accounts holders from 'east Bohemia'. State the account ID the frequency of statement issuance.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T1.frequency FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000'",
        "amends": [],
        "rules": [
            "Accounts holder refers to the person who own this account."
        ]
    },
    "758": {
        "sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nJOIN colour c ON s.hair_colour_id = c.id\nWHERE r.race = 'Human' AND s.height_cm = 185;"
        ],
        "question": "Provide the hair colour of the human superhero who is 185 cm tall.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
        "amends": [],
        "rules": [
            "185 cm tall refers to height_cm = 185; human superhero refers to race = 'human'; hair colour refers to colour where hair_colour_id = colour.id;"
        ]
    },
    "993": {
        "sql": [
            "SELECT name, location, country, lat, lng FROM circuits WHERE name = 'Hungaroring';",
            "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring';"
        ],
        "question": "In which location does the Hungaroring circuit located? Also, find the country and coordinates of this circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring'",
        "amends": [
            "Do remove `name` and `location` from the SELECT list instead of including them, and do keep only `country`, `lat`, and `lng` instead of the original five columns. Do maintain the same FROM source `circuits` and WHERE filter `name = 'Hungaroring'` without changes. The amended query now correctly returns only the country and coordinates data for the specified circuit instead of including unnecessary name and location information."
        ],
        "rules": [
            "coordinates expressed in latitude and longitude refers to (lat, lng)"
        ]
    },
    "1097": {
        "sql": [
            "SELECT SUM(pa.crossing) AS total_crossing_score\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Aaron Lennox';"
        ],
        "question": "What is Aaron Lennox's total crossing score?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.crossing) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Lennox'",
        "amends": [],
        "rules": [
            "Aaron Lennox's refers to T2.player_name = 'Aaron Lennox'; total crossing score refers to SUM(crossing)"
        ]
    },
    "524": {
        "sql": [
            "SELECT DISTINCT artist FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability NOT LIKE '%paper%' AND availability NOT LIKE '%mtgo%';"
        ],
        "question": "List the artists who illustrated cards with black borders which are available only in arena.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT artist FROM cards WHERE availability = 'arena' AND BorderColor = 'black'",
        "amends": [],
        "rules": [
            "black borders refers to BorderColor = 'black'; available only in arena refers to availability = 'arena'"
        ]
    },
    "1357": {
        "sql": [
            "SELECT i.date_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.first_name = 'Connor' AND m.last_name = 'Hilton';"
        ],
        "question": "State the date Connor Hilton paid his/her dues.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Connor' AND T1.last_name = 'Hilton' AND T2.source = 'Dues'",
        "amends": [],
        "rules": [
            "Connor Hilton is the full name; full name refers to first_name, last_name; date the dues was paid refers to date_received where source = 'Dues';"
        ]
    },
    "1450": {
        "sql": [
            "SELECT e.event_name, z.city, z.county\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nJOIN income i ON m.member_id = i.link_to_member\nJOIN zip_code z ON m.zip = z.zip_code\nGROUP BY e.event_id\nHAVING COUNT(i.income_id) > 40;",
            "SELECT DISTINCT z.city, z.county\nFROM income i\nINNER JOIN member m ON i.link_to_member = m.member_id\nINNER JOIN zip_code z ON m.zip = z.zip_code\nWHERE i.amount > 40"
        ],
        "question": "In the events with more than forty incomes, list the city and country in which the event is happening.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.city, T3.county FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip WHERE T1.amount > 40",
        "amends": [
            "Do select only `city` and `county` instead of including `event_name` and grouping by `event_id`. Do remove the `event` and `attendance` table joins instead of keeping them. Do add a filter on `amount > 40` instead of counting income records with `HAVING COUNT(i.income_id) > 40`. Do use `INNER JOIN` between `income` and `member` on `link_to_member = member_id` instead of joining through attendance. Do join `zip_code` directly to `member` on `zip_code = zip` instead of the previous join path. Do add `DISTINCT` to eliminate duplicates instead of using GROUP BY. The amended query now correctly filters by income amount rather than counting records and returns the intended zip code locations."
        ],
        "rules": [
            "more than fifty incomes refers to income > 40"
        ]
    },
    "1074": {
        "sql": [
            "SELECT t.team_short_name \nFROM Match m \nJOIN Team t ON m.home_team_api_id = t.team_api_id \nWHERE m.home_team_goal = 10;"
        ],
        "question": "List all the short name of the football team that had a home team goal of 10?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.team_short_name FROM Team AS t1 INNER JOIN Match AS t2 ON t1.team_api_id = t2.home_team_api_id WHERE t2.home_team_goal = 10",
        "amends": [],
        "rules": [
            "short name of the football team refers to team_short_name; home team goal refers to home_team_goal; home_team_goal = 10;"
        ]
    },
    "900": {
        "sql": [
            "SELECT circuits.name AS circuit_name, circuits.location, races.name AS race_name\nFROM circuits\nJOIN races ON circuits.circuitId = races.circuitId\nWHERE races.year = 2006 AND circuits.country = 'USA';"
        ],
        "question": "List circuits in USA which hosted f1 races in 2006. State the name and location of circuit and the name of the race it hosted.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.location, T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'USA' AND T2.year = 2006",
        "amends": [],
        "rules": []
    },
    "768": {
        "sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Dark Horse Comics');"
        ],
        "question": "How many superheroes were published by Dark Horse Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Dark Horse Comics'",
        "amends": [],
        "rules": [
            "published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';"
        ]
    },
    "833": {
        "sql": [
            "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';"
        ],
        "question": "Name the superhero, otherwise known as Charles Chandler.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler'",
        "amends": [],
        "rules": [
            "name the superhero refers to superhero_name; Charles Chandler is the full name of superhero;"
        ]
    },
    "1124": {
        "sql": [
            "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.attacking_work_rate = 'high';"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "amends": [],
        "rules": [
            "tend to be attacking when their mates were doing attack moves refers to attacking_work_rate = 'high';"
        ]
    },
    "300": {
        "sql": [
            "SELECT atom_id, element FROM atom WHERE molecule_id = 'TR186';",
            "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id = 'TR186';"
        ],
        "question": "What atoms comprise TR186?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id = 'TR186'",
        "amends": [
            "Do reference the table with alias `T` instead of using the bare table name. Do remove the column `element` from the SELECT list instead of including it. Do qualify the column `atom_id` with the table alias as `T.atom_id` instead of using the unqualified column name. Do qualify the column `molecule_id` with the table alias as `T.molecule_id` instead of using the unqualified column name. The amended query now correctly selects only the atom_id column from the aliased table with proper column qualification."
        ],
        "rules": [
            "TR186 is a molecule id"
        ]
    },
    "669": {
        "sql": [
            "SELECT MIN(v.CreationDate) AS FirstVoteDate\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE u.DisplayName = 'chl';"
        ],
        "question": "When did 'chl' cast its first vote in a post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.CreationDate FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl' ORDER BY T2.CreationDate LIMIT 1",
        "amends": [],
        "rules": [
            "DisplayName = 'chl'; cast its first vote refers to MIN(CreationDate);"
        ]
    },
    "564": {
        "sql": [
            "SELECT c.Text FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.ParentId = 107829 LIMIT 1;"
        ],
        "question": "Give the only one comment text of the post with parent id 107829.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "amends": [],
        "rules": [
            "one comment refers to CommentCount = '1'"
        ]
    },
    "1382": {
        "sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE maj.major_name = 'Interior Design' AND e.event_name = 'Community Theater';"
        ],
        "question": "Among the students majored in interior design, who have attended the Community Theater event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id WHERE T4.event_name = 'Community Theater' AND T1.major_name = 'Interior Design'",
        "amends": [],
        "rules": [
            "majored in music refers to major_name = 'Interior Design'; 'Community Theater' is the event name;"
        ]
    },
    "748": {
        "sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.id = 75;"
        ],
        "question": "What is the eye colour of superhero with superhero ID 75?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.id = 75",
        "amends": [],
        "rules": [
            "eye colour refers to colour where eye_colour_id = colour.id;"
        ]
    },
    "1305": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.Admission = '+' AND L.WBC BETWEEN 3.5 AND 9.0;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = 'Yes' \nAND T2.WBC BETWEEN 3.5 AND 9",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '+' \nAND T2.WBC BETWEEN 3.5 AND 9"
        ],
        "question": "How many patients accepted to the hospital have a normal level of white blood cells?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC BETWEEN 3.5 AND 9 AND T1.Admission = '+'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T2.WBC BETWEEN 3.5 AND 9` instead of `L.WBC BETWEEN 3.5 AND 9.0` to use integer comparison and remove the unnecessary decimal. Do place both filter conditions in the `WHERE` clause instead of keeping them there, maintaining the same logical structure. Do use table aliases `T1` and `T2` consistently instead of `P` and `L` for better readability. The amended query now correctly counts all patient records meeting the specified criteria without unnecessary distinct counting and matches the RIGHT_SQL's behavior.",
            "Do remove the `T1.Admission = 'Yes'` filter instead of keeping it, and do change the admission filter to `T1.Admission = '+'` instead of `T1.Admission = 'Yes'`. Do maintain the `INNER JOIN` on `T1.ID = T2.ID` and the `T2.WBC BETWEEN 3.5 AND 9` filter as they appear in both queries. The amended query now correctly filters for patients with admission status as '+' rather than 'Yes', matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "accepted to the hospital refers to Admission = '+'; normal level of white blood cells refers to WBC between 3.5 and 9.0;"
        ]
    },
    "361": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.status = 'restricted' AND c.isTextless = 0;",
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T2.status = 'Restricted' AND T1.isTextless = 0"
        ],
        "question": "How many cards of legalities whose status is restricted have text boxes?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isTextless = 0",
        "amends": [
            "Do use `COUNT(DISTINCT T1.id)` instead of `COUNT(*)` to count distinct card IDs rather than all rows. Do specify table aliases as `T1` and `T2` instead of `c` and `l` for consistency. Do use `INNER JOIN` with explicit table aliases instead of simple `JOIN` with different aliases. Do reference `T2.status = 'Restricted'` instead of `l.status = 'restricted'` to match the exact case-sensitive value. Do reference `T1.isTextless = 0` instead of `c.isTextless = 0` with the proper table alias. The amended query now correctly counts distinct restricted, non-textless cards matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "restricted refers to status = 'restricted'; have text boxes refers to is Textless = 0;"
        ]
    },
    "296": {
        "sql": [
            "SELECT b.molecule_id\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE c.bond_id = 'TR000_1_2' AND c.atom_id = 'TR000_1';",
            "SELECT T2.molecule_id, T2.bond_id, T1.atom_id\nFROM connected AS T1\nINNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.atom_id = 'TR000_1'\nAND T2.bond_id = 'TR000_1_2'"
        ],
        "question": "Indicate the molecule id is belonging to the TR000_1_2 bond that has the first atom named TR000_1.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.molecule_id, T2.bond_id, T1.atom_id FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'",
        "amends": [
            "Do select `T2.molecule_id, T2.bond_id, T1.atom_id` instead of only `b.molecule_id`. Do use explicit table aliases `AS T1` and `AS T2` instead of implicit `c` and `b`. Do specify `INNER JOIN` instead of just `JOIN`. Do place the `WHERE` condition `T1.atom_id = 'TR000_1'` before `T2.bond_id = 'TR000_1_2'` instead of the reverse order. The amended query now correctly returns all three relevant columns with proper table references and maintains the same join logic and filtering conditions."
        ],
        "rules": []
    },
    "1243": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN P.SEX = 'F' AND L.PT >= 14 THEN 1 ELSE 0 END) * 100.0 / \n    SUM(CASE WHEN L.PT >= 14 THEN 1 ELSE 0 END)) AS percentage_female_abnormal_PT\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 55;",
            "SELECT \n    CAST(SUM(CASE WHEN T1.SEX = 'F' AND T2.PT >= 14 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday)) > 55"
        ],
        "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
        "amends": [
            "Do use `CAST(SUM(...) AS REAL)` for precise division instead of implicit integer division. Do reference tables with aliases `T1` and `T2` instead of full table names. Do place the `PT >= 14` condition inside the CASE expression instead of in both numerator and denominator separately. Do use `COUNT(*)` in the denominator instead of `SUM(CASE WHEN L.PT >= 14 THEN 1 ELSE 0 END)` to count all joined records. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do use `CURRENT_TIMESTAMP` instead of `'now'` for the current time reference. Do remove the column alias `percentage_female_abnormal_PT` instead of keeping it. The amended query now correctly calculates the percentage using proper type casting and simplified counting logic."
        ],
        "rules": [
            "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; "
        ]
    },
    "1050": {
        "sql": [
            "SELECT pa.preferred_foot\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY p.birthday DESC\nLIMIT 1;"
        ],
        "question": "What is the preferred foot when attacking of the youngest football player?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday DESC LIMIT 1",
        "amends": [],
        "rules": [
            "preferred foot when attacking refers to preferred_foot; youngest football player refers to latest birthday;"
        ]
    },
    "528": {
        "sql": [
            "SELECT c.name, l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.setCode = (SELECT code FROM sets WHERE name = 'Hour of Devastation');"
        ],
        "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
        "amends": [],
        "rules": [
            "the set Hour of Devastation refers to set.name = 'Hour of Devastation'; names of all the cards in the set refers to cards.name; legal cards refers to status = 'Legal'; the formats refers to format"
        ]
    },
    "124": {
        "sql": [
            "SELECT l.loan_id, d.A2 AS district, d.A11 AS average_salary\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.duration = 60;"
        ],
        "question": "List the loan ID, district and average salary for loan with duration of 60 months.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.loan_id, T2.A2, T2.A11 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.duration = 60",
        "amends": [],
        "rules": [
            "A3 refers to regions; A11 refers to average salary"
        ]
    },
    "490": {
        "sql": [
            "SELECT mcmId FROM sets WHERE code = 'SS2';"
        ],
        "question": "For the set which had 'SS2' as the code, what is its magic card market id?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT mcmId FROM sets WHERE code = 'SS2'",
        "amends": [],
        "rules": [
            "magic card market id refers to mcmId"
        ]
    },
    "1108": {
        "sql": [
            "SELECT ta.buildUpPlaySpeedClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'Willem II' \nAND ta.date = '2011-02-22';",
            "SELECT t2.buildUpPlaySpeedClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Willem II' \nAND SUBSTR(t2.date, 1, 10) = '2011-02-22'"
        ],
        "question": "What was the build up play speed class for \"Willem II\" on 2011/2/22?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.buildUpPlaySpeedClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Willem II' AND SUBSTR(t2.`date`, 1, 10) = '2011-02-22'",
        "amends": [
            "Do use table alias `t2` for the Team_Attributes table instead of `ta` and reference `t2.buildUpPlaySpeedClass` instead of `ta.buildUpPlaySpeedClass`. Do use explicit `INNER JOIN` instead of just `JOIN` while maintaining the same join condition `t1.team_api_id = t2.team_api_id`. Do add table alias `t1` for the Team table instead of `t` and reference `t1.team_long_name` instead of `t.team_long_name`. Do use `SUBSTR(t2.date, 1, 10)` for date comparison instead of direct equality `t2.date = '2011-02-22'` to handle potential timestamp values by extracting just the date portion. The amended query now correctly handles date filtering and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "\"Willem II\" refers to team_long_name = 'Willem II'; on 2011/2/22 refers to date = '2012-02-22'"
        ]
    },
    "746": {
        "sql": [
            "SELECT AVG(attribute_value) AS average_attribute_value FROM hero_attribute;"
        ],
        "question": "Calculate the average attribute value of all superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(attribute_value) FROM hero_attribute",
        "amends": [],
        "rules": [
            "average attribute value of all superheroes refers to AVG(attribute_value)"
        ]
    },
    "441": {
        "sql": [
            "SELECT code FROM sets WHERE releaseDate = '2007-07-13';",
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '07/13/2007'",
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'"
        ],
        "question": "State the set code of the set with release date of 07/13/2007?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'",
        "amends": [
            "Do select `T2.setCode` from the joined table instead of `code` from the base table. Do add `INNER JOIN set_translations AS T2` with predicate `ON T2.setCode = T1.code` instead of querying only the `sets` table. Do reference the table as `T1` in the `WHERE` clause with `T1.releaseDate` instead of directly using `releaseDate`. The amended query now correctly joins the translation table to retrieve the appropriate set codes while maintaining the same date filter condition, matching the RIGHT_SQL's behavior.",
            "Do use the ISO date format `'2007-07-13'` in the WHERE clause instead of the ambiguous `'07/13/2007'` format to ensure proper date comparison and avoid potential parsing errors across different database systems. The amended query now correctly filters by the specified release date using a standardized date format that matches the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "478": {
        "sql": [
            "SELECT * FROM cards WHERE setCode = 'Coldsnap' AND number = '4';",
            "SELECT T1.name \nFROM cards AS T1 \nINNER JOIN sets AS T2 ON T2.code = T1.setCode \nWHERE T2.name = 'Coldsnap' AND T1.number = 4"
        ],
        "question": "What is card number 4 in the set Coldsnap?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.number = 4",
        "amends": [
            "Do select only `T1.name` instead of all columns with `*`. Do join `sets AS T2` instead of querying only the `cards` table. Do use `INNER JOIN` with `T2.code = T1.setCode` instead of filtering directly on `setCode`. Do filter on `T2.name = 'Coldsnap'` instead of `setCode = 'Coldsnap'`. Do use numeric comparison `T1.number = 4` instead of string comparison `number = '4'`. The amended query now correctly joins the sets table to filter by set name rather than set code and uses proper data type comparisons."
        ],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; card number 4 refers to number = 4"
        ]
    },
    "442": {
        "sql": [
            "SELECT baseSetSize, code FROM sets WHERE block IN ('Masques', 'Mirage');",
            "SELECT DISTINCT T1.baseSetSize, T2.setCode\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code\nWHERE T1.block IN ('Masques', 'Mirage')"
        ],
        "question": "Mention the base set size and set code of the set that was in block named \"Masques\" and \"Mirage\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.baseSetSize, T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block IN ('Masques', 'Mirage')",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the SELECT list to `T1.baseSetSize, T2.setCode` instead of `baseSetSize, code`. Do add `INNER JOIN set_translations AS T2 ON T2.setCode = T1.code` instead of querying only the `sets` table. Do add table aliases `T1` and `T2` instead of using unqualified column names. Do qualify the WHERE clause with `T1.block` instead of just `block`. The amended query now correctly joins with set_translations to retrieve the appropriate setCode values and ensures distinct results."
        ],
        "rules": []
    },
    "701": {
        "sql": [
            "WITH most_influential_user AS (\n    SELECT Id\n    FROM users\n    ORDER BY Reputation DESC\n    LIMIT 1\n),\nuser_posts AS (\n    SELECT Id, Score\n    FROM posts\n    WHERE OwnerUserId = (SELECT Id FROM most_influential_user)\n),\ntotal_posts AS (\n    SELECT COUNT(*) AS total\n    FROM user_posts\n),\nhigh_score_posts AS (\n    SELECT COUNT(*) AS high_score\n    FROM user_posts\n    WHERE Score > 50\n)\nSELECT (high_score * 100.0 / total) AS percentage\nFROM high_score_posts, total_posts;"
        ],
        "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
        "amends": [],
        "rules": [
            "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));"
        ]
    },
    "1191": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN p.Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient p\nWHERE \n    p.SEX = 'M' AND \n    strftime('%Y', p.`First Date`) = '1981';"
        ],
        "question": "What percentage of male patients who first presented to the hospital in 1981 were diagnosed with BEHCET?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE STRFTIME('%Y', `First Date`) = '1981' AND SEX = 'M'",
        "amends": [],
        "rules": [
            "male refers to SEX = 'M'; first presented to the hospital in 1981 refers to YEAR(`FIRST DATE`) = '1981'; BEHCET refers to diagnosis; calculation = DIVIDE(SUM(DIAGNOSIS = 'BEHCET') where YEAR(`FIRST DATE`) = '1981', MULTIPLY(COUNT(YEAR(`FIRST DATE`) = '1981')), 100)"
        ]
    },
    "933": {
        "sql": [
            "SELECT r.positionOrder \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' \nAND ra.year = 2008 AND ra.name = 'Chinese Grand Prix';"
        ],
        "question": "What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.positionOrder FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.name = 'Chinese Grand Prix' AND T1.year = 2008",
        "amends": [],
        "rules": [
            "Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; final rank refers to positionOrder; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';"
        ]
    },
    "1511": {
        "sql": [
            "SELECT AVG(Amount * Price) AS AverageTotalPrice\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE c.Currency = 'EUR';",
            "SELECT AVG(T1.Price) AS AveragePrice\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Currency = 'EUR';"
        ],
        "question": "For the customers who paid in the euro, what is their average total price of the transactions?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Currency = 'EUR'",
        "amends": [
            "Do select `AVG(T1.Price)` instead of `AVG(Amount * Price)` to calculate the average price rather than the product of amount and price. Do join `gasstations AS T2` on `T1.GasStationID = T2.GasStationID` instead of omitting this table entirely. Do use `INNER JOIN` for both joins instead of just `JOIN` for clarity. Do reference tables as `T1`, `T2`, and `T3` with explicit aliases instead of `t` and `c` for better readability. Do filter on `T3.Currency = 'EUR'` instead of `c.Currency = 'EUR'` to maintain consistent table alias usage. The amended query now correctly calculates the average price from transactions joined with both gasstations and customers tables for EUR currency transactions."
        ],
        "rules": []
    },
    "1484": {
        "sql": [
            "SELECT \n    (SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'discount') - \n    (SELECT COUNT(*) FROM gasstations WHERE Country = 'SVK' AND Segment = 'discount') AS MoreDiscountGasStations;",
            "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) AS difference\nFROM gasstations\nWHERE Segment = 'Discount';"
        ],
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "amends": [
            "Do use a single query with conditional aggregation using `SUM(IIF(Country = 'CZE', 1, 0))` and `SUM(IIF(Country = 'SVK', 1, 0))` instead of separate subqueries with `COUNT(*)` for each country. Do apply the `Segment = 'Discount'` filter once in the main `WHERE` clause instead of repeating it in each subquery. Do use consistent case sensitivity with `'Discount'` instead of `'discount'` for the segment value. The amended query now correctly calculates the difference in discount gas station counts between Czech Republic and Slovakia with proper filtering and aggregation."
        ],
        "rules": [
            "Czech Republic can be represented as the Country value in gasstations table is 'CZE'; Slovakia can be represented as the Country value in the gasstations table is 'SVK';  Computation of more \"discount\" gas stations= Total no. of discount gas stations in Czech Republic - Total no. of discount gas stations in Slovakia"
        ]
    },
    "968": {
        "sql": [
            "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';"
        ],
        "question": "What is reference name of Robert Kubica?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica'",
        "amends": [],
        "rules": [
            "reference name refers to driverRef;"
        ]
    },
    "570": {
        "sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'DatEpicCoderGuyWhoPrograms';"
        ],
        "question": "For the user whose display name is \"DatEpicCoderGuyWhoPrograms\", what is his/her badge's name?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'DatEpicCoderGuyWhoPrograms'",
        "amends": [],
        "rules": [
            "\"DatEpicCoderGuyWhoPrograms\" is the DisplayName;"
        ]
    },
    "521": {
        "sql": [
            "SELECT l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.frameVersion = '1997'\nAND c.artist = 'D. Alexander Gregory'\nAND (c.hasContentWarning = 1 OR c.flavorText LIKE '%Wizards of the Coast%')\nAND l.format = 'legacy';"
        ],
        "question": "Among the cards whose version of frame style is 1997, what is the status of the card illustrated by D. Alexander Gregory in legacy play format that has sensitive content or Wizards of the Coast?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.frameVersion = 1997 AND T1.hasContentWarning = 1 AND T1.artist = 'D. Alexander Gregory' AND T2.format = 'legacy'",
        "amends": [],
        "rules": [
            "version of frame style is 1997 refers to frameVersion = '1997'; illustrated by D. Alexander Gregory refers to artist = 'D. Alexander Gregory'; sensitive content refers to hasContentWarning = 1; legacy play format refers to format = 'legacy'; status of the card refers to status"
        ]
    },
    "1210": {
        "sql": [
            "SELECT AVG(LDH) AS average_LDH FROM Laboratory WHERE LDH < 500;"
        ],
        "question": "What is the average index of the lactate dehydrogenase (LDH) for all patients with lactate dehydrogenase (LDH) within the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(LDH) FROM Laboratory WHERE LDH < 500",
        "amends": [],
        "rules": [
            "average index of the lactate dehydrogenase (LDH) refers to AVG(LDH); (LDH) within the normal range refers to LDH < 500"
        ]
    },
    "865": {
        "sql": [
            "SELECT d.driverId, d.forename, d.surname, d.dob\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 592 AND r.time IS NOT NULL\nORDER BY d.dob ASC\nLIMIT 1;",
            "SELECT T1.forename, T1.surname\nFROM drivers T1\nJOIN results T2 ON T1.driverId = T2.driverId\nWHERE T2.raceId = 592 \nAND T2.position IS NOT NULL \nAND T1.dob IS NOT NULL\nORDER BY T1.dob ASC\nLIMIT 1",
            "SELECT T1.forename, T1.surname\nFROM drivers T1\nINNER JOIN results T2 ON T2.driverId = T1.driverId\nWHERE T2.raceId = 592\nAND T2.time IS NOT NULL\nAND T1.dob IS NOT NULL\nORDER BY T1.dob ASC\nLIMIT 1"
        ],
        "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
        "amends": [
            "Do select only `forename` and `surname` instead of including `driverId` and `dob` in the SELECT list. Do add filter `T1.dob IS NOT NULL` to the WHERE clause instead of omitting it, ensuring only drivers with known birthdates are considered. Do use table aliases `T1` for drivers and `T2` for results instead of single-letter aliases, though this is cosmetic. The amended query now correctly identifies the youngest driver with a valid time in race 592 by ensuring dob is not null before ordering.",
            "Do filter on `T2.time IS NOT NULL` instead of `T2.position IS NOT NULL` in the WHERE clause. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do maintain the same join condition `T2.driverId = T1.driverId` instead of `T1.driverId = T2.driverId` while preserving the same logical relationship. The amended query now correctly filters drivers who completed the race with a recorded time rather than just having a position, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL); race number refers to raceId; date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;"
        ]
    },
    "974": {
        "sql": [
            "SELECT r.year FROM results res JOIN races r ON res.raceId = r.raceId WHERE res.fastestLapTime IS NOT NULL ORDER BY res.fastestLapTime ASC LIMIT 1;",
            "SELECT T2.year\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T1.fastestLapTime IS NOT NULL"
        ],
        "question": "State the racing year which has the fastest lap time?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `res` and `r` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do select `T2.year` instead of `r.year` to maintain consistent alias usage. Do keep the `WHERE T1.fastestLapTime IS NOT NULL` filter unchanged. Do remove the `ORDER BY res.fastestLapTime ASC LIMIT 1` clause instead of keeping it, as the right query returns all qualifying records rather than just the single fastest lap. The amended query now matches RIGHT_SQL's behavior of returning all years where fastest lap times were recorded rather than just the year of the single fastest lap."
        ],
        "rules": [
            "'has the fastest lap time?' refers to fastestLapTime has values"
        ]
    },
    "1": {
        "sql": [
            "SELECT \n    `School Name`,\n    `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` AS `Eligible Free Rate`\nFROM \n    frpm\nWHERE \n    `School Type` = 'Continuation'\n    AND `Enrollment (Ages 5-17)` > 0\nORDER BY \n    `Eligible Free Rate` ASC\nLIMIT 3;",
            "SELECT CDSCode, \"Percent (%) Eligible Free (Ages 5-17)\" AS \"Eligible Free Rate\"\nFROM frpm\nWHERE \"Educational Option Type\" = 'Continuation School' \nAND \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" IS NOT NULL\nORDER BY \"Percent (%) Eligible Free (Ages 5-17)\" ASC\nLIMIT 3;",
            "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` \nFROM frpm \nWHERE `Educational Option Type` = 'Continuation School' \nAND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL \nORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` \nLIMIT 3"
        ],
        "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3",
        "amends": [
            "Do remove `School Name` from the SELECT list instead of including it. Do change the WHERE filter to use `Educational Option Type` = 'Continuation School' instead of `School Type` = 'Continuation'. Do replace the `Enrollment (Ages 5-17)` > 0 condition with `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL instead of the enrollment check. Do update the ORDER BY clause to reference the full calculation expression instead of the alias `Eligible Free Rate`. The amended query now correctly filters for continuation schools using the proper column name, ensures valid rate calculations by checking for non-null results rather than just positive enrollment, and maintains consistent expression usage throughout.",
            "Do select the expression `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` instead of selecting `CDSCode` and aliasing the expression as `Eligible Free Rate`. Do use backticks around column names `Free Meal Count (Ages 5-17)` and `Enrollment (Ages 5-17)` instead of double quotes. Do order by the expression `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` instead of ordering by the alias `Percent (%) Eligible Free (Ages 5-17)`. The amended query now correctly calculates and orders by the free meal eligibility rate directly rather than using an aliased column reference."
        ],
        "rules": [
            "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`"
        ]
    },
    "1165": {
        "sql": [
            "SELECT MAX(strftime('%Y', Birthday)) - MIN(strftime('%Y', Birthday)) AS age_gap\nFROM Patient\nWHERE ID IN (SELECT DISTINCT ID FROM Laboratory WHERE TG >= 200);"
        ],
        "question": "What is the age gap between the youngest and oldest patient with a normal triglyceride recorded?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', MAX(T1.Birthday)) - STRFTIME('%Y', MIN(T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200",
        "amends": [],
        "rules": [
            "age gap refers to SUBTRACT(MAX(year(Birthday)) - MIN(year(Birthday))); normal triglyceride refers to tg > = 200"
        ]
    },
    "155": {
        "sql": [
            "SELECT (COUNT(CASE WHEN type = 'gold' AND issued < '1998-01-01' THEN 1 END) * 100.0 / COUNT(*)) AS percent_gold_pre_1998\nFROM card;"
        ],
        "question": "How many percent of 'Gold' cards were issued prior to 1998?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') AS REAL) * 100 / COUNT(card_id) FROM card",
        "amends": [],
        "rules": [
            "Percent of Gold = [ count(type = 'gold' and issued date < 1998) / count(all cards)] * 100%"
        ]
    },
    "494": {
        "sql": [
            "SELECT c.name AS card_name, r.text AS ruling_text, \n       CASE WHEN c.hasContentWarning = 1 THEN 'Yes' ELSE 'No' END AS has_missing_or_degraded_properties\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.artist = 'Jim Pavelec';",
            "SELECT T2.text, CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards T1 INNER JOIN rulings T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec'"
        ],
        "question": "For all cards illustrated by Jim Pavelec. and describe the text of the ruling of these cards. Do these cards have missing or degraded properties and values.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text , CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec'",
        "amends": [
            "Do use `T2.text` without an alias instead of `r.text AS ruling_text` for the ruling text column. Do use `CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END` with uppercase 'YES'/'NO' instead of mixed case 'Yes'/'No' and omit the alias `has_missing_or_degraded_properties`. Do remove `c.name AS card_name` instead of including it in the SELECT list. Do specify `INNER JOIN` explicitly instead of just `JOIN` for the join type. Do use `T2.uuid = T1.uuid` instead of `c.uuid = r.uuid` for the join condition while maintaining the same logical relationship. Do use table aliases `T1` and `T2` instead of `c` and `r` while keeping the same table references. The amended query now correctly focuses only on the ruling text and content warning status without the unnecessary card name column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "all cards illustrated by Jim Pavelec refers to artist = 'Jim Pavelec'; the text of the ruling refers to text; cards have missing or degraded properties and values if hasContentWarning = 1 else it doesn't have;"
        ]
    },
    "1180": {
        "sql": [
            "SELECT p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT = 9 AND l.Date = '1992-06-12';"
        ],
        "question": "Was the patient a man or a women whose ALT glutamic pylvic transaminase status got 9 on 1992-6-12?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT = 9.0 AND T2.Date = '1992-06-12'",
        "amends": [],
        "rules": [
            "man refers to SEX = 'M'; women refers to SEX = 'F'; ALT glutamic pylvic transaminase status got 9 GPT = '9'; 1992/6/12 refers to Date = '1992-06-12'"
        ]
    },
    "1110": {
        "sql": [
            "SELECT ta.buildUpPlayPassingClass \nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE t.team_long_name = 'FC Lorient' AND ta.date LIKE '2010-02-22%';"
        ],
        "question": "Tell the build Up play passing class for \"FC Lorient\" on 2010/2/22.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'FC Lorient' AND t2.`date` LIKE '2010-02-22%'",
        "amends": [],
        "rules": [
            "\"FC Lorient\" refers to team_long_name = 'FC Lorient'; on 2010/2/22 refers to date LIKE '2010-02-22%';"
        ]
    },
    "912": {
        "sql": [
            "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit';"
        ],
        "question": "What's the reference name of Marina Bay Street Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit'",
        "amends": [],
        "rules": [
            "reference name refers to circuitRef; Marina Bay Street Circuit refers to circuits.name = 'Marina Bay Street Circuit'"
        ]
    },
    "907": {
        "sql": [
            "SELECT r.name AS race_name, c.country, r.date FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2017 ORDER BY r.date;",
            "SELECT DISTINCT T2.name, T1.country, T2.date\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T2.year = 2017\nORDER BY T2.date ASC;",
            "SELECT DISTINCT T2.name, T1.country\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T2.year = 2017\nORDER BY T2.date ASC"
        ],
        "question": "List all races in 2017 and the hosting country order by date of the event.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name, T1.country FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2017 ORDER BY T2.date ASC",
        "amends": [
            "Do select `T2.name` and `T1.country` instead of `r.name AS race_name`, `c.country`, and `r.date`. Do use `DISTINCT` instead of omitting it. Do reference tables as `circuits AS T1` and `races AS T2` instead of `races r` and `circuits c`. Do perform `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of `JOIN` on `r.circuitId = c.circuitId`. Do filter on `T2.year = 2017` instead of `r.year = 2017`. Do order by `T2.date ASC` instead of `r.date`. The amended query now correctly returns distinct circuit names with their countries for 2017 races in date order.",
            "Do remove `T2.date` from the SELECT list instead of including it, as the DISTINCT operation should only apply to the combination of race names and countries. Do keep the `INNER JOIN` on `T2.circuitID = T1.circuitId` unchanged. Do maintain the WHERE filter on `T2.year = 2017` unchanged. Do preserve the ORDER BY `T2.date ASC` clause despite removing the column from the SELECT list, as this ordering is still valid and meaningful for the result set. The amended query now correctly returns distinct race names with their corresponding countries for the 2017 season, ordered chronologically by race date, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "987": {
        "sql": [
            "SELECT AVG(fastestLapTime) AS average_fastest_lap_time\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE year = 2006 AND name = 'United States Grand Prix')\nAND position <= 10\nAND fastestLapTime IS NOT NULL;"
        ],
        "question": "What is the average fastest lap time of the top 10 drivers in the 2006 United States Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.fastestLapTime) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank < 11 AND T2.year = 2006 AND T2.name = 'United States Grand Prix'",
        "amends": [],
        "rules": [
            "top 10 refers to rank <11; AVG(fastestLapTime);"
        ]
    },
    "1179": {
        "sql": [
            "SELECT e.\"aCL IgM\"\nFROM Examination e\nJOIN Patient p ON e.ID = p.ID\nWHERE p.Diagnosis = 'SLE' AND p.Description = '1994-02-19' AND e.\"Examination Date\" = '1993-11-12';",
            "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` \nFROM Examination \nWHERE `Examination Date` = '1993-11-12' \nAND ID IN (SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19')"
        ],
        "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` FROM Examination WHERE ID IN ( SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19' ) AND `Examination Date` = '1993-11-12'",
        "amends": [
            "Do select `aCL IgA`, `aCL IgG`, `aCL IgM` instead of only `aCL IgM`. Do use a subquery with `ID IN (SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19')` instead of a direct `JOIN Patient p ON e.ID = p.ID`. Do remove the join to the Patient table and instead filter using the subquery. Do keep the `Examination Date` = '1993-11-12' filter in the WHERE clause. The amended query now correctly retrieves all three antibody types from the Examination table for patients with SLE diagnosis born on 1994-02-19, matching the right SQL's behavior."
        ],
        "rules": [
            "diagnosed with SLE refers to Diagnosis = 'SLE'; 1994/2/19 refers to Description = '1994-02-19'; anti-Cardiolipin refers to aCL IgM; 1993/11/12 refers to Examination Date = '1993/11/12'"
        ]
    },
    "137": {
        "sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS number_of_accounts\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE a.district_id = 1 AND (l.status = 'C' OR l.status = 'D');"
        ],
        "question": "How many accounts have running contracts in Branch location 1?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
        "amends": [],
        "rules": [
            "Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt"
        ]
    },
    "1434": {
        "sql": [
            "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico';"
        ],
        "question": "What are the zip codes that have post office boxes in the country of the country of San Juan Municipio whose state is Puerto Rico?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico'",
        "amends": [],
        "rules": [
            "zip codes that have post office boxes refers to type = 'PO Box'"
        ]
    },
    "302": {
        "sql": [
            "SELECT DISTINCT a1.element, a2.element\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_2_4';",
            "SELECT T1.element \nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id = 'TR001_2_4'"
        ],
        "question": "Name the elements that comprise the atoms of bond TR001_2_4.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_2_4'",
        "amends": [
            "Do select only `T1.element` instead of selecting both `a1.element` and `a2.element`. Do use `INNER JOIN` with `T1.atom_id = T2.atom_id` instead of joining twice with `c.atom_id = a1.atom_id` and `c.atom_id2 = a2.atom_id`. Do remove the second table alias `a2` and the second join condition instead of including them. Do keep the `WHERE` filter on `T2.bond_id` instead of changing it. The amended query now correctly returns only the elements from one side of the connection rather than attempting to return elements from both connected atoms, matching the intended behavior."
        ],
        "rules": [
            "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "717": {
        "sql": [
            "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = '3-D Man';"
        ],
        "question": "Please list all the superpowers of 3-D Man.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = '3-D Man'",
        "amends": [],
        "rules": [
            "3-D Man refers to superhero_name = '3-D Man'; superpowers refers to power_name"
        ]
    },
    "117": {
        "sql": [
            "SELECT (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0 / SUM(amount)) AS percentage_paid_no_issue\nFROM loan;"
        ],
        "question": "What is the percentage of loan amount that has been fully paid with no issue.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
        "amends": [],
        "rules": [
            "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%"
        ]
    },
    "545": {
        "sql": [
            "SELECT COUNT(*) \nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie' AND p.ParentId IS NULL;"
        ],
        "question": "Among the posts owned by csgillespie, how many of them are root posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' AND T1.ParentId IS NULL",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; root post refers to ParentId IS Null"
        ]
    },
    "148": {
        "sql": [
            "SELECT a.account_id\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nJOIN disp dp ON a.account_id = dp.account_id\nWHERE d.A2 = 'Tabor' AND dp.type = 'OWNER';"
        ],
        "question": "Please list the accounts whose district is Tabor that are eligible for loans.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.account_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'OWNER' AND T1.A2 = 'Tabor'",
        "amends": [],
        "rules": [
            "District refers to column A2; when the account type = 'OWNER', it's eligible for loans"
        ]
    },
    "1145": {
        "sql": [
            "SELECT l.name, COUNT(m.id) AS game_count\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2015/2016'\nGROUP BY m.league_id\nORDER BY game_count DESC\nLIMIT 4;",
            "SELECT t1.name\nFROM League AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2015/2016'\nGROUP BY t1.name\nORDER BY COUNT(t2.id) DESC\nLIMIT 4"
        ],
        "question": "Which top 4 leagues had the most games in the 2015-2016 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' GROUP BY t1.name ORDER BY COUNT(t2.id) DESC LIMIT 4",
        "amends": [
            "Do select only `t1.name` instead of including `COUNT(m.id) AS game_count` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `t1` and `t2` instead of simple `JOIN` without aliases. Do join on `t1.id = t2.league_id` instead of `m.league_id = l.id`. Do group by `t1.name` instead of `m.league_id`. Do order by `COUNT(t2.id) DESC` directly instead of ordering by the alias `game_count DESC`. The amended query now correctly aggregates and orders by the count of matches while selecting only the league names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "in the 2015-2016 season refers to season = '2015/2016'; league with most games refers to League.name where MAX(COUNT(id))"
        ]
    },
    "1056": {
        "sql": [
            "SELECT l.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE c.name = 'Netherlands';"
        ],
        "question": "What is the name of the football league in the country of Netherlands?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Netherlands'",
        "amends": [],
        "rules": [
            "name of the football league refers to League.name;"
        ]
    },
    "143": {
        "sql": [
            "SELECT DISTINCT d.account_id\nFROM card c\nJOIN disp d ON c.disp_id = d.disp_id\nWHERE c.type = 'gold';"
        ],
        "question": "What are the accounts that have gold credit cards?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.account_id FROM disp AS T2  INNER JOIN card AS T1 ON T1.disp_id = T2.disp_id  WHERE T1.type = 'gold'",
        "amends": [],
        "rules": []
    },
    "1168": {
        "sql": [
            "SELECT \n    L.Date AS \"Laboratory Work Date\",\n    (strftime('%Y', P.\"First Date\") - strftime('%Y', P.Birthday) AS \"Age at Initial Arrival\"\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.Diagnosis = 'SJS'\n    AND P.Birthday = (SELECT MIN(Birthday) FROM Patient WHERE Diagnosis = 'SJS')\nORDER BY \n    L.Date DESC\nLIMIT 1;",
            "SELECT \n    T1.Date,\n    STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday) AS \"Age at Initial Arrival\"\nFROM \n    Laboratory AS T1\nINNER JOIN \n    Patient AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.Diagnosis = 'SJS' \n    AND T2.Birthday IS NOT NULL\nORDER BY \n    T2.Birthday ASC\nLIMIT 1;",
            "SELECT \n    T1.Date,\n    STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday) AS \"Age at Initial Arrival\",\n    T2.Birthday\nFROM \n    Laboratory AS T1\nINNER JOIN \n    Patient AS T2 ON T1.ID = T2.ID\nWHERE \n    T2.Diagnosis = 'SJS' \n    AND T2.Birthday IS NOT NULL\nORDER BY \n    T2.Birthday ASC\nLIMIT 1;"
        ],
        "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Date, STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday),T2.Birthday FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL ORDER BY T2.Birthday ASC LIMIT 1",
        "amends": [
            "Do use `T1.Date` and `STRFTIME('%Y', T2.\\`First Date\\`) - STRFTIME('%Y', T2.Birthday)` with explicit `T2.Birthday` instead of `L.Date AS \"Laboratory Work Date\"` and `(strftime('%Y', P.\"First Date\") - strftime('%Y', P.Birthday) AS \"Age at Initial Arrival\"`. Do use table aliases `Laboratory AS T1` and `Patient AS T2` instead of `Patient P` and `Laboratory L`. Do use `INNER JOIN` instead of `JOIN` while keeping the same `ON T1.ID = T2.ID` condition. Do add `T2.Birthday IS NOT NULL` filter instead of omitting it. Do change the subquery `(SELECT MIN(Birthday) FROM Patient WHERE Diagnosis = 'SJS')` to a direct `ORDER BY T2.Birthday ASC LIMIT 1` approach instead of the complex subquery comparison. Do remove the `DESC` ordering and use `ASC` instead to get the oldest patient. The amended query now correctly finds the oldest SJS patient with valid birthday data instead of potentially returning incorrect results from the subquery comparison.",
            "Do add `T2.Birthday` to the SELECT list instead of omitting it, as the RIGHT_SQL includes this column explicitly while the WRONG_SQL only calculates the age difference without selecting the actual birthday value used in the ORDER BY clause."
        ],
        "rules": [
            "The larger the birthday value, the younger the person is, and vice versa; 'SJS' refers to diagnosis; (SUBTRACT(year(`First Date`)), year(Birthday)); age of the patients when they initially arrived at the hospital refers to year(Birthday)"
        ]
    },
    "982": {
        "sql": [
            "SELECT COUNT(DISTINCT d.driverId) AS american_drivers_with_puncture\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN status s ON r.statusId = s.statusId\nWHERE d.nationality = 'American' AND s.status = 'Puncture';"
        ],
        "question": "How many American drivers have puncture status.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN results AS T2 on T1.driverId = T2.driverId INNER JOIN status AS T3 on T2.statusId = T3.statusId WHERE T3.status = 'Puncture' AND T1.nationality = 'American'",
        "amends": [],
        "rules": [
            "puncture status refers to status = Puncture;"
        ]
    },
    "1300": {
        "sql": [
            "SELECT e.Diagnosis\nFROM Laboratory l\nJOIN Examination e ON l.ID = e.ID\nWHERE l.TG < 200\nORDER BY l.TG DESC\nLIMIT 1;"
        ],
        "question": "What is the disease name of the patient who has the highest level of triglyceride within the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 ORDER BY T2.TG DESC LIMIT 1",
        "amends": [],
        "rules": [
            "disease name referse to Diagnosis; highest level of triglyceride within the normal range refers to MAX(TG < 200);"
        ]
    },
    "589": {
        "sql": [
            "SELECT Id FROM users ORDER BY Reputation DESC LIMIT 1;"
        ],
        "question": "Which user ID has the highest reputation?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "amends": [],
        "rules": [
            "highest reputation refers to Max(Reputation)"
        ]
    },
    "306": {
        "sql": [
            "SELECT DISTINCT m.molecule_id, m.label, GROUP_CONCAT(DISTINCT a.element) AS elements\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE b.bond_type = '#'\nGROUP BY m.molecule_id, m.label;",
            "SELECT DISTINCT a.molecule_id, a.element\nFROM atom a\nINNER JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nINNER JOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = 'triple'",
            "SELECT T1.molecule_id, T2.element\nFROM bond AS T1\nINNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#'"
        ],
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select only `molecule_id` and `element` instead of including `label` and `GROUP_CONCAT` aggregation. Do join only `bond` and `atom` tables instead of including the unnecessary `molecule` table. Do use `INNER JOIN` between `bond` and `atom` instead of separate joins to `molecule`. Do remove the `GROUP BY` clause and aggregation instead of grouping by multiple columns. Do remove the `DISTINCT` modifier from the main query instead of keeping it since the join already produces unique combinations. Do eliminate the `GROUP_CONCAT` function instead of aggregating elements into a concatenated string. The amended query now correctly identifies atoms in molecules with specific bond types without unnecessary grouping or table references, matching the RIGHT_SQL's behavior.",
            "Do select `T1.molecule_id` and `T2.element` instead of `a.molecule_id` and `a.element`. Do use `bond AS T1` as the primary table instead of `atom a`. Do `INNER JOIN atom AS T2` on `T1.molecule_id = T2.molecule_id` instead of joining through `connected` and `bond` tables with `a.atom_id = c.atom_id OR a.atom_id = c.atom_id2` and `c.bond_id = b.bond_id`. Do filter with `T1.bond_type = '#'` instead of `b.bond_type = 'triple'`. Do remove the unnecessary `connected` table join and the complex join conditions instead of keeping them. The amended query now correctly identifies atoms in molecules with triple bonds by directly joining bond and atom tables on molecule_id."
        ],
        "rules": [
            "triple bond refers to bond_type = '#'; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "368": {
        "sql": [
            "SELECT (COUNT(CASE WHEN borderColor = 'borderless' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_borderless_cards FROM cards;"
        ],
        "question": "What is the percentage of borderless cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "amends": [],
        "rules": [
            "borderless card refers to borderColor = 'borderless'; percentage = Divide(Count (id) where borderColor = 'borderless', Count(id)) *100"
        ]
    },
    "778": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Adaptation';"
        ],
        "question": "Provide superheroes' names who have the adaptation power.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Adaptation'",
        "amends": [],
        "rules": [
            "adaptation power refers to power_name = 'Adaptation';"
        ]
    },
    "381": {
        "sql": [
            "SELECT DISTINCT c.artist\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Chinese Simplified';"
        ],
        "question": "List down the name of artists for cards in Chinese Simplified.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
        "amends": [],
        "rules": [
            "Chinese Simplified' is the language;"
        ]
    },
    "50": {
        "sql": [
            "SELECT s.School, s.Street\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nWHERE sc.AvgScrMath IS NOT NULL\nORDER BY sc.AvgScrMath DESC\nLIMIT 1 OFFSET 6;",
            "SELECT T2.MailStreet, T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 6, 1"
        ],
        "question": "What is the postal street address for the school with the 7th highest Math average? Indicate the school's name.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 6, 1",
        "amends": [
            "Do select `T2.MailStreet` and `T2.School` instead of `s.School` and `s.Street`. Do use `INNER JOIN` with alias `T2` for schools instead of `JOIN` with alias `s`. Do reference `T1.AvgScrMath` in ORDER BY instead of `sc.AvgScrMath`. Do use `LIMIT 6, 1` syntax instead of `LIMIT 1 OFFSET 6`. Do remove the `WHERE sc.AvgScrMath IS NOT NULL` filter instead of keeping it, as the ORDER BY DESC naturally handles NULL values by placing them last. The amended query now correctly retrieves the 7th highest math score school's mailing address and name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Postal street and mailing street are synonyms."
        ]
    },
    "1297": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.`T-CHO` >= 250 AND E.KCT = '-';",
            "SELECT COUNT(T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.`T-CHO` >= 250 AND T3.KCT = '-'"
        ],
        "question": "For the patients whose total cholesterol is higher than normal, how many of them have a negative measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-CHO` >= 250 AND T3.KCT = '-'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID) AS PatientCount` to count all matching rows rather than distinct patient IDs. Do reference tables as `T1`, `T2`, and `T3` with explicit `AS` aliases instead of `P`, `L`, and `E`. Do specify `INNER JOIN` explicitly instead of just `JOIN` for both joins. Do maintain the same join conditions `ON T1.ID = T2.ID` and `ON T1.ID = T3.ID` instead of the original join predicates. Do keep the WHERE filters `T2.T-CHO >= 250` and `T3.KCT = '-'` unchanged. Do remove the column alias `AS PatientCount` instead of keeping it. The amended query now correctly counts all patient records meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "total cholesterol is higher than normal refers to `T-CHO` > = 250; negative measure of degree of coagulation refers to KCT = '-' ;"
        ]
    },
    "513": {
        "sql": [
            "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1;"
        ],
        "question": "Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1",
        "amends": [],
        "rules": [
            "expansion type refers to type where type = 'commander'; totalSetSize: The total number of cards in the set, including promotional and related supplemental products but excluding Alchemy modifications; highest total number of cards refers to MAX(totalSetSize)"
        ]
    },
    "115": {
        "sql": [
            "WITH max_inhabitants_district AS (\n    SELECT district_id\n    FROM district\n    WHERE A3 = 'south Bohemia'\n    ORDER BY A4 DESC\n    LIMIT 1\n),\nclient_counts AS (\n    SELECT \n        COUNT(*) AS total_clients,\n        SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) AS male_clients\n    FROM client\n    WHERE district_id = (SELECT district_id FROM max_inhabitants_district)\n)\nSELECT \n    (male_clients * 100.0 / total_clients) AS male_percentage\nFROM client_counts;"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Percentage of the male clients = DIVIDE(COUNT(male clients), COUNT(clients)) * 100; Male refers to gender = 'M', A3 is the region name. A4 contains the information about inhabitants."
        ]
    },
    "84": {
        "sql": [
            "WITH combined_names AS (\n  SELECT AdmFName1 AS first_name, District FROM schools WHERE AdmFName1 IS NOT NULL\n  UNION ALL\n  SELECT AdmFName2 AS first_name, District FROM schools WHERE AdmFName2 IS NOT NULL\n  UNION ALL\n  SELECT AdmFName3 AS first_name, District FROM schools WHERE AdmFName3 IS NOT NULL\n)\nSELECT first_name, District, COUNT(*) AS name_count\nFROM combined_names\nGROUP BY first_name, District\nORDER BY name_count DESC\nLIMIT 2;",
            "SELECT DISTINCT T1.AdmFName1, T1.District\nFROM schools T1\nINNER JOIN (\n    SELECT admfname1\n    FROM schools\n    WHERE admfname1 IS NOT NULL\n    GROUP BY admfname1\n    ORDER BY COUNT(admfname1) DESC\n    LIMIT 2\n) T2 ON T1.AdmFName1 = T2.admfname1\nWHERE T1.AdmFName1 IS NOT NULL;"
        ],
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "amends": [
            "Do use a `SELECT DISTINCT` with specific columns `T1.AdmFName1` and `T1.District` instead of aggregating counts across multiple name fields. Do use an `INNER JOIN` with a subquery that selects `admfname1` instead of creating a CTE with `UNION ALL` across multiple name columns. Do have the subquery `GROUP BY admfname1` and `ORDER BY COUNT(admfname1) DESC LIMIT 2` to get the top 2 most frequent first names instead of counting occurrences across all name fields and then limiting. Do join on `T1.AdmFName1 = T2.admfname1` to filter to only those records matching the top names instead of processing all non-null names from three different columns. Do remove the explicit column aliasing and CTE structure instead of preserving them. The amended query now correctly identifies the top 2 most frequent first names from the AdmFName1 field and returns their distinct occurrences with district information, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "576": {
        "sql": [
            "SELECT u.DisplayName FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Text = 'thank you user93!';"
        ],
        "question": "Name the user that commented 'thank you user93!'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'thank you user93!'",
        "amends": [],
        "rules": [
            "\"thank you user93\" is the Text of comment; user refers to DisplayName"
        ]
    },
    "1249": {
        "sql": [
            "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.\"U-PRO\" >= 30;"
        ],
        "question": "Please list the disease names of the patients that have a proteinuria level higher than normal.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` >= 30",
        "amends": [],
        "rules": [
            "disease names refers to Diagnosis; proteinuria level higher than normal refers to `U-PRO` > = 30;"
        ]
    },
    "1115": {
        "sql": [
            "WITH \n    donovan_rating AS (\n        SELECT overall_rating\n        FROM Player_Attributes pa\n        JOIN Player p ON pa.player_api_id = p.player_api_id\n        WHERE p.player_name = 'Landon Donovan' AND pa.date = '2013-07-12'\n    ),\n    bowery_rating AS (\n        SELECT overall_rating\n        FROM Player_Attributes pa\n        JOIN Player p ON pa.player_api_id = p.player_api_id\n        WHERE p.player_name = 'Jordan Bowery' AND pa.date = '2013-07-12'\n    )\nSELECT \n    CASE \n        WHEN (SELECT overall_rating FROM donovan_rating) IS NOT NULL AND (SELECT overall_rating FROM bowery_rating) IS NOT NULL\n        THEN ((SELECT overall_rating FROM donovan_rating) - (SELECT overall_rating FROM bowery_rating)) * 100.0 / (SELECT overall_rating FROM donovan_rating)\n        ELSE NULL\n    END AS percentage_higher;",
            "SELECT \n    (SUM(CASE WHEN p.player_name = 'Landon Donovan' THEN pa.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN p.player_name = 'Jordan Bowery' THEN pa.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN p.player_name = 'Landon Donovan' THEN pa.overall_rating ELSE 0 END) AS percentage_higher\nFROM Player p\nJOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id\nWHERE p.player_name IN ('Landon Donovan', 'Jordan Bowery')\nAND SUBSTR(pa.date, 1, 10) = '2013-07-12'"
        ],
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "amends": [
            "Do use a single query with conditional aggregation instead of multiple CTEs and subqueries. Do join on `player_fifa_api_id` instead of `player_api_id` to ensure correct player matching. Do filter with `SUBSTR(t2.date, 1, 10) = '2013-07-12'` instead of exact date matching to handle potential timestamp formats. Do calculate the percentage difference directly using `SUM(CASE...)` expressions for both players instead of separate CTE lookups. Do remove the NULL check condition since the aggregation approach handles missing data inherently. Do use proper arithmetic operations `(sum1 - sum2) * 100 / sum1` instead of the complex subquery structure. The amended query now correctly calculates the percentage difference between Landon Donovan's and Jordan Bowery's ratings on the specified date using proper join conditions and efficient aggregation."
        ],
        "rules": [
            "Landon Donovan's refers to player_name = 'Landon Donovan'; Jordan Bowery refers to player_name = 'Jordan Bowery'; percentage refers to DIVIDE(SUBTRACT(player_name = 'Landon Donovan' overall_rating; player_name = 'Jordan Bowery' overall_rating), player_name = 'Landon Donovan' overall_rating)*100"
        ]
    },
    "578": {
        "sql": [
            "SELECT u.DisplayName, u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Understanding what Dassault iSight is doing?';"
        ],
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "amends": [],
        "rules": [
            "\"Understanding what Dassault iSight is doing?\" is the Title of post; user refers to DisplayName;"
        ]
    },
    "737": {
        "sql": [
            "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.superhero_name = 'Copycat';"
        ],
        "question": "What is Copycat's race?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'Copycat'",
        "amends": [],
        "rules": [
            "Copycat is the superhero_name;"
        ]
    },
    "1064": {
        "sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.preferred_foot = 'left';",
            "SELECT DISTINCT t1.id, t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.preferred_foot = 'left';"
        ],
        "question": "List out of players whose preferred foot is left.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "amends": [
            "Do select `DISTINCT t1.id, t1.player_name` instead of just `p.player_name` to include the player ID and ensure uniqueness. Do use table aliases `t1` and `t2` instead of `p` and `pa` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use `t1.player_api_id = t2.player_api_id` as the join condition instead of `p.player_api_id = pa.player_api_id` with the aliased table names. The amended query now correctly returns distinct player IDs and names for left-footed players, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "preferred_foot = 'left';"
        ]
    },
    "935": {
        "sql": [
            "SELECT COUNT(DISTINCT driverId) \nFROM results \nWHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') \nAND time IS NOT NULL;"
        ],
        "question": "How many drivers managed to finish the race in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Australian Grand Prix' AND T1.year = 2008 AND T2.time IS NOT NULL",
        "amends": [],
        "rules": [
            "managed to finish the race refers to time is not null"
        ]
    },
    "628": {
        "sql": [
            "SELECT DisplayName, Views FROM users ORDER BY Views DESC LIMIT 1;",
            "SELECT Id, DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users)"
        ],
        "question": "Which users have the highest number of views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id, DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "amends": [
            "Do select `Id` and `DisplayName` instead of `DisplayName` and `Views`. Do add a `WHERE` clause with a subquery `SELECT MAX(Views) FROM users` instead of using `ORDER BY Views DESC LIMIT 1`. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly identifies users with maximum views using a subquery rather than relying on ordering and limiting, ensuring all users with the maximum view count are returned rather than just one arbitrary user with high views."
        ],
        "rules": [
            "users have the highest number of views refer to DisplayName where MAX(Views);"
        ]
    },
    "1188": {
        "sql": [
            "SELECT ID FROM Patient WHERE SEX = 'F' AND strftime('%Y', Birthday) = '1964' AND Admission = '+';"
        ],
        "question": "How many female patients born in 1964 were admitted to the hospital? List them by ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT ID FROM Patient WHERE STRFTIME('%Y', Birthday) = '1964' AND SEX = 'F' AND Admission = '+'",
        "amends": [],
        "rules": [
            "female refers to SEX = 'F'; born in 1964 refers to YEAR(Birthday) = 1964; admitted to the hospital refers to Admission = '+'"
        ]
    },
    "1453": {
        "sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.category = 'Parking'\nAND b.spent < (SELECT AVG(spent) FROM budget WHERE category = 'Parking');",
            "SELECT DISTINCT e.event_name\nFROM event e\nINNER JOIN budget b ON e.event_id = b.link_to_event\nINNER JOIN expense T3 ON b.budget_id = T3.link_to_budget\nWHERE b.category = 'Parking'\nAND T3.cost < (SELECT AVG(cost) FROM expense);"
        ],
        "question": "List the name of events with less than average parking cost.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T2.category = 'Parking' AND T3.cost < (SELECT AVG(cost) FROM expense)",
        "amends": [
            "Do add `INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget` instead of omitting the expense table join. Do change the filter to `T3.cost < (SELECT AVG(cost) FROM expense)` instead of `b.spent < (SELECT AVG(spent) FROM budget WHERE category = 'Parking')` to compare against expense costs rather than budget spent amounts. Do remove the `WHERE category = 'Parking'` condition from the subquery instead of keeping it, as the average should be calculated across all expenses. The amended query now correctly filters events based on parking-related expenses below the average expense cost, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "name of events refers to event_name; less than average parking cost refers to cost < DIVIDE(SUM(cost), COUNT(event_id)) where category = 'Parking'"
        ]
    },
    "1269": {
        "sql": [
            "SELECT DISTINCT e.ID\nFROM Examination e\nJOIN Patient p ON e.ID = p.ID\nWHERE e.`Examination Date` > '1997-01-01'\nAND e.SC170 IN ('negative', '0');",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date > '1997-01-01'\nAND T2.SC170 IN ('negative', '0')",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.SC170 IN ('negative','0')\nAND T2.Date > 1997-01-01"
        ],
        "question": "Please list the IDs of the patients who had the examination done after 1997/1/1 and had a normal anti-scl70.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SC170 IN ('negative','0') AND T2.Date > 1997-01-01",
        "amends": [
            "Do select `T1.ID` instead of `e.ID` and remove `DISTINCT` instead of keeping it. Do use `INNER JOIN` on `Laboratory AS T2` with `T1.ID = T2.ID` instead of `JOIN` on `Patient p` with `e.ID = p.ID`. Do filter on `T2.SC170 IN ('negative','0')` and `T2.Date > 1997-01-01` instead of `e.SC170 IN ('negative','0')` and `e.Examination Date > '1997-01-01'`. The amended query now correctly joins Patient with Laboratory table and applies filters to the Laboratory table columns, matching the intended behavior.",
            "Do use unquoted date literal `1997-01-01` instead of quoted `'1997-01-01'` for proper date comparison. Do reorder the WHERE clause predicates to place `T2.SC170 IN ('negative','0')` before `T2.Date > 1997-01-01` instead of the reverse order, though this is functionally equivalent in most SQL engines. The amended query now correctly matches the RIGHT_SQL's behavior with proper date handling and predicate arrangement."
        ],
        "rules": [
            "examination done after 1997/1/1 refers to `Examination Date` >  1997-01-01; normal anti-scl70 refers to SC170 IN('negative','0');"
        ]
    },
    "200": {
        "sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = '#' AND m.label = '+';",
            "SELECT T2.molecule_id\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#' AND T2.label = '+'"
        ],
        "question": "Find the triple-bonded molecules which are carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'",
        "amends": [
            "Do select only `T2.molecule_id` instead of including both `m.molecule_id` and `m.label`. Do use `INNER JOIN` instead of `JOIN` (which are equivalent, but the explicit keyword is preferred). Do use table aliases `T1` and `T2` instead of `b` and `m` for consistency. Do maintain the same join condition `T1.molecule_id = T2.molecule_id` instead of changing it. Do keep the same WHERE filters `T1.bond_type = '#'` and `T2.label = '+'` instead of modifying them. The amended query now correctly returns only molecule IDs that have both the specified bond type and label, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "triple-bonded molecules refers to bond_type = '#'; carcinogenic refers to label = '+'"
        ]
    },
    "627": {
        "sql": [
            "SELECT COUNT(*) AS adult_users_count FROM users WHERE Age BETWEEN 19 AND 65;"
        ],
        "question": "How many users were adult?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "amends": [],
        "rules": [
            "adult refers to user where Age BETWEEN 19 and 65;"
        ]
    },
    "1166": {
        "sql": [
            "SELECT e.Symptoms, e.Diagnosis\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Birthday = (SELECT MAX(Birthday) FROM Patient)\nAND e.Symptoms IS NOT NULL;",
            "SELECT T2.Symptoms, T1.Diagnosis \nFROM Patient T1 \nINNER JOIN Examination T2 ON T1.ID = T2.ID \nWHERE T2.Symptoms IS NOT NULL \nORDER BY T1.Birthday DESC \nLIMIT 1"
        ],
        "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.Symptoms, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Symptoms IS NOT NULL ORDER BY T1.Birthday DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T2.Symptoms` and `T1.Diagnosis` instead of `e.Symptoms` and `e.Diagnosis`. Do use `INNER JOIN` instead of `JOIN` for clarity. Do remove the subquery filter on `p.Birthday` and instead add `ORDER BY T1.Birthday DESC LIMIT 1` to get the most recent patient record instead of filtering by maximum birthday. Do keep the `T2.Symptoms IS NOT NULL` filter but move it to the WHERE clause instead of having it as a separate condition. Do add explicit ordering and limiting instead of relying on subquery comparison for date filtering."
        ],
        "rules": [
            "The larger the birthday value, the younger the person is, and vice versa; symptoms observed refers to the symptoms is not NULL"
        ]
    },
    "702": {
        "sql": [
            "SELECT COUNT(*) FROM posts WHERE Score < 20;"
        ],
        "question": "How many posts have a score less than 20?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score < 20",
        "amends": [],
        "rules": [
            "score less than 20 refers to Score < 20;"
        ]
    },
    "139": {
        "sql": [
            "SELECT COUNT(*) AS high_level_owner_cards\nFROM card\nJOIN disp ON card.disp_id = disp.disp_id\nWHERE card.type = 'gold' AND disp.type = 'OWNER';"
        ],
        "question": "How many high-level credit cards have \"OWNER\" type of disposition?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'OWNER'",
        "amends": [],
        "rules": [
            "High-level credit cards refers to the cards with the gold type."
        ]
    },
    "1104": {
        "sql": [
            "SELECT pa.potential \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Francesco Parravicini' \nAND pa.date = '2010-08-30 00:00:00';"
        ],
        "question": "What was the potiential for Francesco Parravicini on 2010/8/30?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2010-08-30' AND t1.player_name = 'Francesco Parravicini'",
        "amends": [],
        "rules": [
            "Francesco Parravicini refers to player_name = 'Francesco Parravicini'; on 2010/8/30 refers to date = '2010-08-30 00:00:00'"
        ]
    },
    "1439": {
        "sql": [
            "SELECT m.phone\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' AND maj.college = 'College of Agriculture and Applied Sciences';"
        ],
        "question": "Please list the phone numbers of the members who majored in business at the College of Agriculture and Applied Sciences.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T2.major_name = 'Business' AND T2.college = 'College of Agriculture and Applied Sciences'",
        "amends": [],
        "rules": [
            "'College of Agriculture and Applied Sciences' is the college; majored in business refers to major_name = 'Business'; phone numbers refers to phone"
        ]
    },
    "333": {
        "sql": [
            "SELECT COUNT(*) AS carbon_count\nFROM atom\nJOIN molecule ON atom.molecule_id = molecule.molecule_id\nWHERE molecule.molecule_id = 'TR008' AND atom.element = 'c';"
        ],
        "question": "In the molecule TR008, how many carbons are present?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR008' AND T.element = 'c'",
        "amends": [],
        "rules": [
            "carbon refers to element = 'c'"
        ]
    },
    "43": {
        "sql": [
            "SELECT s.AvgScrMath, sc.County\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE (s.AvgScrMath + s.AvgScrRead + s.AvgScrWrite) = (\n    SELECT MIN(AvgScrMath + AvgScrRead + AvgScrWrite)\n    FROM satscores\n);",
            "SELECT T1.AvgScrMath, T2.County\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath IS NOT NULL\nORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC\nLIMIT 1"
        ],
        "question": "What is the average math score of the school with the lowest average score for all subjects, and in which county is it located?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.AvgScrMath, T2.County FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath IS NOT NULL ORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC LIMIT 1",
        "amends": [
            "Do select `T1.AvgScrMath` and `T2.County` with table aliases instead of `s.AvgScrMath` and `sc.County` without explicit aliases. Do use `INNER JOIN` with explicit join type instead of just `JOIN`. Do change the join condition from `s.cds = sc.CDSCode` to `T1.cds = T2.CDSCode` with proper table aliases. Do remove the subquery that finds minimum total score and instead add `WHERE T1.AvgScrMath IS NOT NULL` to filter out null values. Do add `ORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC` to sort by total score ascending instead of using a subquery equality condition. Do add `LIMIT 1` to return only the first row instead of potentially multiple rows with the same minimum total score. The amended query now correctly returns the school with the lowest total SAT score while handling null values and ensuring only one result is returned."
        ],
        "rules": [
            "Average score for all subjects can be computed by AvgScrMath + AvgScrRead + AvgScrWrite"
        ]
    },
    "444": {
        "sql": [
            "SELECT fd.name AS foreign_name, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'boros';",
            "SELECT DISTINCT T1.name, T1.type\nFROM foreign_data AS T1\nINNER JOIN cards AS T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'boros'",
            "SELECT DISTINCT T1.name, T1.type\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'boros'"
        ],
        "question": "Name the foreign name of the card that has boros watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'boros'",
        "amends": [
            "Do use `DISTINCT` to eliminate duplicate rows instead of omitting it. Do reference `T1.name` and `T1.type` with table aliases instead of `fd.name AS foreign_name` and `c.type`. Do use `INNER JOIN` with explicit table aliases `AS T1` and `AS T2` instead of simple `JOIN` without aliases. Do specify the join condition as `T2.uuid = T1.uuid` instead of `c.uuid = fd.uuid`. Do reference the watermark filter with the aliased table `T1.watermark` instead of `c.watermark`. The amended query now correctly returns distinct card names and types with proper table aliasing and join direction.",
            "Do use `cards AS T1` as the primary table instead of `foreign_data AS T1` to correctly establish the table relationships. Do maintain the `INNER JOIN` on `T2.uuid = T1.uuid` but ensure the join direction aligns with the primary table selection. Do keep the `WHERE T1.watermark = 'boros'` filter unchanged as it correctly references the primary table. Do preserve the `SELECT DISTINCT T1.name, T1.type` column selection since the column names remain consistent despite the table role reversal. The amended query now correctly uses cards as the base table while maintaining the same join logic and filtering conditions to match the intended behavior."
        ],
        "rules": []
    },
    "864": {
        "sql": [
            "SELECT COUNT(DISTINCT driverId) AS drivers_finished\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE date = '2015-11-29') AND time IS NOT NULL;"
        ],
        "question": "For the race happened on 2015/11/29, how many drivers finished the game?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "amends": [],
        "rules": [
            "game and race are synonyms; drivers who finished the race should have record in time;"
        ]
    },
    "305": {
        "sql": [
            "SELECT b.bond_id, b.molecule_id, b.bond_type, c.atom_id AS atom1, c.atom_id2 AS atom2, a1.element AS element1, a2.element AS element2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = '-';",
            "SELECT bond.bond_id, connected.atom_id, connected.atom_id2\nFROM bond\nINNER JOIN connected ON bond.bond_id = connected.bond_id\nWHERE bond.bond_type = 'single'",
            "SELECT T1.bond_id, T2.atom_id, T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '-'"
        ],
        "question": "Name all bonds with single bond types and what atoms are connected to the molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_id, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "amends": [
            "Do select only `bond_id`, `atom_id`, and `atom_id2` instead of including additional columns like `molecule_id`, `bond_type`, `element1`, and `element2`. Do use `INNER JOIN` for the connected table instead of multiple joins to atom tables. Do remove the unnecessary joins to `atom a1` and `atom a2` instead of keeping them. Do use table aliases `T1` and `T2` instead of single-letter aliases. The amended query now correctly focuses on bond connectivity data without extraneous element information, matching the RIGHT_SQL's behavior.",
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T1.bond_id` instead of `bond.bond_id` in the SELECT list. Do reference `T2.atom_id` and `T2.atom_id2` instead of `connected.atom_id` and `connected.atom_id2`. Do use table aliases `bond AS T1` and `connected AS T2` instead of unaliased table names. Do filter on `T1.bond_type = '-'` instead of `bond.bond_type = 'single'`. The amended query now correctly matches the RIGHT_SQL's behavior with proper table aliasing and bond type filtering."
        ],
        "rules": [
            "single bond refers to bond_type = '-';"
        ]
    },
    "397": {
        "sql": [
            "SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability LIKE '%paper%' AND availability LIKE '%mtgo%';"
        ],
        "question": "What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT manaCost FROM cards WHERE availability = 'mtgo,paper' AND borderColor = 'black' AND frameVersion = 2003 AND layout = 'normal'",
        "amends": [],
        "rules": [
            "available in paper and mtgo refers to availability = 'mtgo,paper'; frameVersion = 2003;borderColor = 'black'"
        ]
    },
    "268": {
        "sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_10_11';",
            "SELECT T2.element \nFROM connected AS T1 \nINNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id \nWHERE T1.bond_id = 'TR001_10_11'"
        ],
        "question": "What are the elements for bond id TR001_10_11?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
        "amends": [
            "Do select only `T2.element` instead of `a1.element` and `a2.element`. Do use `INNER JOIN` with `atom AS T2` on `T1.atom_id = T2.atom_id` instead of joining two atom tables on `c.atom_id = a1.atom_id` and `c.atom_id2 = a2.atom_id`. Do remove the second join to `atom a2` instead of keeping it. Do use table aliases `T1` for connected and `T2` for atom instead of `c`, `a1`, and `a2`. The amended query now correctly retrieves only the element from the first atom in the connection instead of both connected atoms, matching the intended behavior."
        ],
        "rules": [
            "TR001_10_11 is the bond id;"
        ]
    },
    "1326": {
        "sql": [
            "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Environmental Engineering';"
        ],
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
        "amends": [],
        "rules": [
            "'Environmental Engineering' is the major name"
        ]
    },
    "363": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nJOIN legalities ON cards.uuid = legalities.uuid \nWHERE legalities.status = 'restricted' AND cards.isStarter = 1;",
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1 \nINNER JOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Restricted' \nAND T1.isStarter = 1"
        ],
        "question": "How many cards of legalities whose status is restricted are found in a starter deck?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isStarter = 1",
        "amends": [
            "Do use `COUNT(DISTINCT T1.id)` instead of `COUNT(*)` to count distinct card IDs rather than all rows. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of full table names for better readability. Do reference `T2.status = 'Restricted'` instead of `legalities.status = 'restricted'` to match the exact case-sensitive value. Do maintain the same join condition `T1.uuid = T2.uuid` and filter `T1.isStarter = 1` as in the original query. The amended query now correctly counts distinct restricted starter cards with proper case handling and explicit syntax."
        ],
        "rules": [
            "restricted refers to status = 'restricted'; found in the starter deck refers to isStarter = 1;"
        ]
    },
    "70": {
        "sql": [
            "SELECT StatusType, COUNT(*) AS NumberOfSchools\nFROM schools\nWHERE County = 'Alpine' AND (District LIKE '%Community Day School%' OR School LIKE '%Community Day School%')\nGROUP BY StatusType;",
            "SELECT COUNT(School) FROM schools WHERE County = 'Alpine' AND (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = '69';"
        ],
        "question": "How many active and closed District Community Day Schools are there in the county of Alpine?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69 AND County = 'Alpine'",
        "amends": [
            "Do select `COUNT(School)` instead of `StatusType, COUNT(*) AS NumberOfSchools` and remove the GROUP BY clause entirely. Do change the WHERE filter to include `(StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69` instead of `(District LIKE '%Community Day School%' OR School LIKE '%Community Day School%')` while keeping `County = 'Alpine'`. The amended query now correctly counts schools meeting the specific status and SOC criteria in Alpine County, matching the intended behavior."
        ],
        "rules": []
    },
    "670": {
        "sql": [
            "SELECT MIN(p.CreaionDate) AS FirstPostDate\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.Age = (SELECT MIN(Age) FROM users WHERE Age IS NOT NULL);"
        ],
        "question": "What is the date when the youngest user made his or her first post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "amends": [],
        "rules": [
            "the youngest user refers to MIN(Age); first post refers to MIN(CreaionDate);"
        ]
    },
    "1241": {
        "sql": [
            "SELECT \n    SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END) AS lower_than_normal,\n    SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END) AS higher_than_normal,\n    SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END) AS comparison\nFROM \n    (SELECT DISTINCT ID, PLT FROM Laboratory WHERE PLT <= 100 OR PLT >= 400);",
            "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) AS platelet_difference\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.PLT IS NOT NULL AND (T2.PLT <= 100 OR T2.PLT >= 400)"
        ],
        "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "amends": [
            "Do use `SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END)` as the single expression instead of separate aggregate columns with a subtraction operation. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `Laboratory` table with a subquery. Do remove the `DISTINCT` clause and subquery structure instead of keeping them. Do use inclusive comparisons `<= 100` and `>= 400` instead of exclusive comparisons `< 100` and `> 400` for proper boundary handling. Do eliminate the separate aggregate columns `lower_than_normal` and `higher_than_normal` instead of calculating them individually. The amended query now correctly calculates the difference between low and high platelet counts by joining patient data and using inclusive boundary conditions."
        ],
        "rules": [
            "abnormal platelet level refers to PLT <= 100 or PLT >= 400; platelet level lower than normal range refers to PLT < 100; calculation = SUBTRACT(SUM(PLT < 100), SUM(PLT > 400)); platelet level higher than normal range refers to PLT > 400;"
        ]
    },
    "636": {
        "sql": [
            "SELECT COUNT(*) AS NegativeCommentCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'Neil McGuigan' AND c.Score < 60;"
        ],
        "question": "How many negative comments did Neil McGuigan get in his posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T1.DisplayName = 'Neil McGuigan' AND T3.Score < 60",
        "amends": [],
        "rules": [
            "Negative comment refers to score < 60; DisplayName = 'Neil McGuigan';"
        ]
    },
    "747": {
        "sql": [
            "SELECT COUNT(*) FROM superhero WHERE full_name IS NULL;"
        ],
        "question": "What is the total number of superheroes without full name?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL",
        "amends": [],
        "rules": [
            "superheroes without full name refers to full_name IS NULL"
        ]
    },
    "172": {
        "sql": [
            "SELECT type, COUNT(*) AS count FROM disp WHERE account_id BETWEEN 1 AND 10 GROUP BY type;",
            "SELECT \n    SUM(CASE WHEN type = 'OWNER' THEN 1 ELSE 0 END) AS owner_count,\n    SUM(CASE WHEN type = 'DISPONENT' THEN 1 ELSE 0 END) AS disponent_count\nFROM disp\nWHERE account_id BETWEEN 1 AND 10;"
        ],
        "question": "How many owner and disponent dispositions are there from account number 1 to account number 10?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT SUM(type = 'OWNER') , SUM(type = 'DISPONENT') FROM disp WHERE account_id BETWEEN 1 AND 10",
        "amends": [
            "Do use conditional aggregation with `SUM(type = 'OWNER')` and `SUM(type = 'DISPONENT')` instead of `COUNT(*) AS count` with `GROUP BY type`. Do remove the `GROUP BY type` clause instead of keeping it, as the conditional sums eliminate the need for grouping. Do return two separate aggregate columns instead of a single count column with type grouping. The amended query now correctly counts OWNER and DISPONENT types separately within the specified account_id range, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "869": {
        "sql": [
            "SELECT c.url\nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nWHERE cr.raceId = 9\nORDER BY cr.points DESC\nLIMIT 1;"
        ],
        "question": "For the constructor which got the highest point in the race No. 9 , what is its introduction website?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.url FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 9 ORDER BY T1.points DESC LIMIT 1",
        "amends": [],
        "rules": [
            "race number refers to raceId; constructor which got the highest point refers to MAX(constructorResults.points); introduction website of the constructor refers to url;"
        ]
    },
    "91": {
        "sql": [
            "SELECT \n    AVG(A12) AS avg_unemployment_1995,\n    AVG(A13) AS avg_unemployment_1996,\n    CASE \n        WHEN AVG(A12) > AVG(A13) THEN '1995 has a higher average unemployment rate'\n        WHEN AVG(A12) < AVG(A13) THEN '1996 has a higher average unemployment rate'\n        ELSE 'Both years have the same average unemployment rate'\n    END AS comparison\nFROM district;",
            "SELECT DISTINCT IIF(AVG(CASE WHEN strftime('%Y', date) = '1995' THEN A13 END) > AVG(CASE WHEN strftime('%Y', date) = '1996' THEN A13 END), '1996', '1995') AS higher_year FROM district d JOIN account a ON d.district_id = a.district_id WHERE strftime('%Y', a.date) IN ('1995', '1996')"
        ],
        "question": "The average unemployment ratio of 1995 and 1996, which one has higher percentage?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT IIF(AVG(A13) > AVG(A12), '1996', '1995') FROM district",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to return only unique comparison results. Do use `IIF(AVG(A13) > AVG(A12), '1996', '1995')` instead of a verbose `CASE` statement with multiple branches and redundant text output. Do remove the explicit column aliases `avg_unemployment_1995` and `avg_unemployment_1996` instead of keeping them since they're not needed in the final output. Do simplify the comparison logic to directly return the year with higher unemployment instead of descriptive text phrases. The amended query now correctly returns only distinct year identifiers indicating which year had higher average unemployment, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "A12 refers to unemploymant rate 1995; A13 refers to unemploymant rate 1996"
        ]
    },
    "1507": {
        "sql": [
            "SELECT DISTINCT Time\nFROM transactions_1k\nJOIN gasstations ON transactions_1k.GasStationID = gasstations.GasStationID\nWHERE gasstations.ChainID = 11\nORDER BY Time;"
        ],
        "question": "Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.Time FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11",
        "amends": [],
        "rules": []
    },
    "824": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Wind Control'\nORDER BY s.superhero_name ASC;"
        ],
        "question": "Identify superheroes who can control wind and list their names in alphabetical order.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Wind Control' ORDER BY T1.superhero_name",
        "amends": [],
        "rules": [
            "superheroes refers to superhero_name; can control wind refers to power_name = 'Wind Control';"
        ]
    },
    "815": {
        "sql": [
            "SELECT COUNT(*) AS good_female_superheroes_count\nFROM superhero\nWHERE alignment_id = 1 AND gender_id = 2;"
        ],
        "question": "Count the good female superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Good' AND T3.gender = 'Female'",
        "amends": [],
        "rules": [
            "good refers to alignment.id = 1; female refers to gender.id = 2;"
        ]
    },
    "883": {
        "sql": [
            "SELECT COUNT(*) AS race_count FROM races WHERE year = 2005;\nSELECT name FROM races WHERE year = 2005 ORDER BY name DESC;",
            "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC;"
        ],
        "question": "How many races were there in 2005? Name all the races in descending order.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC",
        "amends": [
            "Do select `name` instead of `COUNT(*) AS race_count` to return individual race names rather than a count aggregate. Do remove the separate `COUNT(*)` query entirely instead of executing two separate queries, consolidating into a single query that returns the actual race names. Do maintain the `WHERE year = 2005` filter and `ORDER BY name DESC` sorting from the second query instead of having inconsistent query structures. The amended query now correctly returns the list of race names for 2005 in descending alphabetical order rather than providing an unnecessary count followed by the actual names."
        ],
        "rules": []
    },
    "234": {
        "sql": [
            "SELECT COUNT(*) AS bond_count\nFROM connected\nWHERE (atom_id = 'TR009_12' OR atom_id2 = 'TR009_12')\nAND bond_id IN (SELECT bond_id FROM bond WHERE molecule_id = 'TR009');",
            "SELECT COUNT(T2.bond_id) \nFROM bond AS T1 \nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id \nWHERE T1.molecule_id = 'TR009' \nAND (T2.atom_id = T1.molecule_id || '_12' OR T2.atom_id2 = T1.molecule_id || '_12')",
            "SELECT COUNT(T2.bond_id) \nFROM bond AS T1 \nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id \nWHERE T1.molecule_id = 'TR009' \nAND T2.atom_id = T1.molecule_id || '_1' \nAND T2.atom_id2 = T1.molecule_id || '_2'"
        ],
        "question": "How many bonds which involved atom 12 does molecule TR009 have?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2'",
        "amends": [
            "Do use an `INNER JOIN` between `bond AS T1` and `connected AS T2` on `T1.bond_id = T2.bond_id` instead of querying `connected` alone with a subquery. Do add explicit table aliases `T1` and `T2` instead of using unqualified column references. Do change the filter to `T1.molecule_id = 'TR009'` instead of using a subquery for bond filtering. Do add specific atom_id conditions `T2.atom_id = T1.molecule_id || '_1'` and `T2.atom_id2 = T1.molecule_id || '_2'` instead of the generic `atom_id = 'TR009_12' OR atom_id2 = 'TR009_12'`. Do count `T2.bond_id` specifically instead of using `COUNT(*)`. Do remove the `AS bond_count` alias instead of keeping it. The amended query now correctly joins the tables and uses precise atom identifier patterns based on the molecule_id, matching the RIGHT_SQL's behavior.",
            "Do change the WHERE condition from `T2.atom_id = T1.molecule_id || '_12' OR T2.atom_id2 = T1.molecule_id || '_12'` to `T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2'` instead of using an OR operator with the same suffix pattern, which now properly filters for two distinct atom identifiers rather than looking for the same atom ID in both positions. The amended query now correctly matches the RIGHT_SQL's behavior by requiring both atom_id and atom_id2 to match specific patterns simultaneously."
        ],
        "rules": [
            "TR009 is the molecule id;  involved atom 12 refers to atom_id = 'TR009_12' or atom_id2 = 'TR009_12'"
        ]
    },
    "20": {
        "sql": [
            "SELECT COUNT(DISTINCT CDSCode) \nFROM frpm \nWHERE `County Name` = 'Amador' \nAND `Low Grade` = '9' \nAND `High Grade` = '12';"
        ],
        "question": "How many schools in Amador which the Low Grade is 9 and the High Grade is 12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.`School Name`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Amador' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12",
        "amends": [],
        "rules": []
    },
    "931": {
        "sql": [
            "SELECT MAX(r.fastestLapSpeed) AS fastest_lap_speed\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 2009 AND rc.name = 'Spanish Grand Prix';"
        ],
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the fastest lap speed among all refers to max(fastestLapSpeed); Spanish Grand Prix refers to races.name = 'Spanish Grand Prix';"
        ]
    },
    "1126": {
        "sql": [
            "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Match m ON p.player_api_id IN (\n    m.home_player_1, m.home_player_2, m.home_player_3, m.home_player_4, m.home_player_5,\n    m.home_player_6, m.home_player_7, m.home_player_8, m.home_player_9, m.home_player_10, m.home_player_11,\n    m.away_player_1, m.away_player_2, m.away_player_3, m.away_player_4, m.away_player_5,\n    m.away_player_6, m.away_player_7, m.away_player_8, m.away_player_9, m.away_player_10, m.away_player_11\n)\nJOIN League l ON m.league_id = l.id\nJOIN Country c ON l.country_id = c.id\nWHERE c.name = 'Belgium';",
            "SELECT DISTINCT p.player_name\nFROM Player p\nINNER JOIN Match m ON p.player_api_id = m.home_player_1\nINNER JOIN Country c ON m.country_id = c.id\nWHERE c.name = 'Belgium'"
        ],
        "question": "State the name of players who came from Belgium.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Belgium'",
        "amends": [
            "Do use `INNER JOIN` on `t1.id = t2.country_id` instead of joining through `League` and `Country` tables with separate joins. Do join `Player` directly on `t2.home_player_1 = t3.player_api_id` instead of checking against all 22 player position columns. Do remove the `DISTINCT` modifier instead of keeping it since the direct join eliminates duplicates. Do simplify the `WHERE` clause to filter directly on `t1.name = 'Belgium'` instead of the multi-table join approach. The amended query now correctly identifies players who were the home player 1 in matches from Belgium, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "name of players refers to player_name; Belgium is name of country"
        ]
    },
    "1113": {
        "sql": [
            "SELECT ta.defenceAggressionClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'Hannover 96' \nAND ta.date LIKE '2015-09-10%';",
            "SELECT t2.chanceCreationShootingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Hannover 96' \nAND t2.`date` LIKE '2015-09-10%'"
        ],
        "question": "For the team \"Hannover 96\", what was its defence aggression class on 2015/9/10?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.chanceCreationShootingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hannover 96' AND t2.`date` LIKE '2015-09-10%'",
        "amends": [
            "Do select `chanceCreationShootingClass` instead of `defenceAggressionClass` from the Team_Attributes table. Do use table aliases `t1` for Team and `t2` for Team_Attributes instead of `t` and `ta` respectively. Do specify `INNER JOIN` explicitly instead of just `JOIN` while maintaining the same join condition `t1.team_api_id = t2.team_api_id`. Do reference the date column as `t2.date` with backticks instead of `ta.date` while keeping the same filter condition `LIKE '2015-09-10%'`. The amended query now correctly retrieves the chance creation shooting class instead of defence aggression class for Hannover 96 on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "\"Hannover 96\" refers to team_long_name = 'Hannover 96'; on 2015/9/10 refers to date LIKE '2015-09-10%';"
        ]
    },
    "754": {
        "sql": [
            "SELECT sp.power_name \nFROM superhero sh \nJOIN hero_power hp ON sh.id = hp.hero_id \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE sh.id = 56;"
        ],
        "question": "What is the superpower of hero ID 56?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 56",
        "amends": [],
        "rules": [
            "superpower refers to hero_power"
        ]
    },
    "738": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Durability' AND ha.attribute_value < 50;"
        ],
        "question": "Which superheroes have a durability attribute value of less than 50?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "amends": [],
        "rules": [
            "durability of less than 50 refers to attribute_name = 'Durability' AND attribute_value < 50"
        ]
    },
    "1222": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.CRE >= 1.5;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.CRE >= 1.5 AND T1.SEX = 'M'"
        ],
        "question": "How many male patients are are with creatinine index out of the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching records rather than unique patients. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T2.CRE >= 1.5` condition before `T1.SEX = 'M'` in the WHERE clause instead of the reverse order, though this is functionally equivalent. The amended query now correctly counts all laboratory records meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "creatinine (CRE) out of the normal range refers to CRE > = 1.5; Male refers to Sex = 'M'"
        ]
    },
    "649": {
        "sql": [
            "SELECT \n    COUNT(ph.Id) AS post_history_count,\n    MAX(ph.CreationDate) AS last_edit_date\nFROM \n    posts p\nJOIN \n    postHistory ph ON p.Id = ph.PostId\nWHERE \n    p.Title = 'What is the best introductory Bayesian statistics textbook?'\nGROUP BY \n    p.Id;",
            "SELECT T1.Id, T2.LastEditDate \nFROM postHistory AS T1 \nINNER JOIN posts AS T2 ON T1.PostId = T2.Id \nWHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'"
        ],
        "question": "Describe the post history counts and last edit date of the post title \"What is the best introductory Bayesian statistics textbook?\"",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Id, T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'",
        "amends": [
            "Do select `T1.Id` and `T2.LastEditDate` instead of aggregating with `COUNT(ph.Id)` and `MAX(ph.CreationDate)`. Do use `INNER JOIN` with `T1.PostId = T2.Id` instead of `JOIN` with `p.Id = ph.PostId`. Do move the filter to `WHERE T2.Title` instead of `WHERE p.Title`. Do remove the `GROUP BY p.Id` clause instead of keeping it. Do reference tables as `postHistory AS T1` and `posts AS T2` instead of `posts p` and `postHistory ph`. The amended query now correctly retrieves individual post history records with their last edit dates instead of aggregating counts and maximum dates per post."
        ],
        "rules": []
    },
    "607": {
        "sql": [
            "SELECT COUNT(*) AS positive_comments_count FROM comments WHERE Score > 60;"
        ],
        "question": "How many positive comments are there on the list?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM comments WHERE score > 60",
        "amends": [],
        "rules": [
            "Positive comment refers to score > 60"
        ]
    },
    "291": {
        "sql": [
            "SELECT COUNT(*) FROM molecule WHERE label = '+';"
        ],
        "question": "How many chemical compounds in the database are identified as carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "665": {
        "sql": [
            "WITH monthly_links AS (\n    SELECT \n        strftime('%m', pl.CreationDate) AS month,\n        COUNT(pl.Id) AS link_count\n    FROM \n        postLinks pl\n    JOIN \n        posts p ON pl.PostId = p.Id\n    WHERE \n        strftime('%Y', pl.CreationDate) = '2010'\n        AND p.AnswerCount <= 2\n    GROUP BY \n        month\n)\nSELECT \n    AVG(link_count) AS average_monthly_links\nFROM \n    monthly_links;",
            "SELECT CAST(COUNT(*) AS REAL) / 12 AS average_monthly_links\nFROM postLinks T1\nJOIN posts T2 ON T1.PostId = T2.Id\nWHERE strftime('%Y', T1.CreationDate) = '2010'\nAND T2.AnswerCount <= 2;"
        ],
        "question": "What is the average monthly number of links created in 2010 for posts that have no more than 2 answers?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / 12 FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.AnswerCount <= 2 AND STRFTIME('%Y', T1.CreationDate) = '2010'",
        "amends": [
            "Do calculate the average by dividing the total count by 12 instead of using AVG on monthly counts. Do use a direct SELECT with division instead of a CTE with monthly aggregation. Do include the join condition `T1.PostId = T2.Id` instead of potentially incorrect join logic. Do apply the filter `T2.AnswerCount <= 2` directly in the WHERE clause instead of within the CTE. Do use CAST to ensure real number division instead of integer division. Do remove the month extraction and grouping since only the annual average is needed. The amended query now correctly calculates the average monthly links by dividing the total annual count by 12, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "calculation = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2010 and AnswerCount < = 2), 12)"
        ]
    },
    "537": {
        "sql": [
            "SELECT COUNT(*) AS post_count\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');"
        ],
        "question": "How many posts does the user csgillespie own?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user"
        ]
    },
    "509": {
        "sql": [
            "SELECT s.id\nFROM sets s\nJOIN (\n    SELECT setCode, COUNT(*) AS card_count\n    FROM cards\n    GROUP BY setCode\n) c ON s.code = c.setCode\nORDER BY c.card_count DESC\nLIMIT 1;"
        ],
        "question": "What is the unique id of the set that has the highest number of cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM sets ORDER BY baseSetSize DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the highest number of cards refers to MAX(baseSetSize); unique id refers to id"
        ]
    },
    "221": {
        "sql": [
            "SELECT a1.atom_id AS atom1, a2.atom_id AS atom2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_2_6' AND a1.molecule_id = 'TR001' AND a2.molecule_id = 'TR001';",
            "SELECT \n  SUBSTR(T.bond_id, 1, 7) AS atom_id1,\n  T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2\nFROM \n  bond T\nWHERE \n  T.molecule_id = 'TR001' \n  AND T.bond_id = 'TR001_2_6'"
        ],
        "question": "What are the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1 , T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'",
        "amends": [
            "Do use `SUBSTR(T.bond_id, 1, 7)` and `T.molecule_id || SUBSTR(T.bond_id, 8, 2)` in the SELECT list instead of joining to the `atom` table to get `a1.atom_id` and `a2.atom_id`. Do query from the `bond` table as `T` instead of joining `connected c` with `atom a1` and `atom a2`. Do remove the JOIN conditions `c.atom_id = a1.atom_id` and `c.atom_id2 = a2.atom_id` instead of keeping them. Do keep the filter `T.molecule_id = 'TR001'` and `T.bond_id = 'TR001_2_6'` in the WHERE clause instead of the previous complex join-based approach. The amended query now correctly extracts atom identifiers directly from the bond_id field structure rather than relying on potentially incorrect table joins, matching the intended behavior."
        ],
        "rules": [
            "TR001 is the molecule id; TR001_2_6 is the bond id"
        ]
    },
    "365": {
        "sql": [
            "SELECT type FROM cards WHERE name = 'Benalish Knight';"
        ],
        "question": "What is the type of card \"Benalish Knight\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "amends": [],
        "rules": [
            "Benalish Knight' is the name of card;"
        ]
    },
    "1392": {
        "sql": [
            "SELECT source, SUM(amount) AS total_amount\nFROM income\nWHERE date_received BETWEEN '2019-09-01' AND '2019-09-30'\nGROUP BY source\nORDER BY total_amount DESC\nLIMIT 1;",
            "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' ORDER BY source DESC LIMIT 1;"
        ],
        "question": "Indicate the top source of funds received in September 2019 based on their amount.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' and '2019-09-30' ORDER BY source DESC LIMIT 1",
        "amends": [
            "Do remove `SUM(amount) AS total_amount` and the `GROUP BY source` clause instead of including aggregation. Do change the `ORDER BY` to use `source DESC` instead of `total_amount DESC`. Do keep the `WHERE` filter on `date_received BETWEEN '2019-09-01' AND '2019-09-30'` and `LIMIT 1` unchanged. The amended query now correctly selects individual source values without aggregation and orders them alphabetically in descending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "top source funds refers to MAX(source); September 2019 means date_received BETWEEN '2019-09-01' and '2019-09-30'"
        ]
    },
    "111": {
        "sql": [
            "SELECT COUNT(*) \nFROM account \nJOIN district ON account.district_id = district.district_id \nWHERE district.A2 = 'Litomerice' \nAND strftime('%Y', account.date) = '1996';"
        ],
        "question": "How many accounts were opened in Litomerice in 1996?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1996' AND T1.A2 = 'Litomerice'",
        "amends": [],
        "rules": [
            "A2 refers to district name; Litomerice is one of district names."
        ]
    },
    "231": {
        "sql": [
            "WITH bond_counts AS (\n  SELECT bond_type, COUNT(*) AS count\n  FROM bond\n  WHERE molecule_id = 'TR010'\n  GROUP BY bond_type\n)\nSELECT \n  (SELECT bond_type FROM bond_counts ORDER BY count DESC LIMIT 1) AS majority_bond_type,\n  (SELECT label FROM molecule WHERE molecule_id = 'TR010') AS molecule_label;",
            "SELECT \n    T.bond_type,\n    (SELECT m.label FROM molecule m WHERE m.molecule_id = 'TR010') AS is_carcinogenic\nFROM \n    (SELECT \n        b.bond_type,\n        COUNT(b.molecule_id) AS bond_count\n     FROM \n        bond b\n     WHERE \n        b.molecule_id = 'TR010'\n     GROUP BY \n        b.bond_type\n     ORDER BY \n        COUNT(b.molecule_id) DESC\n     LIMIT 1) T",
            "SELECT T.bond_type\nFROM (\n    SELECT T1.bond_type, COUNT(T1.molecule_id) AS bond_count\n    FROM bond T1\n    WHERE T1.molecule_id = 'TR010'\n    GROUP BY T1.bond_type\n    ORDER BY COUNT(T1.molecule_id) DESC\n) AS T\nLIMIT 1"
        ],
        "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do use a subquery with explicit column selection `T.bond_type` instead of a CTE with multiple scalar subqueries. Do include `COUNT(T1.molecule_id)` in the subquery instead of `COUNT(*)` for more precise counting. Do add `ORDER BY COUNT(T1.molecule_id) DESC` to properly sort by bond frequency instead of relying on implicit ordering. Do remove the unnecessary molecule label retrieval and CTE structure instead of maintaining them. Do reference the bond table with alias `T1` instead of without aliases. The amended query now correctly identifies the majority bond type by frequency count and matches the RIGHT_SQL's behavior.",
            "Do remove the subquery `(SELECT m.label FROM molecule m WHERE m.molecule_id = 'TR010') AS is_carcinogenic` from the SELECT list instead of including it, as this subquery is unnecessary for the query's purpose of finding the most common bond type. Do change the alias from `b` to `T1` in the subquery instead of using `b` for consistency with the outer query structure. Do remove the alias `bond_count` from the COUNT aggregation instead of keeping it, since the outer query doesn't reference this alias. Do add the `AS` keyword before the alias `T` in the subquery instead of omitting it for proper SQL syntax. The amended query now correctly focuses on retrieving only the bond_type from the most frequent bond type for molecule 'TR010', matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "TR010 is the molecule id; majority of the bond found refers to MAX(COUNT(bond_type)); "
        ]
    },
    "1141": {
        "sql": [
            "SELECT t.team_long_name, ta.buildUpPlaySpeedClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_long_name = 'KSV Cercle Brugge';",
            "SELECT DISTINCT t1.buildUpPlaySpeedClass \nFROM Team_Attributes AS t1 \nINNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t2.team_long_name = 'KSV Cercle Brugge';"
        ],
        "question": "Does the KSV Cercle Brugge team have a slow, balanced or fast speed class?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.buildUpPlaySpeedClass FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.team_long_name = 'KSV Cercle Brugge'",
        "amends": [
            "Do select `t1.buildUpPlaySpeedClass` instead of `t.team_long_name, ta.buildUpPlaySpeedClass`. Do use `DISTINCT` instead of omitting it. Do reference `Team_Attributes AS t1` instead of `Team_Attributes ta` and `Team AS t2` instead of `Team t`. Do use `INNER JOIN` with `t1.team_api_id = t2.team_api_id` instead of `JOIN` with `t.team_api_id = ta.team_api_id`. Do filter on `t2.team_long_name` instead of `t.team_long_name`. The amended query now correctly retrieves distinct build-up play speed classes for the specified team."
        ],
        "rules": [
            "KSV Cercle Brugge refers to team_long_name = 'KSV Cercle Brugge'; speed class refers to buildUpPlaySpeedClass"
        ]
    },
    "1359": {
        "sql": [
            "WITH yearly_kickoff AS (\n    SELECT SUM(amount) AS total_amount\n    FROM budget\n    WHERE category = 'Advertisement'\n    AND link_to_event IN (SELECT event_id FROM event WHERE event_name = 'Yearly Kickoff')\n),\noctober_meeting AS (\n    SELECT SUM(amount) AS total_amount\n    FROM budget\n    WHERE category = 'Advertisement'\n    AND link_to_event IN (SELECT event_id FROM event WHERE event_name = 'October Meeting')\n)\nSELECT COUNT(*) AS count_more\nFROM yearly_kickoff, october_meeting\nWHERE yearly_kickoff.total_amount > october_meeting.total_amount;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / \n    CAST(SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) AS REAL) AS budget_ratio\nFROM budget T1\nINNER JOIN event T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Advertisement' \nAND T2.type = 'Meeting'\nAND T2.event_name IN ('Yearly Kickoff', 'October Meeting')"
        ],
        "question": "How many times was the budget in Advertisement for \"Yearly Kickoff\" meeting more than \"October Meeting\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs and cross join comparison. Do add explicit `INNER JOIN` on `T1.link_to_event = T2.event_id` instead of using subqueries in the WHERE clause. Do include `T2.type = 'Meeting'` filter instead of omitting it. Do calculate a ratio using `CAST(SUM(CASE...)/SUM(CASE...) AS REAL)` instead of counting occurrences where one total exceeds another. Do remove the cross join between CTEs and the COUNT(*) comparison logic instead of keeping that structure. The amended query now correctly calculates the ratio of advertisement spending between the two specific meeting events rather than just counting if one total is greater than the other."
        ],
        "rules": [
            "budget in Advertisement refer to category = 'Advertisement' in the budget table; DIVIDE(SUM(amount when event_name = 'Yearly Kickoff'), SUM(amount when event_name = 'October Meeting'))"
        ]
    },
    "1429": {
        "sql": [
            "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nWHERE m.position = 'Vice President'\nAND e.type = 'Social'\nAND e.location = '900 E. Washington St.';"
        ],
        "question": "What is the name of the social event that was attended by the vice president of the Student_Club located at 900 E. Washington St.?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T3.position = 'Vice President' AND T2.location = '900 E. Washington St.' AND T2.type = 'Social'",
        "amends": [],
        "rules": [
            "name of social event refers to event_name where type = 'Social'; 'Vice President' is position; located at refers to location"
        ]
    },
    "136": {
        "sql": [
            "SELECT COUNT(*) AS loan_count\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nWHERE a.frequency = 'POPLATEK MESICNE'\nAND l.date BETWEEN '1995-01-01' AND '1997-12-31'\nAND l.amount >= 250000\nAND l.status = 'approved';",
            "SELECT COUNT(T1.account_id) \nFROM account T1 \nJOIN loan T2 ON T1.account_id = T2.account_id \nWHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' \nAND T2.amount >= 250000 \nAND T1.frequency = 'monthly statement issuance'",
            "SELECT COUNT(T1.account_id)\nFROM account T1\nINNER JOIN loan T2 ON T1.account_id = T2.account_id\nWHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31'\nAND T2.amount >= 250000\nAND T1.frequency = 'POPLATEK MESICNE'"
        ],
        "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
        "amends": [
            "Do count `T1.account_id` instead of `COUNT(*)` to ensure accurate counting of specific account relationships. Do use table aliases `T1` and `T2` instead of `a` and `l` for consistency. Do remove the `AND l.status = 'approved'` filter instead of keeping it, as the right query does not include this status condition. Do remove the `AS loan_count` alias instead of including it since the right query returns an unnamed count. The amended query now correctly matches the RIGHT_SQL's behavior by focusing on the account relationships and date/amount/frequency conditions without the additional status filter.",
            "Do use the exact string literal `'POPLATEK MESICNE'` for the frequency filter instead of `'monthly statement issuance'` to match the correct data values. Do maintain the same join condition `T1.account_id = T2.account_id` with an explicit `INNER JOIN` instead of just `JOIN` for clarity. Do keep all other elements including the `COUNT` aggregate on `T1.account_id`, the date range filter on `T2.date`, and the amount filter `T2.amount >= 250000` unchanged. The amended query now correctly filters by the proper frequency value while preserving the original join logic and filtering conditions."
        ],
        "rules": [
            "Frequency = 'POPLATEK MESICNE' stands for monthly issurance"
        ]
    },
    "817": {
        "sql": [
            "SELECT r.race\nFROM superhero s\nJOIN colour c_hair ON s.hair_colour_id = c_hair.id\nJOIN gender g ON s.gender_id = g.id\nJOIN race r ON s.race_id = r.id\nWHERE c_hair.colour = 'blue' AND g.gender = 'male';",
            "SELECT T3.race\nFROM superhero T1\nINNER JOIN colour T2 ON T1.hair_colour_id = T2.id\nINNER JOIN race T3 ON T1.race_id = T3.id\nINNER JOIN gender T4 ON T1.gender_id = T4.id\nWHERE T2.colour = 'Blue' AND T4.gender = 'Male'"
        ],
        "question": "Give the race of the blue-haired male superhero.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T2.colour = 'Blue' AND T4.gender = 'Male'",
        "amends": [
            "Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of `s`, `c_hair`, `r`, and `g`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do change the join order to `colour`, `race`, then `gender` instead of `colour`, `gender`, then `race`. Do capitalize filter values `'Blue'` and `'Male'` instead of lowercase `'blue'` and `'male'`. The amended query now correctly matches the RIGHT_SQL's behavior with proper table aliasing, explicit join types, optimized join order, and case-sensitive value matching."
        ],
        "rules": [
            "blue-haired refers to colour.colour = 'blue' WHERE hair_colour_id = colour.id; male refers to gender = 'male';"
        ]
    },
    "1451": {
        "sql": [
            "WITH member_event_count AS (\n    SELECT \n        e.link_to_member,\n        COUNT(DISTINCT b.link_to_event) AS event_count\n    FROM \n        expense e\n    JOIN \n        budget b ON e.link_to_budget = b.budget_id\n    GROUP BY \n        e.link_to_member\n    HAVING \n        COUNT(DISTINCT b.link_to_event) > 1\n),\nmember_total_expense AS (\n    SELECT \n        e.link_to_member,\n        SUM(e.cost) AS total_spent\n    FROM \n        expense e\n    JOIN \n        member_event_count mec ON e.link_to_member = mec.link_to_member\n    GROUP BY \n        e.link_to_member\n)\nSELECT \n    m.first_name,\n    m.last_name,\n    mte.total_spent\nFROM \n    member_total_expense mte\nJOIN \n    member m ON mte.link_to_member = m.member_id\nORDER BY \n    mte.total_spent DESC\nLIMIT 1;",
            "SELECT T2.member_id\nFROM expense T1\nJOIN member T2 ON T1.link_to_member = T2.member_id\nJOIN budget T3 ON T1.link_to_budget = T3.budget_id\nJOIN event T4 ON T3.link_to_event = T4.event_id\nGROUP BY T2.member_id\nHAVING COUNT(DISTINCT T4.event_id) > 1\nORDER BY SUM(T1.cost) DESC\nLIMIT 1"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "Among the members who incurred expenses in more than one event, who paid the most amount?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.member_id FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY T2.member_id HAVING COUNT(DISTINCT T4.event_id) > 1 ORDER BY SUM(T1.cost) DESC LIMIT 1",
        "amends": [
            "Do select only `T2.member_id` instead of multiple columns like `m.first_name`, `m.last_name`, and `mte.total_spent`. Do use direct joins from `expense` to `member`, `budget`, and `event` tables instead of using CTEs with intermediate aggregations. Do apply the `HAVING COUNT(DISTINCT T4.event_id) > 1` filter directly in the main query instead of in a separate CTE. Do order by `SUM(T1.cost) DESC` instead of ordering by the pre-aggregated `total_spent` from a CTE. Do remove the complex CTE structure with `member_event_count` and `member_total_expense` instead of maintaining multiple subqueries. The amended query now correctly identifies members who attended more than one event by directly counting distinct event IDs and ordering by their total expenses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "paid the most amount refers to for expense incurred in more than one event refers to MAX(cost where COUNT(event_id) > 1)"
        ]
    },
    "1022": {
        "sql": [
            "SELECT preferred_foot \nFROM Player_Attributes \nWHERE potential = (SELECT MIN(potential) FROM Player_Attributes);"
        ],
        "question": "What is the preferred foot when attacking of the player with the lowest potential?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT preferred_foot FROM Player_Attributes WHERE potential IS NOT NULL ORDER BY potential ASC LIMIT 1",
        "amends": [],
        "rules": [
            "preferred foot when attacking refers to preferred_foot; lowest potential refers to MIN(potential);"
        ]
    },
    "1069": {
        "sql": [
            "SELECT player_name, MIN(height) AS shortest_height FROM Player;",
            "SELECT player_name FROM Player ORDER BY height ASC LIMIT 1;"
        ],
        "question": "Which football player has the shortest height?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM player ORDER BY height ASC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `MIN(height)` with an alias. Do remove the `MIN(height)` aggregate function instead of keeping it since we're finding the player with minimum height rather than aggregating. Do add `ORDER BY height ASC` to sort by height ascending instead of omitting ordering. Do add `LIMIT 1` to return only the top row instead of omitting row limiting. Do remove the `FROM Player` table reference capitalization instead of using uppercase table name. The amended query now correctly identifies the single player with the minimum height by sorting and limiting rather than using aggregation which would return all players with their individual heights."
        ],
        "rules": [
            "shortest height refers to MIN(height);"
        ]
    },
    "459": {
        "sql": [
            "SELECT name, convertedManaCost FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC;",
            "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1;"
        ],
        "question": "Which card costs more converted mana, \"Serra Angel\" or \"Shrine Keeper\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1",
        "amends": [
            "Do remove `convertedManaCost` from the SELECT list instead of including it, and do add `LIMIT 1` to the ORDER BY clause instead of omitting it, which restricts the result to only the highest convertedManaCost record among the specified cards. The amended query now matches RIGHT_SQL's behavior by returning just the name of the card with the highest converted mana cost from the given list."
        ],
        "rules": [
            "\"Serra Angel\" refers to name = 'Serra Angel'; \"Shrine Keeper\" refers to name = 'Shrine Keeper'; card costs more converted mana when the value of convertedManaCost is greater"
        ]
    },
    "1463": {
        "sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.category = 'Food';"
        ],
        "question": "List the event names which were budgeted for the food.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Food'",
        "amends": [],
        "rules": [
            "budgeted for food refers to category = 'Food'"
        ]
    },
    "713": {
        "sql": [
            "SELECT u.UpVotes\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text = 'R is also lazy evaluated.';"
        ],
        "question": "What is the up vote number of the user that commented \"R is also lazy evaluated.\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'R is also lazy evaluated.'",
        "amends": [],
        "rules": [
            "commented \"R is also lazy evaluated.\" refers to Text of the comment;"
        ]
    },
    "1199": {
        "sql": [
            "SELECT COUNT(DISTINCT ID) \nFROM Laboratory \nWHERE strftime('%Y', Date) = '1997' \nAND (TP < 6 OR TP > 8.5);",
            "SELECT COUNT(ID) \nFROM Laboratory \nWHERE Date LIKE '1997%' \nAND (ALB <= 6.0 OR ALB >= 8.5)"
        ],
        "question": "How many patients who underwent testing in 1997 had protein levels outside the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(ID) FROM Laboratory WHERE (ALB <= 6.0 OR ALB >= 8.5) AND STRFTIME('%Y', Date) = '1997'",
        "amends": [
            "Do use `COUNT(ID)` instead of `COUNT(DISTINCT ID)` to count all records rather than distinct values. Do reference column `ALB` instead of `TP` for the albumin measurements. Do use comparison operators `<= 6.0` and `>= 8.5` instead of `< 6` and `> 8.5` to include the boundary values. Do place the albumin condition first with parentheses `(ALB <= 6.0 OR ALB >= 8.5)` instead of the year condition for logical grouping. The amended query now correctly counts all laboratory records from 1997 where albumin levels are outside the normal range of 6.0 to 8.5, inclusive of the boundary values."
        ],
        "rules": [
            "underwent testing in 1997 refers to YEAR(DATE) = '1997'; protein levels within the normal range refers to tp > 6 and tp < 8.5"
        ]
    },
    "1147": {
        "sql": [
            "SELECT p.player_name, pa.overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;",
            "SELECT DISTINCT t2.player_name\nFROM Player_Attributes t1\nINNER JOIN Player t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)"
        ],
        "question": "Please name one player whose overall strength is the greatest.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = ( SELECT MAX(overall_rating) FROM Player_Attributes)",
        "amends": [
            "Do select only `player_name` instead of including `overall_rating` in the SELECT list. Do use `DISTINCT` to eliminate duplicate player names instead of potentially returning multiple identical records. Do use table aliases `t1` and `t2` instead of full table names for clarity. Do use `INNER JOIN` with explicit table aliases instead of simple JOIN syntax. Do add a WHERE clause filtering for `overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)` instead of relying on ORDER BY and LIMIT which could miss players tied for the highest rating. Do remove the ORDER BY and LIMIT clauses entirely instead of using them to find maximum values, as the subquery approach correctly handles ties by returning all players with the maximum rating. The amended query now correctly identifies all players with the highest overall rating rather than just one arbitrary top-rated player."
        ],
        "rules": [
            "overall strength is the greatest refers to MAX(overall_rating)"
        ]
    },
    "1464": {
        "sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, i.amount\nFROM member m\nJOIN income i ON m.member_id = i.link_to_member\nWHERE i.date_received = '9/9/2019';",
            "SELECT DISTINCT T3.first_name, T3.last_name, i.amount\nFROM income i\nINNER JOIN member T3 ON i.link_to_member = T3.member_id\nINNER JOIN attendance a ON T3.member_id = a.link_to_member\nINNER JOIN event e ON a.link_to_event = e.event_id\nWHERE i.date_received = '2019-09-09';"
        ],
        "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select separate `first_name` and `last_name` columns instead of concatenating them as `full_name`. Do add joins to `event` and `attendance` tables instead of omitting them, specifically using `INNER JOIN` on `event_id = link_to_event` and `INNER JOIN` on `member_id = link_to_member` to properly connect the relationships. Do change the date format to `'2019-09-09'` instead of `'9/9/2019'` for proper date handling. Do reference tables with aliases `T3` and `T4` instead of `m` and `i` for consistency. The amended query now correctly filters income records for members who attended events on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "full name refers to first_name, last_name, amount of funds received refers to amount, received funds on date refers to date_received"
        ]
    },
    "1347": {
        "sql": [
            "SELECT z.county\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Adela' AND m.last_name = 'O''Gallagher';"
        ],
        "question": "Tell the hometown county for \"Adela O'Gallagher\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'",
        "amends": [],
        "rules": [
            "hometown county refers to county"
        ]
    },
    "1276": {
        "sql": [
            "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.DNA >= 8;"
        ],
        "question": "For the patients who have an abnormal level of anti-DNA, please list the diseases they are diagnosed with.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT(T1.Diagnosis) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA >= 8",
        "amends": [],
        "rules": [
            "abnormal level of anti-DNA refers to DNA > = 8; diseases refers to Diagnosis;"
        ]
    },
    "948": {
        "sql": [
            "SELECT MAX(cs.points) AS max_points\nFROM constructors c\nJOIN constructorStandings cs ON c.constructorId = cs.constructorId\nWHERE c.nationality = 'British';"
        ],
        "question": "What are the maximum points of British constructors?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT MAX(T1.points) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T2.nationality = 'British'",
        "amends": [],
        "rules": [
            "maximum points = MAX(points); British is a nationality"
        ]
    },
    "1238": {
        "sql": [
            "SELECT p.ID, p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Diagnosis = 'SLE'\n  AND l.HGB BETWEEN 12 AND 17.5\nORDER BY p.Birthday ASC\nLIMIT 1;"
        ],
        "question": "Among the patients who were diagnosed with SLE, who is the oldest with normal hemoglobin level. Provide the ID and sex.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.HGB > 10 AND T2.HGB < 17 ORDER BY T1.Birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "diagnosed with SLE refers to Diagnosis = 'SLE'; The larger the birthday value, the younger the person is, and vice versa; normal hemoglobin level refers to 10 < HGB < 17;"
        ]
    },
    "1043": {
        "sql": [
            "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers';"
        ],
        "question": "What is the short name of the football team Queens Park Rangers?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers'",
        "amends": [],
        "rules": [
            "short name of the football team refers to team_short_name; Queens Park Rangers refers to team_long_name = 'Queens Park Rangers';"
        ]
    },
    "1436": {
        "sql": [
            "SELECT DISTINCT a.link_to_event\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nWHERE e.cost > 50;"
        ],
        "question": "Please provide links to events for members who have paid more than 50 dollar.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T1.cost > 50",
        "amends": [],
        "rules": [
            "have paid more than 50 dollar refers to cost > 50"
        ]
    },
    "565": {
        "sql": [
            "SELECT p.ClosedDate IS NULL AS is_well_finished\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE c.UserId = 23853 AND c.CreationDate = '2013-07-12 09:08:18.0';",
            "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS result\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.UserId = 23853 \nAND T1.CreationDate = '2013-07-12 09:08:18'",
            "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.UserId = 23853\nAND T1.CreationDate = '2013-07-12 09:08:18.0';"
        ],
        "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'",
        "amends": [
            "Do use `IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished')` as `resylt` instead of `p.ClosedDate IS NULL AS is_well_finished` to provide descriptive string values rather than a boolean result. Do alias the posts table as `T2` instead of `p` and comments as `T1` instead of `c` for consistent naming. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T1.UserId` and `T1.CreationDate` in the WHERE clause instead of `c.UserId` and `c.CreationDate` to match the table aliasing. The amended query now correctly returns descriptive status strings and matches the RIGHT_SQL's behavior.",
            "Do use the alias `resylt` instead of `result` for the IIF expression output. Do include the full timestamp precision `'2013-07-12 09:08:18.0'` instead of `'2013-07-12 09:08:18'` in the WHERE filter. The amended query now correctly handles the timestamp precision and maintains the same logical behavior with the updated alias."
        ],
        "rules": [
            "user no. 23853 refers to UserId = '23853'; at 9:08:18 on 2013/7/12 refers to CreationDate = '2013-07-12 09:08:18.0'; not well-finished refers to ClosedDate IS NULL and vice versa"
        ]
    },
    "1116": {
        "sql": [
            "SELECT player_name FROM Player WHERE height = (SELECT MAX(height) FROM Player);"
        ],
        "question": "List down most tallest players' name.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM (SELECT player_name, height, DENSE_RANK() OVER (ORDER BY height DESC) as rank FROM Player) WHERE rank = 1",
        "amends": [],
        "rules": [
            "tallest refers to rank based on the height in descending order; Most tallest players refers to rank = 1 "
        ]
    },
    "980": {
        "sql": [
            "SELECT d.driverRef, d.nationality, d.dob\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 23 AND q.q2 IS NOT NULL;"
        ],
        "question": "List the reference name of the drivers who passed the second qualifying lap during race no. 23. Indicate their nationality and birthday.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverRef, T2.nationality, T2.dob FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T1.raceId = 23 AND T1.q2 IS NOT NULL",
        "amends": [],
        "rules": [
            "passed the second qualifying lap refers to q2 is not null; birthday refers to dob; reference name of drivers refers to driverRef; race no. refers to raceId;"
        ]
    },
    "1209": {
        "sql": [
            "SELECT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT > 60\nORDER BY p.Birthday ASC;"
        ],
        "question": "Please provide the diagnosis of patients with ALT glutamic pylvic transaminase beyond the normal range by ascending order of their date of birth.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT > 60 ORDER BY T1.Birthday ASC",
        "amends": [],
        "rules": [
            "ALT glutamic pylvic transaminase beyond the normal range refers to GPT > 60; The larger the birthday value, the younger the person is, and vice versa; "
        ]
    },
    "990": {
        "sql": [
            "SELECT c.constructorRef, c.url\nFROM constructors c\nJOIN results r ON c.constructorId = r.constructorId\nJOIN races ra ON r.raceId = ra.raceId\nWHERE ra.year = 2009 AND ra.name = 'Singapore Grand Prix' AND r.positionOrder = 1;"
        ],
        "question": "What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "amends": [],
        "rules": [
            "the time of the champion shows in the format of \"minutes: seconds.millionsecond\" in which Max(time); constructor reference name refers to constructorRef; website refers to url"
        ]
    },
    "116": {
        "sql": [
            "WITH first_loan_client AS (\n    SELECT l.account_id, c.client_id\n    FROM loan l\n    JOIN account a ON l.account_id = a.account_id\n    JOIN disp d ON a.account_id = d.account_id\n    JOIN client c ON d.client_id = c.client_id\n    WHERE l.date = '1993-07-05'\n    ORDER BY l.loan_id\n    LIMIT 1\n),\nbalance_b AS (\n    SELECT t.account_id, t.balance\n    FROM trans t\n    JOIN first_loan_client flc ON t.account_id = flc.account_id\n    WHERE t.date = '1993-03-22'\n    ORDER BY t.trans_id DESC\n    LIMIT 1\n),\nbalance_a AS (\n    SELECT t.account_id, t.balance\n    FROM trans t\n    JOIN first_loan_client flc ON t.account_id = flc.account_id\n    WHERE t.date = '1998-12-27'\n    ORDER BY t.trans_id DESC\n    LIMIT 1\n)\nSELECT \n    ((ba.balance - bb.balance) * 100.0 / bb.balance) AS increase_rate\nFROM balance_a ba\nJOIN balance_b bb ON ba.account_id = bb.account_id;"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
        "amends": [],
        "rules": [
            "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%"
        ]
    },
    "346": {
        "sql": [
            "SELECT c.id, c.artist\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE (c.power = '*' OR c.power IS NULL)\nAND l.format = 'commander'\nAND l.status = 'Legal';"
        ],
        "question": "List all the card id and artist with unknown power which are legal for commander play format.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Legal' AND T2.format = 'commander' AND (T1.power IS NULL OR T1.power = '*')",
        "amends": [],
        "rules": [
            "unknown power refers to power = '*' or POWER IS NULL; commander play format refers to format = 'commander'; legal for commander play format refers to format = 'commander' where status = 'Legal'"
        ]
    },
    "563": {
        "sql": [
            "SELECT p.FavoriteCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE c.UserId = 3025 AND c.CreationDate = '2014/4/23 20:29:39.0';",
            "SELECT T1.FavoriteCount \nFROM posts AS T1 \nINNER JOIN comments AS T2 ON T1.Id = T2.PostId \nWHERE T2.CreationDate = '2014-04-23 20:29:39.0' \nAND T2.UserId = 3025"
        ],
        "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.CreationDate = '2014-04-23 20:29:39.0' AND T2.UserId = 3025",
        "amends": [
            "Do reference `posts` as `T1` and `comments` as `T2` instead of using original table names. Do use `INNER JOIN` with explicit `AS` aliases instead of simple `JOIN` without aliases. Do specify the join condition as `T1.Id = T2.PostId` instead of `c.PostId = p.Id` to maintain proper table reference consistency. Do place the `CreationDate` filter before the `UserId` filter in the `WHERE` clause instead of the reverse order. Do format the date literal as `'2014-04-23 20:29:39.0'` with hyphens instead of `'2014/4/23 20:29:39.0'` with slashes and inconsistent month padding. The amended query now correctly retrieves the FavoriteCount from posts based on the specified comment criteria."
        ],
        "rules": [
            "user no. 3025 refers to UserId = '3025'; comment at 20:29:39 on 2014/4/23 refers to CreationDate = '2014/4/23 20:29:39.0'"
        ]
    },
    "569": {
        "sql": [
            "SELECT COUNT(*) AS total_votes\nFROM votes v\nJOIN posts p ON v.PostId = p.Id\nWHERE p.Title LIKE '%data visualization%';"
        ],
        "question": "Give the number of votes for the post about data visualization.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data visualization%'",
        "amends": [],
        "rules": [
            "About data visualization is the Title that contains 'data visualization';"
        ]
    },
    "848": {
        "sql": [
            "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.location = 'Shanghai';"
        ],
        "question": "Please list the year during which the race is held on circuits in Shanghai.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.location = 'Shanghai'",
        "amends": [],
        "rules": [
            "Shanghai is a name of location;"
        ]
    },
    "1387": {
        "sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Yearly Kickoff';"
        ],
        "question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
        "amends": [],
        "rules": [
            "name of students means the full name; full name refers to first_name, last_name;'Yearly Kickoff' is an event name;"
        ]
    },
    "153": {
        "sql": [
            "SELECT COUNT(*) AS classic_cards_eligible_for_loan\nFROM card\nJOIN disp ON card.disp_id = disp.disp_id\nJOIN account ON disp.account_id = account.account_id\nWHERE card.type = 'classic' AND disp.type = 'OWNER';"
        ],
        "question": "How many 'classic' cards are eligible for loan?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'classic' AND T2.type = 'OWNER'",
        "amends": [],
        "rules": [
            "when the account type = 'OWNER', it's eligible for loan"
        ]
    },
    "433": {
        "sql": [
            "WITH chinese_cards AS (\n    SELECT DISTINCT c.uuid\n    FROM cards c\n    JOIN foreign_data fd ON c.uuid = fd.uuid\n    WHERE fd.language = 'Chinese Simplified'\n),\nonline_chinese_cards AS (\n    SELECT uuid\n    FROM cards\n    WHERE uuid IN (SELECT uuid FROM chinese_cards) AND isOnlineOnly = 1\n)\nSELECT \n    (COUNT(DISTINCT online_chinese_cards.uuid) * 100.0 / \n    NULLIF(COUNT(DISTINCT chinese_cards.uuid), 0) AS percentage\nFROM chinese_cards\nLEFT JOIN online_chinese_cards ON chinese_cards.uuid = online_chinese_cards.uuid;",
            "SELECT \n    CAST(SUM(CASE WHEN st.language = 'Chinese Simplified' AND s.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100.0 AS percentage\nFROM \n    sets s\nINNER JOIN \n    set_translations st ON s.code = st.setCode;"
        ],
        "question": "What is the percentage of the set of cards that have Chinese Simplified as the language and are only available for online games?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode",
        "amends": [
            "Do use `sets` and `set_translations` tables instead of `cards` and `foreign_data` tables. Do join with `INNER JOIN` on `T1.code = T2.setCode` instead of multiple CTEs with `LEFT JOIN` on `uuid`. Do calculate percentage using `SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END)` divided by `COUNT(*)` instead of counting distinct UUIDs from separate CTEs. Do remove the `DISTINCT` operations and CTE structure instead of maintaining complex subqueries. Do cast the result as `REAL` instead of using `* 100.0` with division. The amended query now correctly calculates the percentage of Chinese Simplified online-only sets by directly joining the relevant tables with proper filtering conditions."
        ],
        "rules": [
            "are only available for online games refers to isOnlineOnly = 1; percentage = DIVIDE(COUNT(isOnlineOnly = 1),COUNT(isOnlineOnly))*100"
        ]
    },
    "622": {
        "sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'Sharpie';"
        ],
        "question": "State the name of badge that the user whose display name is \"Sharpie\" obtained.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Sharpie'",
        "amends": [],
        "rules": [
            "\"Sharpie\" is the DisplayName of user; user refers to UserId"
        ]
    },
    "1459": {
        "sql": [
            "SELECT m.major_name, m.department\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Garrett' AND mb.last_name = 'Gerke';"
        ],
        "question": "What is the major of Garrett Gerke and which department does it belong to?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name, T2.department FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'",
        "amends": [],
        "rules": [
            "major refers to major name;"
        ]
    },
    "1441": {
        "sql": [
            "SELECT COUNT(*) AS education_major_members\nFROM member\nWHERE link_to_major IN (SELECT major_id FROM major WHERE major_name = 'education' AND college = 'College of Education & Human Services');",
            "SELECT COUNT(T1.member_id) \nFROM member AS T1\nINNER JOIN major AS T2 ON T2.major_id = T1.link_to_major\nWHERE T1.position = 'Member'\nAND T2.major_name LIKE '%Education%'\nAND T2.college = 'College of Education & Human Services'"
        ],
        "question": "How many members have education major in the College of Education & Human Services?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member' AND T2.major_name LIKE '%Education%' AND T2.college = 'College of Education & Human Services'",
        "amends": [
            "Do use `COUNT(T1.member_id)` instead of `COUNT(*)` to count specific non-null values. Do add `INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major` instead of using a subquery for the join. Do add `T1.position = 'Member'` filter instead of omitting it. Do change the major condition to `T2.major_name LIKE '%Education%'` instead of exact match `major_name = 'education'` to include variations. Do keep `T2.college = 'College of Education & Human Services'` condition. Do remove the subquery approach and instead use an explicit join with proper table aliases. The amended query now correctly filters for members with position 'Member' and uses pattern matching for education-related majors while maintaining the college filter through a proper join."
        ],
        "rules": [
            "'education' is the major name; 'Member' is a position of club;"
        ]
    },
    "976": {
        "sql": [
            "SELECT l.driverId\nFROM lapTimes l\nJOIN drivers d ON l.driverId = d.driverId\nWHERE l.lap = 1\nORDER BY l.time ASC\nLIMIT 5;"
        ],
        "question": "List the driver's ID of the top five driver, by descending order, the fastest time during the first lap of the race.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY time LIMIT 5",
        "amends": [],
        "rules": [
            "fastest time refers to Min(time);"
        ]
    },
    "39": {
        "sql": [
            "SELECT AVG(s.NumTstTakr) AS average_test_takers\nFROM schools sc\nJOIN satscores s ON sc.CDSCode = s.cds\nWHERE sc.County = 'Fresno'\nAND sc.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';"
        ],
        "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T2.County = 'Fresno'",
        "amends": [],
        "rules": [
            "between 1/1/1980 and 12/31/1980 means the year = 1980"
        ]
    },
    "1264": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nJOIN Laboratory L ON P.ID = L.ID\nWHERE E.Thrombosis = 1 AND L.C4 > 10;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'APS' \nAND T2.C4 > 10"
        ],
        "question": "Among the patients have blood clots in veins, how many of them have a normal level of complement 4?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C4 > 10 AND T1.Diagnosis = 'APS'",
        "amends": [
            "Do use `T1.ID` as the count column instead of `P.ID`. Do join only `Laboratory AS T2` instead of joining both `Examination` and `Laboratory` tables. Do remove the `Examination` table and its `Thrombosis = 1` condition instead of including them. Do add filter `T1.Diagnosis = 'APS'` instead of omitting it. Do use `INNER JOIN` with alias `T2` instead of `JOIN` with alias `L`. Do reference `T2.C4 > 10` instead of `L.C4 > 10`. The amended query now correctly counts patients with APS diagnosis who have elevated C4 levels, matching the intended behavior."
        ],
        "rules": [
            "APS will result in Blood Clots in veins; normal level of complement 4 refers to C4 > 10; Should compute the number of different ones"
        ]
    },
    "1437": {
        "sql": [
            "SELECT m.member_id, m.first_name, m.last_name, e.event_id, e.event_name, e.event_date\nFROM expense ex\nJOIN member m ON ex.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE ex.approved = 'true'\nAND ex.expense_date BETWEEN '2019-01-10' AND '2019-11-19'",
            "SELECT DISTINCT T1.link_to_member, T3.link_to_event\nFROM expense T1\nINNER JOIN attendance T3 ON T1.link_to_member = T3.link_to_member\nWHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19'\nAND T1.approved = 'true'"
        ],
        "question": "Which members who were approved from 1/10/2019 to 11/19/2019? Please identify the member who attended the event and the link to their event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.link_to_member, T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true'",
        "amends": [
            "Do select only `T1.link_to_member` and `T3.link_to_event` instead of multiple columns including `m.member_id`, `m.first_name`, `m.last_name`, `e.event_id`, `e.event_name`, and `e.event_date`. Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do reference tables with aliases `T1`, `T2`, and `T3` instead of `ex`, `m`, `a`, and `e`. Do use `INNER JOIN` consistently instead of mixing `JOIN` syntax. Do join `attendance` directly to `member` via `T2.member_id = T3.link_to_member` instead of through the expense table. Do remove the explicit `event` table join and its columns since they're not needed in the result set. Do apply `date(SUBSTR(T1.expense_date, 1, 10))` to handle date formatting instead of using `expense_date` directly. Do keep the `approved = 'true'` filter but move it after the date condition instead of before it. Do remove the unnecessary table references and columns that were not required for the query logic. The amended query now correctly returns distinct member-event pairs for approved expenses within the specified date range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "approved from 1/10/2019 to 11/19/2019 refers to approved = 'true' and expense_date BETWEEN '2019-01-10' and '2019-11-19'"
        ]
    },
    "1415": {
        "sql": [
            "SELECT m.position\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business';"
        ],
        "question": "List out the position of members who joined major of Business.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.position FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business'",
        "amends": [],
        "rules": [
            "'Business' is the major name"
        ]
    },
    "854": {
        "sql": [
            "SELECT c.lat, c.lng\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Australian Grand Prix';"
        ],
        "question": "What is the coordinates location of the circuits for Australian grand prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Australian Grand Prix'",
        "amends": [],
        "rules": [
            "coordinate position/location refers to lat, lng; circuits for Australian grand prix refers to races.name = 'Australian Grand Prix'"
        ]
    },
    "1240": {
        "sql": [
            "SELECT AVG(HCT) AS average_hematocrit_below_normal \nFROM Laboratory \nWHERE Date LIKE '1991%' AND HCT < 29;"
        ],
        "question": "From laboratory examinations in 1991, what is the average hematoclit level that is lower than the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.HCT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HCT < 29 AND STRFTIME('%Y', T2.Date) = '1991'",
        "amends": [],
        "rules": [
            "laboratory examinations in 1991 refers to Date like '1991%'; average hematoclit level = AVG(HCT); hematoclit level that is lower than the normal range refers to HCT < 29;"
        ]
    },
    "439": {
        "sql": [
            "SELECT name FROM sets WHERE code = 'ALL';"
        ],
        "question": "List out the set name of the set code \"ALL\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM sets WHERE code = 'ALL'",
        "amends": [],
        "rules": []
    },
    "55": {
        "sql": [
            "SELECT \n    (SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND County = 'Colusa') * 1.0 /\n    (SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND County = 'Humboldt') AS ratio_colusa_to_humboldt;"
        ],
        "question": "Of the schools with a mailing state address in California, what is the ratio of the schools located in the county of Colusa against the school located in the county of Humboldt?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END) FROM schools WHERE MailState = 'CA'",
        "amends": [],
        "rules": [
            "Ratio = count(schools in Colusa) / count(schools in Humboldt)"
        ]
    },
    "1301": {
        "sql": [
            "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nJOIN Laboratory l ON p.ID = l.ID\nWHERE e.Thrombosis = 0 AND l.CPK < 250;"
        ],
        "question": "Please list the IDs of the patients with no thrombosis and an abnormal level of creatinine phosphokinase.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 0 AND T1.CPK < 250",
        "amends": [],
        "rules": [
            "no thrombosis refers to Thrombosis = 0 ; abnormal level of creatinine phosphokinase refers to CPK < 250;"
        ]
    },
    "1315": {
        "sql": [
            "SELECT COUNT(link_to_member) AS student_count\nFROM attendance\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = \"Women's Soccer\");"
        ],
        "question": "How many students of the Student_Club have attended the event \"Women's Soccer\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
        "amends": [],
        "rules": [
            "Women's Soccer is an event name"
        ]
    },
    "823": {
        "sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female') \nAND publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');"
        ],
        "question": "How many female superheroes are in Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.gender = 'Female'",
        "amends": [],
        "rules": [
            "female refers to gender = 'Female'; Marvel Comics refers to publisher_name = 'Marvel Comics';"
        ]
    },
    "730": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE p.publisher_name = 'Marvel Comics'\nAND sp.power_name = 'Super Strength';"
        ],
        "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
        "amends": [],
        "rules": [
            "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; super power of \"Super Strength\" refers to power_name = 'Super Strength';"
        ]
    },
    "178": {
        "sql": [
            "SELECT c.type \nFROM card c \nJOIN disp d ON c.disp_id = d.disp_id \nWHERE d.client_id = 9;"
        ],
        "question": "Which kind of credit card does client number 9 possess?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.type FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.client_id = 9",
        "amends": [],
        "rules": []
    },
    "1368": {
        "sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.phone = '809-555-3360';"
        ],
        "question": "What does the person with the phone number \"809-555-3360\" major in?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.phone = '809-555-3360'",
        "amends": [],
        "rules": [
            "major in refers to major_name"
        ]
    },
    "1477": {
        "sql": [
            "SELECT strftime('%Y', t.Date) AS Year, SUM(t.Amount) AS TotalGasUse\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE c.Currency = 'EUR'\nGROUP BY Year\nORDER BY TotalGasUse DESC\nLIMIT 1;",
            "SELECT SUBSTRING(T2.Date, 1, 4) AS Year, SUM(T2.Consumption) AS TotalGasUse\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY Year\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
            "SELECT SUBSTRING(T2.Date, 1, 4) \nFROM yearmonth AS T2\nINNER JOIN customers AS T1 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY SUBSTRING(T2.Date, 1, 4)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "question": "Which year recorded the most gas use paid in EUR?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUBSTRING(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY SUBSTRING(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do extract year using `SUBSTRING(T2.Date, 1, 4)` instead of `strftime('%Y', t.Date)` for date handling. Do join with `yearmonth AS T2` instead of `transactions_1k t` as the source table. Do use `INNER JOIN` with `T1.CustomerID = T2.CustomerID` instead of `JOIN` with `t.CustomerID = c.CustomerID` for the join condition. Do aggregate `SUM(T2.Consumption)` instead of `SUM(t.Amount)` for the calculation. Do order by `SUM(T2.Consumption) DESC` instead of `TotalGasUse DESC` using the actual aggregate expression rather than the alias. The amended query now correctly calculates annual gas consumption from the yearmonth table for EUR currency customers and matches the RIGHT_SQL behavior.",
            "Do reference `SUBSTRING(T2.Date, 1, 4)` directly in the GROUP BY clause instead of using the alias `Year`, as SQL requires grouping by the actual expression rather than column aliases. Do remove the column alias `AS Year` from the SELECT list instead of keeping it, since the RIGHT_SQL omits this explicit naming. Do remove the alias `AS TotalGasUse` from the aggregated column instead of including it, as the RIGHT_SQL returns the sum without an alias. The amended query now correctly groups by the year expression directly and matches RIGHT_SQL's behavior by returning unaliased results while maintaining the same aggregation logic and filtering conditions."
        ],
        "rules": []
    },
    "1378": {
        "sql": [
            "SELECT MAX(spent) AS highest_budget_spend FROM budget;"
        ],
        "question": "What is the highest amount of budget spend for an event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT MAX(spent) FROM budget",
        "amends": [],
        "rules": [
            "highest amount of budget spend refers to MAX(spent)"
        ]
    },
    "412": {
        "sql": [
            "SELECT fd.name AS foreign_name\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.type = 'Creature'\n  AND c.layout = 'normal'\n  AND c.borderColor = 'black'\n  AND c.artist = 'Matthew D. Wilson'\n  AND fd.language = 'French';",
            "SELECT name FROM foreign_data WHERE language = 'French' AND uuid IN (SELECT uuid FROM cards WHERE artist = 'Matthew D. Wilson' AND layout = 'normal' AND borderColor = 'black' AND types LIKE '%Creature%')",
            "SELECT name FROM foreign_data WHERE uuid IN (SELECT uuid FROM cards WHERE artist = 'Matthew D. Wilson' AND layout = 'normal' AND borderColor = 'black' AND types = 'Creature') AND language = 'French'"
        ],
        "question": "What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'",
        "amends": [
            "Do select only `name` instead of `fd.name AS foreign_name`. Do use a subquery with `uuid IN (SELECT uuid FROM cards)` instead of a `JOIN` between tables. Do reference `types` instead of `type` in the subquery filter. Do remove the table alias `fd` from the column reference. Do place all card filters within the subquery instead of mixing them between join conditions and WHERE clause. Do maintain the `language = 'French'` filter on the outer query instead of applying it to the joined table. The amended query now correctly filters cards by their types attribute and uses a more efficient subquery approach instead of an unnecessary join.",
            "Do use `types = 'Creature'` instead of `types LIKE '%Creature%'` for exact matching. Do move the `language = 'French'` filter to the end of the WHERE clause instead of placing it at the beginning. Do maintain the same logical structure with the subquery checking for `uuid` values from the cards table with the specified artist, layout, borderColor, and creature type conditions. The amended query now correctly uses exact string comparison for the creature type and maintains the same result set as the RIGHT_SQL."
        ],
        "rules": [
            "in French refers to language = 'French'; black border color refers to borderColor = 'black'"
        ]
    },
    "1399": {
        "sql": [
            "SELECT CASE WHEN EXISTS (\n    SELECT 1\n    FROM attendance a\n    JOIN member m ON a.link_to_member = m.member_id\n    JOIN event e ON a.link_to_event = e.event_id\n    WHERE m.first_name = 'Maya' AND m.last_name = 'Mclean'\n    AND e.event_name = 'Women''s Soccer'\n) THEN 'Yes' ELSE 'No' END AS did_attend;",
            "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result\nFROM member T1\nINNER JOIN attendance T2 ON T1.member_id = T2.link_to_member\nINNER JOIN event T3 ON T2.link_to_event = T3.event_id\nWHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean';"
        ],
        "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
        "amends": [
            "Do use an explicit `INNER JOIN` chain with table aliases `T1`, `T2`, `T3` instead of an `EXISTS` subquery with implicit joins. Do select `T3.event_name` directly in the `CASE` expression instead of checking existence through a subquery. Do place the `event_name` filter in the `CASE` condition instead of the `WHERE` clause of a subquery. Do move the member name filters `T1.first_name = 'Maya'` and `T1.last_name = 'Mclean'` to the main query's `WHERE` clause instead of the subquery. Do return 'YES' as `result` instead of 'Yes' as `did_attend` when the condition is met, and implicitly return NULL instead of 'No' for non-matching cases. The amended query now correctly returns a row with the event-specific result instead of a single yes/no existence check, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Maya Mclean is the full name; full name refers to first_name, last_name; 'Women's Soccer' is an event_name"
        ]
    },
    "989": {
        "sql": [
            "SELECT d.forename, d.surname, r.time\nFROM races ra\nJOIN results r ON ra.raceId = r.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.name = 'Canadian Grand Prix' AND ra.year = 2008 AND r.positionOrder = 1;",
            "SELECT T1.time \nFROM results AS T1 \nINNER JOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T2.name = 'Canadian Grand Prix' \nAND T2.year = 2008 \nAND T1.time LIKE '_:%:__.___'"
        ],
        "question": "Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___'",
        "amends": [
            "Do select only `T1.time` instead of including `d.forename` and `d.surname`. Do use `INNER JOIN races AS T2` instead of joining with `drivers d`. Do remove the `JOIN drivers` condition entirely instead of keeping it. Do change the filter to `T1.time LIKE '_:%:__.___'` instead of `r.positionOrder = 1`. Do use table aliases `T1` for `results` and `T2` for `races` instead of `r`, `ra`, and `d`. The amended query now correctly filters for time format patterns instead of position order and eliminates unnecessary driver information."
        ],
        "rules": [
            "Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\";"
        ]
    },
    "93": {
        "sql": [
            "SELECT COUNT(*) AS male_customers_north_bohemia_high_salary\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.gender = 'M' AND d.A3 = 'North Bohemia' AND d.A11 > 8000;",
            "SELECT COUNT(T1.client_id) \nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'M' \nAND LOWER(T2.A3) = 'north bohemia' \nAND T2.A11 > 8000;"
        ],
        "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
        "amends": [
            "Do use `COUNT(T1.client_id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do reference the table as `T1` and `T2` instead of `c` and `d` for consistent aliasing. Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do change the case of the region filter to `'north Bohemia'` (lowercase 'n') instead of `'North Bohemia'` to match the actual data format. The amended query now correctly counts male customers from the north Bohemia district with high salary thresholds while maintaining the same logical behavior."
        ],
        "rules": [
            "Male means that gender = 'M'; A3 refers to region; A11 pertains to average salary."
        ]
    },
    "1362": {
        "sql": [
            "SELECT COUNT(DISTINCT city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia';"
        ],
        "question": "How many cities are there in Orange County, Virginia?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia'",
        "amends": [],
        "rules": [
            "Orange County is the county name, Virginia is the state name"
        ]
    },
    "1475": {
        "sql": [
            "SELECT COUNT(DISTINCT c.CustomerID) AS NumberOfCustomers\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Segment = 'KAM'\nAND ym.Date BETWEEN '201201' AND '201212'\nGROUP BY c.CustomerID\nHAVING SUM(ym.Consumption) < 30000;",
            "SELECT COUNT(*) \nFROM (\n    SELECT T1.CustomerID \n    FROM customers T1\n    JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\n    WHERE T1.Segment = 'KAM' \n    AND SUBSTRING(T2.Date, 1, 4) = '2012'\n    GROUP BY T1.CustomerID\n    HAVING SUM(T2.Consumption) < 30000\n)"
        ],
        "question": "How many customers in KAM had a consumption of less than 30,000 for the year 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T2.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND SUBSTRING(T2.Date, 1, 4) = '2012' GROUP BY T2.CustomerID HAVING SUM(T2.Consumption) < 30000 ) AS t1",
        "amends": [
            "Do use `COUNT(*)` on the subquery result instead of `COUNT(DISTINCT c.CustomerID)` to count unique customers. Do add table aliases `T1` and `T2` instead of `c` and `ym` for clarity. Do change the date filter to `SUBSTRING(T2.Date, 1, 4) = '2012'` instead of `ym.Date BETWEEN '201201' AND '201212'` to properly extract the year. Do remove the redundant `GROUP BY c.CustomerID` from the outer query instead of keeping it, as the grouping is already handled in the subquery. Do restructure the query with a subquery that selects `CustomerID` instead of directly aggregating in the main query. The amended query now correctly counts customers with consumption below 30000 in 2012, matching the intended behavior."
        ],
        "rules": [
            "Year 2012 can be presented as Between 201201 And 201212, which means between January and December in 2012"
        ]
    },
    "700": {
        "sql": [
            "SELECT COUNT(*) AS NumberOfPostsWithBountyOver30 FROM votes WHERE BountyAmount >= 30;"
        ],
        "question": "Identify the number of posts that offer a bounty amount over 30.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM votes WHERE BountyAmount >= 30",
        "amends": [],
        "rules": [
            "bounty amount over 30 refers to BountyAmount > = 30;"
        ]
    },
    "972": {
        "sql": [
            "SELECT d.driverId, d.code\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE strftime('%Y', d.dob) = '1971'\nAND r.fastestLapTime IS NOT NULL;"
        ],
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "amends": [],
        "rules": [
            "born in 1971 refers to year(dob) = 1971; has the fastest lap time refers to fastestLapTime has values"
        ]
    },
    "366": {
        "sql": [
            "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Benalish Knight';",
            "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'"
        ],
        "question": "What is the rule of playing card \"Benalish Knight\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "amends": [
            "Do select `T2.format` instead of `r.text` and use table alias `T1` for cards instead of `c`. Do join `legalities AS T2` instead of `rulings r` and use `INNER JOIN` instead of `JOIN` with the same join condition `ON T1.uuid = T2.uuid` instead of `ON r.uuid = c.uuid`. Do keep the WHERE filter `T1.name = 'Benalish Knight'` unchanged. The amended query now correctly retrieves format information from the legalities table instead of text from rulings, matching the intended behavior."
        ],
        "rules": [
            "Benalish Knight' is the name of card; rule of playing card refers to format;"
        ]
    },
    "620": {
        "sql": [
            "SELECT u.Views\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Date = '2010-07-19 19:39:08.0';"
        ],
        "question": "State the number of views of users who obtained the badge on 7/19/2010 7:39:08 PM.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Views FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'",
        "amends": [],
        "rules": [
            "on 7/19/2010 7:39:08 PM refers to Date = '2010-07-19 19:39:08.0'"
        ]
    },
    "1157": {
        "sql": [
            "SELECT P.ID, P.SEX, COALESCE(E.Diagnosis, P.Diagnosis) AS Disease\nFROM Patient P\nLEFT JOIN Examination E ON P.ID = E.ID\nWHERE E.Thrombosis = 2;",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis\nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.Thrombosis = 2"
        ],
        "question": "For patients with severe degree of thrombosis, list their ID, sex and disease the patient is diagnosed with.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 2",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `T1.ID`, `T1.SEX`, and `T1.Diagnosis` instead of `P.ID`, `P.SEX`, and `COALESCE(E.Diagnosis, P.Diagnosis) AS Disease`. Do use `INNER JOIN` instead of `LEFT JOIN` to only include patients with matching examination records. Do join on `T1.ID = T2.ID` instead of `P.ID = E.ID` with consistent table aliasing. Do filter on `T2.Thrombosis = 2` instead of `E.Thrombosis = 2` with proper table reference. Do remove the `COALESCE` function and directly use `T1.Diagnosis` instead of attempting to merge diagnosis sources. The amended query now correctly returns distinct patients with thrombosis examination results, matching the intended behavior."
        ],
        "rules": [
            "severe degree of thrombosis refers to thrombosis = 2; disease refers to diagnosis;"
        ]
    },
    "417": {
        "sql": [
            "WITH japanese_translated_sets AS (\n    SELECT COUNT(*) AS total_japanese_sets\n    FROM set_translations\n    WHERE language = 'Japanese'\n),\n\nexpansion_japanese_sets AS (\n    SELECT COUNT(*) AS expansion_japanese_sets\n    FROM set_translations st\n    JOIN sets s ON st.setCode = s.code\n    WHERE st.language = 'Japanese' AND s.type = 'expansion'\n)\n\nSELECT (expansion_japanese_sets.expansion_japanese_sets * 100.0 / japanese_translated_sets.total_japanese_sets) AS percentage\nFROM japanese_translated_sets, expansion_japanese_sets;",
            "SELECT \n    SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id) AS percentage\nFROM \n    sets T1\nINNER JOIN \n    set_translations T2 ON T1.code = T2.setCode\nWHERE \n    T1.type = 'expansion';"
        ],
        "question": "What percentage of Japanese translated sets are expansion sets?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.type = 'expansion'",
        "amends": [
            "Do use a single query with `INNER JOIN` on `T1.code = T2.setCode` instead of separate CTEs with cross join. Do calculate percentage using `SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) * 100 / COUNT(T1.id)` instead of separate counts from different tables. Do filter with `WHERE T1.type = 'expansion'` instead of filtering only in one CTE. Do cast the numerator as `REAL` instead of implicit integer division. Do reference tables directly with aliases `T1` and `T2` instead of using CTE names. The amended query now correctly calculates the percentage of Japanese-translated expansion sets by joining the tables properly and avoiding the cross join issue that could produce incorrect results."
        ],
        "rules": [
            "Japanese translated refers to language = 'Japanese'; expansion sets refers to type = 'expansion'; percentage = DIVIDE(COUNT(language = 'Japanese'),COUNT(language))*100"
        ]
    },
    "1221": {
        "sql": [
            "SELECT P.ID, P.SEX, P.Birthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'RA' AND L.UN < 30;"
        ],
        "question": "Provide the ID, sex, birthday of all patients diagnosed with 'RA' that are within the UN normal index.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN < 30 AND T1.Diagnosis = 'RA'",
        "amends": [],
        "rules": [
            "within the UN normal index refers to UN < 30; Diagnosis = 'RA'"
        ]
    },
    "1495": {
        "sql": [
            "SELECT CustomerID, SUM(Consumption) AS TotalConsumption\nFROM yearmonth\nWHERE Date = '201309'\nGROUP BY CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date LIKE '2013-09%'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "question": "Which client ID consumed the most in September 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do add the `customers` table with an `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `yearmonth` table. Do reference `T2.Date` in the WHERE clause instead of just `Date`. Do calculate the SUM of `T2.Consumption` in the ORDER BY clause instead of selecting it as a column in the SELECT list. Do remove the explicit `TotalConsumption` alias from the SELECT list instead of including it. The amended query now correctly joins customer data with consumption records and properly orders by the aggregated sum while matching the RIGHT_SQL's behavior.",
            "Do use exact equality `T2.Date = '201309'` instead of pattern matching `T2.Date LIKE '2013-09%'` for the date filter. Do remove the unnecessary table alias `T1.` prefix from `CustomerID` in the SELECT list instead of keeping it. The amended query now correctly matches the right SQL's behavior by using precise date comparison and cleaner column reference."
        ],
        "rules": [
            "September 2013 refers to yearmonth.date = '201309'"
        ]
    },
    "1205": {
        "sql": [
            "SELECT \n    P.SEX,\n    L.UA,\n    CASE \n        WHEN P.SEX = 'M' AND L.UA > 8.0 THEN 'Normal'\n        WHEN P.SEX = 'F' AND L.UA > 6.5 THEN 'Normal'\n        ELSE 'Not Normal'\n    END AS UricAcidStatus\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.ID = 57266;",
            "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN false ELSE true END AS is_normal_uric_acid\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.ID = 57266\nORDER BY T2.Date DESC\nLIMIT 1;",
            "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T1.ID = 57266"
        ],
        "question": "Was the patient with the number 57266's uric acid within a normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 57266",
        "amends": [
            "Do use a boolean expression returning `true`/`false` instead of string labels `'Normal'`/`'Not Normal'` in the CASE statement. Do change the CASE logic to `(T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0)` instead of separate WHEN clauses with different thresholds. Do use table aliases `T1` and `T2` instead of `P` and `L` for the Patient and Laboratory tables. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do remove the column selection `P.SEX, L.UA` and only return the boolean result instead of including source columns. The amended query now correctly returns a boolean evaluation of uric acid status matching the specified gender-based thresholds.",
            "Do reverse the CASE WHEN logic to return `true` instead of `false` for abnormal uric acid conditions and `false` instead of `true` for normal conditions. Do remove the `ORDER BY T2.Date DESC LIMIT 1` clause instead of keeping it, as the right query returns all matching records rather than just the most recent one. Do remove the `AS is_normal_uric_acid` alias instead of including it, as the right query returns an unaliased result. The amended query now correctly identifies abnormal uric acid levels with true/false values and returns all relevant records without limiting to the most recent laboratory result."
        ],
        "rules": [
            "uric acid within a normal range refers to UA > 8.0 and SEX = 'M'OR UA > 6.5 and SEX = 'F'"
        ]
    },
    "1015": {
        "sql": [
            "SELECT r.raceId, r.year, r.name, MIN(r.time) AS fastest_lap_time\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nJOIN results res ON r.raceId = res.raceId\nWHERE c.name = 'Austrian Grand Prix Circuit' AND res.time IS NOT NULL\nGROUP BY r.raceId, r.year, r.name\nORDER BY fastest_lap_time ASC\nLIMIT 1;",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.year,\n        r.name,\n        c.name AS circuit_name,\n        res.fastestLapTime,\n        CAST(SUBSTR(res.fastestLapTime, 1, INSTR(res.fastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, ':') + 1) AS REAL) AS time_in_seconds\n    FROM results res\n    JOIN races r ON res.raceId = r.raceId\n    JOIN circuits c ON r.circuitId = c.circuitId\n    WHERE res.fastestLapTime IS NOT NULL\n)\nSELECT T2.name\nFROM fastest_lap_times T2\nJOIN circuits c ON T2.circuit_name = c.name\nWHERE c.name = 'Austrian Grand Prix'\nAND T2.time_in_seconds = (\n    SELECT MIN(time_in_seconds)\n    FROM fastest_lap_times T1\n    JOIN circuits c1 ON T1.circuit_name = c1.name\n    WHERE c1.name = 'Austrian Grand Prix'\n)",
            "error",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.FastestLapTime,\n        (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 + \n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + \n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results AS T1\n    WHERE T1.FastestLapTime IS NOT NULL\n)\nSELECT T2.name\nFROM fastest_lap_times AS flt\nJOIN races AS T2 ON flt.raceId = T2.raceId\nJOIN circuits AS T3 ON T2.circuitId = T3.circuitId\nWHERE T2.name = 'Austrian Grand Prix'\nAND flt.time_in_seconds = (\n    SELECT MIN(flt2.time_in_seconds)\n    FROM fastest_lap_times AS flt2\n    JOIN races AS r2 ON flt2.raceId = r2.raceId\n    JOIN circuits AS c2 ON r2.circuitId = c2.circuitId\n    WHERE r2.name = 'Austrian Grand Prix'\n)",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.FastestLapTime,\n        (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + \n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + \n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) AS time_in_seconds\n    FROM results AS T1\n    WHERE T1.FastestLapTime IS NOT NULL\n)\nSELECT T2.name\nFROM races AS T2\nINNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId\nINNER JOIN fastest_lap_times AS T1 ON T2.raceId = T1.raceId\nWHERE T2.name = 'Austrian Grand Prix'\nAND T1.time_in_seconds = (\n    SELECT MIN(T1.time_in_seconds)\n    FROM fastest_lap_times AS T1\n    INNER JOIN races AS T2 ON T1.raceId = T2.raceId\n    INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId\n    WHERE T2.name = 'Austrian Grand Prix'\n)"
        ],
        "question": "In which Formula_1 race was the lap record for the Austrian Grand Prix Circuit set?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T2.name FROM races AS T2 INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN results AS T1 on T2.raceId = T1.raceId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix'",
        "amends": [
            "Do use a CTE `fastest_lap_times` to convert `FastestLapTime` to seconds instead of directly using `MIN(r.time)`. Do select only `T2.name` instead of multiple columns `r.raceId, r.year, r.name`. Do join `circuits` with condition `T2.name = 'Austrian Grand Prix'` instead of `c.name = 'Austrian Grand Prix Circuit'`. Do add complex time conversion using `SUBSTR`, `INSTR`, and `CAST` operations on `FastestLapTime` instead of simple `res.time IS NOT NULL`. Do use a subquery to find the minimum time in seconds instead of direct aggregation. Do join on the converted time matching the minimum time instead of simple grouping. Do remove explicit `GROUP BY` and `ORDER BY` clauses instead of keeping them. The amended query now correctly identifies the Austrian Grand Prix race with the fastest lap time using proper time conversion and comparison logic.",
            "Do remove `r.year`, `r.name`, and `c.name AS circuit_name` from the CTE SELECT list instead of including them. Do change the time conversion calculation to handle milliseconds by adding `(CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000)` instead of the simpler conversion that ignores milliseconds. Do remove the joins to `races` and `circuits` from the CTE instead of keeping them. Do change the main query to join `races AS T2`, `circuits AS T3`, and `results AS T1` directly instead of using the CTE as the primary source. Do move the circuit filter to `WHERE T2.name = 'Austrian Grand Prix'` instead of filtering on `c.name`. Do use a subquery to calculate `MIN(time_in_seconds)` with proper joins to `races` and `circuits` instead of the incorrect CTE-based approach. Do change the join condition to match the precise time calculation with milliseconds instead of the simplified time comparison. The amended query now correctly handles millisecond precision in lap times and properly filters for the Austrian Grand Prix, matching the RIGHT_SQL's behavior.",
            "Do use a CTE `fastest_lap_times` to precompute time conversions instead of repeating the complex time calculation in multiple places. Do add proper table aliases `T1`, `T2`, `T3` for clarity instead of ambiguous joins. Do include `WHERE T1.FastestLapTime IS NOT NULL` in the CTE instead of filtering later. Do join `circuits` through `races.circuitId = circuits.circuitId` instead of incorrect join paths. Do calculate the minimum time in a subquery that joins `fastest_lap_times` with `races` and `circuits` filtered for 'Austrian Grand Prix' instead of incorrect aggregation scope. Do use the precomputed `time_in_seconds` from the CTE in the final join condition instead of recalculating the complex time conversion. Do maintain the filter `WHERE T2.name = 'Austrian Grand Prix'` in the main query instead of omitting it. The amended query now correctly identifies races with the fastest lap times for the Austrian Grand Prix by properly handling time conversions and join relationships.",
            "Do join `races` and `circuits` directly instead of using the CTE as the primary source, and do add an explicit `INNER JOIN` on `results` instead of relying on the CTE join. Do move the minimum time calculation to a subquery `T4` instead of using a correlated subquery in the `WHERE` clause. Do change the join condition to compare the calculated lap time directly with `T4.min_time_in_seconds` instead of using the CTE-derived `time_in_seconds`. Do keep the `WHERE` filter on `T2.name = 'Austrian Grand Prix'` but apply it to both the main query and the subquery instead of only in the subquery. The amended query now correctly identifies races with the fastest lap time by performing the time calculation consistently across both the main table and subquery, ensuring accurate comparison and matching behavior with the RIGHT_SQL."
        ],
        "rules": [
            "lap record means the fastest time recorded which refers to time"
        ]
    },
    "10": {
        "sql": [
            "SELECT f.\"FRPM Count (Ages 5-17)\"\nFROM frpm f\nJOIN satscores s ON f.CDSCode = s.cds\nWHERE s.AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores);",
            "SELECT f.\"FRPM Count (Ages 5-17)\"\nFROM satscores s\nINNER JOIN frpm f ON s.cds = f.CDSCode\nORDER BY s.AvgScrRead DESC\nLIMIT 1;"
        ],
        "question": "For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1",
        "amends": [
            "Do select `FRPM Count (Ages 5-17)` from `frpm` instead of from `satscores`. Do use `INNER JOIN` with `T1.cds = T2.CDSCode` instead of `JOIN` with `f.CDSCode = s.cds`. Do remove the subquery filter `WHERE s.AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores)` instead of keeping it. Do add `ORDER BY T1.AvgScrRead DESC` instead of omitting it. Do add `LIMIT 1` instead of omitting it. The amended query now correctly retrieves the single highest-scoring record by sorting and limiting rather than using a subquery comparison."
        ],
        "rules": []
    },
    "22": {
        "sql": [
            "SELECT s.School, s.County, sc.NumTstTakr\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.County = 'Contra Costa'\nORDER BY sc.NumTstTakr DESC\nLIMIT 1;",
            "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1;"
        ],
        "question": "Which school in Contra Costa has the highest number of test takers?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1",
        "amends": [
            "Do select only `sname` instead of multiple columns `s.School, s.County, sc.NumTstTakr`. Do query from `satscores` table only instead of joining `schools` and `satscores` tables. Do filter with `cname = 'Contra Costa'` instead of `s.County = 'Contra Costa'`. Do add `sname IS NOT NULL` filter instead of omitting it. Do remove the explicit join condition `s.CDSCode = sc.cds` instead of keeping it. The amended query now correctly retrieves the school name with the highest number of test takers in Contra Costa county directly from the satscores table without unnecessary joins."
        ],
        "rules": []
    },
    "162": {
        "sql": [
            "SELECT d.A3 AS region\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.client_id = 3541;"
        ],
        "question": "What is the region of the client with the id 3541 from?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
        "amends": [],
        "rules": [
            "A3 refers to region"
        ]
    },
    "981": {
        "sql": [
            "WITH youngest_driver AS (\n    SELECT driverId, forename, surname, dob\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 1\n),\nfirst_qualifying_race AS (\n    SELECT q.raceId, MIN(r.date) AS first_race_date\n    FROM qualifying q\n    JOIN races r ON q.raceId = r.raceId\n    JOIN youngest_driver yd ON q.driverId = yd.driverId\n    GROUP BY q.driverId\n)\nSELECT r.year, r.name, r.date, r.time, yd.forename, yd.surname\nFROM races r\nJOIN first_qualifying_race fqr ON r.raceId = fqr.raceId\nJOIN youngest_driver yd ON 1=1\nWHERE r.date = fqr.first_race_date;",
            "SELECT \n    r.year,\n    r.name,\n    r.date,\n    r.time\nFROM \n    qualifying q\nJOIN \n    races r ON q.raceId = r.raceId\nWHERE \n    q.driverId = (\n        SELECT driverId \n        FROM drivers \n        ORDER BY dob DESC \n        LIMIT 1\n    )\nORDER BY \n    r.date ASC \nLIMIT 1;"
        ],
        "question": "On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.year, T3.name, T3.date, T3.time FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T1.driverId = ( SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1 ) ORDER BY T3.date ASC LIMIT 1",
        "amends": [
            "Do use a simple subquery to find the youngest driver's ID instead of a CTE with unnecessary columns. Do join `qualifying` directly with `drivers` and `races` instead of creating complex CTEs with incorrect joins. Do remove the `JOIN youngest_driver yd ON 1=1` cross join that incorrectly duplicates results. Do filter for the specific youngest driver with `WHERE T1.driverId = (subquery)` instead of trying to match race dates. Do add `ORDER BY T3.date ASC LIMIT 1` to get the earliest race instead of relying on incorrect date matching logic. Do remove the unnecessary `forename` and `surname` columns from the final SELECT since they're not needed in the output. The amended query now correctly finds the first qualifying race for the youngest driver by directly filtering for that driver and ordering races chronologically."
        ],
        "rules": [
            "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; first qualifying race refers to MIN(races.date);"
        ]
    },
    "827": {
        "sql": [
            "SELECT AVG(s.height_cm) AS average_height\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN race r ON s.race_id = r.id\nWHERE p.publisher_name = 'Dark Horse Comics'\nAND r.race != 'Human';"
        ],
        "question": "What is the average height of a non-human superhero in Dark Horse Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.race != 'Human'",
        "amends": [],
        "rules": [
            "average = AVG(height_cm); non-human superhero refers to race <> 'Human'; Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';"
        ]
    },
    "1011": {
        "sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name, lt.time\nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nORDER BY lt.time ASC\nLIMIT 20;",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        driverId,\n        CASE \n            WHEN INSTR(time, ':') > 0 THEN\n                CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n                CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n            ELSE\n                CAST(time AS REAL)\n        END AS time_in_seconds\n    FROM lapTimes\n)\nSELECT \n    d.forename,\n    d.surname,\n    MIN(lts.time_in_seconds) AS min_time_in_seconds\nFROM \n    drivers d\nJOIN \n    lap_times_in_seconds lts ON d.driverId = lts.driverId\nGROUP BY \n    d.driverId\nORDER BY \n    min_time_in_seconds ASC\nLIMIT 20;",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        driverId,\n        CASE \n            WHEN INSTR(time, ':') > 0 THEN\n                CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) + \n                CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n            WHEN INSTR(time, '.') > 0 THEN\n                CAST(SUBSTR(time, 1, INSTR(time, '.') - 1) AS REAL) + \n                CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n            ELSE\n                CAST(time AS REAL)\n        END AS time_in_seconds\n    FROM lapTimes\n    WHERE time IS NOT NULL AND time <> ''\n),\nT1 AS (\n    SELECT \n        driverId,\n        MIN(time_in_seconds) AS min_time_in_seconds\n    FROM lap_times_in_seconds\n    GROUP BY driverId\n)\nSELECT \n    T1.driverId,\n    T2.forename,\n    T2.surname,\n    T1.min_time_in_seconds\nFROM T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nORDER BY T1.min_time_in_seconds ASC\nLIMIT 20;",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        driverId,\n        CASE \n            WHEN time IS NULL OR time = '' THEN NULL\n            WHEN INSTR(time, ':') = 0 THEN CAST(time AS REAL)\n            ELSE \n                CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END +\n                CASE WHEN SUBSTR(time, INSTR(time, ':') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1) AS REAL) ELSE 0 END\n        END AS time_in_seconds\n    FROM lapTimes\n),\nT1 AS (\n    SELECT \n        driverId,\n        MIN(time_in_seconds) AS min_time_in_seconds\n    FROM lap_times_in_seconds\n    WHERE time_in_seconds IS NOT NULL\n    GROUP BY driverId\n)\nSELECT \n    T2.forename,\n    T2.surname\nFROM T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nORDER BY T1.min_time_in_seconds ASC\nLIMIT 20",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        raceId,\n        driverId,\n        lap,\n        CASE\n            WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60\n            ELSE 0\n        END +\n        CASE\n            WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)\n            ELSE 0\n        END +\n        CASE\n            WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n            ELSE 0\n        END AS time_in_seconds\n    FROM lapTimes\n),\nT1 AS (\n    SELECT \n        driverId,\n        MIN(time_in_seconds) AS min_time_in_seconds\n    FROM lap_times_in_seconds\n    GROUP BY driverId\n)\nSELECT \n    T2.forename,\n    T2.surname,\n    T1.driverId\nFROM T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nORDER BY T1.min_time_in_seconds ASC\nLIMIT 20"
        ],
        "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
        "amends": [
            "Do add a CTE `lap_times_in_seconds` to convert time format instead of using raw `time` column directly. Do use `CASE` expressions with `SUBSTR` and `INSTR` to parse minutes, seconds, and milliseconds instead of treating time as a simple string. Do calculate `MIN(time_in_seconds)` per driver with `GROUP BY driverId` instead of selecting individual lap times. Do join the aggregated minimum times with drivers instead of joining raw lap times. Do select `forename` and `surname` as separate columns instead of concatenating them as `full_name`. Do order by `min_time_in_seconds` instead of raw `time` to ensure proper numerical ordering. The amended query now correctly finds each driver's fastest lap time by converting to seconds and aggregating, matching the intended behavior.",
            "Do handle empty string cases in the time conversion with separate CASE statements checking `SUBSTR(...) <> ''` instead of assuming non-empty substrings. Do restructure the query to use a subquery `T1` that first calculates `MIN(time_in_seconds)` grouped by `driverId` instead of grouping in the main query. Do join the aggregated results with `drivers AS T2` using `INNER JOIN` instead of joining before aggregation. Do include `T1.driverId` in the SELECT list instead of omitting it. Do reference columns with table aliases `T1.min_time_in_seconds` and `T2.forename`, `T2.surname` instead of unqualified column names. The amended query now correctly handles edge cases in time parsing and properly aggregates lap times before joining with driver information, matching the RIGHT_SQL's behavior.",
            "Do add proper NULL handling in the time conversion CASE expression by checking for empty substrings with `<> ''` conditions instead of omitting them, which prevents conversion errors when time components are missing. Do remove the `WHERE time IS NOT NULL AND time <> ''` filter from the CTE instead of keeping it, as the RIGHT_SQL handles empty values through the CASE expression. Do change the SELECT list order to `T2.forename, T2.surname, T1.driverId` instead of `T1.driverId, T2.forename, T2.surname`, and do remove the explicit `T1.min_time_in_seconds` column from the final SELECT instead of including it since it's only used for ordering. The amended query now correctly handles edge cases in time parsing and matches RIGHT_SQL's behavior.",
            "Do remove the NULL handling condition `WHEN time IS NULL OR time = '' THEN NULL` from the CASE expression instead of keeping it, as the RIGHT_SQL assumes valid time data. Do change the time conversion logic to handle milliseconds by adding `CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END` instead of the simpler second-only conversion. Do add `T1.driverId` to the SELECT list instead of omitting it. Do remove the `WHERE time_in_seconds IS NOT NULL` filter from the aggregation subquery instead of keeping it, as the GROUP BY will naturally handle NULL values. The amended query now correctly handles millisecond precision in lap time conversion and includes the driverId in the final output while maintaining the same ranking logic."
        ],
        "rules": [
            "shortest lap time refers to MIN(time); the time format for the shortest lap time is 'MM:SS.mmm' or 'M:SS.mmm'; full name of the driver refers to forename, surname"
        ]
    },
    "787": {
        "sql": [
            "SELECT r.race, a.alignment\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nJOIN alignment a ON s.alignment_id = a.id\nWHERE s.superhero_name = 'Cameron Hicks';"
        ],
        "question": "What are the race and alignment of Cameron Hicks?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race, T3.alignment FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T1.superhero_name = 'Cameron Hicks'",
        "amends": [],
        "rules": [
            "Cameron Hicks refers to superhero_name = 'Cameron Hicks';"
        ]
    },
    "133": {
        "sql": [
            "SELECT A2 AS district_name, A13 AS unemployment_rate FROM district ORDER BY A13 DESC;",
            "SELECT district_id, A2 FROM district WHERE A13 = (SELECT MAX(A13) FROM district) LIMIT 1;"
        ],
        "question": "In 1996, which districts have the highest unemployment rate? List their branch location and district name.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1",
        "amends": [
            "Do select `district_id` and `A2` instead of `A2` and `A13` in the SELECT list. Do remove the alias `AS district_name` for `A2` instead of keeping it. Do remove the alias `AS unemployment_rate` for `A13` instead of keeping it. Do add `LIMIT 1` at the end instead of omitting it to return only the top record. The amended query now correctly returns the district_id and district name for the single record with the highest unemployment rate, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "A2 refers to district names; A13 refers to unemploymant rate in 1996"
        ]
    },
    "879": {
        "sql": [
            "SELECT d.nationality \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nWHERE r.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results);"
        ],
        "question": "For the driver who set the fastest lap speed, what is his nationality?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the fastest lap speed refers to (MAX) fastestLapSpeed;"
        ]
    },
    "526": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'Matthew D. Wilson' \nAND availability = 'paper';"
        ],
        "question": "Among the card designed by Matthew D. Wilson, how many are available only in the paper?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper'",
        "amends": [],
        "rules": [
            "card designed by Matthew D. Wilson refers to artist = 'Matthew D. Wilson'; available only in the paper refers to availability = 'paper'"
        ]
    },
    "1083": {
        "sql": [
            "SELECT p.player_name, pa.overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;",
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t2.overall_rating DESC\nLIMIT 1;"
        ],
        "question": "Which player has the strongest overall strength?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `overall_rating` in the SELECT list. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference the joined table as `t2` instead of `pa` for consistency. Do maintain the same join condition `t1.player_api_id = t2.player_api_id` instead of changing it. Do keep the same ORDER BY clause on `t2.overall_rating DESC` instead of altering it. Do preserve the same LIMIT 1 instead of modifying it. The amended query now correctly returns only the player name of the highest-rated player instead of including the redundant rating value in the output."
        ],
        "rules": [
            "overall strength refers to overall_rating; strongest overall strength refers to MAX(overall_rating);"
        ]
    }
}