{
    "80": {
        "sql": [
            "SELECT s.School, s.Latitude, f.`School Type`\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nORDER BY s.Latitude DESC\nLIMIT 1;",
            "SELECT T1.\"School Type\", T1.\"School Name\", T2.Latitude\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.Latitude DESC\nLIMIT 1;"
        ],
        "question": "What is the school type of the school with the highest latitude? Indicate the name of the school as well as the latitude coordinates.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`School Type`, T1.`School Name`, T2.Latitude FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.Latitude DESC LIMIT 1",
        "amends": [
            "Do select `T1.School Type`, `T1.School Name`, and `T2.Latitude` instead of `s.School`, `s.Latitude`, and `f.School Type`. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do reference `T1.CDSCode = T2.CDSCode` instead of `s.CDSCode = f.CDSCode`. Do order by `T2.Latitude DESC` instead of `s.Latitude DESC`. The amended query now correctly retrieves the school with the highest latitude while maintaining proper table aliases and join conditions to match the intended behavior."
        ],
        "rules": []
    },
    "140": {
        "sql": [
            "SELECT COUNT(*) AS account_count\nFROM account\nJOIN district ON account.district_id = district.district_id\nWHERE district.A2 = 'Pisek';"
        ],
        "question": "How many accounts are there in the district of \"Pisek\"?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Pisek'",
        "amends": [],
        "rules": [
            "A2 refers to district name"
        ]
    },
    "876": {
        "sql": [
            "SELECT COUNT(*) AS drivers_not_finished\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN status s ON r.statusId = s.statusId\nWHERE rc.date = '2015-11-29' AND s.status != 'Finished';"
        ],
        "question": "For the race happened in 2015/11/29, how many drivers did not finish the game?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NULL",
        "amends": [],
        "rules": [
            "game and race are synonyms; drivers who didn't finish the race should have record in time;"
        ]
    },
    "1048": {
        "sql": [
            "SELECT pa.overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Gabriel Tamas' AND strftime('%Y', pa.date) = '2011';"
        ],
        "question": "What is the overall rating of the football player Gabriel Tamas in year 2011?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Gabriel Tamas' AND strftime('%Y', t2.date) = '2011'",
        "amends": [],
        "rules": [
            "in year 2011 refers to strftime('%Y', date) = '2011';"
        ]
    },
    "596": {
        "sql": [
            "SELECT u.Id, u.DisplayName, COUNT(c.Id) AS CommentCount, b.Name AS BadgeName\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nLEFT JOIN badges b ON u.Id = b.UserId\nGROUP BY u.Id, u.DisplayName\nORDER BY CommentCount DESC\nLIMIT 10;",
            "SELECT b.Name\nFROM badges b\nINNER JOIN comments c ON b.UserId = c.UserId\nGROUP BY b.UserId\nORDER BY COUNT(c.UserId) DESC\nLIMIT 1;"
        ],
        "question": "Which users have posted the most comments. List out the user's badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Name FROM badges AS T1 INNER JOIN comments AS T2 ON T1.UserId = t2.UserId GROUP BY T2.UserId ORDER BY COUNT(T2.UserId) DESC LIMIT 1",
        "amends": [
            "Do select only `Name` instead of multiple columns including `u.Id`, `u.DisplayName`, and `CommentCount`. Do use `INNER JOIN` between `badges` and `comments` instead of joining `users` to both tables separately. Do join on `T1.UserId = T2.UserId` instead of joining both tables to `users` via `u.Id = c.UserId` and `u.Id = b.UserId`. Do group by `T2.UserId` instead of grouping by `u.Id` and `u.DisplayName`. Do order by `COUNT(T2.UserId)` descending instead of ordering by `CommentCount` descending. Do limit to `1` result instead of limiting to `10` results. The amended query now correctly finds the badge name for the user with the most comments by directly joining badges and comments tables."
        ],
        "rules": [
            "user with the most comments refers to UserId where Max(Count(Id)"
        ]
    },
    "485": {
        "sql": [
            "SELECT r.date FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Reminisce';"
        ],
        "question": "When was the ruling for the card 'Reminisce' created?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Reminisce'",
        "amends": [],
        "rules": [
            "Reminisce refers to name = 'Reminisce'; when created is the date"
        ]
    },
    "94": {
        "sql": [
            "WITH OldestFemaleClients AS (\n    SELECT c.client_id, c.birth_date, d.account_id, dt.A11 AS avg_salary\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN account a ON d.account_id = a.account_id\n    JOIN district dt ON c.district_id = dt.district_id\n    WHERE c.gender = 'F'\n    ORDER BY c.birth_date ASC\n    LIMIT 1\n),\nSalaryGap AS (\n    SELECT MAX(A11) AS max_salary, MIN(A11) AS min_salary, MAX(A11) - MIN(A11) AS gap\n    FROM district\n)\nSELECT o.account_id, s.gap\nFROM OldestFemaleClients o, SalaryGap s\nWHERE o.avg_salary = s.min_salary;",
            "SELECT \n    T1.account_id,\n    (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM \n    account AS T1\n    INNER JOIN disp AS T2 ON T1.account_id = T2.account_id\n    INNER JOIN client AS T3 ON T2.client_id = T3.client_id\n    INNER JOIN district AS T4 ON T3.district_id = T4.district_id\nWHERE \n    T3.gender = 'F' \n    AND T3.district_id = (\n        SELECT district_id \n        FROM client \n        WHERE gender = 'F' \n        ORDER BY birth_date ASC \n        LIMIT 1\n    )\n    AND T4.A11 = (\n        SELECT MIN(A11) \n        FROM district \n        WHERE district_id IN (\n            SELECT district_id \n            FROM client \n            WHERE gender = 'F' \n            ORDER BY birth_date ASC \n            LIMIT 1\n        )\n    )\nGROUP BY T1.account_id",
            "SELECT \n    T1.account_id,\n    (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM \n    account AS T1\nINNER JOIN \n    district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN \n    disp AS T3 ON T1.account_id = T3.account_id\nINNER JOIN \n    client AS T4 ON T3.client_id = T4.client_id\nWHERE \n    T4.gender = 'F' AND\n    T4.birth_date = (SELECT MIN(birth_date) FROM client WHERE gender = 'F')\nORDER BY \n    T2.A11 ASC\nLIMIT 1;",
            "SELECT \n    T1.account_id,\n    (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM \n    account AS T1\nINNER JOIN \n    district AS T2 ON T1.district_id = T2.district_id\nWHERE \n    T2.district_id = (\n        SELECT district_id \n        FROM client \n        WHERE gender = 'F' \n        ORDER BY birth_date ASC \n        LIMIT 1\n    )\nORDER BY \n    T2.A11 DESC \nLIMIT 1"
        ],
        "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id , ( SELECT MAX(A11) - MIN(A11) FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "amends": [
            "Do use a single query with joins instead of CTEs, and do `INNER JOIN` tables directly on proper foreign keys like `T1.district_id = T2.district_id` instead of joining through multiple CTEs. Do move the oldest female client filter to a subquery in the `WHERE` clause instead of using a separate CTE. Do calculate the salary gap directly in the `SELECT` list with `(SELECT MAX(A11) - MIN(A11) FROM district)` instead of using a separate CTE. Do add proper table aliases like `account AS T1` instead of using full table names. Do change the join condition from `c.client_id = d.client_id` to proper account-based joins like `T1.account_id = T3.account_id`. Do remove the `avg_salary` column reference and instead filter by `district_id` in the WHERE clause. Do add `ORDER BY T2.A11 DESC LIMIT 1` instead of ordering by birth date in a CTE. The amended query now correctly identifies accounts from the district of the oldest female client and returns the salary gap with proper join relationships.",
            "Do join `account` directly with `district` on `district_id` instead of joining through `disp` and `client` tables to reach district. Do remove the `gender = 'F'` filter from the WHERE clause instead of keeping it as a direct condition. Do move the district selection logic to the JOIN condition with `district` instead of using it in WHERE filters. Do remove the subquery checking `A11 = MIN(A11)` for specific districts instead of keeping that redundant filtering. Do add `ORDER BY T2.A11 DESC LIMIT 1` instead of grouping by account_id and omitting ordering. Do remove the GROUP BY clause entirely instead of grouping by account_id. Do simplify the salary gap calculation to use the global district table instead of filtering by specific districts. The amended query now correctly identifies accounts in the target district and selects the one with highest A11 value, matching RIGHT_SQL's behavior.",
            "Do use the `salary_gap` alias instead of omitting it for the subquery result. Do change the WHERE filter to use `T2.district_id = (subquery)` instead of `T4.gender = 'F' AND T4.birth_date = (subquery)`. Do modify the subquery to select `district_id` instead of `MIN(birth_date)` and add `ORDER BY birth_date ASC` instead of just finding the minimum birth date. Do change the ORDER BY direction to `DESC` instead of `ASC` for `T2.A11`. The amended query now correctly identifies the district_id of the oldest female client first, then filters accounts by that district instead of incorrectly trying to match both gender and exact birth date simultaneously, which could return no results if no client has the exact minimum birth date."
        ],
        "rules": [
            "Female means gender = 'F'; A11 refers to average salary; Gap = highest average salary - lowest average salary; If the person A's birthdate > B's birthdate, it means that person B is order than person A."
        ]
    },
    "1364": {
        "sql": [
            "SELECT z.city, z.county, z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Amy' AND m.last_name = 'Firth';"
        ],
        "question": "Where is Amy Firth's hometown?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.city, T2.county, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Amy' AND T1.last_name = 'Firth'",
        "amends": [],
        "rules": [
            "hometown refers to city, county, state"
        ]
    },
    "290": {
        "sql": [
            "SELECT DISTINCT a.element \nFROM atom a \nJOIN molecule m ON a.molecule_id = m.molecule_id \nWHERE m.label = 'TR151' \nAND a.element IN ('cl', 'br', 'f', 'i', 'pb', 'sn', 'te', 'hg');",
            "SELECT element FROM atom WHERE molecule_id = 'TR151' AND element IN ('cl', 'br', 'f', 'i', 'pb', 'sn', 'te', 'hg')",
            "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR151'"
        ],
        "question": "Which toxic element can be found in the molecule TR151?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR151'",
        "amends": [
            "Do remove the `JOIN` with `molecule` table and its `ON a.molecule_id = m.molecule_id` condition instead of keeping the unnecessary join. Do change the `WHERE` filter to directly compare `T.molecule_id = 'TR151'` instead of joining and filtering on `m.label = 'TR151'`. Do remove the `IN` clause filtering elements `('cl', 'br', 'f', 'i', 'pb', 'sn', 'te', 'hg')` instead of keeping the restrictive element filter. Do use table alias `T` instead of `a` for consistency. The amended query now correctly filters atoms by molecule_id directly without the unnecessary join and element restrictions, matching the RIGHT_SQL's behavior.",
            "Do add `DISTINCT` instead of omitting it, and do remove the `IN` filter condition on `element` instead of keeping it, while also adding table alias `T` to the `element` column reference instead of using it unqualified. Do change the `FROM` clause to include table alias `AS T` instead of omitting it. The amended query now correctly returns distinct elements for molecule 'TR151' without the unnecessary element type restrictions."
        ],
        "rules": [
            "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "209": {
        "sql": [
            "SELECT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'cl'\nGROUP BY b.bond_type;"
        ],
        "question": "Chlorine is in what type of bond?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T3.element = 'cl'",
        "amends": [],
        "rules": [
            "type of bond refers to bond_type; chlorine refers to element = 'cl'"
        ]
    },
    "619": {
        "sql": [
            "SELECT COUNT(DISTINCT u.Id) AS AdultSupporters\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE u.Age BETWEEN 19 AND 65\nAND b.Name = 'Supporter';"
        ],
        "question": "How many adults who obtained the badge Supporter?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Supporter' AND T1.Age BETWEEN 19 AND 65",
        "amends": [],
        "rules": [
            "Supporter is the Name of badge; adult refers to Age BETWEEN 19 AND 65"
        ]
    },
    "294": {
        "sql": [
            "SELECT b.bond_id\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE m.label = '+' AND b.bond_type = ' = ';",
            "SELECT T1.bond_id\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '=' AND T2.label = '+'"
        ],
        "question": "Which bond ids are double-bond with carcinogenic compound?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.bond_type = '='",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `b` and `m` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do remove the space around the equals sign in `'='` instead of `' = '` to match the actual data format. Do maintain the same join condition `T1.molecule_id = T2.molecule_id` instead of changing it. The amended query now correctly filters for bonds with type '=' on molecules labeled '+', matching the intended behavior."
        ],
        "rules": [
            "label = '+' mean molecules are carcinogenic; double bond refers to bond_type = ' = ';"
        ]
    },
    "47": {
        "sql": [
            "SELECT COUNT(*) / 12.0 AS monthly_average\nFROM schools\nWHERE County = 'Alameda'\n  AND DOC = '52'\n  AND strftime('%Y', OpenDate) = '1980';"
        ],
        "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
        "amends": [],
        "rules": [
            "Elementary School District refers to DOC = 52; Monthly average number of schools that opened in 1980 = count(schools that opened in 1980) / 12"
        ]
    },
    "1503": {
        "sql": [
            "SELECT p.Description\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE c.Currency = 'Euro';",
            "SELECT DISTINCT T1.ProductID, T3.Description\nFROM transactions_1k T1\nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN products T3 ON T1.ProductID = T3.ProductID\nWHERE T2.Currency = 'EUR'"
        ],
        "question": "Please list the product description of the products bought in transactions in euro.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ProductID, T3.Description FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Currency = 'EUR'",
        "amends": [
            "Do select `DISTINCT T1.ProductID, T3.Description` instead of just `p.Description`. Do use table aliases `T1`, `T2`, and `T3` instead of full table names. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do filter on `T2.Currency = 'EUR'` instead of `c.Currency = 'Euro'` to match the correct currency code format. The amended query now correctly returns distinct product IDs with their descriptions for Euro currency transactions."
        ],
        "rules": []
    },
    "318": {
        "sql": [
            "SELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';"
        ],
        "question": "What is the molecule id of bond id TR001_1_7?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "amends": [],
        "rules": []
    },
    "1239": {
        "sql": [
            "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age\nFROM Patient P\nWHERE P.ID IN (\n    SELECT L.ID\n    FROM Laboratory L\n    WHERE L.HCT >= 52\n    GROUP BY L.ID\n    HAVING COUNT(L.ID) >= 2\n);"
        ],
        "question": "Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )",
        "amends": [],
        "rules": [
            "age = SUBTRACT(year(current_timestamp), year(Birthday)); patient with two or more laboratory examinations refers to COUNT(ID) > 2; hematoclit level exceeded the normal range refers to HCT > = 52;"
        ]
    },
    "1492": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN c.Currency = 'EUR' THEN 1 END) * 100.0 / COUNT(*)) AS Percentage_KAM_EUR\nFROM \n    customers c\nWHERE \n    c.Segment = 'KAM';"
        ],
        "question": "What percentage of KAM customers pay in euros?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(Currency = 'EUR') AS FLOAT) * 100 / COUNT(CustomerID) FROM customers WHERE Segment = 'KAM'",
        "amends": [],
        "rules": [
            "Percentage of KAM uses Euro = (Total of KAM uses Euro / Total of KAM) * 100%."
        ]
    },
    "138": {
        "sql": [
            "WITH SecondHighestCrimeDistrict AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A15 DESC\n    LIMIT 1 OFFSET 1\n)\nSELECT COUNT(*) AS male_clients_count\nFROM client\nWHERE gender = 'M' AND district_id = (SELECT district_id FROM SecondHighestCrimeDistrict);"
        ],
        "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
        "amends": [],
        "rules": [
            "Male refers to gender = 'M'; A15 stands for no. of commited crimes 1995"
        ]
    },
    "106": {
        "sql": [
            "SELECT MAX(t.amount) AS biggest_transaction_amount\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN card cd ON d.disp_id = cd.disp_id\nWHERE cd.issued = '1996-10-21';"
        ],
        "question": "What is the biggest amount of transaction that the client whose card was opened in 1996/10/21 made?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.amount FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 on T2.account_id = T3.account_id JOIN trans AS T4 on T3.account_id = T4.account_id WHERE T1.issued = '1996-10-21' ORDER BY T4.amount DESC LIMIT 1",
        "amends": [],
        "rules": []
    },
    "831": {
        "sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.superhero_name = 'Abomination';"
        ],
        "question": "What is Abomination's eye colour?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Abomination'",
        "amends": [],
        "rules": [
            "Abomination refers to superhero_name = 'Abomination'; eye colour refers to colour.colour where eye_colour_id = colour.id;"
        ]
    },
    "1308": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.PLT > 100 AND L.PLT < 400 \nAND P.Diagnosis IS NOT NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.PLT BETWEEN 150 AND 450\nAND T1.Diagnosis IS NOT NULL",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.PLT > 100 AND T2.PLT < 400\nAND T1.Diagnosis IS NOT NULL"
        ],
        "question": "Among the patients who have a normal platelet level, how many of them have other symptoms observed?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 100 AND T2.PLT < 400 AND T1.Diagnosis IS NOT NULL",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do reference `T2.PLT` instead of `L.PLT` in the WHERE clause to match the table alias change. Do reference `T1.Diagnosis` instead of `P.Diagnosis` to maintain alias consistency. The amended query now correctly counts all patient records meeting the criteria rather than distinct patient IDs, matching the RIGHT_SQL's behavior.",
            "Do change the PLT filter to `PLT > 100 AND PLT < 400` instead of `PLT BETWEEN 150 AND 450` to use open intervals rather than closed range boundaries. The amended query now correctly counts patients with platelet counts strictly between 100 and 400 rather than the inclusive 150-450 range, matching the intended logic."
        ],
        "rules": [
            "normal platelet level refers to PLT > 100 and PLT < 400; have other symptoms refers to Diagnosis is not null;"
        ]
    },
    "692": {
        "sql": [
            "SELECT \n    b.Name AS BadgeName, \n    b.Date AS BadgeDate, \n    u.CreationDate AS AccountCreationDate, \n    julianday(b.Date) - julianday(u.CreationDate) AS DaysToGetBadge\nFROM \n    badges b\nJOIN \n    users u ON b.UserId = u.Id\nWHERE \n    u.DisplayName = 'Zolomon'\nORDER BY \n    b.Date;",
            "SELECT T1.Date - T2.CreationDate FROM badges T1 INNER JOIN users T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'"
        ],
        "question": "How long did it take the user, known by his or her display name 'Zolomon' to get the badge? Count from the date the user's account was created.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Date - T2.CreationDate FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'",
        "amends": [
            "Do use `T1.Date - T2.CreationDate` for date subtraction instead of `julianday(b.Date) - julianday(u.CreationDate)` with julianday conversion. Do use table aliases `T1` and `T2` instead of `b` and `u`. Do remove the explicit column aliases `BadgeName`, `BadgeDate`, `AccountCreationDate`, and `DaysToGetBadge` instead of keeping them. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do remove the `ORDER BY b.Date` clause instead of including it. The amended query now correctly performs direct date subtraction and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "SUBTRACT(Date from stats_badges, CreationDate) where DisplayName = 'Zolomon';"
        ]
    },
    "483": {
        "sql": [
            "SELECT c.name AS card_name, fd.text AS italian_ruling_text\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE s.name = 'Coldsnap' AND fd.language = 'Italian';",
            "SELECT DISTINCT T1.text\nFROM foreign_data T1\nINNER JOIN cards T2 ON T2.uuid = T1.uuid\nINNER JOIN sets T3 ON T3.code = T2.setCode\nWHERE T1.language = 'Italian' AND T3.code = 'Coldsnap'",
            "SELECT DISTINCT T1.text\nFROM foreign_data T1\nINNER JOIN cards T2 ON T2.uuid = T1.uuid\nINNER JOIN sets T3 ON T3.code = T2.setCode\nWHERE T1.language = 'Italian' AND T3.name = 'Coldsnap'"
        ],
        "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
        "amends": [
            "Do select only `T1.text` instead of `c.name` and `fd.text` with aliases. Do use `INNER JOIN` for both joins instead of `JOIN` (which is equivalent but explicit). Do join `cards` to `foreign_data` on `T2.uuid = T1.uuid` instead of `c.uuid = fd.uuid`, maintaining the same logic. Do join `sets` on `T3.code = T2.setCode` instead of `c.setCode = s.code`, preserving the relationship. Do add `DISTINCT` to eliminate duplicate rows instead of potentially returning multiple identical entries. Do remove the column aliases `card_name` and `italian_ruling_text` since only one column is selected. The amended query now correctly returns distinct Italian ruling texts for Coldsnap cards, matching the RIGHT_SQL's behavior.",
            "Do filter on `T3.name = 'Coldsnap'` instead of `T3.code = 'Coldsnap'` to correctly identify the set by name rather than code. Do maintain the `SELECT DISTINCT T1.text` clause and the join structure with `INNER JOIN cards T2 ON T2.uuid = T1.uuid` and `INNER JOIN sets T3 ON T3.code = T2.setCode` as they remain unchanged. Do keep the `T1.language = 'Italian'` filter in the WHERE clause. The amended query now correctly matches the RIGHT_SQL's behavior by filtering on the set name rather than code."
        ],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'"
        ]
    },
    "426": {
        "sql": [
            "SELECT name FROM sets WHERE mtgoCode IS NULL OR mtgoCode = '' ORDER BY name ASC LIMIT 3;"
        ],
        "question": "Please provide top three sets that don't appear in Magic: The Gathering Online, along with their names in in alphabetical order.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3",
        "amends": [],
        "rules": [
            "don't appear in Magic: The Gathering Online refers to mtgoCode is NULL or mtgoCode = ''"
        ]
    },
    "1013": {
        "sql": [
            "SELECT MIN(r.fastestLapTime) AS lapRecord\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN circuits c ON rc.circuitId = c.circuitId\nWHERE c.name = 'Austrian Grand Prix Circuit';",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.circuitId,\n        r.name AS race_name,\n        res.fastestLapTime\n    FROM \n        results res\n    INNER JOIN \n        races r ON res.raceId = r.raceId\n    WHERE \n        res.fastestLapTime IS NOT NULL\n)\nSELECT \n    MIN(fastest_lap_times.fastestLapTime) AS lap_record\nFROM \n    fastest_lap_times\nINNER JOIN \n    races T2 ON fastest_lap_times.raceId = T2.raceId\nINNER JOIN \n    circuits c ON T2.circuitId = c.circuitId\nWHERE \n    T2.name = 'Austrian Grand Prix';"
        ],
        "question": "What is the lap record for the Austrian Grand Prix Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.fastestLapTime FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL) SELECT MIN(fastest_lap_times.fastestLapTime) as lap_record FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix'",
        "amends": [
            "Do add a CTE `fastest_lap_times` that filters for `fastestLapTime IS NOT NULL` instead of querying the raw results table directly. Do change the join condition from `r.raceId = rc.raceId` to `fastest_lap_times.raceId = T2.raceId` with proper table aliasing. Do modify the WHERE clause to filter on `T2.name = 'Austrian Grand Prix'` instead of `c.name = 'Austrian Grand Prix Circuit'` to match the correct circuit naming convention. Do use `INNER JOIN` consistently instead of mixing `JOIN` syntax. The amended query now correctly handles NULL fastest lap times and uses the proper circuit name filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "lap record means the fastest time recorded which refers to time"
        ]
    },
    "995": {
        "sql": [
            "SELECT AVG(r.points) AS average_score\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.name LIKE '%Turkish Grand Prix%'\nAND d.forename = 'Lewis' AND d.surname = 'Hamilton';",
            "SELECT AVG(ds.points) FROM driverStandings ds INNER JOIN drivers d ON ds.driverId = d.driverId INNER JOIN races r ON ds.raceId = r.raceId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' AND r.name = 'Turkish Grand Prix'"
        ],
        "question": "What is the average score of Lewis Hamilton among all the Turkish Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T3.name = 'Turkish Grand Prix'",
        "amends": [
            "Do join `driverStandings` instead of `results` as the source for `points` data. Do use `INNER JOIN` on `drivers` to `driverStandings` via `driverId` instead of joining `results` to `drivers`. Do join `races` to `driverStandings` via `raceId` instead of joining `races` to `results`. Do use exact equality `T3.name = 'Turkish Grand Prix'` instead of pattern matching with `LIKE '%Turkish Grand Prix%'`. Do remove the `AS average_score` alias instead of keeping it. The amended query now correctly calculates Lewis Hamilton's average points from driver standings rather than race results, matching the intended behavior."
        ],
        "rules": [
            "Average score = AVG(points)"
        ]
    },
    "984": {
        "sql": [
            "SELECT c.url\nFROM constructors c\nJOIN (\n    SELECT constructorId, SUM(wins) AS total_wins\n    FROM constructorStandings\n    GROUP BY constructorId\n    ORDER BY total_wins DESC\n    LIMIT 1\n) AS max_wins ON c.constructorId = max_wins.constructorId;",
            "SELECT T1.url \nFROM constructors AS T1\nINNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId\nORDER BY T2.wins DESC\nLIMIT 1"
        ],
        "question": "What is the website of the constructor who tallied the most total wins.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1",
        "amends": [
            "Do select `T1.url` instead of `c.url` and use table aliases `T1` and `T2` instead of `c` and subquery aliases. Do use a direct `INNER JOIN` on `constructorStandings AS T2` instead of joining with a subquery that calculates `SUM(wins)`. Do join on `T1.constructorId = T2.constructorId` instead of joining with a subquery result. Do remove the unnecessary aggregation `SUM(wins)` and grouping `GROUP BY constructorId` instead of keeping them. Do order by `T2.wins DESC` directly instead of ordering by the calculated `total_wins DESC`. Do keep the `LIMIT 1` but apply it after the join instead of within a subquery. The amended query now correctly retrieves the constructor URL by joining directly with constructor standings and ordering by wins to find the top constructor, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "introduction website refers to url;"
        ]
    },
    "516": {
        "sql": [
            "SELECT COUNT(DISTINCT c.id) \nFROM cards c \nJOIN foreign_data fd ON c.uuid = fd.uuid \nWHERE c.artist = 'Volkan Ba\u01f5a' AND fd.language = 'French';"
        ],
        "question": "How many cards did Volkan Ba\u00c7\u00b5a illustrated whose foreign language is in French?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.id) FROM ( SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Ba\u01f5a' AND T2.language = 'French' GROUP BY T1.id ) AS T3",
        "amends": [],
        "rules": [
            "Volkan Ba\u00c7\u00b5a refers to artist = 'Volkan Ba\u01f5a'; foreign language is in French refers to language = 'French'"
        ]
    },
    "75": {
        "sql": [
            "SELECT `School Name`, `Educational Option Type` FROM frpm WHERE `County Code` = '37' AND `NSLP Provision Status` = '2';",
            "SELECT T2.School, T2.EILName \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T1.\"NSLP Provision Status\" = 'Breakfast Provision 2' \nAND T1.\"County Code\" = 37;",
            "SELECT T2.EILName, T2.School\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2'\nAND T1.`County Code` = 37"
        ],
        "question": "What is the educational level name for the schools with Breakfast Provision 2 in county code 37? Indicate the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.EILName, T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2' AND T1.`County Code` = 37",
        "amends": [
            "Do select `T2.EILName` and `T2.School` instead of `School Name` and `Educational Option Type`. Do join `schools AS T2` with `frpm AS T1` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `frpm` table. Do filter on `T1.NSLP Provision Status = 'Breakfast Provision 2'` instead of `'2'` and use numeric value `37` instead of string `'37'` for the county code. The amended query now correctly joins school data and uses proper value formats to match the intended logic.",
            "Do reverse the column order in the SELECT list to `T2.EILName, T2.School` instead of `T2.School, T2.EILName`. Do use backticks for column names `NSLP Provision Status` and `County Code` instead of double quotes to ensure proper identifier quoting. End with confirmation that the amended query now correctly selects columns in the specified order and uses proper identifier quoting for the WHERE clause conditions."
        ],
        "rules": []
    },
    "1454": {
        "sql": [
            "SELECT (SUM(e.cost) / COUNT(DISTINCT ev.event_id)) * 100 AS percentage_cost\nFROM event ev\nJOIN budget b ON ev.event_id = b.link_to_event\nJOIN expense e ON b.budget_id = e.link_to_budget\nWHERE ev.type = 'Meeting';",
            "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) FROM event T1 INNER JOIN budget T2 ON T1.event_id = T2.link_to_event INNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget;"
        ],
        "question": "What is the percentage of the cost for the meeting events?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "amends": [
            "Do calculate `SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost)` instead of `(SUM(e.cost) / COUNT(DISTINCT ev.event_id)) * 100` to properly compute the percentage of meeting costs relative to total costs. Do use `INNER JOIN` consistently instead of mixing `JOIN` and `INNER JOIN` syntax. Do reference tables with aliases `T1`, `T2`, and `T3` instead of `ev`, `b`, and `e` for clarity. Do move the `type = 'Meeting'` filter from the `WHERE` clause into a `CASE` expression instead of filtering rows before aggregation. Do remove the `DISTINCT` count and unnecessary division by event count instead of including it in the calculation. Do eliminate the column alias `percentage_cost` instead of keeping it since the result is a single value. The amended query now correctly calculates the percentage of meeting-related expenses relative to all expenses."
        ],
        "rules": [
            "meeting events refers to type = 'Meeting'; percentage = DIVIDE( SUM(cost), COUNT(event_id)) * 100"
        ]
    },
    "1185": {
        "sql": [
            "WITH November_TCHO AS (\n    SELECT SUM(`T-CHO`) AS sum_nov\n    FROM Laboratory\n    WHERE ID IN (SELECT ID FROM Patient WHERE Birthday = '1959-02-18')\n    AND Date LIKE '1981-11-%'\n),\nDecember_TCHO AS (\n    SELECT SUM(`T-CHO`) AS sum_dec\n    FROM Laboratory\n    WHERE ID IN (SELECT ID FROM Patient WHERE Birthday = '1959-02-18')\n    AND Date LIKE '1981-12-%'\n)\nSELECT \n    CASE \n        WHEN November_TCHO.sum_nov IS NULL OR December_TCHO.sum_dec IS NULL THEN 'Insufficient data'\n        ELSE ((November_TCHO.sum_nov - December_TCHO.sum_dec) / November_TCHO.sum_nov * 100) || '%'\n    END AS decrease_rate\nFROM November_TCHO, December_TCHO;",
            "SELECT \n    (November_sum - December_sum) / CAST(December_sum AS REAL) * 100 AS decrease_rate\nFROM (\n    SELECT \n        SUM(CASE WHEN strftime('%m', Date) = '11' AND strftime('%Y', Date) = '1981' THEN \"T-CHO\" ELSE 0 END) AS November_sum,\n        SUM(CASE WHEN strftime('%m', Date) = '12' AND strftime('%Y', Date) = '1981' THEN \"T-CHO\" ELSE 0 END) AS December_sum\n    FROM Laboratory\n    INNER JOIN Patient ON Laboratory.ID = Patient.ID\n    WHERE Patient.Birthday = '1959-02-18'\n)",
            "SELECT \n    (SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - \n     SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) / \n    CAST(SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) AS REAL) AS decrease_rate\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Birthday = '1959-02-18'"
        ],
        "question": "For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) AS REAL) / SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-02-18'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for each month. Do add `INNER JOIN` between `Patient` and `Laboratory` on `T1.ID = T2.ID` instead of using subqueries for patient filtering. Do move the patient birthday filter to the `WHERE` clause instead of using `INNER` subqueries. Do calculate the percentage decrease using `(November_sum - December_sum) / December_sum` instead of `(November_sum - December_sum) / November_sum` to show the correct relative decrease from December's baseline. Do use `CAST(... AS REAL)` for proper division instead of string concatenation with percentage sign. Do remove the `CASE` statement for 'Insufficient data' and handle nulls through the division logic instead. The amended query now correctly calculates the percentage decrease of T-CHO values from November to December 1981 for patients born on 1959-02-18.",
            "Do calculate the percentage decrease as `(November_sum - December_sum) / December_sum` instead of `(November_sum - December_sum) / December_sum * 100` to avoid incorrect percentage scaling. Do use direct date pattern matching with `LIKE '1981-11-%'` instead of `strftime('%m', Date)` functions for month extraction. Do place the aggregation directly in the main query instead of using a subquery for the sums. Do reference the Laboratory table directly as `T2.`T-CHO`` instead of using the table-qualified column name. Do remove the unnecessary multiplication by 100 since the division already produces the correct ratio. Do maintain the `INNER JOIN` on `T1.ID = T2.ID` instead of `Laboratory.ID = Patient.ID` for proper table correlation. Do keep the filter on `T1.Birthday = '1959-02-18'` unchanged. The amended query now correctly calculates the ratio of November to December T-CHO values for patients born on 1959-02-18."
        ],
        "rules": [
            "born on 1959/2/18 refers to Birthday = '1959-02-18'; calculation = SUBTRACT(SUM(Birthday = '1959-02-18' and Date like '1981-11-%' THEN `T-CHO`), SUM(Birthday = '1959-02-18' and Date like '1981-12-%' THEN `T-CHO`))"
        ]
    },
    "644": {
        "sql": [
            "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images';"
        ],
        "question": "Provide the last edit date and last edit user ID for the post \"Detecting a given face in a database of facial images\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images'",
        "amends": [],
        "rules": [
            "Title = 'Detecting a given face in a database of facial images';"
        ]
    },
    "205": {
        "sql": [
            "SELECT DISTINCT a.molecule_id FROM atom a WHERE a.element = 'c';"
        ],
        "question": "Identify by their ID the molecules in which there is carbon.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM atom AS T WHERE T.element = 'c'",
        "amends": [],
        "rules": [
            "carbon refers to element = 'c';"
        ]
    },
    "648": {
        "sql": [
            "SELECT u.DisplayName, u.WebsiteUrl \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE p.FavoriteCount > 150;"
        ],
        "question": "Provide the users' display names and available website URLs of the post with favorite count of more than 150.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName, T1.WebsiteUrl FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.FavoriteCount > 150",
        "amends": [],
        "rules": [
            "favorite count of more than 150 refers to FavoriteCount > 150;"
        ]
    },
    "194": {
        "sql": [
            "SELECT c.client_id, (strftime('%Y', 'now') - strftime('%Y', c.birth_date)) - (strftime('%m-%d', 'now') < strftime('%m-%d', c.birth_date)) AS age\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card cd ON d.disp_id = cd.disp_id\nWHERE cd.type = 'gold' AND d.type = 'OWNER';",
            "SELECT \n    T3.client_id,\n    STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) AS age\nFROM \n    disp AS T1\nINNER JOIN \n    card AS T2 ON T2.disp_id = T1.disp_id\nINNER JOIN \n    client AS T3 ON T1.client_id = T3.client_id\nINNER JOIN \n    loan AS T4 ON T1.account_id = T4.account_id\nWHERE \n    T2.type = 'gold' AND \n    T1.type = 'OWNER' AND \n    T4.status = 'A'",
            "SELECT T3.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) AS age\nFROM disp AS T1\nINNER JOIN card AS T2 ON T2.disp_id = T1.disp_id\nINNER JOIN client AS T3 ON T1.client_id = T3.client_id\nWHERE T2.type = 'gold' AND T1.type = 'OWNER'"
        ],
        "question": "Provide the IDs and age of the client with high level credit card, which is eligible for loans.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'",
        "amends": [
            "Do calculate age using `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date)` instead of the complex birthday adjustment formula with `strftime('%Y', 'now') - strftime('%Y', c.birth_date)) - (strftime('%m-%d', 'now') < strftime('%m-%d', c.birth_date))`. Do use table aliases `T1`, `T2`, and `T3` instead of `c`, `d`, and `cd`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do join `card AS T2` on `T2.disp_id = T1.disp_id` instead of `cd ON d.disp_id = cd.disp_id`. Do join `client AS T3` on `T1.client_id = T3.client_id` instead of starting with client table. Do reference `T2.type` and `T1.type` in WHERE clause instead of `cd.type` and `d.type`. Do remove the age calculation adjustment for exact birthday comparison instead of keeping it. The amended query now correctly calculates age without the complex birthday adjustment and follows proper join relationships.",
            "Do remove the `INNER JOIN loan AS T4 ON T1.account_id = T4.account_id` and its associated `T4.status = 'A'` filter instead of including them, as the right query does not require loan data. Do keep the `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date)` age calculation without an alias instead of aliasing it as `age`. The amended query now correctly focuses only on clients with gold cards who are account owners, matching the right SQL's behavior."
        ],
        "rules": [
            "the credit card is high-level refers to card.type = 'gold'; eligible for loans refers to disp.type = 'OWNER'"
        ]
    },
    "1440": {
        "sql": [
            "SELECT m.email\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost > 20\nAND e.expense_date BETWEEN '2019-09-10' AND '2019-11-19';"
        ],
        "question": "List emails of people who paid more than 20 dollars from 9/10/2019 to 11/19/2019.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.email FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE date(SUBSTR(T2.expense_date, 1, 10)) BETWEEN '2019-09-10' AND '2019-11-19' AND T2.cost > 20",
        "amends": [],
        "rules": [
            "expense_date BETWEEN '2019-09-10' and '2019-11-19'; cost > 20"
        ]
    },
    "102": {
        "sql": [
            "SELECT DISTINCT a.account_id\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nWHERE strftime('%Y', a.date) < '1997'\nAND t.balance > 3000;",
            "SELECT DISTINCT T1.account_id\nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE T1.amount > 3000\nAND STRFTIME('%Y', T2.date) < '1997'"
        ],
        "question": "State different accounts who have account opening date before 1997 and own an amount of money greater than 3000USD",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) < '1997' AND T1.amount > 3000",
        "amends": [
            "Do reference `account_id` from the `trans` table instead of the `account` table in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` for `trans` and `T2` for `account` instead of implicit aliases `a` and `t`. Do filter on `T1.amount > 3000` instead of `t.balance > 3000` to use the correct column name. Do apply the date filter using `STRFTIME('%Y', T2.date) < '1997'` on the account table's date column instead of the original approach. The amended query now correctly identifies accounts with transactions over 3000 amount before 1997, matching the intended behavior."
        ],
        "rules": []
    },
    "544": {
        "sql": [
            "SELECT u.DisplayName \nFROM posts p \nJOIN users u ON p.LastEditorUserId = u.Id \nWHERE p.Title = 'Examples for teaching: Correlation does not mean causation';"
        ],
        "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'",
        "amends": [],
        "rules": [
            "\"Examples for teaching: Correlation does not mean causation\" is the Title of post; user who last edited refers to LastEditorUserId"
        ]
    },
    "312": {
        "sql": [
            "SELECT m.label \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.bond_id = 'TR001_2_4';"
        ],
        "question": "What is the carcinogenic label for bond TR001_2_4?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic"
        ]
    },
    "1445": {
        "sql": [
            "SELECT first_name || ' ' || last_name AS full_name FROM member WHERE t_shirt_size = 'X-Large';",
            "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large'"
        ],
        "question": "Find the full name of members whose t-shirt size is extra large.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large'",
        "amends": [
            "Do select `first_name` and `last_name` as separate columns instead of concatenating them with `|| ' ' ||` into a single `full_name` alias. The WHERE clause remains unchanged with the filter `t_shirt_size = 'X-Large'` applied to the member table. The amended query now returns the individual name components rather than a combined string, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "full name refers to first_name, last_name; t_shirt_size = 'X-Large'"
        ]
    },
    "479": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nJOIN sets ON cards.setCode = sets.code \nWHERE sets.name = 'Coldsnap' \nAND cards.convertedManaCost > 5 \nAND (cards.power = '*' OR cards.power IS NULL);"
        ],
        "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
        "amends": [],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; converted mana cost higher than 5 refers to convertedManaCost > 5; unknown power refers to power = '*' or T1.power is null"
        ]
    },
    "1075": {
        "sql": [
            "SELECT p.player_name, pa.balance, pa.potential\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.balance = (SELECT MAX(balance) FROM Player_Attributes)\nAND pa.potential = 61;",
            "SELECT p.player_name \nFROM Player p\nINNER JOIN Player_Attributes t1 ON p.player_api_id = t1.player_api_id\nINNER JOIN Player_Attributes t2 ON p.player_api_id = t2.player_api_id\nWHERE t1.potential = '61'\nORDER BY t2.balance DESC\nLIMIT 1;",
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.potential = '61'\nORDER BY t2.balance DESC\nLIMIT 1"
        ],
        "question": "List all the football player with the highest balance score and potential score of 61.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = '61' ORDER BY t2.balance DESC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `balance` and `potential`. Do use `INNER JOIN` with table aliases `t1` and `t2` instead of `JOIN` without aliases. Do change the WHERE condition to filter on `potential = '61'` with string comparison instead of numeric `61` and remove the subquery for maximum balance. Do add `ORDER BY balance DESC` and `LIMIT 1` instead of trying to match the maximum balance directly. Do remove the subquery that was incorrectly attempting to find maximum balance across all records. The amended query now correctly finds the player with the highest balance among those with potential '61' instead of potentially returning multiple rows or incorrect results.",
            "Do reference `t1.player_name` instead of `p.player_name` to align with the table alias used in the FROM clause. Do remove the redundant second `INNER JOIN` on `Player_Attributes` instead of keeping the duplicate join that serves no purpose. Do use `t2.potential` in the WHERE clause instead of `t1.potential` since only one Player_Attributes table is now joined. Do maintain the `ORDER BY t2.balance DESC` and `LIMIT 1` as they correctly identify the top record by balance. The amended query now correctly joins Player to Player_Attributes once and filters on potential while ordering by balance to match the intended behavior."
        ],
        "rules": [
            "balance score refers to balance; highest balance score refers to MAX(balance); potential score refers to potential; potential = 61;"
        ]
    },
    "27": {
        "sql": [
            "SELECT s.School AS \"School Name\", sc.AvgScrWrite AS \"Average Writing Score\", s.Phone AS \"Communication Number\"\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE (s.OpenDate > '1991-12-31' OR s.ClosedDate < '2000-01-01')\nAND sc.AvgScrWrite IS NOT NULL\nORDER BY s.School;",
            "SELECT T2.School, T1.AvgScrWrite, T2.Phone\nFROM satscores T1\nLEFT JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
            "SELECT T2.School, T1.AvgScrWrite, T2.Phone\nFROM schools AS T2\nLEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds\nWHERE (strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000')"
        ],
        "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
        "amends": [
            "Do use `LEFT JOIN` instead of `JOIN` to preserve all schools records regardless of SAT score availability. Do reference tables with aliases `T1` and `T2` instead of `s` and `sc` for clarity. Do remove the column aliases \"School Name\", \"Average Writing Score\", and \"Communication Number\" instead of keeping them. Do change the date filter to use `strftime('%Y', T2.OpenDate) > '1991'` and `strftime('%Y', T2.ClosedDate) < '2000'` instead of comparing full date strings to handle year comparisons properly. Do remove the `AND sc.AvgScrWrite IS NOT NULL` condition instead of keeping it to include all schools regardless of whether they have SAT scores. Do remove the `ORDER BY` clause instead of including it. The amended query now correctly returns all schools meeting the date criteria while preserving those without SAT scores through the left join.",
            "Do use `schools AS T2` as the left table in the `LEFT JOIN` instead of `satscores T1` to preserve all schools records. Do reverse the join condition to `T2.CDSCode = T1.cds` instead of `T1.cds = T2.CDSCode` for proper left join semantics. Do remove the unnecessary table alias prefixes from the SELECT list since they are unambiguous. The amended query now correctly returns all schools meeting the date criteria while preserving those without matching SAT scores through the left join, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "Communication number refers to phone number."
        ]
    },
    "845": {
        "sql": [
            "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.height_cm > (SELECT 0.8 * AVG(height_cm) FROM superhero);"
        ],
        "question": "List the power of superheroes with height greater than 80% of the average height of all superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm * 100 > ( SELECT AVG(height_cm) FROM superhero ) * 80",
        "amends": [],
        "rules": [
            "power of superheroes refers to power_name; height greater than 80% of the average height of all superheroes = height_cm > MULTIPLY(AVG(height_cm), 0.8);"
        ]
    },
    "903": {
        "sql": [
            "SELECT COUNT(*) AS win_count\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nJOIN races ra ON r.raceId = ra.raceId\nJOIN circuits c ON ra.circuitId = c.circuitId\nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher'\nAND c.name = 'Sepang International Circuit'\nAND r.position = 1;",
            "SELECT SUM(T2.wins) AS total_wins\nFROM drivers AS T1\nJOIN driverStandings AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nJOIN circuits AS T4 ON T3.circuitId = T4.circuitId\nWHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher'\nAND T4.name = 'Sepang International Circuit';"
        ],
        "question": "How many times did Michael Schumacher won from races hosted in Sepang International Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.wins) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId INNER JOIN circuits AS T4 ON T4.circuitId = T3.circuitId WHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher' AND T4.name = 'Sepang International Circuit'",
        "amends": [
            "Do use `SUM(T2.wins)` instead of `COUNT(*)` to aggregate actual win counts from standings data rather than counting individual race results. Do join `driverStandings AS T2` instead of `results r` to access pre-calculated win statistics rather than raw position data. Do reference `T2.wins` column instead of filtering `r.position = 1` to directly use the aggregated win count. Do remove the `r.position = 1` filter condition instead of keeping it since the win count is now sourced from standings data. Do maintain the same join structure with drivers, races, and circuits tables but with different table aliases (T1, T3, T4 instead of d, ra, c). The amended query now correctly calculates Michael Schumacher's total wins at Sepang International Circuit using the driver standings data instead of attempting to count individual race results."
        ],
        "rules": [
            "win from races refers to max(points)"
        ]
    },
    "1247": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' \nAND L.WBC > 3.5 AND L.WBC < 9.0 \nAND (L.FG <= 150 OR L.FG >= 450);",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC BETWEEN 4.0 AND 10.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.FG <= 150 OR T2.FG >= 450\nAND T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0"
        ],
        "question": "Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'",
        "amends": [
            "Do use `T1` and `T2` table aliases instead of `P` and `L` for consistency. Do place the `FG` condition first in the WHERE clause instead of last, maintaining the same logical OR operation between `T2.FG <= 150` and `T2.FG >= 450`. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do remove the parentheses around the FG condition since operator precedence makes them unnecessary. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and results.",
            "Do use `T2.WBC > 3.5 AND T2.WBC < 9.0` instead of `T2.WBC BETWEEN 4.0 AND 10.0` for the WBC range filter. Do change the logical grouping by removing parentheses around `T2.FG <= 150 OR T2.FG >= 450` instead of keeping them, allowing proper operator precedence with the AND conditions. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.SEX = 'M'` filter without changes. The amended query now correctly implements the intended logic with adjusted WBC thresholds and proper condition grouping to match the RIGHT_SQL's behavior.",
            "Do use parentheses to properly group the `OR` condition `(T2.FG <= 150 OR T2.FG >= 450)` instead of applying it without grouping, which would incorrectly combine with the `AND` conditions due to operator precedence. Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` clause, `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` join structure, and all filter conditions including `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0`, and the FG range check, but ensure the logical grouping preserves the intended OR relationship between the FG thresholds. The amended query now correctly counts distinct male patients with WBC values between 3.5 and 9.0 and FG values either \u2264150 or \u2265450, matching the RIGHT_SQL's behavior.",
            "Do use the correct operator precedence with parentheses around `T2.FG <= 150 OR T2.FG >= 450` instead of incorrectly grouping it, and maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and all filter conditions including `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0`, and the FG range check. The amended query now correctly evaluates the logical conditions and matches RIGHT_SQL's behavior.",
            "Do use parentheses to properly group the `OR` condition `T2.FG <= 150 OR T2.FG >= 450` instead of having it incorrectly grouped with the `AND` conditions, which changes the logical evaluation order. Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` clause, `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` join structure, and all individual filter conditions including `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0`, and the FG range check, but with corrected operator precedence. The amended query now correctly evaluates the logical conditions to match the intended behavior.",
            "Do move the `T2.FG <= 150 OR T2.FG >= 450` condition to the beginning of the WHERE clause instead of placing it at the end, and do remove the parentheses around the FG condition instead of keeping them, while maintaining all other elements including the `COUNT(DISTINCT T1.ID)`, `INNER JOIN` on `T1.ID = T2.ID`, and the remaining filters `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0` unchanged. The amended query now matches RIGHT_SQL's behavior by preserving the same logical conditions while adjusting the syntax structure."
        ],
        "rules": [
            "male patients refers to Sex = 'M'; normal level of white blood cells refers to WBC > 3.5 and WBC <9.0; abnormal fibrinogen level refers to FG < = 150 or FG > = 450; Don't compute repetitive ones."
        ]
    },
    "211": {
        "sql": [
            "SELECT c.atom_id, c.atom_id2, c.bond_id\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nJOIN molecule m ON a1.molecule_id = m.molecule_id\nWHERE m.label = '-';",
            "SELECT DISTINCT T1.atom_id\nFROM atom AS T1\nJOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nJOIN connected AS T3 ON T1.atom_id = T3.atom_id\nWHERE T2.label = '-'"
        ],
        "question": "Indicate which atoms are connected in non-carcinogenic type molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.label = '-'",
        "amends": [
            "Do select only `T1.atom_id` instead of multiple columns `c.atom_id, c.atom_id2, c.bond_id`. Do use `DISTINCT` instead of omitting it to eliminate duplicates. Do reference tables with aliases `T1, T2, T3` instead of `c, a1, a2, m`. Do join `atom AS T1` directly to `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of joining through multiple atom tables. Do join `connected AS T3` on `T1.atom_id = T3.atom_id` instead of joining both atom_id and atom_id2 to separate atom tables. Do apply the filter `T2.label = '-'` directly instead of the same condition. Do remove the unnecessary second atom table join and bond_id column selection. The amended query now correctly returns distinct atom IDs from molecules labeled '-' that have connections, matching the intended behavior."
        ],
        "rules": [
            "label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1220": {
        "sql": [
            "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.UN = 29;"
        ],
        "question": "Provide all ID, sex and birthday of patients whose urea nitrogen (UN) just within the borderline of passing?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN = 29",
        "amends": [],
        "rules": [
            "urea nitrogen (UN) just within the borderline of passing refers to UN = 29; "
        ]
    },
    "1458": {
        "sql": [
            "WITH total_members AS (\n    SELECT COUNT(*) AS total FROM member\n),\nnew_jersey_members AS (\n    SELECT COUNT(*) AS nj_count\n    FROM member\n    JOIN zip_code ON member.zip = zip_code.zip_code\n    WHERE zip_code.short_state = 'NJ'\n),\nvermont_members AS (\n    SELECT COUNT(*) AS vt_count\n    FROM member\n    JOIN zip_code ON member.zip = zip_code.zip_code\n    WHERE zip_code.short_state = 'VT'\n)\nSELECT \n    ((nj_count * 100.0 / total) - (vt_count * 100.0 / total)) AS percentage_difference\nFROM total_members, new_jersey_members, vermont_members;"
        ],
        "question": "Calculate the difference in the percentage of members in New Jersey and Vermont.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.member_id) AS diff FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip",
        "amends": [],
        "rules": [
            "SUBTRACT( DIVIDE( SUM(state = 'New Jersey'), COUNT(position = 'Member')), DIVIDE( SUM(state = 'Vermont'), COUNT(position = 'Member')) )"
        ]
    },
    "924": {
        "sql": [
            "SELECT r.date\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Barcelona-Catalunya';\n",
            "SELECT T2.date \nFROM circuits T1 \nINNER JOIN races T2 ON T2.circuitId = T1.circuitId \nWHERE T1.name = 'Circuit de Barcelona-Catalunya'"
        ],
        "question": "Please list the exact dates on which a Formula_1 race took place on the Barcelona-Catalunya circuit.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "amends": [
            "Do use `T2.date` instead of `r.date` for the SELECT list. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId` for the join condition. Do filter on `T1.name = 'Circuit de Barcelona-Catalunya'` instead of `c.name = 'Barcelona-Catalunya'` in the WHERE clause. Do use table aliases `T1` and `T2` consistently instead of `c` and `r`. The amended query now correctly matches the RIGHT_SQL's behavior by using the full circuit name and proper table aliases."
        ],
        "rules": []
    },
    "88": {
        "sql": [
            "SELECT s.AdmEmail1, sc.sname\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);"
        ],
        "question": "What is the administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500?Provide the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.AdmEmail1, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [],
        "rules": []
    },
    "307": {
        "sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR000_2_3';",
            "SELECT T2.element \nFROM connected AS T1 \nINNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id \nWHERE T1.bond_id = 'TR000_2_3'"
        ],
        "question": "Name the atoms' elements that form bond TR000_2_3.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3'",
        "amends": [
            "Do select only `T2.element` instead of both `a1.element` and `a2.element` with aliases. Do use `INNER JOIN` with `atom AS T2` on `T1.atom_id = T2.atom_id` instead of joining two separate `atom` tables on different conditions. Do remove the second join to `atom a2` on `c.atom_id2 = a2.atom_id` instead of keeping it. Do use table aliases `T1` for `connected` and `T2` for `atom` instead of `c`, `a1`, and `a2`. Do keep the `WHERE` filter on `T1.bond_id = 'TR000_2_3'` unchanged. The amended query now correctly retrieves only the element from the single joined atom table instead of attempting to join two different atom records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "343": {
        "sql": [
            "SELECT name FROM cards WHERE frameVersion = '2015' AND edhrecRank < 100;",
            "SELECT id FROM cards WHERE frameVersion = 2015 AND edhrecRank < 100"
        ],
        "question": "Name all cards with 2015 frame style ranking below 100 on EDHRec.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = 2015",
        "amends": [
            "Do select `id` instead of `name` in the SELECT list. Do use integer comparison `frameVersion = 2015` instead of string comparison `frameVersion = '2015'`. Do maintain the same WHERE clause conditions but ensure proper data type handling for the frameVersion comparison. The amended query now correctly retrieves card IDs with the proper numeric comparison for frameVersion while maintaining the same filtering logic for edhrecRank."
        ],
        "rules": [
            "below 100 on EDHRec refers to EDHRec <100; with 2015 frame style refers to frameVersion = 2015;"
        ]
    },
    "1497": {
        "sql": [
            "SELECT c.CustomerID, c.Segment, y.Consumption\nFROM customers c\nJOIN yearmonth y ON c.CustomerID = y.CustomerID\nWHERE c.Segment = 'SME' AND y.Date = '201206'\nORDER BY y.Consumption ASC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND T2.Date LIKE '2012-06%'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption)\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND T2.Date = '201206'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ],
        "question": "Which SME customer consumed the least in June 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do select only `CustomerID` instead of including `Segment` and `Consumption` columns. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `c` and `y`. Do move the `Segment` filter to the `WHERE` clause instead of keeping it in the original position. Do add `GROUP BY T1.CustomerID` instead of omitting aggregation grouping. Do order by `SUM(T2.Consumption)` instead of ordering by raw `Consumption` values. Do remove the explicit `ASC` keyword while maintaining ascending order instead of keeping it. The amended query now correctly aggregates consumption by customer and returns the customer with the lowest total consumption for the specified segment and date period, matching the RIGHT_SQL's behavior.",
            "Do use exact equality `T2.Date = '201206'` instead of pattern matching `T2.Date LIKE '2012-06%'` for the date filter. Do add explicit `ASC` direction in the `ORDER BY` clause instead of omitting it. The amended query now correctly filters by exact date value and specifies ascending sort order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "June 2012 refers to yearmonth.date = '201206'"
        ]
    },
    "1061": {
        "sql": [
            "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Adam%' AND weight > 170;"
        ],
        "question": "How many players whose first names are Adam and weigh more than 170?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE weight > 170 AND player_name LIKE 'Adam%'",
        "amends": [],
        "rules": [
            "team names refers to team_long_name; speed class refers to buildUpPlaySpeedClass; buildUpPlaySpeedClass = 'Fast';"
        ]
    },
    "917": {
        "sql": [
            "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';"
        ],
        "question": "Which website should I go to if I want to know more about Anthony Davidson?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
        "amends": [],
        "rules": [
            "website refers to url"
        ]
    },
    "710": {
        "sql": [
            "SELECT COUNT(*) AS ZeroScoreCommentsCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.CommentCount = 1 AND c.Score = 0;",
            "SELECT COUNT(T1.Id) \nFROM comments T1\nJOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Score = 0\nAND T2.CommentCount = 1"
        ],
        "question": "In posts with 1 comment, how many of the comments have 0 score?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do reference the `comments` table as `T1` instead of `c` and `posts` as `T2` instead of `p` for consistent aliasing. Do filter on `T2.Score = 0` instead of `c.Score = 0` to check the post's score rather than the comment's score, which correctly identifies posts with zero score that have exactly one comment. The amended query now matches the intended behavior of counting comments from posts with zero score and exactly one comment."
        ],
        "rules": [
            "in posts with 1 comment refers to CommentCount = 1;"
        ]
    },
    "842": {
        "sql": [
            "SELECT AVG(s.height_cm) AS average_height\nFROM superhero s\nJOIN alignment a ON s.alignment_id = a.id\nWHERE a.alignment = 'Neutral' AND s.height_cm IS NOT NULL;"
        ],
        "question": "Calculate the average height of all neutral superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "amends": [],
        "rules": []
    },
    "254": {
        "sql": [
            "WITH element_pairs AS (\n  SELECT a1.element AS element1, a2.element AS element2, COUNT(*) AS pair_count\n  FROM connected c\n  JOIN atom a1 ON c.atom_id = a1.atom_id\n  JOIN atom a2 ON c.atom_id2 = a2.atom_id\n  GROUP BY a1.element, a2.element\n),\nmax_pair AS (\n  SELECT MAX(pair_count) AS max_count\n  FROM element_pairs\n),\ntotal_bonds AS (\n  SELECT COUNT(*) AS total\n  FROM bond\n)\nSELECT (max_pair.max_count * 100.0 / total_bonds.total) AS percentage\nFROM max_pair, total_bonds;",
            "SELECT \n    (SELECT COUNT(*) FROM connected) AS total_bonds,\n    (SELECT COUNT(*) FROM connected c JOIN bond b ON c.bond_id = b.bond_id GROUP BY b.bond_type ORDER BY COUNT(*) DESC LIMIT 1) AS max_bond_count,\n    CAST((SELECT COUNT(*) FROM connected c JOIN bond b ON c.bond_id = b.bond_id GROUP BY b.bond_type ORDER BY COUNT(*) DESC LIMIT 1) AS REAL) / \n    (SELECT COUNT(*) FROM connected) * 100.0 AS percentage",
            "SELECT \n    (SELECT COUNT(*) \n     FROM connected c \n     INNER JOIN bond b ON c.bond_id = b.bond_id \n     GROUP BY b.bond_type \n     ORDER BY COUNT(*) DESC \n     LIMIT 1) * 100.0 / \n    (SELECT COUNT(*) FROM connected) \nAS percentage"
        ],
        "question": "What percentage of bonds have the most common combination of atoms' elements?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST((SELECT COUNT(T1.atom_id) FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id GROUP BY T2.bond_type ORDER BY COUNT(T2.bond_id) DESC LIMIT 1 ) AS REAL) * 100 / ( SELECT COUNT(atom_id) FROM connected )",
        "amends": [
            "Do use a single SELECT with subqueries instead of a CTE structure. Do calculate the maximum bond count from `connected` joined with `bond` on `bond_id` instead of counting element pairs from `atom` joins. Do group by `bond_type` instead of element pairs. Do order by count descending with limit 1 instead of finding maximum pair count. Do cast the maximum count to REAL instead of using decimal multiplication. Do divide by the total count from `connected` instead of from `bond` table. Do remove the unnecessary CTEs and cross join, using subqueries directly in the main SELECT instead. The amended query now correctly calculates the percentage of the most frequent bond type rather than element pair frequency.",
            "Do use `COUNT(T1.atom_id)` instead of `COUNT(*)` in the numerator subquery, and do use `COUNT(T2.bond_id)` instead of `COUNT(*)` for the bond count aggregation. Do specify `INNER JOIN` explicitly instead of just `JOIN` between connected and bond tables. Do remove the unnecessary `total_bonds` and `max_bond_count` columns instead of including them in the output. Do move the multiplication by 100 to the numerator instead of keeping it in the denominator division. Do use `COUNT(atom_id)` instead of `COUNT(*)` in the denominator subquery. Do remove the percentage calculation division operator and instead perform direct multiplication and division with proper operator precedence. The amended query now correctly calculates the percentage of the most frequent bond type relative to total connections."
        ],
        "rules": [
            "DIVIDE(COUNT(bond_id), COUNT(atom_id where MAX(COUNT(atom_id)) ))"
        ]
    },
    "779": {
        "sql": [
            "SELECT COUNT(*) AS power_count\nFROM hero_power\nWHERE hero_id = (SELECT id FROM superhero WHERE superhero_name = 'Amazo');"
        ],
        "question": "How many powers does Amazo hero have?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.power_id) FROM hero_power AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.superhero_name = 'Amazo'",
        "amends": [],
        "rules": [
            "Amazo hero refers to superhero_name = 'Amazo';"
        ]
    },
    "889": {
        "sql": [
            "SELECT MAX(r.year) AS last_season\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Brands Hatch' AND r.name LIKE '%British Grand Prix%';",
            "SELECT T2.date \nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Brands Hatch' \nAND T2.name = 'British Grand Prix'\nORDER BY T2.year DESC \nLIMIT 1;"
        ],
        "question": "When was the last f1 season whereby Brands Hatch hosted the British Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Brands Hatch' AND T2.name = 'British Grand Prix' ORDER BY T2.year DESC LIMIT 1",
        "amends": [
            "Do select `T2.date` instead of `MAX(r.year) AS last_season` to retrieve the actual date rather than just the maximum year. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with `r` and `c` aliases for better clarity. Do join on `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId` to ensure proper column matching. Do filter with exact equality `T2.name = 'British Grand Prix'` instead of pattern matching `LIKE '%British Grand Prix%'` for precise race name matching. Do add `ORDER BY T2.year DESC LIMIT 1` instead of omitting ordering and limiting to get the most recent single result. The amended query now correctly retrieves the date of the most recent British Grand Prix at Brands Hatch circuit."
        ],
        "rules": [
            "the last refers to max(year);"
        ]
    },
    "0": {
        "sql": [
            "SELECT MAX(`Percent (%) Eligible Free (K-12)`) AS HighestEligibleFreeRate\nFROM frpm\nWHERE `County Name` = 'Alameda';"
        ],
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`"
        ]
    },
    "562": {
        "sql": [
            "SELECT COUNT(*) AS comment_count\nFROM comments\nWHERE PostId IN (SELECT Id FROM posts WHERE ViewCount = 1910);"
        ],
        "question": "For the post which got 1910 view counts, how many comments does it get?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ViewCount = 1910",
        "amends": [],
        "rules": []
    },
    "685": {
        "sql": [
            "SELECT p.ViewCount AS TotalViews, u.DisplayName AS UserName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Computer Game Datasets';",
            "SELECT T2.ViewCount, T3.DisplayName\nFROM postHistory AS T1\nINNER JOIN posts AS T2 ON T1.PostId = T2.Id\nINNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id\nWHERE T1.Text = 'Computer Game Datasets'"
        ],
        "question": "Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.ViewCount, T3.DisplayName FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id WHERE T1.Text = 'Computer Game Datasets'",
        "amends": [
            "Do change the FROM clause to use `postHistory AS T1` instead of `posts p` and add `INNER JOIN posts AS T2` on `T1.PostId = T2.Id` instead of joining directly to users. Do change the join condition to `T2.LastEditorUserId = T3.Id` instead of `p.OwnerUserId = u.Id` when joining to users. Do change the WHERE filter to use `T1.Text = 'Computer Game Datasets'` instead of `p.Title = 'Computer Game Datasets'`. Do change the SELECT list to use `T2.ViewCount` and `T3.DisplayName` instead of `p.ViewCount AS TotalViews` and `u.DisplayName AS UserName`. The amended query now correctly filters on post history text rather than post title and joins through the appropriate relationships to match the right SQL's behavior."
        ],
        "rules": [
            "total views refer to ViewCount; Name the user refers to DisplayName; post 'Computer Game Datasets' refers to Text = 'Computer Game Datasets';"
        ]
    },
    "828": {
        "sql": [
            "SELECT COUNT(DISTINCT hero_id) AS fastest_superheroes_count\nFROM hero_attribute\nJOIN attribute ON hero_attribute.attribute_id = attribute.id\nWHERE attribute.attribute_name = 'Speed' AND hero_attribute.attribute_value = 100;"
        ],
        "question": "Count the fastest superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' AND T1.attribute_value = 100",
        "amends": [],
        "rules": [
            "fastest refers to attribute_value = 100 WHERE attribute_name = 'Speed';"
        ]
    },
    "357": {
        "sql": [
            "SELECT promoTypes FROM cards WHERE name = 'Duress';",
            "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL;"
        ],
        "question": "What type of promotion is of card 'Duress'?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL",
        "amends": [
            "Do add `AND promoTypes IS NOT NULL` to the WHERE clause instead of omitting this filter, ensuring only non-null promoTypes values are returned for cards named 'Duress' instead of potentially including null values. The amended query now matches RIGHT_SQL's behavior by filtering out records where promoTypes is null."
        ],
        "rules": [
            "card Duress refers to name = 'Duress'; type of promotion refers to promoTypes;"
        ]
    },
    "41": {
        "sql": [
            "WITH RankedSchools AS (\n    SELECT \n        s.School,\n        s.County,\n        sc.AvgScrRead,\n        RANK() OVER (PARTITION BY s.County ORDER BY sc.AvgScrRead DESC) AS rank_in_county\n    FROM \n        schools s\n    JOIN \n        satscores sc ON s.CDSCode = sc.cds\n    WHERE \n        s.Virtual = 'F'\n)\nSELECT \n    School,\n    County,\n    AvgScrRead\nFROM \n    RankedSchools\nWHERE \n    rank_in_county <= 5\nORDER BY \n    County, rank_in_county;",
            "SELECT T2.School\nFROM (\n    SELECT \n        cds,\n        AvgScrRead,\n        cname,\n        ROW_NUMBER() OVER (PARTITION BY cname ORDER BY AvgScrRead DESC) as rnk\n    FROM satscores\n    WHERE rtype = 'S'\n) T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F' AND T1.rnk <= 5\nORDER BY T1.cname, T1.rnk",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND T1.cds IN (\n    SELECT cds\n    FROM (\n        SELECT cds, \n               RANK() OVER (PARTITION BY T2.County ORDER BY AvgScrRead DESC) as rnk\n        FROM satscores\n        INNER JOIN schools ON satscores.cds = schools.CDSCode\n        WHERE schools.Virtual = 'F'\n          AND AvgScrRead IS NOT NULL\n    ) ranked\n    WHERE rnk <= 5\n  )",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC;",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC;",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC;",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n      SELECT COUNT(*) \n      FROM satscores T3 \n      INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n      WHERE T4.County = T2.County \n        AND T3.AvgScrRead >= T1.AvgScrRead\n        AND T4.Virtual = 'F'\n        AND T3.AvgScrRead IS NOT NULL\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*)\n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead >= T1.AvgScrRead\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead >= T1.AvgScrRead\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT School\nFROM (\n    SELECT \n        T2.School,\n        T1.AvgScrRead,\n        RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk\n    FROM satscores T1\n    INNER JOIN schools T2 ON T1.cds = T2.CDSCode\n    WHERE T2.Virtual = 'F'\n) ranked_schools\nWHERE rnk <= 5"
        ],
        "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
        "amends": [
            "Do use `T2.School` and `T1.AvgScrRead` in the SELECT list instead of including `County` and omitting the rank column from the final output. Do use an `INNER JOIN` on `T1.cds = T2.CDSCode` instead of joining on `s.CDSCode = sc.cds`. Do apply the `Virtual = 'F'` filter directly in the WHERE clause instead of placing it in the CTE. Do reference the rank column as `rnk` in the final WHERE filter instead of `rank_in_county`. Do remove the explicit ORDER BY clause with `County, rank_in_county` instead of keeping it. Do structure the query as a subquery instead of using a CTE. The amended query now correctly returns only the top 5 schools per county by reading scores without including county information or unnecessary ordering in the final output.",
            "Do select only `School` instead of including multiple columns in the outer query. Do use `RANK()` instead of `ROW_NUMBER()` for ranking to handle ties properly. Do partition by `T2.County` instead of `cname` to group schools by county rather than by an unspecified column. Do move the `rnk <= 5` filter to the outer WHERE clause instead of keeping it in the inner query's WHERE clause. Do remove the unnecessary `ORDER BY` clause at the end since ranking is already handled by the window function. Do add the join condition `T1.cds = T2.CDSCode` directly in the main query instead of using a subquery structure. The amended query now correctly identifies top 5 schools per county based on average SAT reading scores instead of using an unclear grouping column and properly handles ranking with ties.",
            "Do include `T1.AvgScrRead` and `rnk` in the SELECT list of the subquery instead of omitting them, and do move the `RANK()` window function to the main query's subquery instead of using a nested subquery. Do remove the redundant `AND T1.AvgScrRead IS NOT NULL` filter from the outer WHERE clause instead of keeping it, as the window function already handles NULL values appropriately. Do eliminate the unnecessary IN subquery with its own join operation instead of maintaining the nested structure, and do simplify the query to a single subquery with window function and filtering instead of the complex nested approach. Do ensure the window function partitions by `T2.County` and orders by `T1.AvgScrRead DESC` directly in the main subquery instead of through multiple layers. The amended query now correctly identifies top schools by reading scores per county with proper window function implementation and eliminates redundant operations.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and `>=` comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of including it in both main and subquery. Do restructure with a derived table `ranked_schools` containing the rank calculation instead of using a subquery in the WHERE clause. Do simplify the SELECT list to only `School` instead of including additional columns in the output. Do remove the explicit ORDER BY clause from the outer query since ranking already handles the ordering logic. The amended query now correctly identifies top 5 schools per county using proper ranking semantics instead of potentially incorrect count-based logic that could produce duplicate rankings.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and `>=` comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of keeping it in both the main query and subquery. Do restructure the query with a derived table `ranked_schools` containing the rank calculation instead of using a complex WHERE clause with subquery. Do simplify the SELECT list to only include `School` instead of the original projection. Do remove the explicit `ORDER BY` clause since ranking handles the ordering internally instead of maintaining it at the end. The amended query now correctly identifies the top 5 schools per county using proper ranking semantics instead of the potentially incorrect count-based approach that could miss ties or handle ranking improperly.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and `>=` comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of keeping it in both main and subquery. Do restructure the query with a derived table `ranked_schools` instead of using a complex WHERE clause with subquery. Do simplify the SELECT list to only `School` instead of including `T2.School` with table prefix. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` clause since ranking handles the ordering logic internally. The amended query now correctly identifies top 5 schools per county using proper ranking semantics instead of the flawed count-based approach that could produce incorrect results with duplicate scores.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top schools. Do move the `AvgScrRead IS NOT NULL` filter from the `WHERE` clause to the ranking logic instead of filtering before ranking. Do restructure the query with a subquery to filter by `rnk <= 5` instead of using a complex subquery condition. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` from the outer query since the ranking already handles the ordering. The amended query now correctly identifies the top 5 schools per county using proper window function ranking instead of the inefficient and potentially incorrect correlated subquery approach.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top schools. Do include `T1.AvgScrRead` in the SELECT list instead of omitting it to enable ranking. Do wrap the query in a derived table `ranked_schools` instead of using a subquery in the WHERE clause. Do filter with `rnk <= 5` in the outer query instead of using a complex subquery condition. Do remove the explicit `IS NOT NULL` check on `AvgScrRead` instead of keeping it since the ranking naturally handles NULL values. Do simplify the ORDER BY clause by removing it from the main query instead of including it since the ranking already orders the results. The amended query now correctly identifies the top 5 schools per county using efficient window functions instead of expensive correlated subqueries.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top schools. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of keeping it in both the main query and subquery. Do restructure the query with a derived table `ranked_schools` containing the rank calculation instead of using a complex correlated subquery. Do filter on `rnk <= 5` in the outer WHERE clause instead of using a subquery with inequality comparison. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` from the main query since the ranking already handles the ordering logic internally. The amended query now correctly identifies the top 5 schools per county using proper window function ranking instead of the inefficient and potentially incorrect correlated subquery approach.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and comparison. Do move the ranking logic to a derived table instead of keeping it in the `WHERE` clause. Do remove the redundant `T1.AvgScrRead IS NOT NULL` filter since the window function handles null values appropriately. Do simplify the query structure by eliminating the duplicate join condition `T4.Virtual = 'F'` from the subquery. Do change the output to select only `School` from the ranked results instead of including `T2.School` directly. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` since the ranking already orders by county and score. The amended query now correctly identifies the top 5 schools per county by average reading score using proper window function semantics instead of error-prone correlated subquery counting.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of applying it in both main and subquery. Do restructure the query with a derived table `ranked_schools` instead of using a complex WHERE clause with subquery. Do simplify the SELECT list to only `School` instead of including additional columns. Do remove the explicit ORDER BY clause at the end instead of keeping it since ranking handles the ordering. The amended query now correctly identifies top 5 schools per county using proper ranking semantics instead of potentially incorrect count-based logic.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and comparison. Do move the `AvgScrRead IS NOT NULL` filter to the ranking logic instead of explicit null checks. Do restructure the query with a derived table `ranked_schools` instead of the original flat structure. Do simplify the final selection to only `School` instead of including additional columns. Do remove the explicit `ORDER BY` clause from the outer query instead of keeping it since ranking handles ordering. The amended query now correctly identifies top 5 schools per county using proper ranking semantics instead of potentially incorrect count-based filtering.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top schools. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of including it in both the main query and subquery. Do restructure the query with a derived table `ranked_schools` instead of using a complex WHERE clause with subquery. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` from the outer query since ranking already handles the ordering logic internally. Do simplify the final SELECT to only include `School` instead of the full `T2.School` reference. The amended query now correctly identifies the top 5 schools per county using proper ranking semantics instead of the potentially incorrect count-based approach.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top 5 schools per county. Do remove the `T1.AvgScrRead IS NOT NULL` filter from the WHERE clause instead of keeping it, as window functions handle NULL values appropriately. Do restructure the query with a derived table `ranked_schools` instead of using a complex subquery in the WHERE condition. Do simplify the final SELECT to only include `School` instead of selecting multiple columns. Do eliminate the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` clause instead of keeping it, as the ranking already provides the necessary ordering. The amended query now correctly identifies the top 5 schools per county based on average reading scores using efficient window functions rather than expensive correlated subqueries.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of applying it in both the main query and subquery. Do restructure the query with a derived table `ranked_schools` containing the rank calculation instead of using a complex WHERE clause with subquery. Do simplify the SELECT clause to only include `School` instead of the full `T2.School` reference. Do remove the explicit ORDER BY clause at the end since ranking already handles the ordering logic internally. The amended query now correctly identifies the top 5 schools per county by average reading score using proper window function ranking instead of the inefficient and potentially incorrect correlated subquery approach."
        ],
        "rules": [
            "Exclusively virtual refers to Virtual = 'F'; respective counties means PARTITION BY County"
        ]
    },
    "299": {
        "sql": [
            "SELECT label FROM molecule WHERE molecule_id = 'TR124';"
        ],
        "question": "Is molecule TR124 carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "515": {
        "sql": [
            "SELECT c.originalReleaseDate, l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic' AND l.status = 'legal'\nORDER BY c.originalReleaseDate ASC\nLIMIT 1;",
            "SELECT T1.originalReleaseDate, T2.format\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'mythic' \nAND T2.status = 'Legal'\nAND T1.originalReleaseDate IS NOT NULL\nORDER BY T1.originalReleaseDate\nLIMIT 1;"
        ],
        "question": "When was the oldest mythic card released and what are its legal play formats?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate LIMIT 1",
        "amends": [
            "Do add `T1.originalReleaseDate IS NOT NULL` to the WHERE clause instead of omitting it to filter out null dates. Do change the join to `INNER JOIN` instead of `JOIN` for explicit clarity. Do use table aliases `T1` and `T2` instead of `c` and `l` for consistency. Do capitalize `Legal` instead of `legal` in the status filter to match case-sensitive values. Do remove `ASC` from the ORDER BY clause instead of keeping it since ascending is the default. The amended query now correctly excludes null release dates while maintaining the same join logic and filtering criteria."
        ],
        "rules": [
            "the oldest card refers to MIN(originalReleaseDate); mythic card refers to rarity = 'mythic'; legal play refers to status = 'legal'; play format refers to format"
        ]
    },
    "860": {
        "sql": [
            "SELECT d.nationality\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nWHERE q.raceId = 355 AND q.q2 = '0:01:40';",
            "SELECT DISTINCT T2.nationality\nFROM qualifying T1\nINNER JOIN drivers T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'"
        ],
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "amends": [
            "Do use `DISTINCT` on `nationality` instead of omitting it to eliminate duplicate nationalities. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `d` and `q` aliases. Do reference `T2.nationality` instead of `d.nationality` to clarify the source table. Do use `LIKE '1:40%'` for the q2 filter instead of exact match `= '0:01:40'` to capture variations in time formatting. Do maintain the same join condition `T2.driverId = T1.driverId` instead of `d.driverId = q.driverId` with corrected table reference order. The amended query now correctly identifies distinct nationalities of drivers who qualified with q2 times starting with '1:40' for race 355, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "race number refers to raceId;"
        ]
    },
    "769": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE p.publisher_name = 'Dark Horse Comics'\nAND a.attribute_name = 'durability'\nORDER BY ha.attribute_value DESC\nLIMIT 1;",
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T3.id = T2.attribute_id\nINNER JOIN publisher T4 ON T4.id = T1.publisher_id\nWHERE T4.publisher_name = 'Dark Horse Comics'\nAND T3.attribute_name = 'Durability'\nORDER BY T2.attribute_value DESC\nLIMIT 1;"
        ],
        "question": "Which superhero has the most durability published by Dark Horse Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for all table joins. Do reference tables with aliases `T1`, `T2`, `T3`, and `T4` instead of single-letter aliases `s`, `p`, `ha`, and `a`. Do capitalize the attribute name filter to `'Durability'` instead of lowercase `'durability'` to match the actual data format. Do maintain the same join conditions on `T1.id = T2.hero_id`, `T3.id = T2.attribute_id`, and `T4.id = T1.publisher_id` instead of the original join structure. Do preserve the same `WHERE` filters for publisher name and attribute name, the same `ORDER BY` on attribute value descending, and the same `LIMIT 1` to return the single highest durability hero. The amended query now correctly matches the RIGHT_SQL's behavior with proper case sensitivity and explicit join syntax."
        ],
        "rules": [
            "which superhero refers to superhero_name; most durability refers to MAX(attribute_value) WHERE attribute_name = 'durability'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';"
        ]
    },
    "367": {
        "sql": [
            "SELECT DISTINCT c.artist FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Phyrexian';"
        ],
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "amends": [],
        "rules": [
            "Phyrexian' is the language; name of artists refers to artist;"
        ]
    },
    "624": {
        "sql": [
            "SELECT DisplayName FROM users WHERE Id = 30;"
        ],
        "question": "What is the name of user with the ID of 30?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = 30",
        "amends": [],
        "rules": [
            "name of user refers to DisplayName;"
        ]
    },
    "988": {
        "sql": [
            "SELECT d.forename, d.surname, AVG(p.duration) AS avg_pitstop_duration\nFROM drivers d\nJOIN pitStops p ON d.driverId = p.driverId\nWHERE d.nationality = 'German' AND d.dob BETWEEN '1980-01-01' AND '1985-12-31'\nGROUP BY d.driverId, d.forename, d.surname\nORDER BY avg_pitstop_duration ASC\nLIMIT 3;",
            "SELECT T2.forename, T2.surname\nFROM pitStops T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German' \nAND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985'\nGROUP BY T2.forename, T2.surname\nORDER BY AVG(T1.duration)\nLIMIT 3;"
        ],
        "question": "List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3",
        "amends": [
            "Do select only `forename` and `surname` instead of including `AVG(p.duration)` with an alias. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with single-letter aliases. Do change the date filter to use `STRFTIME('%Y', T2.dob)` between year strings instead of direct date range comparison with `BETWEEN`. Do group by only `forename` and `surname` instead of including `driverId`. Do order by `AVG(T1.duration)` directly instead of using the alias `avg_pitstop_duration`. The amended query now correctly handles year extraction for date filtering and maintains proper aggregation semantics."
        ],
        "rules": [
            "Full name of the driver refers to drivers.forename and drivers.surname; born between 1980-1985 refers to 1980< year(dob)>1985; Average pitstop duration refers to Divide(SUM(duration),COUNT(duration)); shortest average refers to Min(avg(duration));"
        ]
    },
    "704": {
        "sql": [
            "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample';"
        ],
        "question": "What is the excerpt post ID and wiki post ID of the tag named sample?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'",
        "amends": [],
        "rules": [
            "tag named sample refers to TagName = 'sample';"
        ]
    },
    "1132": {
        "sql": [
            "SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name ASC LIMIT 3;"
        ],
        "question": "Please provide the names of top three football players who are over 180 cm tall in alphabetical order.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name LIMIT 3",
        "amends": [],
        "rules": [
            "over 180 cm tall refers to height > 180; name of football player refers to player_name"
        ]
    },
    "107": {
        "sql": [
            "WITH highest_salary_district AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A11 DESC\n    LIMIT 1\n),\naccounts_in_district AS (\n    SELECT account_id\n    FROM account\n    WHERE district_id = (SELECT district_id FROM highest_salary_district)\n),\nclient_accounts AS (\n    SELECT client_id\n    FROM disp\n    WHERE account_id IN (SELECT account_id FROM accounts_in_district) AND type = 'OWNER'\n),\noldest_client AS (\n    SELECT client_id, gender\n    FROM client\n    WHERE client_id IN (SELECT client_id FROM client_accounts)\n    ORDER BY birth_date ASC\n    LIMIT 1\n)\nSELECT gender\nFROM oldest_client;"
        ],
        "question": "What is the gender of the oldest client who opened his/her account in the highest average salary branch?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.gender FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id ORDER BY T1.A11 DESC, T2.birth_date ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Earlier birthdate refers to older age; A11 refers to average salary"
        ]
    },
    "539": {
        "sql": [
            "SELECT u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Eliciting priors from experts';"
        ],
        "question": "Who is the owner of the post \"Eliciting priors from experts\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'",
        "amends": [],
        "rules": [
            "\"Eliciting priors from experts\" is the Title of post; owner refers to DisplayName"
        ]
    },
    "650": {
        "sql": [
            "SELECT u.DisplayName, u.LastAccessDate, u.Location\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE b.Name = 'Outliers'\nORDER BY u.LastAccessDate DESC;",
            "SELECT T2.LastAccessDate, T2.Location\nFROM badges T1\nINNER JOIN users T2 ON T1.Id = T2.UserId\nWHERE T1.Name = 'outliers'",
            "SELECT T1.LastAccessDate, T1.Location\nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T2.Name = 'outliers'"
        ],
        "question": "Describe the last accessed date and location of the users who received the outliers badge.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.LastAccessDate, T1.Location FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'outliers'",
        "amends": [
            "Do select only `LastAccessDate` and `Location` instead of including `DisplayName`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do reference the join condition as `T1.Id = T2.UserId` instead of `b.UserId = u.Id`. Do filter on lowercase `'outliers'` instead of title case `'Outliers'`. Do remove the `ORDER BY` clause instead of keeping it. The amended query now correctly retrieves user access dates and locations for those with the 'outliers' badge without unnecessary columns or sorting.",
            "Do reference `T1.LastAccessDate` and `T1.Location` from the users table instead of `T2.LastAccessDate` and `T2.Location` from the wrong table alias. Do use `T2.Name` in the WHERE filter instead of `T1.Name` to correctly reference the badges table where the Name column exists. Do maintain the same INNER JOIN logic with `ON T1.Id = T2.UserId` but ensure proper table alias usage throughout. The amended query now correctly filters on badge names while returning user attributes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Outliers is the name of the badge;"
        ]
    },
    "1198": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS Female_APS_Patients\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'F' AND E.Diagnosis = 'APS';",
            "SELECT COUNT(ID) FROM Patient WHERE SEX = 'female' AND Diagnosis = 'APS';",
            "SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS';"
        ],
        "question": "How many female patients were given an APS diagnosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS'",
        "amends": [
            "Do remove the `JOIN` with `Examination` table and the `DISTINCT` modifier instead of including them, as the diagnosis information is directly available in the `Patient` table. Do reference `Diagnosis` directly from the `Patient` table instead of from the joined `Examination` table. Do simplify the aggregate to `COUNT(ID)` instead of `COUNT(DISTINCT P.ID)` since the join is unnecessary and could cause duplicate counting. Do remove the table alias `P` and column prefixing since only one table is involved. The amended query now correctly counts female patients with APS diagnosis directly from the Patient table without unnecessary joins or distinct operations, matching the right SQL's behavior.",
            "Do use `SEX = 'F'` instead of `SEX = 'female'` in the WHERE filter to match the correct gender code format used in the data. The amended query now correctly counts patients with the specified gender code and diagnosis, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "female refers to SEX = 'F'; APS diagnosis refers to Diagnosis='APS'"
        ]
    },
    "807": {
        "sql": [
            "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.full_name = 'Helen Parr';"
        ],
        "question": "What is the superpowers of the superhero has Helen Parr as their full name?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.full_name = 'Helen Parr'",
        "amends": [],
        "rules": [
            "superpowers refers to power_name; Helen Parr is the full name of superhero;"
        ]
    },
    "763": {
        "sql": [
            "SELECT a.attribute_name, ha.attribute_value\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE s.superhero_name = 'Abomination';",
            "SELECT T2.attribute_value\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Abomination'"
        ],
        "question": "Indicate the attribute value of superhero Abomination.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Abomination'",
        "amends": [
            "Do select only `T2.attribute_value` instead of including `a.attribute_name` and `ha.attribute_value`. Do use `INNER JOIN` with `hero_attribute AS T2` instead of joining through both `hero_attribute ha` and `attribute a` tables. Do remove the unnecessary join to the `attribute` table instead of keeping the redundant table reference. Do reference `T2.attribute_value` directly instead of using the `ha` alias. Do use table aliases `T1` and `T2` consistently instead of mixed aliasing. The amended query now correctly retrieves only the attribute values for the specified superhero without the unnecessary attribute name column and extra table join."
        ],
        "rules": [
            "Abomination refers to superhero_name = 'Abomination';"
        ]
    },
    "1159": {
        "sql": [
            "SELECT p.ID, p.SEX, p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.ALB < 3.5;"
        ],
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
        "amends": [],
        "rules": [
            "albumin level lower than 3.5 refers to ALB < 3.5;"
        ]
    },
    "890": {
        "sql": [
            "SELECT COUNT(DISTINCT r.year) AS seasons_hosted\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit' AND r.name = 'British Grand Prix';"
        ],
        "question": "How many seasons has Silverstone Circuit hosted the United Kindom grand prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.circuitid) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit' AND T2.name = 'British Grand Prix'",
        "amends": [],
        "rules": [
            "British Grand Prix is the name of race; British refers to the United Kindom"
        ]
    },
    "1227": {
        "sql": [
            "SELECT AVG(strftime('%Y', 'now') - strftime('%Y', Birthday)) AS average_age\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.SEX = 'M' AND Laboratory.\"T-CHO\" >= 250;"
        ],
        "question": "What is the average age of the male patient with high cholesterol?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-CHO` >= 250 AND T1.SEX = 'M'",
        "amends": [],
        "rules": [
            "average age = DIVIDE(SUM(SUBTRACT(YEAR(NOW()), YEAR(birthday))), COUNT(ID)); male patient refers to sex = 'M'; high cholesterol refers to `T-CHO` > = 250;"
        ]
    },
    "1123": {
        "sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes);"
        ],
        "question": "What is the name of players with the highest potential?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.potential DESC LIMIT 1",
        "amends": [],
        "rules": [
            "highest potential refers to MAX(potential)"
        ]
    },
    "1161": {
        "sql": [
            "SELECT AVG(e.\"aCL IgG\") AS \"Average aCL IgG Concentration\"\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Admission = '+' AND (strftime('%Y', 'now') - strftime('%Y', p.Birthday)) >= 50;"
        ],
        "question": "For in-patient age 50 and above, what is their average anti-cardiolipin antibody (IgG) concentration?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.`aCL IgG`) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 AND T1.Admission = '+'",
        "amends": [],
        "rules": [
            "in-patient refers to Admission = '+'; age 50 and above refers to SUBTRACT(year(current_timestamp), year(Birthday)) >= '50'; average anti-cardiolipin antibody (IgG) concentration refers to AVG(aCL IgG)"
        ]
    },
    "1418": {
        "sql": [
            "SELECT DISTINCT type FROM event WHERE location = 'MU 215';",
            "SELECT T2.category \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.location = 'MU 215'"
        ],
        "question": "Mention the category of events which were held at MU 215.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "amends": [
            "Do select `T2.category` instead of `type` and remove `DISTINCT` instead of keeping it. Do add `INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event` instead of omitting the join to the budget table. Do keep the `WHERE T1.location = 'MU 215'` filter but apply it to the joined table structure instead of the original single table. The amended query now correctly retrieves category information from the budget table through proper table joining instead of attempting to get type directly from the event table."
        ],
        "rules": [
            "held at MU 215 refers to location = 'MU 215'"
        ]
    },
    "432": {
        "sql": [
            "SELECT s.name, s.baseSetSize\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Russian'\nORDER BY s.baseSetSize DESC\nLIMIT 1;",
            "SELECT T1.id\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Russian'\nGROUP BY T1.baseSetSize\nORDER BY T1.baseSetSize DESC\nLIMIT 1;"
        ],
        "question": "Which Russian set of cards contains the most cards overall?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Russian' GROUP BY T1.baseSetSize ORDER BY T1.baseSetSize DESC LIMIT 1",
        "amends": [
            "Do select `T1.id` instead of `s.name, s.baseSetSize` and do group by `T1.baseSetSize` instead of omitting grouping. Do use table aliases `T1` and `T2` instead of `s` and `st`, and do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T1.baseSetSize` in ORDER BY instead of `s.baseSetSize`. The amended query now correctly groups by the baseSetSize and selects only the id while maintaining the same filtering logic for Russian language set translations."
        ],
        "rules": [
            "Russian refers to language = 'Russian'; contains the most cards overall refers to MAX(baseSetSize)"
        ]
    },
    "156": {
        "sql": [
            "SELECT c.client_id, c.gender, c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE d.type = 'OWNER'\nORDER BY l.amount DESC\nLIMIT 1;",
            "SELECT T1.client_id\nFROM disp AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nINNER JOIN account AS T3 ON T1.account_id = T3.account_id\nWHERE T1.type = 'OWNER'\nORDER BY T2.amount DESC\nLIMIT 1;"
        ],
        "question": "Who is the owner of the account with the largest loan amount?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.client_id FROM disp AS T1 INNER JOIN account AS T3 ON T1.account_id = T3.account_id INNER JOIN loan AS T2 ON T3.account_id = T2.account_id WHERE T1.type = 'OWNER' ORDER BY T2.amount DESC LIMIT 1",
        "amends": [
            "Do select only `client_id` instead of including `gender` and `birth_date` in the SELECT list. Do use table aliases `T1`, `T2`, and `T3` instead of `c`, `d`, `a`, and `l` for consistency. Do join `disp AS T1` directly to `account AS T3` on `T1.account_id = T3.account_id` instead of joining through `client` first. Do use `INNER JOIN` consistently instead of mixing `JOIN` without explicit type specification. Do reference `T1.type` in the WHERE clause instead of `d.type` to match the alias change. Do order by `T2.amount` instead of `l.amount` to align with the new table alias. The amended query now correctly focuses on retrieving only the client ID of the account owner with the highest loan amount, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "801": {
        "sql": [
            "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Male')) * 1.0 /\n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female')) AS male_to_female_ratio;"
        ],
        "question": "Find the ratio between male superheroes and female superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id",
        "amends": [],
        "rules": [
            "ratio = DIVIDE(SUM(gender_id = 1) / SUM(gender_id = 2)); male superheroes refers to gender = 'Female'; female superheroes refers to gender = 'Male';"
        ]
    },
    "1253": {
        "sql": [
            "SELECT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.IGA = (SELECT MAX(IGA) FROM Laboratory WHERE IGA BETWEEN 80 AND 500)\nAND l.IGA BETWEEN 80 AND 500;",
            "SELECT patientData.Diagnosis\nFROM Patient AS patientData\nINNER JOIN Laboratory AS labData ON patientData.ID = labData.ID\nWHERE labData.IGA BETWEEN 80 AND 500\nORDER BY labData.IGA DESC\nLIMIT 1;"
        ],
        "question": "For the patient who has the highest Ig A within the normal range, what is his or her diagnosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT patientData.Diagnosis FROM Patient AS patientData INNER JOIN Laboratory AS labData ON patientData.ID = labData.ID WHERE labData.IGA BETWEEN 80 AND 500 ORDER BY labData.IGA DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` with explicit `AS` aliases `patientData` and `labData` instead of simple `JOIN` with single-letter aliases `p` and `l`. Do remove the subquery that finds the maximum IGA value and instead use `ORDER BY labData.IGA DESC LIMIT 1` to get the single highest record instead of potentially multiple records matching the maximum value. Do add explicit `ORDER BY` and `LIMIT` clauses instead of relying on a subquery comparison that could return multiple rows. Do keep the `BETWEEN 80 AND 500` filter in the `WHERE` clause instead of duplicating it in both the main query and subquery. The amended query now correctly returns only the single patient with the highest IGA value within the specified range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "highest Ig A within the normal range refers to MAX(IGA BETWEEN 80 AND 500);"
        ]
    },
    "377": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes NOT LIKE '%Angel%';",
            "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel';"
        ],
        "question": "How many cards with original type of \"Summon - Angel\" have subtype other than \"Angel\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'",
        "amends": [
            "Do use `COUNT(id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do use `!=` operator instead of `NOT LIKE` for exact string comparison when checking if subtypes does not equal 'Angel'. Do remove the wildcard pattern matching from the condition since we want exact inequality comparison rather than pattern exclusion. The amended query now correctly counts cards where originalType is exactly 'Summon - Angel' and subtypes is not exactly 'Angel', matching the intended behavior."
        ],
        "rules": [
            "subtype other than Angel refers to subtypes is not 'Angel';"
        ]
    },
    "204": {
        "sql": [
            "SELECT COUNT(*) FROM molecule WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND label = '+';"
        ],
        "question": "Of the first 100 molecules in number order, how many are carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'",
        "amends": [],
        "rules": [
            "first 100 molecules in number order refers to molecule_id between 'TR000' and 'TR099'; label = '+' means molecules are carcinogenic"
        ]
    },
    "1255": {
        "sql": [
            "WITH AbnormalIgMPatients AS (\n    SELECT DISTINCT ID\n    FROM Laboratory\n    WHERE IGM <= 40 OR IGM >= 400\n),\nDiagnosisCount AS (\n    SELECT Diagnosis, COUNT(*) AS Count\n    FROM Examination\n    WHERE ID IN (SELECT ID FROM AbnormalIgMPatients) AND Diagnosis IS NOT NULL\n    GROUP BY Diagnosis\n)\nSELECT Diagnosis\nFROM DiagnosisCount\nORDER BY Count DESC\nLIMIT 1;",
            "SELECT T1.Diagnosis, COUNT(T1.Diagnosis) AS count_diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.IGM NOT BETWEEN 40 AND 400\nGROUP BY T1.Diagnosis\nORDER BY COUNT(T1.Diagnosis) DESC\nLIMIT 1;",
            "SELECT T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.IGM NOT BETWEEN 40 AND 400\nGROUP BY T1.Diagnosis\nORDER BY COUNT(T1.Diagnosis) DESC\nLIMIT 1"
        ],
        "question": "For the patients with an abnormal Ig M level, what is the most common disease they are diagnosed with?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGM NOT BETWEEN 40 AND 400 GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1",
        "amends": [
            "Do use `SELECT T1.Diagnosis` with explicit table alias instead of just `Diagnosis`. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of using a CTE with subquery. Do filter with `T2.IGM NOT BETWEEN 40 AND 400` instead of `IGM <= 40 OR IGM >= 400` in a separate CTE. Do remove the DISTINCT operation and CTE structure instead of keeping them. Do group by `T1.Diagnosis` instead of grouping in a separate CTE. Do order by `COUNT(T1.Diagnosis)` directly instead of ordering by a pre-computed count column. Do remove the explicit NULL check on Diagnosis since the join and grouping implicitly handle this. The amended query now correctly joins patient and laboratory data directly and matches the right SQL's behavior.",
            "Do remove `COUNT(T1.Diagnosis) AS count_diagnosis` from the SELECT list instead of including it, as the RIGHT_SQL only needs to return the Diagnosis column without the count aggregation. The amended query now correctly returns only the Diagnosis column while maintaining the same join logic, filtering condition, grouping, and ordering behavior as specified in the RIGHT_SQL."
        ],
        "rules": [
            "abnormal Ig M level refers to IGM <=40 OR IGM >= 400; most common disease refers to MAX(COUNT(Diagnosis));"
        ]
    },
    "428": {
        "sql": [
            "SELECT s.name AS set_name, st.translation FROM sets s LEFT JOIN set_translations st ON s.code = st.setCode WHERE s.id = 5;",
            "SELECT T1.name, T2.translation\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.id = 5\nGROUP BY T1.name, T2.translation;"
        ],
        "question": "What is the name of set number 5 and its translation?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 5 GROUP BY T1.name, T2.translation",
        "amends": [
            "Do use `INNER JOIN` instead of `LEFT JOIN` to ensure only matching records are returned. Do reference `T2.id` in the WHERE clause instead of `s.id` to filter by the translation table's ID. Do add `GROUP BY T1.name, T2.translation` instead of omitting aggregation when selecting non-aggregated columns. Do use table aliases `T1` and `T2` instead of `s` and `st` for consistency. Do remove the column alias `set_name` instead of keeping it since the column is now simply named `name`. The amended query now correctly filters by translation ID and ensures proper grouping for the result set."
        ],
        "rules": [
            "set number 5 refers to id = 5"
        ]
    },
    "1219": {
        "sql": [
            "WITH LatestLabResults AS (\n    SELECT \n        L.ID,\n        L.UA,\n        P.SEX,\n        ROW_NUMBER() OVER (PARTITION BY L.ID ORDER BY L.Date DESC) AS rn\n    FROM \n        Laboratory L\n    JOIN \n        Patient P ON L.ID = P.ID\n    WHERE \n        (P.SEX = 'M' AND L.UA < 8.0) OR (P.SEX = 'F' AND L.UA < 6.5)\n)\nSELECT AVG(UA) AS AverageUAIndex\nFROM LatestLabResults\nWHERE rn = 1;",
            "SELECT AVG(L.UA) AS average_ua\nFROM Patient P\nINNER JOIN Laboratory L ON P.ID = L.ID\nWHERE L.UA BETWEEN \n    CASE \n        WHEN P.SEX = 'M' THEN 3.7 AND 7.0\n        WHEN P.SEX = 'F' THEN 2.5 AND 5.7\n        ELSE L.UA\n    END\nAND L.Date = (\n    SELECT MAX(Date) \n    FROM Laboratory \n    WHERE ID = P.ID\n)",
            "SELECT AVG(T2.UA) AS average_ua\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date = (\n    SELECT MAX(Date)\n    FROM Laboratory\n    WHERE ID = T1.ID\n)\nAND (\n    (T2.UA < 6.5 AND T1.SEX = 'F') OR\n    (T2.UA < 8.0 AND T1.SEX = 'M')\n)",
            "SELECT AVG(T2.UA)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M')\nAND T2.Date = (SELECT MAX(Date) FROM Laboratory WHERE ID = T1.ID)",
            "SELECT AVG(T2.UA)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M')\nAND T2.Date = (SELECT MAX(Date) FROM Laboratory)"
        ],
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "amends": [
            "Do use a direct `INNER JOIN` between `Patient` and `Laboratory` instead of a CTE with window functions. Do place the sex-specific UA threshold conditions directly in the `WHERE` clause instead of filtering after window numbering. Do remove the `ROW_NUMBER()` window function and instead use a subquery to find the `MAX(Date)` for each patient in the `WHERE` condition instead of filtering by row number. Do reference `T2.UA` directly in the `AVG()` function instead of using a CTE-derived column. Do ensure the date filter uses equality with the maximum date subquery instead of relying on window function ordering. The amended query now correctly calculates the average UA value for patients' most recent lab results based on sex-specific thresholds.",
            "Do use table aliases `T1` and `T2` instead of full table names. Do change the WHERE clause to use explicit OR conditions with `T2.UA < 6.5 AND T1.SEX = 'F'` and `T2.UA < 8.0 AND T1.SEX = 'M'` instead of the CASE statement with BETWEEN ranges. Do remove the ELSE condition from the CASE statement instead of keeping it. Do simplify the subquery by removing the WHERE ID = P.ID correlation instead of maintaining it. The amended query now correctly filters UA values based on sex-specific thresholds and matches the RIGHT_SQL's behavior.",
            "Do remove the alias `average_ua` from the `AVG` aggregate instead of keeping it. Do move the `T2.Date` subquery filter to the end of the `WHERE` clause instead of placing it at the beginning. Do remove the correlation `WHERE ID = T1.ID` from the subquery instead of keeping it, making the subquery independent. Do adjust the parentheses grouping in the `WHERE` clause to properly associate the gender-specific UA thresholds with their respective conditions instead of the previous grouping that could cause logical ambiguity. The amended query now correctly calculates the average UA values without the unnecessary correlation in the subquery and with proper logical grouping of conditions.",
            "Do remove the correlated subquery condition `WHERE ID = T1.ID` from the `MAX(Date)` subquery instead of keeping it, making the subquery uncorrelated to find the global maximum date across all Laboratory records rather than per-patient maximum. Do ensure the WHERE clause properly groups the conditions with parentheses to maintain the intended logic of filtering by sex-specific UA thresholds and the global maximum date. The amended query now correctly calculates the average UA value for patients meeting sex-specific UA thresholds at the overall maximum laboratory date across all patients, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "uric acid (UA) with normal range refers to UA < 8.0 and SEX = 'M' or UA < 6.5 and SEX = 'F'; average UA index refers to AVG(UA)"
        ]
    },
    "1306": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'SLE' AND L.WBC BETWEEN 3.5 AND 9.0;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' \nAND T2.WBC BETWEEN 3.5 AND 9"
        ],
        "question": "How many patients diagnosed with SLE have a normal white blood cell level?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.WBC BETWEEN 3.5 AND 9",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do reference `T2.WBC BETWEEN 3.5 AND 9` instead of `L.WBC BETWEEN 3.5 AND 9.0` to use integer comparison without decimal precision. The amended query now correctly counts all patient records meeting the diagnostic and laboratory criteria without unnecessary distinct filtering."
        ],
        "rules": [
            "diagnosed with SLE refers to Diagnosis = 'SLE'; normal white blood cell level refers to WBC between 3.5 and 9.0;"
        ]
    },
    "1215": {
        "sql": [
            "SELECT P.ID, (L.TP - 8.5) AS TP_Deviation\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'F' AND L.TP > 8.5;",
            "SELECT T2.TP - 8.5\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'female' AND T2.TP > 8.5",
            "SELECT T2.TP - 8.5\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F' AND T2.TP > 8.5"
        ],
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "amends": [
            "Do use `T2.TP - 8.5` without an alias instead of `(L.TP - 8.5) AS TP_Deviation` with an alias. Do reference `T2.TP` instead of `L.TP` in the SELECT expression. Do use table aliases `T1` and `T2` instead of `P` and `L` throughout the query. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly matches the RIGHT_SQL's behavior without the column alias while maintaining the same logical filtering and calculation.",
            "Do use the literal 'F' for the SEX filter instead of 'female' to match the correct gender code representation. The amended query now correctly filters for female patients using the standardized code 'F' while maintaining the same join logic and calculation of TP - 8.5, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "female refers to SEX = 'F'; total protein (TP) beyond the normal index refers to TP > 8.5; deviation of TP index from normal refers to SUBTRACT(TP, 8.5)"
        ]
    },
    "631": {
        "sql": [
            "SELECT COUNT(*) AS NumberOfPosts\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Daniel Vassallo');",
            "SELECT COUNT(T2.Id) \nFROM users AS T1 \nJOIN postHistory AS T2 ON T1.Id = T2.UserId \nWHERE T1.DisplayName = 'Daniel Vassallo'"
        ],
        "question": "How many posts were created by Daniel Vassallo?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "amends": [
            "Do use `COUNT(T1.Id)` instead of `COUNT(*)` to count specific user-related records. Do join `users AS T1` with `postHistory AS T2` on `T1.Id = T2.UserId` instead of querying the `posts` table with a subquery. Do filter on `T1.DisplayName = 'Daniel Vassallo'` in the WHERE clause instead of using a subquery to find the user ID. Do remove the subquery entirely instead of maintaining the nested SELECT structure. The amended query now correctly counts post history entries for the specified user instead of posts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "DisplayName = 'Daniel Vassallo';"
        ]
    },
    "158": {
        "sql": [
            "SELECT a.district_id\nFROM account a\nJOIN `order` o ON a.account_id = o.account_id\nWHERE o.order_id = 33333;"
        ],
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "amends": [],
        "rules": []
    },
    "73": {
        "sql": [
            "SELECT f.\"Free Meal Count (Ages 5-17)\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.School = 'Youth Authority School' AND s.MailStreet = 'PO Box 1040';",
            "SELECT T1.\"FRPM Count (Ages 5-17)\"\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.MailStreet = 'PO Box 1040'\nAND T2.SOCType = 'Youth Authority Facilities'\nORDER BY T1.\"FRPM Count (Ages 5-17)\" DESC;"
        ],
        "question": "What is the free or reduced price meal count for ages 5 to 17 in the Youth Authority School with a mailing street address of PO Box 1040?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`FRPM Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.MailStreet = 'PO Box 1040' AND T2.SOCType = 'Youth Authority Facilities'",
        "amends": [
            "Do select `FRPM Count (Ages 5-17)` instead of `Free Meal Count (Ages 5-17)` as the column name. Do use table aliases `T1` and `T2` instead of `f` and `s` for better clarity. Do change the join from implicit `JOIN` to explicit `INNER JOIN` for consistency. Do remove the filter on `School = 'Youth Authority School'` instead of keeping it, as it's replaced by a more specific condition. Do add the filter `SOCType = 'Youth Authority Facilities'` instead of omitting it, which provides the proper school type identification. Do reorder the WHERE clause predicates for logical grouping. The amended query now correctly identifies youth authority facilities and retrieves the appropriate FRPM count data."
        ],
        "rules": []
    },
    "403": {
        "sql": [
            "SELECT \n    c.name AS card_name,\n    (COUNT(fd.id) * 100.0 / (SELECT COUNT(*) FROM cards)) AS percentage_spanish\nFROM \n    cards c\nLEFT JOIN \n    foreign_data fd ON c.uuid = fd.uuid AND fd.language = 'Spanish'\nGROUP BY \n    c.name\nHAVING \n    COUNT(fd.id) > 0\nORDER BY \n    c.name;",
            "SELECT \n    name,\n    (SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM foreign_data\nWHERE language = 'Spanish'\nGROUP BY name",
            "SELECT \n    (SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(*) \n     FROM foreign_data) AS percentage,\n    name\nFROM foreign_data\nWHERE language = 'Spanish'"
        ],
        "question": "Calculate the percentage of cards in Spanish. List them by name.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
        "amends": [
            "Do calculate the percentage using `SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END)` within a subquery instead of `COUNT(fd.id)` with a LEFT JOIN. Do remove the `GROUP BY c.name` and `HAVING COUNT(fd.id) > 0` clauses instead of grouping by card name and filtering for Spanish entries. Do select from `foreign_data` table directly with a `WHERE language = 'Spanish'` filter instead of joining with `cards` table. Do return both the calculated percentage and `name` columns instead of only card_name and percentage. Do eliminate the `ORDER BY c.name` clause instead of sorting the results. The amended query now correctly calculates the percentage of Spanish entries directly from the foreign_data table without unnecessary joins and grouping.",
            "Do calculate the percentage in a scalar subquery instead of using a GROUP BY clause. Do place the name column after the percentage calculation instead of before it. Do remove the GROUP BY name clause instead of keeping it since the percentage is now computed across all Spanish records. Do use CAST to REAL for the sum instead of implicit casting with 100.0. Do select both the percentage and name from the foreign_data table instead of just name with aggregated percentage. The amended query now correctly computes the overall percentage of Spanish records while still returning individual names from Spanish records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Spanish refer to language; Percentage refer to DIVIDE(SUM(ID where language = 'Spanish'), COUNT(id))*100"
        ]
    },
    "496": {
        "sql": [
            "SELECT s.baseSetSize\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.translation = 'Rinascita di Alara';"
        ],
        "question": "What is the number of cards are there in the set of \"Rinascita di Alara\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Rinascita di Alara'",
        "amends": [],
        "rules": [
            "number of cards refers to baseSetSize; set of \"Rinascita di Alara\" refers to translation = 'Rinascita di Alara'"
        ]
    },
    "1008": {
        "sql": [
            "SELECT p.lap\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nJOIN races r ON p.raceId = r.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND r.year = 2011 AND r.name = 'Australian Grand Prix';"
        ],
        "question": "During which lap did Lewis Hamilton take a pit stop during the 2011 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.lap FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' AND T3.year = 2011 AND T3.name = 'Australian Grand Prix'",
        "amends": [],
        "rules": []
    },
    "57": {
        "sql": [
            "SELECT s.Phone, s.Ext\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY sc.AvgScrWrite DESC\nLIMIT 1 OFFSET 332;"
        ],
        "question": "What is the phone number and extension number for the school that had the 333rd highest average writing score?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone, T2.Ext FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrWrite DESC LIMIT 332, 1",
        "amends": [],
        "rules": []
    },
    "359": {
        "sql": [
            "SELECT originalType FROM cards WHERE name = \"Ancestor's Chosen\";",
            "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL;"
        ],
        "question": "What is the type of the card \"Ancestor's Chosen\" as originally printed?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL",
        "amends": [
            "Do add `AND originalType IS NOT NULL` filter instead of omitting it to exclude null values from the results. Do use single quotes with proper escaping `'Ancestor''s Chosen'` instead of double quotes `\"Ancestor's Chosen\"` for string literals to maintain SQL standard compliance. The amended query now correctly filters out null originalType values while maintaining the same name matching logic."
        ],
        "rules": [
            "Ancestor's Chosen' is the name of card; type of the card as originally printed refers to originaltype;"
        ]
    },
    "1190": {
        "sql": [
            "WITH normal_proteinuria AS (\n    SELECT COUNT(DISTINCT ID) AS total_patients\n    FROM Laboratory\n    WHERE `U-PRO` > 0 AND `U-PRO` < 30\n),\nlow_uric_acid AS (\n    SELECT COUNT(DISTINCT ID) AS patients_with_low_ua\n    FROM Laboratory\n    WHERE `U-PRO` > 0 AND `U-PRO` < 30 AND UA <= 6.5\n)\nSELECT \n    CASE \n        WHEN total_patients = 0 THEN 0\n        ELSE (patients_with_low_ua * 100.0 / total_patients)\n    END AS percentage\nFROM normal_proteinuria, low_uric_acid;",
            "SELECT \n    CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) AS percentage\nFROM Laboratory\nWHERE `U-PRO` = '-' OR `U-PRO` = 'negative' OR `U-PRO` = 'Normal'",
            "SELECT \n    CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) AS percentage\nFROM Laboratory\nWHERE U-PRO > 0 AND U-PRO < 30",
            "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) \nFROM Laboratory \nWHERE `U-PRO` > 0 AND `U-PRO` < 30"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "What percentage of patients with a proteinuria level within the normal range have a uric acid level below the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Laboratory WHERE `U-PRO` > 0 AND `U-PRO` < 30",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs and cross join. Do calculate the percentage directly with `CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID)` instead of separate counts and division. Do remove the redundant `DISTINCT ID` counts and cross join between CTEs. Do eliminate the CASE statement for division by zero protection since COUNT(ID) will never be zero when filtering by `U-PRO` conditions. Do apply the `U-PRO` filter once in the WHERE clause instead of duplicating it across multiple CTEs. The amended query now correctly calculates the percentage of patients with low uric acid among those with normal proteinuria in a single efficient operation.",
            "Do change the WHERE clause filter to use numeric comparison `U-PRO > 0 AND U-PRO < 30` instead of string matching `U-PRO = '-' OR U-PRO = 'negative' OR U-PRO = 'Normal'` to properly handle numeric values rather than string representations. The amended query now correctly filters for U-PRO values between 0 and 30 and matches the RIGHT_SQL's behavior.",
            "Do use backticks around `U-PRO` column name instead of unquoted `U-PRO` to handle the hyphen properly in the WHERE clause. Do remove the alias `percentage` from the SELECT list instead of keeping it to match the simplified output format. The amended query now correctly handles the special character in the column name and produces the same calculation result without the output column alias."
        ],
        "rules": [
            "proteinuria level within the normal range refers to `U-PRO` > 0 AND `U-PRO` < 30; uric acid level below the normal range refers to UA < = 6.5; calculation = MULTIPLY(DIVIDE(UA < = 6.5, `U-PRO` > 0 AND `U-PRO` < 30)\uff0c100)"
        ]
    },
    "1068": {
        "sql": [
            "SELECT AVG(pa.overall_rating) AS average_overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height > 170\nAND strftime('%Y', pa.date) BETWEEN '2010' AND '2015';",
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_rating\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 170\nAND STRFTIME('%Y', t2.date) >= '2010' \nAND STRFTIME('%Y', t2.date) <= '2015'"
        ],
        "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
        "amends": [
            "Do use explicit division with `CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id)` instead of `AVG(pa.overall_rating)` to ensure proper floating-point calculation. Do reference tables as `t1` and `t2` instead of `p` and `pa` for consistent aliasing. Do use explicit `INNER JOIN` instead of just `JOIN` for clarity. Do split the date range into separate conditions `STRFTIME('%Y',t2.date) >= '2010' AND STRFTIME('%Y',t2.date) <= '2015'` instead of `BETWEEN '2010' AND '2015'` to ensure inclusive boundary handling. Do reference `t2.id` in the count instead of relying on implicit averaging behavior. The amended query now correctly calculates the average rating with proper floating-point precision and inclusive date filtering."
        ],
        "rules": [
            "from 2010 to 2015 refers to strftime('%Y', date) >= '2010' AND <= '2015'; average overall rating = SUM(t2.overall_rating)/ COUNT(t2.id); higher than 170 refers to Player.height > 170;"
        ]
    },
    "983": {
        "sql": [
            "SELECT c.name, c.url AS introduction_website, SUM(cs.points) AS total_points\nFROM constructors c\nJOIN constructorStandings cs ON c.constructorId = cs.constructorId\nWHERE c.nationality = 'Italian'\nGROUP BY c.constructorId\nORDER BY total_points DESC\nLIMIT 1;",
            "SELECT T1.url FROM constructors T1 INNER JOIN constructorStandings T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1;"
        ],
        "question": "Which of the Italian constructor got the highest point to date? Give its introduction website?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1",
        "amends": [
            "Do select only `T1.url` instead of `c.name, c.url AS introduction_website, SUM(cs.points) AS total_points`. Do use `INNER JOIN` with alias `T2` instead of `JOIN` with alias `cs`. Do reference `T1.constructorId = T2.constructorId` instead of `c.constructorId = cs.constructorId`. Do remove the `GROUP BY c.constructorId` clause instead of keeping it. Do order by `T2.points DESC` instead of `total_points DESC` to use the raw points value rather than a sum. The amended query now correctly retrieves the website URL of the Italian constructor with the highest points without unnecessary aggregation."
        ],
        "rules": [
            "introduction website refers to url; Italian is a nationality"
        ]
    },
    "160": {
        "sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS weekly_accounts_with_loan_under_200000\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND l.amount < 200000;"
        ],
        "question": "Among the weekly issuance accounts, how many have a loan of under 200000?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.amount < 200000",
        "amends": [],
        "rules": [
            "frequency = 'POPLATEK TYDNE' stands for weekly issuance"
        ]
    },
    "1216": {
        "sql": [
            "SELECT P.ID, P.Birthday, L.ALB\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND (L.ALB <= 3.5 OR L.ALB >= 5.5)\nORDER BY P.Birthday DESC;",
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'male' AND T2.ALB IS NOT NULL\nORDER BY T1.Birthday DESC;",
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' \nAND (T2.ALB <= 3.5 OR T2.ALB >= 5.5)\nORDER BY T1.Birthday DESC;"
        ],
        "question": "Sort in descending order all patients by birthday for male patient with albumin not within range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5) ORDER BY T1.Birthday DESC",
        "amends": [
            "Do select only `DISTINCT T1.ID` instead of `P.ID, P.Birthday, L.ALB` to return unique patient IDs rather than detailed records. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T2.ALB` in the WHERE condition instead of `L.ALB` to match the table alias change. The amended query now correctly returns distinct patient IDs with abnormal albumin levels while maintaining the same filtering logic and sorting by birthday descending.",
            "Do use `SEX = 'M'` instead of `SEX = 'male'` for the gender filter. Do add the condition `(T2.ALB <= 3.5 OR T2.ALB >= 5.5)` instead of just checking `ALB IS NOT NULL`. Do remove the unnecessary table aliases `AS` from the `FROM` clause while keeping the same join logic. The amended query now correctly filters for male patients with abnormal albumin values rather than just non-null values, matching the intended behavior."
        ],
        "rules": [
            "male = SEX = 'M'; albumin not within range refers to ALB < = 3.5 or ALB > = 5.5"
        ]
    },
    "464": {
        "sql": [
            "SELECT c.name\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE st.translation = 'Hauptset Zehnte Edition';"
        ],
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "amends": [],
        "rules": [
            "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'"
        ]
    },
    "892": {
        "sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name, MAX(ds.points) AS max_points\nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nGROUP BY ds.driverId\nORDER BY max_points DESC\nLIMIT 1;",
            "SELECT d.forename, d.surname, ds.points \nFROM driverStandings ds\nINNER JOIN drivers d ON ds.driverId = d.driverId\nINNER JOIN races r ON ds.raceId = r.raceId\nORDER BY ds.points DESC\nLIMIT 1;"
        ],
        "question": "State the driver with the most points scored. Find his full name with that points.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `full_name`, and do select actual `points` instead of aggregating with `MAX(points)`. Do join `races` table with `driverStandings` on `raceId` instead of omitting the races table entirely, and do use `INNER JOIN` on `T2.raceId = T1.raceId` instead of joining only drivers without race context. Do remove the `GROUP BY ds.driverId` clause instead of grouping by driver when individual race results are needed. Do order by actual `T2.points` instead of the aggregated `max_points`, maintaining the descending order. The amended query now correctly retrieves the highest points from individual race standings rather than maximum points per driver across all races, matching the RIGHT_SQL's behavior of showing the single highest race result."
        ],
        "rules": [
            "the most points scored refers to max(points); Full name of the driver refers to drivers.forename and drivers.surname;"
        ]
    },
    "1413": {
        "sql": [
            "SELECT DISTINCT m.zip\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost < 50;"
        ],
        "question": "Mention the zip code of member who incurred less than 50USD.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.zip FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.cost < 50",
        "amends": [],
        "rules": [
            "incurred less than 50USD refers to cost < 50"
        ]
    },
    "119": {
        "sql": [
            "SELECT a.account_id, d.A2 AS district_name, d.A3 AS district_region\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE strftime('%Y', a.date) = '1993' AND a.frequency = 'POPLATEK PO OBRATU';"
        ],
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "amends": [],
        "rules": [
            "Records about district names could be found in A2; A3 contains the information about regions. 'POPLATEK PO OBRATU' stands for issuance after transaction"
        ]
    },
    "83": {
        "sql": [
            "-- Part 1: Count of schools with magnet program serving K-8 and offering Multiple Provision Types\nSELECT COUNT(*) AS MagnetSchoolsWithMultipleProvision\nFROM frpm\nWHERE `Magnet` = 1 AND `Low Grade` = 'K' AND `High Grade` = '8' AND `NSLP Provision Status` = 'Multiple Provision Types';\n\n-- Part 2: Number of cities and schools serving K-8 grade span per city\nSELECT City, COUNT(*) AS NumberOfSchools\nFROM schools\nWHERE `Low Grade` = 'K' AND `High Grade` = '8'\nGROUP BY City;",
            "SELECT T2.City, COUNT(T2.CDSCode) AS school_count\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.Magnet = 1 \nAND T2.GSoffered = 'K-8'\nAND T1.\"NSLP Provision Status\" = 'Multiple Provision Types'\nGROUP BY T2.City"
        ],
        "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
        "amends": [
            "Do join `frpm AS T1` with `schools AS T2` on `T1.CDSCode = T2.CDSCode` instead of querying separate tables independently. Do filter on `T2.Magnet = 1` and `T2.GSoffered = 'K-8'` instead of checking individual grade columns `Low Grade` and `High Grade`. Do use `T1.`NSLP Provision Status` = 'Multiple Provision Types'` as a filter condition instead of treating it as a separate query part. Do select `T2.City` and count `T2.CDSCode` instead of separate counts without grouping. Do group by `T2.City` instead of omitting grouping in the first query. Do remove the separate city count query and combine all logic into a single joined query instead of maintaining two independent queries. The amended query now correctly joins the tables and provides city-level counts of magnet schools with K-8 offering and multiple provision types, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1; Multiple Provision Types refers to `NSLP Provision Status` = 'Multiple Provision Types'"
        ]
    },
    "281": {
        "sql": [
            "SELECT a.element, COUNT(*) AS tally\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+' AND substr(a.atom_id, 7, 1) = '4'\nGROUP BY a.element;",
            "SELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'\nAND SUBSTR(T1.atom_id, -1) = '4'\nAND LENGTH(T1.atom_id) = 7"
        ],
        "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
        "amends": [
            "Do use `DISTINCT T1.element` instead of `a.element, COUNT(*) AS tally` to return unique elements rather than counts. Do specify `FROM atom AS T1 INNER JOIN molecule AS T2` instead of `FROM molecule m JOIN atom a` to reverse the join direction and add explicit aliases. Do use `ON T1.molecule_id = T2.molecule_id` instead of `ON m.molecule_id = a.molecule_id` to maintain the same join logic with consistent aliases. Do keep `WHERE T2.label = '+'` instead of `WHERE m.label = '+'` with updated table reference. Do change to `SUBSTR(T1.atom_id, -1) = '4'` instead of `substr(a.atom_id, 7, 1) = '4'` to check the last character rather than position 7. Do add `AND LENGTH(T1.atom_id) = 7` instead of omitting this length validation. Do remove `GROUP BY a.element` instead of keeping it since aggregation is no longer needed. The amended query now correctly returns distinct elements meeting all specified conditions."
        ],
        "rules": [
            "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; "
        ]
    },
    "949": {
        "sql": [
            "SELECT c.name, SUM(cs.points) AS total_points\nFROM constructorStandings cs\nJOIN constructors c ON cs.constructorId = c.constructorId\nGROUP BY cs.constructorId\nORDER BY total_points DESC\nLIMIT 1;",
            "SELECT T2.name\nFROM constructorStandings T1\nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId\nORDER BY T1.points DESC\nLIMIT 1;"
        ],
        "question": "Which constructor has the highest point?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId ORDER BY T1.points DESC LIMIT 1",
        "amends": [
            "Do select only `T2.name` instead of `c.name, SUM(cs.points) AS total_points`. Do remove the `SUM` aggregate function and `GROUP BY cs.constructorId` instead of including them. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `cs` and `c`. Do keep the join condition `T1.constructorId = T2.constructorId` instead of `cs.constructorId = c.constructorId`. Do order by `T1.points DESC` instead of the aggregated `total_points DESC`. Do maintain `LIMIT 1` as in the original. The amended query now correctly retrieves the constructor with the highest points from a single standings record rather than attempting to sum points across multiple records."
        ],
        "rules": []
    },
    "764": {
        "sql": [
            "SELECT sp.power_name FROM hero_power hp JOIN superpower sp ON hp.power_id = sp.id WHERE hp.hero_id = 1;"
        ],
        "question": "What are the superpowers of heroes with ID 1?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1",
        "amends": [],
        "rules": [
            "superpowers refers to power_name; heroes with ID 1 refers to hero_id = 1;"
        ]
    },
    "92": {
        "sql": [
            "SELECT COUNT(DISTINCT d.district_id) AS number_of_districts\nFROM district d\nJOIN client c ON d.district_id = c.district_id\nWHERE c.gender = 'F' AND d.A11 > 6000 AND d.A11 < 10000;"
        ],
        "question": "List out the no. of districts that have female average salary is more than 6000 but less than 10000?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.district_id)  FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A11 BETWEEN 6000 AND 10000",
        "amends": [],
        "rules": [
            "A11 refers to average salary; Female mapps to gender = 'F'"
        ]
    },
    "632": {
        "sql": [
            "SELECT COUNT(*) AS vote_count\nFROM votes\nWHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'Harlan');",
            "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId WHERE T1.DisplayName = 'Harlan'"
        ],
        "question": "How many votes were made by Harlan?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId WHERE T1.DisplayName = 'Harlan'",
        "amends": [
            "Do add table joins with `users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId` instead of querying only the `votes` table. Do change the WHERE condition to filter on `T1.DisplayName = 'Harlan'` instead of using a subquery with `UserId = (SELECT Id FROM users WHERE DisplayName = 'Harlan')`. Do count `T1.Id` instead of counting all rows with `COUNT(*)`. Do remove the alias `AS vote_count` instead of keeping it. The amended query now correctly joins the necessary tables to count votes associated with the user 'Harlan' through their post history relationships."
        ],
        "rules": [
            "DisplayName = 'Harlan';"
        ]
    },
    "406": {
        "sql": [
            "SELECT c.id\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.types LIKE '%Creature%'\nAND l.status = 'legal';",
            "SELECT T1.id\nFROM cards AS T1\nINNER JOIN legalities AS T3 ON T1.uuid = T3.uuid\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.types = 'Creature'\nAND T3.status = 'Legal';"
        ],
        "question": "Lists by ID all Creature-type cards with legal status.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
        "amends": [
            "Do join `rulings AS T2` on `T1.uuid = T2.uuid` instead of omitting this table entirely. Do change the join type to `INNER JOIN` for both joins instead of just `JOIN`. Do use exact equality `T1.types = 'Creature'` instead of the pattern match `LIKE '%Creature%'`. Do capitalize the status comparison to `'Legal'` instead of `'legal'`. Do add table aliases `T1`, `T2`, and `T3` instead of using simple aliases `c` and `l`. The amended query now correctly joins the rulings table, uses precise type matching, and proper case sensitivity for status values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "legal status refer to status = 'legal'; Goblin-type cards refer to types = 'Creature';"
        ]
    },
    "911": {
        "sql": [
            "SELECT name, lat FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;",
            "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;"
        ],
        "question": "Which of these circuits is located at a higher latitude, Silverstone Circuit, Hockenheimring or Hungaroring?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1",
        "amends": [
            "Do remove `lat` from the SELECT list instead of including it, as only the `name` column is needed in the final output while still using `lat` for sorting purposes in the ORDER BY clause. The amended query now correctly returns only the circuit name with the highest latitude among the specified circuits, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "higher latitude refers to max(lat)"
        ]
    },
    "979": {
        "sql": [
            "SELECT raceId, COUNT(*) AS finisher_count\nFROM results\nWHERE time IS NOT NULL\nGROUP BY raceId\nORDER BY finisher_count DESC\nLIMIT 1;",
            "SELECT raceId, COUNT(time IS NOT NULL) AS finisher_count FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1;",
            "SELECT raceId FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1;",
            "SELECT raceId FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1;"
        ],
        "question": "What race number has the most finishers?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT raceId FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1",
        "amends": [
            "Do use `COUNT(time IS NOT NULL)` in the ORDER BY clause instead of `COUNT(*) AS finisher_count` in the SELECT list and then ordering by that alias. Do remove the explicit WHERE clause filtering for `time IS NOT NULL` instead of keeping it as a separate filter. Do omit the alias `finisher_count` in the SELECT list instead of including it. The amended query now correctly counts only non-null time values while grouping by raceId and ordering by that count, matching the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(time IS NOT NULL) AS finisher_count` column from the SELECT list instead of including it, as the query only needs to return the raceId. Do keep the `COUNT(time IS NOT NULL)` expression in the ORDER BY clause instead of removing it, maintaining the correct ordering by the count of non-null time values. Do preserve the GROUP BY raceId, WHERE filters (none present), and LIMIT 1 clauses without changes. The amended query now correctly returns only the raceId with the highest count of finishers (non-null time values) while matching the RIGHT_SQL's behavior.",
            "Do remove the `WHERE time IS NOT NULL` filter instead of keeping it, as the aggregate function `COUNT(time IS NOT NULL)` already handles NULL values correctly by counting only non-NULL occurrences. Do maintain the `GROUP BY raceId` clause and `ORDER BY COUNT(time IS NOT NULL) DESC` with `LIMIT 1` to find the race with the most non-NULL time values. The amended query now correctly counts non-NULL time values across all races without prematurely filtering rows, matching the intended behavior."
        ],
        "rules": [
            "finisher refers to time is not null;"
        ]
    },
    "267": {
        "sql": [
            "SELECT bond_type FROM bond WHERE molecule_id BETWEEN 'TR000' AND 'TR050';",
            "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'"
        ],
        "question": "List down the bond type for molecules from molecule id TR000 to TR050.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'",
        "amends": [
            "Do add `T2.molecule_id` to the SELECT list instead of omitting it. Do change the FROM clause to use `INNER JOIN` between `molecule AS T1` and `bond AS T2` with join condition `T1.molecule_id = T2.molecule_id` instead of querying only the `bond` table. Do move the filter condition to reference `T1.molecule_id` instead of `T2.molecule_id` while keeping the same `BETWEEN 'TR000' AND 'TR050'` predicate. The amended query now correctly joins the molecule and bond tables to return both molecule_id and bond_type for the specified molecule range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ]
    },
    "393": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE artist = 'John Avon' AND cardKingdomFoilId IS NULL;",
            "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon';"
        ],
        "question": "On how many cards designed by John Avon is its foil non-powerful?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do add parentheses around `cardKingdomId IS NULL OR cardKingdomFoilId IS NULL` instead of only checking `cardKingdomFoilId IS NULL` to include both conditions. Do move the artist filter `artist = 'John Avon'` to the end instead of having it first to maintain logical grouping with the NULL checks. The amended query now correctly counts cards where either cardKingdomId or cardKingdomFoilId is NULL for John Avon's artwork, matching the intended behavior."
        ],
        "rules": [
            "John Avon refer to artist; foil poweful foils refers to cardKingdomId and cardKingdomFoildId is NOT NULL \n"
        ]
    },
    "285": {
        "sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_10_11';",
            "SELECT DISTINCT T1.element \nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2\nINNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE T3.bond_id = 'TR001_10_11'"
        ],
        "question": "Name chemical elements that form a bond TR001_10_11.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_id = 'TR001_10_11'",
        "amends": [
            "Do select only `T1.element` instead of selecting `a1.element` and `a2.element` with aliases. Do use `atom AS T1` instead of `atom a1` and remove the second atom table join. Do add `INNER JOIN bond AS T3` on `T2.bond_id = T3.bond_id` instead of omitting the bond table entirely. Do change the WHERE condition to filter on `T3.bond_id` instead of filtering directly on `c.bond_id`. Do remove the second atom table reference and its join condition instead of keeping the dual atom table structure. The amended query now correctly joins through the bond table to filter bond relationships and returns only the relevant element data, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium; TR001_10_11 is the bond id; molecule id refers to SUBSTR(bond_id, 1, 5); atom 1 refers to SUBSTR(bond_id, 7, 2); atom 2 refers to SUBSTR(bond_id, 10, 2)"
        ]
    },
    "775": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN c.colour = 'Blue' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_blue_female\nFROM \n    superhero s\nJOIN \n    gender g ON s.gender_id = g.id\nLEFT JOIN \n    colour c ON s.skin_colour_id = c.id\nWHERE \n    g.gender = 'Female';"
        ],
        "question": "What is the percentage of blue female superheroes among all female superheroes?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.colour = 'Blue' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.gender = 'Female'",
        "amends": [],
        "rules": [
            "percentage = MULTIPLY(DIVIDE(SUM(colour = 'Blue' WHERE gender = 'Female'), COUNT(gender = 'Female')), 100); blue refers to the color = 'Blue' WHERE skin_colour_id = colour.id; female refers to gender = 'Female';"
        ]
    },
    "1521": {
        "sql": [
            "SELECT COUNT(*) \nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-26' \nAND t.Time BETWEEN '08:00:00' AND '09:00:00'\nAND g.Country = 'CZE';"
        ],
        "question": "For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'",
        "amends": [],
        "rules": [
            "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; '2012/8/26' can be represented by '2012-08-26'; during 8:00-9:00 can be represented as Time BETWEEN '08:00:00' AND '09:00:00'"
        ]
    },
    "1208": {
        "sql": [
            "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.GPT >= 60;"
        ],
        "question": "Provide IDs for male patients with ALT glutamic pylvic transaminase (GPT) that have history of ALT glutamic pylvic transaminase (GPT) exceed the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.GPT >= 60",
        "amends": [],
        "rules": [
            "male refers to SEX = 'M'; ALT glutamic pylvic transaminase (GPT) exceed the normal range refers to GPT > = 60"
        ]
    },
    "1512": {
        "sql": [
            "SELECT CustomerID, SUM(Amount * Price) AS TotalPaid\nFROM transactions_1k\nWHERE Date = '2012-08-25'\nGROUP BY CustomerID\nORDER BY TotalPaid DESC\nLIMIT 1;",
            "SELECT CustomerID, SUM(Price) \nFROM transactions_1k \nWHERE Date = '2012/8/25' \nGROUP BY CustomerID \nORDER BY SUM(Price) DESC \nLIMIT 1;",
            "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1"
        ],
        "question": "Which customer paid the most in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "amends": [
            "Do remove the `SUM(Amount * Price)` calculation and `TotalPaid` alias from the SELECT list instead of including them. Do change the ORDER BY clause to use `SUM(Price)` instead of the removed `TotalPaid` alias. Do remove the explicit column alias reference in ORDER BY since the aggregate expression is now directly specified. The amended query now correctly identifies the customer with the highest total price sum rather than calculating an incorrect amount-price product, matching the intended behavior of finding the customer with maximum spending based on price alone.",
            "Do remove the `SUM(Price)` column from the SELECT list instead of including it, as only the CustomerID is needed. Do use the date format `'2012-08-25'` instead of `'2012/8/25'` for proper date handling. Do maintain the GROUP BY CustomerID clause instead of altering it. Do keep the ORDER BY SUM(Price) DESC for sorting by total price instead of changing it. Do preserve the LIMIT 1 constraint instead of modifying it. The amended query now correctly returns only the CustomerID with the highest total transaction amount on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "'2012/8/25' can be represented by '2012-08-25'"
        ]
    },
    "1177": {
        "sql": [
            "SELECT \n    CASE \n        WHEN `T-CHO` BETWEEN 125 AND 200 THEN 'Normal'\n        ELSE 'Abnormal'\n    END AS Cholesterol_Status\nFROM Laboratory\nWHERE ID = 2927464 AND Date = '1995-09-04';"
        ],
        "question": "Was the total cholesterol status for the patient id 2927464 on 1995-9-4 at the normal level?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CASE WHEN `T-CHO` < 250 THEN 'Normal' ELSE 'Abnormal' END FROM Laboratory WHERE ID = 2927464 AND Date = '1995-09-04'",
        "amends": [],
        "rules": [
            "total cholesterol normal level refers to N < 250"
        ]
    },
    "1435": {
        "sql": [
            "SELECT event_name FROM event WHERE type = 'Game' AND status = 'Closed' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';"
        ],
        "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "amends": [],
        "rules": [
            "name of events refers event_name; game event that was closed refers to type = 'Game' where status = 'Closed'; event_date BETWEEN '2019-03-15' and '2020-03-20'; "
        ]
    },
    "1284": {
        "sql": [
            "SELECT p.`First Date`\nFROM Patient p\nJOIN (\n    SELECT l.ID, MAX(l.LDH) AS MaxLDH\n    FROM Laboratory l\n    WHERE l.LDH < 500\n    GROUP BY l.ID\n    ORDER BY MaxLDH DESC\n    LIMIT 1\n) max_ldh ON p.ID = max_ldh.ID;",
            "SELECT p.ID, MIN(l.Date) as first_recorded_date\nFROM Patient p\nINNER JOIN Laboratory l ON p.ID = l.ID\nWHERE l.LDH < 500\nORDER BY l.LDH ASC\nLIMIT 1;",
            "SELECT T1.`First Date`\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH < 500\nORDER BY T2.LDH ASC\nLIMIT 1"
        ],
        "question": "For the patient with the highest lactate dehydrogenase in the normal range, when was his or her data first recorded?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH < 500 ORDER BY T2.LDH ASC LIMIT 1",
        "amends": [
            "Do use a direct `INNER JOIN` between `Patient` and `Laboratory` tables instead of a subquery with aggregation. Do filter `LDH < 500` in the `WHERE` clause instead of within a subquery. Do order by `LDH ASC` instead of ordering by `MaxLDH DESC` in a subquery. Do remove the `GROUP BY` and `MAX` aggregation instead of including them unnecessarily. Do reference the joined table directly as `T2.LDH` instead of creating an alias `max_ldh`. The amended query now correctly finds the patient with the lowest LDH value below 500 instead of the highest, matching the RIGHT_SQL's behavior.",
            "Do use `T1.`First Date`` as the selected column instead of `p.ID, MIN(l.Date)` to return only the first date instead of both ID and a minimum date. Do remove the aggregation `MIN()` and alias `first_recorded_date` instead of keeping them since no grouping is needed. Do change table alias `p` to `T1` and `l` to `T2` instead of keeping the original aliases for consistency. Do use backticks around `First Date` instead of unquoted identifiers to handle potential reserved words or spaces. Do move the date selection directly to the SELECT list instead of using an aggregate function with grouping semantics. Do keep the `INNER JOIN` on `T1.ID = T2.ID` instead of changing the join type or condition. Do maintain the `WHERE T2.LDH < 500` filter instead of altering the predicate. Do preserve the `ORDER BY T2.LDH ASC` and `LIMIT 1` instead of modifying the sorting or limiting logic. The amended query now correctly returns only the earliest date for patients with LDH under 500 instead of attempting to aggregate without proper grouping."
        ],
        "rules": [
            "highest lactate dehydrogenase in the normal range refers to MAX(LDH < 500); when the data first recorded refers to MIN(First Date);"
        ]
    },
    "286": {
        "sql": [
            "WITH total_molecules AS (\n  SELECT COUNT(DISTINCT molecule_id) AS total\n  FROM molecule\n),\nmolecules_with_triple_bond AS (\n  SELECT COUNT(DISTINCT m.molecule_id) AS triple_bond_count\n  FROM molecule m\n  JOIN bond b ON m.molecule_id = b.molecule_id\n  WHERE b.bond_type = '#'\n)\nSELECT (triple_bond_count * 100.0 / total) AS percent_triple_bond\nFROM total_molecules, molecules_with_triple_bond;",
            "SELECT \n    CAST(COUNT(CASE WHEN bond_type = '#' THEN bond_id ELSE NULL END) AS REAL) * 100.0 / COUNT(bond_id) AS percentage\nFROM bond;"
        ],
        "question": "Among all chemical compounds identified in the database, what percent of compounds form a triple-bond.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for total counts. Do calculate percentage directly using `COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END)` instead of counting distinct molecules with triple bonds. Do operate on the `bond` table directly instead of joining with the `molecule` table. Do use `COUNT(T.bond_id)` as the denominator instead of counting distinct molecules. Do cast the result to `REAL` instead of using decimal multiplication. Do remove the CTE structure and perform all calculations in the main SELECT instead of using cross-joined CTEs. The amended query now correctly calculates the percentage of triple bonds among all bonds rather than the percentage of molecules containing triple bonds, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "triple bond refers to bond_type = '#';"
        ]
    },
    "121": {
        "sql": [
            "SELECT a.account_id, a.date\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE d.A2 = 'Prachatice';"
        ],
        "question": "List account ID and account opening date for accounts from 'Prachatice'.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T1.date FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Prachatice'",
        "amends": [],
        "rules": [
            "A2 refers to the names of districts."
        ]
    },
    "217": {
        "sql": [
            "SELECT DISTINCT a2.*\nFROM atom a1\nJOIN connected c ON a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2\nJOIN atom a2 ON (a2.atom_id = c.atom_id OR a2.atom_id = c.atom_id2) AND a2.atom_id != a1.atom_id\nWHERE a1.molecule_id = 'TR181';",
            "SELECT T2.atom_id, T2.atom_id2\nFROM connected T2\nINNER JOIN atom T1 ON T2.atom_id = T1.atom_id\nWHERE T1.molecule_id = 'TR181'"
        ],
        "question": "Identify all the atoms that are connected to the atoms of the TR181 molecule.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T1.molecule_id = 'TR181'",
        "amends": [
            "Do select specific columns `T2.atom_id` and `T2.atom_id2` instead of selecting all columns with `a2.*`. Do use `INNER JOIN` on `T2.atom_id = T1.atom_id` instead of complex `JOIN` conditions with `OR` clauses and self-join logic. Do remove the `DISTINCT` modifier instead of keeping it. Do simplify the join structure by removing the second `atom` table join and instead directly query from the `connected` table. Do remove the additional filter condition `a2.atom_id != a1.atom_id` instead of including it. Do use table aliases `T1` and `T2` instead of `a1`, `c`, and `a2`. The amended query now correctly retrieves connected atom pairs from the specified molecule without unnecessary complexity and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "TR181 molecule refers to molecule_id = 'TR181'"
        ]
    },
    "1408": {
        "sql": [
            "SELECT SUM(cost) AS total_parking_cost FROM expense WHERE expense_description LIKE '%Parking%';"
        ],
        "question": "Calculate the total cost spent for Parking in the list.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Parking'",
        "amends": [],
        "rules": [
            "total cost spent for Parking refers to SUM(cost) where expense_description = 'Parking'"
        ]
    },
    "1290": {
        "sql": [
            "SELECT e.\"Examination Date\"\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE l.ALB BETWEEN 3.5 AND 5.5\nORDER BY l.ALB DESC\nLIMIT 1;",
            "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1;"
        ],
        "question": "What is the examination date of the patient whose albumin is the highest in the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1",
        "amends": [
            "Do select `Date` instead of `e.\"Examination Date\"` from the `Laboratory` table instead of joining `Examination` and `Laboratory` tables. Do use simple WHERE conditions `ALB > 3.5 AND ALB < 5.5` instead of `BETWEEN 3.5 AND 5.5` to exclude the boundary values. Do remove the unnecessary table join and examination date reference since all required data exists in the Laboratory table alone. The amended query now correctly retrieves the date from Laboratory records where albumin levels fall strictly within the specified range, matching the right SQL's behavior."
        ],
        "rules": [
            "examination date refers to Date; albumin is the highest in the normal range refers to MAX(ALB > 3.5 and ALB < 5.5);"
        ]
    },
    "1402": {
        "sql": [
            "SELECT t_shirt_size, COUNT(t_shirt_size) AS size_count FROM member GROUP BY t_shirt_size ORDER BY size_count DESC LIMIT 1;",
            "SELECT t_shirt_size FROM member GROUP BY t_shirt_size ORDER BY COUNT(t_shirt_size) DESC LIMIT 1;"
        ],
        "question": "What is the most popular size of t-shirt ordered by the club members?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT t_shirt_size FROM member GROUP BY t_shirt_size ORDER BY COUNT(t_shirt_size) DESC LIMIT 1",
        "amends": [
            "Do select only `t_shirt_size` instead of including `COUNT(t_shirt_size) AS size_count` in the SELECT list. Do order by `COUNT(t_shirt_size)` directly instead of referencing the alias `size_count` in the ORDER BY clause. The amended query now correctly returns only the t_shirt_size with the highest count while maintaining the same grouping and limiting behavior."
        ],
        "rules": [
            "most popular size of t-shirt ordered refers to MAX(COUNT(t_shirt_size))"
        ]
    },
    "549": {
        "sql": [
            "SELECT p.Body \nFROM tags t \nJOIN posts p ON t.ExcerptPostId = p.Id \nWHERE t.TagName = 'bayesian';"
        ],
        "question": "From which post is the tag \"bayesian\" excerpted from? Please give the body of the post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Body FROM tags AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.ExcerptPostId WHERE T1.TagName = 'bayesian'",
        "amends": [],
        "rules": [
            "\"bayesian\" is the TagName; excerpt from refers to ExcerptPostId"
        ]
    },
    "2": {
        "sql": [
            "SELECT DISTINCT s.Zip\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.\"Charter School (Y/N)\" = 1 AND f.\"County Name\" = 'Fresno County Office of Education';",
            "SELECT T2.Zip\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"District Name\" = 'Fresno County Office of Education'\nAND T1.\"Charter School (Y/N)\" = 1"
        ],
        "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it. Do change the column reference from `s.Zip` to `T2.Zip` instead of using the original alias. Do change the table alias from `f` to `T1` and from `s` to `T2` instead of the original aliases. Do change the join from `JOIN` to `INNER JOIN` instead of the implicit join type. Do change the WHERE condition from `f.\"County Name\" = 'Fresno County Office of Education'` to `T1.\"District Name\" = 'Fresno County Office of Education'` instead of using the wrong column name. Do keep the condition `T1.\"Charter School (Y/N)\" = 1` instead of changing it. The amended query now correctly filters by district name instead of county name and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Charter schools refers to `Charter School (Y/N)` = 1 in the table fprm"
        ]
    },
    "1070": {
        "sql": [
            "SELECT c.name AS country_name\nFROM League l\nJOIN Country c ON l.country_id = c.id\nWHERE l.name = 'Italy Serie A';"
        ],
        "question": "Which country is the league Italy Serie A from?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Italy Serie A'",
        "amends": [],
        "rules": [
            "Italy Serie A from refers to League.name = 'Italy Serie A';"
        ]
    },
    "1319": {
        "sql": [
            "SELECT m.college\nFROM member AS mem\nJOIN major AS m ON mem.link_to_major = m.major_id\nWHERE mem.position = 'Vice President';"
        ],
        "question": "Which college is the vice president of the Student_Club from?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position LIKE 'vice president'",
        "amends": [],
        "rules": [
            "Vice President is a position of the Student Club"
        ]
    },
    "1486": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN c.Currency = 'CZK' THEN 1 END) - COUNT(CASE WHEN c.Currency = 'EUR' THEN 1 END)) AS MoreSMEsInCZK\nFROM \n    customers c\nJOIN \n    transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE \n    c.Segment = 'SME';",
            "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') AS difference\nFROM customers\nWHERE Segment = 'SME';"
        ],
        "question": "Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') FROM customers WHERE Segment = 'SME'",
        "amends": [
            "Do use `SUM(Currency = 'CZK') - SUM(Currency = 'EUR')` instead of `COUNT(CASE WHEN c.Currency = 'CZK' THEN 1 END) - COUNT(CASE WHEN c.Currency = 'EUR' THEN 1 END)` for more efficient boolean aggregation. Do remove the unnecessary `JOIN transactions_1k t ON c.CustomerID = t.CustomerID` instead of including it, as the customer currency data is already available in the customers table. Do keep the `WHERE Segment = 'SME'` filter in the same position. The amended query now correctly calculates the difference between CZK and EUR customers without the extraneous join that could distort counts through duplicate transactions."
        ],
        "rules": [
            "Amount of more SMEs = Total of SMEs pay using Currency CZK - Total of SMEs pay using Currency EUR"
        ]
    },
    "477": {
        "sql": [
            "SELECT DISTINCT c.artist\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Coldsnap'\nAND c.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy');"
        ],
        "question": "Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (T2.name = 'Coldsnap' AND T1.artist = 'Chippy') OR (T2.name = 'Coldsnap' AND T1.artist = 'Aaron Miller') OR (T2.name = 'Coldsnap' AND T1.artist = 'Jeremy Jarvis') GROUP BY T1.artist",
        "amends": [],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; Jeremy Jarvis, Aaron Miller or Chippy are the name of artists which refers to artist IN ('Jeremy Jarvis', 'Aaron Miller','Chippy');"
        ]
    },
    "1311": {
        "sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p \nJOIN Examination e ON p.ID = e.ID \nJOIN Laboratory l ON p.ID = l.ID \nWHERE e.Thrombosis = 1 \nAND l.PT BETWEEN 10 AND 14;"
        ],
        "question": "How many patients with severe thrombosis have a normal prothrombin time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.PT < 14 AND T3.Thrombosis < 3 AND T3.Thrombosis > 0",
        "amends": [],
        "rules": [
            "severe thrombosis refers to Thrombosis = 2 or 1; normal prothrombin time refers to PT < 14;"
        ]
    },
    "1481": {
        "sql": [
            "",
            "SELECT \n    CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'SME', T1.CustomerID, NULL)) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'LAM', T1.CustomerID, NULL)) AS SME_LAM_Difference,\n    CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'LAM', T1.CustomerID, NULL)) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'KAM', T1.CustomerID, NULL)) AS LAM_KAM_Difference,\n    CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'KAM', T1.CustomerID, NULL)) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'SME', T1.CustomerID, NULL)) AS KAM_SME_Difference\nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK' \nAND T2.Date BETWEEN '201301' AND '201312';",
            "SELECT \n    CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) AS SME_LAM_Difference,\n    CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) AS LAM_KAM_Difference,\n    CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) AS KAM_SME_Difference\nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK' \n    AND T2.Date BETWEEN 201301 AND 201312\n    AND T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth)"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(Consumption) FROM yearmonth ) AND T2.Date BETWEEN 201301 AND 201312",
        "amends": [
            "Do use `SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) / COUNT(T1.CustomerID) - SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) / COUNT(T1.CustomerID)` instead of incorrect segment comparisons, and do add `CAST(... AS REAL)` around each division operation instead of omitting explicit casting to ensure proper numeric precision. Do include all three difference calculations between SME-LAM, LAM-KAM, and KAM-SME segments instead of incomplete logic. Do maintain the `FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID` structure with correct join condition. Do keep the `WHERE T1.Currency = 'CZK'` filter but do remove the incorrect `T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth)` subquery condition instead of including it, as it incorrectly filters to only the minimum consumption record rather than all relevant records. Do retain the `T2.Date BETWEEN 201301 AND 201312` date range filter. The amended query now correctly calculates average consumption differences between segments for all CZK currency customers within the specified date range.",
            "Do use `COUNT(T1.CustomerID)` instead of `COUNT(DISTINCT IIF(T1.Segment = 'SME', T1.CustomerID, NULL))` and similar conditional counts for all segment calculations to count all customers rather than segment-specific distinct counts. Do add `AND T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth)` to the WHERE clause instead of omitting this filter condition. Do use integer literals `201301` and `201312` instead of string literals `'201301'` and `'201312'` for the date range comparison. Do remove the column aliases `SME_LAM_Difference`, `LAM_KAM_Difference`, and `KAM_SME_Difference` instead of keeping them. The amended query now correctly calculates average consumption differences across segments while filtering for minimum consumption values and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "annual average consumption of customer with the lowest consumption in each segment = total consumption per year / the number of customer with lowest consumption in each segment; Difference in annual average = SME's annual average - LAM's annual average; Difference in annual average = LAM's annual average - KAM's annual average; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year."
        ]
    },
    "776": {
        "sql": [
            "SELECT s.superhero_name, r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.full_name = 'Charles Chandler';"
        ],
        "question": "Provide the hero name and race of Charles Chandler.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.full_name = 'Charles Chandler'",
        "amends": [],
        "rules": [
            "hero name refers to superhero_name; Charles Chandler is the full name of superhero;"
        ]
    },
    "51": {
        "sql": [
            "SELECT s.MailStreet, s.School\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY sc.AvgScrRead ASC\nLIMIT 1;",
            "SELECT T2.MailStreet, T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;"
        ],
        "question": "In which mailing street address can you find the school that has the lowest average score in reading? Also give the school's name.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "amends": [
            "Do add `WHERE T1.AvgScrRead IS NOT NULL` instead of omitting it to exclude null average reading scores from consideration. Do use table aliases `T1` and `T2` instead of full table names for better readability. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. The amended query now correctly filters out null values before ordering, ensuring the lowest non-null average reading score is selected, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "643": {
        "sql": [
            "SELECT DisplayName, Age FROM users ORDER BY Views DESC LIMIT 1;"
        ],
        "question": "What are the display names and ages of user who got the highest in views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName, Age FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "amends": [],
        "rules": [
            "the highest in views refers to MAX(Views);"
        ]
    },
    "1320": {
        "sql": [
            "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nWHERE m.first_name = 'Maya' AND m.last_name = 'Mclean';"
        ],
        "question": "Please list the event names of all the events attended by Maya Mclean.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean'",
        "amends": [],
        "rules": []
    },
    "774": {
        "sql": [
            "SELECT r.race \nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.superhero_name = 'A-Bomb';"
        ],
        "question": "Which group does superhero A-Bomb belong to?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'",
        "amends": [],
        "rules": [
            "group refers to race; A-Bomb refers to superhero_name = 'A-Bomb';"
        ]
    },
    "1172": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.`T-BIL` >= 2.0;"
        ],
        "question": "How many male patients have elevated total bilirubin count?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "amends": [],
        "rules": [
            "male refers to SEX = 'M'; elevated means above the normal range; total bilirubin above the normal range refers to `T-BIL` >= '2.0'"
        ]
    },
    "1143": {
        "sql": [
            "SELECT MAX(home_team_goal) AS highest_home_score\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Netherlands Eredivisie');"
        ],
        "question": "What was the highest score of the home team in the Netherlands Eredivisie league?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT MAX(t2.home_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Netherlands Eredivisie'",
        "amends": [],
        "rules": [
            "highest score of the home team refers to MAX(home_team_goal)"
        ]
    },
    "322": {
        "sql": [
            "SELECT element FROM atom WHERE atom_id = 'TR000_1';"
        ],
        "question": "What is the element of toxicology for the atom with the ID of TR000_1?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.element FROM atom AS T WHERE T.atom_id = 'TR000_1'",
        "amends": [],
        "rules": [
            "atom with ID refers to atom_id; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "1471": {
        "sql": [
            "SELECT \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'EUR') * 1.0 / \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'CZK') AS ratio_EUR_to_CZK;"
        ],
        "question": "What is the ratio of customers who pay in EUR against customers who pay in CZK?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) AS ratio FROM customers",
        "amends": [],
        "rules": [
            "ratio of customers who pay in EUR against customers who pay in CZK = count(Currency = 'EUR') / count(Currency = 'CZK')."
        ]
    },
    "904": {
        "sql": [
            "SELECT r.name AS race_name, r.year AS race_year\nFROM results res\nJOIN drivers d ON res.driverId = d.driverId\nJOIN races r ON res.raceId = r.raceId\nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher'\nAND res.milliseconds = (SELECT MIN(milliseconds) FROM results WHERE driverId = d.driverId);",
            "SELECT r.name, r.year \nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nJOIN races r ON lt.raceId = r.raceId\nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher'\nORDER BY lt.milliseconds ASC\nLIMIT 1;"
        ],
        "question": "State the race and year of race in which Michael Schumacher had his fastest lap.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' ORDER BY T2.milliseconds ASC LIMIT 1",
        "amends": [
            "Do use `lapTimes` table instead of `results` table for joining with `drivers` and `races`. Do change the join condition to `T2.raceId = T1.raceId` instead of `res.raceId = r.raceId`. Do use `T3.driverId = T2.driverId` instead of `res.driverId = d.driverId` for the driver join. Do remove the subquery approach for finding minimum milliseconds instead of using it. Do add `ORDER BY T2.milliseconds ASC LIMIT 1` instead of the subquery filter to get the fastest lap. Do change the column aliases to simple `name` and `year` instead of `race_name` and `race_year`. The amended query now correctly identifies Michael Schumacher's fastest lap by ordering lap times and limiting to one result instead of using a potentially incorrect subquery approach."
        ],
        "rules": [
            "fastest lap refers to min(milliseconds); Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;"
        ]
    },
    "1404": {
        "sql": [
            "SELECT e.expense_description AS type, SUM(e.cost) AS total_value\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'October Meeting' AND e.approved = 'approved'\nGROUP BY e.expense_description;",
            "SELECT T1.type, SUM(T3.cost) AS total_value\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'October Meeting'\nGROUP BY T1.type"
        ],
        "question": "Identify the type of expenses and their total value approved for 'October Meeting' event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'",
        "amends": [
            "Do use `T1.type` instead of `e.expense_description AS type` in the SELECT list. Do use `SUM(T3.cost)` instead of `SUM(e.cost) AS total_value` for the aggregate expression. Do use `event AS T1` instead of `expense e` as the primary FROM source. Do use `INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event` instead of `JOIN budget b ON e.link_to_budget = b.budget_id` for the first join with corrected table aliases and join direction. Do use `INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget` instead of `JOIN event ev ON b.link_to_event = ev.event_id` for the second join with proper table aliases and join condition. Do remove the `e.approved = 'approved'` filter instead of keeping it in the WHERE clause. Do remove the GROUP BY clause instead of including `e.expense_description`. The amended query now correctly aggregates expenses for the October Meeting without the unnecessary approval filter and grouping."
        ],
        "rules": [
            "total value refers to SUM(cost); 'October Meeting' is an event name;"
        ]
    },
    "716": {
        "sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN u.UpVotes = 0 THEN c.UserId END) * 100.0 / COUNT(DISTINCT c.UserId)) AS percentage\nFROM \n    comments c\nJOIN \n    users u ON c.UserId = u.Id\nWHERE \n    c.Score BETWEEN 5 AND 10;",
            "SELECT \n    (CAST(SUM(IIF(T2.UpVotes = 0, 1, 0)) AS REAL) / COUNT(T1.Id)) * 100.0 AS percentage\nFROM \n    comments T1\nINNER JOIN \n    users T2 ON T1.UserId = T2.Id\nWHERE \n    T1.Score BETWEEN 5 AND 10"
        ],
        "question": "Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10",
        "amends": [
            "Do use `SUM(IIF(T1.UpVotes = 0, 1, 0))` with explicit `CAST` to `REAL` instead of `COUNT(DISTINCT CASE WHEN u.UpVotes = 0 THEN c.UserId END)` for the numerator calculation. Do count `T1.Id` instead of `c.UserId` for the denominator to ensure accurate user counting. Do use `INNER JOIN` with `T1.Id = T2.UserId` instead of `JOIN` with `c.UserId = u.Id` for proper table aliasing and join condition clarity. Do place the `Score BETWEEN 5 AND 10` filter on the comments table instead of maintaining the same condition. Do remove the `DISTINCT` qualifiers from both counts instead of keeping them to avoid unnecessary deduplication. Do use explicit table aliases `T1` and `T2` instead of `u` and `c` for better readability. The amended query now correctly calculates the percentage of users with zero upvotes who made comments with scores between 5-10, matching the intended behavior."
        ],
        "rules": [
            "percentage = DIVIDE(COUNT(UserId where UpVotes = 0 and Score BETWEEN 5 and 10))*100, (COUNT(UserId where Score BETWEEN 5 and 10));"
        ]
    },
    "958": {
        "sql": [
            "SELECT d.forename, d.surname\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.milliseconds IS NOT NULL\nORDER BY r.milliseconds ASC\nLIMIT 1;",
            "SELECT T2.forename, T2.surname, T1.fastestLapTime\nFROM results T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T1.fastestLapTime IS NOT NULL\nORDER BY T1.fastestLapTime ASC\nLIMIT 1;"
        ],
        "question": "Which driver has the fastest lap time? Please give their forenames and surnames.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.forename, T2.surname, T1.fastestLapTime FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T1.fastestLapTime IS NOT NULL ORDER BY T1.fastestLapTime ASC LIMIT 1",
        "amends": [
            "Do select `T2.forename`, `T2.surname`, and `T1.fastestLapTime` instead of only `d.forename` and `d.surname`. Do use `INNER JOIN` with aliases `T1` for `results` and `T2` for `drivers` instead of `JOIN` with aliases `r` and `d`. Do filter on `T1.fastestLapTime IS NOT NULL` instead of `r.milliseconds IS NOT NULL`. Do order by `T1.fastestLapTime ASC` instead of `r.milliseconds ASC`. The amended query now correctly identifies the fastest lap time rather than milliseconds and includes the fastest lap time in the output."
        ],
        "rules": []
    },
    "275": {
        "sql": [
            "SELECT DISTINCT molecule_id FROM bond WHERE bond_type = ' = ';",
            "SELECT T.molecule_id FROM bond T WHERE T.bond_type = '='"
        ],
        "question": "Give me the molecule ID of the double bond type.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '='",
        "amends": [
            "Do use table alias `T` for the `bond` table instead of omitting it, and do reference `T.molecule_id` instead of just `molecule_id` to make the column reference explicit. Do use `T.bond_type = '='` instead of `bond_type = ' = '` to remove the extra spaces around the equals sign in the string comparison. The amended query now correctly matches RIGHT_SQL's behavior with proper table aliasing and accurate string matching."
        ],
        "rules": [
            "double bond refers to bond_type = ' = ';"
        ]
    },
    "839": {
        "sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.weight_kg < 100 AND c.colour = 'brown';",
            "SELECT T1.full_name\nFROM superhero T1\nINNER JOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T1.weight_kg < 100\nAND T2.colour = 'Brown';"
        ],
        "question": "In superheroes with weight less than 100, list the full name of the superheroes with brown eyes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Brown'",
        "amends": [
            "Do use explicit `INNER JOIN` instead of implicit `JOIN` for clarity. Do reference the colour table as `T2` instead of `c` for consistent aliasing. Do use uppercase `'Brown'` instead of lowercase `'brown'` for the colour filter to match the exact case in the data. Do qualify all column references with table aliases (`T1.full_name`, `T1.weight_kg`, `T2.colour`) instead of using unqualified column names for better readability and to avoid potential ambiguity. The amended query now correctly filters for brown eye colour with proper case sensitivity and maintains consistent table aliasing throughout."
        ],
        "rules": [
            "weight less than 100 refers to weight_kg < 100"
        ]
    },
    "1307": {
        "sql": [
            "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE (L.RBC <= 3.5 OR L.RBC >= 6.0) AND P.Admission = '-';"
        ],
        "question": "Please list the patient's ID if he or she has an abnormal level of red blood cell and is followed at the outpatient clinic.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RBC <= 3.5 OR T2.RBC >= 6) AND T1.Admission = '-'",
        "amends": [],
        "rules": [
            "RBC < = 3.5 or RBC > = 6.0 means the patient has an abnormal level of red blood cell; 3.5 < RBC < 6.0 means the patient has a normal level of red blood cell; followed at the outpatient clinic refers to Admission = '-';"
        ]
    },
    "258": {
        "sql": [
            "SELECT DISTINCT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'sn';"
        ],
        "question": "What are the bond type for atoms with element Tin?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "amends": [],
        "rules": [
            "element Tin refers to element = 'sn'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#'"
        ]
    },
    "484": {
        "sql": [
            "WITH ColdsnapCards AS (\n    SELECT c.id, c.name, c.convertedManaCost, c.uuid\n    FROM cards c\n    JOIN sets s ON c.setCode = s.code\n    WHERE s.name = 'Coldsnap'\n),\nMaxCMC AS (\n    SELECT MAX(convertedManaCost) AS max_cmc\n    FROM ColdsnapCards\n)\nSELECT fd.name AS italian_name\nFROM foreign_data fd\nJOIN ColdsnapCards cc ON fd.uuid = cc.uuid\nJOIN MaxCMC m ON cc.convertedManaCost = m.max_cmc\nWHERE fd.language = 'Italian';",
            "SELECT T1.name AS italian_name\nFROM foreign_data T1\nINNER JOIN cards T2 ON T1.uuid = T2.uuid\nINNER JOIN sets T3 ON T2.setCode = T3.code\nWHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'\nORDER BY T2.convertedManaCost DESC;",
            "SELECT T2.name\nFROM foreign_data T1\nINNER JOIN cards T2 ON T2.uuid = T1.uuid\nINNER JOIN sets T3 ON T3.code = T2.setCode\nWHERE T3.name = 'Coldsnap'\nAND T1.language = 'Italian'\nORDER BY T2.convertedManaCost DESC;"
        ],
        "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
        "amends": [
            "Do use a single query with `INNER JOIN` between `foreign_data`, `cards`, and `sets` tables instead of using CTEs with separate `ColdsnapCards` and `MaxCMC` subqueries. Do filter directly with `T3.name = 'Coldsnap'` in the WHERE clause instead of creating a separate CTE for Coldsnap cards. Do add `ORDER BY T2.convertedManaCost DESC` to sort by converted mana cost in descending order instead of attempting to find maximum CMC through a separate CTE join. Do remove the unnecessary `MaxCMC` CTE and its join condition `cc.convertedManaCost = m.max_cmc` instead of trying to match maximum converted mana cost values. Do select `T2.name` (the card name from cards table) instead of selecting `fd.name` as italian_name from foreign_data. Do use table aliases `T1`, `T2`, and `T3` for clarity instead of the original table names. The amended query now correctly retrieves Italian card names from the Coldsnap set ordered by converted mana cost, matching the RIGHT_SQL's behavior.",
            "Do select `T2.name` instead of `T1.name AS italian_name` to retrieve the card name from the correct table. Do maintain the same `INNER JOIN` structure between `foreign_data T1` and `cards T2` but correct the join condition to `T2.uuid = T1.uuid` instead of `T1.uuid = T2.uuid` for proper table relationship. Do keep the `INNER JOIN` with `sets T3` on `T3.code = T2.setCode` instead of `T2.setCode = T3.code` for consistent join direction. Do preserve the `WHERE` filters for `T3.name = 'Coldsnap'` and `T1.language = 'Italian'` unchanged. Do maintain the `ORDER BY T2.convertedManaCost DESC` clause without modification. The amended query now correctly retrieves card names from the cards table rather than Italian names from foreign_data, while maintaining the same filtering and sorting logic to match the intended behavior."
        ],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'; highest converted mana cost refers to MAX(convertedManaCost)"
        ]
    },
    "1098": {
        "sql": [
            "SELECT MAX(ta.chanceCreationPassing) AS highest_chance_creation_passing, ta.chanceCreationPassingClass\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE t.team_long_name = 'Ajax';"
        ],
        "question": "What is Ajax's highest chance creation passing score and what is it classified as?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Ajax' ORDER BY t2.chanceCreationPassing DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Ajax's refers to team_long_name = 'Ajax'; chance creation passing score refers to MAX(chanceCreationPassing); classified refer to chanceCreationPassingClass"
        ]
    },
    "1186": {
        "sql": [
            "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Diagnosis LIKE '%Behcet%'\nAND e.`Examination Date` >= '1997-01-01'\nAND e.`Examination Date` <= '1997-12-31';",
            "SELECT ID FROM Examination WHERE Diagnosis = 'Behcet' AND \"Examination Date\" BETWEEN '1970-01-01' AND '1997-12-31'",
            "SELECT ID FROM Examination WHERE Diagnosis = 'Behcet' AND `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31'"
        ],
        "question": "Lists all patients by ID who were diagnosed with Behcet's and had their exams between 01/01/197 and 12/31/1997.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT ID FROM Examination WHERE `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31' AND Diagnosis = 'Behcet'",
        "amends": [
            "Do remove the `Patient` table and join condition `p.ID = e.ID` instead of including an unnecessary join. Do change the WHERE filter to use `Diagnosis = 'Behcet'` instead of `LIKE '%Behcet%'` for exact matching. Do remove the DISTINCT modifier instead of keeping it since duplicates are handled by the examination-focused logic. Do change the date filter to use `BETWEEN` instead of separate `>=` and `<=` conditions. The amended query now correctly focuses solely on the Examination table with precise filtering, matching the RIGHT_SQL's behavior.",
            "Do use backticks for `Examination Date` column name instead of double quotes to ensure proper identifier quoting. Do change the date range filter to `BETWEEN '1997-01-01' AND '1997-12-31'` instead of the incorrect `BETWEEN '1970-01-01' AND '1997-12-31'` to properly constrain the examination period to only 1997. Do maintain the same logical order of conditions but ensure the date filter covers the correct year range. The amended query now correctly identifies examinations from 1997 with Behcet diagnosis instead of potentially including examinations from a much broader 27-year period."
        ],
        "rules": [
            "'Behcet' refers to diagnosis; exam between 01/01/1997 and 12/31/1997 refers to YEAR(Description) > = '1997-1-1' AND YEAR(Description) < '1998-1-1'"
        ]
    },
    "724": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id AND eye_colour.colour = 'Blue'\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id AND hair_colour.colour = 'Blond';\n"
        ],
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "amends": [],
        "rules": [
            "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; blond hair refers to colour = 'Blond' and hair_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'"
        ]
    },
    "362": {
        "sql": [
            "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Condemn';"
        ],
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "amends": [],
        "rules": [
            "Ancestor's Chosen' is the name of card; description about the ruling refers to text;"
        ]
    },
    "14": {
        "sql": [
            "SELECT s.NCESchool, f.\"School Name\", f.\"Enrollment (Ages 5-17)\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nORDER BY f.\"Enrollment (Ages 5-17)\" DESC\nLIMIT 5;",
            "SELECT T1.NCESSchool\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.`Enrollment (Ages 5-17)` DESC\nLIMIT 5"
        ],
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "amends": [
            "Do select only `T1.NCESSchool` instead of including `s.NCESchool`, `f.School Name`, and `f.Enrollment (Ages 5-17)` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `s` and `f`. Do join on `T1.CDSCode = T2.CDSCode` instead of `f.CDSCode = s.CDSCode` to maintain proper join direction. Do order by `T2.Enrollment (Ages 5-17)` instead of `f.Enrollment (Ages 5-17)` using backticks for the column name. The amended query now correctly returns only the school names from the top 5 enrollments as specified in the RIGHT_SQL."
        ],
        "rules": []
    },
    "886": {
        "sql": [
            "SELECT year, COUNT(*) AS race_count FROM races GROUP BY year ORDER BY race_count DESC LIMIT 1;",
            "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1;"
        ],
        "question": "Which year has the most number of races?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
        "amends": [
            "Do order by `COUNT(round)` instead of `race_count` alias. Do remove the `COUNT(*) AS race_count` column selection instead of including it. Do count `round` instead of `*` in the ORDER BY clause. The amended query now correctly identifies the year with the most rounds by counting actual race rounds rather than using an alias that references the count itself, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "the most number of races refers to max(round);"
        ]
    },
    "681": {
        "sql": [
            "SELECT DISTINCT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ViewCount > 20000\nAND strftime('%Y', p.CreaionDate) = '2011';"
        ],
        "question": "Please list the users' display names whose posts had over 20000 views in 2011.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2011' AND T2.ViewCount > 20000",
        "amends": [],
        "rules": [
            "had over 20000 views in 2011 refers to ViewCount > 20000 where YEAR(CreationDate) = 2011;"
        ]
    },
    "288": {
        "sql": [
            "SELECT m.label \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE a.atom_id = 'TR001_1';"
        ],
        "question": "Identify whether the molecule that contains atom TR001_1 is carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_1'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "1283": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS MalePatientsWithNormalGPT\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.GPT < 60;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60 AND T1.SEX = 'M'"
        ],
        "question": "For the patients with the normal glutamic pylvic transaminase level, how many of them are male?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patients. Do reference `T2.GOT < 60` instead of `L.GPT < 60` to filter on the correct laboratory test value. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T1.SEX = 'M'` condition in the WHERE clause instead of changing its position. The amended query now correctly counts male patients with normal GOT values rather than GPT values."
        ],
        "rules": [
            "normal glutamic pylvic transaminase level refers to GOT < 60; male refers to Sex = 'M';"
        ]
    },
    "535": {
        "sql": [
            "SELECT COUNT(*) AS UserCount\nFROM users\nWHERE UpVotes > 100 AND DownVotes > 1;"
        ],
        "question": "Among the users who have more than 100 upvotes, how many of them have more then 1 downvotes?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Upvotes > 100 AND Downvotes > 1",
        "amends": [],
        "rules": [
            "more than 100 upvotes refers to Upvotes > 100; more than 1 downvotes refers to Downvotes > 1"
        ]
    },
    "1082": {
        "sql": [
            "SELECT l.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE c.name = 'Germany';"
        ],
        "question": "Please list the leagues from Germany.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Germany'",
        "amends": [],
        "rules": [
            "Germany refers to Country.name = 'Germany';"
        ]
    },
    "1242": {
        "sql": [
            "SELECT DISTINCT P.ID, P.SEX, P.Birthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE YEAR(L.Date) = 1984\nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) < 50\nAND L.PLT BETWEEN 100 AND 400;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.PLT BETWEEN 100 AND 400\nAND STRFTIME('%Y', T2.Date) = '1984'\nAND (STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) < 50"
        ],
        "question": "For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 AND STRFTIME('%Y', T2.Date) = '1984'",
        "amends": [
            "Do select only `ID` instead of including `SEX` and `Birthday` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with single-letter aliases. Do place the `PLT BETWEEN 100 AND 400` filter first in the WHERE clause instead of last. Do calculate age difference using `STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)` instead of current year minus birthday. Do use exact string comparison `STRFTIME('%Y', T2.Date) = '1984'` instead of numeric comparison `YEAR(L.Date) = 1984`. The amended query now correctly filters patients based on their age at the time of the lab test rather than their current age, ensuring the logic matches the intended behavior of finding patients who were under 50 years old when their 1984 lab tests were performed."
        ],
        "rules": [
            "laboratory examinations take in 1984 refers to YEAR(Date) = '1984'; below 50 years old = SUBTRACT(year(current_timestamp), year(Birthday)) < 50; normal platelet level refers to PLT between 100 and 400; "
        ]
    },
    "950": {
        "sql": [
            "SELECT c.name \nFROM constructors c \nJOIN constructorResults cr ON c.constructorId = cr.constructorId \nWHERE cr.raceId = 291 AND cr.points = 0;",
            "SELECT T2.name \nFROM constructorStandings T1 \nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId \nWHERE T1.raceId = 291 AND T1.points = 0"
        ],
        "question": "Please list the constructor names with 0 points at race 291.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291",
        "amends": [
            "Do use table `constructorStandings` instead of `constructorResults` as the source table. Do join `constructors` with `constructorStandings` on `constructorId` instead of joining with `constructorResults`. Do reference columns `points` and `raceId` from `constructorStandings` instead of from `constructorResults`. Do use table alias `T1` for `constructorStandings` and `T2` for `constructors` instead of `c` and `cr`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do place both filter conditions in the `WHERE` clause instead of keeping them there. The amended query now correctly retrieves constructor names from standings data rather than results data, matching the intended behavior."
        ],
        "rules": [
            "race at 291 refers to raceID = 291;"
        ]
    },
    "456": {
        "sql": [
            "SELECT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';"
        ],
        "question": "What's the list of all types for the card \"Molimo, Maro-Sorcerer\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'",
        "amends": [],
        "rules": [
            "card \"Molimo, Maro-Sorcerer\" refers to name = 'Molimo, Maro-Sorcerer'; list of all types refers to subtypes,supertypes"
        ]
    },
    "1217": {
        "sql": [
            "SELECT \n    P.ID,\n    CASE \n        WHEN L.ALB BETWEEN 3.5 AND 5.5 THEN 'Within Normal Range'\n        ELSE 'Outside Normal Range'\n    END AS AlbuminStatus\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    strftime('%Y', P.Birthday) = '1982';\n",
            "SELECT \n    CASE \n        WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal'\n        ELSE 'abnormal'\n    END AS albumin_status\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    strftime('%Y', T1.Birthday) = '1982';"
        ],
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "amends": [
            "Do use `CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5` instead of `CASE WHEN L.ALB BETWEEN 3.5 AND 5.5` to explicitly define the inclusive range boundaries. Do return 'normal' and 'abnormal' instead of 'Within Normal Range' and 'Outside Normal Range' for the albumin status labels. Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do reference `T2.ALB` instead of `L.ALB` and use table aliases `T1` and `T2` instead of `P` and `L` throughout the query. Do remove the `P.ID` column from the SELECT list instead of including it, focusing only on the albumin status result. The amended query now correctly identifies albumin test results within the specified range for patients born in 1982."
        ],
        "rules": [
            "Year(Birthday) = '1982'; albumin is within normal range refers to ALB between 3.5 and 5.5"
        ]
    },
    "371": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN fd.language = 'French' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards c\nLEFT JOIN \n    foreign_data fd ON c.uuid = fd.uuid\nWHERE \n    c.isStorySpotlight = 1;",
            "SELECT \n    (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    cards T1\nINNER JOIN \n    foreign_data T2 ON T1.uuid = T2.uuid\nWHERE \n    T1.isStorySpotlight = 1;"
        ],
        "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1",
        "amends": [
            "Do use `SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN fd.language = 'French' THEN 1 END)` to properly count French records. Do cast the sum to `REAL` instead of using `100.0` for floating-point division. Do use `INNER JOIN` instead of `LEFT JOIN` to exclude cards without foreign data. Do reference `T1.id` in `COUNT(T1.id)` instead of `COUNT(*)` to count only cards with foreign data. Do use table aliases `T1` and `T2` instead of `c` and `fd` for consistency. The amended query now correctly calculates the percentage of French cards among those with foreign data that are story spotlight cards."
        ],
        "rules": [
            "Story Spotlight card refers to isStorySpotlight = 1; French is the language; Percentage = Divide(Count(id) where language = 'French' and isStorySpotlight = 1, Count(id) where isStorySpotlight = 1)*100"
        ]
    },
    "635": {
        "sql": [
            "SELECT COUNT(DISTINCT p.Id) AS PostCount\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nJOIN votes v ON p.Id = v.PostId\nWHERE u.DisplayName = 'Matt Parker'\nGROUP BY p.Id\nHAVING COUNT(v.Id) > 4;",
            "SELECT COUNT(T3.Id) \nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nINNER JOIN votes T4 ON T4.PostId = T3.Id\nWHERE T1.DisplayName = 'Matt Parker'\nGROUP BY T2.PostId, T4.Id\nHAVING COUNT(T4.Id) > 4"
        ],
        "question": "How many posts by Matt Parker have more than 4 votes?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id INNER JOIN votes AS T4 ON T4.PostId = T3.Id WHERE T1.DisplayName = 'Matt Parker' GROUP BY T2.PostId, T4.Id HAVING COUNT(T4.Id) > 4",
        "amends": [
            "Do use `INNER JOIN` with `postHistory` table on `T1.Id = T2.UserId` instead of directly joining `posts` to `users`. Do join `posts` through `postHistory` via `T2.PostId = T3.Id` instead of directly on `u.Id = p.OwnerUserId`. Do change the vote join to `T4.PostId = T3.Id` instead of `p.Id = v.PostId`. Do remove the `DISTINCT` from the count and change to `COUNT(T1.Id)` instead of `COUNT(DISTINCT p.Id)`. Do modify the GROUP BY to `T2.PostId, T4.Id` instead of just `p.Id`. Do keep the HAVING condition `COUNT(T4.Id) > 4` but reference the correct vote table. The amended query now correctly navigates the user-post-vote relationship through the postHistory table and produces the intended result set."
        ],
        "rules": [
            "more than 4 votes refer to PostId > 4; DisplayName = 'Matt Parker';"
        ]
    },
    "1397": {
        "sql": [
            "SELECT AVG(spent) AS average_food_spending\nFROM budget\nWHERE category = 'Food' AND link_to_event IN (SELECT event_id FROM event WHERE status = 'Closed');"
        ],
        "question": "On average, how much did the Student_Club spend on food for the typical event in the past?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(spent) / COUNT(spent) FROM budget WHERE category = 'Food' AND event_status = 'Closed'",
        "amends": [],
        "rules": [
            "DIVIDE(SUM(spent), COUNT(spent)) where category = 'Food'; 'event in the past' means event_status = 'Closed'"
        ]
    },
    "575": {
        "sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'SilentGhost';"
        ],
        "question": "What is the badge name that user 'SilentGhost' obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'SilentGhost'",
        "amends": [],
        "rules": [
            "\"SilentGhost\" is the DisplayName of user;"
        ]
    },
    "1313": {
        "sql": [
            "SELECT COUNT(DISTINCT m.member_id) \nFROM member m \nJOIN major maj ON m.link_to_major = maj.major_id \nWHERE maj.college = 'College of Engineering';"
        ],
        "question": "How many students in the Student_Club are from the College of Engineering?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.college = 'College of Engineering'",
        "amends": [],
        "rules": []
    },
    "1134": {
        "sql": [
            "SELECT (SELECT jumping FROM Player_Attributes WHERE player_api_id = 6) - (SELECT jumping FROM Player_Attributes WHERE player_api_id = 23) AS jumping_difference;",
            "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) AS jumping_difference FROM Player_Attributes AS t1 WHERE t1.id IN (6, 23);"
        ],
        "question": "What is the difference between players 6 and 23's jumping scores?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) FROM Player_Attributes AS t1",
        "amends": [
            "Do use a single table reference `Player_Attributes AS t1` instead of multiple subqueries against the same table. Do aggregate with `SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END)` instead of separate scalar subqueries `(SELECT jumping FROM Player_Attributes WHERE player_api_id = 6)`. Do reference the correct column `t1.id` for player identification instead of `player_api_id`. Do subtract the aggregated sums directly instead of subtracting the results of separate subqueries. The amended query now correctly handles multiple rows per player and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "difference between players 6 and 23's jumping scores refers to SUBTRACT(jumping AND id = 6,jumping AND id = 23)"
        ]
    },
    "587": {
        "sql": [
            "SELECT p.Title, c.Text AS Comment, AVG(p.ViewCount) AS AverageViewCount\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE p.Tags LIKE '%<humor>%'\nGROUP BY p.Id, p.Title, c.Text;",
            "SELECT AVG(T2.ViewCount) AS AverageViewCount, T2.Title, T1.Text\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Tags = '<humor>'\nGROUP BY T2.Title, T1.Text"
        ],
        "question": "Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.ViewCount), T2.Title, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.PostId  WHERE T2.Tags = '<humor>' GROUP BY T2.Title, T1.Text ",
        "amends": [
            "Do use `AVG(T2.ViewCount)` as the first column instead of placing `p.Title` first in the SELECT list. Do reference `T2.Title` and `T1.Text` instead of using aliases `p.Title` and `c.Text AS Comment`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `p` and `c`. Do use exact equality comparison `T2.Tags = '<humor>'` instead of pattern matching `LIKE '%<humor>%'` for the tag filter. Do group by `T2.Title, T1.Text` instead of including the unnecessary `p.Id` in the GROUP BY clause. The amended query now correctly calculates average view counts for humor-tagged posts with their comments using proper equality matching and optimized grouping."
        ],
        "rules": [
            "tagged as  'humor' refers to tag = '<humor>'; comment of the post refers to Text; average view count = AVG(ViewCount)"
        ]
    },
    "1262": {
        "sql": [
            "SELECT COUNT(DISTINCT p.ID) AS PatientCount\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE e.\"ANA Pattern\" = 'P' AND l.C3 IS NOT NULL;"
        ],
        "question": "How many patients with a normal level of complement 3 have a P pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C3 > 35 AND T1.`ANA Pattern` = 'P'",
        "amends": [],
        "rules": [
            "normal level of complement 3 refers to C3 > 35; have a P pattern observed in the sheet of ANA examination refers to ANA Pattern = 'P'; Should compute the number of distinct ones"
        ]
    },
    "1483": {
        "sql": [
            "SELECT SUM(Consumption) AS TotalConsumption FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311';"
        ],
        "question": "How much did customer 6 consume in total between August and November 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'",
        "amends": [],
        "rules": [
            "Between August And November 2013 refers to Between 201308 And 201311; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
        ]
    },
    "233": {
        "sql": [
            "SELECT bond_id, bond_type FROM bond WHERE molecule_id = 'TR006' ORDER BY bond_type ASC LIMIT 2;",
            "SELECT DISTINCT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.molecule_id = 'TR006'\nORDER BY T2.bond_id\nLIMIT 2"
        ],
        "question": "Please list top two bonds that happened with the molecule TR006 in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.molecule_id = 'TR006' ORDER BY T2.bond_id LIMIT 2",
        "amends": [
            "Do select `T2.bond_id` instead of `bond_id, bond_type` and add `DISTINCT` instead of omitting it. Do join `atom AS T1` and `connected AS T2` with `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of querying only the `bond` table. Do filter on `T1.molecule_id = 'TR006'` instead of `molecule_id = 'TR006'` from the bond table. Do order by `T2.bond_id` instead of `bond_type ASC` while keeping the same `LIMIT 2`. The amended query now correctly retrieves distinct bond IDs from the connected table through atom relationships instead of directly from the bond table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "TR006 is the molecule id"
        ]
    },
    "853": {
        "sql": [
            "SELECT r.name \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.country = 'Spain';"
        ],
        "question": "Please give the names of the races held on the circuits in Spain.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "amends": [],
        "rules": [
            "Spain is a name of country;"
        ]
    },
    "390": {
        "sql": [
            "SELECT c.id, c.colors, l.format FROM cards c LEFT JOIN legalities l ON c.uuid = l.uuid WHERE c.id BETWEEN 1 AND 20;",
            "SELECT T1.colors, T2.format \nFROM cards T1 \nINNER JOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T1.id BETWEEN 1 AND 20"
        ],
        "question": "What are the colors of cards from ID 1-20? What are the format of these cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.colors, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20",
        "amends": [
            "Do select only `colors` and `format` instead of including `id` in the SELECT list. Do use `INNER JOIN` instead of `LEFT JOIN` for the table relationship. Do reference tables as `T1` and `T2` with explicit aliases instead of simple `c` and `l` aliases. Do join on `T1.uuid = T2.uuid` instead of `c.uuid = l.uuid` while maintaining the same join condition logic. The amended query now correctly performs an inner join between the cards and legalities tables, selecting only the relevant color and format columns for records where the card ID falls within the specified range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "ID 1-20 refers to id BETWEEN 1 and 20;"
        ]
    },
    "616": {
        "sql": [
            "SELECT c.Score\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.CreaionDate = '2010-07-19 19:19:56.0';",
            "SELECT T1.Score\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.CreationDate = '2010-07-19 19:19:56'",
            "SELECT T1.Score \nFROM comments T1 \nINNER JOIN posts T2 ON T1.PostId = T2.Id \nWHERE T1.CreationDate = '2010-07-19 19:19:56.0'"
        ],
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "amends": [
            "Do reference `T1.Score` instead of `c.Score` for column selection. Do use `INNER JOIN` explicitly instead of just `JOIN` for the table join. Do join on `T1.PostId = T2.Id` instead of `c.PostId = p.Id` using different table aliases. Do filter on `T1.CreationDate` instead of `p.CreationDate` to apply the date condition to the comments table rather than the posts table. The amended query now correctly filters comments by their own creation date rather than the post's creation date, matching the intended behavior.",
            "Do use the full timestamp format '2010-07-19 19:19:56.0' instead of the truncated '2010-07-19 19:19:56' to ensure precise datetime matching. The amended query now correctly matches the RIGHT_SQL's behavior with proper timestamp precision."
        ],
        "rules": [
            "created on 7/19/2010 7:19:56 PM refers to CreationDate = '2010-07-19 19:19:56.0'"
        ]
    },
    "625": {
        "sql": [
            "SELECT COUNT(*) FROM users WHERE Location LIKE '%New York%';",
            "SELECT COUNT(Id) FROM users WHERE Location = 'New York';"
        ],
        "question": "How many users were from New York?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "amends": [
            "Do use `COUNT(Id)` instead of `COUNT(*)` to count only non-null user IDs. Do use exact equality `Location = 'New York'` instead of pattern matching `LIKE '%New York%'` to avoid counting locations that merely contain 'New York' as a substring. The amended query now correctly counts users specifically located in New York rather than any location containing that text."
        ],
        "rules": [
            "New York refers to Location;"
        ]
    },
    "411": {
        "sql": [
            "SELECT artist FROM cards WHERE text = 'Das perfekte Gegenmittel zu einer dichten Formation';",
            "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%Das perfekte Gegenmittel zu einer dichten Formation%'"
        ],
        "question": "To which artist does the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\" belong?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
        "amends": [
            "Do add `DISTINCT` modifier instead of omitting it to eliminate duplicate artist results. Do change the source table to `cards AS T1` instead of just `cards` and add an `INNER JOIN` with `foreign_data AS T2` on `T1.uuid = T2.uuid` instead of querying a single table. Do change the filter to use `T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'` instead of `text = 'Das perfekte Gegenmittel zu einer dichten Formation'` to perform a case-insensitive pattern match with wildcards rather than an exact string comparison. The amended query now correctly joins the cards and foreign_data tables to access the flavorText field and uses appropriate pattern matching to find the target text."
        ],
        "rules": []
    },
    "1425": {
        "sql": [
            "SELECT COUNT(*) FROM major WHERE college = 'College of Agriculture and Applied Sciences' AND department = 'School of Applied Sciences, Technology and Education';"
        ],
        "question": "In the College of Agriculture and Applied Sciences, how many majors are under the department of School of Applied Sciences, Technology and Education?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(major_id) FROM major WHERE department = 'School of Applied Sciences, Technology and Education' AND college = 'College of Agriculture and Applied Sciences'",
        "amends": [],
        "rules": []
    },
    "938": {
        "sql": [
            "SELECT d.forename, d.surname, d.url\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE rc.year = 2008 AND rc.name = 'Australian Grand Prix' AND r.positionOrder = 1;"
        ],
        "question": "Who was the champion of 2008's Australian Grand Prix and where can I know more about him?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname, T1.url FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T2.time LIKE '_:%:__.___' AND T3.year = 2008",
        "amends": [],
        "rules": [
            "only champion's finished time is represented by 'HH:MM:SS.mmm'; where can I know more refers to url"
        ]
    },
    "354": {
        "sql": [
            "SELECT COUNT(DISTINCT types) FROM cards WHERE artist = 'Aaron Boyd';",
            "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd';"
        ],
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "amends": [
            "Do use `COUNT(type)` instead of `COUNT(DISTINCT types)` to count all occurrences of the type column rather than counting distinct values from a non-existent column. Do reference the correct column name `type` instead of the incorrect `types` that doesn't exist in the schema. The amended query now correctly counts all card types by the specified artist rather than attempting to count distinct values from a non-existent column, matching the intended behavior."
        ],
        "rules": [
            "Aaron Boyd' is artist;"
        ]
    },
    "870": {
        "sql": [
            "SELECT q.q1\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 345 AND d.forename = 'Lucas' AND d.surname = 'di Grassi';"
        ],
        "question": "What's Lucas di Grassi's Q1 result in the race No. 345?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 345 AND T2.forename = 'Lucas' AND T2.surname = 'di Grassi'",
        "amends": [],
        "rules": [
            "race number refers to raceId;"
        ]
    },
    "46": {
        "sql": [
            "SELECT s.CDSCode, s.School, s.District, s.County, f.\"Enrollment (K-12)\"\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.DOC = '31'\nORDER BY f.\"Enrollment (K-12)\" DESC\nLIMIT 10;",
            "SELECT T1.School\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.DOC = 31\nORDER BY T1.\"Enrollment (K-12)\" DESC\nLIMIT 1;",
            "SELECT T2.School\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.DOC = 31\nORDER BY T1.`Enrollment (K-12)` DESC\nLIMIT 1;"
        ],
        "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "amends": [
            "Do select only `School` instead of including `CDSCode`, `District`, `County`, and `Enrollment (K-12)`. Do use `INNER JOIN` with aliases `T1` and `T2` instead of `JOIN` with aliases `s` and `f`. Do join on `T1.CDSCode = T2.CDSCode` instead of `s.CDSCode = f.CDSCode`. Do filter with `T2.DOC = 31` instead of `s.DOC = '31'`, removing the string quotes. Do order by `T1.Enrollment (K-12)` instead of `f.Enrollment (K-12)`. Do limit to `1` result instead of `10`. The amended query now correctly returns only the top school by enrollment for the specified DOC code.",
            "Do select `T2.School` instead of `T1.School` to retrieve the school name from the correct table. Do use backticks for `Enrollment (K-12)` instead of double quotes to properly handle the column name with special characters. The amended query now correctly returns the school name from the schools table while maintaining the same join logic, filter condition, and sorting behavior to identify the school with the highest enrollment where DOC equals 31."
        ],
        "rules": [
            "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12"
        ]
    },
    "48": {
        "sql": [
            "WITH UnifiedCount AS (\n    SELECT COUNT(*) AS count_unified\n    FROM schools\n    WHERE County = 'Orange' AND DOC = '54'\n),\nElementaryCount AS (\n    SELECT COUNT(*) AS count_elementary\n    FROM schools\n    WHERE County = 'Orange' AND DOC = '52'\n)\nSELECT \n    count_unified AS \"Unified School District Schools\",\n    count_elementary AS \"Elementary School District Schools\",\n    CASE \n        WHEN count_elementary = 0 THEN NULL\n        ELSE CAST(count_unified AS REAL) / count_elementary\n    END AS \"Ratio (Unified to Elementary)\"\nFROM UnifiedCount, ElementaryCount;",
            "SELECT \n    CAST(SUM(CASE WHEN s.DOC = '54' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN s.DOC = '52' THEN 1 ELSE 0 END), 0) AS ratio\nFROM schools s\nWHERE s.County = 'Orange' \nAND s.StatusType = 'Merged';"
        ],
        "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for counts. Do calculate the ratio directly using `SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END)` and `SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END)` instead of separate count columns. Do add the filter `StatusType = 'Merged'` instead of omitting it. Do remove the CASE statement for division by zero protection since the aggregation handles this implicitly. Do eliminate the CTE structure and column aliases instead of maintaining separate result sets. Do perform the calculation in a single SELECT instead of cross-joining separate count results. The amended query now correctly filters for merged schools and calculates the ratio directly with proper aggregation."
        ],
        "rules": [
            "Elementary School District refers to DOC = 52; Unified School District refers to DOC = 54."
        ]
    },
    "929": {
        "sql": [
            "SELECT r.name AS race_name, r.year, c.name AS circuit_name\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nJOIN drivers d ON res.driverId = d.driverId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';\n",
            "SELECT T1.name FROM races T1 INNER JOIN results T2 ON T2.raceId = T1.raceId INNER JOIN drivers T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'"
        ],
        "question": "Please list the Formula_1 races that Lewis Hamilton participated.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "amends": [
            "Do select only `T1.name` instead of including `r.name AS race_name`, `r.year`, and `c.name AS circuit_name`. Do remove the `JOIN circuits c` table entirely instead of keeping it. Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `res`, and `d`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use `T2.raceId = T1.raceId` instead of `res.raceId = r.raceId` for the join condition. Do use `T3.driverId = T2.driverId` instead of `res.driverId = d.driverId` for the driver join. The amended query now correctly returns only race names for Lewis Hamilton's races without unnecessary circuit information."
        ],
        "rules": []
    },
    "1176": {
        "sql": [
            "SELECT `ANA` FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02';"
        ],
        "question": "What was the anti-nucleus antibody concentration level for the patient id 3605340 on 1996/12/2?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT ANA FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02'",
        "amends": [],
        "rules": [
            "anti-nucleus antibody refers to ANA; 1996/12/2 refers to `Examination Date` = '1996-12-02'"
        ]
    },
    "1223": {
        "sql": [
            "SELECT \n    (SELECT COUNT(DISTINCT P.ID) \n     FROM Patient P \n     JOIN Laboratory L ON P.ID = L.ID \n     WHERE L.CRE >= 1.5 AND P.SEX = 'M') > \n    (SELECT COUNT(DISTINCT P.ID) \n     FROM Patient P \n     JOIN Laboratory L ON P.ID = L.ID \n     WHERE L.CRE >= 1.5 AND P.SEX = 'F') AS result;",
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) \n        THEN 'True' \n        ELSE 'False' \n    END AS result\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T2.CRE >= 1.5"
        ],
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "amends": [
            "Do use a single query with `CASE` expressions and aggregation instead of separate subqueries with comparison. Do join `Patient` and `Laboratory` as `T1` and `T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of separate joins in subqueries. Do apply the `T2.CRE >= 1.5` filter in the `WHERE` clause instead of repeating it in both subqueries. Do aggregate counts using `SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT P.ID)` with separate filters. Do return a string result `'True'` or `'False'` instead of a boolean comparison. Do remove the redundant `DISTINCT` from the count operations since the join condition already ensures uniqueness. The amended query now correctly compares male and female patient counts with elevated creatinine levels in a single efficient operation."
        ],
        "rules": [
            "creatinine (CRE) not within the normal range refers to CRE > = 1.5; male refers to Sex = 'M'; female refers to Sex = 'F'; calculation = (SUM(SEX = 'M') > SUM(SEX = 'F')) where CRE > = 1.5"
        ]
    },
    "212": {
        "sql": [
            "SELECT a.element, COUNT(a.element) AS element_count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '-'\nGROUP BY a.element\nORDER BY element_count ASC\nLIMIT 1;",
            "SELECT T.element\nFROM (\n    SELECT a.element, COUNT(DISTINCT a.molecule_id) AS molecule_count\n    FROM atom a\n    JOIN molecule m ON a.molecule_id = m.molecule_id\n    WHERE m.label = '-'\n    GROUP BY a.element\n    ORDER BY molecule_count ASC\n    LIMIT 1\n) T"
        ],
        "question": "Which element is the least numerous in non-carcinogenic molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
        "amends": [
            "Do use `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(a.element)` to count distinct molecules per element rather than total atom occurrences. Do add `DISTINCT` in the count instead of omitting it to avoid duplicate molecule counting. Do include the count in the subquery's SELECT list instead of only in ORDER BY for proper aggregation. Do use a subquery structure instead of a simple query to properly handle the ordering and limiting of aggregated results. Do reference the count column in ORDER BY instead of the alias `element_count` since aliases aren't available at that scope. Do return only `T.element` in the outer SELECT instead of both element and count to match the required output format. The amended query now correctly identifies the element with the fewest distinct molecules labeled '-', matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; least numerous refers to MIN(COUNT(element));"
        ]
    },
    "967": {
        "sql": [
            "WITH youngest_drivers AS (\n    SELECT code, nationality\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 3\n)\nSELECT \n    COUNT(*) AS netherlandic_drivers_count\nFROM youngest_drivers\nWHERE nationality IN ('Dutch', 'Netherlandic');"
        ],
        "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
        "amends": [],
        "rules": [
            "youngest driver refers to Max (year(dob)); Netherlandic and Dutch refer to the same country"
        ]
    },
    "78": {
        "sql": [
            "SELECT GSserved, COUNT(*) as count\nFROM schools\nWHERE City = 'Adelanto'\nGROUP BY GSserved\nORDER BY count DESC\nLIMIT 1;",
            "SELECT GSserved FROM schools WHERE City = 'Adelanto' AND GSserved IS NOT NULL GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1;"
        ],
        "question": "What is the most common type of grade span served in the city of Adelanto?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT GSserved FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1",
        "amends": [
            "Do select only `GSserved` instead of selecting both `GSserved` and `COUNT(*) as count`. Do remove the alias `count` from the SELECT list instead of keeping it. Do change the ORDER BY clause to use `COUNT(GSserved)` instead of the alias `count`. Do remove the explicit column reference in the ORDER BY clause instead of using the alias. The amended query now correctly returns only the GSserved value with the highest count for Adelanto city instead of returning both the value and its count."
        ],
        "rules": []
    },
    "295": {
        "sql": [
            "SELECT COUNT(*) \nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'h' AND m.label = '+';"
        ],
        "question": "How many atoms belong to the molecule that element is hydrogen and labeled with carcinogenic compound?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.atom_id) AS atomnums_h FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'h'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; hydrogen refers to element = h'"
        ]
    },
    "28": {
        "sql": [
            "WITH LocalFundedSchools AS (\n    SELECT \n        s.CDSCode,\n        s.School,\n        s.DOCType,\n        f.\"Enrollment (K-12)\" - f.\"Enrollment (Ages 5-17)\" AS EnrollmentDifference\n    FROM \n        schools s\n    JOIN \n        frpm f ON s.CDSCode = f.CDSCode\n    WHERE \n        s.FundingType = 'Local'\n),\nAverageDifference AS (\n    SELECT \n        AVG(EnrollmentDifference) AS AvgEnrollmentDifference\n    FROM \n        LocalFundedSchools\n)\nSELECT \n    l.School,\n    l.DOCType\nFROM \n    LocalFundedSchools l, AverageDifference a\nWHERE \n    l.EnrollmentDifference > a.AvgEnrollmentDifference;",
            "SELECT T2.School, T2.DOC\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.FundingType = 'Locally funded'\nAND (T1.\"Enrollment (K-12)\" - T1.\"Enrollment (Ages 5-17)\") > (\n    SELECT AVG(T3.\"Enrollment (K-12)\" - T3.\"Enrollment (Ages 5-17)\")\n    FROM frpm T3\n    INNER JOIN schools T4 ON T3.CDSCode = T4.CDSCode\n    WHERE T4.FundingType = 'Locally funded'\n);"
        ],
        "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
        "amends": [
            "Do use a direct `INNER JOIN` between `frpm` and `schools` instead of a CTE structure. Do reference `T2.School` and `T2.DOC` instead of `l.School` and `l.DOCType`. Do filter with `T2.FundingType = 'Locally funded'` instead of `s.FundingType = 'Local'`. Do calculate the enrollment difference directly in the main query and subquery instead of using a CTE. Do use a correlated subquery for the average calculation instead of a separate CTE with cross join. Do reference the correct column `DOC` instead of `DOCType`. The amended query now correctly filters for locally funded schools and compares each school's enrollment difference against the average of all locally funded schools."
        ],
        "rules": [
            "Difference between K-12 enrollment and 15-17 enrollment can be computed by `Enrollment (K-12)` - `Enrollment (Ages 5-17)`"
        ]
    },
    "1058": {
        "sql": [
            "WITH HeightExtremes AS (\n    SELECT \n        MIN(height) AS min_height,\n        MAX(height) AS max_height\n    FROM Player\n),\nFilteredPlayers AS (\n    SELECT \n        p.player_api_id,\n        p.player_name,\n        p.height\n    FROM Player p, HeightExtremes h\n    WHERE p.height = h.min_height OR p.height = h.max_height\n),\nPlayerFinishing AS (\n    SELECT \n        fp.player_api_id,\n        fp.player_name,\n        fp.height,\n        AVG(pa.finishing) AS avg_finishing\n    FROM FilteredPlayers fp\n    JOIN Player_Attributes pa ON fp.player_api_id = pa.player_api_id\n    GROUP BY fp.player_api_id, fp.player_name, fp.height\n)\nSELECT \n    player_api_id,\n    player_name,\n    height,\n    avg_finishing\nFROM PlayerFinishing\nORDER BY avg_finishing DESC\nLIMIT 1;",
            "SELECT \n    'Max' AS height_classification,\n    AVG(pa.finishing) AS avg_finishing\nFROM \n    Player_Attributes pa\nJOIN \n    Player p ON pa.player_api_id = p.player_api_id\nWHERE \n    p.height = (SELECT MAX(height) FROM Player)\n\nUNION ALL\n\nSELECT \n    'Min' AS height_classification,\n    AVG(pa.finishing) AS avg_finishing\nFROM \n    Player_Attributes pa\nJOIN \n    Player p ON pa.player_api_id = p.player_api_id\nWHERE \n    p.height = (SELECT MIN(height) FROM Player)\n\nORDER BY avg_finishing DESC\nLIMIT 1;",
            "SELECT A FROM (\n    SELECT 'Max' AS A, AVG(T2.finishing) AS result\n    FROM Player T1\n    INNER JOIN Player_Attributes T2 ON T1.player_api_id = T2.player_api_id\n    WHERE T1.height = (SELECT MAX(height) FROM Player)\n    \n    UNION\n    \n    SELECT 'Min' AS A, AVG(T2.finishing) AS result\n    FROM Player T1\n    INNER JOIN Player_Attributes T2 ON T1.player_api_id = T2.player_api_id\n    WHERE T1.height = (SELECT MIN(height) FROM Player)\n) \nORDER BY result DESC \nLIMIT 1"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "Who has the highest average finishing rate between the highest and shortest football player?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM Player ) UNION SELECT AVG(finishing) result, 'Min' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM Player ) ) ORDER BY result DESC LIMIT 1",
        "amends": [
            "Do use a `UNION` with two separate subqueries instead of a single CTE chain with `OR` conditions. Do calculate `AVG(finishing)` separately for maximum and minimum height players instead of grouping all players together. Do add explicit `'Max'` and `'Min'` labels in the `SELECT` list instead of omitting height classification. Do move the height filter conditions directly into `WHERE` clauses with subqueries instead of using a CTE with `HeightExtremes`. Do remove the `GROUP BY` clause on player details instead of keeping it, since we're calculating separate averages. Do change the output to include the height classification label `A` instead of individual player attributes. Do maintain the `ORDER BY result DESC LIMIT 1` to find the highest average finishing between max and min height groups instead of finding individual players. The amended query now correctly compares the average finishing skills between the tallest and shortest player groups rather than individual players with extreme heights.",
            "Do use an alias `A` for the classification column instead of `height_classification` and add a `result` column for the average instead of `avg_finishing`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of `JOIN` without aliases. Do wrap the entire UNION query in a subquery instead of applying ORDER BY and LIMIT directly to the UNION result. Do order by the `result` column instead of `avg_finishing` and maintain the same LIMIT 1. The amended query now correctly selects only the classification column from the subquery while ordering by the average result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "finishing rate refers to finishing; highest average finishing rate = MAX(AVG(finishing)); highest football player refers to MAX(height); shortest football player refers to MIN(height);"
        ]
    },
    "664": {
        "sql": [
            "SELECT SUM(Score) FROM posts WHERE LasActivityDate LIKE '2010-07-19%';"
        ],
        "question": "What is the sum of score of the post on 2010-07-19?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(Score) FROM posts WHERE LasActivityDate LIKE '2010-07-19%'",
        "amends": [],
        "rules": [
            "on 2010-07-19 refers to LasActivityDate LIKE '2010-07-19%';"
        ]
    },
    "1403": {
        "sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.status = 'Closed' AND b.remaining < 0\nORDER BY b.remaining ASC\nLIMIT 1;"
        ],
        "question": "Indicate the name of the closed event whose cost has exceeded the budget the most.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event WHERE T1.event_status = 'Closed' AND T1.remaining < 0 ORDER BY T1.remaining LIMIT 1",
        "amends": [],
        "rules": [
            "closed events refers to event_name where status = 'Closed'; exceed the budget the most refers to MIN(remaining) where remaining < 0"
        ]
    },
    "1154": {
        "sql": [
            "SELECT p.SEX, p.Birthday, e.\"Examination Date\", e.Symptoms\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.ID = 163109;"
        ],
        "question": "State the sex and birthday of patient ID '163109'. When was the examination taken and what symptom does the patient had.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.SEX, T1.Birthday, T2.`Examination Date`, T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = 163109",
        "amends": [],
        "rules": [
            "When was the examination taken refers to `Examination Date`"
        ]
    },
    "63": {
        "sql": [
            "SELECT \n    School AS \"School Name\",\n    City AS \"City\",\n    AdmFName1 || ' ' || AdmLName1 AS \"Administrator 1\",\n    AdmFName2 || ' ' || AdmLName2 AS \"Administrator 2\",\n    AdmFName3 || ' ' || AdmLName3 AS \"Administrator 3\"\nFROM \n    schools\nWHERE \n    Charter = 1 \n    AND CharterNum = '00D2';",
            "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE CharterNum = '00D2'"
        ],
        "question": "In chartered schools with charter number 00D2, what are the names of all the administrators? Include the name of the school and the city to which it belongs",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2'",
        "amends": [
            "Do select only `AdmFName1`, `AdmLName1`, `School`, and `City` columns instead of including concatenated administrator names and additional aliases. Do remove the concatenation expressions `AdmFName1 || ' ' || AdmLName1`, `AdmFName2 || ' ' || AdmLName2`, and `AdmFName3 || ' ' || AdmLName3` instead of keeping them. Do omit the column aliases \"School Name\", \"City\", \"Administrator 1\", \"Administrator 2\", and \"Administrator 3\" instead of including them. The amended query now correctly returns only the specified columns without unnecessary transformations or aliasing, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Chartered schools refer to Charter = 1 in the table schools; Full name refers to first name, last name"
        ]
    },
    "468": {
        "sql": [
            "SELECT st.translation\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.name = 'Eighth Edition' AND st.language = 'Chinese Simplified';"
        ],
        "question": "What is the Simplified Chinese translation of the name of the set \"Eighth Edition\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Eighth Edition' AND T2.language = 'Chinese Simplified'",
        "amends": [],
        "rules": [
            "Eighth Edition is the name of card set which refers to name = 'Eighth Edition'; Simplified Chinese refers to language = 'Chinese Simplified'; translation of the name refers to translation"
        ]
    },
    "1532": {
        "sql": [
            "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.ProductID = 2\nORDER BY t.Price DESC\nLIMIT 1;"
        ],
        "question": "Which country had the gas station that sold the most expensive product id No.2 for one unit?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.ProductID = 2 ORDER BY T1.Price DESC LIMIT 1",
        "amends": [],
        "rules": []
    },
    "504": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT code FROM sets WHERE name = 'World Championship Decks 2004') \nAND convertedManaCost = 3;"
        ],
        "question": "How many cards are there in the set 'World Championship Decks 2004' with the converted mana cost as '3'.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE setCode IN ( SELECT code FROM sets WHERE name = 'World Championship Decks 2004' ) AND convertedManaCost = 3",
        "amends": [],
        "rules": [
            "the set 'World Championship Decks 2004' refers to name = 'World Championship Decks 2004'"
        ]
    },
    "849": {
        "sql": [
            "SELECT url FROM circuits WHERE name = 'Circuit de Barcelona-Catalunya';"
        ],
        "question": "Where can the introduction of the races held on Circuit de Barcelona-Catalunya be found?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "amends": [],
        "rules": [
            "introduction of races refers to url; Circuit de Barcelona-Catalunya is a name of circuit;"
        ]
    },
    "689": {
        "sql": [
            "SELECT u.DisplayName, u.Location\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE p.Id = 183;",
            "SELECT T2.DisplayName, T2.Location \nFROM posts T1 \nJOIN users T2 ON T1.OwnerUserId = T2.Id \nWHERE T1.Id = 183 \nORDER BY T1.LastEditDate DESC \nLIMIT 1"
        ],
        "question": "Identify the display name and location of the user, who was the last to edit the post with ID 183.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName, T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 183 ORDER BY T1.LastEditDate DESC LIMIT 1",
        "amends": [
            "Do join on `T1.OwnerUserId = T2.Id` instead of `p.LastEditorUserId = u.Id` for the correct user association. Do add `ORDER BY T1.LastEditDate DESC LIMIT 1` instead of omitting ordering and limiting to ensure only the most recent edit is returned. Do use table aliases `T1` and `T2` instead of full table names for consistency. The amended query now correctly retrieves the post owner's information rather than the last editor's details and ensures only a single result is returned based on the most recent edit date."
        ],
        "rules": [
            "last to edit refers to MAX(LastEditDate);"
        ]
    },
    "640": {
        "sql": [
            "SELECT \n    (SELECT COALESCE(SUM(p.ViewCount), 0) FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Mornington') -\n    (SELECT COALESCE(SUM(p.ViewCount), 0) FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Amos') AS ViewCountDifference;",
            "SELECT \n    SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - \n    SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS view_count_difference\nFROM \n    users AS T1\nJOIN \n    postHistory AS T2 ON T1.Id = T2.UserId\nJOIN \n    posts AS T3 ON T3.Id = T2.PostId\nWHERE \n    T1.DisplayName IN ('Mornington', 'Amos')"
        ],
        "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "amends": [
            "Do use a single query with conditional aggregation using `SUM(IIF(condition, value, 0))` instead of separate subqueries with `COALESCE(SUM(), 0)`. Do join `users AS T1` to `postHistory AS T2` on `T1.Id = T2.UserId` instead of directly joining to `posts`. Do then join `posts AS T3` on `T3.Id = T2.PostId` instead of joining directly from `users` to `posts` on `OwnerUserId`. Do reference the correct table aliases `T1.DisplayName` and `T3.ViewCount` instead of the original column references. Do remove the separate subquery structure and instead perform the calculation in a single pass through the joined tables. The amended query now correctly calculates the view count difference between the two users by properly traversing the relationship through postHistory instead of assuming a direct user-to-posts connection."
        ],
        "rules": [
            "calculation = SUBTRACT(SUM(ViewCount where DisplayName = 'Mornington'), SUM(ViewCount where DisplayName = 'Amos'));"
        ]
    },
    "1422": {
        "sql": [
            "SELECT DISTINCT type FROM event WHERE location = 'MU 215';",
            "SELECT DISTINCT T2.category\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.location = 'MU 215'"
        ],
        "question": "State the category of events were held at MU 215.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "amends": [
            "Do join `budget AS T2` on `T1.event_id = T2.link_to_event` instead of querying only the `event` table. Do select `T2.category` instead of `type` from the event table. Do add the `INNER JOIN` condition instead of omitting the table relationship entirely. Do keep the `DISTINCT` modifier and `WHERE` filter on `T1.location = 'MU 215'` as they were correctly implemented. The amended query now correctly retrieves distinct categories from the joined budget table rather than types from the event table alone, matching the intended behavior."
        ],
        "rules": [
            "'MU 215' is the location of event; "
        ]
    },
    "550": {
        "sql": [
            "SELECT p.Body \nFROM posts p \nJOIN tags t ON p.Id = t.ExcerptPostId \nWHERE t.Count = (SELECT MAX(Count) FROM tags);"
        ],
        "question": "From which post is the most popular tag excerpted from? Please give the body of the post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Body FROM posts WHERE id = ( SELECT ExcerptPostId FROM tags ORDER BY Count DESC LIMIT 1 )",
        "amends": [],
        "rules": [
            "most popular tag refers to Max(Count); excerpt from refer to ExcerptPostId"
        ]
    },
    "1341": {
        "sql": [
            "SELECT location FROM event WHERE event_name = 'Spring Budget Review';"
        ],
        "question": "Give the location for \"Spring Budget Review\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT location FROM event WHERE event_name = 'Spring Budget Review'",
        "amends": [],
        "rules": [
            "'Spring Budget Review' is an event name;"
        ]
    },
    "806": {
        "sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.full_name = 'Karen Beecher-Duncan';"
        ],
        "question": "Provide the eye colour of the superhero who has Karen Beecher-Duncan as their full name.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Karen Beecher-Duncan'",
        "amends": [],
        "rules": [
            "eye colour refers to colour.colour where eye_colour_id = colour.id; Karen Beecher-Duncan is the full name of superhero;"
        ]
    },
    "179": {
        "sql": [
            "SELECT SUM(t.amount) AS total_payment\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN trans t ON d.account_id = t.account_id\nWHERE c.client_id = 617\nAND strftime('%Y', t.date) = '1998';"
        ],
        "question": "How much, in total, did client number 617 pay for all of the transactions in 1998?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT SUM(T3.amount) FROM client AS T1 INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date)= '1998' AND T1.client_id = 617",
        "amends": [],
        "rules": []
    },
    "1214": {
        "sql": [
            "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TP < 6.0;"
        ],
        "question": "List ID, sex and date of birth of patient whose total protein (TP) below the lower range of the normal index.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0",
        "amends": [],
        "rules": [
            "total protein (TP) below the lower range of the normal index refers to TP < 6.0"
        ]
    },
    "1067": {
        "sql": [
            "SELECT t.team_short_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE ta.buildUpPlayPassing > 70;"
        ],
        "question": "Which teams have build up play passing more than 70? Please list their short names.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayPassing > 70",
        "amends": [],
        "rules": [
            "build up play passing refers to buildUpPlayPassing; buildUpPlayPassing > 70; short names refers to team_short_name;"
        ]
    },
    "1078": {
        "sql": [
            "SELECT \n    p1.player_name AS player1_name, \n    p1.birthday AS player1_birthday, \n    p2.player_name AS player2_name, \n    p2.birthday AS player2_birthday,\n    CASE \n        WHEN p1.birthday < p2.birthday THEN p1.player_name || ' is older.'\n        WHEN p1.birthday > p2.birthday THEN p2.player_name || ' is older.'\n        ELSE 'Both players have the same age.'\n    END AS result\nFROM \n    Player p1, \n    Player p2\nWHERE \n    p1.player_name = 'Aaron Lennon' \n    AND p2.player_name = 'Abdelaziz Barrada';",
            "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1;"
        ],
        "question": "Which player is older, Aaron Lennon or Abdelaziz Barrada?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of multiple columns with player comparisons. Do use a single `FROM Player` table instead of a cross join between two aliases. Do change the WHERE filter to `player_name IN` with both names instead of separate conditions on different aliases. Do add `ORDER BY birthday ASC` instead of using CASE logic for age comparison. Do add `LIMIT 1` to return only the oldest player instead of comparing both players in each row. Do remove the complex CASE expression that determined older player instead of simply ordering by birthday. The amended query now correctly identifies the single oldest player from the specified list by leveraging proper ordering and limiting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "The larger the birthday value, the younger the person is, and vice versa;"
        ]
    },
    "274": {
        "sql": [
            "SELECT DISTINCT element FROM atom WHERE molecule_id = 'TR001';"
        ],
        "question": "List the toxicology elements associated with molecule TR001.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR001'",
        "amends": [],
        "rules": [
            "TR001 is the molecule id"
        ]
    },
    "279": {
        "sql": [
            "SELECT m.label\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_id = 'TR001_10_11';"
        ],
        "question": "What is the label for bond ID TR001_10_11?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_10_11'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "328": {
        "sql": [
            "SELECT DISTINCT a.element\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE m.molecule_id = 'TR024' AND b.bond_type = '=';",
            "SELECT T1.element\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='"
        ],
        "question": "List all the elements with double bond, consisted in molecule TR024.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='",
        "amends": [
            "Do select `T1.element` instead of `a.element` and remove `DISTINCT` instead of keeping it. Do use `atom AS T1` and `bond AS T2` as sources instead of multiple joined tables including `molecule`, `atom`, `connected`, and `bond`. Do perform an `INNER JOIN` between `T1` and `T2` on `T1.molecule_id = T2.molecule_id` instead of complex join conditions involving `OR` operations and multiple table connections. Do keep the filter `T1.molecule_id = 'TR024'` and `T2.bond_type = '='` in the `WHERE` clause instead of moving them elsewhere. The amended query now correctly matches the intended behavior by simplifying the table relationships and eliminating unnecessary joins while maintaining the same filtering logic."
        ],
        "rules": [
            "double bond refers to bond_type = '='; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "1474": {
        "sql": [
            "SELECT c.CustomerID, SUM(t.Amount) AS TotalConsumption\nFROM customers c\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE c.Currency = 'CZK' AND t.Date BETWEEN '201101' AND '201112'\nGROUP BY c.CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "SELECT c.CustomerID\nFROM customers c\nJOIN yearmonth T2 ON c.CustomerID = T2.CustomerID\nWHERE c.Currency = 'CZK' \nAND T2.Date BETWEEN 201101 AND 201112\nGROUP BY c.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;"
        ],
        "question": "Which customers, paying in CZK, consumed the most gas in 2011?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Date BETWEEN 201101 AND 201112 GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do join `yearmonth` table instead of `transactions_1k` table. Do reference `T2.Consumption` column instead of `t.Amount` column in the aggregation. Do use `SUM(T2.Consumption)` in the ORDER BY clause instead of referencing the alias `TotalConsumption`. Do remove the column alias `TotalConsumption` from the SELECT list instead of including it. Do use numeric literals `201101` AND `201112` without quotes instead of string literals for the date range comparison. The amended query now correctly aggregates consumption data from the yearmonth table with proper numeric date handling and ordering."
        ],
        "rules": [
            "Year 2011 can be presented as Between 201101 And 201112, which means between January and December in 2011"
        ]
    },
    "261": {
        "sql": [
            "SELECT b.bond_id\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE m.label = '+';"
        ],
        "question": "Write down bond id for molecules that are carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic"
        ]
    },
    "1375": {
        "sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.department = 'School of Applied Sciences, Technology and Education';"
        ],
        "question": "List all the members of the \"School of Applied Sciences, Technology and Education\" department.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'",
        "amends": [],
        "rules": [
            "list all members means to list all the full name; full name refers to first_name, last_name;"
        ]
    },
    "668": {
        "sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN (\n    SELECT UserId, COUNT(*) AS badge_count\n    FROM badges\n    GROUP BY UserId\n) b ON u.Id = b.UserId\nORDER BY b.badge_count DESC\nLIMIT 1;"
        ],
        "question": "What is the display name of the user who acquired the highest amount of badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T1.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "highest amount of badges refers to MAX(COUNT(Name));"
        ]
    },
    "726": {
        "sql": [
            "SELECT s.superhero_name, s.height_cm\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'Marvel Comics'\nORDER BY s.height_cm DESC;",
            "SELECT \n    superhero_name,\n    full_name,\n    height_cm,\n    RANK() OVER (ORDER BY height_cm DESC) AS HeightRank\nFROM \n    superhero\nINNER JOIN \n    publisher ON superhero.publisher_id = publisher.id\nWHERE \n    publisher.publisher_name = 'Marvel Comics'\nORDER BY \n    height_cm DESC;",
            "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics';"
        ],
        "question": "Rank heroes published by Marvel Comics by their height in descending order.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
        "amends": [
            "Do add `RANK() OVER (ORDER BY height_cm DESC) AS HeightRank` to the SELECT list instead of omitting this window function. Do use `INNER JOIN` instead of `JOIN` for explicit clarity, though both are equivalent. Do remove the table alias `s` from `superhero_name` and `height_cm` instead of keeping the aliased references. Do remove the explicit `ORDER BY s.height_cm DESC` clause instead of keeping it, as the window function's ORDER BY handles the ranking without needing a final result set sort. The amended query now correctly calculates rank positions for Marvel Comics superheroes by height without redundant sorting.",
            "Do remove `full_name` from the SELECT list instead of including it. Do remove the explicit ORDER BY clause at the end instead of keeping it, as the window function's ORDER BY already provides the necessary sorting. The amended query now correctly returns only the superhero name, height, and rank for Marvel Comics characters without redundant columns or duplicate sorting."
        ],
        "rules": [
            "name refers to superhero_name; the tallest hero refers to MAX(height_cm); published by Marvel Comics refers to publisher_name = 'Marvel Comics'"
        ]
    },
    "735": {
        "sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE hair_colour_id = (SELECT id FROM colour WHERE colour = 'Blond');"
        ],
        "question": "How many superheroes with blonde hair are there?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id WHERE T2.colour = 'Blond'",
        "amends": [],
        "rules": [
            "superheroes with blonde hair refers to colour = 'Blond' where hair_colour_id = colour.id"
        ]
    },
    "218": {
        "sql": [
            "WITH carcinogenic_molecules AS (\n  SELECT DISTINCT m.molecule_id\n  FROM molecule m\n  WHERE m.label = '+'\n),\nfluorine_molecules AS (\n  SELECT DISTINCT a.molecule_id\n  FROM atom a\n  WHERE a.element = 'f'\n)\nSELECT \n  (COUNT(DISTINCT cm.molecule_id) - COUNT(DISTINCT fm.molecule_id)) * 100.0 / COUNT(DISTINCT cm.molecule_id) AS percentage\nFROM carcinogenic_molecules cm\nLEFT JOIN fluorine_molecules fm ON cm.molecule_id = fm.molecule_id;",
            "SELECT \n    (COUNT(DISTINCT CASE WHEN a.element <> 'f' THEN m.molecule_id ELSE NULL END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM \n    molecule m\nINNER JOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = '+'"
        ],
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [
            "Do use a single query with `INNER JOIN` between `atom` and `molecule` tables instead of separate CTEs with `LEFT JOIN`. Do calculate the percentage using `CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END` instead of subtracting counts from separate CTEs. Do filter with `WHERE T2.label = '+'` instead of using a CTE for carcinogenic molecules. Do cast the count to `REAL` before division instead of using `100.0` with implicit casting. Do remove the CTE structure and perform the calculation directly in the main query instead of using intermediate result sets. The amended query now correctly calculates the percentage of carcinogenic molecules that do not contain fluorine atoms by joining the tables directly and using conditional counting."
        ],
        "rules": [
            "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;"
        ]
    },
    "884": {
        "sql": [
            "SELECT name FROM races\nWHERE year = (SELECT MIN(year) FROM races)\nAND strftime('%m', date) = (SELECT strftime('%m', date) FROM races WHERE year = (SELECT MIN(year) FROM races) ORDER BY date LIMIT 1);"
        ],
        "question": "List the names of all races that occurred in the earliest recorded year and month.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE STRFTIME('%Y', date) = ( SELECT STRFTIME('%Y', date) FROM races ORDER BY date ASC LIMIT 1 ) AND STRFTIME('%m', date) = ( SELECT STRFTIME('%m', date) FROM races ORDER BY date ASC LIMIT 1 )",
        "amends": [],
        "rules": [
            "earliest recorded year and month refers to year = year(min(date)) and month = month(min(date));"
        ]
    },
    "319": {
        "sql": [
            "SELECT COUNT(DISTINCT a1.element) AS element_count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_3_4';"
        ],
        "question": "How many elements are contained in bond_id TR001_3_4?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.element) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_3_4'",
        "amends": [],
        "rules": [
            "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "559": {
        "sql": [
            "SELECT CreationDate\nFROM votes\nGROUP BY CreationDate\nORDER BY COUNT(Id) DESC\nLIMIT 1;"
        ],
        "question": "Indicate the creation date of the maximum number of votes.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CreationDate FROM votes GROUP BY CreationDate ORDER BY COUNT(Id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the creation date of the maximum number of votes refers to CreationDate where Max(Count(Id))"
        ]
    },
    "1469": {
        "sql": [
            "SELECT m.first_name, m.last_name, m.position\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE z.city = 'Lincolnton' AND z.state = 'North Carolina' AND m.zip = 28092;"
        ],
        "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
        "amends": [],
        "rules": [
            "full name refers to first_name, last_name, hometown of Lincolnton, North Carolina refers to city = 'Lincolnton' AND state = 'North Carolina'"
        ]
    },
    "463": {
        "sql": [
            "SELECT COUNT(*) AS translation_count\nFROM set_translations\nWHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy');",
            "SELECT COUNT(DISTINCT translation) \nFROM set_translations \nWHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy') \nAND translation IS NOT NULL;"
        ],
        "question": "How many translations are there for the set of cards with \"Angel of Mercy\" in it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT translation) FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Angel of Mercy' ) AND translation IS NOT NULL",
        "amends": [
            "Do use `COUNT(DISTINCT translation)` instead of `COUNT(*)` to count unique translations rather than all rows. Do add `AND translation IS NOT NULL` instead of omitting it to exclude null translation values. Do keep the same subquery structure for the `IN` clause with `SELECT setCode FROM cards WHERE name = 'Angel of Mercy'` without changes. The amended query now correctly counts distinct non-null translations for the specified card set."
        ],
        "rules": [
            "set of cards with \"Angel of Mercy\" in it refers to name = 'Angel of Mercy'"
        ]
    },
    "1103": {
        "sql": [
            "SELECT pa.overall_rating \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Aaron Mooy' \nAND pa.date LIKE '2016-02-04%';"
        ],
        "question": "What was the overall rating for Aaron Mooy on 2016/2/4?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-02-04' AND t1.player_name = 'Aaron Mooy'",
        "amends": [],
        "rules": [
            "Aaron Mooy refers to player_name = 'Aaron Mooy'; on 2016/2/4 refers to date LIKE '2016-02-04%';"
        ]
    },
    "629": {
        "sql": [
            "SELECT \n    (SELECT COUNT(*) FROM votes WHERE strftime('%Y', CreationDate) = '2010') * 1.0 / \n    (SELECT COUNT(*) FROM votes WHERE strftime('%Y', CreationDate) = '2011') AS ratio_2010_to_2011;"
        ],
        "question": "Calculate the ratio of votes in 2010 and 2011.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
        "amends": [],
        "rules": [
            "DIVIDE(COUNT(Id where YEAR(CreationDate) = 2010), COUNT(Id where YEAR(CreationDate) = 2011)) FROM votes;"
        ]
    },
    "150": {
        "sql": [
            "SELECT COUNT(DISTINCT t.account_id) AS account_count\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE d.A3 = 'North Bohemia' AND t.bank = 'AB';",
            "SELECT COUNT(T2.account_id) \nFROM district T1 \nJOIN account T2 ON T1.district_id = T2.district_id \nJOIN trans T3 ON T2.account_id = T3.account_id \nWHERE T1.A3 = 'north Bohemia' AND T3.bank = 'AB'"
        ],
        "question": "How many accounts in North Bohemia has made a transaction with the partner's bank being AB?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.bank = 'AB' AND T1.A3 = 'north Bohemia'",
        "amends": [
            "Do use `COUNT(T2.account_id)` without DISTINCT instead of `COUNT(DISTINCT t.account_id)` to count all matching rows rather than unique accounts. Do join tables in the order `district \u2192 account \u2192 trans` instead of `trans \u2192 account \u2192 district` to properly filter by district first. Do reference `T3.bank` and `T1.A3` in the WHERE clause instead of `t.bank` and `d.A3` to match the new table aliases. Do use case-insensitive comparison `'north Bohemia'` instead of `'North Bohemia'` to match the actual data format. The amended query now correctly counts all transactions from AB bank in the north Bohemia district rather than unique accounts with such transactions."
        ],
        "rules": [
            "A3 contains the region names; North Bohemia is a region."
        ]
    },
    "1100": {
        "sql": [
            "SELECT MAX(pa.overall_rating) AS highest_overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Dorlan Pabon';"
        ],
        "question": "What is the highest overall rating received by Dorlan Pabon?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT MAX(t2.overall_rating) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Dorlan Pabon'",
        "amends": [],
        "rules": [
            "Dorlan Pabon refers to T2.player_name = 'Dorlan Pabon'; highest overall rating refers to MAX(overall_rating)"
        ]
    },
    "676": {
        "sql": [
            "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65;"
        ],
        "question": "Please list all display names of users who are adults.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65",
        "amends": [],
        "rules": [
            "adults refer to users where Age BETWEEN 19 and 65;"
        ]
    },
    "186": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN c.gender = 'M' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_male_clients\nFROM \n    account a\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    client c ON d.client_id = c.client_id\nWHERE \n    a.frequency = 'POPLATEK TYDNE';",
            "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) AS percentage_male_weekly_statements\nFROM client AS T1\nJOIN account AS T2 ON T1.district_id = T2.district_id\nJOIN district AS T3 ON T1.district_id = T3.district_id\nJOIN disp AS T4 ON T1.client_id = T4.client_id AND T2.account_id = T4.account_id\nWHERE T2.frequency = 'WEEKLY STATEMENT'",
            "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) \nFROM client AS T1\nINNER JOIN district AS T3 ON T1.district_id = T3.district_id\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id\nINNER JOIN account AS T2 ON T2.account_id = T4.account_id\nWHERE T2.frequency = 'POPLATEK TYDNE'",
            "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) \nFROM client AS T1\nINNER JOIN district AS T3 ON T1.district_id = T3.district_id\nINNER JOIN account AS T2 ON T2.district_id = T3.district_id\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T2.account_id = T4.account_id\nWHERE T2.frequency = 'POPLATEK TYDNE'"
        ],
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "amends": [
            "Do calculate the percentage using `CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id)` instead of `(COUNT(CASE WHEN c.gender = 'M' THEN 1 END) * 100.0 / COUNT(*))` to properly handle boolean aggregation and client counting. Do join `district AS T3` on `T1.district_id = T3.district_id` instead of omitting the district table entirely. Do add an additional join condition `T2.account_id = T4.account_id` to the `disp` table join instead of only joining on `T1.client_id = T4.client_id`. Do reference `T2.frequency` in the WHERE clause instead of `a.frequency` to align with the new table aliases. The amended query now correctly calculates the percentage of male clients by properly joining through the district relationship and ensuring accurate account-client linkages.",
            "Do use `INNER JOIN` for all table connections instead of mixing join types. Do join `district AS T3` before `account AS T2` instead of the reverse order, establishing proper district-based relationships. Do change the WHERE filter to `POPLATEK TYDNE` instead of `WEEKLY STATEMENT` to match the correct frequency condition. Do remove the alias `percentage_male_weekly_statements` instead of keeping it, as the right query returns an unnamed expression. The amended query now correctly filters for the specified account frequency and maintains proper join relationships through the district table.",
            "Do join `account AS T2` directly on `T2.district_id = T3.district_id` instead of joining through `disp AS T4` first, and do combine the `T2.account_id = T4.account_id` condition with the client join as `T1.client_id = T4.client_id AND T2.account_id = T4.account_id` instead of having separate join clauses. The amended query now correctly establishes the relationship between account and district directly while maintaining the proper connection through the disposition table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Percentage of male clients = [count(male clients who requested weekly statements / count(clients who requested weekly statements)] * 100%; Male means gender = 'M'; 'POPLATEK TYDNE' stands for weekly issuance"
        ]
    },
    "725": {
        "sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');"
        ],
        "question": "How many superheroes are published by Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "amends": [],
        "rules": [
            "published by Marvel Comics refers to publisher_name = 'Marvel Comics'"
        ]
    },
    "19": {
        "sql": [
            "SELECT s.Phone\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores);",
            "SELECT s.Phone \nFROM schools s\nINNER JOIN satscores T2 ON s.CDSCode = T2.cds\nORDER BY T2.AvgScrMath DESC \nLIMIT 1"
        ],
        "question": "What is the phone number of the school that has the highest average score in Math?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY T2.AvgScrMath DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` with alias `T2` instead of `JOIN` with alias `sc`. Do change the join condition to `T1.CDSCode = T2.cds` instead of `s.CDSCode = sc.cds`. Do remove the subquery filter `WHERE sc.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores)` instead of keeping it. Do add `ORDER BY T2.AvgScrMath DESC LIMIT 1` instead of omitting it, which correctly retrieves the school with the highest math score rather than potentially returning multiple schools tied for maximum score. The amended query now matches RIGHT_SQL's behavior by using ordering and limiting to find the single highest-scoring school."
        ],
        "rules": []
    },
    "1289": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'SJS' AND L.TP > 6.0 AND L.TP < 8.5;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SJS' AND T2.TP BETWEEN 6.6 AND 8.1",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SJS' \nAND T2.TP > 6.0 AND T2.TP < 8.5"
        ],
        "question": "For the patients who are diagnosed with SJS, how many of them have a normal level of total protein?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SJS' AND T2.TP > 6.0 AND T2.TP < 8.5",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` consistently instead of mixing `P` and `L` with aliases. Do reference `T2.TP` in the WHERE clause instead of `L.TP` to match the table alias pattern. The amended query now correctly counts all laboratory results meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior.",
            "Do change the TP filter to `T2.TP > 6.0 AND T2.TP < 8.5` instead of `T2.TP BETWEEN 6.6 AND 8.1` to widen the range and use exclusive bounds rather than inclusive bounds. The amended query now correctly counts patients with SJS diagnosis whose TP values fall within the expanded range of greater than 6.0 and less than 8.5, matching the intended behavior."
        ],
        "rules": [
            "diagnosed with SJS refers to Diagnosis = 'SJS'; normal level of total protein refers to TP > 6.0 and TP < 8.5;"
        ]
    },
    "579": {
        "sql": [
            "SELECT c.Text \nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.Title = 'How does gentle boosting differ from AdaBoost?';"
        ],
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'",
        "amends": [],
        "rules": [
            "\"How does gentle boosting differ from AdaBoost?\" is the Title of post; comments refers to Text"
        ]
    }
}