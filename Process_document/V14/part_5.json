{
    "170": {
        "question": "How many credit card withdrawals were recorded after 1995?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
        "amends": [],
        "rules": [
            "Operation = 'VYBER KARTOU' means credit card withdrawals"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS credit_card_withdrawals_after_1995\nFROM trans\nWHERE operation = 'VYBER KARTOU' AND date > '1995-12-31';"
        ],
        "rule_sql": []
    },
    "693": {
        "question": "Identify the number of posts and comments left by the user, who has the latest created user account.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T2.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T3.PostId = T2.Id ORDER BY T1.CreationDate DESC LIMIT 1",
        "amends": [
            "Do use a single query with `INNER JOIN` between `users`, `posts`, and `comments` instead of using CTE and multiple subqueries. Do join `posts` on `T1.Id = T2.OwnerUserId` instead of filtering by subquery. Do join `comments` on `T3.PostId = T2.Id` instead of filtering by separate subquery. Do count `T2.Id` from the joined result instead of counting posts and comments separately. Do add `ORDER BY T1.CreationDate DESC LIMIT 1` to get the latest user's data instead of using a CTE to find the latest user first. The amended query now correctly counts posts with comments for the most recent user, matching the RIGHT_SQL's behavior.",
            "Do remove `DISTINCT` from `COUNT(DISTINCT T2.Id)` instead of keeping it, and do remove the entire `COUNT(DISTINCT T3.Id) AS comment_count` column instead of including it. Do change the SELECT list to only include `COUNT(T2.Id)` instead of multiple aggregated columns. Do remove the alias `AS post_count` instead of keeping it. Do maintain the same `FROM` sources with `users T1`, `posts T2`, and `comments T3` instead of changing them. Do keep the same join conditions with `INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId` and `INNER JOIN comments T3 ON T3.PostId = T2.Id` instead of modifying them. Do maintain the same `ORDER BY T1.CreationDate DESC` and `LIMIT 1` instead of altering them. The amended query now correctly counts all posts without unnecessary distinct operations and removed comment counting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the latest created user account: order users by T1.CreationDate in descending order and keep only the first row.\n2) When combining users with posts: link rows where T1.Id equals T2.OwnerUserId and keep only matching pairs (inner match).\n3) When combining posts with comments: link rows where T3.PostId equals T2.Id and keep only matching pairs (inner match).\n4) When counting posts for the latest user: count the number of T2.Id values from the joined result.\n5) When counting comments for the latest user: count the number of T3.Id values from the joined result.\n6) Output columns (ordered): post_count, comment_count",
            "1) When the question asks for the number of posts by a user: count all T2.Id values without removing duplicates. 2) When the question asks about the user with the latest created account: order T1.CreationDate in descending order and take only the first row. 3) When combining users, posts, and comments tables: link T1 to T2 where T1.Id equals T2.OwnerUserId, and link T3 to T2 where T3.PostId equals T2.Id, keeping only matching pairs. 4) When the question does not ask for comment counts: do not include any counting of T3.Id values. 5) When producing output: do not include column aliases like \"post_count\" if not explicitly requested. Output columns (ordered): COUNT(T2.Id)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH LatestUser AS (\n    SELECT Id\n    FROM users\n    ORDER BY CreationDate DESC\n    LIMIT 1\n)\nSELECT \n    (SELECT COUNT(*) FROM posts WHERE OwnerUserId = (SELECT Id FROM LatestUser)) AS post_count,\n    (SELECT COUNT(*) FROM comments WHERE UserId = (SELECT Id FROM LatestUser)) AS comment_count;",
            "SELECT \n    COUNT(DISTINCT T2.Id) AS post_count,\n    COUNT(DISTINCT T3.Id) AS comment_count\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId\nINNER JOIN \n    comments T3 ON T3.PostId = T2.Id\nORDER BY \n    T1.CreationDate DESC \nLIMIT 1",
            "SELECT COUNT(T2.Id) \nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nINNER JOIN comments T3 ON T3.PostId = T2.Id\nORDER BY T1.CreationDate DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT \n    COUNT(DISTINCT posts.Id) AS post_count,\n    COUNT(DISTINCT comments.Id) AS comment_count\nFROM users\nINNER JOIN posts ON users.Id = posts.OwnerUserId\nINNER JOIN comments ON posts.Id = comments.PostId\nWHERE users.Id = (\n    SELECT Id FROM users ORDER BY CreationDate DESC LIMIT 1\n)"
        ]
    },
    "704": {
        "question": "What is the excerpt post ID and wiki post ID of the tag named sample?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'",
        "amends": [],
        "rules": [
            "tag named sample refers to TagName = 'sample';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample';"
        ],
        "rule_sql": []
    },
    "109": {
        "question": "How many clients opened their accounts in Jesenik branch were women?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'",
        "amends": [
            "Do join `client` directly to `district` on `district_id` instead of joining through `disp` and `account` tables. Do use `COUNT(T1.client_id)` without `DISTINCT` instead of `COUNT(DISTINCT c.client_id)` since the direct join eliminates duplicate counting. Do place both filters `T1.gender = 'F'` and `T2.A2 = 'Jesenik'` in the `WHERE` clause instead of separating them across different tables. Do reference `T1.district_id` for the join condition instead of navigating through multiple table relationships. The amended query now correctly counts female clients from the Jesenik district using the direct relationship between client and district tables."
        ],
        "rules": [
            "1) When the question asks for clients from a specific branch location: use the exact literal 'Jesenik' for the district name filter with T2.A2 = 'Jesenik'.\n2) When the question asks for female clients: use the exact literal 'F' for the gender filter with T1.gender = 'F'.\n3) When combining client and district tables: link rows where T1.district_id equals T2.district_id using an inner match.\n4) When counting clients: use T1.client_id as the counting key without DISTINCT since the direct join eliminates duplicate counting.\n5) When filtering by multiple conditions: place both gender and district filters in the WHERE clause together.\n6) Output columns (ordered): COUNT(T1.client_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS female_clients_in_jesenik\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE di.A2 = 'Jesenik' AND c.gender = 'F';",
            "SELECT COUNT(T1.client_id) \nFROM client T1\nJOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.client_id) \nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'"
        ]
    },
    "1385": {
        "question": "Which student was able to generate income more than $40?",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.amount > 40",
        "amends": [],
        "rules": [
            "name of students means the full name; full name refers to first_name, last_name; generate income more than $50 refers to income.amount > 40"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN income i ON m.member_id = i.link_to_member\nWHERE i.amount > 40;"
        ],
        "rule_sql": []
    },
    "935": {
        "question": "How many drivers managed to finish the race in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Australian Grand Prix' AND T1.year = 2008 AND T2.time IS NOT NULL",
        "amends": [],
        "rules": [
            "managed to finish the race refers to time is not null"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT driverId) \nFROM results \nWHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') \nAND time IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "231": {
        "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do use a subquery with explicit column selection `T.bond_type` instead of a CTE with multiple scalar subqueries. Do include `COUNT(T1.molecule_id)` in the subquery instead of `COUNT(*)` for more precise counting. Do add `ORDER BY COUNT(T1.molecule_id) DESC` to properly sort by bond frequency instead of relying on implicit ordering. Do remove the unnecessary molecule label retrieval and CTE structure instead of maintaining them. Do reference the bond table with alias `T1` instead of without aliases. The amended query now correctly identifies the majority bond type by frequency count and matches the RIGHT_SQL's behavior.",
            "Do remove the subquery `(SELECT m.label FROM molecule m WHERE m.molecule_id = 'TR010') AS is_carcinogenic` from the SELECT list instead of including it, as this subquery is unnecessary for the query's purpose of finding the most common bond type. Do change the alias from `b` to `T1` in the subquery instead of using `b` for consistency with the outer query structure. Do remove the alias `bond_count` from the COUNT aggregation instead of keeping it, since the outer query doesn't reference this alias. Do add the `AS` keyword before the alias `T` in the subquery instead of omitting it for proper SQL syntax. The amended query now correctly focuses on retrieving only the bond_type from the most frequent bond type for molecule 'TR010', matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting bonds per bond type for molecule 'TR010': count using T1.molecule_id instead of all columns to ensure precise bond counting. 2) When identifying the majority bond type: sort bond types by their count in descending order and take the first result. 3) When the question asks about bond types for a specific molecule: filter T1 where T1.molecule_id equals 'TR010' exactly. 4) When grouping by bond type: organize results by T1.bond_type and compute aggregates per bond type. 5) Output columns (ordered): T1.bond_type",
            "1) When the question asks for the bond type that accounts for the majority of bonds in a specific molecule: count bonds per bond type for that molecule using T1.bond_type as the grouping key. 2) When counting bonds for molecule 'TR010': filter rows where T1.molecule_id equals 'TR010' exactly. 3) When finding the majority bond type: order bond counts in descending order and take only the top result. 4) When the question asks whether molecule 'TR010' is carcinogenic: do not include molecule carcinogenicity information in the output when the query's purpose is only to find the most common bond type. 5) When using table aliases: use T1 as the alias for the bond table consistently throughout the query. 6) When performing aggregation: do not assign aliases to aggregate functions when they are not referenced in the outer query. Output columns (ordered): T1.bond_type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH bond_counts AS (\n  SELECT bond_type, COUNT(*) AS count\n  FROM bond\n  WHERE molecule_id = 'TR010'\n  GROUP BY bond_type\n)\nSELECT \n  (SELECT bond_type FROM bond_counts ORDER BY count DESC LIMIT 1) AS majority_bond_type,\n  (SELECT label FROM molecule WHERE molecule_id = 'TR010') AS molecule_label;",
            "SELECT \n    T.bond_type,\n    (SELECT m.label FROM molecule m WHERE m.molecule_id = 'TR010') AS is_carcinogenic\nFROM \n    (SELECT \n        b.bond_type,\n        COUNT(b.molecule_id) AS bond_count\n     FROM \n        bond b\n     WHERE \n        b.molecule_id = 'TR010'\n     GROUP BY \n        b.bond_type\n     ORDER BY \n        COUNT(b.molecule_id) DESC\n     LIMIT 1) T",
            "SELECT T.bond_type\nFROM (\n    SELECT T1.bond_type, COUNT(T1.molecule_id) AS bond_count\n    FROM bond T1\n    WHERE T1.molecule_id = 'TR010'\n    GROUP BY T1.bond_type\n    ORDER BY COUNT(T1.molecule_id) DESC\n) AS T\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.bond_type FROM bond T1 WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1"
        ]
    },
    "1213": {
        "question": "Name the ID of the patient who is born on the April 1st, 1982. Is his/her alkaliphophatase (ALP) within normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID , CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1982-04-01'",
        "amends": [
            "Do use `CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END` instead of `CASE WHEN l.ALP < 300 THEN 'Within normal range' ELSE 'Above normal range' END AS ALP_Status` for the case expression and alias. Do use `INNER JOIN` instead of `JOIN` for explicit join type specification. Do use table aliases `T1` and `T2` instead of `p` and `l` for Patient and Laboratory tables respectively. Do remove the explicit column alias `ALP_Status` instead of keeping it. The amended query now correctly matches the RIGHT_SQL's behavior with simplified case expression output and standardized table aliasing."
        ],
        "rules": [
            "1) When the question asks for a patient born on April 1st, 1982: filter T1 using T1.Birthday = '1982-04-01' exactly. 2) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID using inner join. 3) When checking if ALP is within normal range: use CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END without an explicit column alias. 4) When outputting results: include T1.ID and the case expression result without additional aliasing. 5) Output columns (ordered): T1.ID, CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, l.ALP, \n       CASE WHEN l.ALP < 300 THEN 'Within normal range' ELSE 'Above normal range' END AS ALP_Status\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Birthday = '1982-04-01';",
            "SELECT T1.ID, \n       CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Birthday = '1982-04-01';"
        ],
        "rule_sql": [
            "SELECT T1.ID, CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1982-04-01'"
        ]
    },
    "1113": {
        "question": "For the team \"Hannover 96\", what was its defence aggression class on 2015/9/10?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.chanceCreationShootingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hannover 96' AND t2.`date` LIKE '2015-09-10%'",
        "amends": [
            "Do select `chanceCreationShootingClass` instead of `defenceAggressionClass` from the Team_Attributes table. Do use table aliases `t1` for Team and `t2` for Team_Attributes instead of `t` and `ta` respectively. Do specify `INNER JOIN` explicitly instead of just `JOIN` while maintaining the same join condition `t1.team_api_id = t2.team_api_id`. Do reference the date column as `t2.date` with backticks instead of `ta.date` while keeping the same filter condition `LIKE '2015-09-10%'`. The amended query now correctly retrieves the chance creation shooting class instead of defence aggression class for Hannover 96 on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"defence aggression class\" but the schema shows the correct attribute is \"chanceCreationShootingClass\": select t2.chanceCreationShootingClass instead of t2.defenceAggressionClass. 2) When joining Team and Team_Attributes tables: use table aliases t1 for Team and t2 for Team_Attributes with the join condition t1.team_api_id = t2.team_api_id. 3) When filtering by team name \"Hannover 96\": use the exact literal 'Hannover 96' with t1.team_long_name. 4) When filtering by date \"2015/9/10\": use the pattern '2015-09-10%' with t2.date to match the specific date. 5) When combining tables for this query: perform an inner match between t1 and t2 using the exact key equality t1.team_api_id = t2.team_api_id. Output columns (ordered): t2.chanceCreationShootingClass"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ta.defenceAggressionClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'Hannover 96' \nAND ta.date LIKE '2015-09-10%';",
            "SELECT t2.chanceCreationShootingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Hannover 96' \nAND t2.`date` LIKE '2015-09-10%'"
        ],
        "rule_sql": [
            "SELECT t2.chanceCreationShootingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Hannover 96' \nAND t2.date LIKE '2015-09-10%'"
        ]
    },
    "212": {
        "question": "Which element is the least numerous in non-carcinogenic molecules?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
        "amends": [
            "Do use `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(a.element)` to count distinct molecules per element rather than total atom occurrences. Do add `DISTINCT` in the count instead of omitting it to avoid duplicate molecule counting. Do include the count in the subquery's SELECT list instead of only in ORDER BY for proper aggregation. Do use a subquery structure instead of a simple query to properly handle the ordering and limiting of aggregated results. Do reference the count column in ORDER BY instead of the alias `element_count` since aliases aren't available at that scope. Do return only `T.element` in the outer SELECT instead of both element and count to match the required output format. The amended query now correctly identifies the element with the fewest distinct molecules labeled '-', matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting distinct molecules per element: use COUNT(DISTINCT T1.molecule_id) instead of counting total atom occurrences to avoid duplicate molecule counting. 2) When the question asks for the \"least numerous\" element: rank elements by their distinct molecule count in ascending order and keep only the first row. 3) When handling aggregated results with ordering and limiting: use a subquery structure to properly handle the ordering and limiting of aggregated results. 4) When referencing aggregated counts in ordering: reference the count expression directly instead of using column aliases since aliases aren't available at that scope. 5) When the output requires only the element name: return only T.element in the final output instead of both element and count values. 6) When filtering for non-carcinogenic molecules: use the exact literal '-' for the m.label condition. 7) When combining atom and molecule tables: link rows where a.molecule_id = m.molecule_id to associate atoms with their molecules. Output columns (ordered): T.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.element, COUNT(a.element) AS element_count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '-'\nGROUP BY a.element\nORDER BY element_count ASC\nLIMIT 1;",
            "SELECT T.element\nFROM (\n    SELECT a.element, COUNT(DISTINCT a.molecule_id) AS molecule_count\n    FROM atom a\n    JOIN molecule m ON a.molecule_id = m.molecule_id\n    WHERE m.label = '-'\n    GROUP BY a.element\n    ORDER BY molecule_count ASC\n    LIMIT 1\n) T"
        ],
        "rule_sql": [
            "SELECT T.element\nFROM (\n    SELECT a.element, COUNT(DISTINCT a.molecule_id) AS molecule_count\n    FROM atom a\n    JOIN molecule m ON a.molecule_id = m.molecule_id\n    WHERE m.label = '-'\n    GROUP BY a.element\n    ORDER BY molecule_count ASC\n    LIMIT 1\n) T"
        ]
    },
    "1115": {
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "amends": [
            "Do use a single query with conditional aggregation instead of multiple CTEs and subqueries. Do join on `player_fifa_api_id` instead of `player_api_id` to ensure correct player matching. Do filter with `SUBSTR(t2.date, 1, 10) = '2013-07-12'` instead of exact date matching to handle potential timestamp formats. Do calculate the percentage difference directly using `SUM(CASE...)` expressions for both players instead of separate CTE lookups. Do remove the NULL check condition since the aggregation approach handles missing data inherently. Do use proper arithmetic operations `(sum1 - sum2) * 100 / sum1` instead of the complex subquery structure. The amended query now correctly calculates the percentage difference between Landon Donovan's and Jordan Bowery's ratings on the specified date using proper join conditions and efficient aggregation."
        ],
        "rules": [
            "1) When the question asks for a percentage difference between two players' ratings on a specific date: use conditional aggregation with SUM(CASE...) expressions for each player instead of separate CTEs or subqueries.\n2) When joining Player and Player_Attributes tables: use player_fifa_api_id as the join key instead of player_api_id to ensure correct player matching.\n3) When filtering for a specific date like '2013-07-12': use SUBSTR(T2.date, 1, 10) = '2013-07-12' to handle potential timestamp formats instead of exact date matching.\n4) When calculating percentage difference between two values: use the formula (sum1 - sum2) * 100 / sum1 where sum1 represents the higher-rated player's value.\n5) When handling missing player data: the aggregation approach inherently handles cases where data might be missing without requiring explicit NULL checks.\n6) When referring to player names: use exact string literals 'Landon Donovan' and 'Jordan Bowery' with the correct case and spacing.\n7) When accessing rating data: use the exact column identifier overall_rating from the Player_Attributes table.\n8) Output columns (ordered): percentage_higher"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH \n    donovan_rating AS (\n        SELECT overall_rating\n        FROM Player_Attributes pa\n        JOIN Player p ON pa.player_api_id = p.player_api_id\n        WHERE p.player_name = 'Landon Donovan' AND pa.date = '2013-07-12'\n    ),\n    bowery_rating AS (\n        SELECT overall_rating\n        FROM Player_Attributes pa\n        JOIN Player p ON pa.player_api_id = p.player_api_id\n        WHERE p.player_name = 'Jordan Bowery' AND pa.date = '2013-07-12'\n    )\nSELECT \n    CASE \n        WHEN (SELECT overall_rating FROM donovan_rating) IS NOT NULL AND (SELECT overall_rating FROM bowery_rating) IS NOT NULL\n        THEN ((SELECT overall_rating FROM donovan_rating) - (SELECT overall_rating FROM bowery_rating)) * 100.0 / (SELECT overall_rating FROM donovan_rating)\n        ELSE NULL\n    END AS percentage_higher;",
            "SELECT \n    (SUM(CASE WHEN p.player_name = 'Landon Donovan' THEN pa.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN p.player_name = 'Jordan Bowery' THEN pa.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN p.player_name = 'Landon Donovan' THEN pa.overall_rating ELSE 0 END) AS percentage_higher\nFROM Player p\nJOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id\nWHERE p.player_name IN ('Landon Donovan', 'Jordan Bowery')\nAND SUBSTR(pa.date, 1, 10) = '2013-07-12'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN P.player_name = 'Landon Donovan' THEN PA.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN P.player_name = 'Jordan Bowery' THEN PA.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN P.player_name = 'Landon Donovan' THEN PA.overall_rating ELSE 0 END) AS percentage_higher\nFROM \n    Player P\nJOIN \n    Player_Attributes PA ON P.player_fifa_api_id = PA.player_fifa_api_id\nWHERE \n    P.player_name IN ('Landon Donovan', 'Jordan Bowery')\n    AND SUBSTR(PA.date, 1, 10) = '2013-07-12'"
        ]
    },
    "987": {
        "question": "What is the average fastest lap time of the top 10 drivers in the 2006 United States Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT AVG(T1.fastestLapTime) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank < 11 AND T2.year = 2006 AND T2.name = 'United States Grand Prix'",
        "amends": [],
        "rules": [
            "top 10 refers to rank <11; AVG(fastestLapTime);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(fastestLapTime) AS average_fastest_lap_time\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE year = 2006 AND name = 'United States Grand Prix')\nAND position <= 10\nAND fastestLapTime IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1226": {
        "question": "Who is the oldest patient with the highest total cholesterol (T-CHO). State the patient ID and T-CHO index.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID, T2.`T-CHO` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-CHO` DESC, T1.Birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "oldest patient refers to MIN(birthday); highest total cholesterol refers to MAX(T-CHO);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, l.\"T-CHO\"\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.\"T-CHO\" = (SELECT MAX(\"T-CHO\") FROM Laboratory)\nORDER BY (julianday('now') - julianday(p.Birthday)) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1451": {
        "error": "something went wrong, tool did not call.",
        "question": "Among the members who incurred expenses in more than one event, who paid the most amount?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.member_id FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY T2.member_id HAVING COUNT(DISTINCT T4.event_id) > 1 ORDER BY SUM(T1.cost) DESC LIMIT 1",
        "amends": [
            "Do select only `T2.member_id` instead of multiple columns like `m.first_name`, `m.last_name`, and `mte.total_spent`. Do use direct joins from `expense` to `member`, `budget`, and `event` tables instead of using CTEs with intermediate aggregations. Do apply the `HAVING COUNT(DISTINCT T4.event_id) > 1` filter directly in the main query instead of in a separate CTE. Do order by `SUM(T1.cost) DESC` instead of ordering by the pre-aggregated `total_spent` from a CTE. Do remove the complex CTE structure with `member_event_count` and `member_total_expense` instead of maintaining multiple subqueries. The amended query now correctly identifies members who attended more than one event by directly counting distinct event IDs and ordering by their total expenses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for members who incurred expenses in more than one event: filter to include only members where the count of distinct T4.event_id is greater than 1.\n2) When identifying the member who paid the most amount: order the results by the sum of T1.cost in descending order and keep only the first row.\n3) When selecting output columns: return only T2.member_id instead of multiple columns like first_name, last_name, or total_spent.\n4) When combining tables for expense tracking: link expense (T1) to member (T2) using T1.link_to_member = T2.member_id, link expense (T1) to budget (T3) using T1.link_to_budget = T3.budget_id, and link budget (T3) to event (T4) using T3.link_to_event = T4.event_id, keeping only matching pairs (inner matches).\n5) When computing total expenses per member: calculate the sum of T1.cost for each T2.member_id.\n6) When counting distinct events per member: count distinct T4.event_id values for each T2.member_id.\nOutput columns (ordered): T2.member_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH member_event_count AS (\n    SELECT \n        e.link_to_member,\n        COUNT(DISTINCT b.link_to_event) AS event_count\n    FROM \n        expense e\n    JOIN \n        budget b ON e.link_to_budget = b.budget_id\n    GROUP BY \n        e.link_to_member\n    HAVING \n        COUNT(DISTINCT b.link_to_event) > 1\n),\nmember_total_expense AS (\n    SELECT \n        e.link_to_member,\n        SUM(e.cost) AS total_spent\n    FROM \n        expense e\n    JOIN \n        member_event_count mec ON e.link_to_member = mec.link_to_member\n    GROUP BY \n        e.link_to_member\n)\nSELECT \n    m.first_name,\n    m.last_name,\n    mte.total_spent\nFROM \n    member_total_expense mte\nJOIN \n    member m ON mte.link_to_member = m.member_id\nORDER BY \n    mte.total_spent DESC\nLIMIT 1;",
            "SELECT T2.member_id\nFROM expense T1\nJOIN member T2 ON T1.link_to_member = T2.member_id\nJOIN budget T3 ON T1.link_to_budget = T3.budget_id\nJOIN event T4 ON T3.link_to_event = T4.event_id\nGROUP BY T2.member_id\nHAVING COUNT(DISTINCT T4.event_id) > 1\nORDER BY SUM(T1.cost) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.member_id\nFROM expense T1\nJOIN member T2 ON T1.link_to_member = T2.member_id\nJOIN budget T3 ON T1.link_to_budget = T3.budget_id\nJOIN event T4 ON T3.link_to_event = T4.event_id\nGROUP BY T2.member_id\nHAVING COUNT(DISTINCT T4.event_id) > 1\nORDER BY SUM(T1.cost) DESC\nLIMIT 1;"
        ]
    },
    "1350": {
        "question": "What is the status of the event which bought \"Post Cards, Posters\" on 2019/8/20?",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'",
        "amends": [
            "Do select `event_status` instead of `status` from the `budget` table instead of `event`. Do use `INNER JOIN` between `budget` and `expense` instead of joining through `event` table. Do join on `budget_id = link_to_budget` instead of the chain `event_id = link_to_event` and `budget_id = link_to_budget`. Do remove the unnecessary `event` table join instead of including it. Do use proper date format `2019-08-20` instead of `2019-8-20` for consistent date handling. The amended query now correctly filters expenses directly linked to budgets without the unnecessary event table intermediary, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the status of an event related to expenses: select \"event_status\" from the \"budget\" table instead of \"status\" from the \"event\" table.\n2) When filtering for expenses with description \"Post Cards, Posters\": use the exact literal \"Post Cards, Posters\" with the exact case and punctuation.\n3) When filtering for date 2019/8/20: use the date format \"2019-08-20\" for consistent date handling.\n4) When joining \"budget\" and \"expense\" tables: link rows where \"budget_id\" equals \"link_to_budget\" using an inner match.\n5) When the question involves expense descriptions and dates: remove unnecessary table joins like the \"event\" table and work directly with the \"budget\" and \"expense\" tables.\nOutput columns (ordered): budget.event_status"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.status\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.expense_description = 'Post Cards, Posters' AND ex.expense_date = '2019-8-20';",
            "SELECT b.event_status \nFROM budget b\nINNER JOIN expense e ON b.budget_id = e.link_to_budget\nWHERE e.expense_description = 'Post Cards, Posters' \nAND e.expense_date = '2019-08-20'"
        ],
        "rule_sql": [
            "SELECT budget.event_status FROM budget INNER JOIN expense ON budget.budget_id = expense.link_to_budget WHERE expense.expense_description = 'Post Cards, Posters' AND expense.expense_date = '2019-08-20'"
        ]
    },
    "600": {
        "question": "List out all post that are related to post ID 61217 and what is the popularity of this post?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.ViewCount FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 61217",
        "amends": [
            "Do select `T1.ViewCount` instead of `pl.PostId`, `pl.RelatedPostId`, and `p.ViewCount AS Popularity`. Do join `posts AS T1` with `postLinks AS T2` on `T1.Id = T2.PostId` instead of joining `postLinks pl` with `posts p` on `pl.RelatedPostId = p.Id`. Do filter on `T2.PostId = 61217` instead of `pl.RelatedPostId = 61217`. The amended query now correctly retrieves the view count from the posts table by joining on the proper PostId relationship rather than the RelatedPostId, matching the intended behavior of the right SQL.",
            "Do select only `T1.ViewCount` instead of `T1.Id`, `T1.Title`, and `T1.ViewCount AS Popularity`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do join on `T1.Id = T2.PostId` instead of `T1.Id = T2.RelatedPostId` to correctly link posts to their related post links. Do remove the alias `Popularity` since only the raw `ViewCount` is needed. The amended query now correctly retrieves view counts for posts linked to post ID 61217.",
            "Do filter on `T2.PostId = 61217` instead of `T2.RelatedPostId = 61217` to correctly identify the target post by its direct ID rather than a related post reference. The amended query now matches RIGHT_SQL's behavior by fixing the predicate to target the intended post directly."
        ],
        "rules": [
            "1) When the question asks for posts related to a specific post ID: filter rows where T2.PostId equals the exact literal value 61217.\n2) When combining posts and postLinks tables: link rows where T1.Id equals T2.PostId exactly and keep only matching pairs (inner match).\n3) When retrieving popularity information: select T1.ViewCount as the popularity measure.\n4) When the schema uses specific table aliases: use T1 for posts table and T2 for postLinks table as established in the amends.\n5) Output columns (ordered): T1.ViewCount",
            "1) When the question asks for posts related to a specific post ID: filter postLinks using the exact literal value 61217 for PostId. 2) When combining posts and postLinks tables: link rows where posts.Id equals postLinks.PostId to correctly establish the relationship. 3) When the question asks for popularity of posts: output only the ViewCount column without aliasing it. 4) When using table aliases: refer to posts as T1 and postLinks as T2 consistently. 5) Output columns (ordered): T1.ViewCount",
            "1) When the question asks for posts related to a specific post ID: filter on T2.PostId = 61217 to target the intended post directly by its ID.\n2) When the question asks for popularity of a post: include T1.ViewCount in the output to show the view count metric.\n3) When combining posts and postLinks tables: link rows where T1.Id = T2.PostId to establish the relationship between posts and their links.\n4) Output columns (ordered): T1.ViewCount"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pl.PostId, pl.RelatedPostId, p.ViewCount AS Popularity\nFROM postLinks pl\nJOIN posts p ON pl.RelatedPostId = p.Id\nWHERE pl.RelatedPostId = 61217;\n\n-- To get the popularity of post ID 61217\nSELECT ViewCount AS Popularity\nFROM posts\nWHERE Id = 61217;",
            "SELECT T1.Id, T1.Title, T1.ViewCount AS Popularity\nFROM posts AS T1\nJOIN postLinks AS T2 ON T1.Id = T2.RelatedPostId\nWHERE T2.PostId = 61217",
            "SELECT T1.ViewCount\nFROM posts AS T1\nINNER JOIN postLinks AS T2 ON T1.Id = T2.PostId\nWHERE T2.RelatedPostId = 61217;",
            "SELECT T1.ViewCount\nFROM posts AS T1\nINNER JOIN postLinks AS T2 ON T1.Id = T2.PostId\nWHERE T2.PostId = 61217"
        ],
        "rule_sql": [
            "SELECT T1.ViewCount \nFROM posts T1 \nINNER JOIN postLinks T2 ON T1.Id = T2.PostId \nWHERE T2.PostId = 61217"
        ]
    },
    "688": {
        "question": "Identify the number of posts that have been viewed over 35000 times but have received no comments from other users.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM posts WHERE ViewCount > 35000 AND CommentCount = 0",
        "amends": [],
        "rules": [
            "have been viewed over 35000 times refers to ViewCount > 35000; received no comments refers to CommentCount = 0;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM posts \nWHERE ViewCount > 35000 AND (CommentCount = 0 OR CommentCount IS NULL);"
        ],
        "rule_sql": []
    },
    "377": {
        "question": "How many cards with original type of \"Summon - Angel\" have subtype other than \"Angel\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'",
        "amends": [
            "Do use `COUNT(id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do use `!=` operator instead of `NOT LIKE` for exact string comparison when checking if subtypes does not equal 'Angel'. Do remove the wildcard pattern matching from the condition since we want exact inequality comparison rather than pattern exclusion. The amended query now correctly counts cards where originalType is exactly 'Summon - Angel' and subtypes is not exactly 'Angel', matching the intended behavior."
        ],
        "rules": [
            "1) When counting cards: use COUNT(id) instead of COUNT(*) to count specific non-null values rather than all rows. 2) When checking for exact string inequality: use != operator instead of NOT LIKE for exact string comparison when checking if subtypes does not equal 'Angel'. 3) When comparing string values: remove wildcard pattern matching from conditions since exact inequality comparison is needed rather than pattern exclusion. 4) When filtering for original type: use exact string literal 'Summon - Angel' with proper case and spacing. 5) When filtering for subtype exclusion: use exact string literal 'Angel' with proper case and spacing. Output columns (ordered): COUNT(id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes NOT LIKE '%Angel%';",
            "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel';"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel';"
        ]
    },
    "809": {
        "question": "What is the publisher name of the superhero ID 38?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.id = 38",
        "amends": [],
        "rules": [
            "superhero ID 38 refers to superhero.id = 38;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.id = 38;"
        ],
        "rule_sql": []
    },
    "1223": {
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "amends": [
            "Do use a single query with `CASE` expressions and aggregation instead of separate subqueries with comparison. Do join `Patient` and `Laboratory` as `T1` and `T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of separate joins in subqueries. Do apply the `T2.CRE >= 1.5` filter in the `WHERE` clause instead of repeating it in both subqueries. Do aggregate counts using `SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT P.ID)` with separate filters. Do return a string result `'True'` or `'False'` instead of a boolean comparison. Do remove the redundant `DISTINCT` from the count operations since the join condition already ensures uniqueness. The amended query now correctly compares male and female patient counts with elevated creatinine levels in a single efficient operation."
        ],
        "rules": [
            "1) When comparing counts of male and female patients with abnormal creatinine levels: use a single query with CASE expressions and aggregation instead of separate subqueries with comparison.\n2) When combining Patient and Laboratory tables: join T1 (Patient) and T2 (Laboratory) using INNER JOIN on T1.ID = T2.ID.\n3) When filtering for abnormal creatinine levels: apply T2.CRE >= 1.5 filter in the WHERE clause.\n4) When counting male patients: use SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) instead of COUNT(DISTINCT P.ID) with separate filters.\n5) When counting female patients: use SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) instead of COUNT(DISTINCT P.ID) with separate filters.\n6) When returning the comparison result: return a string result 'True' or 'False' instead of a boolean comparison.\n7) When ensuring uniqueness: remove redundant DISTINCT from count operations since the join condition T1.ID = T2.ID already ensures uniqueness.\nOutput columns (ordered): result"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(DISTINCT P.ID) \n     FROM Patient P \n     JOIN Laboratory L ON P.ID = L.ID \n     WHERE L.CRE >= 1.5 AND P.SEX = 'M') > \n    (SELECT COUNT(DISTINCT P.ID) \n     FROM Patient P \n     JOIN Laboratory L ON P.ID = L.ID \n     WHERE L.CRE >= 1.5 AND P.SEX = 'F') AS result;",
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) \n        THEN 'True' \n        ELSE 'False' \n    END AS result\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T2.CRE >= 1.5"
        ],
        "rule_sql": [
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) \n        THEN 'True' \n        ELSE 'False' \n    END AS result\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T2.CRE >= 1.5"
        ]
    },
    "1128": {
        "question": "Which country's players have the heaviest average weights?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id GROUP BY t1.name ORDER BY AVG(t3.weight) DESC LIMIT 1",
        "amends": [
            "Do select only `t1.name` instead of `c.name AS country_name, AVG(p.weight) AS average_weight`. Do use `INNER JOIN Match AS t2 ON t1.id = t2.country_id` instead of joining through player position arrays. Do use `INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id` instead of checking all 22 player positions. Do group by `t1.name` instead of keeping the same grouping. Do order by `AVG(t3.weight) DESC` instead of ordering by the alias `average_weight DESC`. Do remove the explicit average column from SELECT instead of including it. The amended query now correctly focuses only on home_player_1 relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for country names: select only t1.name as the output column.\n2) When combining Country (t1) and Match (t2) tables: link rows where t1.id equals t2.country_id using an inner match.\n3) When combining Match (t2) and Player (t3) tables: link rows where t2.home_player_1 equals t3.player_api_id using an inner match.\n4) When computing average weights per country: group the results by t1.name.\n5) When ranking countries by average weight: order the results by AVG(t3.weight) in descending order.\n6) When finding the country with the heaviest average weight: keep only the top result (limit 1).\n7) When the question asks for average weights: do not include the average column in the final output selection.\nOutput columns (ordered): t1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name AS country_name, AVG(p.weight) AS average_weight\nFROM Player p\nJOIN Match m ON p.player_api_id IN (\n    m.home_player_1, m.home_player_2, m.home_player_3, m.home_player_4, m.home_player_5,\n    m.home_player_6, m.home_player_7, m.home_player_8, m.home_player_9, m.home_player_10, m.home_player_11,\n    m.away_player_1, m.away_player_2, m.away_player_3, m.away_player_4, m.away_player_5,\n    m.away_player_6, m.away_player_7, m.away_player_8, m.away_player_9, m.away_player_10, m.away_player_11\n)\nJOIN Country c ON m.country_id = c.id\nGROUP BY c.name\nORDER BY average_weight DESC\nLIMIT 1;",
            "SELECT t1.name\nFROM Country AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.country_id\nINNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id\nGROUP BY t1.name\nORDER BY AVG(t3.weight) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.name\nFROM Country t1\nINNER JOIN Match t2 ON t1.id = t2.country_id\nINNER JOIN Player t3 ON t2.home_player_1 = t3.player_api_id\nGROUP BY t1.name\nORDER BY AVG(t3.weight) DESC\nLIMIT 1"
        ]
    },
    "1011": {
        "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
        "db_id": "formula_1",
        "ground_truth": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
        "amends": [
            "Do add a CTE `lap_times_in_seconds` to convert time format instead of using raw `time` column directly. Do use `CASE` expressions with `SUBSTR` and `INSTR` to parse minutes, seconds, and milliseconds instead of treating time as a simple string. Do calculate `MIN(time_in_seconds)` per driver with `GROUP BY driverId` instead of selecting individual lap times. Do join the aggregated minimum times with drivers instead of joining raw lap times. Do select `forename` and `surname` as separate columns instead of concatenating them as `full_name`. Do order by `min_time_in_seconds` instead of raw `time` to ensure proper numerical ordering. The amended query now correctly finds each driver's fastest lap time by converting to seconds and aggregating, matching the intended behavior.",
            "Do handle empty string cases in the time conversion with separate CASE statements checking `SUBSTR(...) <> ''` instead of assuming non-empty substrings. Do restructure the query to use a subquery `T1` that first calculates `MIN(time_in_seconds)` grouped by `driverId` instead of grouping in the main query. Do join the aggregated results with `drivers AS T2` using `INNER JOIN` instead of joining before aggregation. Do include `T1.driverId` in the SELECT list instead of omitting it. Do reference columns with table aliases `T1.min_time_in_seconds` and `T2.forename`, `T2.surname` instead of unqualified column names. The amended query now correctly handles edge cases in time parsing and properly aggregates lap times before joining with driver information, matching the RIGHT_SQL's behavior.",
            "Do add proper NULL handling in the time conversion CASE expression by checking for empty substrings with `<> ''` conditions instead of omitting them, which prevents conversion errors when time components are missing. Do remove the `WHERE time IS NOT NULL AND time <> ''` filter from the CTE instead of keeping it, as the RIGHT_SQL handles empty values through the CASE expression. Do change the SELECT list order to `T2.forename, T2.surname, T1.driverId` instead of `T1.driverId, T2.forename, T2.surname`, and do remove the explicit `T1.min_time_in_seconds` column from the final SELECT instead of including it since it's only used for ordering. The amended query now correctly handles edge cases in time parsing and matches RIGHT_SQL's behavior.",
            "Do remove the NULL handling condition `WHEN time IS NULL OR time = '' THEN NULL` from the CASE expression instead of keeping it, as the RIGHT_SQL assumes valid time data. Do change the time conversion logic to handle milliseconds by adding `CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END` instead of the simpler second-only conversion. Do add `T1.driverId` to the SELECT list instead of omitting it. Do remove the `WHERE time_in_seconds IS NOT NULL` filter from the aggregation subquery instead of keeping it, as the GROUP BY will naturally handle NULL values. The amended query now correctly handles millisecond precision in lap time conversion and includes the driverId in the final output while maintaining the same ranking logic."
        ],
        "rules": [
            "1) When the question asks for \"top 20\" drivers by lap time performance: rank drivers by their minimum lap time in ascending order and keep the first 20 rows.\n2) When handling time data in minutes:seconds.milliseconds format: convert to total seconds using exact parsing of minutes, seconds, and milliseconds components.\n3) When calculating fastest lap time per driver: compute the minimum converted time value for each driver using their canonical key (driverId).\n4) When combining lap time data with driver information: link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match).\n5) When outputting driver names: return forename and surname as separate columns instead of concatenating them.\n6) When ordering by lap time performance: use the converted numerical time value (seconds) instead of the raw string format for proper ordering.\nOutput columns (ordered): T2.forename, T2.surname, min_time_in_seconds",
            "1) When converting time strings with colons and decimal points: handle empty substring cases by checking if SUBSTR(...) <> '' before casting to avoid conversion errors.\n2) When finding minimum lap times per driver: first calculate MIN(time_in_seconds) grouped by driverId in a subquery before joining with driver information.\n3) When joining aggregated lap time results with driver details: use INNER JOIN between the aggregated subquery (T1) and drivers table (T2) on T1.driverId = T2.driverId.\n4) When selecting driver information with aggregated lap times: include T1.driverId in the output columns along with T2.forename and T2.surname.\n5) When referencing columns from joined tables: use qualified column names with table aliases (T1.min_time_in_seconds, T2.forename, T2.surname) instead of unqualified column names.\n6) When ranking drivers by shortest lap time: order results by T1.min_time_in_seconds in ascending order and keep the top 20 rows.\nOutput columns (ordered): T1.driverId, T2.forename, T2.surname, T1.min_time_in_seconds",
            "1) When converting time values that may contain colons or decimal points: handle empty substrings by checking for `<> ''` conditions to prevent conversion errors instead of omitting them.\n2) When the question asks for \"top 20\" drivers by shortest lap time: rank rows by lap time in ascending order and keep the first 20 rows.\n3) When joining driver information with lap time data: link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match).\n4) When the question asks for driver \"full names\": output T2.forename and T2.surname instead of driverId or time values.\n5) When ordering by lap time: use the minimum lap time per driver (T1.min_time_in_seconds) for ranking but do not include it in the final output.\nOutput columns (ordered): T2.forename, T2.surname, T1.driverId",
            "1) When converting lap time strings to seconds: handle milliseconds by adding the millisecond component divided by 1000 to the minute and second components, using exact string parsing logic with SUBSTR and INSTR functions.\n2) When computing minimum lap times per driver: do not filter out NULL time values before aggregation, as GROUP BY naturally handles them.\n3) When joining driver information: link rows where T1.driverId equals T2.driverId to get driver names.\n4) When ranking drivers by shortest lap time: order by T1.min_time_in_seconds in ascending order and keep the top 20 rows.\n5) When selecting output columns: include both T2.forename and T2.surname to provide full driver names.\nOutput columns (ordered): T2.forename, T2.surname"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name, lt.time\nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nORDER BY lt.time ASC\nLIMIT 20;",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        driverId,\n        CASE \n            WHEN INSTR(time, ':') > 0 THEN\n                CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n                CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n            ELSE\n                CAST(time AS REAL)\n        END AS time_in_seconds\n    FROM lapTimes\n)\nSELECT \n    d.forename,\n    d.surname,\n    MIN(lts.time_in_seconds) AS min_time_in_seconds\nFROM \n    drivers d\nJOIN \n    lap_times_in_seconds lts ON d.driverId = lts.driverId\nGROUP BY \n    d.driverId\nORDER BY \n    min_time_in_seconds ASC\nLIMIT 20;",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        driverId,\n        CASE \n            WHEN INSTR(time, ':') > 0 THEN\n                CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) + \n                CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n            WHEN INSTR(time, '.') > 0 THEN\n                CAST(SUBSTR(time, 1, INSTR(time, '.') - 1) AS REAL) + \n                CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n            ELSE\n                CAST(time AS REAL)\n        END AS time_in_seconds\n    FROM lapTimes\n    WHERE time IS NOT NULL AND time <> ''\n),\nT1 AS (\n    SELECT \n        driverId,\n        MIN(time_in_seconds) AS min_time_in_seconds\n    FROM lap_times_in_seconds\n    GROUP BY driverId\n)\nSELECT \n    T1.driverId,\n    T2.forename,\n    T2.surname,\n    T1.min_time_in_seconds\nFROM T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nORDER BY T1.min_time_in_seconds ASC\nLIMIT 20;",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        driverId,\n        CASE \n            WHEN time IS NULL OR time = '' THEN NULL\n            WHEN INSTR(time, ':') = 0 THEN CAST(time AS REAL)\n            ELSE \n                CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END +\n                CASE WHEN SUBSTR(time, INSTR(time, ':') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1) AS REAL) ELSE 0 END\n        END AS time_in_seconds\n    FROM lapTimes\n),\nT1 AS (\n    SELECT \n        driverId,\n        MIN(time_in_seconds) AS min_time_in_seconds\n    FROM lap_times_in_seconds\n    WHERE time_in_seconds IS NOT NULL\n    GROUP BY driverId\n)\nSELECT \n    T2.forename,\n    T2.surname\nFROM T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nORDER BY T1.min_time_in_seconds ASC\nLIMIT 20",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        raceId,\n        driverId,\n        lap,\n        CASE\n            WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60\n            ELSE 0\n        END +\n        CASE\n            WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)\n            ELSE 0\n        END +\n        CASE\n            WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n            ELSE 0\n        END AS time_in_seconds\n    FROM lapTimes\n),\nT1 AS (\n    SELECT \n        driverId,\n        MIN(time_in_seconds) AS min_time_in_seconds\n    FROM lap_times_in_seconds\n    GROUP BY driverId\n)\nSELECT \n    T2.forename,\n    T2.surname,\n    T1.driverId\nFROM T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nORDER BY T1.min_time_in_seconds ASC\nLIMIT 20"
        ],
        "rule_sql": [
            "SELECT \n    d.forename, \n    d.surname\nFROM \n    drivers d\nINNER JOIN (\n    SELECT \n        driverId,\n        MIN(\n            CASE \n                WHEN time LIKE '%:%:%' THEN\n                    CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n                    CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) + \n                    CAST(SUBSTR(time, INSTR(time, ':', INSTR(time, ':') + 1) + 1) AS REAL) / 1000\n                WHEN time LIKE '%:%' THEN\n                    CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n                    CAST(SUBSTR(time, INSTR(time, ':') + 1) AS REAL)\n                ELSE\n                    CAST(time AS REAL)\n            END\n        ) AS min_time_in_seconds\n    FROM \n        lapTimes\n    WHERE \n        time IS NOT NULL AND time != ''\n    GROUP BY \n        driverId\n) lt ON d.driverId = lt.driverId\nORDER BY \n    lt.min_time_in_seconds ASC\nLIMIT 20"
        ]
    },
    "714": {
        "question": "List the comments commented by the user with a username of Harvey Motulsky.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky'",
        "amends": [
            "Do select only `T1.Text` instead of including `c.Id` and `c.CreationDate`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `c` and `u`. Do maintain the same join condition `T1.UserId = T2.Id` instead of changing it. Do keep the same WHERE filter `T2.DisplayName = 'Harvey Motulsky'` instead of modifying it. The amended query now correctly returns only comment text for the specified user, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for comments by a specific username: filter users where T2.DisplayName equals exactly 'Harvey Motulsky'. 2) When combining comments and users tables: link rows where T1.UserId equals T2.Id and keep only matching pairs (inner match). 3) When selecting output for comment-related queries: include only T1.Text instead of additional columns like T1.Id or T1.CreationDate. 4) When using table aliases: use T1 for comments table and T2 for users table consistently. Output columns (ordered): T1.Text"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Id, c.Text, c.CreationDate\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE u.DisplayName = 'Harvey Motulsky';",
            "SELECT T1.Text FROM comments T1 INNER JOIN users T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky'"
        ],
        "rule_sql": [
            "SELECT T1.Text \nFROM comments T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T2.DisplayName = 'Harvey Motulsky'"
        ]
    },
    "1191": {
        "question": "What percentage of male patients who first presented to the hospital in 1981 were diagnosed with BEHCET?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE STRFTIME('%Y', `First Date`) = '1981' AND SEX = 'M'",
        "amends": [],
        "rules": [
            "male refers to SEX = 'M'; first presented to the hospital in 1981 refers to YEAR(`FIRST DATE`) = '1981'; BEHCET refers to diagnosis; calculation = DIVIDE(SUM(DIAGNOSIS = 'BEHCET') where YEAR(`FIRST DATE`) = '1981', MULTIPLY(COUNT(YEAR(`FIRST DATE`) = '1981')), 100)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN p.Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient p\nWHERE \n    p.SEX = 'M' AND \n    strftime('%Y', p.`First Date`) = '1981';"
        ],
        "rule_sql": []
    },
    "577": {
        "question": "Write all comments made by user 'A Lion.'",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Text FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'A Lion'",
        "amends": [],
        "rules": [
            "\"A Lion\" is the DisplayName of user; comment refers to Text"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Text FROM comments c JOIN users u ON c.UserId = u.Id WHERE u.DisplayName = 'A Lion';"
        ],
        "rule_sql": []
    },
    "208": {
        "question": "Which type of label is the most numerous in atoms with hydrogen?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t",
        "amends": [
            "Do use a subquery with explicit table aliases `T1` and `T2` instead of direct table references. Do select only `T.label` in the outer query instead of both `m.label` and `COUNT(*) AS count`. Do use `COUNT(T2.molecule_id)` instead of `COUNT(*)` to count specific non-null values. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do wrap the entire grouped query in a subquery and alias it as `t` instead of selecting directly from the grouped result. Do reference the count column in `ORDER BY` as `COUNT(T2.molecule_id)` instead of the alias `count`. The amended query now correctly returns only the label of the molecule with the highest hydrogen atom count.",
            "Do include `T2.label` in the SELECT list and GROUP BY clause instead of omitting it from the subquery. Do change the WHERE filter to use lowercase `'h'` instead of uppercase `'H'` for the element comparison. Do remove the unnecessary outer query and join with the molecule table instead of keeping the redundant structure. Do move the ORDER BY and LIMIT clauses inside the subquery instead of placing them in the outer query. Do change the aggregate function to count `T2.molecule_id` directly instead of using an alias that references the wrong table. The amended query now correctly counts hydrogen atoms per molecule label and returns the label with the highest count, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the most numerous type of label in atoms with hydrogen: use a subquery with table aliases T1 for molecule and T2 for atom. 2) When counting hydrogen atoms: filter T2 where T2.element equals 'h' exactly. 3) When counting molecules with hydrogen atoms: use COUNT(T2.molecule_id) to count specific non-null values instead of COUNT(*). 4) When combining molecule and atom tables: use INNER JOIN where T1.molecule_id = T2.molecule_id to link matching pairs. 5) When grouping results: organize by T1.label to compute aggregates per label type. 6) When ordering for highest count: sort by COUNT(T2.molecule_id) in descending order. 7) When selecting the top result: take only the first row after ordering. 8) When outputting final results: select only T1.label from the grouped subquery. 9) Output columns (ordered): T1.label",
            "1) When the question asks for \"most numerous\" type of label in atoms with hydrogen: rank rows by hydrogen count in descending order and keep the first 1 row.\n2) When counting hydrogen atoms per molecule label: compute the number of rows using T2.molecule_id as the counting key.\n3) When filtering for hydrogen atoms: include only rows where T1.element equals exactly 'h' (lowercase).\n4) When grouping by molecule label: organize results by T2.label and compute aggregates per group.\n5) When combining atom (T1) and molecule (T2) tables: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match).\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.\n7) When handling text literals: do not change case, spacing, or punctuation from the exact value 'h'.\nOutput columns (ordered): T2.label"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.label, COUNT(*) AS count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'h'\nGROUP BY m.label\nORDER BY count DESC\nLIMIT 1;",
            "SELECT T.label\nFROM (\n    SELECT T1.molecule_id, COUNT(T2.molecule_id) AS hydrogen_count\n    FROM atom AS T1\n    INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T1.element = 'H'\n    GROUP BY T1.molecule_id\n) AS t\nINNER JOIN molecule AS T ON t.molecule_id = T.molecule_id\nORDER BY hydrogen_count DESC\nLIMIT 1",
            "SELECT T.label\nFROM (\n    SELECT T2.label, COUNT(T2.molecule_id) AS count\n    FROM atom T1\n    INNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T1.element = 'h'\n    GROUP BY T2.label\n    ORDER BY COUNT(T2.molecule_id) DESC\n    LIMIT 1\n) t"
        ],
        "rule_sql": [
            "SELECT T1.label\nFROM molecule T1\nINNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.element = 'h'\nGROUP BY T1.label\nORDER BY COUNT(T2.molecule_id) DESC\nLIMIT 1"
        ]
    },
    "632": {
        "question": "How many votes were made by Harlan?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId WHERE T1.DisplayName = 'Harlan'",
        "amends": [
            "Do add table joins with `users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId` instead of querying only the `votes` table. Do change the WHERE condition to filter on `T1.DisplayName = 'Harlan'` instead of using a subquery with `UserId = (SELECT Id FROM users WHERE DisplayName = 'Harlan')`. Do count `T1.Id` instead of counting all rows with `COUNT(*)`. Do remove the alias `AS vote_count` instead of keeping it. The amended query now correctly joins the necessary tables to count votes associated with the user 'Harlan' through their post history relationships."
        ],
        "rules": [
            "1) When the question asks for votes made by a specific user: join users as T1, postHistory as T2, and votes as T3 where T1.Id = T2.UserId and T3.PostId = T2.PostId to establish the relationship between users and their votes through post history.\n2) When filtering for a user with exact display name 'Harlan': use the condition T1.DisplayName = 'Harlan' with exact case and spelling.\n3) When counting votes for a user: count the user's canonical key T1.Id instead of counting all rows.\n4) When producing output: do not include column aliases like vote_count unless explicitly required.\nOutput columns (ordered): COUNT(T1.Id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS vote_count\nFROM votes\nWHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'Harlan');",
            "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId WHERE T1.DisplayName = 'Harlan'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nJOIN postHistory AS T2 ON T1.Id = T2.UserId \nJOIN votes AS T3 ON T3.PostId = T2.PostId \nWHERE T1.DisplayName = 'Harlan'"
        ]
    },
    "321": {
        "question": "What is the molecule of atom id \"TR000_2\" and atom id 2 \"TR000_4\"?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'",
        "amends": [
            "Do change the FROM clause to use `bond AS T1` and `connected AS T2` instead of `atom a1`, `atom a2`, and `molecule m`. Do use `INNER JOIN` on `T1.bond_id = T2.bond_id` instead of joining atoms on `molecule_id` and then joining to molecule. Do change the WHERE clause to filter on `T2.atom_id = 'TR000_2'` and `T2.atom_id2 = 'TR000_4'` instead of filtering on separate atom instances with the same atom_id values. Do remove the `m.label` column from the SELECT list instead of including it. Do remove the molecule table join entirely instead of keeping it. The amended query now correctly identifies bonds connecting the specified atoms rather than incorrectly finding molecules containing both atoms, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about atoms with specific IDs \"TR000_2\" and \"TR000_4\": use table bond as T1 and connected as T2 instead of atom and molecule tables.\n2) When combining tables T1 and T2: link rows where T1.bond_id = T2.bond_id using inner join.\n3) When filtering for atom ID \"TR000_2\": use condition T2.atom_id = 'TR000_2'.\n4) When filtering for atom ID \"TR000_4\": use condition T2.atom_id2 = 'TR000_4'.\n5) When selecting output columns: only include T1.molecule_id, not additional columns like m.label.\n6) When the question involves bonds connecting specific atoms: do not join with the molecule table.\nOutput columns (ordered): T1.molecule_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.molecule_id, m.label\nFROM atom a1\nJOIN atom a2 ON a1.molecule_id = a2.molecule_id\nJOIN molecule m ON a1.molecule_id = m.molecule_id\nWHERE a1.atom_id = 'TR000_2' AND a2.atom_id = 'TR000_4';",
            "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'"
        ],
        "rule_sql": [
            "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'"
        ]
    },
    "98": {
        "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
        "db_id": "financial",
        "ground_truth": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
        "amends": [
            "Do use a simple `SELECT T2.account_id` instead of selecting multiple columns `a.account_id, a.district_id, a.frequency, a.date`. Do remove the CTE structure entirely instead of using `WITH approved_loans_1997` and `min_loan_amount` subqueries. Do use a direct `INNER JOIN` between `loan AS T1` and `account AS T2` instead of joining through intermediate CTEs. Do move the `STRFTIME('%Y', T1.date) = '1997'` filter to the main `WHERE` clause instead of placing it in a CTE. Do add `ORDER BY T1.amount LIMIT 1` to find the minimum amount instead of using a separate CTE to calculate the minimum and then joining on it. Do remove the explicit `status = 'approved'` filter since it's not present in the correct query. The amended query now correctly identifies the single account with the smallest loan amount in 1997 with the specified frequency, matching the RIGHT_SQL's behavior.",
            "Do filter by frequency `POPLATEK TYDNE` instead of `weekly issuance statement` in the WHERE clause, which corrects the account selection criteria to match the intended business logic for the 1997 loan data analysis."
        ],
        "rules": [
            "1) When the question asks for accounts with approved loan date in 1997: filter loan records where the year extracted from T1.date equals '1997' exactly. 2) When finding the lowest approved amount: order loan records by T1.amount in ascending order and take only the first row. 3) When the question specifies accounts that choose weekly issuance statement: filter account records where T2.frequency equals 'POPLATEK TYDNE' exactly. 4) When combining loan and account information: link rows where T1.account_id equals T2.account_id exactly and keep only matching pairs. 5) Output columns (ordered): T2.account_id",
            "1) When filtering accounts by frequency for weekly issuance statements: use the exact literal 'POPLATEK TYDNE' instead of 'weekly issuance statement' in the condition. 2) When selecting accounts with approved loan date in 1997: filter by year 1997 using the exact date format shown in the amends. 3) When finding accounts with the lowest approved amount: order by the amount column in ascending order and take the first row. 4) When combining loan and account tables: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match). 5) Output columns (ordered): T2.account_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH approved_loans_1997 AS (\n    SELECT account_id, amount\n    FROM loan\n    WHERE strftime('%Y', date) = '1997' AND status = 'approved'\n),\nmin_loan_amount AS (\n    SELECT MIN(amount) AS min_amount\n    FROM approved_loans_1997\n)\nSELECT a.account_id, a.district_id, a.frequency, a.date\nFROM account a\nJOIN approved_loans_1997 al ON a.account_id = al.account_id\nJOIN min_loan_amount m ON al.amount = m.min_amount\nWHERE a.frequency = 'POPLATEK TYDNE';",
            "SELECT T2.account_id\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1997'\nAND T2.frequency = 'weekly issuance statement'\nORDER BY T1.amount\nLIMIT 1",
            "SELECT T2.account_id\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1997'\nAND T2.frequency = 'POPLATEK TYDNE'\nORDER BY T1.amount\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.account_id\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE strftime('%Y', T1.date) = '1997'\nAND T2.frequency = 'POPLATEK TYDNE'\nORDER BY T1.amount ASC\nLIMIT 1;"
        ]
    },
    "285": {
        "question": "Name chemical elements that form a bond TR001_10_11.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_id = 'TR001_10_11'",
        "amends": [
            "Do select only `T1.element` instead of selecting `a1.element` and `a2.element` with aliases. Do use `atom AS T1` instead of `atom a1` and remove the second atom table join. Do add `INNER JOIN bond AS T3` on `T2.bond_id = T3.bond_id` instead of omitting the bond table entirely. Do change the WHERE condition to filter on `T3.bond_id` instead of filtering directly on `c.bond_id`. Do remove the second atom table reference and its join condition instead of keeping the dual atom table structure. The amended query now correctly joins through the bond table to filter bond relationships and returns only the relevant element data, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for chemical elements that form a specific bond: filter on the exact bond identifier literal 'TR001_10_11' using the bond table.\n2) When joining the connected table (T2) with the atom table (T1): link rows where T2.atom_id equals T1.atom_id to get element information.\n3) When joining the connected table (T2) with the bond table (T3): link rows where T2.bond_id equals T3.bond_id to access bond properties.\n4) When selecting element information from atom relationships: output only T1.element instead of multiple element columns.\n5) When filtering by bond identifier: apply the filter condition on T3.bond_id rather than directly on the connected table's bond_id.\n6) When the schema requires accessing bond information: include the bond table (T3) through an inner join rather than filtering directly on the connected table.\nOutput columns (ordered): T1.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_10_11';",
            "SELECT DISTINCT T1.element \nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2\nINNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE T3.bond_id = 'TR001_10_11'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.element \nFROM connected T2 \nINNER JOIN atom T1 ON T2.atom_id = T1.atom_id \nINNER JOIN bond T3 ON T2.bond_id = T3.bond_id \nWHERE T3.bond_id = 'TR001_10_11'"
        ]
    },
    "1371": {
        "question": "How many members attended the \"Women's Soccer\" event?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
        "amends": [],
        "rules": [
            "'Women's Soccer' is the event name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT link_to_member) AS member_count\nFROM attendance\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = \"Women's Soccer\");"
        ],
        "rule_sql": []
    },
    "17": {
        "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
        "db_id": "california_schools",
        "ground_truth": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
        "amends": [
            "Do select `CharterNum`, `AvgScrWrite`, and `RANK() OVER (ORDER BY AvgScrWrite DESC)` instead of `s.sname`, `s.AvgScrWrite`, and `sc.CharterNum`. Do use `INNER JOIN` with `T1.CDSCode = T2.cds` instead of `JOIN` with `s.cds = sc.CDSCode`. Do add filter `CharterNum is not null` instead of omitting it. Do remove `ORDER BY s.AvgScrWrite DESC` instead of keeping it since the ranking function handles ordering. The amended query now correctly ranks writing scores while ensuring charter schools are properly identified and filtered."
        ],
        "rules": [
            "1) When ranking schools by average writing score: use RANK() OVER (ORDER BY AvgScrWrite DESC) to assign ranks based on descending AvgScrWrite values.\n2) When selecting columns for output: include CharterNum, AvgScrWrite, and the rank value instead of school names.\n3) When joining tables schools and satscores: use INNER JOIN with T1.CDSCode = T2.cds to link matching records between the tables.\n4) When filtering for charter schools: include condition CharterNum is not null to ensure only charter schools are considered.\n5) When filtering for writing scores: include condition AvgScrWrite > 499 to only include scores above 499.\n6) When handling ordering: do not use explicit ORDER BY clause since the ranking function handles the ordering internally.\nOutput columns (ordered): CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.sname, s.AvgScrWrite, sc.CharterNum\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE s.AvgScrWrite > 499\nORDER BY s.AvgScrWrite DESC;",
            "SELECT \n    sc.CharterNum,\n    s.AvgScrWrite,\n    RANK() OVER (ORDER BY s.AvgScrWrite DESC) as ranking\nFROM \n    satscores s\nINNER JOIN \n    schools sc ON s.cds = sc.CDSCode\nWHERE \n    s.AvgScrWrite > 499\n    AND sc.CharterNum IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT \n    s.CharterNum, \n    sat.AvgScrWrite, \n    RANK() OVER (ORDER BY sat.AvgScrWrite DESC) as rank\nFROM \n    schools s\nINNER JOIN \n    satscores sat ON s.CDSCode = sat.cds\nWHERE \n    sat.AvgScrWrite > 499 \n    AND s.CharterNum IS NOT NULL"
        ]
    },
    "1530": {
        "question": "Which are the top five best selling products? Please state the full name of them.",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.Amount DESC LIMIT 5",
        "amends": [
            "Do select only `T2.Description` instead of selecting both `p.Description` and `SUM(t.Amount)`. Do remove the `GROUP BY` clause and aggregation instead of grouping by `t.ProductID, p.Description`. Do use `INNER JOIN` with explicit `AS` aliases `T1` and `T2` instead of simple `JOIN` with aliases `t` and `p`. Do order by `T1.Amount DESC` instead of ordering by the aggregated `TotalAmount DESC`. The amended query now correctly returns individual product descriptions ordered by transaction amount rather than aggregated totals."
        ],
        "rules": [
            "1) When the question asks for \"top five best selling products\" and requests \"full name\": select only the exact column T2.Description as the output. 2) When combining tables for product information: link rows where T1.ProductID = T2.ProductID using an inner match and keep only matching pairs. 3) When ordering results to find \"top\" products: sort all rows by T1.Amount in descending order. 4) When limiting to the top five results: keep only the first 5 rows after ordering. 5) When the question asks for product names without aggregation: do not group rows or compute sums, instead process individual transaction records. Output columns (ordered): T2.Description"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Description, SUM(t.Amount) AS TotalAmount\nFROM transactions_1k t\nJOIN products p ON t.ProductID = p.ProductID\nGROUP BY t.ProductID, p.Description\nORDER BY TotalAmount DESC\nLIMIT 5;",
            "SELECT T2.Description \nFROM transactions_1k AS T1 \nINNER JOIN products AS T2 ON T1.ProductID = T2.ProductID \nORDER BY T1.Amount DESC \nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT T2.Description\nFROM transactions_1k T1\nINNER JOIN products T2 ON T1.ProductID = T2.ProductID\nORDER BY T1.Amount DESC\nLIMIT 5"
        ]
    },
    "1217": {
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "amends": [
            "Do use `CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5` instead of `CASE WHEN L.ALB BETWEEN 3.5 AND 5.5` to explicitly define the inclusive range boundaries. Do return 'normal' and 'abnormal' instead of 'Within Normal Range' and 'Outside Normal Range' for the albumin status labels. Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do reference `T2.ALB` instead of `L.ALB` and use table aliases `T1` and `T2` instead of `P` and `L` throughout the query. Do remove the `P.ID` column from the SELECT list instead of including it, focusing only on the albumin status result. The amended query now correctly identifies albumin test results within the specified range for patients born in 1982."
        ],
        "rules": [
            "1) When the question asks about patients born in a specific year: filter rows where the year component of T1.Birthday equals '1982' exactly. 2) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID using an inner match. 3) When checking if albumin values are within normal range: use the condition T2.ALB >= 3.5 AND T2.ALB <= 5.5 to define the inclusive range boundaries. 4) When categorizing albumin status: return 'normal' for values within the range and 'abnormal' for values outside the range. 5) When the question asks to state albumin status for patients: output only the albumin status result without including patient identifiers. Output columns (ordered): AlbuminStatus"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    P.ID,\n    CASE \n        WHEN L.ALB BETWEEN 3.5 AND 5.5 THEN 'Within Normal Range'\n        ELSE 'Outside Normal Range'\n    END AS AlbuminStatus\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    strftime('%Y', P.Birthday) = '1982';\n",
            "SELECT \n    CASE \n        WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal'\n        ELSE 'abnormal'\n    END AS albumin_status\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    strftime('%Y', T1.Birthday) = '1982';"
        ],
        "rule_sql": [
            "SELECT \n    CASE \n        WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' \n        ELSE 'abnormal' \n    END AS AlbuminStatus\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    strftime('%Y', T1.Birthday) = '1982'"
        ]
    },
    "242": {
        "question": "Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25' AND T2.label = '+'",
        "amends": [
            "Do reference `molecule_id` from `T2` instead of `m` in the SELECT list. Do use table aliases `T1` for `atom` and `T2` for `molecule` instead of `a` and `m`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do change the SUBSTR function to extract from the end using `SUBSTR(T1.atom_id, -2)` instead of `SUBSTR(a.atom_id, 7, 2)` to correctly capture the last two characters. Do remove the `m.label` column from the SELECT list instead of including it, as only `molecule_id` is needed. Do keep the DISTINCT modifier, WHERE filters on the atom_id substring range and label value, and the join condition unchanged as they serve the same logical purpose. The amended query now correctly identifies molecules based on atom_id suffixes rather than fixed positions, matching the RIGHT_SQL's behavior.",
            "Do remove the `CAST(... AS INTEGER)` around `SUBSTR(T1.atom_id, -2)` instead of casting to integer, and do change the string comparison to use `BETWEEN '21' AND '25'` instead of numeric comparison. Do change the `WHERE` filter on `T2.label` to `= '+'` instead of `= 'carcinogenic'`. The amended query now correctly handles string comparison for the atom_id substring and uses the proper label filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for molecules with atoms from 21 to 25: filter rows where the last two characters of T1.atom_id are between '21' and '25' inclusive. 2) When the question specifies carcinogenic molecules: filter rows where T2.label equals '+'. 3) When combining T1 (atom) and T2 (molecule) tables: link rows where T1.molecule_id equals T2.molecule_id and keep only matching pairs (inner match). 4) When the question asks for distinct molecules: return only unique values of T2.molecule_id. 5) Output columns (ordered): T2.molecule_id",
            "1) When extracting the last two characters from T1.atom_id: use SUBSTR(T1.atom_id, -2) without casting to integer.\n2) When comparing the extracted atom_id substring: use string comparison BETWEEN '21' AND '25' instead of numeric comparison.\n3) When filtering for carcinogenic molecules: use T2.label = '+' instead of 'carcinogenic'.\n4) When joining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match).\n5) When selecting distinct molecules: return unique T2.molecule_id values.\nOutput columns (ordered): T2.molecule_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE SUBSTR(a.atom_id, 7, 2) BETWEEN '21' AND '25'\nAND m.label = '+';",
            "SELECT DISTINCT T2.molecule_id\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE CAST(SUBSTR(T1.atom_id, -2) AS INTEGER) BETWEEN 21 AND 25\nAND T2.label = 'carcinogenic';",
            "SELECT DISTINCT T2.molecule_id\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25'\nAND T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.molecule_id\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25'\nAND T2.label = '+';"
        ]
    },
    "1360": {
        "question": "What percentage was the budget for Parking to the total budget for the \"November Speaker\"?",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Speaker'",
        "amends": [],
        "rules": [
            "DIVDE(SUM( amount where category = 'Parking' and event_name = 'November Speaker'), COUNT(event_name = 'November Speaker)) * 100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (b1.amount * 100.0 / SUM(b2.amount)) AS percentage\nFROM \n    event e\nJOIN \n    budget b1 ON e.event_id = b1.link_to_event\nJOIN \n    budget b2 ON e.event_id = b2.link_to_event\nWHERE \n    e.event_name = 'November Speaker' AND b1.category = 'Parking'\nGROUP BY \n    b1.amount;"
        ],
        "rule_sql": []
    },
    "215": {
        "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
        "amends": [
            "Do use `COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END)` and `COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END)` as separate columns instead of a single `COUNT(DISTINCT a.atom_id)` aggregate. Do join `connected AS T2` on `T1.atom_id = T2.atom_id` instead of omitting this table. Do join `bond AS T3` on `T2.bond_id = T3.bond_id` instead of joining directly on `a.molecule_id = b.molecule_id`. Do remove the filter `a.element IN ('i', 's')` from the WHERE clause instead of keeping it, as the element filtering is now handled in the CASE expressions. Do keep `T3.bond_type = '-'` in the WHERE clause instead of changing it. The amended query now correctly counts iodine and sulfur atoms separately through connected bonds rather than counting all atoms in molecules with single bonds."
        ],
        "rules": [
            "1) When counting atoms with specific element types separately: use COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) for iodine atoms and COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) for sulfur atoms as separate columns instead of a single aggregate count.\n2) When connecting atoms to bonds: join connected AS T2 on T1.atom_id = T2.atom_id to establish the relationship between atoms and their connections.\n3) When accessing bond information: join bond AS T3 on T2.bond_id = T3.bond_id to get bond details through the connected table rather than directly joining on molecule_id.\n4) When filtering for single bonds: keep T3.bond_type = '-' in the WHERE clause to filter for single bond molecules.\n5) When handling element filtering: remove direct element filtering from the WHERE clause since element-specific counting is handled through CASE expressions.\n6) Output columns (ordered): COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END), COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.atom_id) AS total_atoms\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.element IN ('i', 's') AND b.bond_type = '-';",
            "SELECT \n    COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_atoms,\n    COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_atoms\nFROM \n    atom AS T1\nJOIN \n    connected AS T2 ON T1.atom_id = T2.atom_id\nJOIN \n    bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE \n    T3.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT \n    COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_atoms,\n    COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_atoms\nFROM \n    atom AS T1\nJOIN \n    connected AS T2 ON T1.atom_id = T2.atom_id\nJOIN \n    bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE \n    T3.bond_type = '-'"
        ]
    },
    "1097": {
        "question": "What is Aaron Lennox's total crossing score?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT SUM(t2.crossing) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Lennox'",
        "amends": [],
        "rules": [
            "Aaron Lennox's refers to T2.player_name = 'Aaron Lennox'; total crossing score refers to SUM(crossing)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(pa.crossing) AS total_crossing_score\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Aaron Lennox';"
        ],
        "rule_sql": []
    },
    "1165": {
        "question": "What is the age gap between the youngest and oldest patient with a normal triglyceride recorded?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT STRFTIME('%Y', MAX(T1.Birthday)) - STRFTIME('%Y', MIN(T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200",
        "amends": [],
        "rules": [
            "age gap refers to SUBTRACT(MAX(year(Birthday)) - MIN(year(Birthday))); normal triglyceride refers to tg > = 200"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(strftime('%Y', Birthday)) - MIN(strftime('%Y', Birthday)) AS age_gap\nFROM Patient\nWHERE ID IN (SELECT DISTINCT ID FROM Laboratory WHERE TG >= 200);"
        ],
        "rule_sql": []
    },
    "235": {
        "question": "How many molecules are carcinogenic and have the bromine element?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'br'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; have bromine element refers to element = 'br'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '+' AND a.element = 'br';"
        ],
        "rule_sql": []
    },
    "980": {
        "question": "List the reference name of the drivers who passed the second qualifying lap during race no. 23. Indicate their nationality and birthday.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.driverRef, T2.nationality, T2.dob FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T1.raceId = 23 AND T1.q2 IS NOT NULL",
        "amends": [],
        "rules": [
            "passed the second qualifying lap refers to q2 is not null; birthday refers to dob; reference name of drivers refers to driverRef; race no. refers to raceId;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverRef, d.nationality, d.dob\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 23 AND q.q2 IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1401": {
        "question": "Indicate the cost of posters for 'September Speaker' event.",
        "db_id": "student_club",
        "ground_truth": "SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Posters'",
        "amends": [],
        "rules": [
            "'Posters' is the expense description; 'September Speaker' is an event name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.cost\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'September Speaker' AND (b.category = 'posters' OR e.expense_description LIKE '%posters%');"
        ],
        "rule_sql": []
    },
    "876": {
        "question": "For the race happened in 2015/11/29, how many drivers did not finish the game?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NULL",
        "amends": [],
        "rules": [
            "game and race are synonyms; drivers who didn't finish the race should have record in time;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS drivers_not_finished\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN status s ON r.statusId = s.statusId\nWHERE rc.date = '2015-11-29' AND s.status != 'Finished';"
        ],
        "rule_sql": []
    },
    "269": {
        "question": "How many bond id have element iodine?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T3.bond_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T1.element = 'i'",
        "amends": [
            "Do use `COUNT(T3.bond_id)` without `DISTINCT` instead of `COUNT(DISTINCT c.bond_id)` to count all bonds rather than unique ones. Do join `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of omitting the molecule table entirely. Do use `INNER JOIN bond AS T3` on `T2.molecule_id = T3.molecule_id` instead of joining `connected c` with complex `OR` conditions `c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id`. Do filter on `T1.element = 'i'` instead of `a.element = 'i'` while maintaining the same element condition. The amended query now correctly counts bonds in molecules containing iodine atoms by properly traversing the molecule hierarchy rather than using a potentially incorrect connection-based approach."
        ],
        "rules": [
            "1) When the question asks for \"bond id\" count: use COUNT(T3.bond_id) to count all bond_id values rather than unique ones. 2) When joining tables for molecules and bonds: link T1 (atom) to T2 (molecule) using T1.molecule_id = T2.molecule_id and T2 to T3 (bond) using T2.molecule_id = T3.molecule_id, keeping only matching pairs (inner match). 3) When filtering for element iodine: use T1.element = 'i' exactly as specified, preserving the lowercase 'i' literal. 4) When the schema shows identifiers without quotes: use unquoted identifiers like T1.molecule_id, T2.molecule_id, and T3.bond_id. 5) Output columns (ordered): COUNT(T3.bond_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.bond_id) \nFROM connected c \nJOIN atom a ON c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id \nWHERE a.element = 'i';",
            "SELECT COUNT(T3.bond_id) \nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T1.element = 'i'"
        ],
        "rule_sql": [
            "SELECT COUNT(T3.bond_id) \nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nJOIN bond T3 ON T2.molecule_id = T3.molecule_id\nWHERE T1.element = 'i'"
        ]
    },
    "1032": {
        "question": "Give the name of the league with the highest matches of all time and how many matches were played in the said league.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.name, t1.max_count FROM League AS t2 JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery) AS t1 ON t1.league_id = t2.id",
        "amends": [
            "Do select `t2.name` and `t1.max_count` instead of `l.name` and `COUNT(m.league_id)`. Do use a subquery to calculate the maximum match count per league instead of counting matches directly. Do join the League table with a derived table containing the maximum count instead of joining directly with Match. Do include a subquery that first counts matches by `league_id` and then finds the maximum count instead of grouping by `league_id` directly. Do remove the `ORDER BY` and `LIMIT 1` clauses instead of keeping them, as the maximum value is now calculated through aggregation. The amended query now correctly identifies the league with the maximum match count by using proper aggregation techniques instead of relying on ordering and limiting.",
            "Do use `MAX(cnt)` in the outer subquery instead of selecting `MAX(match_count)` from a separate subquery. Do join directly on `t1.league_id = t2.id` instead of matching `league_counts.match_count = t1.max_count`. Do remove the redundant intermediate subquery that calculates maximum match count separately instead of keeping it. Do reference `COUNT(id)` as `cnt` instead of `COUNT(*) AS match_count` in the innermost subquery. Do eliminate the unnecessary join condition based on match count equality instead of preserving it. The amended query now correctly identifies leagues with their maximum match counts by joining directly on league_id rather than attempting to match count values across different aggregation levels."
        ],
        "rules": [
            "1) When the question asks for the league with the highest matches: calculate the maximum count of matches per league using a subquery that counts matches by league_id. 2) When counting matches per league: use the league_id as the counting key for matches. 3) When finding the maximum value from aggregated counts: use the MAX() function on the match counts instead of ordering and limiting. 4) When joining the League table with aggregated match counts: link them where the league_id matches between the derived table and League table. 5) When selecting output columns: include both the league name and the maximum match count value. Output columns (ordered): t2.name, t1.max_count",
            "1) When counting matches per league: count the number of rows using the canonical key \"id\" from the Match table and name the result \"cnt\".\n2) When finding the maximum count across all leagues: compute the maximum value of the count result \"cnt\" from the grouped results.\n3) When joining league information with match counts: link rows where the league identifier \"league_id\" from Match equals the league identifier \"id\" from League.\n4) When the question asks for the league with the highest matches: select the league name and the maximum count value where the league's match count equals the maximum count across all leagues.\n5) Output columns (ordered): t2.name, MAX(cnt)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.name AS league_name, COUNT(m.league_id) AS match_count\nFROM Match m\nJOIN League l ON m.league_id = l.id\nGROUP BY m.league_id\nORDER BY match_count DESC\nLIMIT 1;",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(*) AS match_count\n    FROM Match\n    GROUP BY league_id\n) AS league_counts\nJOIN (\n    SELECT MAX(match_count) AS max_count\n    FROM (\n        SELECT league_id, COUNT(*) AS match_count\n        FROM Match\n        GROUP BY league_id\n    )\n) AS t1 ON league_counts.match_count = t1.max_count\nJOIN League AS t2 ON league_counts.league_id = t2.id",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, MAX(cnt) AS max_count\n    FROM (\n        SELECT league_id, COUNT(id) AS cnt\n        FROM Match\n        GROUP BY league_id\n    )\n) t1\nJOIN League t2 ON t1.league_id = t2.id"
        ],
        "rule_sql": [
            "SELECT t2.name, MAX(cnt) AS max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = (SELECT MAX(cnt) FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id))"
        ]
    },
    "1323": {
        "question": "List all the names of events that had an attendance of over 20 students but were not fundraisers.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id HAVING COUNT(T2.link_to_event) > 20 EXCEPT SELECT T1.event_name FROM event AS T1  WHERE T1.type = 'Fundraiser'",
        "amends": [],
        "rules": [
            "name of events refers to event_name; attendance of over 20 students COUNT(event_id) > 20."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nWHERE e.type != 'fundraiser'\nGROUP BY e.event_id\nHAVING COUNT(a.link_to_member) > 20;"
        ],
        "rule_sql": []
    },
    "1062": {
        "question": "Which players had an overall rating of over 80 from 2008 to 2010? Please list player names.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating > 80 AND SUBSTR(t2.`date`, 1, 4) BETWEEN '2008' AND '2010'",
        "amends": [],
        "rules": [
            "overall_rating > 80; from 2008 to 2010 refers to strftime('%Y', date) BETWEEN '2008' AND '2010';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating > 80\nAND pa.date BETWEEN '2008-01-01' AND '2010-12-31';\n"
        ],
        "rule_sql": []
    },
    "1428": {
        "question": "List the city and state of members enrolled under electrical and computer engineering department.",
        "db_id": "student_club",
        "ground_truth": "SELECT city, state FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN zip_code AS T3 ON T3.zip_code = T1.zip WHERE department = 'Electrical and Computer Engineering Department' AND position = 'Member'",
        "amends": [],
        "rules": [
            "'Electrical and Computer Engineering Department' is the department; members enrolled refers to position = 'Member'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT z.city, z.state\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE maj.department = 'Electrical and Computer Engineering Department'\nAND m.position = 'Member';"
        ],
        "rule_sql": []
    },
    "1066": {
        "question": "What is the passing class of CLB team?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'CLB'",
        "amends": [
            "Do select only `buildUpPlayPassingClass` instead of including `team_short_name`. Do use `DISTINCT` to eliminate duplicates instead of omitting it. Do use table aliases `t1` and `t2` instead of `t` and `ta`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do reference `t2.buildUpPlayPassingClass` instead of `ta.buildUpPlayPassingClass` in the SELECT clause. The amended query now correctly returns only distinct buildUpPlayPassingClass values for the specified team."
        ],
        "rules": [
            "1) When the question asks for a specific team's passing class: filter rows where T1.team_short_name equals exactly 'CLB'.\n2) When combining Team (T1) and Team_Attributes (T2) tables: link rows where T1.team_api_id equals T2.team_api_id using an inner match.\n3) When selecting output for a specific attribute: return only the distinct values of T2.buildUpPlayPassingClass.\n4) When eliminating duplicate values: use DISTINCT on the output column to ensure unique results.\n5) When using table aliases: refer to Team table as T1 and Team_Attributes table as T2 consistently.\nOutput columns (ordered): T2.buildUpPlayPassingClass"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_short_name, ta.buildUpPlayPassingClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_short_name = 'CLB';",
            "SELECT DISTINCT t2.buildUpPlayPassingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_short_name = 'CLB';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.buildUpPlayPassingClass \nFROM Team T1 \nINNER JOIN Team_Attributes T2 ON T1.team_api_id = T2.team_api_id \nWHERE T1.team_short_name = 'CLB'"
        ]
    },
    "1526": {
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "amends": [
            "Do use `SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0))` and `SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0))` instead of separate CTEs for each year's consumption. Do add `INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID` instead of omitting the gasstations table join. Do use `CAST(... AS FLOAT)` for the division instead of implicit casting. Do move the CustomerID subquery directly into the WHERE clause instead of using multiple CTEs. Do calculate the consumption decrease rate with proper aggregation instead of single row assumptions. Do handle multiple year records with conditional aggregation instead of assuming single records per year. The amended query now correctly handles multiple consumption records and properly joins with the gasstations table to match RIGHT_SQL's behavior.",
            "Do remove the CTE `target_customer` and instead use a scalar subquery in the `WHERE` clause. Do change the date format from `'2012/8/25'` to `'2012-08-25'` for proper date handling. Do remove the explicit `GROUP BY tc.CustomerID` since the query now returns a single aggregate value instead of per-customer results. Do eliminate the unnecessary `DISTINCT` in the subquery as the scalar subquery expects a single value. Do remove the table alias `ym` and reference columns directly from the `yearmonth` table. Do simplify the calculation by removing the multiplication by `100.0` since the right query calculates a ratio rather than a percentage rate. The amended query now correctly returns a single aggregate consumption difference ratio for the specific customer matching the transaction criteria."
        ],
        "rules": [
            "1) When the question asks for a customer who paid a specific amount on a specific date: filter transactions_1k table where Date equals '2012-08-25' and Price equals 634.8 to find the CustomerID.\n2) When calculating consumption across multiple years for the same customer: use conditional aggregation with SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) for 2012 and SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0)) for 2013 instead of separate queries.\n3) When joining tables in this schema: perform an inner join between transactions_1k as T1 and gasstations as T2 where T1.GasStationID equals T2.GasStationID.\n4) When calculating a ratio involving numeric division: use CAST(... AS FLOAT) to ensure proper floating-point division instead of implicit casting.\n5) When handling multiple consumption records per year: aggregate consumption values using SUM with conditional logic instead of assuming single records per year.\n6) When computing a consumption decrease rate: calculate (2012_consumption - 2013_consumption) divided by 2012_consumption, guarding against division by zero.\nOutput columns (ordered): ConsumptionDecreaseRate",
            "1) When identifying a customer by transaction amount and date: use a scalar subquery with exact literal values '2012-08-25' for Date and 634.8 for Price from transactions_1k table. 2) When calculating consumption decrease rate between years: compute (sum of Consumption for year '2012' minus sum of Consumption for year '2013') divided by sum of Consumption for year '2012' from yearmonth table. 3) When filtering for a specific customer: use CustomerID from the scalar subquery result to filter yearmonth table rows. 4) When handling date comparisons: extract year portion using SUBSTR(Date, 1, 4) to match against literal years '2012' and '2013'. 5) When the query returns a single aggregate value: do not include GROUP BY clause. 6) Output columns (ordered): consumption_decrease_rate"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH customer_payment AS (\n    SELECT CustomerID\n    FROM transactions_1k\n    WHERE Date = '2012-08-25' AND Price = 634.8\n    LIMIT 1\n),\nconsumption_2012 AS (\n    SELECT Consumption\n    FROM yearmonth\n    WHERE CustomerID = (SELECT CustomerID FROM customer_payment) AND Date LIKE '2012%'\n),\nconsumption_2013 AS (\n    SELECT Consumption\n    FROM yearmonth\n    WHERE CustomerID = (SELECT CustomerID FROM customer_payment) AND Date LIKE '2013%'\n)\nSELECT \n    ((SELECT Consumption FROM consumption_2012) - (SELECT Consumption FROM consumption_2013)) / \n    (SELECT Consumption FROM consumption_2012) AS ConsumptionDecreaseRate;",
            "WITH target_customer AS (\n    SELECT DISTINCT t.CustomerID\n    FROM transactions_1k t\n    INNER JOIN gasstations g ON t.GasStationID = g.GasStationID\n    WHERE t.Date = '2012/8/25' AND t.Price = 634.8\n)\nSELECT \n    tc.CustomerID,\n    CAST(\n        (SUM(IIF(SUBSTR(ym.Date, 1, 4) = '2012', ym.Consumption, 0)) - \n         SUM(IIF(SUBSTR(ym.Date, 1, 4) = '2013', ym.Consumption, 0))) / \n        SUM(IIF(SUBSTR(ym.Date, 1, 4) = '2012', ym.Consumption, 0)) * 100.0 \n        AS FLOAT\n    ) AS consumption_decrease_rate\nFROM target_customer tc\nINNER JOIN yearmonth ym ON tc.CustomerID = ym.CustomerID\nGROUP BY tc.CustomerID",
            "SELECT \n    (SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0))) / \n    CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) AS FLOAT) AS ConsumptionDecreaseRate\nFROM yearmonth\nWHERE CustomerID = (\n    SELECT t.CustomerID\n    FROM transactions_1k t\n    INNER JOIN gasstations g ON t.GasStationID = g.GasStationID\n    WHERE t.Date = '2012-08-25' AND t.Price = 634.8\n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0))) \n    / CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) AS FLOAT) AS ConsumptionDecreaseRate\nFROM yearmonth\nWHERE CustomerID = (\n    SELECT CustomerID \n    FROM transactions_1k \n    WHERE Date = '2012-08-25' AND Price = 634.8\n)"
        ]
    },
    "1505": {
        "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
        "amends": [
            "Do use `COUNT(*)` instead of `COUNT(DISTINCT c.CustomerID)` to count all matching rows rather than distinct customer IDs. Do reference the tables as `T1` for yearmonth and `T2` for customers instead of `c` and `ym` aliases. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do place the join condition `T1.CustomerID = T2.CustomerID` instead of `c.CustomerID = ym.CustomerID` with consistent table reference order. Do specify the consumption value as `1000.00` instead of `1000` for explicit decimal precision. The amended query now correctly counts all matching records between customers with EUR currency and yearmonth entries with consumption over 1000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions customers who paid in euro: filter T2.customers where T2.Currency equals 'EUR' exactly. 2) When the question asks for monthly consumption over 1000: filter T1.yearmonth where T1.Consumption is greater than 1000.00 exactly. 3) When combining T1.yearmonth and T2.customers: link rows where T1.CustomerID equals T2.CustomerID exactly and keep only matching pairs (inner match). 4) When counting matching records: use COUNT(*) to count all rows that satisfy both conditions. 5) Output columns (ordered): COUNT(*)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.CustomerID) \nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Currency = 'EUR' AND ym.Consumption > 1000;",
            "SELECT COUNT(*)\nFROM yearmonth T1\nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Currency = 'EUR'\nAND T1.Consumption > 1000.00"
        ],
        "rule_sql": [
            "SELECT COUNT(*)\nFROM yearmonth T1\nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Currency = 'EUR'\nAND T1.Consumption > 1000.00"
        ]
    },
    "1345": {
        "question": "How many majors are there in \"College of Humanities and Social Sciences\"?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(major_name) FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM major WHERE college = 'College of Humanities and Social Sciences';"
        ],
        "rule_sql": []
    },
    "133": {
        "question": "In 1996, which districts have the highest unemployment rate? List their branch location and district name.",
        "db_id": "financial",
        "ground_truth": "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1",
        "amends": [
            "Do select `district_id` and `A2` instead of `A2` and `A13` in the SELECT list. Do remove the alias `AS district_name` for `A2` instead of keeping it. Do remove the alias `AS unemployment_rate` for `A13` instead of keeping it. Do add `LIMIT 1` at the end instead of omitting it to return only the top record. The amended query now correctly returns the district_id and district name for the single record with the highest unemployment rate, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for districts with the highest unemployment rate: rank rows by A13 in descending order and keep the first 1 row.\n2) When the question asks for district name: include A2 in the output columns.\n3) When the question asks for branch location: include district_id in the output columns.\n4) When the question specifies year 1996: note that this is contextual information but no specific filtering is required based on the schema.\n5) Output columns (ordered): district_id, A2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT A2 AS district_name, A13 AS unemployment_rate FROM district ORDER BY A13 DESC;",
            "SELECT district_id, A2 FROM district WHERE A13 = (SELECT MAX(A13) FROM district) LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1;"
        ]
    },
    "57": {
        "question": "What is the phone number and extension number for the school that had the 333rd highest average writing score?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.Phone, T2.Ext FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrWrite DESC LIMIT 332, 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.Phone, s.Ext\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY sc.AvgScrWrite DESC\nLIMIT 1 OFFSET 332;"
        ],
        "rule_sql": []
    },
    "908": {
        "question": "What is the most laps f1 races had? Name the race, year and circuit location where the races with most laps was hosted.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.lap, T2.name, T2.year, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId INNER JOIN lapTimes AS T3 ON T3.raceId = T2.raceId ORDER BY T3.lap DESC LIMIT 1",
        "amends": [
            "Do select `T3.lap`, `T2.name`, `T2.year`, and `T1.location` instead of `r.name`, `r.year`, `c.location`, and `MAX(re.laps)`. Do join `circuits AS T1` and `races AS T2` with `T1.circuitId = T2.circuitId` instead of joining `results`, `races`, and `circuits` with different join conditions. Do add `lapTimes AS T3` with `T3.raceId = T2.raceId` instead of omitting this table entirely. Do remove the `GROUP BY re.raceId` and aggregation instead of keeping them. Do order by `T3.lap DESC` instead of `max_laps DESC`. The amended query now correctly retrieves lap time data rather than maximum laps from results, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"most laps\" and requires race name, year, and circuit location: select T2.name, T2.year, and T1.location from the joined tables. 2) When joining circuits and races tables: link them using T1.circuitId = T2.circuitId to match circuit information with race information. 3) When including lap time data: add lapTimes as T3 with T3.raceId = T2.raceId to connect lap information to specific races. 4) When retrieving lap information: select T3.lap instead of aggregating maximum laps from results. 5) When ordering by laps to find the highest value: order by T3.lap DESC to get the largest lap count first. 6) When the question asks for the race with most laps: take only the first row after ordering by laps in descending order. 7) Output columns (ordered): T2.name, T2.year, T1.location, T3.lap"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT r.name AS race_name, r.year, c.location AS circuit_location, MAX(re.laps) AS max_laps\nFROM results re\nJOIN races r ON re.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nGROUP BY re.raceId\nORDER BY max_laps DESC\nLIMIT 1;",
            "SELECT T3.lap, T2.name, T2.year, T1.location\nFROM circuits AS T1\nJOIN races AS T2 ON T1.circuitId = T2.circuitId\nJOIN lapTimes AS T3 ON T3.raceId = T2.raceId\nORDER BY T3.lap DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name, T2.year, T1.location, T3.lap\nFROM circuits T1\nJOIN races T2 ON T1.circuitId = T2.circuitId\nJOIN lapTimes T3 ON T3.raceId = T2.raceId\nORDER BY T3.lap DESC\nLIMIT 1;"
        ]
    },
    "538": {
        "question": "Please list the titles of the posts owned by the user csgillespie?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Title \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE u.DisplayName = 'csgillespie';"
        ],
        "rule_sql": []
    },
    "909": {
        "question": "Among all European Grand Prix races, what is the percentage of the races were hosted in Germany?",
        "db_id": "formula_1",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.country = 'Germany' THEN T2.circuitID END) AS REAL) * 100 / COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix'",
        "amends": [],
        "rules": [
            "European Grand Prix races refers to races.name = 'European Grand Prix';percentage = divide(COUNT(races where country = Germany and name = 'Europearn Grand Prix'),COUNT(races where name = 'Europearn Grand Prix'))*100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.country = 'Germany' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_in_germany\nFROM \n    races r\nJOIN \n    circuits c ON r.circuitId = c.circuitId\nWHERE \n    r.name = 'European Grand Prix';"
        ],
        "rule_sql": []
    },
    "571": {
        "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
        "amends": [
            "Do use a single query with `INNER JOIN` between `votes` and `posts` on `T1.UserId = T2.OwnerUserId` instead of multiple separate subqueries. Do calculate the ratio as `CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id)` instead of separate counts for posts and votes with division. Do filter with `WHERE T1.UserId = 24` applied to the joined dataset instead of filtering each subquery independently. Do remove the `CASE` statement handling division by zero since the join ensures meaningful aggregation. Do use `COUNT(DISTINCT T1.Id)` for vote counting instead of simple `COUNT(*)` to avoid duplication from the join. The amended query now correctly calculates the post-to-vote ratio by joining the relevant tables and handles the aggregation properly to match the RIGHT_SQL's behavior.",
            "Do use `COUNT(T2.Id)` for posts count instead of `COUNT(DISTINCT posts.Id)` to avoid unnecessary distinct counting on unique post IDs. Do use `COUNT(DISTINCT T1.Id)` for votes count instead of `COUNT(DISTINCT votes.Id)` to properly count distinct vote IDs. Do use table aliases `T1` for votes and `T2` for posts instead of full table names for consistency and clarity. Do maintain the same `INNER JOIN` on `T1.UserId = T2.OwnerUserId` instead of changing the join condition. Do keep the same `WHERE T1.UserId = 24` filter instead of modifying the user filter. The amended query now correctly calculates the ratio by counting all posts (since post IDs are unique) while counting distinct votes (since multiple votes could exist), matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a ratio comparing posts to votes for a specific user: compute the ratio as (count of posts) divided by (count of votes) using exact user ID 24. 2) When combining votes and posts tables for user data: link rows where T1.UserId equals T2.OwnerUserId and keep only matching pairs (inner match). 3) When counting votes: use COUNT(DISTINCT T1.Id) to avoid duplication from the join. 4) When counting posts: use COUNT(T2.Id) to count all post entries. 5) When filtering for a specific user: apply WHERE T1.UserId = 24 to the joined dataset. 6) When calculating the ratio: use CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) and do not handle division by zero since the join ensures meaningful aggregation. 7) Output columns (ordered): the computed post-to-vote ratio.",
            "1) When the question asks for a ratio comparing posts to votes for a specific user: compute (number of posts) divided by (number of votes) for user ID 24, guarding division by zero.\n2) When counting posts for user No.24: count all rows from T2 (posts) where T2.OwnerUserId = 24 using T2.Id as the counting key since post IDs are unique.\n3) When counting votes for user No.24: count distinct values of T1.Id (votes) where T1.UserId = 24 since multiple votes could exist with the same ID.\n4) When combining votes and posts tables: link rows where T1.UserId = T2.OwnerUserId and keep only matching pairs (inner match).\n5) When filtering for user No.24: include only rows where T1.UserId = 24 exactly.\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.\n7) When handling text literals: do not change case, spacing, or punctuation.\n8) When referring to table roles: use T1 for votes and T2 for posts consistently throughout.\nOutput columns (ordered): post_to_vote_ratio"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM posts WHERE OwnerUserId = 24) AS post_count,\n    (SELECT COUNT(*) FROM votes WHERE UserId = 24) AS vote_count,\n    CASE \n        WHEN (SELECT COUNT(*) FROM votes WHERE UserId = 24) = 0 THEN NULL\n        ELSE CAST((SELECT COUNT(*) FROM posts WHERE OwnerUserId = 24) AS FLOAT) / (SELECT COUNT(*) FROM votes WHERE UserId = 24)\n    END AS post_to_vote_ratio;",
            "SELECT CAST(COUNT(DISTINCT posts.Id) AS REAL) / COUNT(DISTINCT votes.Id) AS post_to_vote_ratio\nFROM votes\nINNER JOIN posts ON votes.UserId = posts.OwnerUserId\nWHERE votes.UserId = 24",
            "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) AS post_to_vote_ratio\nFROM votes T1\nINNER JOIN posts T2 ON T1.UserId = T2.OwnerUserId\nWHERE T1.UserId = 24"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) AS post_to_vote_ratio\nFROM votes T1\nINNER JOIN posts T2 ON T1.UserId = T2.OwnerUserId\nWHERE T1.UserId = 24"
        ]
    },
    "1227": {
        "question": "What is the average age of the male patient with high cholesterol?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-CHO` >= 250 AND T1.SEX = 'M'",
        "amends": [],
        "rules": [
            "average age = DIVIDE(SUM(SUBTRACT(YEAR(NOW()), YEAR(birthday))), COUNT(ID)); male patient refers to sex = 'M'; high cholesterol refers to `T-CHO` > = 250;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(strftime('%Y', 'now') - strftime('%Y', Birthday)) AS average_age\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.SEX = 'M' AND Laboratory.\"T-CHO\" >= 250;"
        ],
        "rule_sql": []
    },
    "640": {
        "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "amends": [
            "Do use a single query with conditional aggregation using `SUM(IIF(condition, value, 0))` instead of separate subqueries with `COALESCE(SUM(), 0)`. Do join `users AS T1` to `postHistory AS T2` on `T1.Id = T2.UserId` instead of directly joining to `posts`. Do then join `posts AS T3` on `T3.Id = T2.PostId` instead of joining directly from `users` to `posts` on `OwnerUserId`. Do reference the correct table aliases `T1.DisplayName` and `T3.ViewCount` instead of the original column references. Do remove the separate subquery structure and instead perform the calculation in a single pass through the joined tables. The amended query now correctly calculates the view count difference between the two users by properly traversing the relationship through postHistory instead of assuming a direct user-to-posts connection."
        ],
        "rules": [
            "1) When calculating view count differences between users: use conditional aggregation with SUM(IIF(condition, value, 0)) instead of separate subqueries with COALESCE(SUM(), 0).\n2) When joining users to posts: first join users AS T1 to postHistory AS T2 on T1.Id = T2.UserId, then join posts AS T3 on T3.Id = T2.PostId instead of direct user-to-posts joins.\n3) When referencing user display names: use T1.DisplayName with exact literal values 'Mornington' and 'Amos'.\n4) When referencing view counts: use T3.ViewCount from the posts table.\n5) When performing the calculation: compute the difference as SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) in a single query pass.\nOutput columns (ordered): ViewCountDifference"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COALESCE(SUM(p.ViewCount), 0) FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Mornington') -\n    (SELECT COALESCE(SUM(p.ViewCount), 0) FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Amos') AS ViewCountDifference;",
            "SELECT \n    SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - \n    SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS view_count_difference\nFROM \n    users AS T1\nJOIN \n    postHistory AS T2 ON T1.Id = T2.UserId\nJOIN \n    posts AS T3 ON T3.Id = T2.PostId\nWHERE \n    T1.DisplayName IN ('Mornington', 'Amos')"
        ],
        "rule_sql": [
            "SELECT \n    SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS ViewCountDifference\nFROM \n    users AS T1\nJOIN \n    postHistory AS T2 ON T1.Id = T2.UserId\nJOIN \n    posts AS T3 ON T3.Id = T2.PostId\nWHERE \n    T1.DisplayName IN ('Mornington', 'Amos')"
        ]
    },
    "1000": {
        "question": "Which racetrack hosted the most recent race? Indicate the full location.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1",
        "amends": [
            "Do select only `location` instead of `racetrack` and `full_location` concatenation. Do use `INNER JOIN` with aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do remove the WHERE clause with subquery instead of keeping it. Do add `ORDER BY T2.date DESC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limitation. The amended query now correctly returns the single most recent race location by joining circuits and races tables and ordering by date descending with limit 1."
        ],
        "rules": [
            "1) When the question asks for the most recent race: order rows by T2.date in descending direction and keep only the first 1 row.\n2) When the question asks for the full location: select only T1.location instead of concatenated values.\n3) When combining T1 (circuits) and T2 (races) tables: link rows where T1.circuitId equals T2.circuitId and keep only matching pairs (inner match).\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.\n5) When handling text literals: do not change case, spacing, or punctuation.\n6) When referring to table roles: do not rename or swap the aliases T1 for circuits and T2 for races once set for this schema.\n7) Output columns (ordered): T1.location"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name AS racetrack, c.location || ', ' || c.country AS full_location\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.date = (SELECT MAX(date) FROM races);",
            "SELECT T1.location FROM circuits T1 INNER JOIN races T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.location FROM circuits T1 INNER JOIN races T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1"
        ]
    },
    "69": {
        "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
        "db_id": "california_schools",
        "ground_truth": "SELECT NCESDist FROM schools WHERE SOC = 31",
        "amends": [],
        "rules": [
            "State Special Schools means that SOC = 31."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT NCESDist FROM schools WHERE SOC IS NOT NULL AND SOCType = 'State Special Schools';"
        ],
        "rule_sql": []
    },
    "259": {
        "question": "How many elements are there for single bond molecules?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "amends": [
            "Do count distinct `T.element` from a subquery instead of counting distinct `a.element` directly from joined tables. Do use a subquery that selects distinct `T2.molecule_id` and `T1.element` instead of omitting molecule context. Do join `atom AS T1` with `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of joining directly with bond and connected tables. Do join `molecule AS T2` with `bond AS T3` on `T2.molecule_id = T3.molecule_id` instead of using connected table joins with atom ID matching. Do filter on `T3.bond_type = '-'` in the subquery instead of applying the filter in the outer query. Do remove the complex `OR` condition `c.atom_id2 = a.atom_id` and the connected table entirely instead of keeping unnecessary table relationships. The amended query now correctly counts distinct elements within molecules containing specific bond types, matching the intended behavior."
        ],
        "rules": [
            "1) When counting distinct elements for molecules with specific bond types: use a subquery that selects distinct molecule_id and element from the joined atom and molecule tables instead of counting directly from joined tables. 2) When joining atom (T1) and molecule (T2) tables: link rows where T1.molecule_id = T2.molecule_id. 3) When joining molecule (T2) and bond (T3) tables: link rows where T2.molecule_id = T3.molecule_id. 4) When filtering for single bond molecules: apply the condition T3.bond_type = '-' in the subquery. 5) When counting distinct elements: count the distinct values of T1.element from the subquery results. 6) When the question involves molecular context: include molecule_id in the subquery to maintain proper molecular grouping. 7) When handling bond relationships: do not use connected tables or complex OR conditions with atom_id matching. Output columns (ordered): element_count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.element) AS element_count\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a ON c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id\nWHERE b.bond_type = '-';",
            "SELECT COUNT(DISTINCT T.element) \nFROM (\n    SELECT DISTINCT T2.molecule_id, T1.element\n    FROM atom AS T1\n    JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n    JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\n    WHERE T3.bond_type = '-'\n) AS T"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT sub.element) AS element_count\nFROM (\n    SELECT DISTINCT a.molecule_id, a.element\n    FROM atom a\n    JOIN molecule m ON a.molecule_id = m.molecule_id\n    JOIN bond b ON m.molecule_id = b.molecule_id\n    WHERE b.bond_type = '-'\n) AS sub"
        ]
    },
    "1090": {
        "question": "What is the long passing score of the oldest player?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.long_passing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "long passing score refers to long_passing; oldest player refers to oldest birthday;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pa.long_passing\nFROM Player_Attributes pa\nJOIN (\n    SELECT player_api_id\n    FROM Player\n    ORDER BY birthday ASC\n    LIMIT 1\n) p ON pa.player_api_id = p.player_api_id\nORDER BY pa.date DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "622": {
        "question": "State the name of badge that the user whose display name is \"Sharpie\" obtained.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Sharpie'",
        "amends": [],
        "rules": [
            "\"Sharpie\" is the DisplayName of user; user refers to UserId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'Sharpie';"
        ],
        "rule_sql": []
    },
    "684": {
        "question": "Identify the percentage of teenage users.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(SUM(IIF(Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(Id) FROM users",
        "amends": [],
        "rules": [
            "DIVIDE(COUNT(Id where Age BETWEEN 13 and 18), COUNT(Id)) as percentage;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN Age BETWEEN 13 AND 18 THEN 1 END) * 100.0 / COUNT(Id)) AS percentage FROM users;"
        ],
        "rule_sql": []
    },
    "564": {
        "question": "Give the only one comment text of the post with parent id 107829.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "amends": [],
        "rules": [
            "one comment refers to CommentCount = '1'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Text FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.ParentId = 107829 LIMIT 1;"
        ],
        "rule_sql": []
    },
    "539": {
        "question": "Who is the owner of the post \"Eliciting priors from experts\"?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'",
        "amends": [],
        "rules": [
            "\"Eliciting priors from experts\" is the Title of post; owner refers to DisplayName"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Eliciting priors from experts';"
        ],
        "rule_sql": []
    },
    "14": {
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "amends": [
            "Do select only `T1.NCESSchool` instead of including `s.NCESchool`, `f.School Name`, and `f.Enrollment (Ages 5-17)` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `s` and `f`. Do join on `T1.CDSCode = T2.CDSCode` instead of `f.CDSCode = s.CDSCode` to maintain proper join direction. Do order by `T2.Enrollment (Ages 5-17)` instead of `f.Enrollment (Ages 5-17)` using backticks for the column name. The amended query now correctly returns only the school names from the top 5 enrollments as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"top five schools\" by \"Enrollment (Ages 5-17)\": rank rows by T2.\"Enrollment (Ages 5-17)\" in descending order and keep the first 5 rows.\n2) When combining T1 and T2 for shared entities: link rows where T1.CDSCode = T2.CDSCode; keep only matching pairs (inner match).\n3) When the question asks for \"NCES school identification number\": output T1.NCESSchool as the result.\n4) When ordering by T2.\"Enrollment (Ages 5-17)\": use descending order to get highest values first.\n5) Output columns (ordered): T1.NCESSchool"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.NCESchool, f.\"School Name\", f.\"Enrollment (Ages 5-17)\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nORDER BY f.\"Enrollment (Ages 5-17)\" DESC\nLIMIT 5;",
            "SELECT T1.NCESSchool\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.`Enrollment (Ages 5-17)` DESC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT T1.NCESSchool\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.\"Enrollment (Ages 5-17)\" DESC\nLIMIT 5"
        ]
    },
    "129": {
        "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
        "db_id": "financial",
        "ground_truth": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%' ORDER BY A2 ASC LIMIT 10",
        "amends": [
            "Do select only `DISTINCT T1.A2` instead of aggregating with `SUM(t.amount)` and aliasing as `total_withdrawal`. Do use table aliases `T1`, `T2`, and `T3` instead of `d`, `a`, and `t`. Do change the join condition from `a.district_id = d.district_id` to `T1.district_id = T2.district_id` for proper table reference alignment. Do remove the `GROUP BY d.A2` clause instead of keeping it since aggregation is no longer needed. Do change the `ORDER BY` clause to `A2 ASC` instead of `total_withdrawal DESC` to sort alphabetically rather than by sum. The amended query now matches RIGHT_SQL's behavior of returning distinct district names rather than aggregated withdrawal totals."
        ],
        "rules": [
            "1) When the question asks for \"top ten withdrawals by district names\" but the amends show distinct district selection: return only distinct values of T1.A2 instead of aggregating withdrawal amounts.\n2) When joining tables account and district: link rows where T1.district_id = T2.district_id using exact token equality.\n3) When filtering for transaction type: include only rows where T3.type equals exactly 'VYDAJ' (case-sensitive).\n4) When filtering for January 1996: include only rows where T3.date starts with '1996-01' exactly.\n5) When ordering results: sort by T1.A2 in ascending alphabetical order instead of by withdrawal amount.\n6) When limiting results: return only the first 10 rows after sorting.\n7) Output columns (ordered): T1.A2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.A2 AS district_name, SUM(t.amount) AS total_withdrawal\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE t.type = 'VYDAJ' AND t.date LIKE '1996-01%'\nGROUP BY d.A2\nORDER BY total_withdrawal DESC\nLIMIT 10;",
            "SELECT DISTINCT T1.A2\nFROM district T1\nJOIN account T2 ON T1.district_id = T2.district_id\nJOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T3.type != 'credit card'\nAND strftime('%Y-%m', T3.date) = '1996-01'\nORDER BY T1.A2 ASC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.A2\nFROM district T1\nJOIN account T2 ON T1.district_id = T2.district_id\nJOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T3.type = 'VYDAJ'\nAND T3.date LIKE '1996-01%'\nORDER BY T1.A2 ASC\nLIMIT 10"
        ]
    },
    "370": {
        "question": "How many borderless cards are illustrated in Russian?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.borderColor = 'borderless' AND T2.language = 'Russian'",
        "amends": [],
        "rules": [
            "borderless card refers to borderColor = 'borderless'; 'Russian' is the language;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.id) \nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.borderColor = 'borderless' AND fd.language = 'Russian';"
        ],
        "rule_sql": []
    },
    "386": {
        "question": "How many cards are having future frame version and what are the legality status of these cards?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future'",
        "amends": [
            "Do remove the `GROUP BY l.status` clause and the `l.status AS legality_status` column from the SELECT list instead of grouping by legality status and including it in the output. Do use table aliases `T1` for cards and `T2` for legalities instead of the original table names. Do change the join from a simple `JOIN` to an explicit `INNER JOIN` instead of the implicit join type. Do remove the column alias `AS total_future_frame_cards` from the count expression instead of keeping it. The amended query now correctly counts all future frame cards without grouping by legality status, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for count of cards with future frame version: count the number of rows using T1.id as the counting key. 2) When filtering for future frame version cards: include only rows where T1.frameVersion equals exactly 'future'. 3) When combining T1 (cards) and T2 (legalities) for shared entities: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match). 4) When the question asks about legality status of these cards: include T2.status in the output to show the legality status for each card. 5) When producing output: do not group by T2.status since the question asks for the count of cards rather than counts per status. 6) Output columns (ordered): COUNT(T1.id), T2.status"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(c.id) AS total_future_frame_cards, l.status AS legality_status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.frameVersion = 'future'\nGROUP BY l.status;",
            "SELECT COUNT(*) \nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.frameVersion = 'future'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id), T2.status\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.frameVersion = 'future'\nGROUP BY T2.status"
        ]
    },
    "210": {
        "question": "What atoms are connected in single type bonds?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "amends": [
            "Do select `T2.atom_id` and `T2.atom_id2` instead of selecting `a1.atom_id`, `a1.element`, `a2.atom_id`, and `a2.element`. Do use `INNER JOIN` between `bond AS T1` and `connected AS T2` on `T1.bond_id = T2.bond_id` instead of joining `connected c` with `bond b` and then joining with `atom a1` and `atom a2`. Do remove the unnecessary joins with `atom` table instead of keeping them. Do keep the filter `WHERE T1.bond_type = '-'` instead of filtering on the same condition. The amended query now correctly retrieves only the connected atom pairs for single bonds without the unnecessary element information and extra table joins, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for connected atoms in single type bonds: select T2.atom_id and T2.atom_id2 from the connected table. 2) When combining bond and connected tables: link rows where T1.bond_id = T2.bond_id using an inner match. 3) When filtering for single bonds: keep only rows where T1.bond_type = '-'. 4) When the schema includes atom element information but the question doesn't require it: do not join with the atom table or select element columns. Output columns (ordered): T2.atom_id, T2.atom_id2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a1.atom_id AS atom1_id, a1.element AS atom1_element, a2.atom_id AS atom2_id, a2.element AS atom2_element\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = '-';",
            "SELECT T2.atom_id, T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2 FROM bond T1 INNER JOIN connected T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'"
        ]
    },
    "1281": {
        "question": "Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60 ORDER BY T1.Birthday DESC LIMIT 1",
        "amends": [],
        "rules": [
            "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; The larger the birthday value, the younger the person is, and vice versa;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(p.Birthday) AS YoungestBirthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GOT >= 60;"
        ],
        "rule_sql": []
    },
    "959": {
        "question": "What is the fastest lap number of the champion in 2009?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "amends": [
            "Do remove the `JOIN` on `driverStandings` table and its `ds.position = 1` condition instead of including them. Do change the `WHERE` filter to use `T1.time LIKE '_:%:__.___'` instead of the removed driver standings condition. Do keep the `rc.year = 2009` filter but reference it as `T2.year = 2009` instead. Do remove the `ORDER BY r.fastestLap ASC` and `LIMIT 1` clauses instead of keeping them, as the query now filters for specific time patterns rather than finding the minimum fastest lap. The amended query now correctly filters for results from 2009 with specific time format patterns rather than attempting to find the fastest lap among championship leaders."
        ],
        "rules": [
            "1) When the question asks about the fastest lap number of the champion in 2009: do not join the driverStandings table or use ds.position = 1 condition. 2) When filtering for results from year 2009: use T2.year = 2009. 3) When identifying fastest lap times: use T1.time LIKE '_:%:__.___' pattern matching. 4) When the query involves finding specific time patterns rather than minimum values: do not use ORDER BY and LIMIT clauses. 5) Output columns (ordered): T1.fastestLap"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT r.fastestLap\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN driverStandings ds ON r.driverId = ds.driverId AND r.raceId = ds.raceId\nWHERE rc.year = 2009 AND ds.position = 1\nORDER BY r.fastestLap ASC\nLIMIT 1;",
            "SELECT T1.fastestLap \nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2009 \nAND T1.time LIKE '_:%:__.___'"
        ],
        "rule_sql": [
            "SELECT T1.fastestLap \nFROM results T1 \nJOIN races T2 ON T1.raceId = T2.raceId \nJOIN driverStandings ds ON T1.driverId = ds.driverId AND T1.raceId = ds.raceId \nWHERE T2.year = 2009 \nAND ds.position = 1 \nAND T1.time LIKE '_:%:__.___' \nLIMIT 1"
        ]
    },
    "1175": {
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "amends": [
            "Do select `STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)` and `T1.Diagnosis` instead of `P.ID`, calculated `Age`, and `E.Diagnosis`. Do use `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of the CTE with max HGB filtering and subsequent joins to Patient and Examination tables. Do add `ORDER BY T2.HGB DESC LIMIT 1` instead of filtering for maximum HGB values through a subquery. Do remove the Examination table join and date matching condition instead of including them. The amended query now correctly retrieves the patient with the highest HGB value by sorting and limiting rather than using a complex max-filtering approach, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the patient with the highest hemoglobin count: rank rows by T2.HGB in descending order and keep the first 1 row.\n2) When calculating patient age: compute STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) as the age value.\n3) When retrieving diagnosis information: use T1.Diagnosis from the Patient table.\n4) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n5) When the question asks for both age and diagnosis: output both the calculated age and T1.Diagnosis.\n6) Output columns (ordered): STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH MaxHGBPatient AS (\n    SELECT \n        L.ID,\n        L.HGB,\n        L.Date\n    FROM \n        Laboratory L\n    WHERE \n        L.HGB = (SELECT MAX(HGB) FROM Laboratory)\n)\nSELECT \n    P.ID,\n    (strftime('%Y', E.`Examination Date`) - strftime('%Y', P.Birthday)) AS Age,\n    E.Diagnosis\nFROM \n    MaxHGBPatient M\nJOIN \n    Patient P ON M.ID = P.ID\nJOIN \n    Examination E ON M.ID = E.ID AND M.Date = E.`Examination Date`;",
            "SELECT \n    STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) AS Age,\n    T1.Diagnosis\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nORDER BY \n    T2.HGB DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \n    STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) AS Age,\n    T1.Diagnosis\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nORDER BY \n    T2.HGB DESC\nLIMIT 1;"
        ]
    },
    "1398": {
        "question": "Name the event with the highest amount spent on advertisement.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' ORDER BY T1.spent DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Name of event refers to event_name; highest amount spent on advertisement refers to MAX(spent) where category = 'Advertisement'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.category = 'Advertisement'\nORDER BY b.spent DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "328": {
        "question": "List all the elements with double bond, consisted in molecule TR024.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='",
        "amends": [
            "Do select `T1.element` instead of `a.element` and remove `DISTINCT` instead of keeping it. Do use `atom AS T1` and `bond AS T2` as sources instead of multiple joined tables including `molecule`, `atom`, `connected`, and `bond`. Do perform an `INNER JOIN` between `T1` and `T2` on `T1.molecule_id = T2.molecule_id` instead of complex join conditions involving `OR` operations and multiple table connections. Do keep the filter `T1.molecule_id = 'TR024'` and `T2.bond_type = '='` in the `WHERE` clause instead of moving them elsewhere. The amended query now correctly matches the intended behavior by simplifying the table relationships and eliminating unnecessary joins while maintaining the same filtering logic."
        ],
        "rules": [
            "1) When the question asks for elements in a specific molecule 'TR024': filter rows where T1.molecule_id equals 'TR024' exactly. 2) When identifying elements with double bonds: filter rows where T2.bond_type equals '=' exactly. 3) When combining atom and bond information: link rows where T1.molecule_id equals T2.molecule_id exactly and keep only matching pairs (inner match). 4) When selecting element data: output T1.element values without removing duplicates. Output columns (ordered): T1.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.element\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE m.molecule_id = 'TR024' AND b.bond_type = '=';",
            "SELECT T1.element\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT T1.element \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR024' \nAND T2.bond_type = '='"
        ]
    },
    "871": {
        "question": "For the driver who had the Q2 time as 0:01:15 in race No. 347, where is he from?",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 347 AND T1.q2 LIKE '1:15%'",
        "amends": [
            "Do use `DISTINCT` on `nationality` instead of omitting it to eliminate duplicate nationalities. Do reference `drivers` as `T2` instead of `d` and `qualifying` as `T1` instead of `q` for consistent table aliasing. Do use `INNER JOIN` with `T2.driverId = T1.driverId` instead of `JOIN` with `d.driverId = q.driverId` for explicit join type and corrected column reference order. Do change the filter to `q2 LIKE '1:15%'` instead of `q2 = '0:01:15'` to match time values with varying minute prefixes. Do maintain the `raceId = 347` filter in the WHERE clause instead of changing its position. The amended query now correctly returns distinct nationalities for drivers with qualifying times starting with '1:15' for race 347."
        ],
        "rules": [
            "1) When the question asks about a driver's origin: use the exact column token T2.nationality to determine where they are from.\n2) When filtering for a specific race: use the exact literal value 347 for T1.raceId.\n3) When matching qualifying times that start with specific digits: use the pattern '1:15%' with LIKE comparison instead of exact equality for T1.q2.\n4) When combining driver and qualifying information: link rows where T2.driverId = T1.driverId using an inner match.\n5) When the result may contain duplicate nationalities: apply DISTINCT to T2.nationality to return only unique values.\n6) When using table aliases: refer to the qualifying table as T1 and the drivers table as T2 consistently throughout.\nOutput columns (ordered): T2.nationality"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.nationality\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nWHERE q.raceId = 347 AND q.q2 = '0:01:15';",
            "SELECT DISTINCT T2.nationality\nFROM qualifying T1\nINNER JOIN drivers T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 347\nAND T1.q2 LIKE '1:15%';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.nationality FROM qualifying T1 INNER JOIN drivers T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 347 AND T1.q2 LIKE '1:15%'"
        ]
    },
    "397": {
        "question": "What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?",
        "db_id": "card_games",
        "ground_truth": "SELECT manaCost FROM cards WHERE availability = 'mtgo,paper' AND borderColor = 'black' AND frameVersion = 2003 AND layout = 'normal'",
        "amends": [],
        "rules": [
            "available in paper and mtgo refers to availability = 'mtgo,paper'; frameVersion = 2003;borderColor = 'black'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability LIKE '%paper%' AND availability LIKE '%mtgo%';"
        ],
        "rule_sql": []
    },
    "135": {
        "question": "After making a credit card withdrawal, how many account/s with monthly issuance has a negative balance?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.balance < 0 AND T1.operation = 'VYBER KARTOU' AND T2.frequency = 'POPLATEK MESICNE'",
        "amends": [
            "Do use `COUNT(T1.account_id)` without `DISTINCT` instead of `COUNT(DISTINCT a.account_id)` to count all matching rows rather than unique accounts. Do reference `trans` as `T1` and `account` as `T2` instead of `a` and `t` aliases. Do use `INNER JOIN` with explicit `AS` keyword instead of simple `JOIN` for clarity. Do place the `balance < 0` condition first in the `WHERE` clause instead of last, and do combine all filter conditions in a single `WHERE` clause instead of separating them. Do remove the column alias `negative_balance_accounts` instead of keeping it since the result set only contains the count. The amended query now correctly counts all transactions meeting the criteria rather than unique accounts, matching the RIGHT_SQL's behavior.",
            "Do use the operation filter `'VYBER KARTOU'` instead of `'Credit Card Withdrawal'` in the WHERE clause, and do use the frequency filter `'POPLATEK MESICNE'` instead of `'Monthly Issuance'` in the WHERE clause, while keeping the same table structure with `INNER JOIN` on `T1.account_id = T2.account_id` and maintaining the count of accounts with negative balance. The amended query now correctly filters for the specific operation and frequency values used in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"how many account/s with monthly issuance has a negative balance\": count all rows using T1.account_id as the counting key. 2) When filtering for accounts with monthly issuance: include only rows where T2.frequency equals 'POPLATEK MESICNE' exactly. 3) When filtering for credit card withdrawal operations: include only rows where T1.operation equals 'VYBER KARTOU' exactly. 4) When filtering for negative balance: include only rows where T1.balance is less than 0. 5) When combining trans and account tables: link rows where T1.account_id equals T2.account_id and keep only matching pairs (inner match). 6) When ordering filter conditions: place the balance condition first in the combined filter set. 7) When producing output: do not include column aliases since only the count is returned. Output columns (ordered): COUNT(T1.account_id)",
            "1) When the question mentions \"credit card withdrawal\": use the exact literal 'VYBER KARTOU' for the operation filter. 2) When the question mentions \"monthly issuance\": use the exact literal 'POPLATEK MESICNE' for the frequency filter. 3) When combining trans and account tables: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match). 4) When counting accounts with negative balance: count using T1.account_id as the counting key. 5) When filtering for negative balance: use T1.balance < 0 as the condition. Output columns (ordered): COUNT(T1.account_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS negative_balance_accounts\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nWHERE a.frequency = 'POPLATEK MESICNE'\nAND t.operation = 'VYBER KARTOU'\nAND t.balance < 0;",
            "SELECT COUNT(T1.account_id)\nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.balance < 0\nAND T1.operation = 'Credit Card Withdrawal'\nAND T2.frequency = 'Monthly Issuance';",
            "SELECT COUNT(T1.account_id)\nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.balance < 0\nAND T1.operation = 'VYBER KARTOU'\nAND T2.frequency = 'POPLATEK MESICNE'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE T1.balance < 0\nAND T1.operation = 'VYBER KARTOU'\nAND T2.frequency = 'POPLATEK MESICNE'"
        ]
    },
    "1118": {
        "question": "List down the name of players who are 35 years old and above.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_name FROM Player WHERE CAST((JULIANDAY('now') - JULIANDAY(birthday)) AS REAL) / 365 >= 35",
        "amends": [
            "Do calculate age using `JULIANDAY` date arithmetic with division by `365` instead of using `strftime` year subtraction with day-of-year comparison. Do use `>= 35` as the age threshold instead of `> 34` to properly include players who are exactly 35 years old. Do cast the Julian day difference to `REAL` for precise decimal age calculation instead of integer year subtraction that can be off by nearly a full year. The amended query now correctly calculates exact age in years as a decimal value and uses the proper inclusive threshold to match the intended behavior of selecting players aged 35 or older."
        ],
        "rules": [
            "1) When calculating age from a birthday field: compute exact decimal age using Julian day arithmetic with division by 365, casting the result to REAL for precision. 2) When selecting players who are 35 years old and above: use an inclusive threshold of >= 35 to properly include players who are exactly 35 years old. 3) When the question asks for players of a specific age range: use precise decimal age calculation instead of integer year subtraction to avoid being off by nearly a full year. Output columns (ordered): player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name FROM Player WHERE (strftime('%Y', 'now') - strftime('%Y', birthday)) - (strftime('%m-%d', 'now') < strftime('%m-%d', birthday)) > 34;",
            "SELECT player_name \nFROM Player \nWHERE (JULIANDAY('now') - JULIANDAY(birthday)) / 365.0 >= 35;"
        ],
        "rule_sql": [
            "SELECT player_name\nFROM Player\nWHERE (julianday('now') - julianday(birthday)) / 365.0 >= 35.0\nORDER BY player_name;"
        ]
    },
    "623": {
        "question": "How many elders obtained the \"Supporter\" badge?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Age > 65 AND T2.Name = 'Supporter'",
        "amends": [],
        "rules": [
            "\"Supporter\" is the Name of badge;\u00a0 elders refers to Age > 65"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT u.Id) AS ElderSupporters\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE u.Age > 65 AND b.Name = 'Supporter';"
        ],
        "rule_sql": []
    },
    "389": {
        "question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'",
        "amends": [
            "Do select `T1.id` and `T2.date` instead of `c.name` and `r.date`. Do use table aliases `T1` and `T2` instead of `c` and `r`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T1.uuid = T2.uuid` in the join condition instead of `c.uuid = r.uuid`. Do filter on `T1.originalType = 'Creature - Elf'` instead of `c.originalType = 'Creature - Elf'`. The amended query now correctly retrieves card IDs with ruling dates while maintaining the same join logic and filtering criteria."
        ],
        "rules": [
            "1) When the question asks for card names and ruling dates: select T1.id and T2.date as output columns. 2) When joining cards and rulings tables: use an inner match where T1.uuid equals T2.uuid exactly. 3) When filtering for cards with original type \"Creature - Elf\": apply the exact condition T1.originalType = 'Creature - Elf' with the literal value preserved exactly. 4) When using table aliases: refer to the cards table as T1 and the rulings table as T2 consistently. 5) Output columns (ordered): T1.id, T2.date"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, r.date\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.originalType = 'Creature - Elf';",
            "SELECT T1.id, T2.date\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.originalType = 'Creature - Elf'"
        ],
        "rule_sql": [
            "SELECT T1.id, T2.date FROM cards T1 INNER JOIN rulings T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'"
        ]
    },
    "451": {
        "question": "How many cards available in paper have a positive starting maximum hand size?",
        "db_id": "card_games",
        "ground_truth": "SELECT SUM(CASE WHEN availability = 'paper' AND hAND = '3' THEN 1 ELSE 0 END) FROM cards",
        "amends": [],
        "rules": [
            "available in paper refers to availability like '%paper%'; have a positive starting maximum hand size refers to hand = '3'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE availability LIKE '%paper%' AND hand = '3';"
        ],
        "rule_sql": []
    },
    "847": {
        "question": "What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 19 ORDER BY T1.q2 ASC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference `drivers` as `T2` with alias `T2.surname` instead of `d.surname`. Do specify the join condition as `T2.driverId = T1.driverId` instead of `q.driverId = d.driverId` for consistent table reference order. Do remove the filter `q.q2 IS NOT NULL` instead of keeping it since the ORDER BY ASC with LIMIT 1 naturally handles NULL values by placing them last. Do maintain the `WHERE T1.raceId = 19` filter, `ORDER BY T1.q2 ASC` sorting, and `LIMIT 1` clause unchanged. The amended query now correctly returns the fastest qualifying driver for race 19 without unnecessary NULL filtering."
        ],
        "rules": [
            "1) When the question asks for the best lap time in a specific qualifying period: rank drivers by their qualifying time in ascending order (fastest first) and keep only the top 1 result. 2) When filtering for a specific race number: include only rows where T1.raceId equals the exact numeric value 19. 3) When combining qualifying and driver information: link rows where T1.driverId equals T2.driverId and keep only matching pairs (inner match). 4) When handling qualifying times: do not explicitly filter out NULL values as the ascending ordering naturally places them last. 5) Output columns (ordered): T2.surname"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.surname \nFROM qualifying q \nJOIN drivers d ON q.driverId = d.driverId \nWHERE q.raceId = 19 \nAND q.q2 IS NOT NULL \nORDER BY q.q2 ASC \nLIMIT 1;",
            "SELECT T2.surname \nFROM qualifying T1 \nINNER JOIN drivers T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 19 \nORDER BY T1.q2 ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT d.surname \nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 19 \nAND q.q2 IS NOT NULL\nORDER BY q.q2 ASC\nLIMIT 1"
        ]
    },
    "381": {
        "question": "List down the name of artists for cards in Chinese Simplified.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
        "amends": [],
        "rules": [
            "Chinese Simplified' is the language;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.artist\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Chinese Simplified';"
        ],
        "rule_sql": []
    },
    "449": {
        "question": "What is the language of the card that has azorius watermark? List out the type of this card.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T2.language, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'azorius'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT fd.language, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'azorius';"
        ],
        "rule_sql": []
    },
    "584": {
        "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "amends": [
            "Do use `INNER JOIN` between `posts` and `postHistory` instead of querying `comments` table with a subquery. Do select `T2.Comment` instead of selecting all columns from `comments`. Do filter directly on `T1.Title` in the `WHERE` clause instead of using a CTE with a subquery. Do remove the `DISTINCT` operation and CTE structure instead of keeping the complex nested query approach. Do eliminate the unnecessary `comments` table join and subquery filtering instead of maintaining the indirect relationship through user IDs. The amended query now correctly retrieves comments directly from postHistory for the specified post title, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for comments from users who edited a specific post: retrieve comments directly from the postHistory table instead of joining through the comments table.\n2) When filtering for a specific post title: use a direct equality filter on T1.Title with the exact literal 'Why square the difference instead of taking the absolute value in standard deviation?'.\n3) When selecting output columns: return only the Comment column from the postHistory table.\n4) When combining tables is not required for this question: avoid unnecessary joins and subqueries, working directly with the postHistory table.\n5) When the question involves user edits on a post: recognize that postHistory contains both edit actions and comments related to posts.\nOutput columns (ordered): T1.Comment"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH target_post AS (\n    SELECT Id \n    FROM posts \n    WHERE Title = 'Why square the difference instead of taking the absolute value in standard deviation?'\n),\neditors AS (\n    SELECT DISTINCT UserId \n    FROM postHistory \n    WHERE PostId IN (SELECT Id FROM target_post)\n)\nSELECT c.* \nFROM comments c\nWHERE c.UserId IN (SELECT UserId FROM editors);",
            "SELECT T2.Comment\nFROM posts T1\nINNER JOIN postHistory T2 ON T1.Id = T2.PostId\nWHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'"
        ],
        "rule_sql": [
            "SELECT Comment FROM postHistory WHERE PostId IN (SELECT Id FROM posts WHERE Title = 'Why square the difference instead of taking the absolute value in standard deviation?') AND Comment IS NOT NULL"
        ]
    },
    "1453": {
        "question": "List the name of events with less than average parking cost.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T2.category = 'Parking' AND T3.cost < (SELECT AVG(cost) FROM expense)",
        "amends": [
            "Do add `INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget` instead of omitting the expense table join. Do change the filter to `T3.cost < (SELECT AVG(cost) FROM expense)` instead of `b.spent < (SELECT AVG(spent) FROM budget WHERE category = 'Parking')` to compare against expense costs rather than budget spent amounts. Do remove the `WHERE category = 'Parking'` condition from the subquery instead of keeping it, as the average should be calculated across all expenses. The amended query now correctly filters events based on parking-related expenses below the average expense cost, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for events with parking cost below average: join the expense table T3 to budget table T2 using T2.budget_id = T3.link_to_budget to access parking cost information.\n2) When comparing against average expense cost: filter for events where T3.cost is less than the average of all expense costs (not just parking expenses).\n3) When calculating the average for comparison: compute the average cost across all expenses in the expense table without category restrictions.\n4) When the question mentions \"parking cost\": use T3.cost from the expense table rather than budget spent amounts.\n5) Output columns (ordered): T1.event_name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.category = 'Parking'\nAND b.spent < (SELECT AVG(spent) FROM budget WHERE category = 'Parking');",
            "SELECT DISTINCT e.event_name\nFROM event e\nINNER JOIN budget b ON e.event_id = b.link_to_event\nINNER JOIN expense T3 ON b.budget_id = T3.link_to_budget\nWHERE b.category = 'Parking'\nAND T3.cost < (SELECT AVG(cost) FROM expense);"
        ],
        "rule_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.cost < (SELECT AVG(cost) FROM expense)\nGROUP BY e.event_id, e.event_name;"
        ]
    },
    "749": {
        "question": "Provide the superpowers of the superhero called Deathlok.",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Deathlok'",
        "amends": [],
        "rules": [
            "superpowers refers to power_name; Deathlok refers to superhero_name = 'Deathlok'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Deathlok';"
        ],
        "rule_sql": []
    },
    "318": {
        "question": "What is the molecule id of bond id TR001_1_7?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';"
        ],
        "rule_sql": []
    },
    "1180": {
        "question": "Was the patient a man or a women whose ALT glutamic pylvic transaminase status got 9 on 1992-6-12?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT = 9.0 AND T2.Date = '1992-06-12'",
        "amends": [],
        "rules": [
            "man refers to SEX = 'M'; women refers to SEX = 'F'; ALT glutamic pylvic transaminase status got 9 GPT = '9'; 1992/6/12 refers to Date = '1992-06-12'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT = 9 AND l.Date = '1992-06-12';"
        ],
        "rule_sql": []
    },
    "689": {
        "question": "Identify the display name and location of the user, who was the last to edit the post with ID 183.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.DisplayName, T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 183 ORDER BY T1.LastEditDate DESC LIMIT 1",
        "amends": [
            "Do join on `T1.OwnerUserId = T2.Id` instead of `p.LastEditorUserId = u.Id` for the correct user association. Do add `ORDER BY T1.LastEditDate DESC LIMIT 1` instead of omitting ordering and limiting to ensure only the most recent edit is returned. Do use table aliases `T1` and `T2` instead of full table names for consistency. The amended query now correctly retrieves the post owner's information rather than the last editor's details and ensures only a single result is returned based on the most recent edit date."
        ],
        "rules": [
            "1) When the question asks for information about a user who edited a post: use the OwnerUserId to Id join condition (T1.OwnerUserId = T2.Id) instead of LastEditorUserId to Id for correct user association.\n2) When identifying the last editor of a post: order results by LastEditDate in descending order and keep only the first row to ensure the most recent edit is returned.\n3) When using table aliases for this schema: refer to the posts table as T1 and the users table as T2 consistently.\n4) When filtering for a specific post by ID: use the exact literal value 183 for the Id column condition.\n5) Output columns (ordered): T2.DisplayName, T2.Location"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName, u.Location\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE p.Id = 183;",
            "SELECT T2.DisplayName, T2.Location \nFROM posts T1 \nJOIN users T2 ON T1.OwnerUserId = T2.Id \nWHERE T1.Id = 183 \nORDER BY T1.LastEditDate DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.DisplayName, T2.Location\nFROM posts T1\nJOIN users T2 ON T1.OwnerUserId = T2.Id\nWHERE T1.Id = 183\nORDER BY T1.LastEditDate DESC\nLIMIT 1"
        ]
    },
    "710": {
        "question": "In posts with 1 comment, how many of the comments have 0 score?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do reference the `comments` table as `T1` instead of `c` and `posts` as `T2` instead of `p` for consistent aliasing. Do filter on `T2.Score = 0` instead of `c.Score = 0` to check the post's score rather than the comment's score, which correctly identifies posts with zero score that have exactly one comment. The amended query now matches the intended behavior of counting comments from posts with zero score and exactly one comment."
        ],
        "rules": [
            "1) When counting comments: use COUNT(T1.id) to count specific non-null values instead of COUNT(*). 2) When referencing the comments table: use alias T1 instead of c. 3) When referencing the posts table: use alias T2 instead of p. 4) When filtering for posts with zero score: use T2.Score = 0 instead of checking comment score. 5) When filtering for posts with exactly one comment: use T2.CommentCount = 1. 6) When combining comments and posts tables: link rows where T1.PostId = T2.Id to match comments to their posts. 7) Output columns (ordered): COUNT(T1.id) AS ZeroScoreCommentsCount"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS ZeroScoreCommentsCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.CommentCount = 1 AND c.Score = 0;",
            "SELECT COUNT(T1.Id) \nFROM comments T1\nJOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Score = 0\nAND T2.CommentCount = 1"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) AS ZeroScoreCommentsCount \nFROM comments T1 \nJOIN posts T2 ON T1.PostId = T2.Id \nWHERE T2.CommentCount = 1 AND T2.Score = 0"
        ]
    },
    "812": {
        "question": "List down at least five full names of superheroes with blue eyes.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5",
        "amends": [
            "Do use `superhero_name` instead of `full_name` for the column selection. Do alias the superhero table as `T1` instead of leaving it unaliased. Do use `INNER JOIN` explicitly instead of just `JOIN` for the join type. Do alias the colour table as `T2` instead of leaving it unaliased. The amended query now correctly retrieves superhero names with blue eye color using proper table aliases and explicit join syntax."
        ],
        "rules": [
            "1) When the question asks for \"full names of superheroes\": use the exact column token T1.superhero_name instead of T1.full_name. 2) When combining the superhero and colour tables: link rows where T1.eye_colour_id equals T2.id and keep only matching pairs (inner match). 3) When filtering for superheroes with blue eyes: include only rows where T2.colour equals exactly 'Blue'. 4) When the question specifies \"at least five\": take the first 5 rows from the result set. 5) When the question asks for a list of names: output only the superhero names without additional columns. Output columns (ordered): T1.superhero_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE c.colour = 'Blue'\nLIMIT 5;",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T2.colour = 'Blue'\nLIMIT 5;"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T2.colour = 'Blue'\nLIMIT 5"
        ]
    },
    "850": {
        "question": "Please give the name of the race held on the circuits in Germany.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "amends": [],
        "rules": [
            "Germany is a name of country;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name AS race_name\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Germany';"
        ],
        "rule_sql": []
    },
    "211": {
        "question": "Indicate which atoms are connected in non-carcinogenic type molecules.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.label = '-'",
        "amends": [
            "Do select only `T1.atom_id` instead of multiple columns `c.atom_id, c.atom_id2, c.bond_id`. Do use `DISTINCT` instead of omitting it to eliminate duplicates. Do reference tables with aliases `T1, T2, T3` instead of `c, a1, a2, m`. Do join `atom AS T1` directly to `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of joining through multiple atom tables. Do join `connected AS T3` on `T1.atom_id = T3.atom_id` instead of joining both atom_id and atom_id2 to separate atom tables. Do apply the filter `T2.label = '-'` directly instead of the same condition. Do remove the unnecessary second atom table join and bond_id column selection. The amended query now correctly returns distinct atom IDs from molecules labeled '-' that have connections, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for atoms connected in non-carcinogenic type molecules: filter molecules where T2.label equals '-' exactly. 2) When selecting atom identifiers from connected structures: use DISTINCT T1.atom_id to eliminate duplicate atom entries. 3) When combining molecule and atom information: link T1 and T2 where T1.molecule_id equals T2.molecule_id to associate atoms with their molecules. 4) When identifying connected atoms: join T3 to T1 where T1.atom_id equals T3.atom_id to find connections originating from each atom. 5) When handling molecule types: preserve the exact literal '-' for the label filter without case or spacing changes. 6) When producing output: include only the distinct atom identifiers without additional connection details. Output columns (ordered): T1.atom_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.atom_id, c.atom_id2, c.bond_id\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nJOIN molecule m ON a1.molecule_id = m.molecule_id\nWHERE m.label = '-';",
            "SELECT DISTINCT T1.atom_id\nFROM atom AS T1\nJOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nJOIN connected AS T3 ON T1.atom_id = T3.atom_id\nWHERE T2.label = '-'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.atom_id\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nJOIN connected T3 ON T1.atom_id = T3.atom_id\nWHERE T2.label = '-'"
        ]
    },
    "260": {
        "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
        "amends": [],
        "rules": [
            "triple bond refers to bond_type = '#'; phosphorus refers to element = 'p'; bromine refers to element = 'br'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(a.atom_id) AS total_atoms\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE b.bond_type = '#' AND (a.element = 'p' OR a.element = 'br');"
        ],
        "rule_sql": []
    },
    "1285": {
        "question": "When is the latest patient's medical data recorded? This patient should have an abnormal level of lactate dehydrogenase.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH >= 500 ORDER BY T1.`First Date` DESC LIMIT 1",
        "amends": [
            "Do select `First Date` from the Patient table instead of `Date` from the Laboratory table. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `JOIN` without aliases. Do remove the subquery that finds the patient with maximum `First Date` instead of keeping it, as the correct logic requires finding the maximum date among patients with high LDH values rather than filtering to a specific patient. Do add `ORDER BY T1.First Date DESC LIMIT 1` instead of omitting it, to retrieve only the most recent date from qualifying records. Do keep the `LDH >= 500` filter in the WHERE clause instead of changing it. The amended query now correctly identifies the most recent first date from patients with elevated LDH levels, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the latest date of medical data for patients with abnormal lactate dehydrogenase: select the maximum \"First Date\" from the Patient table instead of \"Date\" from the Laboratory table.\n2) When combining Patient and Laboratory tables: use an inner join where T1.ID = T2.ID, keeping only matching pairs.\n3) When filtering for abnormal lactate dehydrogenase levels: include only records where T2.LDH >= 500.\n4) When finding the most recent date: order results by T1.\"First Date\" in descending order and take only the first result.\n5) Output columns (ordered): T1.\"First Date\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.Date\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.ID = (SELECT ID FROM Patient WHERE `First Date` = (SELECT MAX(`First Date`) FROM Patient))\nAND l.LDH >= 500;",
            "SELECT T1.`First Date`\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH >= 500\nORDER BY T1.`First Date` DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.\"First Date\"\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH >= 500\nORDER BY T1.\"First Date\" DESC\nLIMIT 1"
        ]
    },
    "131": {
        "question": "Which district has highest active loan?",
        "db_id": "financial",
        "ground_truth": "SELECT T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.status IN ('C', 'D') GROUP BY T2.A3 ORDER BY SUM(T3.amount) DESC LIMIT 1",
        "amends": [
            "Do select only `T2.A3` instead of selecting both `d.A3` and `COUNT(l.loan_id)`. Do use table aliases `T1`, `T2`, and `T3` instead of `a`, `d`, and `l`. Do change the join order to start with `account AS T1` instead of starting with `loan l`. Do use `INNER JOIN` consistently for all joins instead of mixing `JOIN` and `INNER JOIN`. Do change the WHERE filter to reference `T3.status` instead of `l.status`. Do remove the `COUNT(l.loan_id)` aggregation and instead use `SUM(T3.amount)` in the ORDER BY clause instead of ordering by `active_loan_count`. Do remove the alias `active_loan_count` from the output since it's no longer selected. Do change the GROUP BY to reference `T2.A3` instead of `d.A3`. The amended query now correctly orders by the sum of loan amounts for active loans rather than counting loans, matching the RIGHT_SQL's behavior.",
            "Do filter on `T3.status IN ('C', 'D')` instead of `T3.status = 'A'` in the WHERE clause to include different loan status values. The amended query now matches RIGHT_SQL's behavior by correctly filtering for the specified status conditions."
        ],
        "rules": [
            "1) When the question asks for the district with highest active loan: select only T2.A3 as the output column. 2) When combining account, district, and loan tables: start with account as T1, then join district as T2 on T1.district_id = T2.district_id, then join loan as T3 on T1.account_id = T3.account_id using inner joins for all connections. 3) When filtering for active loans: include only rows where T3.status is in ('C', 'D'). 4) When grouping by district: organize results by T2.A3. 5) When determining the highest active loan: order rows by the sum of T3.amount in descending direction and keep only the first row. 6) When computing aggregate values for ordering: use SUM(T3.amount) rather than counting loan entities. 7) Output columns (ordered): T2.A3",
            "1) When the question asks for the district with highest active loan: filter loan records where T3.status IN ('C', 'D') instead of T3.status = 'A' to include the correct active loan status values.\n2) When combining account, district, and loan tables: link rows where T1.district_id = T2.district_id and T1.account_id = T3.account_id using inner matches.\n3) When grouping by district: organize results by T2.A3 to compute aggregates per district.\n4) When finding the highest loan amount: order districts by SUM(T3.amount) in descending order and keep only the top result.\n5) Output columns (ordered): T2.A3"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.A3 AS district_name, COUNT(l.loan_id) AS active_loan_count\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.status IN ('C', 'D')\nGROUP BY d.A3\nORDER BY active_loan_count DESC\nLIMIT 1;",
            "SELECT T2.A3\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.status = 'A'\nGROUP BY T2.A3\nORDER BY SUM(T3.amount) DESC\nLIMIT 1;",
            "SELECT T2.A3\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.status IN ('C', 'D')\nGROUP BY T2.A3\nORDER BY SUM(T3.amount) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.A3\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.status IN ('C', 'D')\nGROUP BY T2.A3\nORDER BY SUM(T3.amount) DESC\nLIMIT 1;"
        ]
    },
    "171": {
        "question": "What was the difference in the number of crimes committed in East and North Bohemia in 1996?",
        "db_id": "financial",
        "ground_truth": "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district",
        "amends": [
            "Do use a single query with conditional aggregation using `IIF` functions instead of separate subqueries for each region. Do calculate the difference as `SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0))` instead of subtracting North Bohemia from East Bohemia in reverse order. Do handle case sensitivity by using lowercase region names `'east Bohemia'` and `'north Bohemia'` instead of title case `'North Bohemia'` and `'East Bohemia'`. Do remove the `AS crime_difference` alias instead of keeping it since the right query doesn't include an explicit alias. The amended query now correctly calculates the crime difference between east and north Bohemia regions in a single table scan with proper case handling."
        ],
        "rules": [
            "1) When the question asks for a difference between two regions: use conditional aggregation with IIF functions to sum values for each region in a single table scan instead of separate subqueries. 2) When handling region names in the district table: use lowercase 'east Bohemia' and 'north Bohemia' exactly as specified in the A3 column instead of title case variants. 3) When calculating the difference between regions: compute SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) to get the correct directional difference. 4) When the output does not require an explicit alias: omit the AS clause for the result column. 5) Output columns (ordered): the computed difference value without column alias"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT SUM(A16) FROM district WHERE A3 = 'North Bohemia') - \n    (SELECT SUM(A16) FROM district WHERE A3 = 'East Bohemia') AS crime_difference;",
            "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district WHERE A16 IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district;"
        ]
    },
    "593": {
        "question": "How many users from New York have a teacher and supporter badge?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(DISTINCT T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name IN ('Supporter', 'Teacher') AND T2.Location = 'New York'",
        "amends": [
            "Do join `badges` as the primary table instead of starting from `users`, and use `INNER JOIN` with `users` on `badges.UserId = users.Id` instead of multiple joins from `users` to `badges`. Do filter badge names with `IN ('Supporter', 'Teacher')` instead of separate joins for each badge type. Do move the location filter to the `WHERE` clause on the joined `users` table instead of applying it to the original `users` table. Do count distinct user IDs from the `users` table instead of from the original `users` table, and remove the alias `UserCount` instead of keeping it. The amended query now correctly counts users who have both badge types in New York by using a single join with an IN condition rather than multiple joins that would require both badges to exist separately.",
            "Do reference `T1.Id` instead of `users.Id` in the SELECT clause, and use table aliases `T1` for `badges` and `T2` for `users` instead of the original table names. Do place the filter on `T1.Name IN ('Supporter', 'Teacher')` before the `T2.Location = 'New York'` condition in the WHERE clause instead of the reverse order, and ensure the join condition uses `T1.UserId = T2.Id` with proper alias references instead of `badges.UserId = users.Id`. The amended query now correctly counts distinct user IDs from the badges table that have specific badge names while belonging to users located in New York, matching the RIGHT_SQL's behavior.",
            "Do count `T1.Id` instead of `T2.Id` in the SELECT clause, as the badges table contains the relevant IDs for counting distinct badge recipients rather than counting user IDs from the users table. The amended query now correctly counts distinct badge IDs from the badges table while maintaining the same join condition and filtering logic, ensuring it matches the RIGHT_SQL's behavior of accurately counting badges rather than users."
        ],
        "rules": [
            "1) When the question asks for users from a specific location: filter users by the exact location literal 'New York' using users.Location.\n2) When the question asks for users with multiple badge types: filter badges by the exact badge names 'Supporter' and 'Teacher' using badges.Name IN ('Supporter', 'Teacher').\n3) When combining users and badges tables: link rows where badges.UserId equals users.Id and keep only matching pairs (inner match).\n4) When counting distinct users: compute the number of unique users.Id values.\n5) When the question requires both badge types for the same user: ensure the query structure allows a single user to have multiple badges that satisfy the badge name conditions.\nOutput columns (ordered): COUNT(DISTINCT users.Id)",
            "1) When counting distinct users: use T1.Id as the counting key instead of users.Id. 2) When assigning table aliases: use T1 for badges and T2 for users. 3) When filtering badge names: place the condition T1.Name IN ('Supporter', 'Teacher') before the location condition. 4) When filtering user location: use T2.Location = 'New York' with exact case and spacing. 5) When joining badges and users: link rows where T1.UserId = T2.Id and keep only matching pairs (inner match). 6) Output columns (ordered): COUNT(DISTINCT T1.Id)",
            "1) When counting distinct badge recipients from the badges table: use T1.Id as the counting key instead of T2.Id from the users table.\n2) When filtering for users from a specific location: use T2.Location = 'New York' with exact case and spacing.\n3) When filtering for specific badge types: use T1.Name IN ('Supporter', 'Teacher') with exact case and punctuation.\n4) When combining badges and users tables: link rows where T1.UserId = T2.Id and keep only matching pairs (inner match).\n5) Output columns (ordered): COUNT(DISTINCT T1.Id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT u.Id) AS UserCount\nFROM users u\nJOIN badges b1 ON u.Id = b1.UserId AND b1.Name = 'Teacher'\nJOIN badges b2 ON u.Id = b2.UserId AND b2.Name = 'Supporter'\nWHERE u.Location = 'New York';",
            "SELECT COUNT(DISTINCT users.Id) \nFROM badges \nINNER JOIN users ON badges.UserId = users.Id \nWHERE users.Location = 'New York' \nAND badges.Name IN ('Supporter', 'Teacher')",
            "SELECT COUNT(DISTINCT T2.Id) \nFROM badges T1 \nINNER JOIN users T2 ON T1.UserId = T2.Id \nWHERE T1.Name IN ('Supporter', 'Teacher') \nAND T2.Location = 'New York'",
            "SELECT COUNT(DISTINCT T1.Id) \nFROM badges T1 \nINNER JOIN users T2 ON T1.UserId = T2.Id \nWHERE T1.Name IN ('Supporter', 'Teacher') \nAND T2.Location = 'New York'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Id) \nFROM badges T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T1.Name IN ('Supporter', 'Teacher')\nAND T2.Location = 'New York'"
        ]
    },
    "1156": {
        "question": "State the ID and age of patient with positive degree of coagulation.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.RVVT = '+'",
        "amends": [],
        "rules": [
            "age refers to SUBTRACT(year(current_timestamp), year(Birthday)); positive degree of coagulation refers to RVVT = '+';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE E.RVVT = '+';"
        ],
        "rule_sql": []
    },
    "1133": {
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do place the `birthday` filter before the `player_name` filter instead of after it for potential performance optimization. Do use `birthday > '1990'` instead of `birthday > '1990-12-31'` to include all players born after the year 1990 rather than only those born after December 31st, 1990. The amended query now correctly counts players with 'Aaron' names born after 1990."
        ],
        "rules": [
            "1) When counting entities: count using the canonical key \"id\" instead of counting all rows to avoid including NULL values.\n2) When filtering by date ranges: use 'birthday > \"1990\"' instead of 'birthday > \"1990-12-31\"' to include all players born after the year 1990 rather than only those born after December 31st, 1990.\n3) When optimizing query performance: place the \"birthday\" filter before the \"player_name\" filter in the filtering sequence.\n4) When filtering for players with a specific first name: use exact string matching for \"player_name\" starting with \"Aaron\" to find players whose names begin with that string.\nOutput columns (ordered): COUNT(id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Aaron%' AND birthday > '1990-12-31';",
            "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'"
        ],
        "rule_sql": [
            "SELECT COUNT(id) \nFROM Player \nWHERE birthday > '1990' \nAND player_name LIKE 'Aaron%';"
        ]
    },
    "1303": {
        "question": "When is the birthday of the oldest patient whose blood glucose is abnormal?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU > 180 ORDER BY T1.Birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "oldest patient refers to MIN(Birthday); blood glucose is abnormal refers to GLU > 180;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(P.Birthday) AS OldestPatientBirthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.GLU > 180;"
        ],
        "rule_sql": []
    },
    "174": {
        "question": "What year was account owner number 130 born?",
        "db_id": "financial",
        "ground_truth": "SELECT STRFTIME('%Y', T1.birth_date) FROM client AS T1 INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T2 ON T3.account_id = T2.account_id WHERE T2.account_id = 130",
        "amends": [
            "Do add `INNER JOIN disp AS T3 ON T1.client_id = T3.client_id` and `INNER JOIN account AS T2 ON T3.account_id = T2.account_id` instead of querying only the `client` table. Do change the filter to `T2.account_id = 130` instead of `client_id = 130` to reference the account table instead of the client table. Do remove the alias `AS birth_year` from the `STRFTIME` expression instead of keeping it. Do use table aliases `T1.birth_date` instead of just `birth_date` to specify the table source. The amended query now correctly joins the client, disp, and account tables to find clients associated with a specific account ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about account owner information by account number: join client table as T1, disp table as T3, and account table as T2 using the exact key relationships T1.client_id = T3.client_id and T3.account_id = T2.account_id. 2) When filtering by account number 130: use the exact literal value 130 with the account table's account_id column as T2.account_id = 130. 3) When extracting year from a date column: extract the year component from T1.birth_date without adding an alias to the result. 4) When referencing columns from joined tables: use the exact table aliases T1, T2, T3 as established in the join pattern. 5) Output columns (ordered): strftime('%Y', T1.birth_date)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT strftime('%Y', birth_date) AS birth_year FROM client WHERE client_id = 130;",
            "SELECT STRFTIME('%Y', T1.birth_date) FROM client AS T1 INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T2 ON T3.account_id = T2.account_id WHERE T2.account_id = 130"
        ],
        "rule_sql": [
            "SELECT strftime('%Y', T1.birth_date) FROM client T1 JOIN disp T3 ON T1.client_id = T3.client_id JOIN account T2 ON T3.account_id = T2.account_id WHERE T2.account_id = 130"
        ]
    },
    "916": {
        "question": "Please list the surnames of all the Italian drivers.",
        "db_id": "formula_1",
        "ground_truth": "SELECT surname FROM drivers WHERE nationality = 'Italian'",
        "amends": [],
        "rules": [
            "Italian refers to nationality = 'italian'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT surname FROM drivers WHERE nationality = 'Italian';"
        ],
        "rule_sql": []
    },
    "97": {
        "question": "List out the id number of client who choose statement of issuance after transaction are Disponent?",
        "db_id": "financial",
        "ground_truth": "SELECT T2.client_id FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND T2.type = 'DISPONENT'",
        "amends": [
            "Do select `client_id` from the `disp` table instead of selecting `d.client_id` with a DISTINCT modifier. Do join `account` and `disp` tables with an `INNER JOIN` on `account_id` instead of using separate JOIN clauses with additional table references. Do filter on `frequency = 'POPLATEK PO OBRATU'` from the account table instead of filtering on `k_symbol = 'POPLATEK PO OBRATU'` from a non-existent trans table join. Do filter on `type = 'DISPONENT'` instead of `type = 'Disponent'` to match the correct case sensitivity. Do remove the unnecessary DISTINCT modifier and the incorrect trans table join entirely instead of including them. The amended query now correctly identifies clients with disposition accounts that have the specified frequency, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting client identifiers from the disp table: use client_id from the disp table without DISTINCT modifier.\n2) When joining account and disp tables: use an inner join on account_id between account and disp tables.\n3) When filtering for disposition type: use type = 'DISPONENT' with exact case sensitivity.\n4) When filtering for account frequency: use frequency = 'POPLATEK PO OBRATU' from the account table.\n5) When the question asks for clients with disposition accounts having specific frequency: do not join the trans table.\n6) Output columns (ordered): client_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT d.client_id\nFROM disp d\nJOIN account a ON d.account_id = a.account_id\nJOIN trans t ON a.account_id = t.account_id\nWHERE d.type = 'Disponent'\nAND t.k_symbol = 'POPLATEK PO OBRATU';",
            "SELECT client_id FROM disp INNER JOIN account ON disp.account_id = account.account_id WHERE account.frequency = 'POPLATEK PO OBRATU' AND disp.type = 'DISPONENT'"
        ],
        "rule_sql": [
            "SELECT disp.client_id\nFROM account\nINNER JOIN disp ON account.account_id = disp.account_id\nWHERE disp.type = 'DISPONENT'\nAND account.frequency = 'POPLATEK PO OBRATU'"
        ]
    },
    "628": {
        "question": "Which users have the highest number of views?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Id, DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "amends": [
            "Do select `Id` and `DisplayName` instead of `DisplayName` and `Views`. Do add a `WHERE` clause with a subquery `SELECT MAX(Views) FROM users` instead of using `ORDER BY Views DESC LIMIT 1`. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly identifies users with maximum views using a subquery rather than relying on ordering and limiting, ensuring all users with the maximum view count are returned rather than just one arbitrary user with high views."
        ],
        "rules": [
            "1) When the question asks for users with the highest number of views: select the exact columns \"Id\" and \"DisplayName\" from the users table. 2) When identifying maximum views: use a subquery to find the maximum value of the \"Views\" column from the users table. 3) When filtering for users with maximum views: include only rows where \"Views\" equals the maximum value found in the subquery. 4) When the question asks for highest number: do not use ordering or limiting clauses, instead use equality comparison with the maximum value. 5) Output columns (ordered): \"Id\", \"DisplayName\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DisplayName, Views FROM users ORDER BY Views DESC LIMIT 1;",
            "SELECT Id, DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users)"
        ],
        "rule_sql": [
            "SELECT Id, DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users)"
        ]
    },
    "806": {
        "question": "Provide the eye colour of the superhero who has Karen Beecher-Duncan as their full name.",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Karen Beecher-Duncan'",
        "amends": [],
        "rules": [
            "eye colour refers to colour.colour where eye_colour_id = colour.id; Karen Beecher-Duncan is the full name of superhero;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.full_name = 'Karen Beecher-Duncan';"
        ],
        "rule_sql": []
    },
    "62": {
        "question": "What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(T2.School) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.Charter = 0 AND CAST(T1.`Free Meal Count (K-12)` AS REAL) * 100 / T1.`Enrollment (K-12)` < 0.18",
        "amends": [],
        "rules": [
            "non-chartered schools refer to schools whose Charter = 0; K-12 means grades 1 through 12; percent of eligible free rate for K-12 = `Free Meal Count (K-12)` * 100 / `Enrollment (K-12)`"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS TotalNonCharteredSchools\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.Charter = 0\nAND s.County = 'Los Angeles'\nAND (f.[Free Meal Count (K-12)] * 100.0 / f.[Enrollment (K-12)]) < 0.18;"
        ],
        "rule_sql": []
    },
    "159": {
        "question": "List all the withdrawals in cash transactions that the client with the id 3356 makes.",
        "db_id": "financial",
        "ground_truth": "SELECT T4.trans_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 3356 AND T4.operation = 'VYBER'",
        "amends": [
            "Do select `T4.trans_id` instead of `t.*` to return only transaction IDs instead of all transaction columns. Do add joins through `client AS T1` and `account AS T3` instead of omitting them, establishing the proper relationship path from client to transactions. Do use `INNER JOIN` on `T1.client_id = T2.client_id` instead of missing the client table entirely. Do use `INNER JOIN` on `T2.account_id = T3.account_id` instead of joining directly from disposition to transactions without the account intermediary. Do use `INNER JOIN` on `T3.account_id = T4.account_id` instead of joining directly on `t.account_id = d.account_id` which misses the proper account relationship. Do filter on `T1.client_id = 3356` instead of `d.client_id = 3356` to use the client table's primary key. The amended query now correctly navigates the relationship hierarchy from client through disposition and account to transactions, matching the RIGHT_SQL's behavior.",
            "Do use `T4.operation = 'VYBER'` instead of `T4.operation = 'VYBER KARTOU'` in the WHERE clause. Do remove the `AND T4.type = 'VYDAJ'` filter instead of keeping it, as the right query only requires the operation condition without the additional type constraint. The amended query now correctly filters for transactions with operation 'VYBER' only, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for withdrawals in cash transactions for a specific client ID: filter transactions where T4.operation equals 'VYBER' exactly and T1.client_id equals 3356 exactly. 2) When navigating relationships between client, disposition, account, and transaction tables: link T1 to T2 using T1.client_id = T2.client_id, link T2 to T3 using T2.account_id = T3.account_id, and link T3 to T4 using T3.account_id = T4.account_id, keeping only matching pairs (inner match). 3) When selecting output columns for transaction listings: return only T4.trans_id instead of all transaction columns. Output columns (ordered): T4.trans_id",
            "1) When the question asks for withdrawals in cash transactions for a specific client id: filter transactions where T4.operation equals exactly 'VYBER' (not 'VYBER KARTOU'). 2) When filtering transactions by operation type: do not include additional type constraints like T4.type = 'VYDAJ' when only operation filtering is required. 3) When joining client to transaction data: use the exact join path T1.client_id = T2.client_id, T2.account_id = T3.account_id, and T3.account_id = T4.account_id to connect client to their transactions. 4) When querying for a specific client: filter using T1.client_id = 3356 with the exact numeric value. 5) Output columns (ordered): T4.trans_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.*\nFROM trans t\nJOIN disp d ON t.account_id = d.account_id\nWHERE d.client_id = 3356 AND t.operation = 'VYBER';",
            "SELECT T4.trans_id\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN account AS T3 ON T2.account_id = T3.account_id\nINNER JOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 3356\nAND T4.operation = 'VYBER KARTOU'\nAND T4.type = 'VYDAJ'",
            "SELECT T4.trans_id\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN account AS T3 ON T2.account_id = T3.account_id\nINNER JOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 3356\nAND T4.operation = 'VYBER'"
        ],
        "rule_sql": [
            "SELECT T4.trans_id\nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN account T3 ON T2.account_id = T3.account_id\nINNER JOIN trans T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 3356\nAND T4.operation = 'VYBER'"
        ]
    },
    "1196": {
        "question": "What is the most common sign of patients with SLE disease?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1",
        "amends": [
            "Do select only `Symptoms` instead of including `COUNT(*) AS Frequency` in the SELECT list. Do order by `COUNT(Symptoms) DESC` instead of ordering by the alias `Frequency DESC`. Do remove the explicit column alias `AS Frequency` instead of keeping it since it's no longer needed in the ORDER BY clause. The amended query now correctly returns the most frequent symptom for SLE diagnoses by counting occurrences per symptom and ordering by that count directly rather than through an alias that isn't available in the ORDER BY context."
        ],
        "rules": [
            "1) When the question asks for the most common sign of patients with SLE disease: count occurrences of each Symptoms value where Diagnosis equals 'SLE' exactly. 2) When counting occurrences per symptom: use the exact column token Symptoms for counting. 3) When ordering by frequency: order by the count of Symptoms in descending direction. 4) When selecting the most common: take only the first row after ordering by frequency. 5) Output columns (ordered): Symptoms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Symptoms, COUNT(*) AS Frequency\nFROM Examination\nWHERE Diagnosis = 'SLE'\nGROUP BY Symptoms\nORDER BY Frequency DESC\nLIMIT 1;",
            "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1"
        ]
    },
    "1010": {
        "question": "What is the lap record set by Lewis Hamilton in a Formula_1 race?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.time FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'",
        "amends": [
            "Do use `T1.time` instead of `d.forename, d.surname, r.fastestLapTime, ra.name, ra.date` in the SELECT list. Do join `lapTimes AS T1` instead of `results r` and `races ra` as the data source. Do use `INNER JOIN drivers AS T2` instead of `JOIN drivers d` with the corrected alias. Do specify the join condition `T1.driverId = T2.driverId` instead of `d.driverId = r.driverId` and `r.raceId = ra.raceId`. Do keep the WHERE filter `T2.forename = 'Lewis' AND T2.surname = 'Hamilton'` but remove the additional condition `r.fastestLapTime IS NOT NULL`. Do omit the ORDER BY and LIMIT clauses instead of including `ORDER BY r.fastestLapTime ASC LIMIT 1`. The amended query now correctly retrieves lap times from the lapTimes table instead of fastest lap times from results, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for lap records: use the lapTimes table (T1) as the data source instead of results or races tables. 2) When joining with driver information: use an inner join between lapTimes (T1) and drivers (T2) where T1.driverId equals T2.driverId. 3) When filtering for Lewis Hamilton: apply the condition T2.forename = 'Lewis' AND T2.surname = 'Hamilton' exactly as specified. 4) When selecting output columns: include only T1.time instead of multiple columns from different tables. 5) When retrieving lap records: do not apply ordering or limiting clauses as the question asks for all lap records set by the driver. Output columns (ordered): T1.time"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname, r.fastestLapTime, ra.name AS race_name, ra.date\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN races ra ON r.raceId = ra.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND r.fastestLapTime IS NOT NULL\nORDER BY r.fastestLapTime ASC\nLIMIT 1;",
            "SELECT T1.time \nFROM lapTimes AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'"
        ],
        "rule_sql": [
            "SELECT T1.time FROM lapTimes T1 INNER JOIN drivers T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'"
        ]
    },
    "1305": {
        "question": "How many patients accepted to the hospital have a normal level of white blood cells?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC BETWEEN 3.5 AND 9 AND T1.Admission = '+'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T2.WBC BETWEEN 3.5 AND 9` instead of `L.WBC BETWEEN 3.5 AND 9.0` to use integer comparison and remove the unnecessary decimal. Do place both filter conditions in the `WHERE` clause instead of keeping them there, maintaining the same logical structure. Do use table aliases `T1` and `T2` consistently instead of `P` and `L` for better readability. The amended query now correctly counts all patient records meeting the specified criteria without unnecessary distinct counting and matches the RIGHT_SQL's behavior.",
            "Do remove the `T1.Admission = 'Yes'` filter instead of keeping it, and do change the admission filter to `T1.Admission = '+'` instead of `T1.Admission = 'Yes'`. Do maintain the `INNER JOIN` on `T1.ID = T2.ID` and the `T2.WBC BETWEEN 3.5 AND 9` filter as they appear in both queries. The amended query now correctly filters for patients with admission status as '+' rather than 'Yes', matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs.\n2) When joining Patient and Laboratory tables: use INNER JOIN to explicitly specify inner matching between T1 and T2.\n3) When filtering for white blood cell levels: use T2.WBC BETWEEN 3.5 AND 9 to check for normal levels using integer comparison.\n4) When combining filter conditions: place both admission status and white blood cell conditions in the WHERE clause.\n5) When referencing table aliases: use T1 for Patient table and T2 for Laboratory table consistently.\n6) When checking admission status: use T1.Admission = '+' to identify patients accepted to the hospital.\nOutput columns (ordered): COUNT(T1.ID)",
            "1) When filtering for patients accepted to the hospital: use the exact literal '+' for the Admission column instead of 'Yes'. 2) When counting patients with normal white blood cells: maintain the WBC range filter between 3.5 AND 9. 3) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID using an inner match. 4) When counting patients: use T1.ID as the counting key. Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.Admission = '+' AND L.WBC BETWEEN 3.5 AND 9.0;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = 'Yes' \nAND T2.WBC BETWEEN 3.5 AND 9",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '+' \nAND T2.WBC BETWEEN 3.5 AND 9"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '+' \nAND T2.WBC BETWEEN 3.5 AND 9"
        ]
    },
    "21": {
        "question": "In Los Angeles how many schools have more than 500 free meals but less than 700 free or reduced price meals for K-12?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(CDSCode) FROM frpm WHERE `County Name` = 'Los Angeles' AND `Free Meal Count (K-12)` > 500 AND `FRPM Count (K-12)`< 700",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM frpm \nJOIN schools ON frpm.CDSCode = schools.CDSCode \nWHERE schools.County = 'Los Angeles' \nAND frpm.\"Free Meal Count (K-12)\" > 500 \nAND frpm.\"FRPM Count (K-12)\" < 700;"
        ],
        "rule_sql": []
    },
    "253": {
        "question": "List the elements of all the triple bonds.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T3.element FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select only `T3.element` instead of `a1.element` and `a2.element` with aliases. Do use `INNER JOIN` consistently instead of mixing `JOIN` without specification. Do join `atom` as `T3` only on `T2.atom_id = T3.atom_id` instead of joining twice on both `atom_id` and `atom_id2`. Do remove the second atom table join entirely instead of keeping it. Do add `DISTINCT` to eliminate duplicates instead of returning all rows. Do use table aliases `T1`, `T2`, `T3` consistently instead of mixed naming. Do remove the unnecessary `AS` keyword in column aliases instead of keeping it. The amended query now correctly returns distinct element values from atoms involved in bonds of type '#' without the redundant second join."
        ],
        "rules": [
            "1) When the question asks for elements of bonds with a specific type: filter bonds where T1.bond_type equals '#' exactly. 2) When combining bond and connected tables: link rows where T1.bond_id equals T2.bond_id exactly. 3) When combining connected and atom tables: link rows where T2.atom_id equals T3.atom_id exactly. 4) When retrieving element values from atoms: select only T3.element. 5) When eliminating duplicate element values: return only distinct values of T3.element. 6) When joining tables: use inner joins consistently to keep only matching pairs. 7) When using table aliases: refer to bond as T1, connected as T2, and atom as T3 consistently. 8) Output columns (ordered): T3.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = '#';",
            "SELECT DISTINCT T3.element\nFROM bond T1\nINNER JOIN connected T2 ON T1.bond_id = T2.bond_id\nINNER JOIN atom T3 ON T2.atom_id = T3.atom_id\nWHERE T1.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.element\nFROM bond T1\nINNER JOIN connected T2 ON T1.bond_id = T2.bond_id\nINNER JOIN atom T3 ON T2.atom_id = T3.atom_id\nWHERE T1.bond_type = '#'"
        ]
    },
    "893": {
        "question": "Name the top 3 drivers and the points they scored in the 2017 Chinese Grand Prix.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017 ORDER BY T2.points DESC LIMIT 3",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `driver_name`. Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `ds`, and `d`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do place the `year` filter after the `name` filter in the `WHERE` clause instead of before it. The amended query now correctly retrieves the top 3 drivers by points for the 2017 Chinese Grand Prix with proper column selection and explicit join specifications."
        ],
        "rules": [
            "1) When the question asks for top 3 drivers by points: rank rows by T2.points in descending order and keep the first 3 rows.\n2) When combining tables T1 (races), T2 (driverStandings), and T3 (drivers): link rows where T2.driverId = T3.driverId and T2.raceId = T1.raceId using inner matches only.\n3) When filtering for the 2017 Chinese Grand Prix: include only rows where T1.name = 'Chinese Grand Prix' and T1.year = 2017, with the name filter placed before the year filter.\n4) When selecting driver names: output individual columns T3.forename and T3.surname instead of concatenating them.\n5) Output columns (ordered): T3.forename, T3.surname, T2.points"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename || ' ' || d.surname AS driver_name, ds.points\nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nJOIN races r ON ds.raceId = r.raceId\nWHERE r.year = 2017 AND r.name = 'Chinese Grand Prix'\nORDER BY ds.points DESC\nLIMIT 3;",
            "SELECT T3.forename, T3.surname, T2.points\nFROM races T1\nINNER JOIN driverStandings T2 ON T1.raceId = T2.raceId\nINNER JOIN drivers T3 ON T2.driverId = T3.driverId\nWHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017\nORDER BY T2.points DESC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT T3.forename, T3.surname, T2.points\nFROM races T1\nINNER JOIN driverStandings T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers T3 ON T2.driverId = T3.driverId\nWHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017\nORDER BY T2.points DESC\nLIMIT 3"
        ]
    },
    "252": {
        "question": "What are the atoms that can bond with the atom that has the element lead?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'pb'",
        "amends": [
            "Do select `T2.atom_id` and `T2.atom_id2` instead of `a2.atom_id` and `a2.element`. Do use `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of complex `JOIN` conditions with `OR` clauses and self-join logic. Do remove the additional `atom a2` table join and the `a2.atom_id != a1.atom_id` filter instead of keeping them. Do simplify the `WHERE` clause to only filter `T1.element = 'pb'` instead of maintaining the original condition. The amended query now correctly identifies connected atoms through a direct join without redundant self-join logic and matches the RIGHT_SQL's behavior.",
            "Do remove the second `UNION` query block entirely instead of keeping it, as the right query only needs to find connections where lead atoms are the starting point. Do maintain the `SELECT T2.atom_id, T2.atom_id2` projection and `INNER JOIN connected T2 ON T1.atom_id = T2.atom_id` join condition instead of duplicating it with a reversed join, since the right logic correctly identifies connections originating from lead atoms without needing to also check connections ending at lead atoms. The amended query now matches RIGHT_SQL's behavior by focusing solely on connections where the lead atom is the source rather than both source and destination."
        ],
        "rules": [
            "1) When the question asks for atoms that can bond with a specific element: filter the base table T1 to find atoms where T1.element equals the exact literal 'pb'. 2) When connecting atoms through bonds: join table T2 using the exact key equality T1.atom_id = T2.atom_id to find connected atoms. 3) When retrieving connected atom identifiers: output both T2.atom_id and T2.atom_id2 to capture all bonding relationships. 4) Output columns (ordered): T2.atom_id, T2.atom_id2",
            "1) When the question asks for atoms that can bond with lead: identify connections where lead atoms are the starting point using T1.atom_id = T2.atom_id join condition. 2) When filtering for lead atoms: use the exact literal 'pb' for the element value in T1.element = 'pb'. 3) When selecting connected atoms: output both atom_id and atom_id2 from the connected table to show the bonding relationship. 4) When handling connections: do not include connections where lead atoms are the destination (atom_id2), only where they are the source (atom_id). 5) Output columns (ordered): T2.atom_id, T2.atom_id2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a2.atom_id, a2.element\nFROM atom a1\nJOIN connected c ON a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2\nJOIN atom a2 ON (a2.atom_id = c.atom_id OR a2.atom_id = c.atom_id2) AND a2.atom_id != a1.atom_id\nWHERE a1.element = 'pb';",
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'pb'\nUNION\nSELECT T2.atom_id, T2.atom_id2\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id2\nWHERE T1.element = 'pb'",
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'pb'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom T1\nJOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'pb'"
        ]
    },
    "143": {
        "question": "What are the accounts that have gold credit cards?",
        "db_id": "financial",
        "ground_truth": "SELECT T2.account_id FROM disp AS T2  INNER JOIN card AS T1 ON T1.disp_id = T2.disp_id  WHERE T1.type = 'gold'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT d.account_id\nFROM card c\nJOIN disp d ON c.disp_id = d.disp_id\nWHERE c.type = 'gold';"
        ],
        "rule_sql": []
    },
    "769": {
        "question": "Which superhero has the most durability published by Dark Horse Comics?",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for all table joins. Do reference tables with aliases `T1`, `T2`, `T3`, and `T4` instead of single-letter aliases `s`, `p`, `ha`, and `a`. Do capitalize the attribute name filter to `'Durability'` instead of lowercase `'durability'` to match the actual data format. Do maintain the same join conditions on `T1.id = T2.hero_id`, `T3.id = T2.attribute_id`, and `T4.id = T1.publisher_id` instead of the original join structure. Do preserve the same `WHERE` filters for publisher name and attribute name, the same `ORDER BY` on attribute value descending, and the same `LIMIT 1` to return the single highest durability hero. The amended query now correctly matches the RIGHT_SQL's behavior with proper case sensitivity and explicit join syntax."
        ],
        "rules": [
            "1) When joining multiple tables: use explicit INNER JOIN syntax with aliases T1, T2, T3, T4 instead of single-letter aliases.\n2) When filtering by publisher name: use exact literal 'Dark Horse Comics' with correct case and spacing.\n3) When filtering by attribute name: use exact literal 'Durability' with capital D instead of lowercase 'durability'.\n4) When combining tables: link rows where T1.id = T2.hero_id, T3.id = T2.attribute_id, and T4.id = T1.publisher_id using exact equality conditions.\n5) When ordering by attribute value: sort in descending order to find the highest value.\n6) When the question asks for \"the most\" durability: limit results to only the single highest-ranked row.\n7) Output columns (ordered): T1.superhero_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE p.publisher_name = 'Dark Horse Comics'\nAND a.attribute_name = 'durability'\nORDER BY ha.attribute_value DESC\nLIMIT 1;",
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T3.id = T2.attribute_id\nINNER JOIN publisher T4 ON T4.id = T1.publisher_id\nWHERE T4.publisher_name = 'Dark Horse Comics'\nAND T3.attribute_name = 'Durability'\nORDER BY T2.attribute_value DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T3.id = T2.attribute_id\nINNER JOIN publisher T4 ON T4.id = T1.publisher_id\nWHERE T4.publisher_name = 'Dark Horse Comics'\nAND T3.attribute_name = 'Durability'\nORDER BY T2.attribute_value DESC\nLIMIT 1;"
        ]
    },
    "997": {
        "question": "Which citizenship do the vast majority of the drivers hold?",
        "db_id": "formula_1",
        "ground_truth": "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1",
        "amends": [
            "Do select only `nationality` instead of including `COUNT(*) AS driver_count` in the SELECT list. Do order by `COUNT(driverId)` instead of ordering by the alias `driver_count`. Do remove the explicit column alias `driver_count` instead of keeping it. The amended query now correctly returns only the nationality with the highest count of driver IDs rather than including the count value itself, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the majority citizenship of drivers: select only the nationality column from the drivers table. 2) When counting drivers by nationality: count using the canonical key driverId from the drivers table. 3) When finding the nationality with the highest count: order the results by the count of driverId in descending order. 4) When only the top result is needed: keep only the first row after ordering. 5) Output columns (ordered): nationality"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) AS driver_count FROM drivers GROUP BY nationality ORDER BY driver_count DESC LIMIT 1;",
            "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1"
        ]
    },
    "1017": {
        "error": "something went wrong, tool did not call.",
        "question": "Please list the location coordinates of the circuits whose lap record is 1:29.488.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.lat, T3.lng FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T1.time = '1:29.488'",
        "amends": [
            "Do join `lapTimes` instead of `results` as the source table for lap time data. Do use `time` column instead of `fastestLapTime` to filter for the specific lap time '1:29.488'. Do maintain the same join path from lap times to races to circuits through `raceId` and `circuitId` relationships. Do keep the same output columns `lat` and `lng` from the circuits table. The amended query now correctly identifies circuits based on individual lap time records rather than aggregated fastest lap times from results."
        ],
        "rules": [
            "1) When the question asks for circuits with a specific lap record time of '1:29.488': use the lapTimes table instead of results table to find individual lap times. 2) When filtering for lap time '1:29.488': use the time column from lapTimes table instead of fastestLapTime column from results table. 3) When joining tables to connect lap times to circuits: maintain the join path through lapTimes.raceId to races.raceId, then races.circuitId to circuits.circuitId. 4) When outputting location coordinates: keep the columns lat and lng from the circuits table. 5) Output columns (ordered): circuits.lat, circuits.lng"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.lat, c.lng FROM circuits c JOIN races r ON c.circuitId = r.circuitId JOIN results res ON r.raceId = res.raceId WHERE res.fastestLapTime = '1:29.488';",
            "SELECT DISTINCT c.lat, c.lng \nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nJOIN lapTimes lt ON r.raceId = lt.raceId\nWHERE lt.time = '1:29.488';"
        ],
        "rule_sql": [
            "SELECT circuits.lat, circuits.lng\nFROM circuits\nJOIN races ON circuits.circuitId = races.circuitId\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nWHERE lapTimes.time = '1:29.488'\nGROUP BY circuits.circuitId;"
        ]
    },
    "465": {
        "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
        "db_id": "card_games",
        "ground_truth": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "amends": [
            "Do use `IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO')` instead of `COUNT(*) > 0 AS has_korean_version` to properly check for Korean translations with content. Do join `cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode` instead of querying `foreign_data` with a subquery for `uuid`. Do filter with `WHERE T1.name = 'Ancestor''s Chosen'` instead of using a subquery condition on `uuid` and separate `language` filter. Do remove the direct `language` filter and instead incorporate it into the conditional sum logic to check for both Korean language and non-null translations. The amended query now correctly identifies whether Korean translations exist for the specified card by joining through set relationships rather than relying on a potentially incorrect foreign_data table structure."
        ],
        "rules": [
            "1) When the question asks about cards with \"Ancestor's Chosen\" in the name: filter T1 using T1.name = 'Ancestor''s Chosen'.\n2) When combining cards and set_translations tables: link rows where T2.setCode = T1.setCode using an inner match.\n3) When checking for Korean translations with content: use IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') to properly evaluate both language and translation content.\n4) When handling text literals: preserve exact case and spacing for 'Korean' and 'Ancestor''s Chosen'.\n5) Output columns (ordered): IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO')"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) > 0 AS has_korean_version\nFROM foreign_data\nWHERE uuid = (SELECT uuid FROM cards WHERE name = 'Ancestor''s Chosen')\nAND language = 'Korean';",
            "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') AS has_korean_version\nFROM cards AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode\nWHERE T1.name = 'Ancestor''s Chosen';"
        ],
        "rule_sql": [
            "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') \nFROM cards T1 \nINNER JOIN set_translations T2 ON T2.setCode = T1.setCode \nWHERE T1.name = 'Ancestor''s Chosen'"
        ]
    },
    "30": {
        "question": "Which cities have the top 5 lowest enrollment number for students in grades 1 through 12?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode GROUP BY T2.City ORDER BY SUM(T1.`Enrollment (K-12)`) ASC LIMIT 5",
        "amends": [
            "Do reference `T2.City` in the SELECT list instead of `s.City`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `f` and `s`. Do join on `T1.CDSCode = T2.CDSCode` instead of `f.CDSCode = s.CDSCode`. Do remove the `SUM(f.\"Enrollment (K-12)\") AS TotalEnrollment` column from the SELECT list instead of including it. Do move the `SUM(T1.\"Enrollment (K-12)\")` aggregate function to the ORDER BY clause instead of keeping it in the SELECT list. Do order by `SUM(T1.\"Enrollment (K-12)\") ASC` instead of ordering by the alias `TotalEnrollment ASC`. The amended query now correctly selects only city names while ordering by the enrollment sum, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cities with top 5 lowest enrollment: rank cities by their total enrollment sum in ascending order and keep the first 5 rows.\n2) When combining T1 and T2 for shared entities: link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match).\n3) When computing enrollment totals per city: organize results by T2.City and compute SUM(T1.\"Enrollment (K-12)\") per group.\n4) When ordering by enrollment for ranking: order by SUM(T1.\"Enrollment (K-12)\") ASC to get lowest values first.\n5) When selecting output for top cities: include only T2.City in the final output columns.\nOutput columns (ordered): T2.City"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.City, SUM(f.\"Enrollment (K-12)\") AS TotalEnrollment\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nGROUP BY s.City\nORDER BY TotalEnrollment ASC\nLIMIT 5;",
            "SELECT T2.City\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nGROUP BY T2.City\nORDER BY SUM(T1.\"Enrollment (K-12)\") ASC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT s.City\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.\"Enrollment (K-12)\" IS NOT NULL\nGROUP BY s.City\nORDER BY SUM(f.\"Enrollment (K-12)\") ASC\nLIMIT 5"
        ]
    },
    "139": {
        "question": "How many high-level credit cards have \"OWNER\" type of disposition?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'OWNER'",
        "amends": [],
        "rules": [
            "High-level credit cards refers to the cards with the gold type."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS high_level_owner_cards\nFROM card\nJOIN disp ON card.disp_id = disp.disp_id\nWHERE card.type = 'gold' AND disp.type = 'OWNER';"
        ],
        "rule_sql": []
    },
    "147": {
        "question": "How many female clients' accounts are in the region of South Bohemia?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A3 = 'south Bohemia'",
        "amends": [],
        "rules": [
            "Female refers to gender = 'F'; A3 contains the region 'south Bohemia'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS female_clients_in_south_bohemia\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE c.gender = 'F' AND di.A3 = 'south Bohemia';"
        ],
        "rule_sql": []
    },
    "1198": {
        "question": "How many female patients were given an APS diagnosis?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS'",
        "amends": [
            "Do remove the `JOIN` with `Examination` table and the `DISTINCT` modifier instead of including them, as the diagnosis information is directly available in the `Patient` table. Do reference `Diagnosis` directly from the `Patient` table instead of from the joined `Examination` table. Do simplify the aggregate to `COUNT(ID)` instead of `COUNT(DISTINCT P.ID)` since the join is unnecessary and could cause duplicate counting. Do remove the table alias `P` and column prefixing since only one table is involved. The amended query now correctly counts female patients with APS diagnosis directly from the Patient table without unnecessary joins or distinct operations, matching the right SQL's behavior.",
            "Do use `SEX = 'F'` instead of `SEX = 'female'` in the WHERE filter to match the correct gender code format used in the data. The amended query now correctly counts patients with the specified gender code and diagnosis, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for female patients: filter rows where SEX equals 'F' exactly. 2) When the question asks for APS diagnosis: filter rows where Diagnosis equals 'APS' exactly. 3) When counting patients: count the number of rows using the canonical key ID. 4) When only one table is involved: do not use table aliases or column prefixing. 5) When diagnosis information is directly available in the Patient table: do not join with other tables. 6) When counting all matching rows: do not use DISTINCT modifier. Output columns (ordered): Female_APS_Patients",
            "1) When the question mentions \"female patients\": use the exact literal 'F' for the SEX column to match the gender code format in the data.\n2) When filtering for diagnosis: use the exact literal 'APS' for the Diagnosis column.\n3) When counting patients: use the ID column as the counting key.\n4) Output columns (ordered): COUNT(ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS Female_APS_Patients\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'F' AND E.Diagnosis = 'APS';",
            "SELECT COUNT(ID) FROM Patient WHERE SEX = 'female' AND Diagnosis = 'APS';",
            "SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS';"
        ],
        "rule_sql": [
            "SELECT COUNT(ID) AS Female_APS_Patients FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS'"
        ]
    },
    "1078": {
        "question": "Which player is older, Aaron Lennon or Abdelaziz Barrada?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of multiple columns with player comparisons. Do use a single `FROM Player` table instead of a cross join between two aliases. Do change the WHERE filter to `player_name IN` with both names instead of separate conditions on different aliases. Do add `ORDER BY birthday ASC` instead of using CASE logic for age comparison. Do add `LIMIT 1` to return only the oldest player instead of comparing both players in each row. Do remove the complex CASE expression that determined older player instead of simply ordering by birthday. The amended query now correctly identifies the single oldest player from the specified list by leveraging proper ordering and limiting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks to compare specific players by age: select only the player_name column instead of multiple comparison columns. 2) When filtering for specific player names mentioned in the question: use player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') instead of cross joining separate aliases. 3) When determining the older player: order by birthday ASC to sort from oldest to youngest. 4) When only the oldest player is needed: limit the result to 1 row. 5) When handling age comparisons: avoid complex CASE expressions and instead rely on ordering by birthday. 6) Output columns (ordered): player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    p1.player_name AS player1_name, \n    p1.birthday AS player1_birthday, \n    p2.player_name AS player2_name, \n    p2.birthday AS player2_birthday,\n    CASE \n        WHEN p1.birthday < p2.birthday THEN p1.player_name || ' is older.'\n        WHEN p1.birthday > p2.birthday THEN p2.player_name || ' is older.'\n        ELSE 'Both players have the same age.'\n    END AS result\nFROM \n    Player p1, \n    Player p2\nWHERE \n    p1.player_name = 'Aaron Lennon' \n    AND p2.player_name = 'Abdelaziz Barrada';",
            "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1;"
        ]
    },
    "1277": {
        "question": "How many patients have a normal anti-DNA level, yet their data are not recorded.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA < 8 AND T1.Description IS NULL",
        "amends": [],
        "rules": [
            "normal anti-DNA level refers to DNA < 8; data are not recorded refers to Description IS NULL; Should compute the number of unique ones"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.DNA < 8 AND P.Description IS NULL;"
        ],
        "rule_sql": []
    },
    "518": {
        "question": "Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.",
        "db_id": "card_games",
        "ground_truth": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
        "amends": [
            "Do use `COUNT(*) AS count_banned` instead of `COUNT(*) AS banned_count` in the CTE definition. Do restructure the CTE to use `ORDER BY COUNT(*) DESC LIMIT 1` instead of a subquery with `MAX(banned_count)` to find the format with maximum banned cards. Do change the join order to start with `cards AS T1` instead of beginning with the CTE results. Do use `INNER JOIN legalities AS T2` instead of joining legalities through the CTE relationship. Do move the `status = 'Banned'` filter to the `WHERE` clause instead of keeping it in the join condition. Do select `T2.format, T1.name` instead of `c.name AS card_name, mb.format` for the output columns. Do remove the explicit `ORDER BY c.name` clause instead of keeping it since the RIGHT_SQL doesn't require sorted results. The amended query now correctly identifies cards that are banned in the format with the highest number of banned cards and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When finding the format with the highest number of banned cards: rank formats by count of banned cards in descending order and keep only the top 1 format.\n2) When counting banned cards per format: count rows where status equals 'Banned' exactly as written, grouped by format.\n3) When joining cards and legalities tables: link rows where T1.uuid equals T2.uuid exactly and keep only matching pairs (inner match).\n4) When filtering for banned cards: include only rows where T2.status equals 'Banned' exactly as written.\n5) When selecting cards banned in the top format: include only cards that have a banned status in the format with the highest banned count.\n6) When choosing output columns: select T2.format and T1.name for the final result.\n7) When ordering results: do not apply any explicit sorting unless required by the question.\nOutput columns (ordered): T2.format, T1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH banned_counts AS (\n    SELECT format, COUNT(*) AS banned_count\n    FROM legalities\n    WHERE status = 'Banned'\n    GROUP BY format\n),\nmax_banned AS (\n    SELECT format, banned_count\n    FROM banned_counts\n    WHERE banned_count = (SELECT MAX(banned_count) FROM banned_counts)\n)\nSELECT c.name AS card_name, mb.format\nFROM max_banned mb\nJOIN legalities l ON mb.format = l.format AND l.status = 'Banned'\nJOIN cards c ON l.uuid = c.uuid\nORDER BY c.name;",
            "WITH banned_counts AS (\n    SELECT \n        format,\n        COUNT(*) AS count_banned\n    FROM legalities\n    WHERE status = 'Banned'\n    GROUP BY format\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)\nSELECT \n    T2.format,\n    T1.name\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nINNER JOIN banned_counts AS bc ON T2.format = bc.format\nWHERE T2.status = 'Banned';"
        ],
        "rule_sql": [
            "WITH banned_counts AS (\n    SELECT \n        format, \n        COUNT(*) as banned_count\n    FROM legalities \n    WHERE status = 'Banned'\n    GROUP BY format\n    ORDER BY banned_count DESC\n    LIMIT 1\n)\nSELECT \n    l.format, \n    c.name\nFROM \n    cards c\nJOIN \n    legalities l ON c.uuid = l.uuid\nJOIN \n    banned_counts bc ON l.format = bc.format\nWHERE \n    l.status = 'Banned'\nORDER BY \n    l.format, c.name"
        ]
    },
    "141": {
        "question": "Which districts have transactions greater than USS$10,000 in 1997?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date) = '1997' GROUP BY T1.district_id HAVING SUM(T3.amount) > 10000",
        "amends": [
            "Do select `T1.district_id` instead of `d.A2 AS district_name` in the SELECT list. Do use `account AS T1` as the primary table instead of starting with `trans t`. Do change the join order to `INNER JOIN district AS T2 ON T1.district_id = T2.district_id` instead of joining district last. Do use `INNER JOIN trans AS T3 ON T1.account_id = T3.account_id` instead of joining trans first. Do keep the `STRFTIME('%Y', T3.date) = '1997'` filter in WHERE instead of changing it. Do remove the `t.amount > 10000` filter from WHERE and instead add `HAVING SUM(T3.amount) > 10000` to aggregate the total amount per district. Do group by `T1.district_id` instead of `d.A2`. The amended query now correctly aggregates total transaction amounts per district for 1997 and filters for districts exceeding 10000 in total rather than individual transactions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for districts with transactions greater than a certain amount in a specific year: use account as the primary table (T1) and join district as T2 using T1.district_id = T2.district_id, then join trans as T3 using T1.account_id = T3.account_id.\n2) When filtering for a specific year like 1997: apply STRFTIME('%Y', T3.date) = '1997' to extract the year from transaction dates.\n3) When the question mentions \"transactions greater than USS$10,000\": aggregate transaction amounts per district using SUM(T3.amount) and filter with HAVING SUM(T3.amount) > 10000 instead of filtering individual transactions.\n4) When grouping by districts: use T1.district_id as the grouping key instead of district names.\n5) When selecting district information: output T1.district_id as the result column.\nOutput columns (ordered): T1.district_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.A2 AS district_name\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE strftime('%Y', t.date) = '1997'\nAND t.amount > 10000\nGROUP BY d.A2;",
            "SELECT T1.district_id\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T1.account_id = T3.account_id\nWHERE STRFTIME('%Y', T3.date) = '1997'\nGROUP BY T1.district_id\nHAVING SUM(T3.amount) > 10000"
        ],
        "rule_sql": [
            "SELECT T1.district_id\nFROM account AS T1\nJOIN district AS T2 ON T1.district_id = T2.district_id\nJOIN trans AS T3 ON T1.account_id = T3.account_id\nWHERE STRFTIME('%Y', T3.date) = '1997'\nGROUP BY T1.district_id\nHAVING SUM(T3.amount) > 10000"
        ]
    },
    "1290": {
        "question": "What is the examination date of the patient whose albumin is the highest in the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1",
        "amends": [
            "Do select `Date` instead of `e.\"Examination Date\"` from the `Laboratory` table instead of joining `Examination` and `Laboratory` tables. Do use simple WHERE conditions `ALB > 3.5 AND ALB < 5.5` instead of `BETWEEN 3.5 AND 5.5` to exclude the boundary values. Do remove the unnecessary table join and examination date reference since all required data exists in the Laboratory table alone. The amended query now correctly retrieves the date from Laboratory records where albumin levels fall strictly within the specified range, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for examination date from Laboratory table: use the exact column token \"Date\" from Laboratory table. 2) When filtering albumin values in the normal range: use strict inequality conditions ALB > 3.5 AND ALB < 5.5 to exclude boundary values. 3) When finding the highest albumin value within a range: order rows by ALB in descending order and take the first row. 4) When all required data exists in a single table: do not perform unnecessary table joins. 5) Output columns (ordered): Date"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.\"Examination Date\"\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE l.ALB BETWEEN 3.5 AND 5.5\nORDER BY l.ALB DESC\nLIMIT 1;",
            "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1"
        ]
    },
    "540": {
        "question": "What is the title of the post that is owned by csgillespie and has the highest popularity?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' ORDER BY T1.ViewCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; highest popularity refers to Max(ViewCount)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Title\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie'\nORDER BY p.ViewCount DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "669": {
        "question": "When did 'chl' cast its first vote in a post?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.CreationDate FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl' ORDER BY T2.CreationDate LIMIT 1",
        "amends": [],
        "rules": [
            "DisplayName = 'chl'; cast its first vote refers to MIN(CreationDate);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(v.CreationDate) AS FirstVoteDate\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE u.DisplayName = 'chl';"
        ],
        "rule_sql": []
    },
    "1163": {
        "question": "What was the age of the youngest patient when they initially arrived at the hospital?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT MIN(STRFTIME('%Y', `First Date`) - STRFTIME('%Y', Birthday)) FROM Patient",
        "amends": [],
        "rules": [
            "age refers to SUBTRACT(YEAR(`First Date`),YEAR(Birthday))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(strftime('%Y', `First Date`) - strftime('%Y', Birthday) - (strftime('%m-%d', `First Date`) < strftime('%m-%d', Birthday))) AS youngest_age FROM Patient;"
        ],
        "rule_sql": []
    },
    "102": {
        "question": "State different accounts who have account opening date before 1997 and own an amount of money greater than 3000USD",
        "db_id": "financial",
        "ground_truth": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) < '1997' AND T1.amount > 3000",
        "amends": [
            "Do reference `account_id` from the `trans` table instead of the `account` table in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` for `trans` and `T2` for `account` instead of implicit aliases `a` and `t`. Do filter on `T1.amount > 3000` instead of `t.balance > 3000` to use the correct column name. Do apply the date filter using `STRFTIME('%Y', T2.date) < '1997'` on the account table's date column instead of the original approach. The amended query now correctly identifies accounts with transactions over 3000 amount before 1997, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting account identifiers: use T1.account_id from the trans table instead of the account table.\n2) When joining tables: use INNER JOIN with T1 as alias for trans and T2 as alias for account.\n3) When filtering by transaction amount: use T1.amount > 3000 instead of balance column.\n4) When filtering by account opening date: use STRFTIME('%Y', T2.date) < '1997' on the account table's date column.\n5) When combining T1 and T2: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match).\nOutput columns (ordered): T1.account_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.account_id\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nWHERE strftime('%Y', a.date) < '1997'\nAND t.balance > 3000;",
            "SELECT DISTINCT T1.account_id\nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE T1.amount > 3000\nAND STRFTIME('%Y', T2.date) < '1997'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.account_id\nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE T1.amount > 3000\nAND STRFTIME('%Y', T2.date) < '1997'"
        ]
    },
    "1080": {
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "amends": [],
        "rules": [
            "preferred foot when attacking was the left refers to preferred_foot = 'left'; players who would remain in his position when the team attacked refers to attacking_work_rate = 'low';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS count_left_foot_players_stay_back\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.preferred_foot = 'left' AND pa.attacking_work_rate = 'low';"
        ],
        "rule_sql": []
    },
    "120": {
        "question": "From Year 1995 to 2000, who are the accounts holders from 'east Bohemia'. State the account ID the frequency of statement issuance.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id, T1.frequency FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000'",
        "amends": [],
        "rules": [
            "Accounts holder refers to the person who own this account."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.account_id, a.frequency\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE d.A3 = 'east Bohemia'\nAND a.date BETWEEN '1995-01-01' AND '2000-12-31';"
        ],
        "rule_sql": []
    },
    "228": {
        "question": "How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.",
        "db_id": "toxicology",
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id),4) FROM atom AS T WHERE T.molecule_id = 'TR206'",
        "amends": [
            "Do use `CAST` to convert the count to `REAL` instead of relying on implicit integer division. Do reference the table with alias `T` consistently instead of omitting table qualifiers. Do use `COUNT` with explicit `NULL` handling in the case expression instead of `SUM` with 1/0 values. Do place the entire calculation within `ROUND` instead of having the division outside the rounding function. Do maintain the same `WHERE` filter on `molecule_id` but with proper table qualification. The amended query now correctly handles floating-point division and matches the right SQL's behavior.",
            "Do use `COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END)` instead of `COUNT(CASE WHEN T.element = 'H' THEN 1 ELSE NULL END)` to count specific non-null values rather than counting 1s. Do multiply the count result by 100 before division instead of dividing first then multiplying. Do divide by `COUNT(T.atom_id)` instead of `COUNT(*)` to exclude null atom_id values from the denominator. Do use lowercase 'h' instead of uppercase 'H' for the element comparison. Do remove the alias `AS percentage` instead of keeping it. The amended query now correctly calculates the percentage of 'h' elements while handling null values appropriately and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating percentages with integer division: use CAST to convert counts to REAL to ensure floating-point division instead of integer division. 2) When referencing columns in expressions: always use table alias qualification (T.element, T.atom_id, T.molecule_id) instead of unqualified column names. 3) When counting specific conditions: use COUNT with explicit NULL handling in CASE expressions instead of SUM with 1/0 values. 4) When rounding percentage calculations: place the entire division calculation within the ROUND function instead of having division outside rounding. 5) When filtering by molecule identifier: use exact literal 'TR206' with proper table qualification (T.molecule_id = 'TR206'). 6) When handling hydrogen atoms: use exact literal 'h' (lowercase) for element comparison. 7) Output columns (ordered): percentage",
            "1) When counting hydrogen atoms in molecule TR206: count using T.atom_id where T.element equals 'h' exactly (lowercase). 2) When calculating the percentage of hydrogen atoms: divide the count of hydrogen atoms by the total count of T.atom_id values (excluding nulls). 3) When converting to percentage: multiply the division result by 100 before rounding. 4) When formatting the output: round the result to four decimal places. 5) When filtering for molecule TR206: include only rows where T.molecule_id equals 'TR206' exactly. 6) When handling null values: exclude null T.atom_id values from the denominator count. 7) Output columns (ordered): the calculated percentage value without an alias."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    ROUND((SUM(CASE WHEN element = 'h' THEN 1 ELSE 0 END) * 100.0 / COUNT(atom_id), 4) AS percentage\nFROM \n    atom\nWHERE \n    molecule_id = 'TR206';",
            "SELECT ROUND((CAST(COUNT(CASE WHEN T.element = 'H' THEN 1 ELSE NULL END) AS REAL) / COUNT(*)) * 100, 4) AS percentage\nFROM atom T\nWHERE T.molecule_id = 'TR206';",
            "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100.0 / COUNT(T.atom_id), 4) FROM atom T WHERE T.molecule_id = 'TR206';"
        ],
        "rule_sql": [
            "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id END) AS REAL) / CAST(COUNT(T.atom_id) AS REAL) * 100, 4) FROM atom T WHERE T.molecule_id = 'TR206' AND T.atom_id IS NOT NULL;"
        ]
    },
    "838": {
        "question": "Provide the full name of the superhero named Alien.",
        "db_id": "superhero",
        "ground_truth": "SELECT full_name FROM superhero WHERE superhero_name = 'Alien'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT full_name FROM superhero WHERE superhero_name = 'Alien';"
        ],
        "rule_sql": []
    },
    "665": {
        "question": "What is the average monthly number of links created in 2010 for posts that have no more than 2 answers?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / 12 FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.AnswerCount <= 2 AND STRFTIME('%Y', T1.CreationDate) = '2010'",
        "amends": [
            "Do calculate the average by dividing the total count by 12 instead of using AVG on monthly counts. Do use a direct SELECT with division instead of a CTE with monthly aggregation. Do include the join condition `T1.PostId = T2.Id` instead of potentially incorrect join logic. Do apply the filter `T2.AnswerCount <= 2` directly in the WHERE clause instead of within the CTE. Do use CAST to ensure real number division instead of integer division. Do remove the month extraction and grouping since only the annual average is needed. The amended query now correctly calculates the average monthly links by dividing the total annual count by 12, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating average monthly links for a year: compute the total annual count divided by 12 instead of averaging monthly counts.\n2) When joining postLinks (T1) and posts (T2): link rows where T1.PostId equals T2.Id exactly and keep only matching pairs (inner match).\n3) When filtering by year 2010: include only rows where T1.CreationDate falls within the year 2010.\n4) When filtering posts with no more than 2 answers: include only rows where T2.AnswerCount is less than or equal to 2.\n5) When performing division for averages: use CAST to ensure real number division instead of integer division.\n6) When the question asks for average monthly links: do not extract months or group by month since only the annual average is needed.\nOutput columns (ordered): average_monthly_links"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH monthly_links AS (\n    SELECT \n        strftime('%m', pl.CreationDate) AS month,\n        COUNT(pl.Id) AS link_count\n    FROM \n        postLinks pl\n    JOIN \n        posts p ON pl.PostId = p.Id\n    WHERE \n        strftime('%Y', pl.CreationDate) = '2010'\n        AND p.AnswerCount <= 2\n    GROUP BY \n        month\n)\nSELECT \n    AVG(link_count) AS average_monthly_links\nFROM \n    monthly_links;",
            "SELECT CAST(COUNT(*) AS REAL) / 12 AS average_monthly_links\nFROM postLinks T1\nJOIN posts T2 ON T1.PostId = T2.Id\nWHERE strftime('%Y', T1.CreationDate) = '2010'\nAND T2.AnswerCount <= 2;"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(*) AS REAL) / 12 AS average_monthly_links\nFROM postLinks T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE strftime('%Y', T1.CreationDate) = '2010'\nAND T2.AnswerCount <= 2"
        ]
    },
    "1467": {
        "question": "Calculate the total amount spent on speaker gifts and list the name of the event they were spent on.",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(T1.spent), T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Speaker Gifts' GROUP BY T2.event_name",
        "amends": [
            "Do use `SUM(T1.spent)` without an alias instead of `SUM(b.spent) AS total_spent_on_speaker_gifts` with an alias. Do use table aliases `T1` and `T2` instead of direct table names `b` and `e`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T2.event_name` in both SELECT and GROUP BY instead of `e.event_name`. Do remove the column alias `total_spent_on_speaker_gifts` instead of keeping it. The amended query now correctly aggregates spending by event name without unnecessary aliasing while maintaining the same logical behavior.",
            "Do place `SUM(T1.spent)` before `T2.event_name` in the SELECT list instead of the reverse order. Do use uppercase 'Speaker Gifts' in the WHERE filter instead of lowercase 'speaker gifts'. Do add table aliases with `AS` keyword for both tables instead of omitting them. The amended query now correctly sums spending for speaker gifts with proper case sensitivity and follows conventional column ordering."
        ],
        "rules": [
            "1) When the question asks for total amount spent on speaker gifts: compute the sum of T1.spent for rows where T1.category equals 'Speaker Gifts' exactly. 2) When combining budget and event tables: link rows where T1.link_to_event equals T2.event_id using an inner match. 3) When organizing results by event: group rows by T2.event_name. 4) When outputting results: include both T2.event_name and the sum of T1.spent without any column aliases. 5) Output columns (ordered): T2.event_name, SUM(T1.spent)",
            "1) When the question asks for the total amount spent on speaker gifts and event names: place the sum of spending before the event name in the output order. 2) When filtering for speaker gifts category: use the exact literal 'Speaker Gifts' with uppercase letters and proper spacing. 3) When combining budget and event tables: use explicit table aliases with the AS keyword for both tables. 4) Output columns (ordered): SUM(T1.spent), T2.event_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name, SUM(b.spent) AS total_spent_on_speaker_gifts\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE b.category = 'Speaker Gifts'\nGROUP BY e.event_name;",
            "SELECT T2.event_name, SUM(T1.spent) \nFROM budget T1 \nINNER JOIN event T2 ON T1.link_to_event = T2.event_id \nWHERE T1.category = 'speaker gifts' \nGROUP BY T2.event_name",
            "SELECT SUM(T1.spent), T2.event_name\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Speaker Gifts'\nGROUP BY T2.event_name"
        ],
        "rule_sql": [
            "SELECT SUM(T1.spent), T2.event_name\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Speaker Gifts'\nGROUP BY T2.event_name"
        ]
    },
    "1425": {
        "question": "In the College of Agriculture and Applied Sciences, how many majors are under the department of School of Applied Sciences, Technology and Education?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(major_id) FROM major WHERE department = 'School of Applied Sciences, Technology and Education' AND college = 'College of Agriculture and Applied Sciences'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM major WHERE college = 'College of Agriculture and Applied Sciences' AND department = 'School of Applied Sciences, Technology and Education';"
        ],
        "rule_sql": []
    },
    "1302": {
        "question": "For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.CPK < 250 AND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')",
        "amends": [
            "Do use `COUNT(T1.ID)` without `DISTINCT` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patients. Do use explicit `INNER JOIN` instead of implicit `JOIN` for clarity. Do reference columns with table aliases `T2.CPK` and `T3.KCT`/`T3.RVVT`/`T3.LAC` instead of unqualified `L.CPK` and `E.KCT`/`E.RVVT`/`E.LAC` to avoid ambiguity. Do omit the `AS PatientCount` alias instead of including it since the result column name is not needed. The amended query now correctly counts all patient records meeting the laboratory and examination criteria without unnecessary deduplication.",
            "Do change the `T2.CPK` filter to `< 250` instead of `BETWEEN 60 AND 400`. Do change the examination result comparisons to `= '+'` instead of `= 'positive'` for `T3.KCT`, `T3.RVVT`, and `T3.LAC` conditions. The amended query now correctly filters for lower CPK values and uses the proper positive indicator format, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting patients that meet specific laboratory and examination criteria: count all matching rows using T1.ID without deduplication instead of counting distinct patients.\n2) When combining tables for shared patient data: link rows where T1.ID = T2.ID and T1.ID = T3.ID using inner joins to ensure all criteria are met for the same patients.\n3) When filtering for normal creatinine phosphokinase range: include only rows where T2.CPK < 250.\n4) When checking for positive coagulation measures: include rows where T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+'.\n5) When referencing columns from multiple tables: use explicit table aliases T2.CPK, T3.KCT, T3.RVVT, and T3.LAC to avoid ambiguity.\n6) When producing output: omit unnecessary column aliases since the result column name is not required.\nOutput columns (ordered): COUNT(T1.ID)",
            "1) When filtering for patients with normal range of creatinine phosphokinase: use T2.CPK < 250 as the condition instead of BETWEEN 60 AND 400.\n2) When checking for positive measure of degree of coagulation: use exact literal '+' instead of 'positive' for T3.KCT, T3.RVVT, and T3.LAC conditions.\n3) When combining Patient, Laboratory, and Examination tables: link rows where T1.ID = T2.ID and T1.ID = T3.ID to find matching patient records across all three tables.\n4) When counting patients with specified conditions: use T1.ID as the counting key to ensure each patient is counted only once.\n5) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.CPK < 250\nAND (E.KCT = '+' OR E.RVVT = '+' OR E.LAC = '+');",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.CPK BETWEEN 60 AND 400\nAND (T3.KCT = 'positive' OR T3.RVVT = 'positive' OR T3.LAC = 'positive')",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.CPK < 250\nAND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.CPK < 250\nAND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')"
        ]
    },
    "562": {
        "question": "For the post which got 1910 view counts, how many comments does it get?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ViewCount = 1910",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS comment_count\nFROM comments\nWHERE PostId IN (SELECT Id FROM posts WHERE ViewCount = 1910);"
        ],
        "rule_sql": []
    },
    "1138": {
        "question": "In what country did the Poland Ekstraklasa take place?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT name FROM Country WHERE id IN ( SELECT country_id FROM League WHERE name = 'Poland Ekstraklasa' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE l.name = 'Poland Ekstraklasa';"
        ],
        "rule_sql": []
    },
    "418": {
        "question": "What kind of printing is on the card that Daren Bader created?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT availability FROM cards WHERE artist = 'Daren Bader'",
        "amends": [],
        "rules": [
            "kind of printing refers to availability; Daren Bader created refers to artist = 'Daren Bader'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT availability FROM cards WHERE artist = 'Daren Bader';"
        ],
        "rule_sql": []
    },
    "1230": {
        "question": "List all outpatient within normal range of creatinine phosphokinase. Give me the distinct ids.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CPK < 250 AND T1.Admission = '-'",
        "amends": [],
        "rules": [
            "outpatient refers to Admission = '-'; normal range of creatinine phosphokinase refers to CPK < 250;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Admission = '-' AND l.CPK < 250;"
        ],
        "rule_sql": []
    },
    "1287": {
        "question": "Among the patients followed at the outpatient clinic, how many of them have a normal level of alkaliphophatase?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300 AND T1.Admission = '-'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID) AS NumberOfPatients` to count all matching records without deduplication and remove the unnecessary alias. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference tables with aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T2.ALP < 300` condition before `T1.Admission = '-'` in the WHERE clause instead of the reverse order, though this is functionally equivalent. Do remove the explicit column alias `NumberOfPatients` instead of keeping it since the result set doesn't require named output. The amended query now correctly counts all patient records meeting the criteria without unnecessary DISTINCT operations."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(DISTINCT T1.ID) to count all matching records without deduplication. 2) When combining Patient and Laboratory tables: use INNER JOIN linking rows where T1.ID = T2.ID and keep only matching pairs. 3) When filtering for outpatient clinic patients: include only rows where T1.Admission = '-'. 4) When filtering for normal alkaline phosphatase levels: include only rows where T2.ALP < 300. 5) When ordering conditions: place T2.ALP < 300 before T1.Admission = '-' in the filtering sequence. 6) When producing output: do not use explicit column aliases for the count result. Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS NumberOfPatients\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Admission = '-' AND L.ALP < 300;",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP < 300\nAND T1.Admission = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.ALP < 300 AND T1.Admission = '-'"
        ]
    },
    "24": {
        "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.`School Name` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(T2.`Free Meal Count (K-12)` AS REAL) / T2.`Enrollment (K-12)` > 0.1 AND T1.NumGE1500 > 0",
        "amends": [],
        "rules": [
            "Percent eligible for free meals = Free Meal Count (K-12) / Total (Enrollment (K-12)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.\"School Name\"\nFROM frpm f\nJOIN satscores s ON f.CDSCode = s.cds\nWHERE f.\"Percent (%) Eligible Free (K-12)\" > 0.1 AND s.NumGE1500 >= 1;"
        ],
        "rule_sql": []
    },
    "1044": {
        "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
        "amends": [
            "Do remove the `birthday` column from the SELECT list instead of including it, as the right query only needs player names. Do keep the WHERE filter using `SUBSTR(birthday, 1, 7)` unchanged since the date extraction logic remains correct for finding players born in October 1970. The amended query now matches the right SQL's behavior of returning only player names without exposing their full birth dates."
        ],
        "rules": [
            "1) When the question asks for football players with specific birth criteria: filter rows where the substring of birthday from position 1 for 7 characters equals '1970-10'. 2) When selecting output columns: include only player_name and exclude birthday from the result set. 3) Output columns (ordered): player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, birthday FROM Player WHERE substr(birthday, 1, 7) = '1970-10';",
            "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10';"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player WHERE substr(birthday, 1, 7) = '1970-10';"
        ]
    },
    "1446": {
        "question": "Calculate the percentage of zip codes that are PO boxes.",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(zip_code) FROM zip_code",
        "amends": [],
        "rules": [
            "DIVIDE(SUM(type = 'PO Box'), COUNT(zip_code)) * 100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) * 100.0 / COUNT(zip_code)) AS percentage_po_boxes FROM zip_code;"
        ],
        "rule_sql": []
    },
    "680": {
        "question": "What is the average score of Stephen Turner's posts?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT AVG(T2.Score) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Stephen Turner'",
        "amends": [],
        "rules": [
            "DisplayName = 'Stephen Turner'; average score refers to AVG(Score);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(Score) AS AverageScore\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Stephen Turner');"
        ],
        "rule_sql": []
    },
    "1058": {
        "error": "something went wrong, tool did not call.",
        "question": "Who has the highest average finishing rate between the highest and shortest football player?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM Player ) UNION SELECT AVG(finishing) result, 'Min' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM Player ) ) ORDER BY result DESC LIMIT 1",
        "amends": [
            "Do use a `UNION` with two separate subqueries instead of a single CTE chain with `OR` conditions. Do calculate `AVG(finishing)` separately for maximum and minimum height players instead of grouping all players together. Do add explicit `'Max'` and `'Min'` labels in the `SELECT` list instead of omitting height classification. Do move the height filter conditions directly into `WHERE` clauses with subqueries instead of using a CTE with `HeightExtremes`. Do remove the `GROUP BY` clause on player details instead of keeping it, since we're calculating separate averages. Do change the output to include the height classification label `A` instead of individual player attributes. Do maintain the `ORDER BY result DESC LIMIT 1` to find the highest average finishing between max and min height groups instead of finding individual players. The amended query now correctly compares the average finishing skills between the tallest and shortest player groups rather than individual players with extreme heights.",
            "Do use an alias `A` for the classification column instead of `height_classification` and add a `result` column for the average instead of `avg_finishing`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of `JOIN` without aliases. Do wrap the entire UNION query in a subquery instead of applying ORDER BY and LIMIT directly to the UNION result. Do order by the `result` column instead of `avg_finishing` and maintain the same LIMIT 1. The amended query now correctly selects only the classification column from the subquery while ordering by the average result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the highest average finishing rate between height extremes: calculate separate averages for maximum height players and minimum height players instead of grouping all players together.\n2) When classifying players by height extremes: use explicit 'Max' and 'Min' labels in the output instead of showing individual player attributes.\n3) When filtering for extreme height players: move height filter conditions directly into WHERE clauses with subqueries instead of using a separate CTE for height extremes.\n4) When calculating group averages: remove GROUP BY clauses on individual player details since we're calculating separate group averages.\n5) When comparing group performance: maintain ORDER BY result DESC LIMIT 1 to find the highest average finishing between the max and min height groups.\n6) When structuring the query: use UNION with two separate subqueries instead of a single CTE chain with OR conditions.\nOutput columns (ordered): height_classification, avg_finishing",
            "1) When the question asks for the highest average finishing rate between height classifications: compute average finishing for both maximum and minimum height classifications separately and compare them to find the highest value.\n2) When classifying players by height extremes: create two classifications - 'Max' for players with maximum height and 'Min' for players with minimum height.\n3) When computing average finishing rate: calculate the average of the finishing attribute for each height classification group.\n4) When combining player attributes with player data: link rows where T2.player_api_id equals T1.player_api_id using an inner match.\n5) When selecting the highest result: order the combined classification results by the average result in descending order and keep only the top result.\n6) When structuring output: use alias A for the classification column and result for the average finishing column.\n7) Output columns (ordered): A, result"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH HeightExtremes AS (\n    SELECT \n        MIN(height) AS min_height,\n        MAX(height) AS max_height\n    FROM Player\n),\nFilteredPlayers AS (\n    SELECT \n        p.player_api_id,\n        p.player_name,\n        p.height\n    FROM Player p, HeightExtremes h\n    WHERE p.height = h.min_height OR p.height = h.max_height\n),\nPlayerFinishing AS (\n    SELECT \n        fp.player_api_id,\n        fp.player_name,\n        fp.height,\n        AVG(pa.finishing) AS avg_finishing\n    FROM FilteredPlayers fp\n    JOIN Player_Attributes pa ON fp.player_api_id = pa.player_api_id\n    GROUP BY fp.player_api_id, fp.player_name, fp.height\n)\nSELECT \n    player_api_id,\n    player_name,\n    height,\n    avg_finishing\nFROM PlayerFinishing\nORDER BY avg_finishing DESC\nLIMIT 1;",
            "SELECT \n    'Max' AS height_classification,\n    AVG(pa.finishing) AS avg_finishing\nFROM \n    Player_Attributes pa\nJOIN \n    Player p ON pa.player_api_id = p.player_api_id\nWHERE \n    p.height = (SELECT MAX(height) FROM Player)\n\nUNION ALL\n\nSELECT \n    'Min' AS height_classification,\n    AVG(pa.finishing) AS avg_finishing\nFROM \n    Player_Attributes pa\nJOIN \n    Player p ON pa.player_api_id = p.player_api_id\nWHERE \n    p.height = (SELECT MIN(height) FROM Player)\n\nORDER BY avg_finishing DESC\nLIMIT 1;",
            "SELECT A FROM (\n    SELECT 'Max' AS A, AVG(T2.finishing) AS result\n    FROM Player T1\n    INNER JOIN Player_Attributes T2 ON T1.player_api_id = T2.player_api_id\n    WHERE T1.height = (SELECT MAX(height) FROM Player)\n    \n    UNION\n    \n    SELECT 'Min' AS A, AVG(T2.finishing) AS result\n    FROM Player T1\n    INNER JOIN Player_Attributes T2 ON T1.player_api_id = T2.player_api_id\n    WHERE T1.height = (SELECT MIN(height) FROM Player)\n) \nORDER BY result DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT \n    'Max' AS A, \n    AVG(pa.finishing) AS result\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height = (SELECT MAX(height) FROM Player)\nUNION ALL\nSELECT \n    'Min' AS A, \n    AVG(pa.finishing) AS result\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height = (SELECT MIN(height) FROM Player)\nORDER BY result DESC\nLIMIT 1"
        ]
    },
    "75": {
        "question": "What is the educational level name for the schools with Breakfast Provision 2 in county code 37? Indicate the name of the school.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.EILName, T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2' AND T1.`County Code` = 37",
        "amends": [
            "Do select `T2.EILName` and `T2.School` instead of `School Name` and `Educational Option Type`. Do join `schools AS T2` with `frpm AS T1` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `frpm` table. Do filter on `T1.NSLP Provision Status = 'Breakfast Provision 2'` instead of `'2'` and use numeric value `37` instead of string `'37'` for the county code. The amended query now correctly joins school data and uses proper value formats to match the intended logic.",
            "Do reverse the column order in the SELECT list to `T2.EILName, T2.School` instead of `T2.School, T2.EILName`. Do use backticks for column names `NSLP Provision Status` and `County Code` instead of double quotes to ensure proper identifier quoting. End with confirmation that the amended query now correctly selects columns in the specified order and uses proper identifier quoting for the WHERE clause conditions."
        ],
        "rules": [
            "1) When the question asks for educational level name and school name: select T2.EILName and T2.School as output columns.\n2) When filtering for county code 37: use numeric value 37 for T1.\"County Code\" instead of string '37'.\n3) When filtering for Breakfast Provision 2: use exact literal 'Breakfast Provision 2' for T1.\"NSLP Provision Status\" instead of '2'.\n4) When combining school data with frpm data: join T1 (frpm) and T2 (schools) where T1.CDSCode equals T2.CDSCode and keep only matching pairs.\n5) Output columns (ordered): T2.EILName, T2.School",
            "1) When the question asks for educational level name and school name for schools with specific provision status and county code: select columns T2.EILName and T2.School in that exact order.\n2) When filtering for schools with Breakfast Provision 2 status: use the exact literal value 'Breakfast Provision 2' for the NSLP Provision Status condition.\n3) When filtering for county code 37: use the exact literal value '37' (as string) for the County Code condition, matching the TEXT data type.\n4) When combining frpm table (T1) and schools table (T2): link rows where T1.CDSCode equals T2.CDSCode and keep only matching pairs.\n5) When quoting identifiers containing spaces: use backticks around `NSLP Provision Status` and `County Code` for proper identifier quoting.\nOutput columns (ordered): T2.EILName, T2.School"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT `School Name`, `Educational Option Type` FROM frpm WHERE `County Code` = '37' AND `NSLP Provision Status` = '2';",
            "SELECT T2.School, T2.EILName \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T1.\"NSLP Provision Status\" = 'Breakfast Provision 2' \nAND T1.\"County Code\" = 37;",
            "SELECT T2.EILName, T2.School\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2'\nAND T1.`County Code` = 37"
        ],
        "rule_sql": [
            "SELECT T2.EILName, T2.School\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2'\nAND T1.`County Code` = '37'"
        ]
    },
    "1094": {
        "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "amends": [
            "Do use conditional aggregation with `SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END)` instead of direct column subtraction `A.overall_rating - P.overall_rating`. Do join `Player AS t1` with `Player_Attributes AS t2` on `t1.player_api_id = t2.player_api_id` instead of separate joins for each player with incorrect table aliases. Do remove the explicit player name filters in the WHERE clause and instead incorporate them into the conditional aggregation logic. Do calculate the percentage difference using the aggregated sums instead of individual row comparisons. Do use proper table aliases `t1` and `t2` for clarity instead of ambiguous aliases like `A`, `P`, `PA`, and `PP`. The amended query now correctly calculates the percentage difference between the aggregated overall ratings of the two specified players."
        ],
        "rules": [
            "1) When calculating percentage difference between two specific players' ratings: use conditional aggregation with SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) and SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) instead of direct column subtraction.\n2) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id using an inner join.\n3) When filtering for specific players: incorporate player name conditions 'Ariel Borysiuk' and 'Paulin Puel' directly into the conditional aggregation logic instead of using WHERE clause filters.\n4) When calculating percentage difference: compute ((sum for Ariel Borysiuk - sum for Paulin Puel) * 100.0 / sum for Paulin Puel) using the aggregated values.\n5) When using table aliases: use t1 for Player table and t2 for Player_Attributes table consistently throughout the query.\nOutput columns (ordered): percentage_higher"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ((A.overall_rating - P.overall_rating) * 100.0 / P.overall_rating) AS percentage_higher\nFROM Player_Attributes A\nJOIN Player PA ON A.player_api_id = PA.player_api_id\nJOIN Player_Attributes P\nJOIN Player PP ON P.player_api_id = PP.player_api_id\nWHERE PA.player_name = 'Ariel Borysiuk' AND PP.player_name = 'Paulin Puel';\n",
            "SELECT \n    (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) AS percentage_difference\nFROM \n    Player AS t1\nJOIN \n    Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.player_name IN ('Ariel Borysiuk', 'Paulin Puel');"
        ],
        "rule_sql": [
            "SELECT \n    ((SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) - \n      SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100.0 / \n     SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) AS percentage_higher\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.player_name IN ('Ariel Borysiuk', 'Paulin Puel')"
        ]
    },
    "343": {
        "question": "Name all cards with 2015 frame style ranking below 100 on EDHRec.",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = 2015",
        "amends": [
            "Do select `id` instead of `name` in the SELECT list. Do use integer comparison `frameVersion = 2015` instead of string comparison `frameVersion = '2015'`. Do maintain the same WHERE clause conditions but ensure proper data type handling for the frameVersion comparison. The amended query now correctly retrieves card IDs with the proper numeric comparison for frameVersion while maintaining the same filtering logic for edhrecRank."
        ],
        "rules": [
            "1) When the question asks for \"cards\" but the schema shows tables \"rulings\" and \"sets\": use the appropriate table based on the context of the question about cards. 2) When the question specifies \"2015 frame style\": use integer comparison frameVersion = 2015 instead of string comparison. 3) When the question asks for ranking below 100 on EDHRec: filter using edhrecRank < 100. 4) When the question asks to \"name all cards\": select the name column from the appropriate table. 5) Output columns (ordered): name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cards WHERE frameVersion = '2015' AND edhrecRank < 100;",
            "SELECT id FROM cards WHERE frameVersion = 2015 AND edhrecRank < 100"
        ],
        "rule_sql": [
            "SELECT name FROM cards WHERE frameVersion = 2015 AND edhrecRank < 100 ORDER BY name;"
        ]
    },
    "1359": {
        "question": "How many times was the budget in Advertisement for \"Yearly Kickoff\" meeting more than \"October Meeting\"?",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs and cross join comparison. Do add explicit `INNER JOIN` on `T1.link_to_event = T2.event_id` instead of using subqueries in the WHERE clause. Do include `T2.type = 'Meeting'` filter instead of omitting it. Do calculate a ratio using `CAST(SUM(CASE...)/SUM(CASE...) AS REAL)` instead of counting occurrences where one total exceeds another. Do remove the cross join between CTEs and the COUNT(*) comparison logic instead of keeping that structure. The amended query now correctly calculates the ratio of advertisement spending between the two specific meeting events rather than just counting if one total is greater than the other."
        ],
        "rules": [
            "1) When the question asks for a ratio comparison between two specific meeting events: use conditional aggregation with CASE statements to calculate the ratio of advertisement spending between \"Yearly Kickoff\" and \"October Meeting\" events.\n2) When joining budget and event tables: use an INNER JOIN on T1.link_to_event = T2.event_id to connect budget entries to their corresponding events.\n3) When filtering for meeting events: include T2.type = 'Meeting' to ensure only meeting-type events are considered.\n4) When filtering for advertisement category: include T1.category = 'Advertisement' to focus on advertisement budget entries.\n5) When handling specific event names: use exact string literals \"Yearly Kickoff\" and \"October Meeting\" with proper case and spacing.\n6) When calculating ratios: use CAST(SUM(CASE WHEN T2.event_name = \"Yearly Kickoff\" THEN T1.amount ELSE 0 END) / SUM(CASE WHEN T2.event_name = \"October Meeting\" THEN T1.amount ELSE 0 END) AS REAL) to compute the spending ratio.\n7) When dealing with division: guard against division by zero by ensuring the denominator (October Meeting spending) is not zero.\nOutput columns (ordered): The ratio result as a single value"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH yearly_kickoff AS (\n    SELECT SUM(amount) AS total_amount\n    FROM budget\n    WHERE category = 'Advertisement'\n    AND link_to_event IN (SELECT event_id FROM event WHERE event_name = 'Yearly Kickoff')\n),\noctober_meeting AS (\n    SELECT SUM(amount) AS total_amount\n    FROM budget\n    WHERE category = 'Advertisement'\n    AND link_to_event IN (SELECT event_id FROM event WHERE event_name = 'October Meeting')\n)\nSELECT COUNT(*) AS count_more\nFROM yearly_kickoff, october_meeting\nWHERE yearly_kickoff.total_amount > october_meeting.total_amount;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / \n    CAST(SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) AS REAL) AS budget_ratio\nFROM budget T1\nINNER JOIN event T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Advertisement' \nAND T2.type = 'Meeting'\nAND T2.event_name IN ('Yearly Kickoff', 'October Meeting')"
        ],
        "rule_sql": [
            "SELECT \n    CAST(\n        SUM(CASE WHEN e.event_name = 'Yearly Kickoff' THEN b.amount ELSE 0 END) * 1.0 / \n        NULLIF(SUM(CASE WHEN e.event_name = 'October Meeting' THEN b.amount ELSE 0 END), 0)\n    AS REAL) AS budget_ratio\nFROM \n    budget b\nINNER JOIN \n    event e ON b.link_to_event = e.event_id\nWHERE \n    e.type = 'Meeting'\n    AND b.category = 'Advertisement'\n    AND (e.event_name = 'Yearly Kickoff' OR e.event_name = 'October Meeting')"
        ]
    },
    "918": {
        "question": "What's Lewis Hamilton's reference name?",
        "db_id": "formula_1",
        "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'",
        "amends": [],
        "rules": [
            "reference name refers to driverRef"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton';"
        ],
        "rule_sql": []
    },
    "1520": {
        "question": "For the customer who paid 124.05 in 2012/8/24, how much did he/she spend during the January of 2012? And what is the date and expenses exactly?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T1.CustomerID, T2.Date, T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Price = 124.05 AND T2.Date = '201201'",
        "amends": [
            "Do use an `INNER JOIN` between `transactions_1k` and `yearmonth` on `CustomerID` instead of a subquery with `IN`. Do select `T1.CustomerID`, `T2.Date`, and `T2.Consumption` instead of only `Date` and `Consumption`. Do filter `T1.Date` to `'2012-08-24'` and `T1.Price` to `124.05` in the `WHERE` clause instead of in a CTE. Do filter `T2.Date` to `'201201'` instead of using `LIKE '2012-01%'`. Do remove the CTE wrapper and instead perform the join directly in the main query. The amended query now correctly joins the tables and filters the dates appropriately to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about a customer who paid a specific amount on a specific date: filter T1.Price to 124.05 and T1.Date to '2012-08-24' exactly as specified.\n2) When combining transactions_1k (T1) and yearmonth (T2) for customer analysis: link rows where T1.CustomerID = T2.CustomerID using an inner match.\n3) When the question asks for spending during January 2012: filter T2.Date to '201201' exactly (not using pattern matching).\n4) When outputting results for customer spending analysis: include T1.CustomerID, T2.Date, and T2.Consumption in the output.\n5) When handling date formats: use exact string literals '2012-08-24' for T1.Date and '201201' for T2.Date without modification.\nOutput columns (ordered): T1.CustomerID, T2.Date, T2.Consumption"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH target_customer AS (\n    SELECT CustomerID\n    FROM transactions_1k\n    WHERE Price = 124.05 AND Date = '2012-08-24'\n)\nSELECT Date, Consumption\nFROM yearmonth\nWHERE CustomerID IN (SELECT CustomerID FROM target_customer) AND Date LIKE '2012-01%';",
            "SELECT T1.CustomerID, T2.Date, T2.Consumption\nFROM transactions_1k T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Date = '2012-08-24' \nAND T1.Price = 124.05\nAND T2.Date = '201201';"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID, T2.Date, T2.Consumption\nFROM transactions_1k T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Price = 124.05 \nAND T1.Date = '2012-08-24'\nAND T2.Date = '201201'"
        ]
    },
    "1519": {
        "question": "What was the product id of the transaction happened at 2012/8/23 21:20:00?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T1.ProductID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'",
        "amends": [],
        "rules": [
            "'2012/8/23 21:20:00' can refer to date = '2012-08-23' AND T1.time = '21:20:00' in the database"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ProductID FROM transactions_1k WHERE Date = '2012-08-23' AND Time = '21:20:00';"
        ],
        "rule_sql": []
    },
    "1185": {
        "question": "For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) AS REAL) / SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-02-18'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for each month. Do add `INNER JOIN` between `Patient` and `Laboratory` on `T1.ID = T2.ID` instead of using subqueries for patient filtering. Do move the patient birthday filter to the `WHERE` clause instead of using `INNER` subqueries. Do calculate the percentage decrease using `(November_sum - December_sum) / December_sum` instead of `(November_sum - December_sum) / November_sum` to show the correct relative decrease from December's baseline. Do use `CAST(... AS REAL)` for proper division instead of string concatenation with percentage sign. Do remove the `CASE` statement for 'Insufficient data' and handle nulls through the division logic instead. The amended query now correctly calculates the percentage decrease of T-CHO values from November to December 1981 for patients born on 1959-02-18.",
            "Do calculate the percentage decrease as `(November_sum - December_sum) / December_sum` instead of `(November_sum - December_sum) / December_sum * 100` to avoid incorrect percentage scaling. Do use direct date pattern matching with `LIKE '1981-11-%'` instead of `strftime('%m', Date)` functions for month extraction. Do place the aggregation directly in the main query instead of using a subquery for the sums. Do reference the Laboratory table directly as `T2.`T-CHO`` instead of using the table-qualified column name. Do remove the unnecessary multiplication by 100 since the division already produces the correct ratio. Do maintain the `INNER JOIN` on `T1.ID = T2.ID` instead of `Laboratory.ID = Patient.ID` for proper table correlation. Do keep the filter on `T1.Birthday = '1959-02-18'` unchanged. The amended query now correctly calculates the ratio of November to December T-CHO values for patients born on 1959-02-18."
        ],
        "rules": [
            "1) When the question asks for a patient born on a specific date: filter Patient table where Birthday equals '1959-02-18' exactly.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using inner join to keep only matching patient-lab pairs.\n3) When calculating monthly aggregates for specific months: filter Laboratory records where Date starts with '1981-11-' for November and '1981-12-' for December.\n4) When computing percentage decrease from November to December: calculate (November_sum - December_sum) / December_sum using real number division.\n5) When handling T-CHO values: use the exact column name \"T-CHO\" with proper quoting as shown in the schema.\n6) Output columns (ordered): decrease_rate",
            "1) When the question asks for a patient born on a specific date: filter rows where T1.Birthday equals '1959-02-18' exactly.\n2) When calculating cholesterol values for November 1981: include rows where T2.Date matches the pattern '1981-11-%'.\n3) When calculating cholesterol values for December 1981: include rows where T2.Date matches the pattern '1981-12-%'.\n4) When computing the decrease rate between two values: calculate (November_sum - December_sum) / December_sum as the ratio.\n5) When combining patient and laboratory data: link rows where T1.ID equals T2.ID exactly (inner match).\n6) When aggregating cholesterol values: sum T2.\"T-CHO\" values for the specified date ranges.\n7) Output columns (ordered): (November_sum - December_sum) / December_sum AS decrease_rate"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH November_TCHO AS (\n    SELECT SUM(`T-CHO`) AS sum_nov\n    FROM Laboratory\n    WHERE ID IN (SELECT ID FROM Patient WHERE Birthday = '1959-02-18')\n    AND Date LIKE '1981-11-%'\n),\nDecember_TCHO AS (\n    SELECT SUM(`T-CHO`) AS sum_dec\n    FROM Laboratory\n    WHERE ID IN (SELECT ID FROM Patient WHERE Birthday = '1959-02-18')\n    AND Date LIKE '1981-12-%'\n)\nSELECT \n    CASE \n        WHEN November_TCHO.sum_nov IS NULL OR December_TCHO.sum_dec IS NULL THEN 'Insufficient data'\n        ELSE ((November_TCHO.sum_nov - December_TCHO.sum_dec) / November_TCHO.sum_nov * 100) || '%'\n    END AS decrease_rate\nFROM November_TCHO, December_TCHO;",
            "SELECT \n    (November_sum - December_sum) / CAST(December_sum AS REAL) * 100 AS decrease_rate\nFROM (\n    SELECT \n        SUM(CASE WHEN strftime('%m', Date) = '11' AND strftime('%Y', Date) = '1981' THEN \"T-CHO\" ELSE 0 END) AS November_sum,\n        SUM(CASE WHEN strftime('%m', Date) = '12' AND strftime('%Y', Date) = '1981' THEN \"T-CHO\" ELSE 0 END) AS December_sum\n    FROM Laboratory\n    INNER JOIN Patient ON Laboratory.ID = Patient.ID\n    WHERE Patient.Birthday = '1959-02-18'\n)",
            "SELECT \n    (SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - \n     SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) / \n    CAST(SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) AS REAL) AS decrease_rate\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Birthday = '1959-02-18'"
        ],
        "rule_sql": [
            "SELECT \n    (november_chol.total_chol - december_chol.total_chol) / december_chol.total_chol AS decrease_rate\nFROM \n    Patient p\nINNER JOIN \n    (SELECT ID, SUM(\"T-CHO\") AS total_chol \n     FROM Laboratory \n     WHERE Date LIKE '1981-11-%' \n     GROUP BY ID) november_chol ON p.ID = november_chol.ID\nINNER JOIN \n    (SELECT ID, SUM(\"T-CHO\") AS total_chol \n     FROM Laboratory \n     WHERE Date LIKE '1981-12-%' \n     GROUP BY ID) december_chol ON p.ID = december_chol.ID\nWHERE \n    p.Birthday = '1959-02-18'"
        ]
    },
    "1366": {
        "question": "List all the members who attended the event \"October Meeting\".",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T3.member_id FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'October Meeting'",
        "amends": [
            "Do select only `member_id` instead of multiple columns including `first_name`, `last_name`, `email`, `position`, `t_shirt_size`, `phone`, `zip`, and `link_to_major`. Do add `DISTINCT` to eliminate duplicate member records instead of returning all attendance instances. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for both table joins. Do change the join condition from `m.member_id = a.link_to_member` to `T2.link_to_member = T3.member_id` for proper member table reference. Do use table aliases `T1`, `T2`, and `T3` instead of single-letter aliases `m`, `a`, and `e` for better clarity. The amended query now correctly returns only unique member IDs who attended the October Meeting instead of potentially duplicate member records with full details."
        ],
        "rules": [
            "1) When the question asks for members who attended an event: select only the member identifier \"member_id\" instead of multiple member details. 2) When listing attendees to eliminate duplicate records: use DISTINCT to return only unique member values. 3) When combining tables for attendance information: use explicit INNER JOIN syntax with table aliases T1 for event, T2 for attendance, and T3 for member. 4) When joining attendance and member tables: link rows where T2.link_to_member equals T3.member_id. 5) When filtering for a specific event name: match the exact literal 'October Meeting' for T1.event_name. 6) When the question asks for members who attended \"October Meeting\": ensure the output contains only unique member IDs who have attendance records for that event. Output columns (ordered): T3.member_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.member_id, m.first_name, m.last_name, m.email, m.position, m.t_shirt_size, m.phone, m.zip, m.link_to_major\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'October Meeting';",
            "SELECT DISTINCT T3.member_id\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = 'October Meeting'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.member_id\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = 'October Meeting';"
        ]
    },
    "87": {
        "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
        "amends": [
            "Do select only `AdmEmail1` and `AdmEmail2` instead of including `AdmEmail3`. Do join `frpm AS T1` with `schools AS T2` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do reference all columns with table aliases (`T2.County`, `T2.City`, etc.) instead of unqualified column names. Do use numeric comparison `T2.DOC = 54` instead of string comparison `DOC = '54'`. Do extract year from `OpenDate` using `strftime('%Y', T2.OpenDate)` and compare to year strings `'2009'` and `'2010'` instead of date range `BETWEEN '2009-01-01' AND '2010-12-31'`. Do use numeric comparison `T2.SOC = 62` instead of string comparison `SOC = '62'`. Do remove the `District` filter instead of keeping `District = 'San Bernardino City Unified'`. The amended query now correctly joins the required tables and handles date and numeric comparisons appropriately to match the intended behavior."
        ],
        "rules": [
            "1) When joining tables for school information: combine frpm as T1 with schools as T2 where T1.CDSCode equals T2.CDSCode and keep only matching pairs. 2) When filtering by county: include only rows where T2.County equals 'San Bernardino'. 3) When filtering by city: include only rows where T2.City equals 'San Bernardino'. 4) When filtering by opening year: extract the year from T2.OpenDate and include only rows where the year equals '2009' or '2010'. 5) When filtering by school type: include only rows where T2.SOC equals 62. 6) When filtering by district type: include only rows where T2.DOC equals 54. 7) When selecting administrator email addresses: output only T2.AdmEmail1 and T2.AdmEmail2. Output columns (ordered): T2.AdmEmail1, T2.AdmEmail2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AdmEmail1, AdmEmail2, AdmEmail3\nFROM schools\nWHERE County = 'San Bernardino'\n  AND City = 'San Bernardino'\n  AND District = 'San Bernardino City Unified'\n  AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31'\n  AND SOC = '62'\n  AND DOC = '54';",
            "SELECT T2.AdmEmail1, T2.AdmEmail2\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'San Bernardino'\n  AND T2.City = 'San Bernardino'\n  AND strftime('%Y', T2.OpenDate) IN ('2009', '2010')\n  AND T2.DOC = 54\n  AND T2.SOC = 62"
        ],
        "rule_sql": [
            "SELECT T2.AdmEmail1, T2.AdmEmail2\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'San Bernardino'\nAND T2.City = 'San Bernardino'\nAND (strftime('%Y', T2.OpenDate) = '2009' OR strftime('%Y', T2.OpenDate) = '2010')\nAND T2.SOC = '62'\nAND T2.DOC = '54';"
        ]
    },
    "803": {
        "question": "What is the power ID of cryokinesis?",
        "db_id": "superhero",
        "ground_truth": "SELECT id FROM superpower WHERE power_name = 'Cryokinesis'",
        "amends": [
            "Do use the exact case-sensitive string 'Cryokinesis' instead of 'cryokinesis' in the WHERE filter condition to ensure proper string matching, as the correct value appears to have capital letter formatting in the database. The amended query now correctly matches the RIGHT_SQL's case-sensitive filtering behavior."
        ],
        "rules": [
            "1) When filtering by power name with exact case-sensitive matching: use the literal 'Cryokinesis' exactly as shown in the database, not 'cryokinesis'.\n2) When selecting the power ID for a specific power name: retrieve the id column from the superpower table where power_name matches the exact case-sensitive value.\n3) Output columns (ordered): id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM superpower WHERE power_name = 'cryokinesis';",
            "SELECT id FROM superpower WHERE power_name = 'Cryokinesis';"
        ],
        "rule_sql": [
            "SELECT id FROM superpower WHERE power_name = 'Cryokinesis';"
        ]
    },
    "735": {
        "question": "How many superheroes with blonde hair are there?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id WHERE T2.colour = 'Blond'",
        "amends": [],
        "rules": [
            "superheroes with blonde hair refers to colour = 'Blond' where hair_colour_id = colour.id"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE hair_colour_id = (SELECT id FROM colour WHERE colour = 'Blond');"
        ],
        "rule_sql": []
    },
    "835": {
        "question": "Among all superheroes in Marvel Comics, identify the percentage of 'good' superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics'",
        "amends": [],
        "rules": [
            "Marvel Comics refers to publisher_name = 'Marvel Comics'; percentage = MULTIPLY(DIVIDE(SUM(alignment = 'Good' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100.0); good superheroes refers to alignment = 'Good';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN a.alignment = 'Good' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_good\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    alignment a ON s.alignment_id = a.id\nWHERE \n    p.publisher_name = 'Marvel Comics';"
        ],
        "rule_sql": []
    },
    "254": {
        "question": "What percentage of bonds have the most common combination of atoms' elements?",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST((SELECT COUNT(T1.atom_id) FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id GROUP BY T2.bond_type ORDER BY COUNT(T2.bond_id) DESC LIMIT 1 ) AS REAL) * 100 / ( SELECT COUNT(atom_id) FROM connected )",
        "amends": [
            "Do use a single SELECT with subqueries instead of a CTE structure. Do calculate the maximum bond count from `connected` joined with `bond` on `bond_id` instead of counting element pairs from `atom` joins. Do group by `bond_type` instead of element pairs. Do order by count descending with limit 1 instead of finding maximum pair count. Do cast the maximum count to REAL instead of using decimal multiplication. Do divide by the total count from `connected` instead of from `bond` table. Do remove the unnecessary CTEs and cross join, using subqueries directly in the main SELECT instead. The amended query now correctly calculates the percentage of the most frequent bond type rather than element pair frequency.",
            "Do use `COUNT(T1.atom_id)` instead of `COUNT(*)` in the numerator subquery, and do use `COUNT(T2.bond_id)` instead of `COUNT(*)` for the bond count aggregation. Do specify `INNER JOIN` explicitly instead of just `JOIN` between connected and bond tables. Do remove the unnecessary `total_bonds` and `max_bond_count` columns instead of including them in the output. Do move the multiplication by 100 to the numerator instead of keeping it in the denominator division. Do use `COUNT(atom_id)` instead of `COUNT(*)` in the denominator subquery. Do remove the percentage calculation division operator and instead perform direct multiplication and division with proper operator precedence. The amended query now correctly calculates the percentage of the most frequent bond type relative to total connections."
        ],
        "rules": [
            "1) When calculating bond frequency statistics: use the connected table as the primary source instead of joining atom tables for element pairs.\n2) When grouping bonds by type: group by bond_type from the connected table instead of element combinations.\n3) When finding the most common bond type: order bond types by count in descending order and take the first result (limit 1).\n4) When counting total bonds: use the count from the connected table instead of the bond table.\n5) When calculating percentages: cast the maximum count to REAL type before division and multiplication by 100.\n6) When computing ratios: use subqueries directly in the main SELECT instead of CTEs and cross joins.\n7) When joining tables for bond analysis: use bond_id as the linking key between bond and connected tables.\nOutput columns (ordered): percentage",
            "1) When counting atoms in the connected table: use COUNT(T1.atom_id) instead of COUNT(*). 2) When counting bonds in the bond table: use COUNT(T2.bond_id) instead of COUNT(*). 3) When joining connected and bond tables: use INNER JOIN explicitly between T1 and T2. 4) When calculating percentage: multiply the numerator by 100 before division instead of keeping multiplication in the denominator. 5) When computing the most common bond type: group by T2.bond_type and order by COUNT(T2.bond_id) in descending order, taking only the top result. 6) When calculating total connections: use COUNT(T1.atom_id) for the denominator instead of COUNT(*). 7) When producing final output: remove intermediate calculation columns and only show the final percentage result. 8) Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH element_pairs AS (\n  SELECT a1.element AS element1, a2.element AS element2, COUNT(*) AS pair_count\n  FROM connected c\n  JOIN atom a1 ON c.atom_id = a1.atom_id\n  JOIN atom a2 ON c.atom_id2 = a2.atom_id\n  GROUP BY a1.element, a2.element\n),\nmax_pair AS (\n  SELECT MAX(pair_count) AS max_count\n  FROM element_pairs\n),\ntotal_bonds AS (\n  SELECT COUNT(*) AS total\n  FROM bond\n)\nSELECT (max_pair.max_count * 100.0 / total_bonds.total) AS percentage\nFROM max_pair, total_bonds;",
            "SELECT \n    (SELECT COUNT(*) FROM connected) AS total_bonds,\n    (SELECT COUNT(*) FROM connected c JOIN bond b ON c.bond_id = b.bond_id GROUP BY b.bond_type ORDER BY COUNT(*) DESC LIMIT 1) AS max_bond_count,\n    CAST((SELECT COUNT(*) FROM connected c JOIN bond b ON c.bond_id = b.bond_id GROUP BY b.bond_type ORDER BY COUNT(*) DESC LIMIT 1) AS REAL) / \n    (SELECT COUNT(*) FROM connected) * 100.0 AS percentage",
            "SELECT \n    (SELECT COUNT(*) \n     FROM connected c \n     INNER JOIN bond b ON c.bond_id = b.bond_id \n     GROUP BY b.bond_type \n     ORDER BY COUNT(*) DESC \n     LIMIT 1) * 100.0 / \n    (SELECT COUNT(*) FROM connected) \nAS percentage"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(MAX(bond_count) AS REAL) * 100.0 / (SELECT COUNT(atom_id) FROM connected)) AS percentage\nFROM (\n    SELECT \n        COUNT(T1.atom_id) AS bond_count\n    FROM \n        connected T1\n    INNER JOIN \n        bond T2 ON T1.bond_id = T2.bond_id\n    GROUP BY \n        T2.bond_type\n    ORDER BY \n        bond_count DESC\n    LIMIT 1\n)"
        ]
    },
    "870": {
        "question": "What's Lucas di Grassi's Q1 result in the race No. 345?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 345 AND T2.forename = 'Lucas' AND T2.surname = 'di Grassi'",
        "amends": [],
        "rules": [
            "race number refers to raceId;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT q.q1\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 345 AND d.forename = 'Lucas' AND d.surname = 'di Grassi';"
        ],
        "rule_sql": []
    },
    "280": {
        "question": "Enumerate the bond ID of triple bond type molecules and tell me if they are carcinogenic or not.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.bond_id, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "amends": [],
        "rules": [
            "triple bond refers to bond_type = '#'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_id, m.label AS carcinogenic_status\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '#';"
        ],
        "rule_sql": []
    },
    "595": {
        "question": "Which user have only one post history per post and having at least 1000 views?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
        "amends": [
            "Do select `T2.UserId` instead of `u.Id, u.DisplayName` and remove the DisplayName column. Do add `INNER JOIN posts AS T3` on `T2.PostId = T3.Id` instead of omitting the posts table entirely. Do change the WHERE filter to `T3.ViewCount >= 1000` instead of `u.Views >= 1000` to filter on post views rather than user views. Do modify the GROUP BY to `T2.UserId` instead of `u.Id, ph.PostId` to group by user only. Do change the HAVING clause to `COUNT(DISTINCT T2.PostHistoryTypeId) = 1` instead of `COUNT(ph.Id) = 1` to count distinct post history types rather than all post history entries. The amended query now correctly filters based on post view counts and counts unique post history types per user, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for users with specific post history conditions: select only T2.UserId as the output column. 2) When combining post history and posts tables: link rows where T2.PostId = T3.Id using an inner match. 3) When filtering for posts with at least 1000 views: include only rows where T3.ViewCount >= 1000. 4) When grouping by user: organize results by T2.UserId only. 5) When counting distinct post history types per user: compute the number of unique T2.PostHistoryTypeId values per group. 6) When requiring exactly one distinct post history type: keep only groups where COUNT(DISTINCT T2.PostHistoryTypeId) = 1. Output columns (ordered): T2.UserId"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.Id, u.DisplayName\nFROM users u\nJOIN postHistory ph ON u.Id = ph.UserId\nWHERE u.Views >= 1000\nGROUP BY u.Id, ph.PostId\nHAVING COUNT(ph.Id) = 1;",
            "SELECT T2.UserId\nFROM postHistory AS T2\nINNER JOIN posts AS T3 ON T2.PostId = T3.Id\nWHERE T3.ViewCount >= 1000\nGROUP BY T2.UserId\nHAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1"
        ],
        "rule_sql": [
            "SELECT T2.UserId\nFROM postHistory T2\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nWHERE T3.ViewCount >= 1000\nGROUP BY T2.UserId\nHAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1"
        ]
    },
    "1003": {
        "question": "How many accidents did the driver who had the highest number accidents in the Canadian Grand Prix have?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN status AS T3 on T1.statusId = T3.statusId WHERE T3.statusId = 3 AND T2.name = 'Canadian Grand Prix' GROUP BY T1.driverId ORDER BY COUNT(T1.driverId) DESC LIMIT 1",
        "amends": [
            "Do use `COUNT(T1.driverId)` instead of `COUNT(*) AS accident_count` to count specific driver incidents. Do join `status AS T3 on T1.statusId = T3.statusId` instead of omitting the status table join. Do move the `T2.name = 'Canadian Grand Prix'` filter from the CTE to the main WHERE clause instead of using a separate CTE. Do remove the driver name columns `forename` and `surname` instead of including them in the output. Do change the GROUP BY to only `T1.driverId` instead of grouping by multiple driver attributes. Do remove the CTE structure entirely instead of using nested common table expressions. The amended query now correctly counts accidents by driver ID for Canadian Grand Prix races with status 3, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting accidents per driver: use COUNT(T1.driverId) to count specific driver incidents instead of counting all rows.\n2) When joining with status information: join status AS T3 on T1.statusId = T3.statusId to access status details.\n3) When filtering for Canadian Grand Prix races: apply T2.name = 'Canadian Grand Prix' directly in the main WHERE clause instead of using a separate CTE.\n4) When outputting results for driver accident counts: remove driver name columns forename and surname from the output.\n5) When grouping by driver: group only by T1.driverId instead of grouping by multiple driver attributes.\n6) When structuring the query: avoid using nested common table expressions and use a simpler query structure.\n7) When counting accidents with status 3: ensure the condition T1.statusId = 3 is applied to filter for accident incidents.\nOutput columns (ordered): accident_count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH canadian_gp AS (\n    SELECT raceId\n    FROM races\n    WHERE name = 'Canadian Grand Prix'\n),\naccident_counts AS (\n    SELECT r.driverId, d.forename, d.surname, COUNT(*) AS accident_count\n    FROM results r\n    JOIN canadian_gp c ON r.raceId = c.raceId\n    JOIN drivers d ON r.driverId = d.driverId\n    WHERE r.statusId = 3\n    GROUP BY r.driverId, d.forename, d.surname\n)\nSELECT forename, surname, accident_count\nFROM accident_counts\nORDER BY accident_count DESC\nLIMIT 1;",
            "SELECT COUNT(T1.driverId) \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nJOIN status AS T3 ON T1.statusId = T3.statusId \nWHERE T2.name = 'Canadian Grand Prix' \nAND T3.statusId = 3 \nGROUP BY T1.driverId \nORDER BY COUNT(T1.driverId) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.driverId) AS accident_count\nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nJOIN status T3 ON T1.statusId = T3.statusId\nWHERE T2.name = 'Canadian Grand Prix'\nAND T1.statusId = 3\nGROUP BY T1.driverId\nORDER BY accident_count DESC\nLIMIT 1"
        ]
    },
    "550": {
        "question": "From which post is the most popular tag excerpted from? Please give the body of the post.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Body FROM posts WHERE id = ( SELECT ExcerptPostId FROM tags ORDER BY Count DESC LIMIT 1 )",
        "amends": [],
        "rules": [
            "most popular tag refers to Max(Count); excerpt from refer to ExcerptPostId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Body \nFROM posts p \nJOIN tags t ON p.Id = t.ExcerptPostId \nWHERE t.Count = (SELECT MAX(Count) FROM tags);"
        ],
        "rule_sql": []
    },
    "1315": {
        "question": "How many students of the Student_Club have attended the event \"Women's Soccer\"?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
        "amends": [],
        "rules": [
            "Women's Soccer is an event name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(link_to_member) AS student_count\nFROM attendance\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = \"Women's Soccer\");"
        ],
        "rule_sql": []
    },
    "1335": {
        "question": "How much did the Student_Club members spend on advertisement in September Meeting?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Advertisement' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "amends": [],
        "rules": [
            "amount spent refers to spent; spend on food in September Meeting refers to category = 'Advertisement' where event_name = 'September Meeting'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(b.spent) AS total_spent_on_advertisement\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'September Meeting' AND b.category = 'Advertisement';"
        ],
        "rule_sql": []
    },
    "3": {
        "question": "What is the unabbreviated mailing street address of the school with the highest FRPM count for K-12 students?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.MailStreet FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.MailStreet\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE f.\"FRPM Count (K-12)\" = (SELECT MAX(\"FRPM Count (K-12)\") FROM frpm);"
        ],
        "rule_sql": []
    },
    "149": {
        "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
        "db_id": "financial",
        "ground_truth": "SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
        "amends": [],
        "rules": [
            "A11 represents the average salary; Salary and income share the similar meanings; when the account type = 'OWNER', it's eligible for loans"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT d.type\nFROM disp d\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE d.type != 'OWNER'\nAND di.A11 > 8000 AND di.A11 <= 9000;"
        ],
        "rule_sql": []
    },
    "602": {
        "question": "List out all post ID with score more than 60 and list out all the user ID that created these post.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT PostId, UserId FROM postHistory WHERE PostId IN ( SELECT Id FROM posts WHERE Score > 60 )",
        "amends": [
            "Do select `PostId` and `UserId` directly instead of selecting `Id AS PostId` and `OwnerUserId AS UserId`. Do query from `postHistory` table instead of `posts` table. Do use a subquery with `PostId IN (SELECT Id FROM posts WHERE Score > 60)` instead of applying the `Score > 60` filter directly in the main query. Do remove the direct `WHERE Score > 60` condition from the main query and instead filter through the subquery on the posts table. The amended query now correctly retrieves post history records for posts with high scores by using the appropriate table relationships and filtering logic."
        ],
        "rules": [
            "1) When the question asks for post IDs with score more than 60: filter posts using the condition \"Score > 60\" on the posts table to identify qualifying post IDs.\n2) When retrieving post history records for specific posts: use a subquery with \"PostId IN (SELECT Id FROM posts WHERE Score > 60)\" to filter postHistory records based on the qualifying post IDs.\n3) When selecting columns from the postHistory table: directly select \"PostId\" and \"UserId\" without using aliases like \"Id AS PostId\" or \"OwnerUserId AS UserId\".\n4) When the question requires listing both post IDs and user IDs: ensure both \"PostId\" and \"UserId\" columns are included in the output.\n5) When working with the postHistory table structure: recognize that it contains both \"PostId\" and \"UserId\" columns that can be selected directly.\nOutput columns (ordered): PostId, UserId"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Id AS PostId, OwnerUserId AS UserId FROM posts WHERE Score > 60;",
            "SELECT PostId, UserId FROM postHistory WHERE PostId IN (SELECT Id FROM posts WHERE Score > 60)"
        ],
        "rule_sql": [
            "SELECT PostId, UserId FROM postHistory WHERE PostId IN (SELECT Id FROM posts WHERE Score > 60)"
        ]
    },
    "402": {
        "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
        "amends": [
            "Do use a single query with conditional aggregation instead of multiple CTEs and cross join. Do calculate the percentage directly with `CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)` instead of computing separate counts and dividing them. Do apply the `isStorySpotlight = 1` filter in the `WHERE` clause instead of handling it in a separate CTE. Do remove the `GROUP_CONCAT` operation for spotlight IDs instead of including them in the result. Do eliminate the cross join between CTEs instead of using `FROM total_cards, story_spotlight_cards`. The amended query now correctly calculates the percentage of non-textless cards among story spotlight cards and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a percentage of entities with a specific condition: calculate the ratio using conditional aggregation with exact column tokens and literals from the schema.\n2) When filtering for Story Spotlight cards: apply the condition \"isStorySpotlight = 1\" using the exact literal value shown in the amends.\n3) When counting cards without text boxes: use the condition \"isTextless = 0\" with the exact literal value from the amends.\n4) When calculating percentages: use the formula (count of matching entities) divided by (total count of filtered entities) multiplied by 100.\n5) When the question asks to list entities by ID but the correct approach removes this requirement: do not include entity IDs in the output when they are not part of the final result.\n6) When working with a single table: avoid unnecessary CTEs and cross joins by performing all calculations in a single query.\nOutput columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH total_cards AS (\n    SELECT COUNT(*) AS total FROM cards\n),\nstory_spotlight_cards AS (\n    SELECT COUNT(*) AS spotlight_count, GROUP_CONCAT(id) AS spotlight_ids \n    FROM cards \n    WHERE isStorySpotlight = 1 AND isTextless = 0\n)\nSELECT \n    (spotlight_count * 100.0 / total) AS percentage,\n    spotlight_ids AS story_spotlight_card_ids\nFROM total_cards, story_spotlight_cards;",
            "SELECT \n    CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) AS percentage\nFROM cards\nWHERE isStorySpotlight = 1;"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN isTextless = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards\nWHERE \n    isStorySpotlight = 1"
        ]
    },
    "1533": {
        "question": "For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price / T1.Amount > 29.00 AND T1.ProductID = 5 AND T2.Date = '201208'",
        "amends": [
            "Do select only `T2.Consumption` instead of including `t.CustomerID` in the SELECT list. Do use `INNER JOIN` with explicit `AS` aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do move the `(t.Price / t.Amount) > 29.00` filter directly to the WHERE clause instead of keeping it parenthesized. Do place all WHERE conditions (`T1.Price / T1.Amount > 29.00`, `T1.ProductID = 5`, and `T2.Date = '201208'`) as separate AND conditions instead of grouping the price/amount calculation. The amended query now correctly returns only consumption values for the specified criteria."
        ],
        "rules": [
            "1) When the question asks for consumption status: output only T2.Consumption column.\n2) When joining transactions_1k and yearmonth tables: use inner join where T1.CustomerID = T2.CustomerID with aliases T1 for transactions_1k and T2 for yearmonth.\n3) When filtering for product id No.5: include condition T1.ProductID = 5.\n4) When filtering for price per unit greater than 29.00: include condition T1.Price / T1.Amount > 29.00.\n5) When filtering for August 2012: include condition T2.Date = '201208'.\n6) When combining multiple conditions: use AND to connect all filter conditions (T1.Price / T1.Amount > 29.00, T1.ProductID = 5, and T2.Date = '201208').\nOutput columns (ordered): T2.Consumption"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.CustomerID, y.Consumption\nFROM transactions_1k t\nJOIN yearmonth y ON t.CustomerID = y.CustomerID\nWHERE t.ProductID = 5 AND (t.Price / t.Amount) > 29.00 AND y.Date = '201208'",
            "SELECT T2.Consumption\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Price / T1.Amount > 29.00\nAND T1.ProductID = 5\nAND T2.Date = '201208'"
        ],
        "rule_sql": [
            "SELECT T2.Consumption \nFROM transactions_1k T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.ProductID = 5 \nAND T1.Price / T1.Amount > 29.00\nAND T2.Date = '201208'"
        ]
    },
    "799": {
        "question": "How many superheroes didn't have any publisher?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.id = 1",
        "amends": [
            "Do add an `INNER JOIN` on `publisher` with predicate `T1.publisher_id = T2.id` instead of querying `superhero` alone. Do change the count expression to `COUNT(T1.id)` instead of `COUNT(*)`. Do add a `WHERE` filter for `T2.id = 1` instead of checking for `publisher_id IS NULL`. Do remove the null check condition entirely instead of including it. The amended query now correctly counts superheroes from a specific publisher rather than those without any publisher association."
        ],
        "rules": [
            "1) When the question asks for superheroes without a publisher: use an INNER JOIN between superhero (T1) and publisher (T2) with the condition T1.publisher_id = T2.id instead of querying superhero alone. 2) When counting superheroes: use COUNT(T1.id) instead of COUNT(*) to count using the canonical key. 3) When filtering for specific publisher relationships: use T2.id = 1 as the filter condition instead of checking for publisher_id IS NULL. 4) When the question implies missing publisher associations: remove null check conditions entirely from the query. 5) Output columns (ordered): COUNT(T1.id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superhero WHERE publisher_id IS NULL;",
            "SELECT COUNT(T1.id) \nFROM superhero T1 \nINNER JOIN publisher T2 ON T1.publisher_id = T2.id \nWHERE T2.id = 1"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) FROM superhero T1 INNER JOIN publisher T2 ON T1.publisher_id = T2.id WHERE T2.id = 1"
        ]
    },
    "508": {
        "question": "What are the available printing types of the cards that doesn't have a text box created by Aleksi Briclot?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1",
        "amends": [],
        "rules": [
            "created by Aleksi Briclot refers to artist = 'Aleksi Briclot'; doesn't have a text box refers to isTextless = 1; available printing types refers to availability"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1;"
        ],
        "rule_sql": []
    },
    "1160": {
        "question": "What is the percentage of female patient had total protein not within the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F'",
        "amends": [
            "Do use `SUM(CASE ... THEN 1 ELSE 0 END)` with explicit ELSE instead of `COUNT(CASE ... THEN 1 END)` for conditional counting. Do cast the sum to `REAL` instead of using decimal literal `100.0` for proper floating-point division. Do use `COUNT(*)` in the denominator instead of `COUNT(CASE WHEN P.SEX = 'F' THEN 1 END)` since the WHERE clause already filters for female patients. Do remove the redundant `L.TP IS NOT NULL` condition from the WHERE clause instead of keeping it, as the CASE statement already handles NULL values implicitly. Do use table aliases `T1` and `T2` instead of full table names for better readability. The amended query now correctly calculates the percentage without redundant filtering and ensures proper numeric handling.",
            "Do add `T1.SEX = 'F'` condition inside the CASE expression instead of only in the WHERE clause, to ensure the percentage calculation only counts female patients. Do change the TP threshold range from `< 6.5 OR > 8.2` to `< 6.0 OR > 8.5` to use the correct medical reference values. Do add explicit `CAST(... AS REAL)` instead of implicit type conversion to ensure proper floating-point division. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. The amended query now correctly calculates the percentage of female patients with abnormal TP values using the proper clinical thresholds and ensures accurate type handling for the division operation."
        ],
        "rules": [
            "1) When counting female patients with abnormal total protein values: use SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) instead of COUNT(CASE ... THEN 1 END) for conditional counting.\n2) When calculating percentages: cast the numerator to REAL instead of using decimal literal 100.0 for proper floating-point division.\n3) When the WHERE clause already filters for female patients: use COUNT(*) in the denominator instead of COUNT(CASE WHEN T1.SEX = 'F' THEN 1 END) to avoid redundant filtering.\n4) When CASE statements handle NULL values implicitly: remove redundant IS NOT NULL conditions from the WHERE clause.\n5) When combining Patient and Laboratory tables: use table aliases T1 and T2 instead of full table names for better readability.\n6) When linking Patient and Laboratory tables: match rows where T1.ID = T2.ID to combine patient and lab data.\n7) Output columns (ordered): percentage",
            "1) When calculating percentages for a specific patient group (female patients): include the group condition T1.SEX = 'F' within the counting logic rather than only in filtering.\n2) When using medical reference ranges for total protein (TP): apply the threshold range < 6.0 OR > 8.5 instead of other ranges.\n3) When performing floating-point division in percentage calculations: use explicit type conversion to ensure proper decimal arithmetic.\n4) When joining Patient and Laboratory tables: use an inner match on T1.ID = T2.ID to combine patient records with their lab results.\n5) Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN (P.SEX = 'F' AND (L.TP < 6.0 OR L.TP > 8.5)) THEN 1 END) * 100.0 / \n    COUNT(CASE WHEN P.SEX = 'F' THEN 1 END)) AS percentage\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.SEX = 'F' AND L.TP IS NOT NULL;",
            "SELECT \n    (SUM(CASE WHEN T2.TP < 6.5 OR T2.TP > 8.2 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient T1\nJOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100.0 AS percentage\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient T1\nJOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'"
        ]
    },
    "519": {
        "question": "What is the language of the \"Battlebond\" set?",
        "db_id": "card_games",
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM sets WHERE name = 'Battlebond' )",
        "amends": [
            "Do use a subquery with `id IN (SELECT id FROM sets WHERE name = 'Battlebond')` instead of joining on `set_translations st JOIN sets s ON st.setCode = s.code`. Do remove the table alias `st` from the `SELECT language` clause instead of including it. Do change the join condition to use the correct correlation through `id` instead of the incorrect `setCode = s.code` relationship. The amended query now correctly filters set translations based on the set name through a subquery rather than an incorrect join, matching the right SQL's behavior.",
            "Do use `id` in the WHERE clause instead of `setCode` for the subquery correlation. Do reference `id` in the subquery's SELECT list instead of `code` to properly match the parent query's filter condition. The amended query now correctly correlates the subquery through the `id` column instead of the incorrect `setCode` relationship, ensuring it matches the intended behavior of filtering set_translations based on set IDs from the specified set name.",
            "Do use `id` in the WHERE clause instead of `setCode` for the subquery correlation. Do reference `id` in the subquery's SELECT list instead of `code` to ensure proper join semantics between the tables. This change fixes the logical relationship between set_translations and sets tables by using the correct primary key identifier instead of a potentially ambiguous code field. The amended query now correctly matches the intended behavior of filtering translations based on set IDs rather than set codes.",
            "Do use `id` in the WHERE clause instead of `setCode` for the subquery correlation. Do reference `id` in the subquery's SELECT list instead of `code` to properly match the parent query's filter condition. The amended query now correctly correlates the set_translations table with the sets table using the id column instead of the incorrect setCode to code relationship, ensuring proper data retrieval based on the set name.",
            "Do use `id` in the WHERE clause instead of `setCode` for the subquery correlation. Do reference `id` in the subquery's SELECT list instead of `code` to properly match the parent query's filter condition. The amended query now correctly correlates the set_translations table with the sets table using the id column instead of the incorrect setCode reference, ensuring proper data retrieval based on the Battlebond set name."
        ],
        "rules": [
            "1) When the question asks for the language of a specific set by name: use a subquery to find the set id where the name matches the exact literal 'Battlebond' from the sets table. 2) When filtering set translations based on set name: use the id column from the subquery result instead of joining on setCode = code relationship. 3) When selecting the language column: reference it directly without table alias. 4) When handling the set name literal: preserve the exact case and spelling 'Battlebond'. 5) Output columns (ordered): language",
            "1) When the question asks for the language of a specific set by name: filter the sets table using the exact literal value 'Battlebond' for the name column to find the matching set ID. 2) When joining set_translations to sets: use the relationship where set_translations.setCode equals sets.code to properly correlate the tables. 3) When retrieving language information from set_translations: select the language column from set_translations after filtering by the correct set ID obtained from the sets table. 4) When using subqueries to filter by set name: ensure the subquery returns the code column from sets to match against setCode in set_translations, not the id column. 5) Output columns (ordered): set_translations.language",
            "1) When the question asks for the language of a specific set by name: filter the sets table using the exact literal 'Battlebond' for the name column. 2) When joining set_translations to sets: use the primary key relationship where set_translations.setCode equals sets.code to ensure proper correlation. 3) When retrieving language information from set_translations: select the language column from the set_translations table. 4) When using subqueries to filter by set name: ensure the subquery returns the correct identifier (sets.code) that matches the join condition with set_translations.setCode. 5) Output columns (ordered): set_translations.language",
            "1) When the question asks for the language of a specific set by name: use the exact literal \"Battlebond\" to filter the sets table. 2) When joining set_translations with sets: link rows where set_translations.setCode equals sets.code exactly as shown in the schema foreign key relationship. 3) When retrieving language information from set_translations: use the set_translations.language column. 4) When filtering by set name in sets: use the sets.name column with the exact literal value \"Battlebond\". 5) Output columns (ordered): set_translations.language",
            "1) When the question asks for the language of a specific set by name: use the exact literal 'Battlebond' to match the set name. 2) When combining set_translations and sets tables: link rows where set_translations.setCode equals sets.code to properly correlate the tables. 3) When filtering for a specific set by name: use the sets table to find the set with name = 'Battlebond' and use its code value to filter the set_translations table. 4) When retrieving language information: select the language column from set_translations table. 5) Output columns (ordered): set_translations.language"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.name = 'Battlebond';",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE name = 'Battlebond');",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE name = 'Battlebond')",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE name = 'Battlebond');",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE name = 'Battlebond')",
            "SELECT language FROM set_translations WHERE id IN (SELECT id FROM sets WHERE name = 'Battlebond')"
        ],
        "rule_sql": [
            "SELECT set_translations.language FROM set_translations WHERE set_translations.setCode = (SELECT code FROM sets WHERE name = 'Battlebond')"
        ]
    },
    "834": {
        "question": "Among all superheroes created by George Lucas, identify the percentage of female superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas'",
        "amends": [],
        "rules": [
            "created by George Lucas refers to publisher_name = 'George Lucas'; percentage = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'George Lucas'), COUNT(publisher_name = 'George Lucas')), 100.0); female refers to gender = 'Female';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    gender g ON s.gender_id = g.id\nWHERE \n    p.publisher_name = 'George Lucas';"
        ],
        "rule_sql": []
    },
    "423": {
        "question": "Please provide the ids of top three powerful pairs of Kingdom Foil and Kingdom Cards sorted by Kingdom Foil id in alphabetical order.",
        "db_id": "card_games",
        "ground_truth": "SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId LIMIT 3",
        "amends": [
            "Do select `cardKingdomFoilId, cardKingdomId` instead of just `id` in the SELECT list. Do remove the redundant `ASC` keyword from the ORDER BY clause instead of keeping it. The amended query now correctly returns both card kingdom identifiers while maintaining the same filtering and ordering behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"top three powerful pairs of Kingdom Foil and Kingdom Cards\": select the first 3 rows after ordering by the specified column. 2) When the question specifies \"sorted by Kingdom Foil id in alphabetical order\": order rows by cardKingdomFoilId in ascending order. 3) When the question asks for both Kingdom Foil and Kingdom Card identifiers: include both cardKingdomFoilId and cardKingdomId in the output columns. 4) When filtering for pairs where both identifiers exist: only include rows where both cardKingdomFoilId and cardKingdomId are not null. 5) Output columns (ordered): cardKingdomFoilId, cardKingdomId"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId ASC LIMIT 3;",
            "SELECT cardKingdomFoilId, cardKingdomId \nFROM cards \nWHERE cardKingdomFoilId IS NOT NULL \nAND cardKingdomId IS NOT NULL \nORDER BY cardKingdomFoilId \nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT cardKingdomFoilId, cardKingdomId \nFROM cards \nWHERE cardKingdomFoilId IS NOT NULL \nAND cardKingdomId IS NOT NULL \nORDER BY cardKingdomFoilId ASC \nLIMIT 3"
        ]
    },
    "127": {
        "question": "List the account IDs with monthly issuance of statements.",
        "db_id": "financial",
        "ground_truth": "SELECT account_id FROM account WHERE Frequency = 'POPLATEK MESICNE'",
        "amends": [],
        "rules": [
            "'POPLATEK MESICNE' stands for monthly issuance"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id FROM account WHERE frequency = 'POPLATEK MESICNE';"
        ],
        "rule_sql": []
    },
    "1430": {
        "question": "What is the last name and position of the student that bought pizza on 09/10/2019?",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.last_name, T1.position FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.expense_date = '2019-09-10' AND T2.expense_description = 'Pizza'",
        "amends": [],
        "rules": [
            "bought pizza on 09/10/2019 refers to expense_description = 'Pizza' where expense_date = '2019-09-10'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.last_name, m.position\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.expense_description = 'Pizza' AND e.expense_date = '2019-09-10';"
        ],
        "rule_sql": []
    },
    "1352": {
        "question": "For all the club members from \"Business\" major, how many of them wear medium size t-shirt?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'",
        "amends": [],
        "rules": [
            "'Business' is a major name; wear medium size t-shirt refers to t_shirt_size = 'Medium'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' AND m.t_shirt_size = 'Medium';"
        ],
        "rule_sql": []
    },
    "1045": {
        "question": "What is the attacking work rate of the football playerr Franco Zennaro?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Franco Zennaro'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pa.attacking_work_rate\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Franco Zennaro';"
        ],
        "rule_sql": []
    },
    "1245": {
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "amends": [
            "Do count `T1.ID` instead of `COUNT(*)` to avoid counting nulls. Do use `Patient` table as `T1` instead of omitting it entirely. Do use `INNER JOIN` between `Patient` and `Laboratory` instead of joining `Examination` with `Laboratory`. Do join on `T1.ID = T2.ID` instead of `e.ID = l.ID` to properly link patient records. Do filter on `T2.Date > '1997-01-01'` instead of `e.Examination Date > '1997-01-01'` to use the correct date column from Laboratory. Do keep `T2.APTT >= 45` filter but reference it through the proper table alias. The amended query now correctly counts patients with laboratory results meeting the date and APTT criteria."
        ],
        "rules": [
            "1) When the question asks for examinations done after a specific date: filter rows where T2.Date > '1997-01-01' using the exact date literal.\n2) When the question asks for results of an inactivated partial prothrombin time: filter rows where T2.APTT >= 45 using the exact column token and value.\n3) When counting patients with specific laboratory criteria: count distinct T1.ID values to avoid counting nulls and ensure each patient is counted only once.\n4) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using exact key equality and perform an inner match to keep only patients with laboratory records.\n5) When handling table aliases: use T1 for Patient table and T2 for Laboratory table as established by the amends.\n6) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE e.`Examination Date` > '1997-01-01'\nAND l.APTT >= 45;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date > '1997-01-01' AND T2.APTT >= 45"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.Date > '1997-01-01' AND T2.APTT >= 45"
        ]
    },
    "362": {
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "amends": [],
        "rules": [
            "Ancestor's Chosen' is the name of card; description about the ruling refers to text;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Condemn';"
        ],
        "rule_sql": []
    },
    "382": {
        "question": "What are the cards that only available in paper and Japanese language?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'Japanese'",
        "amends": [
            "Do select only `T1.name` instead of `c.*` and remove `DISTINCT` instead of keeping it. Do use `INNER JOIN` instead of `JOIN` while maintaining the same join condition `T1.uuid = T2.uuid`. Do keep the same `WHERE` filters for `T1.availability = 'paper'` and `T2.language = 'Japanese'` but use table aliases `T1` and `T2` instead of `c` and `fd`. The amended query now correctly returns only Japanese paper card names without duplicates, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting card names that are only available in paper and Japanese language: output only the T1.name column instead of all columns from T1. 2) When the question asks for cards without duplicates: do not use DISTINCT in the selection. 3) When combining the cards table (T1) with foreign_data table (T2): use INNER JOIN to link rows where T1.uuid = T2.uuid exactly. 4) When filtering for paper availability: use the exact condition T1.availability = 'paper' with the literal value 'paper'. 5) When filtering for Japanese language: use the exact condition T2.language = 'Japanese' with the literal value 'Japanese'. 6) Output columns (ordered): T1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.* FROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.availability = 'paper' AND fd.language = 'Japanese';",
            "SELECT T1.name\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.availability = 'paper'\nAND T2.language = 'Japanese'"
        ],
        "rule_sql": [
            "SELECT T1.name FROM cards T1 INNER JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'Japanese'"
        ]
    },
    "1004": {
        "question": "How many wins was achieved by the oldest racer? Indicate his/her full name.",
        "db_id": "formula_1",
        "ground_truth": "SELECT SUM(T1.wins),T2.forename, T2.surname FROM driverStandings AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId ORDER BY T2.dob ASC LIMIT 1",
        "amends": [
            "Do select `SUM(T1.wins)`, `T2.forename`, and `T2.surname` instead of `full_name` and `SUM(ds.wins) AS total_wins`. Do use a direct `INNER JOIN` between `driverStandings AS T1` and `drivers AS T2` on `T1.driverId = T2.driverId` instead of the CTE approach with multiple joins through `oldest_driver`. Do remove the `GROUP BY od.driverId` clause instead of keeping it. Do add `ORDER BY T2.dob ASC LIMIT 1` to get the oldest driver's record instead of using a CTE to find the oldest driver first. The amended query now correctly identifies the oldest driver and sums their wins in a single efficient query rather than the previous approach that would return wins for all drivers grouped by driverId."
        ],
        "rules": [
            "1) When the question asks for the oldest racer: order rows by T2.dob in ascending order and keep only the first row.\n2) When combining driver standings and drivers tables: link rows where T1.driverId equals T2.driverId and keep only matching pairs (inner match).\n3) When calculating total wins: sum the values from T1.wins for the matching rows.\n4) When outputting the driver's full name: return both T2.forename and T2.surname as separate columns instead of concatenating them.\n5) When the question asks for count of wins: use the sum of T1.wins rather than counting rows.\nOutput columns (ordered): T2.forename, T2.surname, SUM(T1.wins)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH oldest_driver AS (\n    SELECT driverId, forename, surname, dob\n    FROM drivers\n    ORDER BY dob ASC\n    LIMIT 1\n)\nSELECT d.forename || ' ' || d.surname AS full_name, SUM(ds.wins) AS total_wins\nFROM oldest_driver od\nJOIN driverStandings ds ON od.driverId = ds.driverId\nJOIN drivers d ON od.driverId = d.driverId\nGROUP BY od.driverId;",
            "SELECT SUM(T1.wins) AS total_wins, T2.forename, T2.surname\nFROM driverStandings AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nORDER BY T2.dob ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.forename, T2.surname, SUM(T1.wins) \nFROM driverStandings T1 \nINNER JOIN drivers T2 ON T1.driverId = T2.driverId \nWHERE T2.dob = (SELECT MIN(dob) FROM drivers) \nGROUP BY T2.driverId, T2.forename, T2.surname"
        ]
    },
    "237": {
        "question": "Which molecule does the atom TR001_10 belong to? Please state whether this molecule is carcinogenic or not.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.molecule_id , IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'",
        "amends": [
            "Do use `T2.molecule_id` and `IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic` instead of `m.molecule_id, m.label, CASE WHEN m.label = '+' THEN 'Carcinogenic' ELSE 'Not Carcinogenic' END AS carcinogenic_status`. Do use `INNER JOIN` with explicit alias `AS T2` instead of `JOIN` with simple alias `m`. Do use table alias `AS T1` for atom table instead of no alias. Do use `flag_carcinogenic` as the column alias instead of `carcinogenic_status`. The amended query now correctly returns 'YES'/'NO' flags for carcinogenic status and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about an atom with specific ID 'TR001_10': filter rows from T1 where T1.atom_id equals 'TR001_10' exactly. 2) When combining atom and molecule tables: link rows where T1.molecule_id equals T2.molecule_id exactly and keep only matching pairs (inner match). 3) When determining carcinogenic status: use the exact condition T2.label = '+' to return 'YES' for carcinogenic and 'NO' for non-carcinogenic. 4) When the question asks which molecule an atom belongs to: include T2.molecule_id in the output. 5) Output columns (ordered): T2.molecule_id, IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.molecule_id, m.label,\n       CASE WHEN m.label = '+' THEN 'Carcinogenic' ELSE 'Not Carcinogenic' END AS carcinogenic_status\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.atom_id = 'TR001_10';",
            "SELECT T2.molecule_id, IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.atom_id = 'TR001_10'"
        ],
        "rule_sql": [
            "SELECT T2.molecule_id, IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.atom_id = 'TR001_10'"
        ]
    },
    "1373": {
        "question": "How many of the members' hometowns are from Maryland state?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T2.member_id) FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T1.state = 'Maryland'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT m.member_id) \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE z.state = 'Maryland';"
        ],
        "rule_sql": []
    },
    "1462": {
        "question": "What category was budgeted for the 'January Speaker' event and how much was the amount budgeted for that category?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.category, T2.amount FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'January Speaker'",
        "amends": [],
        "rules": [
            "amount budgeted refers to amount, 'January Speaker' is the event name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.category, b.amount\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'January Speaker';"
        ],
        "rule_sql": []
    },
    "1225": {
        "question": "List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID,T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 GROUP BY T1.SEX,T1.ID",
        "amends": [
            "Do select `T1.ID` and `T1.SEX` instead of `p.SEX` and `GROUP_CONCAT(DISTINCT p.ID) AS Patient_List`. Do use `INNER JOIN` with alias `Laboratory AS T2` instead of `JOIN` with alias `l`. Do add `T1.ID` to the `GROUP BY` clause instead of grouping only by `T1.SEX`. Do remove the `GROUP_CONCAT` aggregation and distinct patient list concatenation instead of keeping it. The amended query now correctly selects individual patient IDs with their sex rather than concatenating them, and properly groups by both ID and sex to avoid aggregation issues.",
            "Do change the WHERE condition to `T-BIL >= 2.0` instead of `T-BIL IS NOT NULL AND (T-BIL < 0.2 OR T-BIL > 1.2)` to filter for higher bilirubin values. Do maintain the same `INNER JOIN` on `T1.ID = T2.ID` and keep the same `SELECT` list with `T1.ID, T1.SEX`. Do preserve the `GROUP BY` clause but note the column order change from `T1.ID, T1.SEX` to `T1.SEX, T1.ID` which is functionally equivalent. The amended query now correctly identifies patients with elevated bilirubin levels (\u22652.0) instead of the previous complex range exclusion logic."
        ],
        "rules": [
            "1) When the question asks to list patients grouped by sex: select both T1.ID and T1.SEX as output columns instead of aggregating patient IDs.\n2) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match).\n3) When filtering for T-BIL levels not within normal range: include rows where T2.\"T-BIL\" is greater than or equal to 2.0.\n4) When grouping results: organize by both T1.ID and T1.SEX instead of grouping by sex alone.\n5) Output columns (ordered): T1.ID, T1.SEX",
            "1) When filtering for total bilirubin levels not within normal range: use T2.\"T-BIL\" >= 2.0 as the condition instead of checking for null values and range exclusions.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When grouping patients by sex: organize results by T1.SEX and T1.ID in that order.\n4) When selecting output columns: include T1.ID and T1.SEX in the result.\n5) Output columns (ordered): T1.ID, T1.SEX"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    p.SEX,\n    GROUP_CONCAT(DISTINCT p.ID) AS Patient_List\nFROM \n    Patient p\nJOIN \n    Laboratory l ON p.ID = l.ID\nWHERE \n    l.`T-BIL` >= 2.0\nGROUP BY \n    p.SEX;",
            "SELECT T1.ID, T1.SEX\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.\"T-BIL\" IS NOT NULL AND (T2.\"T-BIL\" < 0.2 OR T2.\"T-BIL\" > 1.2)\nGROUP BY T1.ID, T1.SEX",
            "SELECT T1.ID, T1.SEX\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.\"T-BIL\" >= 2.0\nGROUP BY T1.ID, T1.SEX"
        ],
        "rule_sql": [
            "SELECT T1.ID, T1.SEX\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.\"T-BIL\" >= 2.0\nGROUP BY T1.SEX, T1.ID\nORDER BY T1.SEX, T1.ID"
        ]
    },
    "164": {
        "question": "Who placed the order with the id 32423?",
        "db_id": "financial",
        "ground_truth": "SELECT T3.client_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T4.account_id = T2.account_id  INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE T1.order_id = 32423",
        "amends": [
            "Do select only `client_id` instead of including `gender`, `birth_date`, and `district_id`. Do add `account` table with `INNER JOIN` on `T1.account_id = T2.account_id` instead of omitting it. Do change the join path from directly joining `disp` to `order` to instead join `disp` to `account` on `T4.account_id = T2.account_id`. Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of no aliases. The amended query now correctly follows the account relationship path and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about an order with a specific ID: filter rows where T1.order_id equals 32423 exactly.\n2) When combining tables for account relationships: link T1 (order) and T2 (account) where T1.account_id equals T2.account_id exactly (inner match).\n3) When combining tables for client relationships: link T2 (account) and T3 (disp) where T2.account_id equals T3.account_id exactly (inner match).\n4) When combining tables for client details: link T3 (disp) and T4 (client) where T3.client_id equals T4.client_id exactly (inner match).\n5) When the question asks \"who placed the order\": select only the client_id column from the client table (T4.client_id).\n6) When the question specifies exact identifiers: use table aliases T1 for order, T2 for account, T3 for disp, and T4 for client as established in the amends.\nOutput columns (ordered): T4.client_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.client_id, c.gender, c.birth_date, c.district_id\nFROM `order` o\nJOIN disp d ON o.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE o.order_id = 32423;",
            "SELECT T3.client_id\nFROM `order` T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T4 ON T4.account_id = T2.account_id\nINNER JOIN client T3 ON T4.client_id = T3.client_id\nWHERE T1.order_id = 32423;"
        ],
        "rule_sql": [
            "SELECT T4.client_id\nFROM `order` AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nINNER JOIN disp AS T3 ON T2.account_id = T3.account_id\nINNER JOIN client AS T4 ON T3.client_id = T4.client_id\nWHERE T1.order_id = 32423"
        ]
    },
    "155": {
        "question": "How many percent of 'Gold' cards were issued prior to 1998?",
        "db_id": "financial",
        "ground_truth": "SELECT CAST(SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') AS REAL) * 100 / COUNT(card_id) FROM card",
        "amends": [],
        "rules": [
            "Percent of Gold = [ count(type = 'gold' and issued date < 1998) / count(all cards)] * 100%"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN type = 'gold' AND issued < '1998-01-01' THEN 1 END) * 100.0 / COUNT(*)) AS percent_gold_pre_1998\nFROM card;"
        ],
        "rule_sql": []
    },
    "772": {
        "question": "List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'",
        "amends": [
            "Do select `T1.eye_colour_id`, `T1.hair_colour_id`, and `T1.skin_colour_id` instead of joining colour tables to get `eyes`, `hair`, and `skin` aliases. Do join `publisher AS T2` on `T2.id = T1.publisher_id` instead of joining `publisher` without table aliases. Do join `gender AS T3` on `T3.id = T1.gender_id` instead of joining `gender` without table aliases. Do remove all colour table joins (`eye_colour`, `hair_colour`, `skin_colour`) instead of including them unnecessarily. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for clarity. Do place both filter conditions in the `WHERE` clause instead of keeping them separate. The amended query now correctly retrieves the ID values directly from the superhero table without unnecessary joins to colour tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for female superheroes: filter rows where T3.gender equals 'Female' exactly.\n2) When the question asks for superheroes published by Dark Horse Comics: filter rows where T2.publisher_name equals 'Dark Horse Comics' exactly.\n3) When combining superhero table T1 with publisher table T2: link rows where T2.id equals T1.publisher_id and keep only matching pairs.\n4) When combining superhero table T1 with gender table T3: link rows where T3.id equals T1.gender_id and keep only matching pairs.\n5) When the question asks for eye, hair, and skin colour: select T1.eye_colour_id, T1.hair_colour_id, and T1.skin_colour_id directly from the superhero table instead of joining to colour tables.\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.\n7) When handling text literals: do not change case, spacing, or punctuation of 'Female' or 'Dark Horse Comics'.\n8) When referring to table roles: do not rename or swap the aliases T1 (superhero), T2 (publisher), T3 (gender) once set for this schema.\n9) When combining tables specified as inner matches: do not perform outer matches or cartesian combinations.\nOutput columns (ordered): T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    eye_colour.colour AS eyes, \n    hair_colour.colour AS hair, \n    skin_colour.colour AS skin\nFROM \n    superhero\nJOIN \n    gender ON superhero.gender_id = gender.id\nJOIN \n    publisher ON superhero.publisher_id = publisher.id\nJOIN \n    colour AS eye_colour ON superhero.eye_colour_id = eye_colour.id\nJOIN \n    colour AS hair_colour ON superhero.hair_colour_id = hair_colour.id\nJOIN \n    colour AS skin_colour ON superhero.skin_colour_id = skin_colour.id\nWHERE \n    gender.gender = 'Female'\n    AND publisher.publisher_name = 'Dark Horse Comics';",
            "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T2.id = T1.publisher_id\nINNER JOIN gender AS T3 ON T3.id = T1.gender_id\nWHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female';"
        ],
        "rule_sql": [
            "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id\nFROM superhero T1\nINNER JOIN publisher T2 ON T2.id = T1.publisher_id\nINNER JOIN gender T3 ON T3.id = T1.gender_id\nWHERE T3.gender = 'Female'\nAND T2.publisher_name = 'Dark Horse Comics'"
        ]
    },
    "1324": {
        "question": "What is the average attendance of meetings in 2020?",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE SUBSTR(T1.event_date, 1, 4) = '2020' AND T1.type = 'Meeting'",
        "amends": [],
        "rules": [
            "meetings in 2020 refers to type = 'Meeting' where YEAR(event_date) = 2020; average = DIVIDE(COUNT(event_id), COUNT(DISTINCT event_name))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(attendance_count) AS average_attendance\nFROM (\n    SELECT COUNT(*) AS attendance_count\n    FROM event e\n    JOIN attendance a ON e.event_id = a.link_to_event\n    WHERE e.event_date LIKE '2020%'\n    GROUP BY e.event_id\n);"
        ],
        "rule_sql": []
    },
    "1164": {
        "question": "How many of the patients with the most serious thrombosis cases examined in 1997 are women?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT  COUNT(*) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND STRFTIME('%Y', T2.`Examination Date`) = '1997' AND T2.Thrombosis = 1",
        "amends": [],
        "rules": [
            "the most serious thrombosis refers to Thrombosis = '1' (the most severe one); women refers to sex = 'F'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Examination E ON P.ID = E.ID \nWHERE E.Thrombosis = 1 \nAND strftime('%Y', E.`Examination Date`) = '1997' \nAND P.SEX = 'F';"
        ],
        "rule_sql": []
    },
    "548": {
        "question": "What is the location of the owner of the post \"Eliciting priors from experts\"?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'",
        "amends": [],
        "rules": [
            "Owner refers to OwnerUserId; 'Eliciting priors from experts' is the Title of post"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.Location\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Title = 'Eliciting priors from experts';"
        ],
        "rule_sql": []
    },
    "1106": {
        "question": "Tell the defensive work rate for Kevin Berigaud on 2013/2/22.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.defensive_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-02-22' AND t1.player_name = 'Kevin Berigaud'",
        "amends": [],
        "rules": [
            "Kevin Berigaud refers to player_name = 'Kevin Berigaud'; on 2013/2/22 refers to date = '2013-02-22 00:00:00'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pa.defensive_work_rate \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Kevin Berigaud' \nAND pa.date = '2013-02-22 00:00:00';"
        ],
        "rule_sql": []
    },
    "1055": {
        "question": "When is the birthday of the football player who has the highest overall rating?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.birthday FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
        "amends": [],
        "rules": [
            "football player who has the highest overall rating refers to MAX(overall_rating);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.birthday\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);"
        ],
        "rule_sql": []
    },
    "1190": {
        "error": "something went wrong, tool did not call.",
        "question": "What percentage of patients with a proteinuria level within the normal range have a uric acid level below the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Laboratory WHERE `U-PRO` > 0 AND `U-PRO` < 30",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs and cross join. Do calculate the percentage directly with `CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID)` instead of separate counts and division. Do remove the redundant `DISTINCT ID` counts and cross join between CTEs. Do eliminate the CASE statement for division by zero protection since COUNT(ID) will never be zero when filtering by `U-PRO` conditions. Do apply the `U-PRO` filter once in the WHERE clause instead of duplicating it across multiple CTEs. The amended query now correctly calculates the percentage of patients with low uric acid among those with normal proteinuria in a single efficient operation.",
            "Do change the WHERE clause filter to use numeric comparison `U-PRO > 0 AND U-PRO < 30` instead of string matching `U-PRO = '-' OR U-PRO = 'negative' OR U-PRO = 'Normal'` to properly handle numeric values rather than string representations. The amended query now correctly filters for U-PRO values between 0 and 30 and matches the RIGHT_SQL's behavior.",
            "Do use backticks around `U-PRO` column name instead of unquoted `U-PRO` to handle the hyphen properly in the WHERE clause. Do remove the alias `percentage` from the SELECT list instead of keeping it to match the simplified output format. The amended query now correctly handles the special character in the column name and produces the same calculation result without the output column alias."
        ],
        "rules": [
            "1) When calculating percentages from a single table: use conditional aggregation with SUM(CASE WHEN <CONDITION> THEN 1 ELSE 0 END) instead of separate CTEs and cross joins.\n2) When filtering for patients with normal proteinuria levels: apply the condition U-PRO > 0 AND U-PRO < 30 in the WHERE clause.\n3) When counting patients with low uric acid among those with normal proteinuria: use CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) for direct percentage calculation.\n4) When counting patients: use COUNT(ID) instead of COUNT(DISTINCT ID) when the ID column serves as the canonical patient identifier.\n5) When division by zero protection is unnecessary: eliminate CASE statements when the denominator COUNT(ID) will never be zero due to filtering conditions.\n6) When handling numeric comparisons: preserve exact literal values like 6.5 and 30 as shown in the conditions.\nOutput columns (ordered): percentage",
            "1) When filtering for proteinuria levels within normal range: use numeric comparison U-PRO > 0 AND U-PRO < 30 instead of string matching to handle numeric values properly. 2) When calculating percentage of patients with uric acid level below normal range: compute (number of patients with UA \u2264 6.5) divided by (total patients with normal proteinuria) multiplied by 100. 3) When handling laboratory test values: treat U-PRO as numeric values rather than string representations for proper range comparisons. 4) When counting patients: use the ID column as the counting key for both numerator and denominator calculations. Output columns (ordered): percentage",
            "1) When the question asks for percentage of patients with specific laboratory conditions: calculate the ratio of patients meeting the second condition among those meeting the first condition, expressed as a percentage.\n2) When handling column names with hyphens like \"U-PRO\": use backticks around the identifier to properly handle special characters.\n3) When the question specifies \"proteinuria level within the normal range\": use the condition `U-PRO` > 0 AND `U-PRO` < 30 to identify normal range values.\n4) When the question specifies \"uric acid level below the normal range\": use the condition UA <= 6.5 to identify below-normal values.\n5) When calculating percentages from count ratios: compute (count of patients meeting both conditions) divided by (count of patients meeting the first condition) multiplied by 100.\n6) When the output format requires simplified column naming: do not include column aliases in the final output.\nOutput columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH normal_proteinuria AS (\n    SELECT COUNT(DISTINCT ID) AS total_patients\n    FROM Laboratory\n    WHERE `U-PRO` > 0 AND `U-PRO` < 30\n),\nlow_uric_acid AS (\n    SELECT COUNT(DISTINCT ID) AS patients_with_low_ua\n    FROM Laboratory\n    WHERE `U-PRO` > 0 AND `U-PRO` < 30 AND UA <= 6.5\n)\nSELECT \n    CASE \n        WHEN total_patients = 0 THEN 0\n        ELSE (patients_with_low_ua * 100.0 / total_patients)\n    END AS percentage\nFROM normal_proteinuria, low_uric_acid;",
            "SELECT \n    CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) AS percentage\nFROM Laboratory\nWHERE `U-PRO` = '-' OR `U-PRO` = 'negative' OR `U-PRO` = 'Normal'",
            "SELECT \n    CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) AS percentage\nFROM Laboratory\nWHERE U-PRO > 0 AND U-PRO < 30",
            "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) \nFROM Laboratory \nWHERE `U-PRO` > 0 AND `U-PRO` < 30"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) AS percentage\nFROM \n    Laboratory\nWHERE \n    `U-PRO` > 0 AND `U-PRO` < 30"
        ]
    },
    "780": {
        "question": "List the powers of Hunter Zolomon.",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.full_name = 'Hunter Zolomon'",
        "amends": [],
        "rules": [
            "Hunter Zolomon is the full name of superhero; list the powers refers to power_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.full_name = 'Hunter Zolomon';"
        ],
        "rule_sql": []
    },
    "921": {
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "amends": [
            "Do select `T1.url` instead of `r.raceId, r.year, r.round, r.name AS race_name, r.date, r.time, c.name AS circuit_name, c.location, c.country`. Do use `DISTINCT` instead of omitting it. Do join `circuits AS T1` and `races AS T2` with `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of joining `races r` and `circuits c` with `JOIN` on `r.circuitId = c.circuitId`. Do filter on `T1.name = 'Silverstone Circuit'` instead of `c.name = 'Silverstone Circuit'`. Do remove the table aliases `r` and `c` instead of keeping them. The amended query now correctly returns distinct URLs for the Silverstone Circuit instead of race details."
        ],
        "rules": [
            "1) When the question asks for information about Formula_1 races at a specific circuit: filter rows where T1.name equals exactly 'Silverstone Circuit'.\n2) When combining circuit and race information: link rows where T2.circuitID equals T1.circuitId and keep only matching pairs (inner match).\n3) When the question asks for distinct URLs: return only unique values of T1.url.\n4) Output columns (ordered): T1.url"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.raceId, r.year, r.round, r.name AS race_name, r.date, r.time, c.name AS circuit_name, c.location, c.country\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit';",
            "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Silverstone Circuit'"
        ],
        "rule_sql": [
            "SELECT DISTINCT circuits.url\nFROM circuits\nINNER JOIN races ON circuits.circuitId = races.circuitId\nWHERE circuits.name = 'Silverstone Circuit';"
        ]
    },
    "917": {
        "question": "Which website should I go to if I want to know more about Anthony Davidson?",
        "db_id": "formula_1",
        "ground_truth": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
        "amends": [],
        "rules": [
            "website refers to url"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';"
        ],
        "rule_sql": []
    },
    "1412": {
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "amends": [],
        "rules": [
            "kind of expenses refers to expense_description; t_shirt_size = 'X-Large'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT e.expense_description\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE m.t_shirt_size = 'X-Large';"
        ],
        "rule_sql": []
    },
    "926": {
        "question": "What's the fastest lap time ever in a race for Lewis Hamilton?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.fastestLapTime FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "amends": [],
        "rules": [
            "fastest lap time ever refers to min(fastestLapTime)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(r.fastestLapTime) AS fastest_lap_time\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';"
        ],
        "rule_sql": []
    },
    "282": {
        "question": "What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.",
        "db_id": "toxicology",
        "ground_truth": "WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label",
        "amends": [],
        "rules": [
            "hydrogen refers to element = 'h'; ratio = DIVIDE(SUM(element = 'h'), count(element)) where molecule_id = 'TR006' ; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN a.element = 'h' THEN 1 ELSE 0 END) * 1.0 / COUNT(a.element)) AS ratio,\n    m.label\nFROM \n    atom a\nJOIN \n    molecule m ON a.molecule_id = m.molecule_id\nWHERE \n    a.molecule_id = 'TR006'\nGROUP BY \n    m.label;"
        ],
        "rule_sql": []
    },
    "1121": {
        "question": "Calculate the total home team goal scored by players whose age are 30 years old and below.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_1 WHERE datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31",
        "amends": [
            "Do use `INNER JOIN` on `t1.player_api_id = t2.away_player_1` instead of `JOIN` with multiple `OR` conditions on home players. Do filter with `datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31` instead of `(julianday('now') - julianday(p.birthday)) / 365.25 <= 30`. Do reference `t2.home_team_goal` instead of `m.home_team_goal` and use table aliases `t1` and `t2` instead of `p` and `m`. The amended query now correctly calculates age using datetime functions and joins on away players instead of home players, matching the intended behavior."
        ],
        "rules": [
            "1) When joining Player (T1) and Match (T2) tables: link rows where T1.player_api_id equals T2.away_player_1 exactly (T1.player_api_id = T2.away_player_1) and keep only matching pairs (inner match).\n2) When filtering players by age 30 years old and below: use datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31 to calculate age.\n3) When calculating total home team goals: sum the values from T2.home_team_goal column.\n4) When the question asks for home team goals scored by players: ensure the join connects players to matches through the away_player_1 position rather than home player positions.\n5) Output columns (ordered): total_home_goals"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(m.home_team_goal) AS total_home_goals\nFROM Match m\nJOIN Player p ON m.home_player_1 = p.player_api_id OR m.home_player_2 = p.player_api_id OR m.home_player_3 = p.player_api_id OR m.home_player_4 = p.player_api_id OR m.home_player_5 = p.player_api_id OR m.home_player_6 = p.player_api_id OR m.home_player_7 = p.player_api_id OR m.home_player_8 = p.player_api_id OR m.home_player_9 = p.player_api_id OR m.home_player_10 = p.player_api_id OR m.home_player_11 = p.player_api_id\nWHERE (julianday('now') - julianday(p.birthday)) / 365.25 <= 30;",
            "SELECT SUM(t2.home_team_goal) AS total_home_goals\nFROM Player t1\nINNER JOIN Match t2 ON t1.player_api_id = t2.away_player_1\nWHERE (datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(t1.birthday)) < 31"
        ],
        "rule_sql": [
            "SELECT SUM(T2.home_team_goal) AS total_home_goals\nFROM Player T1\nINNER JOIN Match T2 ON T1.player_api_id = T2.away_player_1\nWHERE (julianday('now') - julianday(T1.birthday)) / 365.25 < 31"
        ]
    },
    "1427": {
        "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do include `T1.type` in the SELECT list instead of only selecting `b.category`. Do use table aliases `T1` and `T2` instead of `e` and `b`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do move the `T1.type = 'Guest Speaker'` filter to the WHERE clause instead of keeping it separate. Do ensure all column references use the correct table aliases throughout the query. The amended query now correctly returns distinct category and type combinations for events meeting all specified criteria."
        ],
        "rules": [
            "1) When the question asks for budget category and guest speaker type: include both T2.category and T1.type in the output columns. 2) When filtering for events at location 'MU 215': include only rows where T1.location equals 'MU 215' exactly. 3) When filtering for guest speaker type: include only rows where T1.type equals 'Guest Speaker' exactly. 4) When filtering for zero budget spent: include only rows where T2.spent equals 0. 5) When combining event and budget tables: link rows where T1.event_id equals T2.link_to_event using an inner match. 6) When the question implies distinct combinations: return only unique combinations of the selected columns. Output columns (ordered): T2.category, T1.type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.category\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.location = 'MU 215'\n  AND e.type = 'Guest Speaker'\n  AND b.spent = 0;",
            "SELECT DISTINCT T2.category, T1.type\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nWHERE T1.location = 'MU 215' \nAND T1.type = 'Guest Speaker' \nAND T2.spent = 0"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.category, T1.type\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nWHERE T1.location = 'MU 215'\nAND T1.type = 'Guest Speaker'\nAND T2.spent = 0"
        ]
    },
    "660": {
        "question": "What is the owner user id of the most valuable post?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT OwnerUserId FROM posts WHERE FavoriteCount = ( SELECT MAX(FavoriteCount) FROM posts )",
        "amends": [],
        "rules": [
            "the most valuable post refers to MAX(FavoriteCount);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT OwnerUserId FROM posts WHERE Score = (SELECT MAX(Score) FROM posts);"
        ],
        "rule_sql": []
    },
    "1033": {
        "question": "What is the average height of players born between 1990 and 1995?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT SUM(height) / COUNT(id) FROM Player WHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'",
        "amends": [],
        "rules": [
            "average height = DIVIDE(SUM(height), COUNT(id)); players born between 1990 and 1995 refers to birthday > = '1990-01-01 00:00:00' AND birthday < '1996-01-01 00:00:00';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) AS average_height\nFROM Player\nWHERE strftime('%Y', birthday) BETWEEN '1990' AND '1995';"
        ],
        "rule_sql": []
    },
    "742": {
        "question": "How many vampire superheroes are there?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.superhero_name) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
        "amends": [],
        "rules": [
            "vampire superheroes refers to race = 'Vampire'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE race_id = (SELECT id FROM race WHERE race = 'Vampire');"
        ],
        "rule_sql": []
    },
    "1416": {
        "question": "How many members of Business have the Medium size of tee shirt?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business' AND T2.t_shirt_size = 'Medium'",
        "amends": [],
        "rules": [
            "members of Economics refers to major_name = 'Business'; t_shirt_size = 'Medium'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Business' AND member.t_shirt_size = 'Medium';"
        ],
        "rule_sql": []
    },
    "857": {
        "question": "Give the coordinate position for Abu Dhabi Grand Prix.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Abu Dhabi Grand Prix'",
        "amends": [],
        "rules": [
            "coordinate position/location refers to lat, lng; Abu Dhabi Grand Prix refers to races.name = 'Abu Dhabi Grand Prix'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.lat, c.lng \nFROM circuits c \nJOIN races r ON c.circuitId = r.circuitId \nWHERE r.name = 'Abu Dhabi Grand Prix';"
        ],
        "rule_sql": []
    },
    "884": {
        "question": "List the names of all races that occurred in the earliest recorded year and month.",
        "db_id": "formula_1",
        "ground_truth": "SELECT name FROM races WHERE STRFTIME('%Y', date) = ( SELECT STRFTIME('%Y', date) FROM races ORDER BY date ASC LIMIT 1 ) AND STRFTIME('%m', date) = ( SELECT STRFTIME('%m', date) FROM races ORDER BY date ASC LIMIT 1 )",
        "amends": [],
        "rules": [
            "earliest recorded year and month refers to year = year(min(date)) and month = month(min(date));"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM races\nWHERE year = (SELECT MIN(year) FROM races)\nAND strftime('%m', date) = (SELECT strftime('%m', date) FROM races WHERE year = (SELECT MIN(year) FROM races) ORDER BY date LIMIT 1);"
        ],
        "rule_sql": []
    },
    "217": {
        "question": "Identify all the atoms that are connected to the atoms of the TR181 molecule.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T1.molecule_id = 'TR181'",
        "amends": [
            "Do select specific columns `T2.atom_id` and `T2.atom_id2` instead of selecting all columns with `a2.*`. Do use `INNER JOIN` on `T2.atom_id = T1.atom_id` instead of complex `JOIN` conditions with `OR` clauses and self-join logic. Do remove the `DISTINCT` modifier instead of keeping it. Do simplify the join structure by removing the second `atom` table join and instead directly query from the `connected` table. Do remove the additional filter condition `a2.atom_id != a1.atom_id` instead of including it. Do use table aliases `T1` and `T2` instead of `a1`, `c`, and `a2`. The amended query now correctly retrieves connected atom pairs from the specified molecule without unnecessary complexity and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for atoms connected to a specific molecule: filter the connected table using the exact molecule identifier 'TR181' from the question. 2) When retrieving connected atom pairs: select both atom_id and atom_id2 columns from the connected table to capture all connections. 3) When using table aliases: use T1 for the base table and T2 for the connected table as specified in the amends. 4) When joining tables for connection relationships: use inner joins on exact key equality T2.atom_id = T1.atom_id as shown in the amends. 5) When handling duplicate results: do not apply DISTINCT modifiers unless explicitly required. 6) When filtering connected atoms: do not add additional exclusion conditions like atom_id != atom_id2 unless specified. Output columns (ordered): T2.atom_id, T2.atom_id2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a2.*\nFROM atom a1\nJOIN connected c ON a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2\nJOIN atom a2 ON (a2.atom_id = c.atom_id OR a2.atom_id = c.atom_id2) AND a2.atom_id != a1.atom_id\nWHERE a1.molecule_id = 'TR181';",
            "SELECT T2.atom_id, T2.atom_id2\nFROM connected T2\nINNER JOIN atom T1 ON T2.atom_id = T1.atom_id\nWHERE T1.molecule_id = 'TR181'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2\nFROM connected T2\nINNER JOIN atom T1 ON T2.atom_id = T1.atom_id\nWHERE T1.molecule_id = 'TR181'"
        ]
    },
    "1042": {
        "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0",
        "amends": [],
        "rules": [
            "name of league refers to League.name; average goals by the home team is higher than the away team = AVG(home_team_goal) > AVG(away_team_goal); AVG(xx_goal) = SUM(xx_goal) / COUNT(DISTINCT Match.id); 2009/2010 season refers to season = '2009/2010'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2009/2010'\nGROUP BY l.name\nHAVING AVG(m.home_team_goal) > AVG(m.away_team_goal);"
        ],
        "rule_sql": []
    },
    "744": {
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "db_id": "superhero",
        "ground_truth": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "amends": [],
        "rules": [
            "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = SUBTRACT(SUM(publisher_name = 'Marvel Comics'), SUM(publisher_name = 'DC Comics'))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics') - \n    (SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'DC Comics') AS difference;"
        ],
        "rule_sql": []
    },
    "22": {
        "question": "Which school in Contra Costa has the highest number of test takers?",
        "db_id": "california_schools",
        "ground_truth": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1",
        "amends": [
            "Do select only `sname` instead of multiple columns `s.School, s.County, sc.NumTstTakr`. Do query from `satscores` table only instead of joining `schools` and `satscores` tables. Do filter with `cname = 'Contra Costa'` instead of `s.County = 'Contra Costa'`. Do add `sname IS NOT NULL` filter instead of omitting it. Do remove the explicit join condition `s.CDSCode = sc.cds` instead of keeping it. The amended query now correctly retrieves the school name with the highest number of test takers in Contra Costa county directly from the satscores table without unnecessary joins."
        ],
        "rules": [
            "1) When the question asks for a school name: select only the exact column token \"sname\" instead of multiple columns. 2) When the question specifies a county filter \"Contra Costa\": use the exact literal 'Contra Costa' with the exact column token \"cname\" for filtering. 3) When querying from a single table that contains all needed information: query from the \"satscores\" table only instead of performing unnecessary joins. 4) When handling potentially null school names: add a filter \"sname IS NOT NULL\" to exclude records with missing school names. 5) When the question asks for the highest number of test takers: order by the test taker count column in descending direction and keep only the top result. Output columns (ordered): sname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.School, s.County, sc.NumTstTakr\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.County = 'Contra Costa'\nORDER BY sc.NumTstTakr DESC\nLIMIT 1;",
            "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1"
        ]
    },
    "1177": {
        "question": "Was the total cholesterol status for the patient id 2927464 on 1995-9-4 at the normal level?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CASE WHEN `T-CHO` < 250 THEN 'Normal' ELSE 'Abnormal' END FROM Laboratory WHERE ID = 2927464 AND Date = '1995-09-04'",
        "amends": [],
        "rules": [
            "total cholesterol normal level refers to N < 250"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN `T-CHO` BETWEEN 125 AND 200 THEN 'Normal'\n        ELSE 'Abnormal'\n    END AS Cholesterol_Status\nFROM Laboratory\nWHERE ID = 2927464 AND Date = '1995-09-04';"
        ],
        "rule_sql": []
    },
    "570": {
        "question": "For the user whose display name is \"DatEpicCoderGuyWhoPrograms\", what is his/her badge's name?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'DatEpicCoderGuyWhoPrograms'",
        "amends": [],
        "rules": [
            "\"DatEpicCoderGuyWhoPrograms\" is the DisplayName;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'DatEpicCoderGuyWhoPrograms';"
        ],
        "rule_sql": []
    },
    "108": {
        "question": "For the client who applied the biggest loan, what was his/her first amount of transaction after opened the account?",
        "db_id": "financial",
        "ground_truth": "SELECT T3.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY T1.amount DESC, T3.date ASC LIMIT 1",
        "amends": [
            "Do use a simple `SELECT` with joins instead of a complex CTE structure. Do join `loan`, `account`, and `trans` tables directly instead of creating multiple CTEs for biggest loan, client info, account dates, and first transactions. Do select only `T3.amount` instead of multiple client attributes like `client_id`, `gender`, and `birth_date`. Do use `INNER JOIN` between `loan` and `account` on `T1.account_id = T2.account_id` instead of the CTE-based approach. Do add a second `INNER JOIN` to `trans` on `T2.account_id = T3.account_id` instead of the separate first_transaction CTE. Do remove all WHERE conditions including the `d.type = 'OWNER'` filter and date comparisons. Do change the ordering to `ORDER BY T1.amount DESC, T3.date ASC` instead of separate ordering in CTEs. Do keep the `LIMIT 1` but apply it to the final result instead of intermediate CTEs. The amended query now correctly returns the transaction amount from the account with the largest loan, ordered by transaction date."
        ],
        "rules": [
            "1) When the question asks for the biggest loan: find the row with the highest T1.amount value. 2) When combining loan and account tables: link rows where T1.account_id equals T2.account_id using an inner match. 3) When combining account and trans tables: link rows where T2.account_id equals T3.account_id using an inner match. 4) When ordering results for the first transaction: sort by T3.date in ascending order. 5) When limiting to a single result: keep only the first row after ordering. 6) When selecting output: include only T3.amount from the transaction table. 7) Output columns (ordered): T3.amount"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH biggest_loan AS (\n    SELECT account_id, amount\n    FROM loan\n    ORDER BY amount DESC\n    LIMIT 1\n),\nclient_info AS (\n    SELECT c.client_id, c.gender, c.birth_date, d.account_id\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN biggest_loan bl ON d.account_id = bl.account_id\n    WHERE d.type = 'OWNER'\n),\naccount_opening_date AS (\n    SELECT a.account_id, a.date AS account_date\n    FROM account a\n    JOIN biggest_loan bl ON a.account_id = bl.account_id\n),\nfirst_transaction AS (\n    SELECT t.account_id, t.amount, t.date\n    FROM trans t\n    JOIN account_opening_date aod ON t.account_id = aod.account_id\n    WHERE t.date > aod.account_date\n    ORDER BY t.date ASC\n    LIMIT 1\n)\nSELECT ci.client_id, ci.gender, ci.birth_date, ft.amount AS first_transaction_amount\nFROM client_info ci\nJOIN first_transaction ft ON ci.account_id = ft.account_id;",
            "SELECT T3.amount\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN trans T3 ON T2.account_id = T3.account_id\nORDER BY T1.amount DESC, T3.date ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T3.amount\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T1.amount = (SELECT MAX(amount) FROM loan)\nORDER BY T3.date ASC\nLIMIT 1;"
        ]
    },
    "1365": {
        "question": "What are the expenses of the budget with the lowest remaining?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.expense_description FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget ORDER BY T1.remaining LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` instead of `JOIN` and specify the join condition as `T1.budget_id = T2.link_to_budget` instead of `e.link_to_budget = b.budget_id`. Do add `ORDER BY T1.remaining LIMIT 1` instead of using a subquery with `WHERE b.remaining = (SELECT MIN(remaining) FROM budget)`. Do remove the subquery entirely instead of keeping it. Do change the table aliases to `T1` and `T2` instead of `b` and `e`. The amended query now correctly finds the single expense with the smallest remaining budget amount using ordering and limiting instead of potentially returning multiple matches from the subquery approach.",
            "Do select only `T2.expense_description` instead of including multiple columns like `T2.expense_id`, `T2.expense_date`, `T2.cost`, `T2.approved`, `T2.link_to_member`, and `T2.link_to_budget`. Do maintain the `INNER JOIN` on `T1.budget_id = T2.link_to_budget` between `budget` and `expense` tables. Do preserve the `ORDER BY T1.remaining` and `LIMIT 1` clauses to return the single expense description from the budget with the smallest remaining amount. The amended query now correctly returns only the expense description instead of unnecessary expense details, matching the intended focused result set."
        ],
        "rules": [
            "1) When combining budget and expense tables: link rows where T1.budget_id equals T2.link_to_budget exactly and keep only matching pairs (inner match).\n2) When finding the budget with the lowest remaining amount: order rows by T1.remaining in ascending direction and keep only the first 1 row.\n3) When the question asks for expenses of a specific budget: return the expense_description from T2 for the matching budget row.\n4) Output columns (ordered): T2.expense_description",
            "1) When the question asks for \"expenses\" of a budget: select only the expense description column (T2.expense_description) instead of multiple expense details. 2) When combining budget and expense tables: link rows where T1.budget_id equals T2.link_to_budget and keep only matching pairs (inner match). 3) When finding the budget with the \"lowest remaining\": order rows by T1.remaining in ascending order and keep only the first row. 4) Output columns (ordered): T2.expense_description"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.expense_description\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nWHERE b.remaining = (SELECT MIN(remaining) FROM budget);",
            "SELECT T2.expense_id, T2.expense_description, T2.expense_date, T2.cost, T2.approved, T2.link_to_member, T2.link_to_budget FROM budget T1 INNER JOIN expense T2 ON T1.budget_id = T2.link_to_budget ORDER BY T1.remaining LIMIT 1",
            "SELECT T2.expense_description \nFROM budget T1 \nINNER JOIN expense T2 ON T1.budget_id = T2.link_to_budget \nORDER BY T1.remaining \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT e.expense_description \nFROM budget b\nINNER JOIN expense e ON b.budget_id = e.link_to_budget\nORDER BY b.remaining ASC\nLIMIT 1"
        ]
    },
    "55": {
        "question": "Of the schools with a mailing state address in California, what is the ratio of the schools located in the county of Colusa against the school located in the county of Humboldt?",
        "db_id": "california_schools",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END) FROM schools WHERE MailState = 'CA'",
        "amends": [],
        "rules": [
            "Ratio = count(schools in Colusa) / count(schools in Humboldt)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND County = 'Colusa') * 1.0 /\n    (SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND County = 'Humboldt') AS ratio_colusa_to_humboldt;"
        ],
        "rule_sql": []
    },
    "673": {
        "question": "What is the average number of posts voted by the oldest users?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT AVG(PostId) FROM votes WHERE UserId IN ( SELECT Id FROM users WHERE Age = ( SELECT MAX(Age) FROM users ) )",
        "amends": [
            "Do use `AVG(PostId)` instead of `AVG(PostCount)` to calculate the average directly from vote records rather than from a grouped count. Do move the user filtering logic to a `WHERE UserId IN` subquery instead of using a CTE with joins. Do remove the `LEFT JOIN` and grouping operation entirely instead of maintaining the complex join structure. Do eliminate the intermediate `PostCount` calculation and nested subquery structure instead of preserving the multi-layered aggregation. Do reference `PostId` directly in the aggregate function instead of counting post IDs through a separate aggregation. The amended query now correctly calculates the average post ID for votes from the oldest users, matching the RIGHT_SQL's behavior.",
            "Do use a subquery that filters users by `Age = (SELECT MAX(Age) FROM users)` instead of ordering by `CreationDate ASC` with `LIMIT 10`. Do remove the unnecessary `ORDER BY` and `LIMIT` clauses from the subquery instead of keeping them. Do add a WHERE condition to select users with maximum age instead of selecting the first 10 users by creation date. The amended query now correctly calculates the average PostId for votes from users who have the maximum age, rather than from an arbitrary set of the 10 earliest created users."
        ],
        "rules": [
            "1) When the question asks for the average number of posts voted by the oldest users: calculate the average directly from vote records using AVG(PostId) instead of counting post IDs through separate aggregation. 2) When filtering for the oldest users: use a WHERE UserId IN subquery with the maximum age condition instead of using CTE with joins. 3) When combining user and vote data: eliminate LEFT JOIN and grouping operations entirely instead of maintaining complex join structures. 4) When calculating aggregates: reference PostId directly in the aggregate function instead of creating intermediate PostCount calculations and nested subqueries. 5) Output columns (ordered): AveragePostsVoted",
            "1) When the question asks for average number of posts voted by users with maximum age: compute the average of PostId values from votes where UserId matches users with Age equal to the maximum Age value from all users.\n2) When filtering users by maximum age: use the condition Age = (SELECT MAX(Age) FROM users) instead of ordering by CreationDate with LIMIT.\n3) When calculating average for a specific user group: ensure the subquery selects users based on the exact maximum age condition rather than arbitrary ordering and limiting.\n4) Output columns (ordered): AVG(PostId)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH OldestUsers AS (\n    SELECT Id\n    FROM users\n    WHERE Age = (SELECT MAX(Age) FROM users)\n)\nSELECT AVG(PostCount) AS AveragePostsVoted\nFROM (\n    SELECT COUNT(v.PostId) AS PostCount\n    FROM OldestUsers ou\n    LEFT JOIN votes v ON ou.Id = v.UserId\n    GROUP BY ou.Id\n);",
            "SELECT AVG(PostId) \nFROM votes \nWHERE UserId IN (\n    SELECT Id \n    FROM users \n    ORDER BY CreationDate ASC \n    LIMIT 10\n)",
            "SELECT AVG(PostId) \nFROM votes \nWHERE UserId IN (\n    SELECT Id \n    FROM users \n    WHERE Age = (SELECT MAX(Age) FROM users)\n)"
        ],
        "rule_sql": [
            "SELECT AVG(PostId) AS AveragePostsVoted\nFROM votes\nWHERE UserId IN (\n    SELECT Id\n    FROM users\n    WHERE Age = (SELECT MAX(Age) FROM users)\n);"
        ]
    },
    "1186": {
        "question": "Lists all patients by ID who were diagnosed with Behcet's and had their exams between 01/01/197 and 12/31/1997.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT ID FROM Examination WHERE `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31' AND Diagnosis = 'Behcet'",
        "amends": [
            "Do remove the `Patient` table and join condition `p.ID = e.ID` instead of including an unnecessary join. Do change the WHERE filter to use `Diagnosis = 'Behcet'` instead of `LIKE '%Behcet%'` for exact matching. Do remove the DISTINCT modifier instead of keeping it since duplicates are handled by the examination-focused logic. Do change the date filter to use `BETWEEN` instead of separate `>=` and `<=` conditions. The amended query now correctly focuses solely on the Examination table with precise filtering, matching the RIGHT_SQL's behavior.",
            "Do use backticks for `Examination Date` column name instead of double quotes to ensure proper identifier quoting. Do change the date range filter to `BETWEEN '1997-01-01' AND '1997-12-31'` instead of the incorrect `BETWEEN '1970-01-01' AND '1997-12-31'` to properly constrain the examination period to only 1997. Do maintain the same logical order of conditions but ensure the date filter covers the correct year range. The amended query now correctly identifies examinations from 1997 with Behcet diagnosis instead of potentially including examinations from a much broader 27-year period."
        ],
        "rules": [
            "1) When the question asks for patients diagnosed with Behcet's: filter rows where Diagnosis equals exactly 'Behcet' (case-sensitive exact match).\n2) When the question specifies exams between 01/01/197 and 12/31/1997: filter rows where Examination Date falls within the inclusive range from '1970-01-01' to '1997-12-31'.\n3) When the question asks for patient IDs: output only the ID column values.\n4) When working with the Examination table: use the table directly without unnecessary joins to other tables.\n5) When selecting patient IDs: do not apply DISTINCT modifier as duplicates are handled by the examination-focused logic.\nOutput columns (ordered): ID",
            "1) When the question mentions \"diagnosed with Behcet's\": filter rows where Diagnosis equals exactly 'Behcet' (case-sensitive). 2) When the question specifies exams between 01/01/197 and 12/31/1997: filter rows where `Examination Date` is between '1997-01-01' and '1997-12-31' inclusive. 3) When the question asks for patients by ID: output the ID column from the Examination table. 4) When handling date ranges: use the exact date format 'YYYY-MM-DD' as shown in the schema sample values. 5) When choosing identifier delimiters: use backticks for `Examination Date` column name instead of double quotes. Output columns (ordered): ID"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Diagnosis LIKE '%Behcet%'\nAND e.`Examination Date` >= '1997-01-01'\nAND e.`Examination Date` <= '1997-12-31';",
            "SELECT ID FROM Examination WHERE Diagnosis = 'Behcet' AND \"Examination Date\" BETWEEN '1970-01-01' AND '1997-12-31'",
            "SELECT ID FROM Examination WHERE Diagnosis = 'Behcet' AND `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31'"
        ],
        "rule_sql": [
            "SELECT ID FROM Examination WHERE Diagnosis = 'Behcet' AND `Examination Date` BETWEEN '1970-01-01' AND '1997-12-31'"
        ]
    },
    "981": {
        "question": "On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.year, T3.name, T3.date, T3.time FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T1.driverId = ( SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1 ) ORDER BY T3.date ASC LIMIT 1",
        "amends": [
            "Do use a simple subquery to find the youngest driver's ID instead of a CTE with unnecessary columns. Do join `qualifying` directly with `drivers` and `races` instead of creating complex CTEs with incorrect joins. Do remove the `JOIN youngest_driver yd ON 1=1` cross join that incorrectly duplicates results. Do filter for the specific youngest driver with `WHERE T1.driverId = (subquery)` instead of trying to match race dates. Do add `ORDER BY T3.date ASC LIMIT 1` to get the earliest race instead of relying on incorrect date matching logic. Do remove the unnecessary `forename` and `surname` columns from the final SELECT since they're not needed in the output. The amended query now correctly finds the first qualifying race for the youngest driver by directly filtering for that driver and ordering races chronologically."
        ],
        "rules": [
            "1) When finding the youngest driver: use the driver's date of birth (T1.dob) in descending order and take only the first row to identify the youngest driver's ID.\n2) When joining tables for qualifying races: combine T1 (drivers), T2 (qualifying), and T3 (races) using the exact key relationships T1.driverId = T2.driverId and T2.raceId = T3.raceId.\n3) When filtering for a specific driver: use a direct equality condition T1.driverId = (subquery) to target only the youngest driver instead of complex date matching.\n4) When finding the first qualifying race: order races by T3.date in ascending order and take only the first row to get the earliest race.\n5) When selecting output columns: include only T3.year, T3.name, T3.date, and T3.time as specified in the question, removing unnecessary driver name columns.\n6) When combining tables: perform inner matches using the exact key equalities shown in the schema relationships, avoiding cross joins or outer matches.\nOutput columns (ordered): T3.year, T3.name, T3.date, T3.time"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH youngest_driver AS (\n    SELECT driverId, forename, surname, dob\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 1\n),\nfirst_qualifying_race AS (\n    SELECT q.raceId, MIN(r.date) AS first_race_date\n    FROM qualifying q\n    JOIN races r ON q.raceId = r.raceId\n    JOIN youngest_driver yd ON q.driverId = yd.driverId\n    GROUP BY q.driverId\n)\nSELECT r.year, r.name, r.date, r.time, yd.forename, yd.surname\nFROM races r\nJOIN first_qualifying_race fqr ON r.raceId = fqr.raceId\nJOIN youngest_driver yd ON 1=1\nWHERE r.date = fqr.first_race_date;",
            "SELECT \n    r.year,\n    r.name,\n    r.date,\n    r.time\nFROM \n    qualifying q\nJOIN \n    races r ON q.raceId = r.raceId\nWHERE \n    q.driverId = (\n        SELECT driverId \n        FROM drivers \n        ORDER BY dob DESC \n        LIMIT 1\n    )\nORDER BY \n    r.date ASC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.year, T3.name, T3.date, T3.time\nFROM races T3\nJOIN qualifying T2 ON T3.raceId = T2.raceId\nJOIN drivers T1 ON T2.driverId = T1.driverId\nWHERE T1.driverId = (\n    SELECT driverId \n    FROM drivers \n    ORDER BY dob DESC \n    LIMIT 1\n)\nORDER BY T3.date ASC\nLIMIT 1;"
        ]
    },
    "76": {
        "question": "What is the city location of the high school level school with Lunch Provision 2 whose lowest grade is 9 and the highest grade is 12 in the county of Merced?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Lunch Provision 2' AND T2.County = 'Merced' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12 AND T2.EILCode = 'HS'",
        "amends": [
            "Do reference `T2.City` instead of `s.City` and use table alias `T2` for schools instead of `s`. Do use `INNER JOIN` with `frpm AS T1` and `schools AS T2` instead of `JOIN` with `schools s` and `frpm f`. Do filter on `T1.`NSLP Provision Status` = 'Lunch Provision 2'` instead of `'2'` to match the correct value format. Do filter on `T2.County = 'Merced'` instead of `f.`County Name` = 'Merced'` to use the correct table and column for county filtering. Do use numeric values `9` and `12` for grade filters instead of string values `'9'` and `'12'` to match the correct data type. The amended query now correctly joins the tables with proper aliases, uses accurate filter values and data types, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for city location: output T2.City as the result column.\n2) When joining frpm and schools tables: use inner join where T1.CDSCode = T2.CDSCode to match related records.\n3) When filtering for high school level: use T2.EILCode = 'HS' to identify high schools.\n4) When filtering for Lunch Provision 2: use T1.\"NSLP Provision Status\" = 'Lunch Provision 2' with exact literal value.\n5) When filtering for lowest grade 9: use T1.\"Low Grade\" = 9 with numeric value.\n6) When filtering for highest grade 12: use T1.\"High Grade\" = 12 with numeric value.\n7) When filtering for county Merced: use T2.County = 'Merced' with exact literal value.\nOutput columns (ordered): T2.City"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.City\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.EILCode = 'HS'\nAND f.`NSLP Provision Status` = '2'\nAND f.`Low Grade` = '9'\nAND f.`High Grade` = '12'\nAND f.`County Name` = 'Merced';",
            "SELECT T2.City\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"NSLP Provision Status\" = 'Lunch Provision 2'\nAND T1.\"Low Grade\" = 9\nAND T1.\"High Grade\" = 12\nAND T2.County = 'Merced';"
        ],
        "rule_sql": [
            "SELECT T2.City\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.EILCode = 'HS'\nAND T1.\"NSLP Provision Status\" = 'Lunch Provision 2'\nAND T1.\"Low Grade\" = 9\nAND T1.\"High Grade\" = 12\nAND T2.County = 'Merced'"
        ]
    },
    "533": {
        "question": "How many users last accessed the website after 2014/9/1?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
        "amends": [
            "Do use `COUNT(Id)` instead of `COUNT(*)` to count only non-null user IDs. Do apply `date()` function to `LastAccessDate` instead of comparing the raw datetime value directly, ensuring proper date comparison semantics. Do remove the `AS user_count` alias instead of keeping it, as the right query does not include an alias. End with confirmation that the amended query now correctly counts users with LastAccessDate after September 1, 2014, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When counting users: use COUNT(Id) instead of COUNT(*) to count only non-null user IDs.\n2) When comparing date values against a specific date like '2014-09-01': apply the date() function to datetime columns like LastAccessDate to ensure proper date comparison semantics.\n3) When the question does not specify an output column alias: do not include AS aliases in the output.\n4) When filtering for dates after a specific date: use the exact literal '2014-09-01' with proper date formatting.\nOutput columns (ordered): COUNT(Id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS user_count FROM users WHERE LastAccessDate > '2014-09-01';",
            "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'"
        ]
    },
    "1393": {
        "question": "Provide the full name and email address of the Student_Club's Secretary.",
        "db_id": "student_club",
        "ground_truth": "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'",
        "amends": [
            "Do select individual columns `first_name` and `last_name` instead of concatenating them with `|| ' ' ||` into a single `full_name` alias. Do remove the concatenation expression and alias while keeping the same `email` column and `WHERE position = 'Secretary'` filter unchanged. The amended query now matches RIGHT_SQL's behavior by returning separate first and last name columns rather than a combined full name string."
        ],
        "rules": [
            "1) When the question asks for a person's full name: return first_name and last_name as separate columns instead of concatenating them into a single full_name string. 2) When filtering for a specific position like \"Secretary\": use the exact literal 'Secretary' with the position column to identify matching rows. 3) When selecting email addresses: include the email column along with name information. 4) Output columns (ordered): first_name, last_name, email"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name || ' ' || last_name AS full_name, email FROM member WHERE position = 'Secretary';",
            "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'"
        ],
        "rule_sql": [
            "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'"
        ]
    },
    "1449": {
        "question": "What is the name and major of members who had to spend more than a hundred dollars on an expense?",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T1.first_name, T1.last_name, T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE T3.cost > 100",
        "amends": [],
        "rules": [
            "full name refers to first_name, last_name; major of members refers to major_name; spend more than a hundred dollars on an expense refers to cost > 100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name, ma.major_name\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE e.cost > 100;"
        ],
        "rule_sql": []
    },
    "493": {
        "question": "For the set \"Commander 2014 Oversized\" , give its parent code.",
        "db_id": "card_games",
        "ground_truth": "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized'",
        "amends": [],
        "rules": [
            "the set \"Commander 2014 Oversized\" refers to name = 'Commander 2014 Oversized';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized';"
        ],
        "rule_sql": []
    },
    "751": {
        "question": "List down at least five superpowers of male superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
        "amends": [],
        "rules": [
            "male refers to gender = 'Male'; superpowers refers to power_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nJOIN gender g ON sh.gender_id = g.id\nWHERE g.gender = 'Male'\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "121": {
        "question": "List account ID and account opening date for accounts from 'Prachatice'.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id, T1.date FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Prachatice'",
        "amends": [],
        "rules": [
            "A2 refers to the names of districts."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.account_id, a.date\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE d.A2 = 'Prachatice';"
        ],
        "rule_sql": []
    },
    "16": {
        "question": "How many schools in merged Alameda have number of test takers less than 100?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(T1.CDSCode) FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Merged' AND T2.NumTstTakr < 100 AND T1.County = 'Lake'",
        "amends": [
            "Do specify `COUNT(T1.CDSCode)` instead of `COUNT(*)` to count specific non-null values. Do use table aliases `T1` for `schools` and `T2` for `satscores` instead of no aliases. Do change the join to `INNER JOIN` with explicit `ON T1.CDSCode = T2.cds` instead of implicit join syntax. Do add filter `T1.StatusType = 'Merged'` instead of omitting this status condition. Do change the county filter to `T1.County = 'Lake'` instead of `'Alameda'` to target different geographic data. The amended query now correctly filters for merged schools in Lake County with appropriate test taker counts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting schools: use COUNT(T1.CDSCode) instead of COUNT(*) to count specific non-null values. 2) When joining tables: use table aliases T1 for schools and T2 for satscores. 3) When combining schools and satscores: link rows where T1.CDSCode = T2.cds using an inner match. 4) When filtering by school status: include T1.StatusType = 'Merged' to target merged schools. 5) When filtering by county: use T1.County = 'Lake' instead of 'Alameda' to target Lake County data. 6) When filtering by number of test takers: use T2.NumTstTakr < 100 to find schools with fewer than 100 test takers. Output columns (ordered): COUNT(T1.CDSCode)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM satscores \nJOIN schools ON satscores.cds = schools.CDSCode \nWHERE schools.County = 'Alameda' AND satscores.NumTstTakr < 100;",
            "SELECT COUNT(T1.CDSCode) \nFROM schools T1 \nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds \nWHERE T1.StatusType = 'Merged' \nAND T1.County = 'Lake' \nAND T2.NumTstTakr < 100"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.CDSCode) \nFROM schools T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nWHERE T1.StatusType = 'Merged' \nAND T1.County = 'Lake' \nAND T2.NumTstTakr < 100"
        ]
    },
    "107": {
        "question": "What is the gender of the oldest client who opened his/her account in the highest average salary branch?",
        "db_id": "financial",
        "ground_truth": "SELECT T2.gender FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id ORDER BY T1.A11 DESC, T2.birth_date ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Earlier birthdate refers to older age; A11 refers to average salary"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH highest_salary_district AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A11 DESC\n    LIMIT 1\n),\naccounts_in_district AS (\n    SELECT account_id\n    FROM account\n    WHERE district_id = (SELECT district_id FROM highest_salary_district)\n),\nclient_accounts AS (\n    SELECT client_id\n    FROM disp\n    WHERE account_id IN (SELECT account_id FROM accounts_in_district) AND type = 'OWNER'\n),\noldest_client AS (\n    SELECT client_id, gender\n    FROM client\n    WHERE client_id IN (SELECT client_id FROM client_accounts)\n    ORDER BY birth_date ASC\n    LIMIT 1\n)\nSELECT gender\nFROM oldest_client;"
        ],
        "rule_sql": []
    },
    "138": {
        "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
        "amends": [],
        "rules": [
            "Male refers to gender = 'M'; A15 stands for no. of commited crimes 1995"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH SecondHighestCrimeDistrict AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A15 DESC\n    LIMIT 1 OFFSET 1\n)\nSELECT COUNT(*) AS male_clients_count\nFROM client\nWHERE gender = 'M' AND district_id = (SELECT district_id FROM SecondHighestCrimeDistrict);"
        ],
        "rule_sql": []
    },
    "196": {
        "question": "In the non-carcinogenic molecules, how many contain chlorine atoms?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'cl' AND T1.label = '-'",
        "amends": [],
        "rules": [
            "non-carcinogenic molecules refers to label = '-'; chlorine atoms refers to element = 'cl'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '-' AND a.element = 'cl';"
        ],
        "rule_sql": []
    },
    "1142": {
        "question": "In the 2015\u20132016 season, how many games were played in the Italian Serie A league?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Italy Serie A' AND t2.season = '2015/2016'",
        "amends": [],
        "rules": [
            "In the 2015\u20132016 season refers to season = '2015/2016'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS total_games\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Italy Serie A')\nAND season = '2015/2016';"
        ],
        "rule_sql": []
    },
    "74": {
        "question": "What is the lowest grade for the District Special Education Consortia School with National Center for Educational Statistics school district identification number of 0613360?",
        "db_id": "california_schools",
        "ground_truth": "SELECT MIN(T1.`Low Grade`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.NCESDist = '0613360' AND T2.EdOpsCode = 'SPECON'",
        "amends": [],
        "rules": [
            "District Special Education Consortia School refers to EdOpsCode = 'SPECON'."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT frpm.\"Low Grade\"\nFROM schools\nJOIN frpm ON schools.CDSCode = frpm.CDSCode\nWHERE schools.NCESDist = '0613360' AND schools.EdOpsCode = 'SPECON';"
        ],
        "rule_sql": []
    },
    "914": {
        "question": "How many drivers don't have a code?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(driverId) - COUNT(CASE WHEN code IS NOT NULL THEN code END) FROM drivers",
        "amends": [],
        "rules": [
            "don't have a code refers to code is null"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE code IS NULL OR code = '';"
        ],
        "rule_sql": []
    },
    "1450": {
        "question": "In the events with more than forty incomes, list the city and country in which the event is happening.",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T3.city, T3.county FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip WHERE T1.amount > 40",
        "amends": [
            "Do select only `city` and `county` instead of including `event_name` and grouping by `event_id`. Do remove the `event` and `attendance` table joins instead of keeping them. Do add a filter on `amount > 40` instead of counting income records with `HAVING COUNT(i.income_id) > 40`. Do use `INNER JOIN` between `income` and `member` on `link_to_member = member_id` instead of joining through attendance. Do join `zip_code` directly to `member` on `zip_code = zip` instead of the previous join path. Do add `DISTINCT` to eliminate duplicates instead of using GROUP BY. The amended query now correctly filters by income amount rather than counting records and returns the intended zip code locations."
        ],
        "rules": [
            "1) When the question asks for city and country information: output columns \"city\" and \"county\" from the zip_code table.\n2) When filtering for incomes with amount greater than forty: apply condition \"amount > 40\" to the income table.\n3) When joining income and member tables: link rows where income.link_to_member equals member.member_id using inner join.\n4) When joining member and zip_code tables: link rows where member.zip equals zip_code.zip_code using inner join.\n5) When eliminating duplicate results: use DISTINCT on the output columns instead of GROUP BY.\n6) When the question mentions \"events with more than forty incomes\": do not join event or attendance tables, as filtering is done directly on income amounts.\n7) Output columns (ordered): zip_code.city, zip_code.county"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name, z.city, z.county\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nJOIN income i ON m.member_id = i.link_to_member\nJOIN zip_code z ON m.zip = z.zip_code\nGROUP BY e.event_id\nHAVING COUNT(i.income_id) > 40;",
            "SELECT DISTINCT z.city, z.county\nFROM income i\nINNER JOIN member m ON i.link_to_member = m.member_id\nINNER JOIN zip_code z ON m.zip = z.zip_code\nWHERE i.amount > 40"
        ],
        "rule_sql": [
            "SELECT DISTINCT zip_code.city, zip_code.county\nFROM income\nINNER JOIN member ON income.link_to_member = member.member_id\nINNER JOIN zip_code ON member.zip = zip_code.zip_code\nWHERE income.amount > 40"
        ]
    },
    "535": {
        "question": "Among the users who have more than 100 upvotes, how many of them have more then 1 downvotes?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Upvotes > 100 AND Downvotes > 1",
        "amends": [],
        "rules": [
            "more than 100 upvotes refers to Upvotes > 100; more than 1 downvotes refers to Downvotes > 1"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS UserCount\nFROM users\nWHERE UpVotes > 100 AND DownVotes > 1;"
        ],
        "rule_sql": []
    },
    "789": {
        "question": "Find the average weight of the heroes who are aliens.",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "amends": [],
        "rules": [
            "average = AVG(weight_kg); aliens refers to race = 'Alien';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(s.weight_kg) AS average_weight\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Alien';"
        ],
        "rule_sql": []
    },
    "490": {
        "question": "For the set which had 'SS2' as the code, what is its magic card market id?",
        "db_id": "card_games",
        "ground_truth": "SELECT mcmId FROM sets WHERE code = 'SS2'",
        "amends": [],
        "rules": [
            "magic card market id refers to mcmId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT mcmId FROM sets WHERE code = 'SS2';"
        ],
        "rule_sql": []
    },
    "226": {
        "question": "What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.",
        "db_id": "toxicology",
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) FROM bond AS T WHERE T.molecule_id = 'TR008'",
        "amends": [
            "Do use `COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END)` instead of `SUM(CASE WHEN bond_type = '=' THEN 1 ELSE 0 END)` to properly count non-NULL values. Do add table alias `T` to all column references instead of using unqualified column names. Do cast the count to `REAL` instead of using `100.0` to ensure floating-point division. Do remove the column alias `percentage` instead of keeping it. The amended query now correctly calculates the percentage using proper NULL handling and explicit casting for accurate division.",
            "Do remove the `JOIN` with `molecule` table and instead filter directly on `T.molecule_id = 'TR008'` instead of joining on `T.molecule_id = M.molecule_id` and filtering `M.label = 'TR008'`. Do add `ROUND` function with precision `5` instead of omitting rounding. Do cast the count to `REAL` instead of using implicit integer division. Do remove the `ELSE NULL` clause from the `CASE` statement as it's redundant. Do use table alias `AS T` instead of just `T` in the FROM clause. The amended query now correctly calculates the percentage of double bonds for molecule TR008 without unnecessary joins and with proper numeric handling."
        ],
        "rules": [
            "1) When counting double bonds in a molecule: use COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) to properly count non-NULL values for double bonds. 2) When calculating percentages: cast the count to REAL instead of using 100.0 to ensure floating-point division. 3) When filtering for a specific molecule: use T.molecule_id = 'TR008' with exact literal value 'TR008'. 4) When referencing columns: always use table alias T with all column references instead of unqualified column names. 5) When formatting output: do not include column aliases in the final result. 6) Output columns (ordered): the calculated percentage value with five decimal places",
            "1) When the question asks for percentage of double bonds in a specific molecule: filter the bond table directly using the exact molecule identifier token 'TR008' on T.molecule_id instead of joining with molecule table. 2) When calculating percentage with specific decimal precision: round the result to 5 decimal places. 3) When performing division in percentage calculations: ensure numeric division by casting counts to real numbers to avoid integer division. 4) When counting bonds of specific type: count bonds where T.bond_type equals '=' exactly. 5) When using CASE statements for conditional counting: omit redundant ELSE NULL clauses. 6) When referencing tables: use explicit table aliases with AS syntax (e.g., bond AS T). Output columns (ordered): (COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id END) * 100.0 / COUNT(T.bond_id))"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    ROUND((SUM(CASE WHEN bond_type = '=' THEN 1 ELSE 0 END) * 100.0 / COUNT(bond_id), 5) AS percentage\nFROM \n    bond\nWHERE \n    molecule_id = 'TR008';",
            "SELECT \n    (COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) * 100.0 / COUNT(T.bond_id)) \nFROM \n    bond T\nJOIN \n    molecule M ON T.molecule_id = M.molecule_id\nWHERE \n    M.label = 'TR008';",
            "SELECT ROUND(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id END) * 100.0 / COUNT(T.bond_id), 5) FROM bond AS T WHERE T.molecule_id = 'TR008';"
        ],
        "rule_sql": [
            "SELECT ROUND((COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id END) * 100.0 / COUNT(T.bond_id)), 5) FROM bond AS T WHERE T.molecule_id = 'TR008';"
        ]
    },
    "875": {
        "question": "Show me the season page of year when the race No. 901 took place.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "amends": [],
        "rules": [
            "the season page refers to url; race number refers to raceId;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.url\nFROM seasons s\nJOIN races r ON s.year = r.year\nWHERE r.raceId = 901;"
        ],
        "rule_sql": []
    }
}