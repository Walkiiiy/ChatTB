{
    "1458": {
        "question": "Calculate the difference in the percentage of members in New Jersey and Vermont.",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.member_id) AS diff FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip",
        "amends": [],
        "rules": [
            "SUBTRACT( DIVIDE( SUM(state = 'New Jersey'), COUNT(position = 'Member')), DIVIDE( SUM(state = 'Vermont'), COUNT(position = 'Member')) )"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH total_members AS (\n    SELECT COUNT(*) AS total FROM member\n),\nnew_jersey_members AS (\n    SELECT COUNT(*) AS nj_count\n    FROM member\n    JOIN zip_code ON member.zip = zip_code.zip_code\n    WHERE zip_code.short_state = 'NJ'\n),\nvermont_members AS (\n    SELECT COUNT(*) AS vt_count\n    FROM member\n    JOIN zip_code ON member.zip = zip_code.zip_code\n    WHERE zip_code.short_state = 'VT'\n)\nSELECT \n    ((nj_count * 100.0 / total) - (vt_count * 100.0 / total)) AS percentage_difference\nFROM total_members, new_jersey_members, vermont_members;"
        ],
        "rule_sql": []
    },
    "631": {
        "question": "How many posts were created by Daniel Vassallo?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "amends": [
            "Do use `COUNT(T1.Id)` instead of `COUNT(*)` to count specific user-related records. Do join `users AS T1` with `postHistory AS T2` on `T1.Id = T2.UserId` instead of querying the `posts` table with a subquery. Do filter on `T1.DisplayName = 'Daniel Vassallo'` in the WHERE clause instead of using a subquery to find the user ID. Do remove the subquery entirely instead of maintaining the nested SELECT structure. The amended query now correctly counts post history entries for the specified user instead of posts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting posts created by a specific user: count using T1.Id as the counting key instead of counting all columns. 2) When the question mentions a user by name \"Daniel Vassallo\": filter using T1.DisplayName = 'Daniel Vassallo' exactly as specified. 3) When combining user and post history information: link rows where T1.Id = T2.UserId to match user records with their post history entries. 4) When the schema requires joining users and postHistory tables: use users as T1 and postHistory as T2 with an inner match on the user ID relationship. 5) Output columns (ordered): COUNT(T1.Id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NumberOfPosts\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Daniel Vassallo');",
            "SELECT COUNT(T2.Id) \nFROM users AS T1 \nJOIN postHistory AS T2 ON T1.Id = T2.UserId \nWHERE T1.DisplayName = 'Daniel Vassallo'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM users T1 \nINNER JOIN postHistory T2 ON T1.Id = T2.UserId \nWHERE T1.DisplayName = 'Daniel Vassallo'"
        ]
    },
    "818": {
        "question": "Among the bad superheroes, what is the percentage of female superheroes?",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Bad'",
        "amends": [],
        "rules": [
            "bad superheroes refers to alignment.id = 2; percentage = MULTIPLY(DIVIDE(SUM(gender.id = 2 WHERE alignment.id = 2), COUNT(alignment.id = 2)), 100.0); female refers to gender.id = 2;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN s.gender_id = 2 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female_bad_superheroes\nFROM superhero s\nWHERE s.alignment_id = 2;"
        ],
        "rule_sql": []
    },
    "479": {
        "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
        "db_id": "card_games",
        "ground_truth": "SELECT SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
        "amends": [],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; converted mana cost higher than 5 refers to convertedManaCost > 5; unknown power refers to power = '*' or T1.power is null"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nJOIN sets ON cards.setCode = sets.code \nWHERE sets.name = 'Coldsnap' \nAND cards.convertedManaCost > 5 \nAND (cards.power = '*' OR cards.power IS NULL);"
        ],
        "rule_sql": []
    },
    "572": {
        "question": "How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'",
        "amends": [],
        "rules": [
            "\"Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer\" is the Title of post; views refers to ViewCount"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';"
        ],
        "rule_sql": []
    },
    "476": {
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "amends": [
            "Do use a simple `SELECT` with `ORDER BY` and `LIMIT` instead of a complex CTE structure with subqueries. Do join `cards` and `sets` tables directly in the main query instead of creating a separate CTE for filtering. Do add `ORDER BY T1.convertedManaCost DESC` instead of using a subquery to find the maximum value. Do include `LIMIT 1` to get the single highest cost card instead of potentially returning multiple cards with equal maximum costs. Do remove the CTE and subquery structure entirely instead of maintaining the nested approach. The amended query now correctly returns the single card with the highest converted mana cost from the Coldsnap set, matching the RIGHT_SQL's behavior.",
            "Do reference `T1.name` instead of `c.name` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `c` and `s`. Do join on `T2.code = T1.setCode` instead of `c.setCode = s.code`. Do filter on `T2.name = 'Coldsnap'` instead of `s.code = 'Coldsnap'` to match by set name rather than set code. The amended query now correctly retrieves cards from the Coldsnap set by name rather than code, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cards from a specific set \"Coldsnap\": filter rows where T2.name equals 'Coldsnap' exactly. 2) When the question asks for the \"highest\" converted mana cost: rank rows by T1.convertedManaCost in descending order and keep the first 1 row. 3) When combining T1 and T2 for shared entities: link rows where T1.setCode equals T2.code exactly; keep only matching pairs (inner match). 4) Output columns (ordered): T1.name",
            "1) When the question asks for cards from a specific set by name: filter using T2.name = 'Coldsnap' instead of set code. 2) When joining the cards and sets tables: use INNER JOIN with T2.code = T1.setCode as the join condition. 3) When ordering by converted mana cost to find highest values: sort by T1.convertedManaCost in descending order. 4) When retrieving the highest converted mana cost cards: return all cards tied for the maximum value, not just one. 5) When the question mentions \"cards in the set\": ensure the join condition correctly links cards to their parent set. Output columns (ordered): T1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH ColdsnapCards AS (\n    SELECT c.name, c.convertedManaCost\n    FROM cards c\n    JOIN sets s ON c.setCode = s.code\n    WHERE s.name = 'Coldsnap'\n),\nMaxManaCost AS (\n    SELECT MAX(convertedManaCost) AS maxCost\n    FROM ColdsnapCards\n)\nSELECT name\nFROM ColdsnapCards\nWHERE convertedManaCost = (SELECT maxCost FROM MaxManaCost);",
            "SELECT c.name \nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.code = 'Coldsnap'\nORDER BY c.convertedManaCost DESC\nLIMIT 1;",
            "SELECT T1.name \nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Coldsnap'\nORDER BY T1.convertedManaCost DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM cards T1\nINNER JOIN sets T2 ON T1.setCode = T2.code\nWHERE T2.name = 'Coldsnap'\nORDER BY T1.convertedManaCost DESC\nLIMIT 1;"
        ]
    },
    "275": {
        "question": "Give me the molecule ID of the double bond type.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '='",
        "amends": [
            "Do use table alias `T` for the `bond` table instead of omitting it, and do reference `T.molecule_id` instead of just `molecule_id` to make the column reference explicit. Do use `T.bond_type = '='` instead of `bond_type = ' = '` to remove the extra spaces around the equals sign in the string comparison. The amended query now correctly matches RIGHT_SQL's behavior with proper table aliasing and accurate string matching."
        ],
        "rules": [
            "1) When the question asks for molecule ID from the bond table: use table alias T for the bond table and reference T.molecule_id. 2) When filtering for double bond type: use T.bond_type = '=' with exact string literal '=' (no extra spaces). 3) When selecting distinct values: return only unique molecule_id values. 4) Output columns (ordered): T.molecule_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT molecule_id FROM bond WHERE bond_type = ' = ';",
            "SELECT T.molecule_id FROM bond T WHERE T.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.molecule_id FROM bond T WHERE T.bond_type = '='"
        ]
    },
    "937": {
        "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
        "amends": [
            "Do reference the time column as `T1.time` instead of `r.time AS finish_time` and remove the alias. Do use `INNER JOIN` explicitly instead of just `JOIN` while keeping the same join condition `T1.raceId = T2.raceId`. Do filter on `T1.rank = 2` instead of `r.positionOrder = 2` to use the correct column name for the ranking position. Do keep the same filters on `T2.name = 'Chinese Grand Prix'` and `T2.year = 2008` but reference them with the T2 alias instead of rc. The amended query now correctly identifies the second-place finisher using the proper rank column and matches the intended behavior.",
            "Do correct the race name filter to `Chinese Grand Prix` instead of the incorrect `AustChineseralian Grand Prix` in the WHERE clause. The amended query now matches RIGHT_SQL's behavior by properly filtering for the Chinese Grand Prix race in 2008 where drivers finished in second position."
        ],
        "rules": [
            "1) When the question asks for a finish time: output the exact column T1.time without aliasing it as finish_time. 2) When combining T1 (results) and T2 (races): link rows where T1.raceId = T2.raceId using an inner match. 3) When filtering for a specific year: use T2.year = 2008. 4) When filtering for a specific race name: use T2.name = 'Chinese Grand Prix' exactly as specified. 5) When identifying a driver by ranking position: filter on T1.rank = 2 to find the second-place finisher. Output columns (ordered): T1.time",
            "1) When the question asks for a finish time for a driver who ranked second: filter results to only include rows where T1.rank equals 2.\n2) When the question specifies a particular race year and name: filter races to only include rows where T2.year equals 2008 and T2.name equals 'Chinese Grand Prix' exactly.\n3) When combining results and races tables: link rows where T1.raceId equals T2.raceId exactly and keep only matching pairs (inner match).\n4) Output columns (ordered): T1.time"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.time AS finish_time\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 2008 AND rc.name = 'Chinese Grand Prix' AND r.positionOrder = 2;",
            "SELECT T1.time\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T1.rank = 2\nAND T2.name = 'AustChineseralian Grand Prix'\nAND T2.year = 2008",
            "SELECT T1.time\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2008\nAND T2.name = 'Chinese Grand Prix'\nAND T1.rank = 2"
        ],
        "rule_sql": [
            "SELECT T1.time \nFROM results T1 \nINNER JOIN races T2 ON T1.raceId = T2.raceId \nWHERE T2.year = 2008 \nAND T2.name = 'Chinese Grand Prix' \nAND T1.rank = 2"
        ]
    },
    "178": {
        "question": "Which kind of credit card does client number 9 possess?",
        "db_id": "financial",
        "ground_truth": "SELECT T3.type FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.client_id = 9",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.type \nFROM card c \nJOIN disp d ON c.disp_id = d.disp_id \nWHERE d.client_id = 9;"
        ],
        "rule_sql": []
    },
    "851": {
        "question": "Please list the positions of the circuits built by the constructor Renault.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T1.position FROM constructorStandings AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T2.name = 'Renault'",
        "amends": [
            "Do use `SELECT DISTINCT T1.position` instead of `SELECT c.name AS circuit_name, c.lat AS latitude, c.lng AS longitude`. Do change the FROM clause to use `constructorStandings AS T1 INNER JOIN constructors AS T2` instead of `circuits c JOIN races r ON c.circuitId = r.circuitId JOIN results res ON r.raceId = res.raceId JOIN constructors con ON res.constructorId = con.constructorId`. Do modify the join condition to `T2.constructorId = T1.constructorId` instead of the multiple join chain. Do keep the WHERE filter `T2.name = 'Renault'` but apply it to the correct table relationship instead of the original complex join structure. Do remove the GROUP BY clause entirely instead of including `GROUP BY c.circuitId`. The amended query now correctly retrieves distinct constructor positions for Renault from the constructor standings table instead of attempting to aggregate circuit data through an incorrect join path."
        ],
        "rules": [
            "1) When the question asks for positions of circuits built by a specific constructor: select distinct positions from the constructor standings table (T1).\n2) When filtering by constructor name 'Renault': apply the condition T2.name = 'Renault' exactly as written.\n3) When joining constructor standings (T1) with constructors (T2): link rows where T2.constructorId = T1.constructorId.\n4) When the question specifies distinct positions: return only unique position values.\n5) Output columns (ordered): T1.position"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name AS circuit_name, c.lat AS latitude, c.lng AS longitude\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nJOIN results res ON r.raceId = res.raceId\nJOIN constructors con ON res.constructorId = con.constructorId\nWHERE con.name = 'Renault'\nGROUP BY c.circuitId;",
            "SELECT DISTINCT T1.position\nFROM constructorStandings AS T1\nINNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId\nWHERE T2.name = 'Renault'"
        ],
        "rule_sql": [
            "SELECT DISTINCT cs.position \nFROM constructorStandings cs \nJOIN constructors c ON cs.constructorId = c.constructorId \nWHERE c.name = 'Renault' \nORDER BY cs.position"
        ]
    },
    "664": {
        "question": "What is the sum of score of the post on 2010-07-19?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT SUM(Score) FROM posts WHERE LasActivityDate LIKE '2010-07-19%'",
        "amends": [],
        "rules": [
            "on 2010-07-19 refers to LasActivityDate LIKE '2010-07-19%';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(Score) FROM posts WHERE LasActivityDate LIKE '2010-07-19%';"
        ],
        "rule_sql": []
    },
    "1222": {
        "question": "How many male patients are are with creatinine index out of the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching records rather than unique patients. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T2.CRE >= 1.5` condition before `T1.SEX = 'M'` in the WHERE clause instead of the reverse order, though this is functionally equivalent. The amended query now correctly counts all laboratory records meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting laboratory records for male patients with abnormal creatinine: use COUNT(T1.ID) without DISTINCT to count all matching records rather than unique patients. 2) When combining Patient and Laboratory tables: use INNER JOIN with T1 and T2 aliases where T1.ID = T2.ID to keep only matching pairs. 3) When filtering for male patients with creatinine out of normal range: include both conditions T2.CRE >= 1.5 and T1.SEX = 'M' in the WHERE clause. 4) When handling text literals for gender: use exact literal 'M' with case and quotes preserved. 5) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.CRE >= 1.5;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.CRE >= 1.5 AND T1.SEX = 'M'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.CRE >= 1.5"
        ]
    },
    "1474": {
        "question": "Which customers, paying in CZK, consumed the most gas in 2011?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Date BETWEEN 201101 AND 201112 GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do join `yearmonth` table instead of `transactions_1k` table. Do reference `T2.Consumption` column instead of `t.Amount` column in the aggregation. Do use `SUM(T2.Consumption)` in the ORDER BY clause instead of referencing the alias `TotalConsumption`. Do remove the column alias `TotalConsumption` from the SELECT list instead of including it. Do use numeric literals `201101` AND `201112` without quotes instead of string literals for the date range comparison. The amended query now correctly aggregates consumption data from the yearmonth table with proper numeric date handling and ordering."
        ],
        "rules": [
            "1) When the question asks for customers paying in CZK: filter T1.Currency to exactly match 'CZK'.\n2) When the question asks for gas consumption in 2011: filter T2.Date to be between 201101 and 201112 inclusive using numeric comparison.\n3) When combining customer and consumption data: link rows where T1.CustomerID equals T2.CustomerID and keep only matching pairs (inner match).\n4) When calculating total gas consumption: sum T2.Consumption values for each customer group.\n5) When finding customers with the most consumption: rank customers by the sum of T2.Consumption in descending order and keep only the top customer.\n6) When outputting results: include only T1.CustomerID in the output.\nOutput columns (ordered): T1.CustomerID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.CustomerID, SUM(t.Amount) AS TotalConsumption\nFROM customers c\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE c.Currency = 'CZK' AND t.Date BETWEEN '201101' AND '201112'\nGROUP BY c.CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "SELECT c.CustomerID\nFROM customers c\nJOIN yearmonth T2 ON c.CustomerID = T2.CustomerID\nWHERE c.Currency = 'CZK' \nAND T2.Date BETWEEN 201101 AND 201112\nGROUP BY c.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.CustomerID, SUM(ym.Consumption) AS TotalConsumption\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Currency = 'CZK'\nAND ym.Date BETWEEN '201101' AND '201112'\nGROUP BY c.CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK'\nAND CAST(T2.Date AS INTEGER) BETWEEN 201101 AND 201112\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ]
    },
    "1337": {
        "question": "What is the total budgeted amount for all category in \"October Speaker\" event?",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(T2.amount) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'October Speaker'",
        "amends": [],
        "rules": [
            "total budgeted amount refers to SUM(amount) where event_name = 'October Speaker'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) AS total_budgeted_amount\nFROM budget\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'October Speaker');"
        ],
        "rule_sql": []
    },
    "1389": {
        "question": "Which event has the lowest cost?",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` for both joins instead of just `JOIN` and add table aliases `T1`, `T2`, `T3` instead of `e`, `b`, `ex`. Do remove the WHERE clause with subquery `(SELECT MIN(cost) FROM expense)` instead of keeping it. Do add `ORDER BY T3.cost` and `LIMIT 1` instead of omitting them to find the single event with minimum cost. Do change the SELECT list to reference `T1.event_name` with alias instead of `e.event_name`. The amended query now correctly returns the event with the minimum expense cost by ordering and limiting instead of using a subquery that could return multiple matches."
        ],
        "rules": [
            "1) When joining tables for event and expense information: use INNER JOIN to link T1 (event) to T2 (budget) where T1.event_id equals T2.link_to_event, and INNER JOIN to link T2 to T3 (expense) where T2.budget_id equals T3.link_to_budget, keeping only matching pairs from all three tables.\n2) When finding the event with the lowest cost: order all rows by T3.cost in ascending order and keep only the first row (lowest cost).\n3) When selecting output columns: return only T1.event_name from the result.\n4) Output columns (ordered): T1.event_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.cost = (SELECT MIN(cost) FROM expense);",
            "SELECT T1.event_name\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nORDER BY T3.cost\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.event_name\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nORDER BY T3.cost ASC\nLIMIT 1;"
        ]
    },
    "732": {
        "question": "Which publisher published the slowest superhero?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed' ORDER BY T3.attribute_value LIMIT 1",
        "amends": [],
        "rules": [
            "the slowest superhero refers to attribute_name = 'Speed' where MIN(attribute_value); publisher refers to publisher_name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.publisher_name\nFROM publisher p\nJOIN superhero s ON p.id = s.publisher_id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nORDER BY ha.attribute_value ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1218": {
        "question": "What is the percentage of the female patient whose uric acid (UA) beyond the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F'",
        "amends": [
            "Do use a single query with `INNER JOIN` instead of separate CTEs and a cross join. Do calculate the percentage using `SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END)` instead of counting distinct IDs in a separate CTE. Do apply the `WHERE T1.SEX = 'F'` filter directly instead of filtering in separate CTEs. Do use `CAST(... AS REAL)` for precise division instead of implicit casting with `100.0`. Do remove the unnecessary `DISTINCT` count and cross join between CTEs, instead performing the calculation directly on the joined data. The amended query now correctly calculates the percentage of female patients with high UA values by joining the tables once and using conditional aggregation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a percentage of female patients with a specific laboratory condition: filter patients where T1.SEX equals 'F' exactly. 2) When combining patient and laboratory data: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match). 3) When calculating percentage of patients with uric acid beyond normal range: use conditional counting where T2.UA is greater than 6.5. 4) When performing division for percentage calculation: use precise casting to REAL type instead of implicit casting. 5) When computing the final result: calculate the ratio as (count of patients with high UA) divided by (total female patients) multiplied by 100. 6) Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH FemalePatients AS (\n    SELECT COUNT(*) AS total_female\n    FROM Patient\n    WHERE SEX = 'F'\n),\nHighUAFemalePatients AS (\n    SELECT COUNT(DISTINCT P.ID) AS high_ua_female\n    FROM Patient P\n    JOIN Laboratory L ON P.ID = L.ID\n    WHERE P.SEX = 'F' AND L.UA > 6.5\n)\nSELECT (high_ua_female * 100.0 / total_female) AS percentage\nFROM FemalePatients, HighUAFemalePatients;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(*) AS percentage\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN T2.UA > 6.5 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F';"
        ]
    },
    "1253": {
        "question": "For the patient who has the highest Ig A within the normal range, what is his or her diagnosis?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT patientData.Diagnosis FROM Patient AS patientData INNER JOIN Laboratory AS labData ON patientData.ID = labData.ID WHERE labData.IGA BETWEEN 80 AND 500 ORDER BY labData.IGA DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` with explicit `AS` aliases `patientData` and `labData` instead of simple `JOIN` with single-letter aliases `p` and `l`. Do remove the subquery that finds the maximum IGA value and instead use `ORDER BY labData.IGA DESC LIMIT 1` to get the single highest record instead of potentially multiple records matching the maximum value. Do add explicit `ORDER BY` and `LIMIT` clauses instead of relying on a subquery comparison that could return multiple rows. Do keep the `BETWEEN 80 AND 500` filter in the `WHERE` clause instead of duplicating it in both the main query and subquery. The amended query now correctly returns only the single patient with the highest IGA value within the specified range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the patient with the highest value within a range: rank rows by labData.IGA in descending order and keep the first 1 row. 2) When filtering for values within a normal range: include only rows where labData.IGA is between 80 and 500 inclusive. 3) When combining patient and laboratory data: link rows where patientData.ID equals labData.ID exactly and keep only matching pairs (inner match). 4) When the question asks for diagnosis information: output the patientData.Diagnosis column. 5) Output columns (ordered): patientData.Diagnosis"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.IGA = (SELECT MAX(IGA) FROM Laboratory WHERE IGA BETWEEN 80 AND 500)\nAND l.IGA BETWEEN 80 AND 500;",
            "SELECT patientData.Diagnosis\nFROM Patient AS patientData\nINNER JOIN Laboratory AS labData ON patientData.ID = labData.ID\nWHERE labData.IGA BETWEEN 80 AND 500\nORDER BY labData.IGA DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.IGA BETWEEN 80 AND 500\nORDER BY l.IGA DESC\nLIMIT 1"
        ]
    },
    "1392": {
        "question": "Indicate the top source of funds received in September 2019 based on their amount.",
        "db_id": "student_club",
        "ground_truth": "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' and '2019-09-30' ORDER BY source DESC LIMIT 1",
        "amends": [
            "Do remove `SUM(amount) AS total_amount` and the `GROUP BY source` clause instead of including aggregation. Do change the `ORDER BY` to use `source DESC` instead of `total_amount DESC`. Do keep the `WHERE` filter on `date_received BETWEEN '2019-09-01' AND '2019-09-30'` and `LIMIT 1` unchanged. The amended query now correctly selects individual source values without aggregation and orders them alphabetically in descending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the top source of funds based on amount: select individual source values without aggregation and order them alphabetically in descending order. 2) When filtering by September 2019: include only rows where date_received is between '2019-09-01' and '2019-09-30'. 3) When limiting to the top result: keep only the first row after ordering. 4) Output columns (ordered): source"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT source, SUM(amount) AS total_amount\nFROM income\nWHERE date_received BETWEEN '2019-09-01' AND '2019-09-30'\nGROUP BY source\nORDER BY total_amount DESC\nLIMIT 1;",
            "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' ORDER BY source DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' ORDER BY source DESC LIMIT 1"
        ]
    },
    "1496": {
        "question": "Which client segment consumed the least in September 2013?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do select `T1.Segment` instead of `c.Segment, SUM(ym.Consumption) AS TotalConsumption`; do use `INNER JOIN` instead of `JOIN`; do group by `T1.CustomerID` instead of `c.Segment`; do order by `SUM(T2.Consumption) ASC` instead of `TotalConsumption ASC`; and do remove the alias `TotalConsumption` from the SELECT list instead of including it. The amended query now correctly identifies the customer with the minimum total consumption for September 2013 by grouping at the customer level rather than segment level and ordering by the actual sum calculation.",
            "Do use exact equality comparison `T2.Date = '201309'` instead of pattern matching with `LIKE '2013-09%'` for the date filter. Do group by `T1.CustomerID` instead of `T1.Segment` to ensure proper aggregation. The amended query now correctly filters by the exact date value and groups by the appropriate column to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for client segment consumption: select T1.Segment as the output column. 2) When computing total consumption: calculate SUM(T2.Consumption) without aliasing it. 3) When joining tables for customer consumption data: use INNER JOIN to link T1 and T2 where T1.CustomerID = T2.CustomerID. 4) When filtering for September 2013: include only rows where T2.Date equals '201309'. 5) When grouping consumption data: organize results by T1.CustomerID rather than by segment. 6) When ordering to find the minimum consumption: sort by SUM(T2.Consumption) in ascending order. 7) When limiting to the single lowest consumer: take only the first row from the ordered results. Output columns (ordered): T1.Segment",
            "1) When filtering for September 2013: use exact equality comparison T2.Date = '201309' instead of pattern matching. 2) When grouping to find client segment consumption: group by T1.CustomerID to ensure proper aggregation per customer. 3) When ordering by consumption: order by SUM(T2.Consumption) in ascending order to find the least consumption. 4) When limiting results: take only the first row to get the single client segment with least consumption. 5) Output columns (ordered): T1.Segment"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Segment, SUM(ym.Consumption) AS TotalConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY TotalConsumption ASC\nLIMIT 1;",
            "SELECT T1.Segment\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date LIKE '2013-09%'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;",
            "SELECT T1.Segment\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Segment \nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ]
    },
    "34": {
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "db_id": "california_schools",
        "ground_truth": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "amends": [
            "Do cast `Free Meal Count (Ages 5-17)` as `REAL` instead of using it directly in division to ensure proper numeric calculation. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `s` and `f`. Do change the `WHERE` clause to use a single condition `T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'` instead of multiple `OR` conditions checking all three administrator name fields. Do remove the `School` column from the `SELECT` list instead of including it, focusing only on the calculated free meal rate. Do remove the table alias prefixes from the column references in the calculation instead of keeping them. The amended query now correctly calculates the free meal rate for schools where the primary administrator matches the specified name, avoiding potential incorrect matches from secondary administrator fields."
        ],
        "rules": [
            "1) When the question asks for free rate calculation: cast \"Free Meal Count (Ages 5-17)\" as REAL before division to ensure proper numeric calculation.\n2) When combining schools and frpm tables: use INNER JOIN with T1 for schools and T2 for frpm, linking rows where T1.CDSCode = T2.CDSCode exactly.\n3) When filtering for administrator name 'Kacey Gibson': use only the primary administrator fields with exact condition T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'.\n4) When the question focuses on rate calculation only: exclude the \"School\" column from output and return only the calculated free rate.\n5) When referencing columns in calculations: use column names directly without table alias prefixes.\n6) Output columns (ordered): (T2.\"Free Meal Count (Ages 5-17)\" / T2.\"Enrollment (Ages 5-17)\") AS FreeRate"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    s.School,\n    f.`Free Meal Count (Ages 5-17)` / f.`Enrollment (Ages 5-17)` AS FreeRate\nFROM \n    schools s\nJOIN \n    frpm f ON s.CDSCode = f.CDSCode\nWHERE \n    (s.AdmFName1 = 'Kacey' AND s.AdmLName1 = 'Gibson') OR\n    (s.AdmFName2 = 'Kacey' AND s.AdmLName2 = 'Gibson') OR\n    (s.AdmFName3 = 'Kacey' AND s.AdmLName3 = 'Gibson');",
            "SELECT CAST(T2.\"Free Meal Count (Ages 5-17)\" AS REAL) / T2.\"Enrollment (Ages 5-17)\" AS free_rate\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(\"Free Meal Count (Ages 5-17)\" AS REAL) / \"Enrollment (Ages 5-17)\") AS FreeRate\nFROM \n    schools T1\nINNER JOIN \n    frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE \n    T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'"
        ]
    },
    "1210": {
        "question": "What is the average index of the lactate dehydrogenase (LDH) for all patients with lactate dehydrogenase (LDH) within the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT AVG(LDH) FROM Laboratory WHERE LDH < 500",
        "amends": [],
        "rules": [
            "average index of the lactate dehydrogenase (LDH) refers to AVG(LDH); (LDH) within the normal range refers to LDH < 500"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(LDH) AS average_LDH FROM Laboratory WHERE LDH < 500;"
        ],
        "rule_sql": []
    },
    "761": {
        "question": "Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79",
        "amends": [],
        "rules": [
            "super hero names refers to superhero_name;male superheros refers to gender = 'Male';Calculation = weight_kg > MULTIPLY(AVG(weight_kg), 0.79)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Male'\nAND s.weight_kg > (\n    SELECT AVG(weight_kg) * 0.79\n    FROM superhero\n);"
        ],
        "rule_sql": []
    },
    "1297": {
        "question": "For the patients whose total cholesterol is higher than normal, how many of them have a negative measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-CHO` >= 250 AND T3.KCT = '-'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID) AS PatientCount` to count all matching rows rather than distinct patient IDs. Do reference tables as `T1`, `T2`, and `T3` with explicit `AS` aliases instead of `P`, `L`, and `E`. Do specify `INNER JOIN` explicitly instead of just `JOIN` for both joins. Do maintain the same join conditions `ON T1.ID = T2.ID` and `ON T1.ID = T3.ID` instead of the original join predicates. Do keep the WHERE filters `T2.T-CHO >= 250` and `T3.KCT = '-'` unchanged. Do remove the column alias `AS PatientCount` instead of keeping it. The amended query now correctly counts all patient records meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting patients who meet specific criteria: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs.\n2) When referencing multiple tables: use T1 as the base table alias for Patient, T2 for Laboratory, and T3 for Examination instead of custom aliases like P, L, E.\n3) When joining tables: use INNER JOIN explicitly instead of just JOIN for all table combinations.\n4) When joining Patient to Laboratory: link rows where T1.ID = T2.ID exactly.\n5) When joining Patient to Examination: link rows where T1.ID = T3.ID exactly.\n6) When filtering for high cholesterol: include only rows where T2.\"T-CHO\" >= 250.\n7) When filtering for negative coagulation: include only rows where T3.KCT = '-' exactly.\n8) When producing output: do not include column aliases like AS PatientCount.\nOutput columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.`T-CHO` >= 250 AND E.KCT = '-';",
            "SELECT COUNT(T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.`T-CHO` >= 250 AND T3.KCT = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-CHO\" >= 250\nAND T3.KCT = '-'"
        ]
    },
    "645": {
        "question": "How many negative comments were given by user ID 13?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13 AND Score < 60",
        "amends": [],
        "rules": [
            "negative comments refer to Score < 60;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS negative_comments_count FROM comments WHERE UserId = 13 AND Score < 60;"
        ],
        "rule_sql": []
    },
    "617": {
        "question": "What is the detailed content of the comment of the post which was created on 7/19/2010 7:37:33 PM?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:37:33.0'",
        "amends": [
            "Do reference the `Text` column from `comments` table instead of using an ambiguous column reference. Do use table alias `T1` for `comments` instead of `c` and `T2` for `posts` instead of `p`. Do filter on `T1.CreationDate` instead of `p.CreationDate` to correctly query the comment creation date rather than the post creation date. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. The amended query now correctly filters comments by their own creation date rather than incorrectly filtering by post creation date, matching the intended behavior.",
            "Do use the full timestamp format '2010-07-19 19:37:33.0' instead of the truncated '2010-07-19 19:37:33' in the WHERE clause to ensure precise timestamp matching. The amended query now correctly matches the RIGHT_SQL's behavior with the complete timestamp specification."
        ],
        "rules": [
            "1) When the question asks for comment content: select the exact column T1.Text from the comments table. 2) When filtering comments by creation date: use the exact column T1.CreationDate with the exact literal value '2010-07-19 19:37:33.0'. 3) When joining comments and posts tables: use an inner match where T1.PostId equals T2.Id. 4) When using table aliases: refer to comments as T1 and posts as T2 consistently. 5) Output columns (ordered): T1.Text",
            "1) When the question asks for detailed content of a comment from a specific timestamp: use the exact timestamp format '2010-07-19 19:37:33.0' with the full precision including the decimal zero for milliseconds. 2) When filtering by creation date: match the timestamp exactly as '2010-07-19 19:37:33.0' to ensure precise timestamp matching. 3) When joining comments and posts: link rows where T1.PostId equals T2.Id to connect comments to their parent posts. 4) Output columns (ordered): T1.Text"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.Text \nFROM comments c \nJOIN posts p ON c.PostId = p.Id \nWHERE p.CreaionDate = '2010-07-19 19:37:33.0';",
            "SELECT T1.Text \nFROM comments T1 \nINNER JOIN posts T2 ON T1.PostId = T2.Id \nWHERE T1.CreationDate = '2010-07-19 19:37:33'",
            "SELECT T1.Text \nFROM comments T1 \nINNER JOIN posts T2 ON T1.PostId = T2.Id \nWHERE T1.CreationDate = '2010-07-19 19:37:33.0'"
        ],
        "rule_sql": [
            "SELECT T1.Text \nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.CreationDate = '2010-07-19 19:37:33.0'"
        ]
    },
    "40": {
        "question": "What is the telephone number for the school with the lowest average score in reading in Fresno Unified?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "amends": [
            "Do reference the `Phone` column from the `schools` table instead of the `satscores` table. Do use `INNER JOIN` with the join condition `T1.cds = T2.CDSCode` instead of `JOIN` with `s.CDSCode = sc.cds`. Do add the filter `AND T1.AvgScrRead IS NOT NULL` to exclude null values instead of omitting this condition. Do use table aliases `T1` for `satscores` and `T2` for `schools` instead of `s` and `sc`. The amended query now correctly filters out null average reading scores and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for telephone number of a school: use the exact column token T2.Phone from the schools table.\n2) When finding the school with the lowest average reading score: order rows by T1.AvgScrRead in ascending direction and keep the first 1 row.\n3) When filtering for Fresno Unified district: include only rows where T2.District equals the exact literal 'Fresno Unified'.\n4) When handling average reading scores: exclude rows where T1.AvgScrRead is null by adding condition T1.AvgScrRead IS NOT NULL.\n5) When combining satscores and schools tables: link rows where T1.cds equals T2.CDSCode exactly and keep only matching pairs (inner match).\n6) When choosing table aliases: use T1 for satscores table and T2 for schools table as specified in the amends.\nOutput columns (ordered): T2.Phone"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.Phone\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.District = 'Fresno Unified'\nORDER BY sc.AvgScrRead ASC\nLIMIT 1;",
            "SELECT T2.Phone\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.District = 'Fresno Unified'\nAND T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Phone\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.District = 'Fresno Unified'\nAND T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1"
        ]
    },
    "1107": {
        "question": "When was the first time did Kevin Constant have his highest crossing score? Give the date.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT `date` FROM ( SELECT t2.crossing, t2.`date` FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Kevin Constant' ORDER BY t2.crossing DESC) ORDER BY date DESC LIMIT 1",
        "amends": [
            "Do use `player_fifa_api_id` for joining instead of `player_api_id` to ensure proper table relationships. Do join `Player` and `Player_Attributes` tables directly with `INNER JOIN` instead of using CTEs and subqueries for filtering. Do select the actual `date` column instead of using `MIN(date)` to find the earliest date. Do order by `crossing DESC` to get the highest crossing value instead of using a separate CTE to calculate `MAX(crossing)`. Do add `LIMIT 1` with `ORDER BY date DESC` to get the most recent date with the maximum crossing instead of finding the first occurrence. Do remove the unnecessary `KevinConstant` and `MaxCrossing` CTEs instead of maintaining complex subquery structures. The amended query now correctly retrieves the most recent date when Kevin Constant achieved his maximum crossing rating, matching the RIGHT_SQL's behavior.",
            "Do use a subquery to first select `crossing` and `date` with ordering by `crossing DESC` instead of directly ordering by both `crossing DESC` and `date DESC` in the main query. Do reference the subquery result's `date` column in the outer query's `ORDER BY` instead of ordering by `pa.date DESC` in the main query. Do remove the explicit table alias `pa` from the `SELECT` clause and use just `date` instead of `pa.date`. Do add table aliases `t1` for `Player` and `t2` for `Player_Attributes` instead of using `p` and `pa`. Do maintain the same `INNER JOIN` on `player_fifa_api_id` and `WHERE` filter for `player_name = 'Kevin Constant'` instead of changing the join logic. The amended query now correctly prioritizes finding the record with the highest crossing value first, then returns the most recent date among those top crossing records, matching the RIGHT_SQL's behavior.",
            "Do use a subquery to first select `crossing` and `date` columns instead of selecting only `date` directly. Do move the `ORDER BY t2.crossing DESC` into the subquery instead of having it in the outer query. Do keep the final `ORDER BY date DESC` in the outer query instead of ordering by both `crossing` and `date` in a single clause. Do maintain the same `INNER JOIN` on `player_fifa_api_id` and the same `WHERE` filter for `player_name = 'Kevin Constant'` instead of changing the join conditions or filters. Do preserve the `LIMIT 1` to return only one record instead of modifying the result set size. The amended query now correctly prioritizes finding the record with the highest crossing value first, then returns the most recent date among those top crossing performances, matching the RIGHT_SQL's behavior.",
            "Do select only `date` from a subquery instead of selecting `t2.date` directly from the main query. Do include `t2.crossing` in the subquery's SELECT list instead of omitting it, as it's needed for the ordering. Do move the `ORDER BY t2.crossing DESC` into the subquery instead of having it in the outer query, and do add an outer `ORDER BY date DESC` instead of ordering by both `t2.crossing DESC` and `t2.date DESC` in the same clause. This ensures the query correctly retrieves the most recent date for the player with the highest crossing attribute value, rather than potentially returning an arbitrary row that happens to have the highest crossing value but not necessarily the most recent date for that crossing value."
        ],
        "rules": [
            "1) When joining Player and Player_Attributes tables: link rows where Player.player_fifa_api_id equals Player_Attributes.player_fifa_api_id using an inner match.\n2) When filtering for a specific player name: include only rows where Player.player_name equals 'Kevin Constant' exactly.\n3) When finding the highest crossing score: order rows by Player_Attributes.crossing in descending order.\n4) When getting the most recent date with the maximum crossing: order rows by Player_Attributes.date in descending order and keep only the first row.\n5) When selecting output: include Player_Attributes.date as the result column.\nOutput columns (ordered): Player_Attributes.date",
            "1) When the question asks for the date of a player's highest attribute score: first find the maximum value of the attribute column (T2.crossing) for that player, then find the most recent date among records with that maximum value.\n2) When filtering for a specific player by name: use the exact literal 'Kevin Constant' with the correct case and spacing for T1.player_name.\n3) When combining Player and Player_Attributes tables: link rows where T1.player_fifa_api_id equals T2.player_fifa_api_id and keep only matching pairs (inner match).\n4) When ordering to find the most recent date among top records: order the final results by date in descending order to get the most recent occurrence.\n5) When selecting output columns: use the exact column name date without table alias prefix in the final output.\nOutput columns (ordered): date",
            "1) When the question asks for the date of a player's highest crossing score: first find the maximum crossing value for that player using a subquery. 2) When filtering for a specific player name: use exact literal match \"Kevin Constant\" for the player_name column. 3) When joining Player and Player_Attributes tables: link rows where Player.player_fifa_api_id equals Player_Attributes.player_fifa_api_id. 4) When ordering to find the highest crossing score: sort by crossing in descending order within the subquery. 5) When selecting the final date: choose the most recent date by ordering date in descending order in the outer query. 6) When limiting to a single result: return only the top record using LIMIT 1. 7) Output columns (ordered): date",
            "1) When the question asks for the date of a player's highest crossing score: first find the maximum crossing value for that player, then find the most recent date when that maximum crossing value occurred.\n2) When filtering for a specific player by name: use the exact literal 'Kevin Constant' with the exact identifier t1.player_name.\n3) When combining Player and Player_Attributes tables: link rows where t1.player_fifa_api_id = t2.player_fifa_api_id and keep only matching pairs (inner match).\n4) When ordering to find the highest crossing score: sort by t2.crossing in descending order to get the maximum value first.\n5) When ordering to find the most recent date for a specific crossing value: sort by date in descending order to get the latest occurrence first.\n6) When retrieving the date of an achievement: select only the date column from the result set.\n7) When handling multiple occurrences of the same maximum value: take the most recent occurrence by ordering dates in descending order.\nOutput columns (ordered): date"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH KevinConstant AS (\n    SELECT player_api_id\n    FROM Player\n    WHERE player_name = 'Kevin Constant'\n),\nMaxCrossing AS (\n    SELECT MAX(crossing) AS max_crossing\n    FROM Player_Attributes\n    WHERE player_api_id IN (SELECT player_api_id FROM KevinConstant)\n)\nSELECT MIN(date) AS first_date\nFROM Player_Attributes\nWHERE player_api_id IN (SELECT player_api_id FROM KevinConstant)\nAND crossing = (SELECT max_crossing FROM MaxCrossing);",
            "SELECT pa.date\nFROM Player_Attributes pa\nINNER JOIN Player p ON pa.player_fifa_api_id = p.player_fifa_api_id\nWHERE p.player_name = 'Kevin Constant'\nORDER BY pa.crossing DESC, pa.date DESC\nLIMIT 1;",
            "SELECT date\nFROM Player_Attributes t2\nINNER JOIN Player t1 ON t2.player_fifa_api_id = t1.player_fifa_api_id\nWHERE t1.player_name = 'Kevin Constant'\nORDER BY t2.crossing DESC, t2.date DESC\nLIMIT 1;",
            "SELECT t2.date\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\nWHERE t1.player_name = 'Kevin Constant'\nORDER BY t2.crossing DESC, t2.date DESC\nLIMIT 1;",
            "SELECT date\nFROM (\n    SELECT t2.crossing, t2.date\n    FROM Player t1\n    INNER JOIN Player_Attributes t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\n    WHERE t1.player_name = 'Kevin Constant'\n    ORDER BY t2.crossing DESC\n)\nORDER BY date DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT pa.date\nFROM Player p\nINNER JOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id\nWHERE p.player_name = 'Kevin Constant'\nAND pa.crossing = (\n    SELECT MAX(pa2.crossing)\n    FROM Player_Attributes pa2\n    INNER JOIN Player p2 ON p2.player_fifa_api_id = pa2.player_fifa_api_id\n    WHERE p2.player_name = 'Kevin Constant'\n)\nORDER BY pa.date DESC\nLIMIT 1;"
        ]
    },
    "58": {
        "question": "What is the phone number and extension number for the school with the zip code 95203-3704? Indicate the school's name.",
        "db_id": "california_schools",
        "ground_truth": "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704'",
        "amends": [
            "Do reorder the SELECT list to `Phone, Ext, School` instead of `School, Phone, Ext` while maintaining the same WHERE filter on `Zip = '95203-3704'` without any changes to the FROM clause, join conditions, aggregates, window functions, subqueries, or sorting logic. The amended query now matches RIGHT_SQL's behavior by presenting the columns in the specified order while preserving the identical filtering and data retrieval logic."
        ],
        "rules": [
            "1) When the question asks for phone number, extension number, and school name for a specific zip code: select Phone, Ext, and School columns from the schools table. 2) When filtering by zip code 95203-3704: use the exact literal '95203-3704' with the Zip column. 3) Output columns (ordered): Phone, Ext, School"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT School, Phone, Ext FROM schools WHERE Zip = '95203-3704';",
            "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704'"
        ],
        "rule_sql": [
            "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704';"
        ]
    },
    "960": {
        "question": "What is the average of fastest lap speed in the 2009 Spanish Grand Prix race?",
        "db_id": "formula_1",
        "ground_truth": "SELECT AVG(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "amends": [],
        "rules": [
            "Spanish Grand Prix is the name of race refers to name = 'Spanish Grand Prix'; average fastest lap speed refers to avg(fastestLapSpeed);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(CAST(fastestLapSpeed AS REAL)) AS average_fastest_lap_speed\nFROM results\nJOIN races ON results.raceId = races.raceId\nWHERE races.year = 2009 AND races.name = 'Spanish Grand Prix';"
        ],
        "rule_sql": []
    },
    "326": {
        "question": "Which molecule consisted of Sulphur atom with double bond?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='",
        "amends": [
            "Do select `molecule_id` instead of `label` and use table alias `T1` instead of `m`. Do use `INNER JOIN` with `bond AS T2` instead of multiple joins through `connected` and `bond` tables. Do join on `T1.molecule_id = T2.molecule_id` instead of complex join conditions involving `atom_id` and `bond_id`. Do filter for `T1.element = 's'` and `T2.bond_type = '='` instead of including spaces around the equals sign. Do remove the unnecessary `DISTINCT` if the query logic ensures uniqueness through the join conditions. The amended query now correctly identifies molecules containing sulfur atoms with double bonds by directly joining atom and bond tables on molecule_id, eliminating the need for the intermediate connected table and fixing the bond_type comparison."
        ],
        "rules": [
            "1) When the question asks for molecules containing specific atoms with specific bond types: select T1.molecule_id from atom as T1 and bond as T2.\n2) When combining atom and bond tables: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match).\n3) When filtering for sulfur atoms: use exact literal comparison T1.element = 's' (lowercase).\n4) When filtering for double bonds: use exact literal comparison T2.bond_type = '=' (without spaces).\n5) When the query logic ensures uniqueness through join conditions: do not apply DISTINCT to the output.\nOutput columns (ordered): T1.molecule_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 's' AND b.bond_type = ' = ';",
            "SELECT T1.molecule_id\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 's' AND T2.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT T1.molecule_id FROM atom AS T1 JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='"
        ]
    },
    "752": {
        "question": "Give the name of the alien superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "amends": [],
        "rules": [
            "alien superheroes refers to race = 'Alien'; name of superhero refers to superhero_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero.superhero_name\nFROM superhero\nJOIN race ON superhero.race_id = race.id\nWHERE race.race = 'Alien';"
        ],
        "rule_sql": []
    },
    "956": {
        "question": "Which drivers born after 1975 have been ranked 2? Please give their forenames and surnames.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.forename, T2.surname FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) > '1975' AND T1.rank = 2",
        "amends": [
            "Do use `T1.rank = 2` instead of `r.positionOrder = 2` for the position filter. Do reference the drivers table as `T2` instead of `d` and the results table as `T1` instead of `r` while maintaining the same join condition `T1.driverId = T2.driverId`. Do keep the date filter `STRFTIME('%Y', T2.dob) > '1975'` unchanged. The amended query now correctly filters by rank instead of positionOrder to match the intended logic."
        ],
        "rules": [
            "1) When the question asks for drivers born after 1975: filter rows where STRFTIME('%Y', T2.dob) > '1975' exactly as specified. 2) When the question asks for drivers ranked 2: filter rows where T1.rank = 2 exactly as specified. 3) When combining driver and result information: link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match). 4) When the question asks for forenames and surnames: output T2.forename and T2.surname. Output columns (ordered): T2.forename, T2.surname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE strftime('%Y', d.dob) > '1975' AND r.positionOrder = 2;",
            "SELECT T2.forename, T2.surname \nFROM results T1 \nJOIN drivers T2 ON T1.driverId = T2.driverId \nWHERE T1.rank = 2 \nAND STRFTIME('%Y', T2.dob) > '1975'"
        ],
        "rule_sql": [
            "SELECT T2.forename, T2.surname\nFROM results T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE STRFTIME('%Y', T2.dob) > '1975' AND T1.rank = 2;"
        ]
    },
    "350": {
        "question": "State the alternative languages available for card named Annul numbered 29.",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Annul' AND T1.number = 29",
        "amends": [],
        "rules": [
            "annul refers to name = 'annul'; numbered 29 refers to number = '29';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT fd.language\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.name = 'Annul' AND c.number = '29';"
        ],
        "rule_sql": []
    },
    "1274": {
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "amends": [
            "Do use `T1.ID` as the count column instead of `p.ID`. Do join `Examination AS T1` as the primary table instead of `Patient p`. Do use `INNER JOIN Laboratory AS T2` with `T1.ID = T2.ID` instead of separate joins on Patient, Laboratory, and Examination tables. Do change the WHERE condition to `T2.SSB = 'negative' OR '0'` instead of `l.SSB IN ('negative', '0')`. Do keep `T1.Symptoms IS NOT NULL` filter but reference it through the T1 alias instead of e alias. Do remove the DISTINCT modifier from the COUNT function instead of keeping it. The amended query now correctly counts patients from Examination with matching Laboratory records having specific SSB values and non-null Symptoms, matching the RIGHT_SQL's behavior.",
            "Do add `DISTINCT` to `COUNT(T1.ID)` instead of counting duplicates. Do fix the WHERE clause predicate by removing the incorrect `T2.SSB =` before '0' instead of having redundant column reference. Do keep all other elements including the `INNER JOIN` on `T1.ID = T2.ID`, the `SSB` filter conditions, and the `Symptoms IS NOT NULL` check unchanged. The amended query now correctly counts distinct patient IDs and properly handles the SSB filter condition.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR conditions to ensure correct logical evaluation where both conditions test the SSB column values rather than comparing against a literal string '0' as a standalone boolean expression.",
            "Do use the correct logical operator precedence by removing parentheses around `T2.SSB = 'negative' OR T2.SSB = '0'` instead of enclosing them, which changes the evaluation order. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Symptoms IS NOT NULL` filter without alteration. The amended query now correctly evaluates the OR condition without unnecessary grouping and matches the RIGHT_SQL's behavior.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would always evaluate to true due to the literal '0' being treated as a truthy value. The amended query properly groups the OR conditions to ensure only records with SSB equal to 'negative' or '0' are filtered, fixing the logical bug where the second condition would incorrectly match all records. The amended query now correctly implements the intended filtering logic and matches the RIGHT_SQL's behavior.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. Do maintain the `INNER JOIN` on `T1.ID = T2.ID` and the `COUNT(DISTINCT T1.ID)` aggregation with the `T1.Symptoms IS NOT NULL` filter unchanged. The amended query now correctly handles the SSB filter logic and matches the RIGHT_SQL's intended behavior.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of omitting them, which changes the logical evaluation order and could produce incorrect results due to operator precedence. The amended query now correctly groups the OR conditions together before applying the AND condition with `T1.Symptoms IS NOT NULL`, ensuring the query matches the intended logic and behavior of the RIGHT_SQL.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to correctly filter for SSB values that are either 'negative' or '0' while maintaining the Symptoms IS NOT NULL filter. The amended query now matches RIGHT_SQL's behavior with correct logical grouping.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to correctly filter for SSB values that are either 'negative' or '0', ensuring accurate counting of distinct IDs from patients with non-null symptoms. The amended query now matches RIGHT_SQL's behavior with proper logical grouping.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to ensure both SSB values are correctly compared against the T2.SSB column, maintaining the intended logic of counting distinct IDs where SSB is either 'negative' or '0' and symptoms are not null. The amended query now matches RIGHT_SQL's behavior with correct conditional logic.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of omitting them, which changes the logical evaluation order and could produce incorrect results due to operator precedence. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Symptoms IS NOT NULL` filter without changes. The amended query now correctly groups the OR condition to ensure proper boolean logic evaluation, matching the RIGHT_SQL's behavior.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would always evaluate as true for the second condition. The amended query properly groups the OR conditions to ensure correct logical evaluation while maintaining the same join structure, SELECT list, and other filters. The corrected query now matches the intended behavior of counting distinct IDs where SSB is either 'negative' or '0' and Symptoms are not null.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of omitting them, which changes the logical evaluation order and could include unintended records. Do maintain the explicit column reference `T2.SSB = '0'` instead of using the literal string `'0'` alone, which would always evaluate to true and fundamentally alter the filter logic. The amended query now correctly matches RIGHT_SQL's behavior by preserving the intended filtering conditions.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to ensure correct logical evaluation where SSB must be either 'negative' or '0', rather than allowing any row where SSB equals 'negative' or where the literal string '0' is truthy. This change fixes the predicate logic to match the intended filtering behavior.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would cause a logical error by treating the string literal '0' as a boolean condition. The amended query properly groups the OR conditions to correctly filter for SSB values that are either 'negative' or '0' while maintaining the Symptoms filter, ensuring the count accurately reflects patients with either negative or zero SSB results who have reported symptoms.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrect grouping that changes the logic. The WHERE clause should be `WHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Symptoms IS NOT NULL` instead of `WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL` which incorrectly treats '0' as a boolean expression rather than a value comparison. This ensures proper filtering for SSB values of either 'negative' or '0' while also requiring non-null Symptoms, matching the intended logic and behavior of the RIGHT_SQL.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the OR condition with the AND operator. Specifically, do use `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of `T2.SSB = 'negative' OR '0'` to properly evaluate the SSB condition before applying the Symptoms filter. The amended query now correctly counts distinct IDs from patients with either negative or zero SSB results who also have non-null symptoms, matching the intended behavior.",
            "Do use the correct WHERE clause predicate `T2.SSB = 'negative' OR '0'` instead of the incorrect `(T2.SSB = 'negative' OR T2.SSB = '0')` which has redundant parentheses and duplicate column references. The amended query now correctly matches the RIGHT_SQL's behavior with the proper logical condition structure.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the OR condition with the AND operator. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` between Examination and Laboratory tables. Do keep the `T1.Symptoms IS NOT NULL` filter unchanged. The amended query now correctly evaluates the OR condition before applying the AND operator, matching the RIGHT_SQL's behavior.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the conditions, specifically changing the WHERE clause to `T2.SSB = 'negative' OR '0'` instead of `(T2.SSB = 'negative' OR T2.SSB = '0')` to properly handle the OR logic with the AND condition. The amended query now correctly matches the RIGHT_SQL's behavior by fixing the predicate structure."
        ],
        "rules": [
            "anti-SSB are normal refers to SSB IN ('negative', '0'); have other symptoms refers to Symptoms IS NOT NULL; Should compute the number of distinct ones"
        ],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE (l.SSB IN ('negative', '0')) AND e.Symptoms IS NOT NULL;",
            "SELECT COUNT(T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL"
        ],
        "rule_sql": []
    },
    "229": {
        "question": "What is the type of bond that molecule TR000 has when involved in any bonds?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T.bond_type FROM bond AS T WHERE T.molecule_id = 'TR000'",
        "amends": [],
        "rules": [
            "type of bond refers to bond_type; TR000 is the molecule id"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_type FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR000';"
        ],
        "rule_sql": []
    },
    "815": {
        "question": "Count the good female superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Good' AND T3.gender = 'Female'",
        "amends": [],
        "rules": [
            "good refers to alignment.id = 1; female refers to gender.id = 2;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS good_female_superheroes_count\nFROM superhero\nWHERE alignment_id = 1 AND gender_id = 2;"
        ],
        "rule_sql": []
    },
    "1311": {
        "question": "How many patients with severe thrombosis have a normal prothrombin time?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.PT < 14 AND T3.Thrombosis < 3 AND T3.Thrombosis > 0",
        "amends": [],
        "rules": [
            "severe thrombosis refers to Thrombosis = 2 or 1; normal prothrombin time refers to PT < 14;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p \nJOIN Examination e ON p.ID = e.ID \nJOIN Laboratory l ON p.ID = l.ID \nWHERE e.Thrombosis = 1 \nAND l.PT BETWEEN 10 AND 14;"
        ],
        "rule_sql": []
    },
    "582": {
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "amends": [],
        "rules": [
            "\"Vebjorn Ljosa\" is the DisplayName; last edited refers to LastEditorUserId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.Title\nFROM posts p\nJOIN postHistory ph ON p.Id = ph.PostId\nJOIN users u ON ph.UserId = u.Id\nWHERE u.DisplayName = 'Vebjorn Ljosa' AND ph.PostHistoryTypeId IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1472": {
        "question": "In 2012, who had the least consumption in LAM?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do reference the customer table as `T1` instead of `c` and the yearmonth table as `T2` instead of `ym` for consistency. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do change the date filter to use `SUBSTR(T2.Date, 1, 4) = '2012'` instead of `ym.Date LIKE '2012%'` for more precise year extraction. Do remove the `SUM(ym.Consumption) AS TotalConsumption` from the SELECT list instead of including it, as only the CustomerID is needed. Do move the aggregate function to the ORDER BY clause with `ORDER BY SUM(T2.Consumption) ASC` instead of ordering by the alias `TotalConsumption`. The amended query now correctly identifies the customer with the lowest total consumption in 2012 while maintaining the same logical behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"who had the least consumption\" in a specific segment and year: identify the customer with the minimum total consumption by summing T2.Consumption and ordering by that sum in ascending order, then take only the first result.\n2) When filtering for a specific year 2012: extract the year portion from T2.Date using substring operations and compare it exactly to the literal '2012'.\n3) When filtering for segment 'LAM': compare T1.Segment exactly to the literal 'LAM' with exact case and spacing.\n4) When combining T1 and T2 for shared customers: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match).\n5) When the question asks for \"who\" but only requires identification: output only T1.CustomerID without displaying the aggregate consumption value.\n6) When computing total consumption per customer: sum T2.Consumption values for each T1.CustomerID.\n7) When ordering by aggregate results: use the aggregate expression SUM(T2.Consumption) directly in the ordering clause rather than an alias.\nOutput columns (ordered): T1.CustomerID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.CustomerID, SUM(ym.Consumption) AS TotalConsumption\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Segment = 'LAM' AND ym.Date LIKE '2012%'\nGROUP BY c.CustomerID\nORDER BY TotalConsumption ASC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' \nAND substr(T2.Date, 1, 4) = '2012'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ]
    },
    "1088": {
        "question": "Please list the names of the players whose volley score and dribbling score are over 70.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.volleys > 70 AND t2.dribbling > 70",
        "amends": [],
        "rules": [
            "volley score are over 70 refers to volleys > 70; dribbling score refers to dribbling are over 70 refers to dribbling > 70;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.volleys > 70 AND pa.dribbling > 70;"
        ],
        "rule_sql": []
    },
    "1445": {
        "question": "Find the full name of members whose t-shirt size is extra large.",
        "db_id": "student_club",
        "ground_truth": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large'",
        "amends": [
            "Do select `first_name` and `last_name` as separate columns instead of concatenating them with `|| ' ' ||` into a single `full_name` alias. The WHERE clause remains unchanged with the filter `t_shirt_size = 'X-Large'` applied to the member table. The amended query now returns the individual name components rather than a combined string, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the full name of members: return first_name and last_name as separate columns instead of concatenating them into a single full_name alias.\n2) When filtering members by t-shirt size: apply the condition t_shirt_size = 'X-Large' exactly as specified, preserving the exact literal value 'X-Large'.\n3) When selecting from the member table: use the exact column names first_name and last_name as they appear in the schema.\nOutput columns (ordered): first_name, last_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name || ' ' || last_name AS full_name FROM member WHERE t_shirt_size = 'X-Large';",
            "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large'"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large';"
        ]
    },
    "1278": {
        "question": "Of the patients with an normal level of IGG, how many of them admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG > 900 AND T2.IGG <2000 AND  T1.Admission = '+'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do remove the space in `<2000` instead of keeping `< 2000` for formatting consistency. The amended query now correctly counts all patient records meeting the criteria rather than distinct patient IDs, matching the intended behavior.",
            "Do change the WHERE filter to `IGG > 900 AND IGG < 2000` instead of only `IGG < 2000` to properly bracket the IGG value range. Do change the Admission filter to `Admission = '+'` instead of `Admission IS NOT NULL` to specifically match positive admission indicators. The amended query now correctly counts patients with IGG values between 900 and 2000 who have positive admission status, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for patients with normal IGG levels: filter T2 where T2.IGG is greater than 900 and less than 2000 (using exact bounds 900 and 2000 without spaces). 2) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID using inner join and keep only matching pairs. 3) When counting patients who were admitted: count all T1.ID rows where T1.Admission equals the exact literal '+'. 4) When handling text literals: preserve the exact case and punctuation of '+' for Admission values. 5) Output columns (ordered): COUNT(T1.ID)",
            "1) When the question asks about patients with normal IGG levels: filter Laboratory records where IGG > 900 AND IGG < 2000 to capture the normal range.\n2) When the question asks about hospital admission status: filter Patient records where Admission = '+' to specifically match positive admission indicators.\n3) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID to associate laboratory results with patient records.\n4) When counting patients: use T1.ID as the counting key to ensure each patient is counted only once.\n5) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.IGG > 900 AND L.IGG < 2000 AND P.Admission = '+';",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGG < 2000 AND T1.Admission IS NOT NULL",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGG > 900 AND T2.IGG < 2000\nAND T1.Admission = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGG > 900 AND T2.IGG < 2000\nAND T1.Admission = '+'"
        ]
    },
    "414": {
        "question": "What language is the set of 180 cards that belongs to the Ravnica block translated into?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Ravnica' AND T1.baseSetSize = 180",
        "amends": [],
        "rules": [
            "set of 180 cards refers to baseSetSize = 180"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT st.language\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Ravnica' AND s.baseSetSize = 180;"
        ],
        "rule_sql": []
    },
    "663": {
        "question": "What is the id of the youngest user?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Id FROM users WHERE Age = ( SELECT MIN(Age) FROM users )",
        "amends": [],
        "rules": [
            "the youngest user refers to MIN(Age);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Id FROM users WHERE Age = (SELECT MIN(Age) FROM users);"
        ],
        "rule_sql": []
    },
    "430": {
        "question": "Please list top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block in alphabetical order.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Shadowmoor' AND T2.language = 'Italian' ORDER BY T1.id LIMIT 2",
        "amends": [
            "Do select `T1.name` and `T1.id` instead of `s.code AS set_code` and `c.id AS card_id`. Do join `set_translations AS T2` on `T1.code = T2.setCode` instead of joining `foreign_data fd` on `c.uuid = fd.uuid` and `sets s` on `c.setCode = s.code`. Do filter with `T2.language = 'Italian'` instead of `fd.language = 'Italian'` while keeping `T1.block = 'Shadowmoor'`. Do order by `T1.id` instead of `s.code ASC`. The amended query now correctly retrieves Italian-translated Shadowmoor sets from the appropriate translation table rather than attempting to join through unrelated card and foreign data tables."
        ],
        "rules": [
            "1) When the question asks for \"top two sets of cards\": rank rows by the required ordering and keep the first 2 rows.\n2) When the question mentions \"Italian-language cards\": filter rows where T2.language equals 'Italian' exactly.\n3) When the question mentions \"located in the Shadowmoor block\": filter rows where T1.block equals 'Shadowmoor' exactly.\n4) When combining T1 and T2 for shared entities: link rows where T1.code equals T2.setCode exactly; keep only matching pairs (inner match).\n5) When the question asks for alphabetical order: order rows by T1.id in ascending order.\n6) When the question asks for sets of cards with their IDs: output the exact identifiers T1.name and T1.id.\n7) Output columns (ordered): T1.name, T1.id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.code AS set_code, c.id AS card_id\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nJOIN sets s ON c.setCode = s.code\nWHERE fd.language = 'Italian' AND s.block = 'Shadowmoor'\nORDER BY s.code ASC\nLIMIT 2;",
            "SELECT T1.name, T1.id\nFROM sets T1\nJOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Italian' AND T1.block = 'Shadowmoor'\nORDER BY T1.id ASC\nLIMIT 2;"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.id\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.block = 'Shadowmoor'\nAND T2.language = 'Italian'\nORDER BY T1.name ASC\nLIMIT 2"
        ]
    },
    "763": {
        "question": "Indicate the attribute value of superhero Abomination.",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Abomination'",
        "amends": [
            "Do select only `T2.attribute_value` instead of including `a.attribute_name` and `ha.attribute_value`. Do use `INNER JOIN` with `hero_attribute AS T2` instead of joining through both `hero_attribute ha` and `attribute a` tables. Do remove the unnecessary join to the `attribute` table instead of keeping the redundant table reference. Do reference `T2.attribute_value` directly instead of using the `ha` alias. Do use table aliases `T1` and `T2` consistently instead of mixed aliasing. The amended query now correctly retrieves only the attribute values for the specified superhero without the unnecessary attribute name column and extra table join."
        ],
        "rules": [
            "1) When the question asks for the attribute value of a specific superhero: select only T2.attribute_value as the output column. 2) When joining superhero and hero_attribute tables: use INNER JOIN where T1.id = T2.hero_id to link the tables. 3) When filtering for a specific superhero name: use the exact literal 'Abomination' with T1.superhero_name. 4) When the schema uses specific table aliases: use T1 for superhero table and T2 for hero_attribute table consistently. 5) When the question only requires attribute values: do not include attribute names or join to the attribute table. Output columns (ordered): T2.attribute_value"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.attribute_name, ha.attribute_value\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE s.superhero_name = 'Abomination';",
            "SELECT T2.attribute_value\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Abomination'"
        ],
        "rule_sql": [
            "SELECT T2.attribute_value\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Abomination'"
        ]
    },
    "1531": {
        "question": "Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.CustomerID, SUM(T2.Price / T2.Amount), T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.CustomerID = ( SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1 ) GROUP BY T2.CustomerID, T1.Currency",
        "amends": [
            "Do use `SUM(T2.Price / T2.Amount)` instead of calculating `SUM(t.Price) / SUM(t.Amount)` for average price per item. Do join `customers` directly with `transactions_1k` instead of using multiple CTEs. Do filter with `WHERE T2.CustomerID = (subquery)` instead of joining with a customer spending CTE. Do reference `yearmonth` table's `Consumption` column instead of calculating total spending from transactions. Do group by both `T2.CustomerID` and `T1.Currency` instead of just CustomerID. Do remove the ORDER BY and LIMIT from the CTE and place it in a subquery instead. Do select only the necessary columns instead of including total_spending. The amended query now correctly identifies the top customer by consumption from yearmonth and calculates their average price per item with proper currency grouping.",
            "Do use `INNER JOIN` instead of `JOIN` for explicit join clarity. Do correct the join condition to `T1.CustomerID = T2.CustomerID` instead of `T2.CustomerID = T1.CustomerID` to maintain consistent table reference order. Do simplify the subquery by removing the unnecessary `GROUP BY` and `SUM` aggregation, instead using direct `ORDER BY Consumption DESC` to find the top customer. Do adjust the column order in the SELECT list to place the aggregate function `SUM(T2.Price / T2.Amount)` before `T1.Currency` instead of after it with an alias. The amended query now correctly identifies the customer with highest consumption and calculates average price per item, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the top spending customer: identify the customer with the highest consumption value from the yearmonth table using T1.Consumption and keep only the top customer.\n2) When calculating average price per item: compute the sum of (T2.Price divided by T2.Amount) for each transaction rather than dividing the sum of prices by the sum of amounts.\n3) When combining customer and transaction information: link the customers table (T1) with transactions_1k table (T2) where T1.CustomerID = T2.CustomerID using an inner match.\n4) When filtering for the top customer: use a subquery to find the CustomerID with maximum T1.Consumption from yearmonth table and filter transactions with WHERE T2.CustomerID = (subquery result).\n5) When grouping results: group by both T2.CustomerID and T1.Currency to ensure currency information is properly associated with each customer.\n6) When selecting output columns: include only the necessary columns showing customer identification, average price per item, and currency information.\n7) When handling currency information: preserve the exact currency value from T1.Currency column without modification.\nOutput columns (ordered): T2.CustomerID, SUM(T2.Price / T2.Amount) AS avg_price_per_item, T1.Currency",
            "1) When the question asks for the \"top spending customer\": identify the customer with the highest Consumption value from the yearmonth table by ordering by Consumption in descending direction and keeping the first row.\n2) When combining customers T1 and transactions_1k T2 for shared customer entities: link rows where T1.CustomerID = T2.CustomerID exactly; keep only matching pairs (inner match).\n3) When calculating average price per single item purchased: compute the sum of Price divided by Amount for all transactions of the identified customer.\n4) When the question asks about currency used: include the Currency column from the customers table for the identified customer.\n5) Output columns (ordered): T2.CustomerID, SUM(T2.Price / T2.Amount), T1.Currency"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH customer_spending AS (\n    SELECT \n        CustomerID,\n        SUM(Price * Amount) AS total_spending\n    FROM \n        transactions_1k\n    GROUP BY \n        CustomerID\n    ORDER BY \n        total_spending DESC\n    LIMIT 1\n),\naverage_price AS (\n    SELECT \n        t.CustomerID,\n        SUM(t.Price) / SUM(t.Amount) AS avg_price_per_item\n    FROM \n        transactions_1k t\n    JOIN \n        customer_spending cs ON t.CustomerID = cs.CustomerID\n    GROUP BY \n        t.CustomerID\n)\nSELECT \n    c.CustomerID,\n    cs.total_spending,\n    ap.avg_price_per_item,\n    c.Currency\nFROM \n    customer_spending cs\nJOIN \n    average_price ap ON cs.CustomerID = ap.CustomerID\nJOIN \n    customers c ON cs.CustomerID = c.CustomerID;",
            "SELECT \n    T2.CustomerID,\n    T1.Currency,\n    SUM(T2.Price / T2.Amount) AS avg_price_per_item\nFROM \n    transactions_1k T2\nJOIN \n    customers T1 ON T2.CustomerID = T1.CustomerID\nWHERE \n    T2.CustomerID = (\n        SELECT CustomerID \n        FROM yearmonth \n        GROUP BY CustomerID \n        ORDER BY SUM(Consumption) DESC \n        LIMIT 1\n    )\nGROUP BY \n    T2.CustomerID, T1.Currency;",
            "SELECT \n    T2.CustomerID,\n    SUM(T2.Price / T2.Amount) AS avg_price_per_item,\n    T1.Currency\nFROM \n    transactions_1k T2\nINNER JOIN \n    customers T1 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T2.CustomerID = (\n        SELECT CustomerID \n        FROM yearmonth \n        ORDER BY Consumption DESC \n        LIMIT 1\n    )\nGROUP BY \n    T2.CustomerID, T1.Currency;"
        ],
        "rule_sql": [
            "SELECT \n    T2.CustomerID, \n    SUM(T2.Price / T2.Amount) AS avg_price_per_item, \n    T1.Currency\nFROM \n    transactions_1k T2\nINNER JOIN \n    customers T1 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T2.CustomerID = (\n        SELECT CustomerID \n        FROM yearmonth \n        ORDER BY Consumption DESC \n        LIMIT 1\n    )\nGROUP BY \n    T2.CustomerID, T1.Currency"
        ]
    },
    "84": {
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "db_id": "california_schools",
        "ground_truth": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "amends": [
            "Do use a `SELECT DISTINCT` with specific columns `T1.AdmFName1` and `T1.District` instead of aggregating counts across multiple name fields. Do use an `INNER JOIN` with a subquery that selects `admfname1` instead of creating a CTE with `UNION ALL` across multiple name columns. Do have the subquery `GROUP BY admfname1` and `ORDER BY COUNT(admfname1) DESC LIMIT 2` to get the top 2 most frequent first names instead of counting occurrences across all name fields and then limiting. Do join on `T1.AdmFName1 = T2.admfname1` to filter to only those records matching the top names instead of processing all non-null names from three different columns. Do remove the explicit column aliasing and CTE structure instead of preserving them. The amended query now correctly identifies the top 2 most frequent first names from the AdmFName1 field and returns their distinct occurrences with district information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"most common first names among school administrators\": count occurrences of T1.AdmFName1 values and rank them by frequency in descending order.\n2) When the question specifies \"two most common\": keep only the top 2 rows after ranking by frequency count.\n3) When the question asks to \"indicate the district to which they administer\": include T1.District in the output for each matching record.\n4) When filtering to only records with the top names: use an inner match where T1.AdmFName1 equals the top names identified from the frequency analysis.\n5) When handling administrator names: process only the AdmFName1 field, not AdmFName2 or AdmFName3.\n6) When counting frequency: use T1.AdmFName1 as the counting key for determining most common names.\n7) When producing final results: return distinct combinations of first name and district information.\nOutput columns (ordered): T1.AdmFName1, T1.District"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH combined_names AS (\n  SELECT AdmFName1 AS first_name, District FROM schools WHERE AdmFName1 IS NOT NULL\n  UNION ALL\n  SELECT AdmFName2 AS first_name, District FROM schools WHERE AdmFName2 IS NOT NULL\n  UNION ALL\n  SELECT AdmFName3 AS first_name, District FROM schools WHERE AdmFName3 IS NOT NULL\n)\nSELECT first_name, District, COUNT(*) AS name_count\nFROM combined_names\nGROUP BY first_name, District\nORDER BY name_count DESC\nLIMIT 2;",
            "SELECT DISTINCT T1.AdmFName1, T1.District\nFROM schools T1\nINNER JOIN (\n    SELECT admfname1\n    FROM schools\n    WHERE admfname1 IS NOT NULL\n    GROUP BY admfname1\n    ORDER BY COUNT(admfname1) DESC\n    LIMIT 2\n) T2 ON T1.AdmFName1 = T2.admfname1\nWHERE T1.AdmFName1 IS NOT NULL;"
        ],
        "rule_sql": [
            "WITH NameFrequency AS (\n    SELECT \n        AdmFName1,\n        COUNT(*) as frequency\n    FROM schools\n    WHERE AdmFName1 IS NOT NULL AND AdmFName1 != ''\n    GROUP BY AdmFName1\n    ORDER BY frequency DESC\n    LIMIT 2\n)\nSELECT DISTINCT\n    s.AdmFName1,\n    s.District\nFROM schools s\nINNER JOIN NameFrequency nf ON s.AdmFName1 = nf.AdmFName1\nWHERE s.AdmFName1 IS NOT NULL AND s.AdmFName1 != ''\nORDER BY s.AdmFName1, s.District;"
        ]
    },
    "1498": {
        "question": "What is the highest monthly consumption in the year 2012?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUM(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(monthly_consumption) AS highest_monthly_consumption\nFROM (\n    SELECT SUM(Consumption) AS monthly_consumption\n    FROM yearmonth\n    WHERE substr(Date, 1, 4) = '2012'\n    GROUP BY substr(Date, 5, 2)\n);"
        ],
        "rule_sql": []
    },
    "290": {
        "question": "Which toxic element can be found in the molecule TR151?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR151'",
        "amends": [
            "Do remove the `JOIN` with `molecule` table and its `ON a.molecule_id = m.molecule_id` condition instead of keeping the unnecessary join. Do change the `WHERE` filter to directly compare `T.molecule_id = 'TR151'` instead of joining and filtering on `m.label = 'TR151'`. Do remove the `IN` clause filtering elements `('cl', 'br', 'f', 'i', 'pb', 'sn', 'te', 'hg')` instead of keeping the restrictive element filter. Do use table alias `T` instead of `a` for consistency. The amended query now correctly filters atoms by molecule_id directly without the unnecessary join and element restrictions, matching the RIGHT_SQL's behavior.",
            "Do add `DISTINCT` instead of omitting it, and do remove the `IN` filter condition on `element` instead of keeping it, while also adding table alias `T` to the `element` column reference instead of using it unqualified. Do change the `FROM` clause to include table alias `AS T` instead of omitting it. The amended query now correctly returns distinct elements for molecule 'TR151' without the unnecessary element type restrictions."
        ],
        "rules": [
            "1) When the question asks about a specific molecule by identifier: filter the atom table directly using the exact molecule identifier token 'TR151' without joining to other tables. 2) When the question asks for toxic elements in a molecule: do not restrict the element values to a predefined list of toxic elements, as the schema does not indicate which elements are considered toxic. 3) When using table aliases for consistency: use the alias T for the atom table instead of other aliases. 4) When filtering by molecule identifier: use the exact literal value 'TR151' with proper case and formatting. 5) Output columns (ordered): T.element",
            "1) When the question asks for toxic elements in a specific molecule 'TR151': filter rows where T.molecule_id equals 'TR151' exactly. 2) When selecting distinct values of a column: return only unique values of the exact column token T.element. 3) When the question does not specify element type restrictions: do not apply any filter conditions on the element column values. 4) When using table aliases: refer to columns using the alias T as shown in the schema. 5) Output columns (ordered): T.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.element \nFROM atom a \nJOIN molecule m ON a.molecule_id = m.molecule_id \nWHERE m.label = 'TR151' \nAND a.element IN ('cl', 'br', 'f', 'i', 'pb', 'sn', 'te', 'hg');",
            "SELECT element FROM atom WHERE molecule_id = 'TR151' AND element IN ('cl', 'br', 'f', 'i', 'pb', 'sn', 'te', 'hg')",
            "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR151'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.element FROM atom T WHERE T.molecule_id = 'TR151'"
        ]
    },
    "1339": {
        "question": "Calculate the total average cost that Elijah Allen spent in the events on September and October.",
        "db_id": "student_club",
        "ground_truth": "SELECT AVG(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.last_name = 'Allen' AND T1.first_name = 'Elijah' AND (SUBSTR(T2.expense_date, 6, 2) = '09' OR SUBSTR(T2.expense_date, 6, 2) = '10')",
        "amends": [
            "Do reference `T2.cost` directly instead of using an alias like `average_cost`. Do join only `member` and `expense` tables instead of including unnecessary `attendance` and `event` tables. Do use `INNER JOIN` between `member` and `expense` with predicate `T1.member_id = T2.link_to_member` instead of the multi-table join chain. Do filter on `T1.last_name = 'Allen'` and `T1.first_name = 'Elijah'` in the WHERE clause instead of the same conditions. Do apply the month filter on `SUBSTR(T2.expense_date, 6, 2)` for September and October instead of filtering on `SUBSTR(ev.event_date, 6, 2)`. Do remove the unnecessary table aliases and simplify the query structure. The amended query now correctly calculates average expenses for the specified member during September and October months based on expense dates rather than event dates."
        ],
        "rules": [
            "1) When calculating average cost for a specific member: compute the average of T2.cost for rows matching the member criteria. 2) When filtering by member name: apply conditions T1.first_name = 'Elijah' and T1.last_name = 'Allen' to identify the specific member. 3) When filtering by months September and October: check if SUBSTR(T2.expense_date, 6, 2) equals '09' or '10' to select expenses from those months. 4) When combining member and expense tables: link rows where T1.member_id = T2.link_to_member using an inner match to ensure only related records are included. 5) When the question involves member expenses: only join the member and expense tables directly, without including unnecessary attendance or event tables. 6) Output columns (ordered): AVG(T2.cost)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(e.cost) AS average_cost\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event ev ON a.link_to_event = ev.event_id\nWHERE m.first_name = 'Elijah' AND m.last_name = 'Allen'\nAND (SUBSTR(ev.event_date, 6, 2) = '09' OR SUBSTR(ev.event_date, 6, 2) = '10');",
            "SELECT AVG(T2.cost) AS average_cost\nFROM member T1\nINNER JOIN expense T2 ON T1.member_id = T2.link_to_member\nWHERE T1.last_name = 'Allen' \nAND T1.first_name = 'Elijah'\nAND SUBSTR(T2.expense_date, 6, 2) IN ('09', '10')"
        ],
        "rule_sql": [
            "SELECT AVG(T2.cost) \nFROM member T1 \nINNER JOIN expense T2 ON T1.member_id = T2.link_to_member \nWHERE T1.first_name = 'Elijah' \nAND T1.last_name = 'Allen' \nAND (SUBSTR(T2.expense_date, 6, 2) = '09' OR SUBSTR(T2.expense_date, 6, 2) = '10')"
        ]
    },
    "574": {
        "question": "Which user has the website URL listed at 'http://stackoverflow.com'",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com'",
        "amends": [],
        "rules": [
            "\"http://stackoverflow.com\" is the WebsiteUrl; user refers to DisplayName"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com';"
        ],
        "rule_sql": []
    },
    "1075": {
        "question": "List all the football player with the highest balance score and potential score of 61.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = '61' ORDER BY t2.balance DESC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `balance` and `potential`. Do use `INNER JOIN` with table aliases `t1` and `t2` instead of `JOIN` without aliases. Do change the WHERE condition to filter on `potential = '61'` with string comparison instead of numeric `61` and remove the subquery for maximum balance. Do add `ORDER BY balance DESC` and `LIMIT 1` instead of trying to match the maximum balance directly. Do remove the subquery that was incorrectly attempting to find maximum balance across all records. The amended query now correctly finds the player with the highest balance among those with potential '61' instead of potentially returning multiple rows or incorrect results.",
            "Do reference `t1.player_name` instead of `p.player_name` to align with the table alias used in the FROM clause. Do remove the redundant second `INNER JOIN` on `Player_Attributes` instead of keeping the duplicate join that serves no purpose. Do use `t2.potential` in the WHERE clause instead of `t1.potential` since only one Player_Attributes table is now joined. Do maintain the `ORDER BY t2.balance DESC` and `LIMIT 1` as they correctly identify the top record by balance. The amended query now correctly joins Player to Player_Attributes once and filters on potential while ordering by balance to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"football player with the highest balance score and potential score of 61\": filter rows where t2.potential equals '61' exactly as a string literal. 2) When ranking for \"highest balance score\": order rows by t2.balance in descending direction and keep only the first 1 row. 3) When selecting output columns: include only t1.player_name from the result. 4) When combining Player and Player_Attributes tables: link rows where t1.player_api_id equals t2.player_api_id exactly and keep only matching pairs (inner match). 5) Output columns (ordered): t1.player_name",
            "1) When the question asks for football players with a specific potential score: filter rows where the exact token t2.potential equals the literal '61' exactly as specified.\n2) When the question asks for the highest balance score: rank all rows by the exact token t2.balance in descending order and keep only the top 1 row.\n3) When combining Player and Player_Attributes tables: link rows where the canonical keys are equal exactly as t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match).\n4) When choosing output columns: use the exact token t1.player_name from the base table Player (aliased as t1) rather than the joined table.\n5) When handling table joins: use only one join to Player_Attributes instead of redundant duplicate joins to the same table.\nOutput columns (ordered): t1.player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.balance, pa.potential\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.balance = (SELECT MAX(balance) FROM Player_Attributes)\nAND pa.potential = 61;",
            "SELECT p.player_name \nFROM Player p\nINNER JOIN Player_Attributes t1 ON p.player_api_id = t1.player_api_id\nINNER JOIN Player_Attributes t2 ON p.player_api_id = t2.player_api_id\nWHERE t1.potential = '61'\nORDER BY t2.balance DESC\nLIMIT 1;",
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.potential = '61'\nORDER BY t2.balance DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.potential = '61'\nORDER BY t2.balance DESC\nLIMIT 1;"
        ]
    },
    "633": {
        "question": "Which post by slashnick has the most answers count? State the post ID.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.PostId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'slashnick' ORDER BY T3.AnswerCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "most answers count refers to MAX(AnswerCount); post by slashnick refers to DisplayName = 'slashnick';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Id\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'slashnick'\nORDER BY p.AnswerCount DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "784": {
        "question": "Provide the full names of vampire heroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
        "amends": [],
        "rules": [
            "vampire heroes refers to race = 'Vampire';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Vampire';"
        ],
        "rule_sql": []
    },
    "1413": {
        "question": "Mention the zip code of member who incurred less than 50USD.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.zip FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.cost < 50",
        "amends": [],
        "rules": [
            "incurred less than 50USD refers to cost < 50"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.zip\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost < 50;"
        ],
        "rule_sql": []
    },
    "68": {
        "question": "Which county reported the most number of school closure in the 1980s with school wonership code belonging to Youth Authority Facilities (CEA)?",
        "db_id": "california_schools",
        "ground_truth": "SELECT County FROM schools WHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND StatusType = 'Closed' AND SOC = 11 GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1",
        "amends": [
            "Do use `strftime('%Y', ClosedDate)` for year extraction instead of direct date range comparison with `BETWEEN '1980-01-01' AND '1989-12-31'`. Do add filter `StatusType = 'Closed'` instead of omitting it to ensure only closed schools are counted. Do change `SOC = 11` (numeric) instead of `SOC = '11'` (string) to match the correct data type. Do count `COUNT(School)` instead of `COUNT(*)` to specifically count school closures rather than all records. Do order by `COUNT(School) DESC` instead of `NumberOfClosures DESC` since the alias is no longer used. Do remove the alias `AS NumberOfClosures` instead of keeping it as the result set only returns County. The amended query now correctly identifies counties with the most school closures in the 1980s by properly filtering for closed status and using appropriate year extraction and counting methods.",
            "Do remove `COUNT(School)` from the SELECT list instead of including it, as the query only needs to return the County. Do keep the same FROM source `schools` and maintain all WHERE filters including `StatusType = 'Closed'`, `strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989'`, and `SOC = 11` with the same logic. Do preserve the GROUP BY `County` and ORDER BY `COUNT(School) DESC` with LIMIT 1 to find the county with the most closed schools in the 1980s. The amended query now correctly returns only the County column while maintaining the same aggregation and filtering behavior."
        ],
        "rules": [
            "1) When the question asks for school closures in the 1980s: extract the year from ClosedDate using strftime('%Y', ClosedDate) and filter for years between 1980 and 1989 inclusive.\n2) When counting school closures: specifically count the School column instead of all records to ensure only actual school closures are counted.\n3) When filtering for closed schools: include the condition StatusType = 'Closed' to ensure only closed schools are considered.\n4) When filtering by school ownership code: use SOC = 11 (numeric value) instead of string '11' to match the correct data type for Youth Authority Facilities (CEA).\n5) When grouping results by county: organize the results by the County column and compute the count of school closures per county.\n6) When finding the county with the most closures: order the results by the count of School in descending order and take only the top result.\n7) Output columns (ordered): County",
            "1) When the question asks for the county with the most school closures: group results by the exact token \"County\" and count using the canonical key for schools. 2) When filtering for school closure status: include only rows where \"StatusType\" equals exactly 'Closed'. 3) When filtering for the 1980s time period: include only rows where the year portion of \"ClosedDate\" falls between '1980' and '1989' inclusive. 4) When filtering for Youth Authority Facilities ownership: include only rows where \"SOC\" equals exactly 11. 5) When ranking results by count: order groups by the count of schools in descending order and keep only the top result. 6) When the question asks for only the county name: return only the \"County\" column in the output. Output columns (ordered): County"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT County, COUNT(*) AS NumberOfClosures\nFROM schools\nWHERE SOC = '11' AND ClosedDate BETWEEN '1980-01-01' AND '1989-12-31'\nGROUP BY County\nORDER BY NumberOfClosures DESC\nLIMIT 1;",
            "SELECT County, COUNT(School) \nFROM schools \nWHERE StatusType = 'Closed' \nAND strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' \nAND SOC = 11 \nGROUP BY County \nORDER BY COUNT(School) DESC \nLIMIT 1;",
            "SELECT County FROM schools WHERE StatusType = 'Closed' AND strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND SOC = 11 GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT County\nFROM schools\nWHERE StatusType = 'Closed'\nAND strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989'\nAND SOC = 11\nGROUP BY County\nORDER BY COUNT(School) DESC\nLIMIT 1;"
        ]
    },
    "1301": {
        "question": "Please list the IDs of the patients with no thrombosis and an abnormal level of creatinine phosphokinase.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 0 AND T1.CPK < 250",
        "amends": [],
        "rules": [
            "no thrombosis refers to Thrombosis = 0 ; abnormal level of creatinine phosphokinase refers to CPK < 250;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nJOIN Laboratory l ON p.ID = l.ID\nWHERE e.Thrombosis = 0 AND l.CPK < 250;"
        ],
        "rule_sql": []
    },
    "1312": {
        "question": "What's Angela Sanders's major?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "amends": [],
        "rules": [
            "Angela Sanders is the full name; full name refers to first_name, last_name; major refers to major_name."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Angela' AND mb.last_name = 'Sanders';"
        ],
        "rule_sql": []
    },
    "1037": {
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "amends": [
            "Do use `COUNT(t1.id)` instead of `COUNT(DISTINCT p.player_api_id)` to avoid potential double-counting issues. Do cast the left-footed count to `REAL` instead of using integer division that could truncate decimal results. Do use `SUBSTR(t1.birthday, 1, 4)` instead of `strftime('%Y', p.birthday)` for year extraction to maintain compatibility across SQL implementations. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `t1` and `t2` instead of full table names for conciseness. Do remove the unnecessary `ELSE 0` from the CASE statement since counting NULL values achieves the same result more efficiently. Do place the percentage calculation directly in the SELECT list instead of wrapping it in parentheses. The amended query now correctly calculates the percentage of left-footed players born between 1987 and 1992 with proper decimal handling."
        ],
        "rules": [
            "1) When calculating percentages involving player attributes: use COUNT(t1.id) instead of COUNT(DISTINCT player_api_id) to avoid double-counting issues.\n2) When performing division for percentage calculations: cast the numerator to REAL instead of using integer division to prevent decimal truncation.\n3) When extracting year from birthday fields: use SUBSTR(t1.birthday, 1, 4) instead of strftime functions for cross-SQL compatibility.\n4) When joining Player and Player_Attributes tables: use INNER JOIN explicitly for clarity and link rows where t1.player_api_id = t2.player_api_id.\n5) When counting conditional cases: omit ELSE 0 from CASE statements since counting NULL values achieves the same result more efficiently.\n6) When filtering by birth year ranges: use SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992' to select players born between 1987 and 1992.\n7) When checking for left-footed preference: use t2.preferred_foot = 'left' as the condition.\n8) When calculating percentage of players with specific attributes: compute (SUM(CASE WHEN t2.preferred_foot = 'left' THEN 1 END) * 100.0) / COUNT(t1.id).\nOutput columns (ordered): percentage_left_footed"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN pa.preferred_foot = 'left' THEN 1 ELSE 0 END) * 100.0) / COUNT(DISTINCT p.player_api_id) AS percentage_left_footed\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    strftime('%Y', p.birthday) BETWEEN '1987' AND '1992';",
            "SELECT \n    (COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id END) * 100.0 / COUNT(t1.id)) AS percentage_left_footed\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    CAST(SUBSTR(t1.birthday, 1, 4) AS INTEGER) BETWEEN 1987 AND 1992;"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN t2.preferred_foot = 'left' THEN 1 END) * 100.0) / COUNT(t1.id) AS percentage_left_footed\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'"
        ]
    },
    "873": {
        "question": "What is the actual finish time for Bruce McLaren in the race No.743?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.time FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 743 AND T1.forename = 'Bruce' AND T1.surname = 'McLaren'",
        "amends": [],
        "rules": [
            "race number refers to raceId;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.time\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 743 AND d.forename = 'Bruce' AND d.surname = 'McLaren';"
        ],
        "rule_sql": []
    },
    "501": {
        "question": "Which card name in the set 'Journey into Nyx Hero's Path' has the highest converted mana cost.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Journey into Nyx Hero''s Path' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "amends": [],
        "rules": [
            "set 'Journey into Nyx Hero's Path' refers to name = 'Journey into Nyx Hero''s Path'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Journey into Nyx Hero''s Path'\nORDER BY c.convertedManaCost DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "971": {
        "question": "Please state the reference name of the oldest German driver.",
        "db_id": "formula_1",
        "ground_truth": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1",
        "amends": [],
        "rules": [
            "oldest refers to MIN(year(dob)); reference names appear in drverRef."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY dob ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "996": {
        "question": "What is the annual average number of races held during the first 10 years of the 21st century?",
        "db_id": "formula_1",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 FROM races WHERE date BETWEEN '2000-01-01' AND '2010-12-31'",
        "amends": [
            "Do calculate the average using `CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10` instead of `AVG(race_count)` from a subquery. Do remove the subquery structure and `GROUP BY year` instead of keeping them. Do move the year range filter from the subquery's `WHERE` clause to a `CASE` expression in the main query instead of filtering in the subquery. Do handle the division explicitly with `/ 10` instead of relying on `AVG` over grouped counts. The amended query now correctly calculates the average number of races per year between 2000 and 2010 by counting qualifying races and dividing by the 10-year span, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating an annual average over a specific decade range (2000-2010): count races occurring in each year of the decade using a conditional count (CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) instead of grouping by year. 2) When the time period spans exactly 10 years: divide the total count by 10 instead of using AVG over grouped counts. 3) When handling year ranges: use inclusive bounds (BETWEEN 2000 AND 2010) to capture all years in the decade. 4) When performing division for averages: cast the numerator to REAL before division to ensure decimal precision. 5) Output columns (ordered): annual_average_races"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(race_count) AS annual_average_races\nFROM (\n    SELECT year, COUNT(*) AS race_count\n    FROM races\n    WHERE date BETWEEN '2000-01-01' AND '2010-12-31'\n    GROUP BY year\n);",
            "SELECT CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 AS average_races FROM races"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE NULL END) AS REAL) / 10 AS annual_average_races FROM races;"
        ]
    },
    "241": {
        "question": "How many of the molecules are not carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecule WHERE label = '-';"
        ],
        "rule_sql": []
    },
    "304": {
        "question": "List all carcinogenic molecules and their elements.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [
            "Do use `DISTINCT` instead of `GROUP BY` with incomplete column selection. Do select `T1.element` instead of including `m.label` which is already filtered. Do use table aliases `T1` and `T2` consistently instead of mixed naming. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T2.molecule_id` in SELECT instead of `m.molecule_id` for consistency with joined tables. Do remove the unnecessary `GROUP BY` clause entirely instead of keeping it with columns that don't require aggregation. The amended query now correctly returns distinct molecule-element pairs for labeled molecules without redundant grouping.",
            "Do use `T2.label = '+'` instead of `T2.label = 'carcinogenic'` in the WHERE filter. End with confirmation that the amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"carcinogenic molecules and their elements\": select distinct pairs of T2.molecule_id and T1.element from the joined tables. 2) When filtering for labeled molecules: include only rows where T2.label equals '+' exactly. 3) When combining molecule and atom tables: link rows where T2.molecule_id equals T1.molecule_id exactly and keep only matching pairs (inner match). 4) When selecting output columns: use T2.molecule_id and T1.element with their exact identifiers. 5) When handling distinct values: use distinct selection instead of grouping when no aggregation is needed. Output columns (ordered): T2.molecule_id, T1.element",
            "1) When the question asks for carcinogenic molecules: filter rows where T2.label equals '+' exactly. 2) When combining atom and molecule tables: link rows where T1.molecule_id equals T2.molecule_id and keep only matching pairs (inner match). 3) When selecting distinct molecule-element pairs: return unique combinations of T2.molecule_id and T1.element. 4) Output columns (ordered): T2.molecule_id, T1.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.molecule_id, m.label, a.element\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+'\nGROUP BY m.molecule_id, a.element;",
            "SELECT DISTINCT T2.molecule_id, T1.element\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = 'carcinogenic';",
            "SELECT DISTINCT T2.molecule_id, T1.element\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.molecule_id, T1.element\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'"
        ]
    },
    "56": {
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin city?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "amends": [
            "Do count `CDSCode` instead of `*` to exclude null values from the count. Do filter on `City` instead of `MailCity` to use the correct location attribute. Do remove the redundant `MailCity` filter since it's replaced by `City`. Do keep the `MailState` and `StatusType` filters unchanged. The amended query now correctly counts active schools in San Joaquin, California using the appropriate location field and excludes null CDS codes from the count.",
            "Do use the state abbreviation `CA` in the `MailState` filter instead of the full state name `California` to match the correct state code format. Do maintain the same column selection with `COUNT(CDSCode)` and preserve the same table source `schools` and join structure. Do keep the same filter conditions for `City = 'San Joaquin'` and `StatusType = 'Active'` in the WHERE clause, only correcting the state code format. The amended query now correctly filters for California schools using the proper state abbreviation and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting schools: count using the canonical key T1.CDSCode instead of all columns to exclude null values from the count.\n2) When filtering for location by city: use the exact column token T1.City instead of T1.MailCity to use the correct location attribute.\n3) When filtering for mailing state: use the exact column token T1.MailState with the exact literal value 'CA' to match California addresses.\n4) When filtering for school status: use the exact column token T1.StatusType with the exact literal value 'Active' to identify active schools.\n5) When the question asks for schools in a specific city and state: apply both location filters (T1.City = 'San Joaquin' and T1.MailState = 'CA') along with the status filter (T1.StatusType = 'Active').\nOutput columns (ordered): COUNT(T1.CDSCode)",
            "1) When filtering for schools with a mailing state address in California: use the exact literal 'CA' for the MailState column instead of 'California' to match the state code format. 2) When counting schools: use the canonical key CDSCode for counting. 3) When filtering for active schools in San Joaquin city: use the exact literals 'San Joaquin' for the City column and 'Active' for the StatusType column. 4) When selecting from the schools table: use the base table schools as T1. Output columns (ordered): COUNT(CDSCode)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM schools \nWHERE MailState = 'CA' \nAND MailCity = 'San Joaquin' \nAND StatusType = 'Active';",
            "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'California' AND City = 'San Joaquin' AND StatusType = 'Active';",
            "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND City = 'San Joaquin' AND StatusType = 'Active'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.CDSCode) \nFROM schools T1 \nWHERE T1.MailState = 'CA' \nAND T1.City = 'San Joaquin' \nAND T1.StatusType = 'Active'"
        ]
    },
    "1204": {
        "question": "How long did it take after patient number 821298 arrived at the hospital for the first time before her evaluation began?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT STRFTIME('%d', T3.`Examination Date`) - STRFTIME('%d', T1.`First Date`) FROM Patient AS T1 INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.ID = 821298",
        "amends": [
            "Do calculate the day difference using `STRFTIME('%d', date)` subtraction instead of `DATEDIFF` function. Do reference `Patient` as `T1` and `Examination` as `T3` instead of using single-letter aliases. Do use `INNER JOIN` with `T1.ID = T3.ID` instead of `JOIN` with `e.ID = p.ID`. Do filter on `T1.ID = 821298` instead of `e.ID = 821298`. Do omit the column alias `days_to_evaluation` instead of including it. The amended query now correctly calculates the day difference between examination and first dates using SQLite-compatible date functions and proper table references."
        ],
        "rules": [
            "1) When calculating date differences in SQLite: use STRFTIME('%d', date) subtraction instead of DATEDIFF function.\n2) When referencing the Patient table: use alias T1 instead of single-letter aliases.\n3) When referencing the Examination table: use alias T3 instead of single-letter aliases.\n4) When joining Patient and Examination tables: use INNER JOIN with T1.ID = T3.ID instead of simple JOIN.\n5) When filtering for patient number 821298: use T1.ID = 821298 instead of filtering on the examination table ID.\n6) When outputting calculated date differences: omit column aliases instead of including descriptive names like days_to_evaluation.\nOutput columns (ordered): STRFTIME('%d', T3.\"Examination Date\") - STRFTIME('%d', T1.\"First Date\")"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DATEDIFF(`Examination Date`, `First Date`) AS days_to_evaluation\nFROM Examination e\nJOIN Patient p ON e.ID = p.ID\nWHERE e.ID = 821298;",
            "SELECT STRFTIME('%d', T3.\"Examination Date\") - STRFTIME('%d', T1.\"First Date\") \nFROM Patient T1\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T1.ID = 821298"
        ],
        "rule_sql": [
            "SELECT STRFTIME('%d', T3.\"Examination Date\") - STRFTIME('%d', T1.\"First Date\")\nFROM Patient T1\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T1.ID = 821298"
        ]
    },
    "1336": {
        "question": "What department offers the major that Pierce and Guidi took?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.last_name = 'Pierce' OR T1.last_name = 'Guidi'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.department\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.last_name IN ('Pierce', 'Guidi');"
        ],
        "rule_sql": []
    },
    "872": {
        "question": "In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'",
        "amends": [
            "Do use `T2.code` instead of `d.code` for the column alias. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reverse the join condition to `T2.driverId = T1.driverId` instead of `q.driverId = d.driverId`. Do use `LIKE '1:33%'` for pattern matching instead of exact equality `= '0:01:33'` to catch variations in time formatting. Do add table aliases `AS T1` and `AS T2` instead of omitting them. The amended query now correctly identifies qualifying times that start with '1:33' regardless of minor formatting differences, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for a driver's abbreviated code: output the exact column T2.code. 2) When combining qualifying and drivers tables: link rows where T2.driverId equals T1.driverId using an inner match. 3) When filtering for race number 45: include only rows where T1.raceId equals 45. 4) When filtering for Q3 time starting with 1:33: include only rows where T1.q3 starts with '1:33' using pattern matching. 5) When handling time values: use pattern matching with '1:33%' to catch formatting variations instead of exact equality. 6) When using table aliases: refer to qualifying as T1 and drivers as T2 consistently. Output columns (ordered): T2.code"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.code \nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 45 AND q.q3 = '0:01:33';",
            "SELECT T2.code \nFROM qualifying AS T1 \nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 45 \nAND T1.q3 LIKE '1:33%'"
        ],
        "rule_sql": [
            "SELECT T2.code FROM qualifying T1 INNER JOIN drivers T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%';"
        ]
    },
    "1129": {
        "question": "List down the long name for slow speed class team.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Slow'",
        "amends": [],
        "rules": [
            "slow speed class refers to buildUpPlaySpeedClass = 'Slow'; long name refers to team_long_name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_long_name \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE ta.buildUpPlaySpeedClass = 'Slow';"
        ],
        "rule_sql": []
    },
    "1079": {
        "question": "Which player is the tallest?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `height` in the SELECT list. Do use `ORDER BY height DESC LIMIT 1` instead of a subquery with `WHERE height = (SELECT MAX(height) FROM Player)`. Do remove the explicit height column selection and subquery approach instead of keeping them, as the ORDER BY with LIMIT more efficiently retrieves the tallest player without needing to compare against the maximum value. The amended query now correctly returns only the name of the tallest player matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the tallest player: rank rows by height in descending order and keep the first 1 row. 2) When selecting output columns for identifying the tallest player: include only player_name. 3) When ordering by height to find the tallest: use the exact column token height without quotes. 4) When referring to the player table: use the exact table name Player without quotes. 5) Output columns (ordered): player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, height FROM Player WHERE height = (SELECT MAX(height) FROM Player);",
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;"
        ]
    },
    "407": {
        "question": "Lists all types of cards in German.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.subtypes, T1.supertypes FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.subtypes IS NOT NULL AND T1.supertypes IS NOT NULL",
        "amends": [
            "Do select `subtypes` and `supertypes` instead of `types`. Do use `INNER JOIN` instead of `JOIN` while maintaining the same join condition `T1.uuid = T2.uuid`. Do add filter conditions `T1.subtypes IS NOT NULL` and `T1.supertypes IS NOT NULL` instead of only `c.types IS NOT NULL`. Do remove `DISTINCT` instead of keeping it. Do use table aliases `T1` and `T2` instead of `c` and `fd`. The amended query now correctly retrieves both subtypes and supertypes for German language cards while ensuring neither field contains null values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"types of cards in German\": select both subtypes and supertypes instead of only types. 2) When joining cards and foreign_data tables: use an inner match where T1.uuid = T2.uuid. 3) When filtering for German language: use the exact literal 'German' for T2.language. 4) When ensuring non-null values: add separate conditions T1.subtypes IS NOT NULL and T1.supertypes IS NOT NULL. 5) When retrieving multiple columns: do not use DISTINCT to allow all combinations to appear. 6) When using table aliases: refer to cards as T1 and foreign_data as T2. Output columns (ordered): T1.subtypes, T1.supertypes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.types\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'German' AND c.types IS NOT NULL;",
            "SELECT T1.subtypes, T1.supertypes\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T2.language = 'German'\nAND T1.subtypes IS NOT NULL\nAND T1.supertypes IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT T1.subtypes, T1.supertypes \nFROM cards T1 \nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid \nWHERE T2.language = 'German' \nAND T1.subtypes IS NOT NULL \nAND T1.supertypes IS NOT NULL"
        ]
    },
    "425": {
        "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
        "amends": [
            "Do select `id` instead of `number` as the output column. Do use exact equality comparison `subtypes = 'Angel,Wizard'` instead of multiple `LIKE` conditions with wildcards. Do keep the `side IS NULL` filter unchanged. The amended query now correctly identifies cards with the exact 'Angel,Wizard' subtype combination rather than cards containing both Angel and Wizard anywhere in their subtypes, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for card numbers: output the column \"id\" instead of \"number\". 2) When filtering for cards with subtypes Angel and Wizard: use exact equality comparison subtypes = 'Angel,Wizard' instead of multiple LIKE conditions. 3) When filtering for cards without multiple faces: keep the condition side IS NULL unchanged. 4) Output columns (ordered): id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT number FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%';",
            "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL"
        ]
    },
    "348": {
        "question": "Describe the information about rulings for card named 'Sublime Epiphany' with number 74s.",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'",
        "amends": [
            "Do select only `text` instead of both `date` and `text`. Do use `INNER JOIN` instead of `JOIN` (which are equivalent, but explicit). Do reference `T1.name` and `T1.number` instead of `c.name` and `c.number` with different aliases. Do use table aliases `T1` for cards and `T2` for rulings instead of `c` and `r`. The amended query now correctly retrieves only the ruling text for the specified card while maintaining the same join logic and filtering conditions."
        ],
        "rules": [
            "1) When the question asks for information about rulings for a specific card: use table T1 for cards and T2 for rulings with an inner match on T1.uuid = T2.uuid. 2) When filtering for card name 'Sublime Epiphany': use exact literal 'Sublime Epiphany' with T1.name. 3) When filtering for card number '74s': use exact literal '74s' with T1.number. 4) When selecting ruling information: output only the text column from T2. Output columns (ordered): T2.text"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.date, r.text\nFROM rulings r\nJOIN cards c ON r.uuid = c.uuid\nWHERE c.name = 'Sublime Epiphany' AND c.number = '74s';",
            "SELECT T2.text \nFROM cards T1 \nINNER JOIN rulings T2 ON T1.uuid = T2.uuid \nWHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'"
        ],
        "rule_sql": [
            "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'"
        ]
    },
    "840": {
        "question": "List the attribute value of the superhero named Aquababy.",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Aquababy'",
        "amends": [
            "Do select only `T2.attribute_value` instead of including `a.attribute_name` from the SELECT list. Do remove the JOIN to the `attribute` table (aliased as `a`) instead of keeping it, as the attribute values are directly available in the hero_attribute table. Do use `INNER JOIN` with table aliases `T1` for superhero and `T2` for hero_attribute instead of the original JOIN syntax without aliases. Do remove the unnecessary join condition `ha.attribute_id = a.id` instead of including it, since the attribute table is no longer needed. The amended query now correctly retrieves only the attribute values for the specified superhero without requiring the additional attribute table join."
        ],
        "rules": [
            "1) When the question asks for attribute values of a specific superhero: filter rows where T1.superhero_name equals 'Aquababy' exactly. 2) When combining superhero and hero_attribute tables: link rows where T1.id equals T2.hero_id and keep only matching pairs (inner match). 3) When the question specifies retrieving only attribute values: output only T2.attribute_value column. 4) When the attribute table is not needed for the requested information: do not join with the attribute table. 5) Output columns (ordered): T2.attribute_value"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.attribute_name, ha.attribute_value\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE s.superhero_name = 'Aquababy';",
            "SELECT T2.attribute_value\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Aquababy'"
        ],
        "rule_sql": [
            "SELECT ha.attribute_value \nFROM superhero s\nINNER JOIN hero_attribute ha ON s.id = ha.hero_id\nWHERE s.superhero_name = 'Aquababy'"
        ]
    },
    "890": {
        "question": "How many seasons has Silverstone Circuit hosted the United Kindom grand prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T2.circuitid) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit' AND T2.name = 'British Grand Prix'",
        "amends": [],
        "rules": [
            "British Grand Prix is the name of race; British refers to the United Kindom"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT r.year) AS seasons_hosted\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit' AND r.name = 'British Grand Prix';"
        ],
        "rule_sql": []
    },
    "398": {
        "question": "What is the  unconverted mana do all the cards created by Rob Alexander cost in total?",
        "db_id": "card_games",
        "ground_truth": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
        "amends": [
            "Do remove the `SUM` aggregate function and `AS total_unconverted_mana_cost` alias instead of keeping them, and do return the raw `manaCost` values instead of summing them. Do maintain the same `FROM cards` source and `WHERE artist = 'Rob Alexander'` filter without changes. The amended query now returns individual mana cost values rather than an aggregated sum, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for individual mana cost values rather than a sum: return the raw manaCost values without aggregation. 2) When filtering for cards created by Rob Alexander: include only rows where artist equals exactly 'Rob Alexander'. 3) When selecting from the cards table: use the exact table name cards without aliases. 4) Output columns (ordered): manaCost"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(manaCost) AS total_unconverted_mana_cost FROM cards WHERE artist = 'Rob Alexander';",
            "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'"
        ],
        "rule_sql": [
            "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'"
        ]
    },
    "390": {
        "question": "What are the colors of cards from ID 1-20? What are the format of these cards?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.colors, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20",
        "amends": [
            "Do select only `colors` and `format` instead of including `id` in the SELECT list. Do use `INNER JOIN` instead of `LEFT JOIN` for the table relationship. Do reference tables as `T1` and `T2` with explicit aliases instead of simple `c` and `l` aliases. Do join on `T1.uuid = T2.uuid` instead of `c.uuid = l.uuid` while maintaining the same join condition logic. The amended query now correctly performs an inner join between the cards and legalities tables, selecting only the relevant color and format columns for records where the card ID falls within the specified range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for colors and format of cards from ID 1-20: select only T1.colors and T2.format columns, excluding T1.id from the output. 2) When combining cards table (T1) and legalities table (T2): perform an inner join where T1.uuid = T2.uuid to match rows present in both tables. 3) When filtering cards by ID range 1-20: include only rows where T1.id is between 1 and 20 inclusive. 4) When choosing identifier delimiters: use the exact column names as shown in the schema without adding quotes unless specified. 5) When handling table aliases: use T1 for the cards table and T2 for the legalities table as established in the amends. Output columns (ordered): T1.colors, T2.format"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.id, c.colors, l.format FROM cards c LEFT JOIN legalities l ON c.uuid = l.uuid WHERE c.id BETWEEN 1 AND 20;",
            "SELECT T1.colors, T2.format \nFROM cards T1 \nINNER JOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T1.id BETWEEN 1 AND 20"
        ],
        "rule_sql": [
            "SELECT T1.colors, T2.format FROM cards T1 INNER JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20"
        ]
    },
    "1104": {
        "question": "What was the potiential for Francesco Parravicini on 2010/8/30?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2010-08-30' AND t1.player_name = 'Francesco Parravicini'",
        "amends": [],
        "rules": [
            "Francesco Parravicini refers to player_name = 'Francesco Parravicini'; on 2010/8/30 refers to date = '2010-08-30 00:00:00'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pa.potential \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Francesco Parravicini' \nAND pa.date = '2010-08-30 00:00:00';"
        ],
        "rule_sql": []
    },
    "394": {
        "question": "How many white bordered cards are powerful?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "amends": [],
        "rules": [
            "white bordered cards refer to borderColor = 'white'; powerful cards refers to cardKingdomFoilId is not null AND cardKingdomId is not null (replace)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "670": {
        "question": "What is the date when the youngest user made his or her first post?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "amends": [],
        "rules": [
            "the youngest user refers to MIN(Age); first post refers to MIN(CreaionDate);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(p.CreaionDate) AS FirstPostDate\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.Age = (SELECT MIN(Age) FROM users WHERE Age IS NOT NULL);"
        ],
        "rule_sql": []
    },
    "1475": {
        "question": "How many customers in KAM had a consumption of less than 30,000 for the year 2012?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T2.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND SUBSTRING(T2.Date, 1, 4) = '2012' GROUP BY T2.CustomerID HAVING SUM(T2.Consumption) < 30000 ) AS t1",
        "amends": [
            "Do use `COUNT(*)` on the subquery result instead of `COUNT(DISTINCT c.CustomerID)` to count unique customers. Do add table aliases `T1` and `T2` instead of `c` and `ym` for clarity. Do change the date filter to `SUBSTRING(T2.Date, 1, 4) = '2012'` instead of `ym.Date BETWEEN '201201' AND '201212'` to properly extract the year. Do remove the redundant `GROUP BY c.CustomerID` from the outer query instead of keeping it, as the grouping is already handled in the subquery. Do restructure the query with a subquery that selects `CustomerID` instead of directly aggregating in the main query. The amended query now correctly counts customers with consumption below 30000 in 2012, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for customers in a specific segment: filter T1.Segment to exactly match the literal 'KAM'.\n2) When the question specifies a particular year: extract the year portion from T2.Date using the first 4 characters and match exactly to '2012'.\n3) When calculating total consumption for a customer: sum T2.Consumption values for each T1.CustomerID.\n4) When filtering for consumption below a threshold: include only customers where the sum of T2.Consumption is less than 30000.\n5) When counting unique customers: use COUNT(*) on the result set of customers that meet all conditions instead of COUNT(DISTINCT T1.CustomerID).\n6) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match).\n7) When handling grouping: perform grouping by T1.CustomerID in a subquery to calculate per-customer aggregates before filtering.\n8) Output columns (ordered): NumberOfCustomers"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.CustomerID) AS NumberOfCustomers\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Segment = 'KAM'\nAND ym.Date BETWEEN '201201' AND '201212'\nGROUP BY c.CustomerID\nHAVING SUM(ym.Consumption) < 30000;",
            "SELECT COUNT(*) \nFROM (\n    SELECT T1.CustomerID \n    FROM customers T1\n    JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\n    WHERE T1.Segment = 'KAM' \n    AND SUBSTRING(T2.Date, 1, 4) = '2012'\n    GROUP BY T1.CustomerID\n    HAVING SUM(T2.Consumption) < 30000\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS NumberOfCustomers\nFROM (\n    SELECT c.CustomerID\n    FROM customers c\n    INNER JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\n    WHERE c.Segment = 'KAM'\n    AND substr(ym.Date, 1, 4) = '2012'\n    GROUP BY c.CustomerID\n    HAVING SUM(ym.Consumption) < 30000\n) AS subquery"
        ]
    },
    "1060": {
        "question": "How many players were born after 1990?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990'",
        "amends": [],
        "rules": [
            "born after 1990 refers to strftime('%Y', birthday) = '1990';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM Player WHERE strftime('%Y', birthday) > '1990';"
        ],
        "rule_sql": []
    },
    "1410": {
        "question": "List out the full name and total cost that member id \"rec4BLdZHS2Blfp4v\" incurred?",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'",
        "amends": [
            "Do use separate columns `first_name` and `last_name` instead of concatenating them as `full_name`. Do use `INNER JOIN` instead of `LEFT JOIN` to exclude members without expenses. Do remove the `GROUP BY` clause instead of keeping it since the WHERE filter returns only one member. Do omit the alias `total_cost` for the aggregate instead of including it. The amended query now correctly returns the first name, last name, and total expense sum for the specified member while excluding those without expenses."
        ],
        "rules": [
            "1) When the question asks for both first name and last name separately: return \"first_name\" and \"last_name\" as separate columns instead of concatenating them. 2) When joining member and expense tables for a specific member's expenses: use an inner match on \"member_id\" = \"link_to_member\" to exclude members without expenses. 3) When filtering for a specific member with ID \"rec4BLdZHS2Blfp4v\": apply the filter condition directly without grouping since only one member is returned. 4) When calculating total cost for a member: sum the \"cost\" values without assigning an alias to the aggregate result. 5) Output columns (ordered): first_name, last_name, SUM(cost)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, SUM(e.cost) AS total_cost\nFROM member m\nLEFT JOIN expense e ON m.member_id = e.link_to_member\nWHERE m.member_id = 'rec4BLdZHS2Blfp4v'\nGROUP BY m.member_id;",
            "SELECT m.first_name, m.last_name, SUM(e.cost) \nFROM member m\nINNER JOIN expense e ON m.member_id = e.link_to_member\nWHERE m.member_id = 'rec4BLdZHS2Blfp4v'"
        ],
        "rule_sql": [
            "SELECT m.first_name, m.last_name, SUM(e.cost) \nFROM member m\nINNER JOIN expense e ON m.member_id = e.link_to_member\nWHERE m.member_id = 'rec4BLdZHS2Blfp4v'\nGROUP BY m.member_id, m.first_name, m.last_name"
        ]
    },
    "225": {
        "question": "Please list top five molecules that have double bonds in alphabetical order.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id LIMIT 5",
        "amends": [
            "Do select only `T.molecule_id` instead of including `m.label` and remove the alias prefix. Do use `FROM bond AS T` instead of joining with `molecule` table. Do change the filter to `T.bond_type = '='` instead of `' = '` with spaces. Do remove the `ORDER BY m.label ASC` clause instead of keeping it and change to `ORDER BY T.molecule_id` without direction. Do keep `LIMIT 5` and `DISTINCT` as they are correctly preserved. The amended query now correctly focuses on bond table data only without unnecessary molecule table joins and label ordering."
        ],
        "rules": [
            "1) When the question asks for \"top five molecules\": rank rows by the exact token T.molecule_id and keep the first 5 rows.\n2) When the question mentions molecules with \"double bonds\": filter rows where the exact token T.bond_type equals the exact literal '=' (without spaces).\n3) When the question asks for results in \"alphabetical order\": order results by the exact token T.molecule_id.\n4) When the question asks for distinct molecules: compute unique values of the exact token T.molecule_id.\n5) When the schema requires working with bond data: use FROM bond AS T instead of joining with molecule table.\n6) Output columns (ordered): T.molecule_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = ' = '\nORDER BY m.label ASC\nLIMIT 5;",
            "SELECT DISTINCT molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY molecule_id LIMIT 5"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.molecule_id\nFROM bond AS T\nWHERE T.bond_type = '='\nORDER BY T.molecule_id\nLIMIT 5"
        ]
    },
    "195": {
        "question": "What is the most common bond type?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.bond_type FROM ( SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do select only `T.bond_type` in the outer query instead of including both `bond_type` and `COUNT(bond_type)`. Do count `bond_id` instead of `bond_type` in the subquery's aggregation. Do use a subquery with alias `AS T` to wrap the aggregation instead of querying the table directly. Do order by `COUNT(bond_id)` instead of the alias `count` in the subquery. The amended query now correctly identifies the bond_type with the highest count of bond_id records rather than counting bond_type values themselves."
        ],
        "rules": [
            "1) When counting entities from the bond table: use bond_id as the counting key instead of bond_type to count individual bond records. 2) When finding the most common value of a categorical column like bond_type: count occurrences using the table's primary key (bond_id) and identify the value with the highest count. 3) When ordering by aggregate results: order by the actual aggregate expression (COUNT(bond_id)) rather than an alias assigned to that aggregate. 4) When selecting only the categorical value with the highest frequency: include only the categorical column (bond_type) in the final output, not both the categorical column and the count. 5) When performing aggregation and filtering for maximum value: use a subquery approach to first compute counts and then select the top result. Output columns (ordered): T.bond_type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type, COUNT(bond_type) AS count FROM bond GROUP BY bond_type ORDER BY count DESC LIMIT 1;",
            "SELECT T.bond_type FROM (SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1) AS T"
        ],
        "rule_sql": [
            "SELECT bond_type FROM (\n    SELECT bond_type, COUNT(bond_id) as count_bonds\n    FROM bond\n    GROUP BY bond_type\n    ORDER BY COUNT(bond_id) DESC\n    LIMIT 1\n) T"
        ]
    },
    "360": {
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "db_id": "card_games",
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "amends": [
            "Do remove the `DISTINCT` keyword instead of keeping it. Do change the SELECT list to only `language` instead of `st.language`. Do remove the `FROM cards c` table and `JOIN sets s ON c.setCode = s.code` join instead of including them. Do change the FROM clause to only `set_translations` instead of multiple joined tables. Do replace the WHERE condition with a subquery `WHERE id IN (SELECT id FROM cards WHERE name = 'Angel of Mercy')` instead of directly filtering on `c.name = 'Angel of Mercy'` through table joins. The amended query now correctly retrieves languages by finding card IDs first through a subquery rather than attempting to join through multiple tables that may not have the necessary relationships."
        ],
        "rules": [
            "1) When the question asks for languages available for a set containing a specific card: first identify the card ID using the exact card name literal 'Angel of Mercy' from the cards table. 2) When retrieving languages from set_translations: use the card ID obtained from the subquery to filter the set_translations table where id matches the card ID from the subquery. 3) When selecting output columns: return only the language column without any DISTINCT modifier. 4) When handling text literals: preserve the exact case and spacing of 'Angel of Mercy' as specified in the question. Output columns (ordered): language"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT st.language\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode\nWHERE c.name = 'Angel of Mercy';",
            "SELECT language FROM set_translations WHERE id IN (SELECT id FROM cards WHERE name = 'Angel of Mercy')"
        ],
        "rule_sql": [
            "SELECT language FROM set_translations WHERE setCode = (SELECT setCode FROM cards WHERE name = 'Angel of Mercy')"
        ]
    },
    "1456": {
        "question": "List the full name of the top five members who spend the most money in the descending order of spending.",
        "db_id": "student_club",
        "ground_truth": "SELECT T3.first_name, T3.last_name FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id ORDER BY T2.spent DESC LIMIT 5",
        "amends": [
            "Do select `first_name` and `last_name` as separate columns instead of concatenating them as `full_name`, and do remove the `SUM(e.cost)` aggregation instead of including it. Do change the FROM clause to use `expense AS T1` as the primary source instead of `member m`, and do add `INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id` instead of omitting the budget table join. Do keep `INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id` but change the alias from `m` to `T3` instead of using `m`. Do remove the GROUP BY clause entirely instead of grouping by `m.member_id`. Do change the ORDER BY to use `T2.spent DESC` instead of `total_spending DESC`, and do keep the `LIMIT 5` unchanged. The amended query now correctly joins the expense, budget, and member tables to retrieve members ordered by budget spending rather than calculating total expense costs."
        ],
        "rules": [
            "1) When the question asks for \"top five members\" who spend the most money: rank rows by T2.spent in descending order and keep the first 5 rows.\n2) When selecting member names: output T3.first_name and T3.last_name as separate columns instead of concatenating them.\n3) When combining expense, budget, and member tables: link rows where T1.link_to_budget = T2.budget_id and T1.link_to_member = T3.member_id using inner matches only.\n4) When ordering by spending: use T2.spent column for ordering instead of calculating aggregate sums.\n5) When the question does not require aggregation: do not include GROUP BY clauses or SUM() calculations.\n6) When using table aliases: use T1 for expense table, T2 for budget table, and T3 for member table as specified in the amends.\nOutput columns (ordered): T3.first_name, T3.last_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, SUM(e.cost) AS total_spending\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nGROUP BY m.member_id\nORDER BY total_spending DESC\nLIMIT 5;",
            "SELECT T3.first_name, T3.last_name\nFROM expense AS T1\nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\nINNER JOIN member AS T3 ON T1.link_to_member = T3.member_id\nORDER BY T2.spent DESC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT T3.first_name, T3.last_name\nFROM expense T1\nINNER JOIN budget T2 ON T1.link_to_budget = T2.budget_id\nINNER JOIN member T3 ON T1.link_to_member = T3.member_id\nORDER BY T2.spent DESC\nLIMIT 5"
        ]
    },
    "786": {
        "question": "How many heroes have the highest attribute value in strength?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )",
        "amends": [],
        "rules": [
            "highest attribute value in strength refers to MAX(attribute_value) WHERE attribute_name = 'Strength';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH strength_attribute AS (\n    SELECT id FROM attribute WHERE attribute_name = 'Strength'\n),\nmax_strength AS (\n    SELECT MAX(attribute_value) AS max_value\n    FROM hero_attribute\n    WHERE attribute_id = (SELECT id FROM strength_attribute)\n)\nSELECT COUNT(DISTINCT hero_id) AS hero_count\nFROM hero_attribute\nWHERE attribute_id = (SELECT id FROM strength_attribute)\nAND attribute_value = (SELECT max_value FROM max_strength);"
        ],
        "rule_sql": []
    },
    "1132": {
        "question": "Please provide the names of top three football players who are over 180 cm tall in alphabetical order.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name LIMIT 3",
        "amends": [],
        "rules": [
            "over 180 cm tall refers to height > 180; name of football player refers to player_name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name ASC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "509": {
        "question": "What is the unique id of the set that has the highest number of cards?",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM sets ORDER BY baseSetSize DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the highest number of cards refers to MAX(baseSetSize); unique id refers to id"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.id\nFROM sets s\nJOIN (\n    SELECT setCode, COUNT(*) AS card_count\n    FROM cards\n    GROUP BY setCode\n) c ON s.code = c.setCode\nORDER BY c.card_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "642": {
        "question": "How many posts were created on 21st July, 2010?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do query from `postHistory` table instead of `posts` to access the correct data source. Do use `date(CreationDate) = '2010-07-21'` instead of `BETWEEN '2010-07-21 00:00:00' AND '2010-07-21 23:59:59'` for more precise date filtering that handles timezone considerations properly. The amended query now correctly counts post history entries from the specified date."
        ],
        "rules": [
            "1) When counting entities from the postHistory table: count using the canonical key \"id\" instead of counting all columns to avoid including NULL values.\n2) When the question asks about posts created on a specific date: query from the \"postHistory\" table instead of the \"posts\" table to access the correct data source.\n3) When filtering for a specific date like '2010-07-21': use exact date equality (date(CreationDate) = '2010-07-21') instead of time range filtering to handle timezone considerations properly.\n4) When the question asks for count of posts created on a specific date: compute the number of rows using the \"id\" column from the \"postHistory\" table where the date portion of \"CreationDate\" equals exactly '2010-07-21'.\nOutput columns (ordered): count of post history entries"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE CreationDate BETWEEN '2010-07-21 00:00:00' AND '2010-07-21 23:59:59';",
            "SELECT COUNT(Id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) AS count_of_post_history_entries FROM postHistory WHERE date(CreationDate) = '2010-07-21'"
        ]
    },
    "1438": {
        "question": "Please indicate the college of the person whose first name is Katy with the link to the major \"rec1N0upiVLy5esTO\".",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.link_to_major = 'rec1N0upiVLy5esTO' AND T1.first_name = 'Katy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.college\nFROM member AS mem\nJOIN major AS m ON mem.link_to_major = m.major_id\nWHERE mem.first_name = 'Katy' AND mem.link_to_major = 'rec1N0upiVLy5esTO';"
        ],
        "rule_sql": []
    },
    "1489": {
        "question": "How much did the KAM customers consume in total in May 2013?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUM(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201305' AND T1.Segment = 'KAM'",
        "amends": [],
        "rules": [
            "May 2013 refers to yearmonth.date = 201305"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(y.Consumption) AS TotalConsumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'KAM' AND y.Date = '201305';"
        ],
        "rule_sql": []
    },
    "1173": {
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "amends": [
            "Do join `Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID` instead of querying only `Examination` table. Do reference `T2.Diagnosis` instead of `Diagnosis` directly from Examination. Do group by `T2.Diagnosis` instead of grouping by Diagnosis without table qualification. Do order by `COUNT(T2.Diagnosis)` instead of ordering by the alias `DiagnosisCount`. The amended query now correctly joins the Patient table to access the Diagnosis field and properly qualifies all column references, matching the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(T2.Diagnosis) AS DiagnosisCount` column from the SELECT list instead of including it. Do remove the `INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID` join and its associated table instead of keeping it. Do change the WHERE filter to use `T1.Examination Date BETWEEN '1985-01-01' AND '1995-12-31'` instead of `T3.Date BETWEEN '1985-01-01' AND '1995-12-31'`. The amended query now correctly filters by examination dates from the Examination table rather than incorrectly joining and filtering by laboratory dates, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question involves patients and their examinations: combine the Examination table (T1) and Patient table (T2) by matching rows where T1.ID equals T2.ID, keeping only matching pairs.\n2) When filtering by examination date range: include only rows where T1.\"Examination Date\" falls between '1985-01-01' and '1995-12-31' inclusive.\n3) When counting occurrences of illnesses: count the number of rows using T2.Diagnosis as the counting entity.\n4) When grouping by illness type: organize results by the exact values of T2.Diagnosis.\n5) When finding the most common illness: rank the groups by count of T2.Diagnosis in descending order and keep only the top result.\n6) When producing output: show the illness name and its count in the results.\nOutput columns (ordered): T2.Diagnosis, COUNT(T2.Diagnosis)",
            "1) When the question asks for the most common illness: rank rows by count of T2.Diagnosis in descending order and keep the first 1 row.\n2) When the question mentions patients whose lab work was done between 1/1/1985 and 12/31/1995: filter rows where T1.\"Examination Date\" is between '1985-01-01' and '1995-12-31' inclusive.\n3) When combining Examination and Patient tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n4) When counting occurrences of illness: compute the number of rows using T2.Diagnosis as the counting key.\n5) When grouping by diagnosis: organize results by T2.Diagnosis and compute requested aggregates per group.\n6) Output columns (ordered): T2.Diagnosis"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Diagnosis, COUNT(Diagnosis) AS DiagnosisCount\nFROM Examination\nWHERE `Examination Date` BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY Diagnosis\nORDER BY DiagnosisCount DESC\nLIMIT 1;",
            "SELECT T2.Diagnosis, COUNT(T2.Diagnosis) AS DiagnosisCount\nFROM Examination AS T1\nINNER JOIN Patient AS T2 ON T1.ID = T2.ID\nINNER JOIN Laboratory AS T3 ON T1.ID = T3.ID\nWHERE T3.Date BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.Diagnosis\nORDER BY COUNT(T2.Diagnosis) DESC\nLIMIT 1;",
            "SELECT T2.Diagnosis\nFROM Examination AS T1\nINNER JOIN Patient AS T2 ON T1.ID = T2.ID\nWHERE T1.\"Examination Date\" BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.Diagnosis\nORDER BY COUNT(T2.Diagnosis) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Diagnosis, COUNT(T2.Diagnosis) AS count_diagnosis\nFROM Examination T1\nINNER JOIN Patient T2 ON T1.ID = T2.ID\nWHERE T1.\"Examination Date\" BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.Diagnosis\nORDER BY count_diagnosis DESC\nLIMIT 1;"
        ]
    },
    "359": {
        "question": "What is the type of the card \"Ancestor's Chosen\" as originally printed?",
        "db_id": "card_games",
        "ground_truth": "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL",
        "amends": [
            "Do add `AND originalType IS NOT NULL` filter instead of omitting it to exclude null values from the results. Do use single quotes with proper escaping `'Ancestor''s Chosen'` instead of double quotes `\"Ancestor's Chosen\"` for string literals to maintain SQL standard compliance. The amended query now correctly filters out null originalType values while maintaining the same name matching logic."
        ],
        "rules": [
            "1) When the question asks for the type of a specific card by name: filter rows where the name column exactly matches the literal value 'Ancestor''s Chosen' with proper single quotes and escaping. 2) When retrieving the originalType column: ensure the originalType value is not null by adding a filter for originalType IS NOT NULL. 3) Output columns (ordered): originalType"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT originalType FROM cards WHERE name = \"Ancestor's Chosen\";",
            "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL"
        ]
    },
    "78": {
        "question": "What is the most common type of grade span served in the city of Adelanto?",
        "db_id": "california_schools",
        "ground_truth": "SELECT GSserved FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1",
        "amends": [
            "Do select only `GSserved` instead of selecting both `GSserved` and `COUNT(*) as count`. Do remove the alias `count` from the SELECT list instead of keeping it. Do change the ORDER BY clause to use `COUNT(GSserved)` instead of the alias `count`. Do remove the explicit column reference in the ORDER BY clause instead of using the alias. The amended query now correctly returns only the GSserved value with the highest count for Adelanto city instead of returning both the value and its count."
        ],
        "rules": [
            "1) When the question asks for the most common type of a specific column in a specific city: filter rows where the exact literal \"Adelanto\" matches the City column. 2) When grouping by a categorical column like GSserved to find the most common value: organize results by the exact GSserved column. 3) When determining the most common value by count: compute the number of occurrences using the exact GSserved column as the counting key. 4) When ranking to find the single most common value: order results by the count of GSserved in descending order and keep only the first row. 5) When outputting only the most common value: return only the GSserved column value without the count. Output columns (ordered): schools.GSserved"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT GSserved, COUNT(*) as count\nFROM schools\nWHERE City = 'Adelanto'\nGROUP BY GSserved\nORDER BY count DESC\nLIMIT 1;",
            "SELECT GSserved FROM schools WHERE City = 'Adelanto' AND GSserved IS NOT NULL GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT schools.GSserved\nFROM schools\nWHERE schools.City = 'Adelanto'\nGROUP BY schools.GSserved\nORDER BY COUNT(schools.GSserved) DESC\nLIMIT 1;"
        ]
    },
    "1095": {
        "question": "How much is the average build up play speed of the Heart of Midlothian team?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Heart of Midlothian'",
        "amends": [],
        "rules": [
            "Heart of Midlothian refers to team_long_name = 'Heart of Midlothian'; average build up play speed refers to\u00a0 AVG(buildUpPlaySpeed)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(buildUpPlaySpeed) AS average_build_up_play_speed\nFROM Team_Attributes\nJOIN Team ON Team_Attributes.team_api_id = Team.team_api_id\nWHERE Team.team_long_name = 'Heart of Midlothian';"
        ],
        "rule_sql": []
    },
    "811": {
        "question": "Give the alignment and superpowers of the superhero named Atom IV.",
        "db_id": "superhero",
        "ground_truth": "SELECT T4.alignment, T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN alignment AS T4 ON T1.alignment_id = T4.id WHERE T1.superhero_name = 'Atom IV'",
        "amends": [],
        "rules": [
            "superpowers refers to power_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.alignment, GROUP_CONCAT(sp.power_name, ', ') AS superpowers\nFROM superhero sh\nJOIN alignment a ON sh.alignment_id = a.id\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Atom IV'\nGROUP BY a.alignment;"
        ],
        "rule_sql": []
    },
    "904": {
        "question": "State the race and year of race in which Michael Schumacher had his fastest lap.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' ORDER BY T2.milliseconds ASC LIMIT 1",
        "amends": [
            "Do use `lapTimes` table instead of `results` table for joining with `drivers` and `races`. Do change the join condition to `T2.raceId = T1.raceId` instead of `res.raceId = r.raceId`. Do use `T3.driverId = T2.driverId` instead of `res.driverId = d.driverId` for the driver join. Do remove the subquery approach for finding minimum milliseconds instead of using it. Do add `ORDER BY T2.milliseconds ASC LIMIT 1` instead of the subquery filter to get the fastest lap. Do change the column aliases to simple `name` and `year` instead of `race_name` and `race_year`. The amended query now correctly identifies Michael Schumacher's fastest lap by ordering lap times and limiting to one result instead of using a potentially incorrect subquery approach."
        ],
        "rules": [
            "1) When the question asks about Michael Schumacher's fastest lap: use the lapTimes table (T2) instead of results table for lap time data.\n2) When joining lapTimes with races: link rows where T2.raceId = T1.raceId exactly.\n3) When joining lapTimes with drivers: link rows where T3.driverId = T2.driverId exactly.\n4) When filtering for Michael Schumacher: use T3.forename = 'Michael' AND T3.surname = 'Schumacher' exactly.\n5) When finding the fastest lap: order rows by T2.milliseconds in ascending order and keep only the first row.\n6) When outputting race information: include T1.name and T1.year as the result columns.\nOutput columns (ordered): T1.name, T1.year"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name AS race_name, r.year AS race_year\nFROM results res\nJOIN drivers d ON res.driverId = d.driverId\nJOIN races r ON res.raceId = r.raceId\nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher'\nAND res.milliseconds = (SELECT MIN(milliseconds) FROM results WHERE driverId = d.driverId);",
            "SELECT r.name, r.year \nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nJOIN races r ON lt.raceId = r.raceId\nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher'\nORDER BY lt.milliseconds ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.year\nFROM races T1\nJOIN lapTimes T2 ON T2.raceId = T1.raceId\nJOIN drivers T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher'\nORDER BY T2.milliseconds ASC\nLIMIT 1;"
        ]
    },
    "190": {
        "question": "How many clients who were born in 1920 stay in east Bohemia?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.birth_date) = '1920' AND T2.A3 = 'east Bohemia'",
        "amends": [],
        "rules": [
            "East Bohemia appears in the column A3, which refers to the region."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE strftime('%Y', c.birth_date) = '1920' \nAND d.A3 = 'east Bohemia';"
        ],
        "rule_sql": []
    },
    "222": {
        "question": "What is the difference between the number of molecules that are carcinogenic and those that are not?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar FROM molecule t",
        "amends": [],
        "rules": [
            "label = '+' means molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; difference = SUBTRACT(SUM(label = '+'), SUM(label = '-'))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN label = '-' THEN 1 ELSE 0 END)) AS difference FROM molecule;"
        ],
        "rule_sql": []
    },
    "250": {
        "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do use `T1.bond_type = '='` instead of `b.bond_type = ' = '` to remove the extra spaces around the equals sign. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do alias tables as `T1` and `T3` instead of `b` and `m` for consistency. Do wrap the entire query in a subquery `T` instead of selecting directly from the main query. Do order by `COUNT(T1.bond_type)` instead of `double_bond_count` to reference the aggregate function directly. Do select only `molecule_id` in the outer query instead of including both `molecule_id` and `double_bond_count`. The amended query now correctly matches the behavior of counting double bonds with proper equality comparison and returns only the molecule_id with the highest count.",
            "Do filter on `T3.label = '+'` instead of `m.label = 'carcinogenic'` in the WHERE clause. Do reference the subquery alias as `T` instead of omitting it in the outer SELECT. Do use table alias `T3` for molecule table instead of `m` in the subquery. Do remove the column alias `AS double_bond_count` instead of keeping it. The amended query now correctly filters for molecules with '+' label and returns the molecule_id with the highest count of double bonds from the subquery."
        ],
        "rules": [
            "1) When the question asks for carcinogenic molecules: filter T3.label to exactly '+'.\n2) When counting double bonds: count T1.bond_type where T1.bond_type equals exactly '=' (without spaces).\n3) When combining molecule and bond tables: link rows where T3.molecule_id equals T1.molecule_id using inner match.\n4) When grouping by molecule: organize results by T3.molecule_id and compute aggregates per molecule.\n5) When finding the molecule with the most double bonds: rank molecules by count of double bonds in descending order and keep the first 1 row.\n6) When selecting output: return only T3.molecule_id for the top molecule.\nOutput columns (ordered): T3.molecule_id",
            "1) When the question asks for carcinogenic molecules: filter molecules where T3.label equals '+' exactly. 2) When counting double bonds: count occurrences where T1.bond_type equals '=' exactly. 3) When finding the molecule with the most double bonds: rank molecules by the count of double bonds in descending order and keep only the top 1 row. 4) When combining molecule and bond tables: link rows where T3.molecule_id equals T1.molecule_id exactly. 5) When producing final output: return only the molecule_id column from the top-ranked result. 6) Output columns (ordered): T.molecule_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.molecule_id, COUNT(b.bond_id) AS double_bond_count\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE m.label = '+' AND b.bond_type = ' = '\nGROUP BY m.molecule_id\nORDER BY double_bond_count DESC\nLIMIT 1;",
            "SELECT molecule_id FROM (\n    SELECT m.molecule_id, COUNT(T1.bond_type) AS double_bond_count\n    FROM molecule m\n    INNER JOIN bond T1 ON m.molecule_id = T1.molecule_id\n    WHERE m.label = 'carcinogenic' AND T1.bond_type = '='\n    GROUP BY m.molecule_id\n    ORDER BY COUNT(T1.bond_type) DESC\n    LIMIT 1\n) T",
            "SELECT T.molecule_id\nFROM (\n    SELECT T3.molecule_id, COUNT(T1.bond_type) \n    FROM bond T1\n    INNER JOIN molecule T3 ON T1.molecule_id = T3.molecule_id\n    WHERE T3.label = '+' AND T1.bond_type = '='\n    GROUP BY T3.molecule_id\n    ORDER BY COUNT(T1.bond_type) DESC\n    LIMIT 1\n) T"
        ],
        "rule_sql": [
            "SELECT T3.molecule_id\nFROM molecule T3\nINNER JOIN bond T1 ON T3.molecule_id = T1.molecule_id\nWHERE T3.label = '+'\nAND T1.bond_type = '='\nGROUP BY T3.molecule_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "970": {
        "question": "List out top 3 German drivers who were born from 1980-1990 and have the earliest lap time.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990' ORDER BY T1.time LIMIT 3",
        "amends": [
            "Do select only `T2.driverId` instead of including `d.forename`, `d.surname`, and `MIN(l.time)` with an alias. Do use `pitStops AS T1` as the primary table instead of `drivers d` and change to `INNER JOIN drivers AS T2` instead of `JOIN lapTimes l`. Do remove the `GROUP BY` clause entirely instead of grouping by driver details. Do order by `T1.time` directly instead of ordering by the aggregated `earliest_lap_time`. Do maintain the same `WHERE` filter on `nationality` and `dob` year range but reference `T2` instead of `d`. The amended query now correctly finds German drivers born between 1980-1990 with pit stop times instead of lap times, ordering by individual pit stop time rather than minimum lap time, and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"top 3\" German drivers: rank rows by T1.time in ascending order and keep the first 3 rows.\n2) When the question mentions drivers born from 1980-1990: filter T2.dob to include only years between 1980 and 1990 inclusive.\n3) When the question specifies German nationality: filter T2.nationality to exactly match 'German'.\n4) When combining pitStops as T1 and drivers as T2: link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match).\n5) When ordering by earliest lap time: sort by T1.time directly in ascending order instead of using aggregated minimum values.\n6) When selecting output columns: include only T2.driverId instead of additional driver details or aggregated values.\n7) Output columns (ordered): T2.driverId"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverId, d.forename, d.surname, MIN(l.time) AS earliest_lap_time\nFROM drivers d\nJOIN lapTimes l ON d.driverId = l.driverId\nWHERE d.nationality = 'German' AND strftime('%Y', d.dob) BETWEEN '1980' AND '1990'\nGROUP BY d.driverId, d.forename, d.surname\nORDER BY earliest_lap_time ASC\nLIMIT 3;",
            "SELECT T2.driverId \nFROM pitStops AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T2.nationality = 'German' \nAND strftime('%Y', T2.dob) BETWEEN '1980' AND '1990' \nORDER BY T1.time \nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T2.driverId\nFROM pitStops T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German'\nAND T2.dob BETWEEN '1980-01-01' AND '1990-12-31'\nORDER BY T1.time ASC\nLIMIT 3"
        ]
    },
    "77": {
        "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
        "amends": [
            "Do use `T2.School` instead of `School Name` and calculate `FRPM Count (Ages 5-17)` * 100 / `Enrollment (Ages 5-17)` instead of dividing first then multiplying by 100. Do add `INNER JOIN schools AS T2` on `T1.CDSCode = T2.CDSCode` instead of querying only the frpm table. Do use `T2.County = 'Los Angeles'` instead of `County Name = 'Los Angeles'` and `T2.GSserved = 'K-9'` instead of separate `Low Grade = 'K'` and `High Grade = '9'` conditions. Do remove the column alias `Percent Eligible FRPM (Ages 5-17)` instead of keeping it. The amended query now correctly joins the schools table for accurate school information and uses the proper grade range filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for schools in Los Angeles county: filter rows where T2.County equals 'Los Angeles' exactly.\n2) When the question asks for schools serving Kindergarten to 9th grade: filter rows where T2.GSserved equals 'K-9' exactly.\n3) When combining frpm and schools tables: link rows where T1.CDSCode equals T2.CDSCode and keep only matching pairs (inner match).\n4) When calculating Percent (%) Eligible FRPM (Ages 5-17): compute (T1.\"FRPM Count (Ages 5-17)\" * 100) divided by T1.\"Enrollment (Ages 5-17)\" without adding a column alias.\n5) When selecting output columns: include T2.School and the calculated percentage value without naming it.\nOutput columns (ordered): T2.School, (T1.\"FRPM Count (Ages 5-17)\" * 100 / T1.\"Enrollment (Ages 5-17)\")"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    `School Name`,\n    (`FRPM Count (Ages 5-17)` / `Enrollment (Ages 5-17)` * 100) AS `Percent Eligible FRPM (Ages 5-17)`\nFROM \n    frpm\nWHERE \n    `County Name` = 'Los Angeles'\n    AND `Low Grade` = 'K'\n    AND `High Grade` = '9';",
            "SELECT T2.School, (T1.\"FRPM Count (Ages 5-17)\" * 100 / T1.\"Enrollment (Ages 5-17)\") \nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'"
        ],
        "rule_sql": [
            "SELECT T2.School, (T1.\"FRPM Count (Ages 5-17)\" * 100 / T1.\"Enrollment (Ages 5-17)\") \nFROM frpm T1 \nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.County = 'Los Angeles' \nAND T2.GSserved = 'K-9'"
        ]
    },
    "492": {
        "question": "For the set \"From the Vault: Lore\", what is its expansion type?",
        "db_id": "card_games",
        "ground_truth": "SELECT type FROM sets WHERE name LIKE '%FROM the Vault: Lore%'",
        "amends": [],
        "rules": [
            "set \"From the Vault refers to name which contains 'From the Vault: Lore'; expansion type refers to type"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type FROM sets WHERE name = 'From the Vault: Lore';"
        ],
        "rule_sql": []
    },
    "924": {
        "question": "Please list the exact dates on which a Formula_1 race took place on the Barcelona-Catalunya circuit.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "amends": [
            "Do use `T2.date` instead of `r.date` for the SELECT list. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId` for the join condition. Do filter on `T1.name = 'Circuit de Barcelona-Catalunya'` instead of `c.name = 'Barcelona-Catalunya'` in the WHERE clause. Do use table aliases `T1` and `T2` consistently instead of `c` and `r`. The amended query now correctly matches the RIGHT_SQL's behavior by using the full circuit name and proper table aliases."
        ],
        "rules": [
            "1) When the question asks for race dates on a specific circuit: filter T1.name to exactly 'Circuit de Barcelona-Catalunya' (case-sensitive with exact spacing and punctuation). 2) When combining the circuits table (T1) and races table (T2): link rows where T1.circuitId equals T2.circuitID exactly (note the case difference: circuitId vs circuitID). 3) When selecting output columns: use T2.date as the output column. 4) When performing table joins: use INNER JOIN to ensure only matching pairs from both tables are included. 5) When using table aliases: consistently use T1 for the circuits table and T2 for the races table throughout the query. Output columns (ordered): T2.date"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.date\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Barcelona-Catalunya';\n",
            "SELECT T2.date \nFROM circuits T1 \nINNER JOIN races T2 ON T2.circuitId = T1.circuitId \nWHERE T1.name = 'Circuit de Barcelona-Catalunya'"
        ],
        "rule_sql": [
            "SELECT T2.date FROM circuits T1 INNER JOIN races T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'"
        ]
    },
    "47": {
        "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
        "db_id": "california_schools",
        "ground_truth": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
        "amends": [],
        "rules": [
            "Elementary School District refers to DOC = 52; Monthly average number of schools that opened in 1980 = count(schools that opened in 1980) / 12"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) / 12.0 AS monthly_average\nFROM schools\nWHERE County = 'Alameda'\n  AND DOC = '52'\n  AND strftime('%Y', OpenDate) = '1980';"
        ],
        "rule_sql": []
    },
    "1509": {
        "question": "Among the transactions made in the gas stations in the Czech Republic, how many of them are taken place after 2012/1/1?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND STRFTIME('%Y', T1.Date) >= '2012'",
        "amends": [],
        "rules": [
            "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NumberOfTransactions\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE' AND t.Date > '2012-01-01';"
        ],
        "rule_sql": []
    },
    "793": {
        "question": "Among the superheroes with the race of god/eternal, how many of them are male",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(*) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T1.race_id = 21 AND T1.gender_id = 1",
        "amends": [],
        "rules": [
            "race \"god/eternal\" refers to race_id = 21; male refers to gender.id = 1"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superhero WHERE race_id = 21 AND gender_id = 1;"
        ],
        "rule_sql": []
    },
    "372": {
        "question": "How many cards are there with toughness of 99?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE toughness = 99",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE toughness = '99';"
        ],
        "rule_sql": []
    },
    "1182": {
        "question": "For the patient who first came to the hospital on 1991/6/13 who was diagnosed with SJS, what is the total number of his/her Laboratory tests in 1995?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(*) FROM Laboratory WHERE ID = ( SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS' ) AND STRFTIME('%Y', Date) = '1995'",
        "amends": [],
        "rules": [
            "1991/6/13 refers to `First Date` = '1991-06-13'; 'SJS' refers to Diagnosis; total number of his/her Laboratory tests refers to COUNT(ID); 1995 refers to Date"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS TotalLabTestsIn1995\nFROM Laboratory\nWHERE ID = (SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS')\nAND strftime('%Y', Date) = '1995';"
        ],
        "rule_sql": []
    },
    "216": {
        "question": "Identify all connected atoms with a triple bond.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select only `atom_id` and `atom_id2` instead of including `bond_id` in the SELECT list. Do use `INNER JOIN` with table aliases `T1` for `bond` and `T2` for `connected` instead of joining without aliases. Do join on `T1.bond_id = T2.bond_id` instead of `c.bond_id = b.bond_id`. Do filter on `T1.bond_type = '#'` instead of `b.bond_type = '#'`. The amended query now correctly retrieves only the atom identifiers from connected bonds of type '#' without redundant bond_id output."
        ],
        "rules": [
            "1) When selecting columns from the connected table: output only T2.atom_id and T2.atom_id2, not bond_id.\n2) When joining bond and connected tables: use table aliases T1 for bond and T2 for connected.\n3) When combining bond and connected tables: link rows where T1.bond_id = T2.bond_id using inner match.\n4) When filtering for triple bonds: include only rows where T1.bond_type = '#' exactly.\nOutput columns (ordered): T2.atom_id, T2.atom_id2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.atom_id, c.atom_id2, c.bond_id\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '#';",
            "SELECT T2.atom_id, T2.atom_id2 FROM bond T1 INNER JOIN connected T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2\nFROM bond T1\nINNER JOIN connected T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '#'"
        ]
    },
    "1038": {
        "question": "List the top 5 leagues in ascending order of the number of goals made in all seasons combined.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.name, SUM(t2.home_team_goal) + SUM(t2.away_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id GROUP BY t1.name ORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC LIMIT 5",
        "amends": [],
        "rules": [
            "number of goals made in all seasons combine = SUM(home_team_goal, away_team_goal);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.name AS league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM Match m\nJOIN League l ON m.league_id = l.id\nGROUP BY m.league_id\nORDER BY total_goals ASC\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "842": {
        "question": "Calculate the average height of all neutral superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(s.height_cm) AS average_height\nFROM superhero s\nJOIN alignment a ON s.alignment_id = a.id\nWHERE a.alignment = 'Neutral' AND s.height_cm IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "942": {
        "question": "What is the average fastest lap time in seconds for Lewis Hamilton in all the Formula_1 races?",
        "db_id": "formula_1",
        "ground_truth": "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.surname = 'Hamilton' AND T1.forename = 'Lewis'",
        "amends": [
            "Do use `INNER JOIN` instead of multiple explicit joins, and reference `T2.fastestLapTime` directly instead of through a CTE. Do parse the time format dynamically using `INSTR` to locate the colon position instead of fixed substring positions, which handles variable-length minute components. Do remove the CTE wrapper and move the filtering directly into the main query's `WHERE` clause instead of separating it. Do simplify the time conversion by combining seconds and milliseconds in a single `CAST` operation instead of separate conversions. Do eliminate the explicit `races` table join since it's not needed for the calculation. The amended query now correctly handles variable time formats and produces the same average fastest lap time calculation."
        ],
        "rules": [
            "1) When the question asks for average fastest lap time for a specific driver: filter rows where T1.forename equals 'Lewis' and T1.surname equals 'Hamilton' and T2.fastestLapTime is not null.\n2) When parsing time format with variable-length components: use INSTR to dynamically locate the colon position instead of fixed substring positions.\n3) When converting time format to seconds: combine seconds and milliseconds in a single CAST operation instead of separate conversions.\n4) When joining driver and result tables: use INNER JOIN where T1.driverId equals T2.driverId.\n5) When calculating average: compute the average of the converted fastest lap time in seconds.\n6) When the schema shows unnecessary tables: eliminate joins to tables not needed for the calculation (such as races table).\n7) Output columns (ordered): average_fastest_lap_seconds"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH hamilton_races AS (\n    SELECT d.driverId, r.raceId, res.fastestLapTime\n    FROM drivers d\n    JOIN results res ON d.driverId = res.driverId\n    JOIN races r ON res.raceId = r.raceId\n    WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\n    AND res.fastestLapTime IS NOT NULL\n)\nSELECT AVG(\n    CAST(SUBSTR(fastestLapTime, 1, 2) AS INTEGER) * 60 + -- minutes to seconds\n    CAST(SUBSTR(fastestLapTime, 4, 2) AS INTEGER) + -- seconds\n    CAST(SUBSTR(fastestLapTime, 7, 3) AS REAL) / 1000 -- milliseconds to seconds\n) AS average_fastest_lap_seconds\nFROM hamilton_races;",
            "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS REAL) * 60 + \n       CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) AS avg_fastest_lap_seconds\nFROM results T2\nINNER JOIN drivers T1 ON T2.driverId = T1.driverId\nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS REAL) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) AS average_fastest_lap_seconds\nFROM drivers T1\nINNER JOIN results T2 ON T1.driverId = T2.driverId\nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL"
        ]
    },
    "823": {
        "question": "How many female superheroes are in Marvel Comics?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.gender = 'Female'",
        "amends": [],
        "rules": [
            "female refers to gender = 'Female'; Marvel Comics refers to publisher_name = 'Marvel Comics';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female') \nAND publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');"
        ],
        "rule_sql": []
    },
    "41": {
        "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
        "db_id": "california_schools",
        "ground_truth": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
        "amends": [
            "Do use `T2.School` and `T1.AvgScrRead` in the SELECT list instead of including `County` and omitting the rank column from the final output. Do use an `INNER JOIN` on `T1.cds = T2.CDSCode` instead of joining on `s.CDSCode = sc.cds`. Do apply the `Virtual = 'F'` filter directly in the WHERE clause instead of placing it in the CTE. Do reference the rank column as `rnk` in the final WHERE filter instead of `rank_in_county`. Do remove the explicit ORDER BY clause with `County, rank_in_county` instead of keeping it. Do structure the query as a subquery instead of using a CTE. The amended query now correctly returns only the top 5 schools per county by reading scores without including county information or unnecessary ordering in the final output.",
            "Do select only `School` instead of including multiple columns in the outer query. Do use `RANK()` instead of `ROW_NUMBER()` for ranking to handle ties properly. Do partition by `T2.County` instead of `cname` to group schools by county rather than by an unspecified column. Do move the `rnk <= 5` filter to the outer WHERE clause instead of keeping it in the inner query's WHERE clause. Do remove the unnecessary `ORDER BY` clause at the end since ranking is already handled by the window function. Do add the join condition `T1.cds = T2.CDSCode` directly in the main query instead of using a subquery structure. The amended query now correctly identifies top 5 schools per county based on average SAT reading scores instead of using an unclear grouping column and properly handles ranking with ties.",
            "Do include `T1.AvgScrRead` and `rnk` in the SELECT list of the subquery instead of omitting them, and do move the `RANK()` window function to the main query's subquery instead of using a nested subquery. Do remove the redundant `AND T1.AvgScrRead IS NOT NULL` filter from the outer WHERE clause instead of keeping it, as the window function already handles NULL values appropriately. Do eliminate the unnecessary IN subquery with its own join operation instead of maintaining the nested structure, and do simplify the query to a single subquery with window function and filtering instead of the complex nested approach. Do ensure the window function partitions by `T2.County` and orders by `T1.AvgScrRead DESC` directly in the main subquery instead of through multiple layers. The amended query now correctly identifies top schools by reading scores per county with proper window function implementation and eliminates redundant operations.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and `>=` comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of including it in both main and subquery. Do restructure with a derived table `ranked_schools` containing the rank calculation instead of using a subquery in the WHERE clause. Do simplify the SELECT list to only `School` instead of including additional columns in the output. Do remove the explicit ORDER BY clause from the outer query since ranking already handles the ordering logic. The amended query now correctly identifies top 5 schools per county using proper ranking semantics instead of potentially incorrect count-based logic that could produce duplicate rankings.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and `>=` comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of keeping it in both the main query and subquery. Do restructure the query with a derived table `ranked_schools` containing the rank calculation instead of using a complex WHERE clause with subquery. Do simplify the SELECT list to only include `School` instead of the original projection. Do remove the explicit `ORDER BY` clause since ranking handles the ordering internally instead of maintaining it at the end. The amended query now correctly identifies the top 5 schools per county using proper ranking semantics instead of the potentially incorrect count-based approach that could miss ties or handle ranking improperly.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and `>=` comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of keeping it in both main and subquery. Do restructure the query with a derived table `ranked_schools` instead of using a complex WHERE clause with subquery. Do simplify the SELECT list to only `School` instead of including `T2.School` with table prefix. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` clause since ranking handles the ordering logic internally. The amended query now correctly identifies top 5 schools per county using proper ranking semantics instead of the flawed count-based approach that could produce incorrect results with duplicate scores.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top schools. Do move the `AvgScrRead IS NOT NULL` filter from the `WHERE` clause to the ranking logic instead of filtering before ranking. Do restructure the query with a subquery to filter by `rnk <= 5` instead of using a complex subquery condition. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` from the outer query since the ranking already handles the ordering. The amended query now correctly identifies the top 5 schools per county using proper window function ranking instead of the inefficient and potentially incorrect correlated subquery approach.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top schools. Do include `T1.AvgScrRead` in the SELECT list instead of omitting it to enable ranking. Do wrap the query in a derived table `ranked_schools` instead of using a subquery in the WHERE clause. Do filter with `rnk <= 5` in the outer query instead of using a complex subquery condition. Do remove the explicit `IS NOT NULL` check on `AvgScrRead` instead of keeping it since the ranking naturally handles NULL values. Do simplify the ORDER BY clause by removing it from the main query instead of including it since the ranking already orders the results. The amended query now correctly identifies the top 5 schools per county using efficient window functions instead of expensive correlated subqueries.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top schools. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of keeping it in both the main query and subquery. Do restructure the query with a derived table `ranked_schools` containing the rank calculation instead of using a complex correlated subquery. Do filter on `rnk <= 5` in the outer WHERE clause instead of using a subquery with inequality comparison. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` from the main query since the ranking already handles the ordering logic internally. The amended query now correctly identifies the top 5 schools per county using proper window function ranking instead of the inefficient and potentially incorrect correlated subquery approach.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and comparison. Do move the ranking logic to a derived table instead of keeping it in the `WHERE` clause. Do remove the redundant `T1.AvgScrRead IS NOT NULL` filter since the window function handles null values appropriately. Do simplify the query structure by eliminating the duplicate join condition `T4.Virtual = 'F'` from the subquery. Do change the output to select only `School` from the ranked results instead of including `T2.School` directly. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` since the ranking already orders by county and score. The amended query now correctly identifies the top 5 schools per county by average reading score using proper window function semantics instead of error-prone correlated subquery counting.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of applying it in both main and subquery. Do restructure the query with a derived table `ranked_schools` instead of using a complex WHERE clause with subquery. Do simplify the SELECT list to only `School` instead of including additional columns. Do remove the explicit ORDER BY clause at the end instead of keeping it since ranking handles the ordering. The amended query now correctly identifies top 5 schools per county using proper ranking semantics instead of potentially incorrect count-based logic.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and comparison. Do move the `AvgScrRead IS NOT NULL` filter to the ranking logic instead of explicit null checks. Do restructure the query with a derived table `ranked_schools` instead of the original flat structure. Do simplify the final selection to only `School` instead of including additional columns. Do remove the explicit `ORDER BY` clause from the outer query instead of keeping it since ranking handles ordering. The amended query now correctly identifies top 5 schools per county using proper ranking semantics instead of potentially incorrect count-based filtering.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top schools. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of including it in both the main query and subquery. Do restructure the query with a derived table `ranked_schools` instead of using a complex WHERE clause with subquery. Do remove the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` from the outer query since ranking already handles the ordering logic internally. Do simplify the final SELECT to only include `School` instead of the full `T2.School` reference. The amended query now correctly identifies the top 5 schools per county using proper ranking semantics instead of the potentially incorrect count-based approach.",
            "Do use a window function `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` to identify top 5 schools per county. Do remove the `T1.AvgScrRead IS NOT NULL` filter from the WHERE clause instead of keeping it, as window functions handle NULL values appropriately. Do restructure the query with a derived table `ranked_schools` instead of using a complex subquery in the WHERE condition. Do simplify the final SELECT to only include `School` instead of selecting multiple columns. Do eliminate the explicit `ORDER BY T2.County, T1.AvgScrRead DESC` clause instead of keeping it, as the ranking already provides the necessary ordering. The amended query now correctly identifies the top 5 schools per county based on average reading scores using efficient window functions rather than expensive correlated subqueries.",
            "Do use a window function with `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` instead of a correlated subquery with `COUNT(*)` and comparison. Do move the `AvgScrRead IS NOT NULL` filter to the outer query instead of applying it in both the main query and subquery. Do restructure the query with a derived table `ranked_schools` containing the rank calculation instead of using a complex WHERE clause with subquery. Do simplify the SELECT clause to only include `School` instead of the full `T2.School` reference. Do remove the explicit ORDER BY clause at the end since ranking already handles the ordering logic internally. The amended query now correctly identifies the top 5 schools per county by average reading score using proper window function ranking instead of the inefficient and potentially incorrect correlated subquery approach."
        ],
        "rules": [
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county by T1.AvgScrRead in descending order and keep the first 5 rows per county.\n2) When the question specifies \"virtual schools\": filter for schools where T2.Virtual equals exactly 'F'.\n3) When combining schools and SAT scores tables: link rows where T1.cds equals T2.CDSCode exactly and keep only matching pairs (inner match).\n4) When the question asks for school names: include T2.School in the output columns.\n5) When ranking requires tie-breaking: use the canonical key T2.CDSCode if needed to break ties in reading scores.\n6) When producing final output: do not include county information or ranking columns in the output.\n7) Output columns (ordered): T2.School, T1.AvgScrRead",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools by T1.AvgScrRead in descending order and keep the first 5 rows per county, handling ties with RANK() instead of ROW_NUMBER().\n2) When grouping schools by county: organize results by T2.County instead of cname to ensure proper county-based grouping.\n3) When filtering for virtual schools: include only rows where T2.Virtual = 'F' to identify virtual schools.\n4) When combining SAT scores and schools data: link rows where T1.cds = T2.CDSCode using inner match to ensure only matching school records are included.\n5) When the question asks for school names: output only the T2.School column as the final result.\n6) When handling ranking filters: apply the rnk <= 5 condition in the outer WHERE clause rather than in subqueries.\n7) Output columns (ordered): T2.School",
            "1) When the question asks for \"top 5\" schools based on average reading scores per county: rank schools by T1.AvgScrRead in descending order within each T2.County group and keep the first 5 rows per county.\n2) When the question specifies \"virtual schools\": include only rows where T2.Virtual equals 'T' instead of 'F'.\n3) When computing rankings per county: partition the ranking window function by T2.County and order by T1.AvgScrRead DESC.\n4) When combining tables schools and satscores: link rows where T1.cds equals T2.CDSCode and keep only matching pairs (inner match).\n5) When selecting output columns: include only T2.School in the final result set.\n6) When handling NULL values in ranking: do not apply redundant IS NOT NULL filters on T1.AvgScrRead since the window function handles NULL values appropriately.\n7) Output columns (ordered): T2.School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep only the top 5 ranked schools per county.\n2) When identifying virtual schools: filter to include only schools where T2.Virtual equals 'F' exactly.\n3) When calculating rankings: use window function partitioning by T2.County and ordering by T1.AvgScrRead DESC to assign ranks within each county group.\n4) When handling null values: exclude rows where T1.AvgScrRead is null before performing ranking calculations.\n5) When combining schools and satscores tables: link rows where T1.cds equals T2.CDSCode exactly and keep only matching pairs (inner join).\n6) When the question asks for school names: output only the T2.School column in the final result.\n7) When ranking produces ties: use the window function ranking method that properly handles duplicate values instead of count-based logic that could produce incorrect rankings.\nOutput columns (ordered): T2.School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep the top 5 ranked schools per county.\n2) When combining schools and satscores tables: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match).\n3) When filtering for virtual schools: include only rows where T2.Virtual = 'F'.\n4) When handling null values for reading scores: exclude rows where T1.AvgScrRead IS NOT NULL.\n5) When ranking schools within counties: use RANK() window function partitioned by T2.County and ordered by T1.AvgScrRead DESC.\n6) When selecting output columns: include only T2.School.\n7) When the question asks for schools \"in their respective counties\": organize results by county groups using T2.County as the partitioning key.\nOutput columns (ordered): T2.School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep the first 5 rows per county.\n2) When combining schools and satscores tables: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match).\n3) When filtering for virtual schools: include only rows where T2.Virtual = 'F' exactly as specified.\n4) When handling null values for reading scores: exclude rows where T1.AvgScrRead IS NOT NULL.\n5) When ranking schools within counties: use RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) to properly handle ties and ensure correct top 5 selection.\n6) When selecting output columns: return only the School column without table prefix.\nOutput columns (ordered): School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep only the top 5 ranked schools per county.\n2) When identifying virtual schools: filter to include only schools where T2.Virtual equals 'T' (not 'F').\n3) When handling null values in ranking: include only rows where T1.AvgScrRead is not null in the ranking calculation.\n4) When combining tables schools and satscores: link rows where T1.cds equals T2.CDSCode and keep only matching pairs (inner match).\n5) When organizing results by county: partition the ranking by T2.County to compute ranks within each county separately.\n6) When the question asks for school names: output T2.School as the result.\n7) Output columns (ordered): T2.School",
            "1) When the question asks for top K schools per county based on reading scores: use window ranking partitioned by T2.County and ordered by T1.AvgScrRead descending to assign ranks within each county.\n2) When identifying virtual schools: filter for rows where T2.Virtual equals 'T' instead of 'F' to select virtual schools only.\n3) When selecting top 5 per county: keep only rows where the rank is less than or equal to 5.\n4) When outputting school names: include T2.School in the result columns.\n5) When handling average reading scores: include T1.AvgScrRead in the output to enable ranking verification.\n6) When combining schools and satscores tables: link rows where T1.cds equals T2.CDSCode to match school records with their test scores.\n7) When ranking schools: do not explicitly check for NULL values in T1.AvgScrRead as the ranking function naturally handles them.\n8) Output columns (ordered): T2.School, T1.AvgScrRead",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep only the top 5 ranked schools per county.\n2) When combining schools and satscores tables: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match).\n3) When filtering for virtual schools: include only rows where T2.Virtual = 'F'.\n4) When handling null values for reading scores: exclude rows where T1.AvgScrRead IS NOT NULL.\n5) When ranking schools within counties: use RANK() window function partitioned by T2.County and ordered by T1.AvgScrRead DESC.\n6) When selecting output columns: return only T2.School for the final result.\nOutput columns (ordered): T2.School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep the first 5 rows per county.\n2) When the question specifies \"virtual schools\": filter to include only rows where T2.Virtual equals 'F' exactly.\n3) When combining tables schools and satscores: link rows where T1.cds equals T2.CDSCode exactly and keep only matching pairs (inner match).\n4) When ranking within partitions: use T2.County as the partition key and T1.AvgScrRead DESC as the ordering criteria.\n5) When handling null values in ranking: do not explicitly filter out null AvgScrRead values as the window function handles them appropriately.\n6) When producing output: select only the School column from the ranked results.\n7) Output columns (ordered): T2.School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep the first 5 rows per county.\n2) When the question specifies \"virtual schools\": filter to include only rows where T2.Virtual equals 'T' (not 'F').\n3) When handling null values for reading scores: exclude rows where T1.AvgScrRead is null in the main query.\n4) When combining tables schools and satscores: link rows where T1.cds equals T2.CDSCode and keep only matching pairs.\n5) When ranking within partitions: use T2.County as the partition key for the ranking operation.\n6) When the question asks for school names: output only the T2.School column.\n7) When breaking ranking ties: use the canonical key T1.cds or T2.CDSCode if needed for deterministic ordering.\nOutput columns (ordered): T2.School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep the first 5 rows per county.\n2) When the question specifies \"virtual schools\": filter to include only rows where T2.Virtual equals 'T' (not 'F').\n3) When ranking schools by average reading scores: exclude rows where T1.AvgScrRead is null from the ranking calculation.\n4) When combining schools and satscores tables: link rows where T1.cds equals T2.CDSCode and keep only matching pairs (inner match).\n5) When organizing results by county: partition the ranking by T2.County to rank schools within each county separately.\n6) Output columns (ordered): T2.School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep only the top 5 ranked schools per county.\n2) When combining tables schools and satscores: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match).\n3) When filtering for virtual schools: include only rows where T2.Virtual = 'F' exactly as specified.\n4) When handling null values in reading scores: exclude rows where T1.AvgScrRead IS NOT NULL.\n5) When ranking schools within counties: use RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) to assign ranks.\n6) When selecting output columns: return only the School column from the schools table.\n7) When the question specifies \"virtual schools\": ensure the condition T2.Virtual = 'F' is applied to identify virtual schools.\n8) When organizing results by county: partition the ranking by T2.County to get rankings within each county separately.\nOutput columns (ordered): School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep only the top 5 ranks per county.\n2) When identifying virtual schools: filter for schools where T2.Virtual equals 'F' exactly.\n3) When combining schools and satscores tables: link rows where T1.cds equals T2.CDSCode exactly and keep only matching pairs (inner match).\n4) When computing rankings per county: partition the ranking by T2.County and order by T1.AvgScrRead in descending direction.\n5) When handling NULL values in ranking: do not filter out NULL values from T1.AvgScrRead as window functions handle them appropriately.\n6) When producing final output: select only T2.School column for the result.\n7) When ordering results: do not add explicit ordering as the ranking already provides the necessary ordering by county and reading score.\nOutput columns (ordered): T2.School",
            "1) When the question asks for \"top 5\" schools per county based on average reading scores: rank schools within each county using T1.AvgScrRead in descending order and keep only the top 5 ranked schools per county.\n2) When identifying virtual schools: filter to include only schools where T2.Virtual equals 'F' exactly.\n3) When computing rankings: use window function partitioning by T2.County and ordering by T1.AvgScrRead DESC to assign ranks within each county group.\n4) When handling null values: exclude rows where T1.AvgScrRead is null from the ranking calculation.\n5) When combining schools and satscores tables: link rows where T1.cds equals T2.CDSCode exactly and keep only matching pairs (inner join).\n6) When producing output: include only the School column from the schools table.\n7) Output columns (ordered): School"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH RankedSchools AS (\n    SELECT \n        s.School,\n        s.County,\n        sc.AvgScrRead,\n        RANK() OVER (PARTITION BY s.County ORDER BY sc.AvgScrRead DESC) AS rank_in_county\n    FROM \n        schools s\n    JOIN \n        satscores sc ON s.CDSCode = sc.cds\n    WHERE \n        s.Virtual = 'F'\n)\nSELECT \n    School,\n    County,\n    AvgScrRead\nFROM \n    RankedSchools\nWHERE \n    rank_in_county <= 5\nORDER BY \n    County, rank_in_county;",
            "SELECT T2.School\nFROM (\n    SELECT \n        cds,\n        AvgScrRead,\n        cname,\n        ROW_NUMBER() OVER (PARTITION BY cname ORDER BY AvgScrRead DESC) as rnk\n    FROM satscores\n    WHERE rtype = 'S'\n) T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F' AND T1.rnk <= 5\nORDER BY T1.cname, T1.rnk",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND T1.cds IN (\n    SELECT cds\n    FROM (\n        SELECT cds, \n               RANK() OVER (PARTITION BY T2.County ORDER BY AvgScrRead DESC) as rnk\n        FROM satscores\n        INNER JOIN schools ON satscores.cds = schools.CDSCode\n        WHERE schools.Virtual = 'F'\n          AND AvgScrRead IS NOT NULL\n    ) ranked\n    WHERE rnk <= 5\n  )",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC;",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC;",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC;",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n      SELECT COUNT(*) \n      FROM satscores T3 \n      INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n      WHERE T4.County = T2.County \n        AND T3.AvgScrRead >= T1.AvgScrRead\n        AND T4.Virtual = 'F'\n        AND T3.AvgScrRead IS NOT NULL\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*)\n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead >= T1.AvgScrRead\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead >= T1.AvgScrRead\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T4.Virtual = 'F'\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\n  AND (\n    SELECT COUNT(*) \n    FROM satscores T3\n    INNER JOIN schools T4 ON T3.cds = T4.CDSCode\n    WHERE T4.County = T2.County\n      AND T3.AvgScrRead IS NOT NULL\n      AND T3.AvgScrRead >= T1.AvgScrRead\n  ) <= 5\nORDER BY T2.County, T1.AvgScrRead DESC",
            "SELECT School\nFROM (\n    SELECT \n        T2.School,\n        T1.AvgScrRead,\n        RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk\n    FROM satscores T1\n    INNER JOIN schools T2 ON T1.cds = T2.CDSCode\n    WHERE T2.Virtual = 'F'\n) ranked_schools\nWHERE rnk <= 5"
        ],
        "rule_sql": [
            "SELECT T2.School\nFROM satscores T1\nJOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Virtual = 'F'\n  AND T1.AvgScrRead IS NOT NULL\nQUALIFY RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) <= 5"
        ]
    },
    "1440": {
        "question": "List emails of people who paid more than 20 dollars from 9/10/2019 to 11/19/2019.",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T1.email FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE date(SUBSTR(T2.expense_date, 1, 10)) BETWEEN '2019-09-10' AND '2019-11-19' AND T2.cost > 20",
        "amends": [],
        "rules": [
            "expense_date BETWEEN '2019-09-10' and '2019-11-19'; cost > 20"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.email\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost > 20\nAND e.expense_date BETWEEN '2019-09-10' AND '2019-11-19';"
        ],
        "rule_sql": []
    },
    "1216": {
        "question": "Sort in descending order all patients by birthday for male patient with albumin not within range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5) ORDER BY T1.Birthday DESC",
        "amends": [
            "Do select only `DISTINCT T1.ID` instead of `P.ID, P.Birthday, L.ALB` to return unique patient IDs rather than detailed records. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T2.ALB` in the WHERE condition instead of `L.ALB` to match the table alias change. The amended query now correctly returns distinct patient IDs with abnormal albumin levels while maintaining the same filtering logic and sorting by birthday descending.",
            "Do use `SEX = 'M'` instead of `SEX = 'male'` for the gender filter. Do add the condition `(T2.ALB <= 3.5 OR T2.ALB >= 5.5)` instead of just checking `ALB IS NOT NULL`. Do remove the unnecessary table aliases `AS` from the `FROM` clause while keeping the same join logic. The amended query now correctly filters for male patients with abnormal albumin values rather than just non-null values, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks to sort patients by birthday in descending order: order the results by T1.Birthday in descending order.\n2) When filtering for male patients: include only rows where T1.SEX equals exactly 'M'.\n3) When filtering for albumin not within range: include only rows where T2.ALB is less than or equal to 3.5 or T2.ALB is greater than or equal to 5.5.\n4) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match).\n5) When the question asks for distinct patients: return only unique values of T1.ID.\nOutput columns (ordered): T1.ID",
            "1) When filtering for male patients: use T1.SEX = 'M' as the gender condition, not 'male'.\n2) When checking for albumin not within range: use the condition (T2.ALB <= 3.5 OR T2.ALB >= 5.5) to identify abnormal values instead of checking for non-null values.\n3) When joining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n4) When sorting patients by birthday: order by T1.Birthday in descending order.\n5) When selecting output columns: include T1.ID to identify patients.\nOutput columns (ordered): T1.ID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, P.Birthday, L.ALB\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND (L.ALB <= 3.5 OR L.ALB >= 5.5)\nORDER BY P.Birthday DESC;",
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'male' AND T2.ALB IS NOT NULL\nORDER BY T1.Birthday DESC;",
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' \nAND (T2.ALB <= 3.5 OR T2.ALB >= 5.5)\nORDER BY T1.Birthday DESC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND (T2.ALB <= 3.5 OR T2.ALB >= 5.5)\nORDER BY T1.Birthday DESC;"
        ]
    },
    "0": {
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "db_id": "california_schools",
        "ground_truth": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(`Percent (%) Eligible Free (K-12)`) AS HighestEligibleFreeRate\nFROM frpm\nWHERE `County Name` = 'Alameda';"
        ],
        "rule_sql": []
    },
    "1029": {
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4",
        "amends": [
            "Do reference `buildUpPlaySpeed` from the `Team_Attributes` table instead of selecting `team_long_name` from the `Team` table. Do use `INNER JOIN` instead of `JOIN` while maintaining the same join condition `team_api_id = team_api_id`. Do order by `buildUpPlaySpeed` in ascending order instead of descending order. Do use table aliases `t1` and `t2` instead of `ta` and `t` respectively. The amended query now correctly returns only the buildUpPlaySpeed values in ascending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"top 4 teams with the highest build Up Play Speed\": rank rows by T2.buildUpPlaySpeed in descending order and keep the first 4 rows.\n2) When combining T1 and T2 for shared entities: link rows where T1.team_api_id = T2.team_api_id exactly as shown in the amends; keep only matching pairs (inner match).\n3) When the question asks for \"speed in which attacks are put together\": select the exact column T2.buildUpPlaySpeed.\n4) When ordering results: sort by T2.buildUpPlaySpeed in ascending order instead of descending order as specified in the amends.\n5) When using table aliases: use T1 for Team table and T2 for Team_Attributes table as established in the amends.\nOutput columns (ordered): T2.buildUpPlaySpeed"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.team_long_name, ta.buildUpPlaySpeed\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nORDER BY ta.buildUpPlaySpeed DESC\nLIMIT 4;",
            "SELECT t1.buildUpPlaySpeed \nFROM Team_Attributes t1 \nINNER JOIN Team t2 ON t1.team_api_id = t2.team_api_id \nORDER BY t1.buildUpPlaySpeed ASC \nLIMIT 4"
        ],
        "rule_sql": [
            "SELECT T2.buildUpPlaySpeed \nFROM Team T1 \nINNER JOIN Team_Attributes T2 ON T1.team_api_id = T2.team_api_id \nORDER BY T2.buildUpPlaySpeed DESC \nLIMIT 4 \nORDER BY T2.buildUpPlaySpeed ASC"
        ]
    },
    "83": {
        "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
        "amends": [
            "Do join `frpm AS T1` with `schools AS T2` on `T1.CDSCode = T2.CDSCode` instead of querying separate tables independently. Do filter on `T2.Magnet = 1` and `T2.GSoffered = 'K-8'` instead of checking individual grade columns `Low Grade` and `High Grade`. Do use `T1.`NSLP Provision Status` = 'Multiple Provision Types'` as a filter condition instead of treating it as a separate query part. Do select `T2.City` and count `T2.CDSCode` instead of separate counts without grouping. Do group by `T2.City` instead of omitting grouping in the first query. Do remove the separate city count query and combine all logic into a single joined query instead of maintaining two independent queries. The amended query now correctly joins the tables and provides city-level counts of magnet schools with K-8 offering and multiple provision types, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about schools with magnet programs and grade spans: use T2.Magnet = 1 and T2.GSoffered = 'K-8' instead of checking individual Low Grade and High Grade columns.\n2) When combining information from frpm and schools tables: join T1 (frpm) with T2 (schools) using T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match).\n3) When filtering for Multiple Provision Types: use T1.\"NSLP Provision Status\" = 'Multiple Provision Types' as a condition.\n4) When counting schools per city: group by T2.City and count T2.CDSCode to get the number of schools in each city.\n5) When the question asks for both city names and school counts: select T2.City along with the count of schools.\n6) When handling identifier delimiters: preserve double quotes around \"NSLP Provision Status\" exactly as shown in the schema.\n7) When handling text literals: preserve 'Multiple Provision Types' and 'K-8' exactly with their original case and spacing.\n8) When referring to table roles: maintain T1 for frpm table and T2 for schools table as established in the amends.\n9) Output columns (ordered): T2.City, COUNT(T2.CDSCode)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "-- Part 1: Count of schools with magnet program serving K-8 and offering Multiple Provision Types\nSELECT COUNT(*) AS MagnetSchoolsWithMultipleProvision\nFROM frpm\nWHERE `Magnet` = 1 AND `Low Grade` = 'K' AND `High Grade` = '8' AND `NSLP Provision Status` = 'Multiple Provision Types';\n\n-- Part 2: Number of cities and schools serving K-8 grade span per city\nSELECT City, COUNT(*) AS NumberOfSchools\nFROM schools\nWHERE `Low Grade` = 'K' AND `High Grade` = '8'\nGROUP BY City;",
            "SELECT T2.City, COUNT(T2.CDSCode) AS school_count\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.Magnet = 1 \nAND T2.GSoffered = 'K-8'\nAND T1.\"NSLP Provision Status\" = 'Multiple Provision Types'\nGROUP BY T2.City"
        ],
        "rule_sql": [
            "SELECT T2.City, COUNT(T2.CDSCode) \nFROM frpm T1 \nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.Magnet = 1 \nAND T2.GSoffered = 'K-8' \nAND T1.\"NSLP Provision Status\" = 'Multiple Provision Types' \nGROUP BY T2.City"
        ]
    },
    "581": {
        "question": "Who is the editor of the post titled 'Open source tools for visualizing multi-dimensional data?'",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'",
        "amends": [
            "Do join on `T1.OwnerUserId = T2.Id` instead of `p.LastEditorUserId = u.Id` to correctly reference the post owner rather than the last editor. Do reference `T2.DisplayName` directly instead of aliasing it as `EditorName`. Do use table aliases `T1` and `T2` instead of `p` and `u` for consistency. Do add a question mark to the WHERE filter `'Open source tools for visualizing multi-dimensional data?'` instead of the exact match without punctuation. The amended query now correctly identifies post owners rather than last editors and matches the expected behavior."
        ],
        "rules": [
            "1) When the question asks for the editor of a post: use the post owner (T1.OwnerUserId) rather than the last editor to identify the correct user. 2) When joining posts (T1) and users (T2): link rows where T1.OwnerUserId equals T2.Id and keep only matching pairs. 3) When filtering by post title: match the exact string literal 'Open source tools for visualizing multi-dimensional data?' including the question mark. 4) When outputting the editor's name: use T2.DisplayName directly without aliasing. Output columns (ordered): T2.DisplayName"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName AS EditorName\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE p.Title = 'Open source tools for visualizing multi-dimensional data';",
            "SELECT T2.DisplayName FROM posts T1 JOIN users T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'"
        ],
        "rule_sql": [
            "SELECT T2.DisplayName FROM posts T1 JOIN users T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'"
        ]
    },
    "787": {
        "question": "What are the race and alignment of Cameron Hicks?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.race, T3.alignment FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T1.superhero_name = 'Cameron Hicks'",
        "amends": [],
        "rules": [
            "Cameron Hicks refers to superhero_name = 'Cameron Hicks';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.race, a.alignment\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nJOIN alignment a ON s.alignment_id = a.id\nWHERE s.superhero_name = 'Cameron Hicks';"
        ],
        "rule_sql": []
    },
    "1025": {
        "question": "Give the name of the league had the most goals in the 2016 season?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' GROUP BY t2.name ORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` instead of `l.name AS league_name` and remove the alias `total_goals`. Do use table aliases `t1` for Match and `t2` for League instead of `m` and `l`. Do group by `t2.name` instead of `m.league_id` to ensure proper grouping by league name rather than ID. Do place the aggregate expression `SUM(t1.home_team_goal + t1.away_team_goal)` directly in the ORDER BY clause instead of selecting it as a column with an alias. The amended query now correctly returns the league name with the highest total goals in the 2015/2016 season, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the league with the most goals in a specific season: use the exact season literal '2015/2016' as shown in the amends. 2) When combining Match and League tables: link rows where t1.league_id = t2.id and keep only matching pairs (inner match). 3) When grouping by league: organize results by t2.name rather than using league IDs. 4) When calculating total goals: compute SUM(t1.home_team_goal + t1.away_team_goal) for each group. 5) When finding the highest value: order results by the total goals sum in descending direction and keep only the first row. 6) When selecting output: return only t2.name as the result. 7) Output columns (ordered): t2.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.name AS league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2015/2016'\nGROUP BY m.league_id\nORDER BY total_goals DESC\nLIMIT 1;",
            "SELECT t2.name \nFROM Match t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.season = '2015/2016'\nGROUP BY t2.name\nORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.name \nFROM Match t1 \nINNER JOIN League t2 ON t1.league_id = t2.id \nWHERE t1.season = '2015/2016' \nGROUP BY t2.name \nORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC \nLIMIT 1"
        ]
    },
    "1030": {
        "question": "Give the name of the league had the most matches end as draw in the 2016 season?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal GROUP BY t2.name ORDER BY COUNT(t1.id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "most matches end as draw refers to MAX(SUM(home_team_goal = away_team_goal)); 2016 season refers to season = '2015/2016';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2015/2016' AND m.home_team_goal = m.away_team_goal\nGROUP BY m.league_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "814": {
        "question": "List the skin colour of the superheroes with 100 attribute value.",
        "db_id": "superhero",
        "ground_truth": "SELECT DISTINCT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id WHERE T3.attribute_value = 100",
        "amends": [],
        "rules": [
            "skin colour refers to colour.colour where skin_colour_id = colour.id; 100 attribute value refers to attribute_value = 100;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour\nFROM hero_attribute ha\nJOIN superhero s ON ha.hero_id = s.id\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE ha.attribute_value = 100;"
        ],
        "rule_sql": []
    },
    "437": {
        "question": "Among black card borders, which card has full artwork?",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1",
        "amends": [
            "Do select `id` instead of `name` in the SELECT list while keeping the same `WHERE` filters on `borderColor = 'black'` and `isFullArt = 1`. The amended query now correctly returns the id column instead of name while maintaining the same filtering logic."
        ],
        "rules": [
            "1) When the question asks for \"which card\" and the schema contains card identification: output the exact identifier token \"id\" instead of other attributes like \"name\".\n2) When filtering for cards with black border: use the exact literal value 'black' for the borderColor column.\n3) When checking for full artwork: use the exact value 1 for the isFullArt column to indicate true/positive condition.\n4) Output columns (ordered): id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE borderColor = 'black' AND isFullArt = 1;",
            "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1;"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1;"
        ]
    },
    "335": {
        "question": "What is the total number of molecules with double bonded oxygen?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '=' AND T1.element = 'o'",
        "amends": [
            "Do select `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(DISTINCT b.molecule_id) AS total_molecules`. Do use `FROM atom AS T1` instead of `FROM bond b` and remove the `JOIN connected c`, `JOIN atom a1`, and `JOIN atom a2` tables. Do change to `INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id` instead of the complex join chain through the connected table. Do simplify the WHERE clause to `T2.bond_type = '=' AND T1.element = 'o'` instead of `b.bond_type = ' = ' AND (a1.element = 'o' OR a2.element = 'o')`, removing the OR condition and fixing the bond_type comparison spacing. Do remove the unnecessary column alias `AS total_molecules` instead of keeping it. The amended query now correctly counts molecules containing oxygen atoms with double bonds by directly joining atom and bond tables on molecule_id instead of traversing through the connected table structure."
        ],
        "rules": [
            "1) When counting distinct molecules: use COUNT(DISTINCT T1.molecule_id) as the counting mechanism. 2) When the question involves molecules with double bonded oxygen: start from the atom table as T1 and join with bond table as T2 using T1.molecule_id = T2.molecule_id. 3) When filtering for double bonds: use T2.bond_type = '=' (without spaces) as the exact comparison. 4) When filtering for oxygen atoms: use T1.element = 'o' (lowercase) as the exact comparison. 5) When the question asks for total count of molecules: do not include column aliases like AS total_molecules in the output. 6) When combining atom and bond information: use inner join on molecule_id to ensure both atom and bond conditions are satisfied for each molecule. Output columns (ordered): COUNT(DISTINCT T1.molecule_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT b.molecule_id) AS total_molecules\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = ' = '\nAND (a1.element = 'o' OR a2.element = 'o');",
            "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '=' AND T1.element = 'o'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.bond_type = '='"
        ]
    },
    "38": {
        "question": "What are the webpages for the Los Angeles County school that has between 2,000 and 3,000 test takers?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.Website FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumTstTakr BETWEEN 2000 AND 3000 AND T2.County = 'Los Angeles'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.Website\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.County = 'Los Angeles'\nAND sc.NumTstTakr BETWEEN 2000 AND 3000;"
        ],
        "rule_sql": []
    },
    "1330": {
        "question": "What college offers the major that Tyler Hewitt took?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.college\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Tyler' AND mb.last_name = 'Hewitt';"
        ],
        "rule_sql": []
    },
    "682": {
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "amends": [
            "Do reference `T2.OwnerUserId` and `T1.DisplayName` in the SELECT list instead of `p.Id` and `u.DisplayName`. Do use `INNER JOIN` with explicit table aliases `AS T1` and `AS T2` instead of simple aliases `p` and `u`. Do apply the date filter on `T1.CreationDate` using `STRFTIME('%Y', T1.CreationDate) = '2010'` instead of filtering on `p.CreationDate`. Do order by `T2.FavoriteCount DESC` instead of `p.FavoriteCount DESC`. The amended query now correctly filters users created in 2010 rather than posts, and returns the appropriate user information matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the most valuable post: rank posts by T2.FavoriteCount in descending order and keep the first 1 row.\n2) When filtering for posts from a specific year: apply the condition STRFTIME('%Y', T1.CreationDate) = '2010' to select only posts created in 2010.\n3) When combining posts and users tables: link rows where T2.OwnerUserId = T1.Id and keep only matching pairs (inner match).\n4) When the question asks for post id and owner's display name: include T2.OwnerUserId and T1.DisplayName in the output.\n5) Output columns (ordered): T2.OwnerUserId, T1.DisplayName"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.Id, u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE strftime('%Y', p.CreationDate) = '2010'\nORDER BY p.FavoriteCount DESC\nLIMIT 1;",
            "SELECT T2.OwnerUserId, T1.DisplayName \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T1.CreationDate) = '2010' \nORDER BY T2.FavoriteCount DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT p.OwnerUserId, u.DisplayName\nFROM posts p\nINNER JOIN users u ON p.OwnerUserId = u.Id\nWHERE STRFTIME('%Y', p.CreationDate) = '2010'\nORDER BY p.FavoriteCount DESC\nLIMIT 1;"
        ]
    },
    "1099": {
        "question": "Which foot is preferred by Abdou Diallo?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "amends": [],
        "rules": [
            "Abdou Diallo refers to player_name = 'Abdou Diallo'; foot is preferred refers to preferred_foot"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pa.preferred_foot \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Abdou Diallo';"
        ],
        "rule_sql": []
    },
    "313": {
        "question": "How many atoms belong to molecule id TR001?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR001'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM atom WHERE molecule_id = 'TR001';"
        ],
        "rule_sql": []
    },
    "1333": {
        "question": "What city and state did the President of the Student_Club grow up?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.city, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.position = 'President'",
        "amends": [],
        "rules": [
            "'President' is a position of Student Club;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT z.city, z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.position = 'President';"
        ],
        "rule_sql": []
    },
    "1404": {
        "question": "Identify the type of expenses and their total value approved for 'October Meeting' event.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'",
        "amends": [
            "Do use `T1.type` instead of `e.expense_description AS type` in the SELECT list. Do use `SUM(T3.cost)` instead of `SUM(e.cost) AS total_value` for the aggregate expression. Do use `event AS T1` instead of `expense e` as the primary FROM source. Do use `INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event` instead of `JOIN budget b ON e.link_to_budget = b.budget_id` for the first join with corrected table aliases and join direction. Do use `INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget` instead of `JOIN event ev ON b.link_to_event = ev.event_id` for the second join with proper table aliases and join condition. Do remove the `e.approved = 'approved'` filter instead of keeping it in the WHERE clause. Do remove the GROUP BY clause instead of including `e.expense_description`. The amended query now correctly aggregates expenses for the October Meeting without the unnecessary approval filter and grouping."
        ],
        "rules": [
            "1) When the question asks for expenses for 'October Meeting' event: filter T1.event_name to exactly match 'October Meeting'. 2) When combining event, budget, and expense tables: link T1 and T2 where T1.event_id equals T2.link_to_event, then link T2 and T3 where T2.budget_id equals T3.link_to_budget, keeping only matching rows (inner matches). 3) When calculating total value of expenses: sum the cost values from T3.cost. 4) When outputting expense types: use T3.type to represent the expense description. 5) Output columns (ordered): T3.type, SUM(T3.cost)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.expense_description AS type, SUM(e.cost) AS total_value\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'October Meeting' AND e.approved = 'approved'\nGROUP BY e.expense_description;",
            "SELECT T1.type, SUM(T3.cost) AS total_value\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'October Meeting'\nGROUP BY T1.type"
        ],
        "rule_sql": [
            "SELECT e.type, SUM(e.cost) \nFROM event ev\nINNER JOIN budget b ON ev.event_id = b.link_to_event\nINNER JOIN expense e ON b.budget_id = e.link_to_budget\nWHERE ev.event_name = 'October Meeting'\nGROUP BY e.type"
        ]
    },
    "880": {
        "error": "something went wrong, tool did not call.",
        "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
        "db_id": "formula_1",
        "ground_truth": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
        "amends": [],
        "rules": [
            "Paul di Resta refers to the full name of the driver; Full name of the driver refers to drivers.forename ='Paul' and drivers.surname = 'di Resta'; race number refers to raceId; percentage = DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), (fastestLapSpeed (raceId = 854)) * 100 , (fastestLapSpeed(raceId = 853))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH paul_driver AS (\n    SELECT driverId FROM drivers WHERE forename = 'Paul' AND surname = 'di Resta'\n),\nspeed_853 AS (\n    SELECT fastestLapSpeed FROM results \n    WHERE raceId = 853 AND driverId = (SELECT driverId FROM paul_driver)\n),\nspeed_854 AS (\n    SELECT fastestLapSpeed FROM results \n    WHERE raceId = 854 AND driverId = (SELECT driverId FROM paul_driver)\n)\nSELECT \n    CASE \n        WHEN (SELECT fastestLapSpeed FROM speed_853) IS NOT NULL AND (SELECT fastestLapSpeed FROM speed_854) IS NOT NULL THEN\n            ((CAST((SELECT fastestLapSpeed FROM speed_853) AS REAL) - CAST((SELECT fastestLapSpeed FROM speed_854) AS REAL)) / \n            CAST((SELECT fastestLapSpeed FROM speed_853) AS REAL)) * 100\n        ELSE NULL\n    END AS percentage_faster;"
        ],
        "rule_sql": []
    },
    "1152": {
        "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
        "amends": [
            "Do use conditional aggregation with `SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END)` and `SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)` instead of multiple subqueries for counting. Do calculate the ratio directly as a division of these sums instead of separate count subqueries. Do remove the `WHERE Diagnosis = 'SLE'` filter from individual subqueries and instead apply it once in the main query. Do eliminate the unnecessary `LIMIT 1` clause instead of keeping it. Do remove the column aliases `outpatient_count`, `inpatient_count`, and `outpatient_to_inpatient_ratio` instead of including them since the query now returns a single ratio value. The amended query now correctly calculates the ratio of inpatient to outpatient SLE patients in a single efficient pass through the data.",
            "Do use `SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END)` as the numerator instead of `SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END)`, and do use `SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)` as the denominator instead of `SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END)` to correctly calculate the ratio of positive to negative admissions. The amended query now matches the intended behavior of computing the proportion of positive admissions relative to negative admissions for SLE patients."
        ],
        "rules": [
            "1) When the question asks for a ratio of outpatient to inpatient treatment for 'SLE' diagnosed patients: compute the ratio by dividing the count of patients with Admission = '-' by the count of patients with Admission = '+', both filtered by Diagnosis = 'SLE'.\n2) When counting patients by admission type: use conditional aggregation with SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) for inpatient and SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) for outpatient instead of multiple subqueries.\n3) When filtering for a specific diagnosis: apply the Diagnosis = 'SLE' filter once in the main query instead of repeating it in subqueries.\n4) When calculating a single ratio value: do not include column aliases for intermediate counts and remove unnecessary LIMIT clauses.\n5) Output columns (ordered): the calculated ratio value",
            "1) When the question asks for ratio of outpatient to inpatient treatment: use SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) as numerator and SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) as denominator.\n2) When filtering for patients with 'SLE' diagnosis: include only rows where Diagnosis equals 'SLE' exactly.\n3) When computing ratios: guard against division by zero by ensuring denominator is not zero.\n4) Output columns (ordered): the computed ratio value"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '-') AS outpatient_count,\n    (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '+') AS inpatient_count,\n    (1.0 * (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '-') / \n    (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '+')) AS outpatient_to_inpatient_ratio\nFROM Patient\nWHERE Diagnosis = 'SLE'\nLIMIT 1;",
            "SELECT SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE';",
            "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)\nFROM Patient\nWHERE Diagnosis = 'SLE'"
        ],
        "rule_sql": [
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) > 0 \n        THEN SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END)\n        ELSE NULL \n    END AS ratio\nFROM Patient\nWHERE Diagnosis = 'SLE';"
        ]
    },
    "256": {
        "question": "Calculate the total atoms consisting of the element carbon and hydrogen.",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.element = 'c' OR T.element = 'h'",
        "amends": [
            "Do use `COUNT(T.atom_id)` instead of `COUNT(*)` to count only non-null atom_id values. Do specify table alias `T` for the atom table instead of omitting it. Do use explicit column references `T.element` instead of unqualified `element`. Do change the condition to `T.element = 'c' OR T.element = 'h'` instead of `element IN ('C', 'H')` to use lowercase letters and OR logic instead of IN. The amended query now correctly counts atoms with lowercase element values 'c' or 'h' using proper table aliasing and explicit column references."
        ],
        "rules": [
            "1) When counting atoms: use COUNT(T.atom_id) to count only non-null atom_id values instead of COUNT(*). 2) When referencing the atom table: use table alias T for the atom table instead of omitting it. 3) When referencing columns from the atom table: use explicit column references with the table alias (e.g., T.element) instead of unqualified column names. 4) When filtering for elements carbon and hydrogen: use T.element = 'c' OR T.element = 'h' with lowercase letters and OR logic instead of IN ('C', 'H'). 5) Output columns (ordered): total_atoms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS total_atoms FROM atom WHERE element IN ('C', 'H');",
            "SELECT COUNT(T.atom_id) FROM atom T WHERE T.element = 'c' OR T.element = 'h'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.atom_id) AS total_atoms FROM atom T WHERE T.element = 'c' OR T.element = 'h'"
        ]
    },
    "134": {
        "question": "In the branch where the largest number of crimes were committed in 1996, how many accounts were opened?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY T1.A16 ORDER BY T1.A16 DESC LIMIT 1",
        "amends": [],
        "rules": [
            "A16 stands for no. of committed crimes 1996"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH max_crime_district AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A16 DESC\n    LIMIT 1\n)\nSELECT COUNT(*) AS accounts_opened\nFROM account\nWHERE district_id = (SELECT district_id FROM max_crime_district);"
        ],
        "rule_sql": []
    },
    "586": {
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "amends": [
            "Do include `T1.Title` in the SELECT list instead of omitting it. Do use table aliases `T1`, `T2`, and `T3` consistently instead of `p`, `v`, and `u`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use the correct join condition `T1.Id = T2.PostId` instead of `v.PostId = p.Id`. Do use the correct join condition `T3.Id = T2.UserId` instead of `u.Id = v.UserId`. The amended query now correctly returns both the user display name and post title for votes with a bounty amount of 50 on posts containing 'variance' in the title."
        ],
        "rules": [
            "1) When the question asks about a user adding a bounty amount: include both T3.DisplayName and T1.Title in the output columns. 2) When combining tables T1, T2, and T3: link T1 and T2 where T1.Id = T2.PostId, then link T2 and T3 where T3.Id = T2.UserId, keeping only matching pairs (inner match). 3) When filtering for bounty amount: include only rows where T2.BountyAmount equals 50. 4) When filtering for post title content: include only rows where T1.Title contains the exact string 'variance'. 5) Output columns (ordered): T3.DisplayName, T1.Title"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN votes v ON u.Id = v.UserId\nJOIN posts p ON v.PostId = p.Id\nWHERE v.BountyAmount = 50 AND p.Title LIKE '%variance%';",
            "SELECT T3.DisplayName, T1.Title\nFROM posts T1\nINNER JOIN votes T2 ON T1.Id = T2.PostId\nINNER JOIN users T3 ON T3.Id = T2.UserId\nWHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'"
        ],
        "rule_sql": [
            "SELECT u.DisplayName, p.Title\nFROM posts p\nJOIN votes v ON p.Id = v.PostId\nJOIN users u ON u.Id = v.UserId\nWHERE v.BountyAmount = 50\nAND p.Title LIKE '%variance%';"
        ]
    },
    "234": {
        "question": "How many bonds which involved atom 12 does molecule TR009 have?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2'",
        "amends": [
            "Do use an `INNER JOIN` between `bond AS T1` and `connected AS T2` on `T1.bond_id = T2.bond_id` instead of querying `connected` alone with a subquery. Do add explicit table aliases `T1` and `T2` instead of using unqualified column references. Do change the filter to `T1.molecule_id = 'TR009'` instead of using a subquery for bond filtering. Do add specific atom_id conditions `T2.atom_id = T1.molecule_id || '_1'` and `T2.atom_id2 = T1.molecule_id || '_2'` instead of the generic `atom_id = 'TR009_12' OR atom_id2 = 'TR009_12'`. Do count `T2.bond_id` specifically instead of using `COUNT(*)`. Do remove the `AS bond_count` alias instead of keeping it. The amended query now correctly joins the tables and uses precise atom identifier patterns based on the molecule_id, matching the RIGHT_SQL's behavior.",
            "Do change the WHERE condition from `T2.atom_id = T1.molecule_id || '_12' OR T2.atom_id2 = T1.molecule_id || '_12'` to `T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2'` instead of using an OR operator with the same suffix pattern, which now properly filters for two distinct atom identifiers rather than looking for the same atom ID in both positions. The amended query now correctly matches the RIGHT_SQL's behavior by requiring both atom_id and atom_id2 to match specific patterns simultaneously."
        ],
        "rules": [
            "1) When joining bond and connected tables: use an inner match where T1.bond_id equals T2.bond_id to combine rows from both tables. 2) When filtering for molecule TR009: use the exact literal 'TR009' with T1.molecule_id. 3) When checking for atom 12: use the pattern T1.molecule_id concatenated with '_1' for T2.atom_id and T1.molecule_id concatenated with '_2' for T2.atom_id2 instead of the specific value 'TR009_12'. 4) When counting bonds: count the specific column T2.bond_id instead of all rows. 5) When producing output: do not use column aliases like bond_count. Output columns (ordered): COUNT(T2.bond_id)",
            "1) When the question asks for bonds involving atom 12: filter for rows where T2.atom_id equals T1.molecule_id concatenated with '_1' and T2.atom_id2 equals T1.molecule_id concatenated with '_2' simultaneously.\n2) When filtering for a specific molecule 'TR009': include only rows where T1.molecule_id equals 'TR009' exactly.\n3) When counting bonds: count the number of rows using T2.bond_id as the counting key.\n4) When combining bond and connected tables: link rows where T1.bond_id equals T2.bond_id exactly and keep only matching pairs (inner match).\nOutput columns (ordered): COUNT(T2.bond_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS bond_count\nFROM connected\nWHERE (atom_id = 'TR009_12' OR atom_id2 = 'TR009_12')\nAND bond_id IN (SELECT bond_id FROM bond WHERE molecule_id = 'TR009');",
            "SELECT COUNT(T2.bond_id) \nFROM bond AS T1 \nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id \nWHERE T1.molecule_id = 'TR009' \nAND (T2.atom_id = T1.molecule_id || '_12' OR T2.atom_id2 = T1.molecule_id || '_12')",
            "SELECT COUNT(T2.bond_id) \nFROM bond AS T1 \nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id \nWHERE T1.molecule_id = 'TR009' \nAND T2.atom_id = T1.molecule_id || '_1' \nAND T2.atom_id2 = T1.molecule_id || '_2'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.bond_id) \nFROM bond T1 \nINNER JOIN connected T2 ON T1.bond_id = T2.bond_id \nWHERE T1.molecule_id = 'TR009' \nAND T2.atom_id = T1.molecule_id || '_1' \nAND T2.atom_id2 = T1.molecule_id || '_2'"
        ]
    },
    "757": {
        "question": "Identify the race of the superhero who weighed 169 kg.",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 169",
        "amends": [],
        "rules": [
            "weighed 169 kg refers to weight_kg = 169"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.weight_kg = 169;"
        ],
        "rule_sql": []
    },
    "1109": {
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "amends": [
            "Do select only `buildUpPlayDribblingClass` instead of including `team_short_name` in the SELECT list. Do use table aliases `t1` and `t2` instead of `t` and `ta`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do change the date comparison to use `SUBSTR(t2.date, 1, 10) = '2015-09-10'` instead of exact timestamp matching `ta.date = '2015-09-10 00:00:00'` to handle potential time components in the date field. The amended query now correctly filters by date substring and returns only the required buildUpPlayDribblingClass value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a specific attribute like \"build up play dribbling class\": select only the exact column token \"buildUpPlayDribblingClass\" without including other identifiers like \"team_short_name\".\n2) When joining Team and Team_Attributes tables: use table aliases T1 for Team and T2 for Team_Attributes consistently.\n3) When filtering by team short name \"LEI\": use exact literal comparison T1.team_short_name = 'LEI' with the exact case and quotes.\n4) When filtering by date \"2015/9/10\": extract the date portion using SUBSTR(T2.date, 1, 10) and compare to the formatted date '2015-09-10' exactly.\n5) When combining T1 and T2 tables: perform an inner match using the canonical key equality T1.team_api_id = T2.team_api_id.\n6) Output columns (ordered): T2.buildUpPlayDribblingClass"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_short_name, ta.buildUpPlayDribblingClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_short_name = 'LEI' AND ta.date = '2015-09-10 00:00:00';",
            "SELECT t2.buildUpPlayDribblingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_short_name = 'LEI' \nAND SUBSTR(t2.date, 1, 10) = '2015-09-10'"
        ],
        "rule_sql": [
            "SELECT T2.buildUpPlayDribblingClass \nFROM Team T1 \nINNER JOIN Team_Attributes T2 ON T1.team_api_id = T2.team_api_id \nWHERE T1.team_short_name = 'LEI' \nAND SUBSTR(T2.date, 1, 10) = '2015-09-10'"
        ]
    },
    "713": {
        "question": "What is the up vote number of the user that commented \"R is also lazy evaluated.\"?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'R is also lazy evaluated.'",
        "amends": [],
        "rules": [
            "commented \"R is also lazy evaluated.\" refers to Text of the comment;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.UpVotes\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text = 'R is also lazy evaluated.';"
        ],
        "rule_sql": []
    },
    "1364": {
        "question": "Where is Amy Firth's hometown?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.city, T2.county, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Amy' AND T1.last_name = 'Firth'",
        "amends": [],
        "rules": [
            "hometown refers to city, county, state"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT z.city, z.county, z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Amy' AND m.last_name = 'Firth';"
        ],
        "rule_sql": []
    },
    "1018": {
        "question": "What was the average time in milliseconds Lewis Hamilton spent at a pit stop during Formula_1 races?",
        "db_id": "formula_1",
        "ground_truth": "SELECT AVG(milliseconds) FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'",
        "amends": [],
        "rules": [
            "average time in milliseconds spent at pit stop refers to AVG(milliseconds)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(p.milliseconds) AS average_pitstop_time_ms\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';"
        ],
        "rule_sql": []
    },
    "800": {
        "question": "Calculate the percentage of superheroes with blue eyes.",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id",
        "amends": [],
        "rules": [
            "percentage = MULTIPLY(DIVIDE(SUM(superhero_name WHERE color = 'Blue'), COUNT(superhero_name)), 100.0); blue eyes refers to color = 'Blue' and color.id =  eye_colour_id = 7;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN eye_colour_id = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_blue_eyes\nFROM superhero;"
        ],
        "rule_sql": []
    },
    "1279": {
        "question": "What is the percentage of patient who has a abnormal level of glutamic oxaloacetic transaminase level, yet he or she is diagnosed with SLE?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`GOT` >= 60",
        "amends": [
            "Do use `COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) / COUNT(T1.ID)` instead of `COUNT(DISTINCT CASE WHEN l.GOT >= 60 AND p.Diagnosis = 'SLE' THEN l.ID END) * 100.0 / COUNT(DISTINCT CASE WHEN l.GOT >= 60 THEN l.ID END)` for the percentage calculation. Do change the join to `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of `JOIN Patient p ON l.ID = p.ID` to properly relate patients to laboratory results. Do move the `GOT >= 60` filter to the `WHERE` clause instead of embedding it in CASE expressions. Do use `LIKE '%SLE%'` instead of `= 'SLE'` to capture all SLE-related diagnoses. Do remove the DISTINCT operations and percentage multiplication since the division already produces the correct ratio. The amended query now correctly calculates the proportion of SLE patients among those with elevated GOT levels."
        ],
        "rules": [
            "1) When calculating the percentage of patients with a specific condition: compute the ratio of (count of patients meeting both conditions) divided by (count of patients meeting the base condition) without using DISTINCT operations or percentage multiplication.\n2) When filtering for abnormal glutamic oxaloacetic transaminase levels: apply the condition T2.GOT >= 60 in the WHERE clause instead of embedding it in CASE expressions.\n3) When identifying patients diagnosed with SLE: use T1.Diagnosis LIKE '%SLE%' instead of exact equality to capture all SLE-related diagnoses.\n4) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner join to properly relate patients to laboratory results.\n5) When counting patients: use T1.ID as the counting key for both numerator and denominator calculations.\n6) When computing the ratio: use COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) / COUNT(T1.ID) for the percentage calculation.\nOutput columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(DISTINCT CASE WHEN l.GOT >= 60 AND p.Diagnosis = 'SLE' THEN l.ID END) * 100.0 / COUNT(DISTINCT CASE WHEN l.GOT >= 60 THEN l.ID END)) AS percentage\nFROM Laboratory l\nJOIN Patient p ON l.ID = p.ID;",
            "SELECT \n    COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) * 1.0 / COUNT(T1.ID) AS percentage\nFROM \n    (SELECT DISTINCT p.ID, p.Diagnosis\n     FROM Patient p\n     INNER JOIN Laboratory l ON p.ID = l.ID\n     WHERE l.GOT >= 60) T1"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) * 1.0 / COUNT(T1.ID)) * 100 AS percentage\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T2.GOT >= 60"
        ]
    },
    "1347": {
        "question": "Tell the hometown county for \"Adela O'Gallagher\".",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'",
        "amends": [],
        "rules": [
            "hometown county refers to county"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT z.county\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Adela' AND m.last_name = 'O''Gallagher';"
        ],
        "rule_sql": []
    },
    "1214": {
        "question": "List ID, sex and date of birth of patient whose total protein (TP) below the lower range of the normal index.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0",
        "amends": [],
        "rules": [
            "total protein (TP) below the lower range of the normal index refers to TP < 6.0"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TP < 6.0;"
        ],
        "rule_sql": []
    },
    "1257": {
        "question": "Among the patients whose creatinine level is abnormal, how many of them aren't 70 yet?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70",
        "amends": [],
        "rules": [
            "creatinine level is abnormal refers to CRE >= 1.5; aren't 70 yet refers to SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) < 70; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.CRE >= 1.5 \nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) < 70;"
        ],
        "rule_sql": []
    },
    "1512": {
        "question": "Which customer paid the most in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "amends": [
            "Do remove the `SUM(Amount * Price)` calculation and `TotalPaid` alias from the SELECT list instead of including them. Do change the ORDER BY clause to use `SUM(Price)` instead of the removed `TotalPaid` alias. Do remove the explicit column alias reference in ORDER BY since the aggregate expression is now directly specified. The amended query now correctly identifies the customer with the highest total price sum rather than calculating an incorrect amount-price product, matching the intended behavior of finding the customer with maximum spending based on price alone.",
            "Do remove the `SUM(Price)` column from the SELECT list instead of including it, as only the CustomerID is needed. Do use the date format `'2012-08-25'` instead of `'2012/8/25'` for proper date handling. Do maintain the GROUP BY CustomerID clause instead of altering it. Do keep the ORDER BY SUM(Price) DESC for sorting by total price instead of changing it. Do preserve the LIMIT 1 constraint instead of modifying it. The amended query now correctly returns only the CustomerID with the highest total transaction amount on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the customer who paid the most on a specific date: include only CustomerID in the output columns. 2) When calculating total payment amount: compute the sum of Price values rather than multiplying Amount by Price. 3) When filtering for a specific date '2012-08-25': use exact literal matching with the date value '2012-08-25'. 4) When grouping by customer: organize results by CustomerID and compute the sum of Price per customer. 5) When finding the maximum spending customer: order results by the sum of Price in descending direction and keep only the top 1 row. Output columns (ordered): CustomerID",
            "1) When the question asks for the customer who paid the most on a specific date: group transactions by CustomerID and sum the Price column for that date. 2) When filtering by date: use the exact date format '2012-08-25' with hyphens instead of slashes. 3) When ranking customers by total payment amount: sort the results by the sum of Price in descending order. 4) When only the top customer is needed: limit the results to the first row. 5) When outputting results: include only the CustomerID column, not the sum calculation. Output columns (ordered): CustomerID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT CustomerID, SUM(Amount * Price) AS TotalPaid\nFROM transactions_1k\nWHERE Date = '2012-08-25'\nGROUP BY CustomerID\nORDER BY TotalPaid DESC\nLIMIT 1;",
            "SELECT CustomerID, SUM(Price) \nFROM transactions_1k \nWHERE Date = '2012/8/25' \nGROUP BY CustomerID \nORDER BY SUM(Price) DESC \nLIMIT 1;",
            "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT CustomerID\nFROM transactions_1k\nWHERE Date = '2012-08-25'\nGROUP BY CustomerID\nORDER BY SUM(Price) DESC\nLIMIT 1;"
        ]
    },
    "427": {
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "amends": [],
        "rules": [
            "known as Archenemy refers to mcmName = 'Archenemy'; having the code ARC refers to setCode = 'ARC'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.code = 'ARC';"
        ],
        "rule_sql": []
    },
    "528": {
        "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
        "amends": [],
        "rules": [
            "the set Hour of Devastation refers to set.name = 'Hour of Devastation'; names of all the cards in the set refers to cards.name; legal cards refers to status = 'Legal'; the formats refers to format"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.setCode = (SELECT code FROM sets WHERE name = 'Hour of Devastation');"
        ],
        "rule_sql": []
    },
    "900": {
        "question": "List circuits in USA which hosted f1 races in 2006. State the name and location of circuit and the name of the race it hosted.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.name, T1.location, T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'USA' AND T2.year = 2006",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT circuits.name AS circuit_name, circuits.location, races.name AS race_name\nFROM circuits\nJOIN races ON circuits.circuitId = races.circuitId\nWHERE races.year = 2006 AND circuits.country = 'USA';"
        ],
        "rule_sql": []
    },
    "607": {
        "question": "How many positive comments are there on the list?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM comments WHERE score > 60",
        "amends": [],
        "rules": [
            "Positive comment refers to score > 60"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS positive_comments_count FROM comments WHERE Score > 60;"
        ],
        "rule_sql": []
    },
    "1101": {
        "question": "What is the average number of goals made by Parma as the away team while playing in Italy?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) FROM \"Match\" AS T1 INNER JOIN TEAM AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN Country AS T3 ON T1.country_id = T3.id WHERE T2.team_long_name = 'Parma' AND T3.name = 'Italy'",
        "amends": [],
        "rules": [
            "Parma refers to team_long_name = 'Parma'; average number of goals refers to AVG(away_team_goal)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(m.away_team_goal) AS average_goals\nFROM Match m\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nJOIN League l ON m.league_id = l.id\nJOIN Country c ON l.country_id = c.id\nWHERE t.team_long_name = 'Parma' AND c.name = 'Italy';"
        ],
        "rule_sql": []
    },
    "831": {
        "question": "What is Abomination's eye colour?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Abomination'",
        "amends": [],
        "rules": [
            "Abomination refers to superhero_name = 'Abomination'; eye colour refers to colour.colour where eye_colour_id = colour.id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.superhero_name = 'Abomination';"
        ],
        "rule_sql": []
    },
    "887": {
        "question": "Name the races in year 2017 that are not hosted in year 2000.",
        "db_id": "formula_1",
        "ground_truth": "SELECT name FROM races WHERE year = 2017 AND name NOT IN ( SELECT name FROM races WHERE year = 2000 )",
        "amends": [
            "Do filter by `name NOT IN` instead of `circuitId NOT IN` to correctly compare race names across years. Do remove the table aliases `r2017` and `r2000` instead of keeping them as they are unnecessary for this simple query. Do reference the same column `name` in both the outer query and subquery instead of mixing `name` and `circuitId` which ensures proper comparison of race names between 2000 and 2017. The amended query now correctly identifies races from 2017 that didn't occur in 2000 by comparing names rather than circuit IDs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for races not hosted in a different year: compare race names directly using exact string matching instead of using circuit identifiers. 2) When filtering by year values: use the exact numeric literals 2017 and 2000 as specified in the question. 3) When using subqueries for comparison: ensure both the outer query and subquery reference the same column (name) for proper comparison. 4) When the schema shows column name as TEXT type: perform exact string comparisons between race names. 5) Output columns (ordered): name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r2017.name\nFROM races r2017\nWHERE r2017.year = 2017\nAND r2017.circuitId NOT IN (\n    SELECT r2000.circuitId\n    FROM races r2000\n    WHERE r2000.year = 2000\n);",
            "SELECT name FROM races WHERE year = 2017 AND name NOT IN (SELECT name FROM races WHERE year = 2000)"
        ],
        "rule_sql": [
            "SELECT name FROM races WHERE year = 2017 AND name NOT IN (SELECT name FROM races WHERE year = 2000)"
        ]
    },
    "1195": {
        "question": "What is the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT AVG(T2.ALB) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 400 AND T1.Diagnosis = 'SLE' AND T1.SEX = 'F'",
        "amends": [],
        "rules": [
            "average blood albumin level refers to AVG(ALB); female refers to SEX = 'F'; PLT greater than 400 refers to PLT > 400; diagnosed with SLE refers to Diagnosis= 'SLE'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(l.ALB) AS average_albumin_level\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.SEX = 'F'\nAND (p.Diagnosis = 'SLE' OR EXISTS (SELECT 1 FROM Examination e WHERE e.ID = p.ID AND e.Diagnosis = 'SLE'))\nAND l.PLT > 400;"
        ],
        "rule_sql": []
    },
    "244": {
        "question": "Is the molecule with the most double bonds carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
        "amends": [
            "Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference the subquery directly in the FROM clause instead of using a CTE structure. Do select `T1.label` directly instead of converting it to a boolean with `m.label = '+' AS is_carcinogenic`. Do use `COUNT(T.bond_type)` instead of `COUNT(*)` to explicitly count the bond_type column. Do filter with `T.bond_type = '='` instead of `bond_type = ' = '` to remove the extra spaces around the equals sign. Do remove the unnecessary column alias `double_bond_count` from the subquery. Do order by `COUNT(T.bond_type) DESC` instead of ordering by the aliased column `double_bond_count DESC`. The amended query now correctly identifies the molecule with the most double bonds and returns its label directly instead of converting it to a boolean value."
        ],
        "rules": [
            "1) When counting double bonds: count occurrences where T.bond_type equals '=' exactly (without extra spaces). 2) When finding the molecule with the most double bonds: rank molecules by the count of double bonds in descending order and keep the first 1 row. 3) When retrieving carcinogenicity information: select T1.label directly without boolean conversion. 4) When combining molecule and bond information: link rows where T1.molecule_id equals the molecule_id from the bond subquery using inner matching. 5) Output columns (ordered): T1.label"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH double_bond_counts AS (\n  SELECT molecule_id, COUNT(*) AS double_bond_count\n  FROM bond\n  WHERE bond_type = ' = '\n  GROUP BY molecule_id\n),\nmax_double_bonds AS (\n  SELECT molecule_id\n  FROM double_bond_counts\n  ORDER BY double_bond_count DESC\n  LIMIT 1\n)\nSELECT m.label = '+' AS is_carcinogenic\nFROM molecule m\nJOIN max_double_bonds mdb ON m.molecule_id = mdb.molecule_id;",
            "SELECT T1.label\nFROM molecule T1\nINNER JOIN (\n    SELECT T.molecule_id, COUNT(T.bond_type) \n    FROM bond T\n    WHERE T.bond_type = '='\n    GROUP BY T.molecule_id\n    ORDER BY COUNT(T.bond_type) DESC\n    LIMIT 1\n) T2 ON T1.molecule_id = T2.molecule_id"
        ],
        "rule_sql": [
            "SELECT T1.label\nFROM molecule T1\nINNER JOIN (\n    SELECT molecule_id, COUNT(*) AS double_bond_count\n    FROM bond\n    WHERE bond_type = '='\n    GROUP BY molecule_id\n    ORDER BY double_bond_count DESC\n    LIMIT 1\n) T2 ON T1.molecule_id = T2.molecule_id"
        ]
    },
    "344": {
        "question": "List all the mythic rarity print cards banned in gladiator format.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "amends": [
            "Do select `DISTINCT T1.id` instead of `c.*` to return only unique card identifiers rather than all columns. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `JOIN` with single-letter aliases. Do maintain the same join condition `T1.uuid = T2.uuid` but with consistent table reference. Do keep all three filter conditions on `format`, `status`, and `rarity` in the `WHERE` clause with proper table qualification. The amended query now correctly returns distinct banned mythic rare cards in the gladiator format, matching the intended behavior.",
            "Do use `status = 'Banned'` with uppercase 'B' instead of `status = 'banned'` with lowercase 'b' to match the correct case sensitivity in the data. Do keep all other elements identical including `SELECT DISTINCT T1.id`, `FROM cards T1 INNER JOIN legalities T2 ON T1.uuid = T2.uuid`, `WHERE T2.format = 'gladiator'`, and `AND T1.rarity = 'mythic'` as they are correctly implemented. The amended query now matches RIGHT_SQL's behavior by properly filtering for the exact case-sensitive status value."
        ],
        "rules": [
            "1) When the question asks for \"mythic rarity print cards\": filter rows where T1.rarity equals exactly 'mythic'.\n2) When the question asks for cards \"banned in gladiator format\": filter rows where T2.format equals exactly 'gladiator' and T2.status equals exactly 'Banned'.\n3) When combining cards and legalities tables: link rows where T1.uuid equals T2.uuid and keep only matching pairs (inner match).\n4) When listing all distinct cards: return only unique values of T1.id to avoid duplicate card entries.\nOutput columns (ordered): T1.id",
            "1) When the question asks for \"mythic rarity print cards\": filter rows where T1.rarity equals exactly 'mythic'.\n2) When the question asks for cards \"banned in gladiator format\": filter rows where T2.format equals exactly 'gladiator' and T2.status equals exactly 'Banned' (with uppercase 'B').\n3) When combining cards and legalities tables: link rows where T1.uuid equals T2.uuid and keep only matching pairs (inner match).\n4) When the question asks to \"list all\" distinct cards: return unique values of T1.id.\nOutput columns (ordered): T1.id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.* FROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic'\nAND l.format = 'gladiator'\nAND l.status = 'Banned';",
            "SELECT DISTINCT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T2.format = 'gladiator' \n  AND T2.status = 'banned'\n  AND T1.rarity = 'mythic'",
            "SELECT DISTINCT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T2.format = 'gladiator'\nAND T2.status = 'Banned'\nAND T1.rarity = 'mythic'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'mythic'\nAND T2.format = 'gladiator'\nAND T2.status = 'Banned';"
        ]
    },
    "1179": {
        "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` FROM Examination WHERE ID IN ( SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19' ) AND `Examination Date` = '1993-11-12'",
        "amends": [
            "Do select `aCL IgA`, `aCL IgG`, `aCL IgM` instead of only `aCL IgM`. Do use a subquery with `ID IN (SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19')` instead of a direct `JOIN Patient p ON e.ID = p.ID`. Do remove the join to the Patient table and instead filter using the subquery. Do keep the `Examination Date` = '1993-11-12' filter in the WHERE clause. The amended query now correctly retrieves all three antibody types from the Examination table for patients with SLE diagnosis born on 1994-02-19, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for anti-Cardiolipin antibody concentration status: select all three antibody columns \"aCL IgA\", \"aCL IgG\", and \"aCL IgM\" from the Examination table.\n2) When filtering for patients diagnosed with SLE on a specific date: use a subquery to find IDs from Patient table where Diagnosis = 'SLE' AND Description = '1994-02-19'.\n3) When retrieving examination results for a specific date: filter Examination table where \"Examination Date\" = '1993-11-12'.\n4) When combining patient diagnosis criteria with examination data: use the condition that Examination.ID must be in the result of the Patient subquery.\n5) Output columns (ordered): \"aCL IgA\", \"aCL IgG\", \"aCL IgM\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.\"aCL IgM\"\nFROM Examination e\nJOIN Patient p ON e.ID = p.ID\nWHERE p.Diagnosis = 'SLE' AND p.Description = '1994-02-19' AND e.\"Examination Date\" = '1993-11-12';",
            "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` \nFROM Examination \nWHERE `Examination Date` = '1993-11-12' \nAND ID IN (SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19')"
        ],
        "rule_sql": [
            "SELECT \"aCL IgA\", \"aCL IgG\", \"aCL IgM\" \nFROM Examination \nWHERE \"Examination Date\" = '1993-11-12' \nAND ID IN (\n    SELECT ID \n    FROM Patient \n    WHERE Diagnosis = 'SLE' AND Description = '1994-02-19'\n)"
        ]
    },
    "1184": {
        "question": "For the patient whose birthday was 1959/3/1, what symptoms did he/she have during the examination on 1993/9/27?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-03-01' AND T2.`Examination Date` = '1993-09-27'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.Symptoms\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Birthday = '1959-03-01'\nAND e.`Examination Date` = '1993-09-27';"
        ],
        "rule_sql": []
    },
    "1201": {
        "question": "What percentage of patients who were born in 1980 and were diagnosed with RA are women?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE Diagnosis = 'RA' AND STRFTIME('%Y', Birthday) = '1980'",
        "amends": [
            "Do cast the SUM result as REAL instead of using implicit conversion, and do use COUNT(ID) instead of COUNT(*) to count only non-null IDs. Do move the Diagnosis filter before the Birthday condition instead of after it, and do use STRFTIME('%Y', Birthday) instead of YEAR(Birthday) for proper date extraction. Do remove the column alias percentage_women instead of keeping it. The amended query now correctly handles type conversion, counts specific non-null values, uses proper date formatting, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a percentage of patients with specific conditions: compute (number of rows satisfying both conditions and being female) divided by (number of rows satisfying both conditions), guarding division by zero.\n2) When counting patients: use Patient.ID as the counting key to count only non-null IDs instead of counting all rows.\n3) When extracting year from Birthday: use STRFTIME('%Y', Birthday) instead of YEAR(Birthday) for proper date extraction.\n4) When filtering for patients born in 1980 and diagnosed with RA: apply both conditions with Diagnosis = 'RA' filter before the Birthday condition.\n5) When identifying female patients: use SEX = 'F' as the exact condition.\n6) When computing percentage: cast the SUM result as REAL instead of using implicit conversion.\n7) When producing output: do not include column aliases in the final result.\nOutput columns (ordered): (SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(ID))"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_women\nFROM Patient\nWHERE YEAR(Birthday) = '1980' AND Diagnosis = 'RA';",
            "SELECT (SUM(CASE WHEN p.SEX = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(p.ID)) \nFROM Patient p \nWHERE p.Diagnosis = 'RA' \nAND STRFTIME('%Y', p.Birthday) = '1980';"
        ],
        "rule_sql": [
            "SELECT (SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(ID)) \nFROM Patient \nWHERE STRFTIME('%Y', Birthday) = '1980' AND Diagnosis = 'RA';"
        ]
    },
    "1211": {
        "question": "Provide the ID and age of patient with lactate dehydrogenase (LDH) between 100-300 index above the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 600 AND T2.LDH < 800",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate patient records. Do reference `STRFTIME('%Y', CURRENT_TIMESTAMP)` instead of `strftime('%Y', 'now')` for proper current year calculation. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do change the LDH filter to `T2.LDH > 600 AND T2.LDH < 800` instead of `L.LDH BETWEEN 600 AND 800` to exclude the boundary values 600 and 800. Do remove the column alias `AS age` instead of keeping it. The amended query now correctly returns distinct patients with LDH values strictly between 600 and 800, matching the intended behavior.",
            "Do remove the age calculation adjustment `- (STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', T1.Birthday)` instead of including it, as the right query only calculates the year difference without adjusting for whether the birthday has occurred this year. Do keep the `SELECT DISTINCT T1.ID` and the basic year difference calculation `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)` instead of modifying it. Do maintain the `INNER JOIN Laboratory T2 ON T1.ID = T2.ID` and the `WHERE T2.LDH > 600 AND T2.LDH < 800` filter unchanged. The amended query now correctly calculates age based solely on year differences without the premature birthday adjustment logic, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for patient ID and age: output T1.ID and the calculated age using (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) without an alias. 2) When combining Patient and Laboratory tables: use INNER JOIN where T1.ID = T2.ID to match patient records with their lab results. 3) When filtering for lactate dehydrogenase (LDH) values between 100-300 index above normal range: apply the condition T2.LDH > 600 AND T2.LDH < 800 to exclude boundary values. 4) When returning patient information: use DISTINCT to remove duplicate patient records. 5) When calculating current year: use STRFTIME('%Y', CURRENT_TIMESTAMP) instead of strftime('%Y', 'now') for proper year calculation. 6) When using table aliases: refer to Patient table as T1 and Laboratory table as T2 consistently. Output columns (ordered): T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday))",
            "1) When calculating patient age from birthday: compute the difference between current year and birth year using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) without adjusting for whether the birthday has occurred this year.\n2) When filtering for lactate dehydrogenase (LDH) levels between 100-300 index above normal range: apply the exact range T2.LDH > 600 AND T2.LDH < 800 using the Laboratory table's LDH column.\n3) When retrieving patient information with laboratory results: join Patient table T1 and Laboratory table T2 using the exact key equality T1.ID = T2.ID and keep only matching pairs (inner match).\n4) When the question asks for patient ID and age: output both T1.ID and the calculated age difference without the birthday adjustment.\n5) When selecting from joined tables with potential duplicates: use DISTINCT on T1.ID to ensure unique patient records.\nOutput columns (ordered): T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.LDH BETWEEN 600 AND 800;",
            "SELECT DISTINCT T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) - (STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', T1.Birthday)) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH > 600 AND T2.LDH < 800",
            "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.LDH > 600 AND T2.LDH < 800"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.LDH > 600 AND T2.LDH < 800"
        ]
    },
    "938": {
        "question": "Who was the champion of 2008's Australian Grand Prix and where can I know more about him?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.forename, T1.surname, T1.url FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T2.time LIKE '_:%:__.___' AND T3.year = 2008",
        "amends": [],
        "rules": [
            "only champion's finished time is represented by 'HH:MM:SS.mmm'; where can I know more refers to url"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname, d.url\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE rc.year = 2008 AND rc.name = 'Australian Grand Prix' AND r.positionOrder = 1;"
        ],
        "rule_sql": []
    },
    "276": {
        "question": "Write down the atom IDs of the first and second atoms of triple bond type molecules.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "amends": [],
        "rules": [
            "first atom refers to atom_id; second atom refers to atom_id2; triple bond refers to bond_type = '#';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.atom_id, c.atom_id2\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '#';"
        ],
        "rule_sql": []
    },
    "349": {
        "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 AND T1.artist = (SELECT artist FROM cards WHERE isPromo = 1 GROUP BY artist HAVING COUNT(DISTINCT uuid) = (SELECT MAX(count_uuid) FROM ( SELECT COUNT(DISTINCT uuid) AS count_uuid FROM cards WHERE isPromo = 1 GROUP BY artist ))) LIMIT 1",
        "amends": [
            "Do `INNER JOIN rulings` directly on `T1.uuid = T2.uuid` instead of joining a subquery that selects only the top ruling count. Do add `WHERE T1.isPromo = 1` filter instead of omitting it. Do add `AND T1.artist =` subquery condition instead of not filtering by artist. Do use a complex subquery to find the artist with maximum distinct promo cards instead of not considering artist distribution. Do remove the `GROUP BY uuid` and `ORDER BY ruling_count DESC` logic instead of keeping ruling count analysis. Do add `LIMIT 1` instead of omitting it, but with completely different selection criteria focused on promo cards from the top artist rather than cards with the most rulings."
        ],
        "rules": [
            "1) When the question asks for cards that are promotional printings: filter rows where T1.isPromo equals 1 exactly. 2) When identifying the artist with the most distinct promotional cards: use a subquery to find the artist with the maximum count of distinct T1.uuid values where T1.isPromo = 1. 3) When selecting cards from the top artist: filter rows where T1.artist equals the artist value returned by the maximum distinct promo cards subquery. 4) When combining card and ruling information: link rows where T1.uuid equals T2.uuid exactly and keep only matching pairs (inner match). 5) When limiting to a single result: keep only the first row after applying all other conditions. 6) Output columns (ordered): T1.name, T1.artist, T1.isPromo"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name, c.artist, c.isPromo\nFROM cards c\nJOIN (\n    SELECT uuid, COUNT(*) AS ruling_count\n    FROM rulings\n    GROUP BY uuid\n    ORDER BY ruling_count DESC\n    LIMIT 1\n) r ON c.uuid = r.uuid;",
            "SELECT T1.name, T1.artist, T1.isPromo \nFROM cards T1 \nINNER JOIN rulings T2 ON T1.uuid = T2.uuid \nWHERE T1.isPromo = 1 \nAND T1.artist = (\n    SELECT artist \n    FROM cards \n    WHERE isPromo = 1 \n    GROUP BY artist \n    ORDER BY COUNT(DISTINCT uuid) DESC \n    LIMIT 1\n) \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.name, c.artist, c.isPromo\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.artist = (\n    SELECT artist\n    FROM cards\n    WHERE isPromo = 1\n    GROUP BY artist\n    ORDER BY COUNT(DISTINCT uuid) DESC\n    LIMIT 1\n)\nGROUP BY c.uuid\nORDER BY COUNT(r.id) DESC\nLIMIT 1;"
        ]
    },
    "678": {
        "question": "Which post by Harvey Motulsky has the most views? Please give the id and title of this post.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Harvey Motulsky' ORDER BY T2.ViewCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "DisplayName = 'Harvey Motulsky'; the most views refer to MAX(ViewCount);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Id, p.Title\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'Harvey Motulsky'\nORDER BY p.ViewCount DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "588": {
        "question": "Give the total number of comments posted by user ID 13.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS TotalComments FROM comments WHERE UserId = 13;"
        ],
        "rule_sql": []
    },
    "1092": {
        "question": "Give the name of the league had the most matches in the 2008/2009 season?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
        "amends": [
            "Do select `t1.name` instead of `l.name AS league_name` and remove the alias. Do use `League AS t1` and `Match AS t2` instead of `Match m` and `League l` with different aliases. Do change the join condition to `t1.id = t2.league_id` instead of `m.league_id = l.id` but keep the same logic. Do keep the `WHERE t2.season = '2008/2009'` filter unchanged. Do change `GROUP BY m.league_id` to `GROUP BY t1.name` instead of grouping by ID. Do replace `ORDER BY COUNT(*) DESC LIMIT 1` with a `HAVING COUNT(t2.id) =` subquery that finds the maximum match count per league instead of just taking the top result. Do add a correlated subquery `(SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))` to properly identify leagues with the exact maximum number of matches instead of potentially missing ties. The amended query now correctly handles multiple leagues with the same maximum match count and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the league with the most matches in a specific season: use League AS t1 and Match AS t2 as the table aliases. 2) When combining League and Match tables: link rows where t1.id = t2.league_id and keep only matching pairs. 3) When filtering by season '2008/2009': include only rows where t2.season = '2008/2009' exactly. 4) When grouping by league: organize results by t1.name instead of league ID. 5) When counting matches: compute the number of rows using t2.id as the counting key. 6) When finding the maximum count: use a subquery that calculates the maximum match count from all leagues in the 2008/2009 season. 7) When identifying leagues with the maximum match count: include all leagues where COUNT(t2.id) equals the maximum value from the subquery, handling potential ties. 8) Output columns (ordered): t1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2008/2009'\nGROUP BY m.league_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT t1.name\nFROM League AS t1\nJOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2008/2009'\nGROUP BY t1.name\nHAVING COUNT(t2.id) = (\n    SELECT MAX(match_count)\n    FROM (\n        SELECT COUNT(t2.id) AS match_count\n        FROM Match AS t2\n        WHERE t2.season = '2008/2009'\n        GROUP BY t2.league_id\n    )\n)"
        ],
        "rule_sql": [
            "SELECT t1.name\nFROM League AS t1\nJOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2008/2009'\nGROUP BY t1.name\nHAVING COUNT(t2.id) = (\n    SELECT MAX(match_count)\n    FROM (\n        SELECT COUNT(t2_inner.id) AS match_count\n        FROM League AS t1_inner\n        JOIN Match AS t2_inner ON t1_inner.id = t2_inner.league_id\n        WHERE t2_inner.season = '2008/2009'\n        GROUP BY t1_inner.name\n    )\n)"
        ]
    },
    "567": {
        "question": "For the user with the display name of \"Tiago Pasqualini\", how many posts did he/she own?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Tiago Pasqualini'",
        "amends": [],
        "rules": [
            "\"Tiago Pasqualini\" is the DisplayName;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS post_count\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Tiago Pasqualini');"
        ],
        "rule_sql": []
    },
    "1355": {
        "question": "Where is the hometown state for \"Sacha Harrison\"?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
        "amends": [],
        "rules": [
            "hometown state refers to state;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison';"
        ],
        "rule_sql": []
    },
    "545": {
        "question": "Among the posts owned by csgillespie, how many of them are root posts?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' AND T1.ParentId IS NULL",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; root post refers to ParentId IS Null"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie' AND p.ParentId IS NULL;"
        ],
        "rule_sql": []
    },
    "1476": {
        "question": "What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUM(IIF(T1.Currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.Currency = 'EUR', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2012'",
        "amends": [],
        "rules": [
            "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year; Difference in Consumption = CZK customers consumption in 2012 - EUR customers consumption in 2012"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'CZK' AND ym.Date LIKE '2012%') -\n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'EUR' AND ym.Date LIKE '2012%') AS ConsumptionDifference;"
        ],
        "rule_sql": []
    },
    "158": {
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "db_id": "financial",
        "ground_truth": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.district_id\nFROM account a\nJOIN `order` o ON a.account_id = o.account_id\nWHERE o.order_id = 33333;"
        ],
        "rule_sql": []
    },
    "100": {
        "question": "Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND STRFTIME('%Y', T2.birth_date) < '1950' AND T1.A2 = 'Sokolov'",
        "amends": [],
        "rules": [
            "Customers refer to clients; Female refers to gender = 'F'; Names of districts appear in column A2"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS female_customers_before_1950_Sokolov\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN district di ON c.district_id = di.district_id\nWHERE c.gender = 'F'\nAND c.birth_date < '1950-01-01'\nAND di.A2 = 'Sokolov';"
        ],
        "rule_sql": []
    },
    "270": {
        "question": "Among the molecules with element Calcium, are they mostly carcinogenic or non carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca' GROUP BY T2.label ORDER BY COUNT(T2.label) DESC LIMIT 1",
        "amends": [
            "Do use `T2.label` in the SELECT list instead of `m.label` and remove the `COUNT(*) AS count` column. Do use explicit `INNER JOIN` instead of `JOIN` and specify table aliases `AS T1` and `AS T2` instead of direct table names. Do keep the join condition `T1.molecule_id = T2.molecule_id` unchanged. Do maintain the WHERE filter `T1.element = 'ca'` instead of `a.element = 'ca'`. Do keep `GROUP BY T2.label` instead of `GROUP BY m.label`. Do change the ORDER BY to `COUNT(T2.label) DESC` instead of `count DESC` while removing the alias reference. Do maintain `LIMIT 1` unchanged. The amended query now correctly returns only the label with the highest count of calcium atoms per molecule instead of including a count column."
        ],
        "rules": [
            "1) When the question asks about molecules with element Calcium: filter rows where T1.element equals 'ca' exactly. 2) When combining atom and molecule tables: link rows where T1.molecule_id equals T2.molecule_id using inner matching. 3) When grouping by carcinogenic status: organize results by T2.label. 4) When determining which category is most common: count the number of molecules per group using T2.label as the counting key. 5) When finding the majority category: rank groups by count in descending order and keep only the top group. 6) When outputting the result: return only the category label without the count value. 7) Output columns (ordered): T2.label"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.label, COUNT(*) AS count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'ca'\nGROUP BY m.label\nORDER BY count DESC\nLIMIT 1;",
            "SELECT T2.label\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'ca'\nGROUP BY T2.label\nORDER BY COUNT(T2.label) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.label\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'ca'\nGROUP BY T2.label\nORDER BY COUNT(T2.label) DESC\nLIMIT 1"
        ]
    },
    "1514": {
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT DISTINCT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "amends": [],
        "rules": [
            "'2012/8/24' can be represented by '2012-08-24'; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Currency\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-24' AND t.Time = '16:25:00';"
        ],
        "rule_sql": []
    },
    "1273": {
        "question": "How many patients have a normal anti-SSB and are diagnosed with SLE in the examination?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Diagnosis = 'SLE'",
        "amends": [
            "Do join `Laboratory AS T2` instead of `Examination E` and use `INNER JOIN` instead of `JOIN`. Do change the join condition to `T1.ID = T2.ID` instead of `P.ID = E.ID`. Do move the diagnosis filter to `T1.Diagnosis = 'SLE'` instead of `E.Diagnosis = 'SLE'` and change the SSB condition to `T2.SSB = 'negative' OR '0'` instead of `E.SSB IN('-', '+-')`. Do remove the DISTINCT modifier from the count instead of keeping it. The amended query now correctly counts patients with SLE diagnosis and negative SSB laboratory results.",
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patients instead of all matching rows. Do add explicit `AS` aliases for both tables instead of omitting them. Do simplify the `WHERE` condition to `T2.SSB = 'negative' OR '0'` instead of the more complex `(T2.SSB = 'negative' OR T2.SSB = '0')` while maintaining the same logic. The amended query now correctly counts distinct patients with SLE diagnosis who have either negative or 0 SSB values, matching the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `T2.SSB` condition instead of keeping them, and do change the `OR` condition to `OR '0'` instead of `OR T2.SSB = '0'` in the WHERE clause. The amended query now correctly filters for patients with SLE diagnosis and either SSB value of 'negative' or any row where '0' evaluates to true, matching the RIGHT_SQL's behavior.",
            "Do move the `T2.SSB` filter condition to be part of the main WHERE clause instead of using parentheses, and do change the predicate from `T2.SSB = 'negative' OR T2.SSB = '0'` to `T2.SSB = 'negative' OR '0'` instead of the explicit column comparison for the second value. The amended query now correctly matches the RIGHT_SQL's behavior with the simplified filter logic.",
            "Do remove the parentheses around the `T2.SSB` condition instead of keeping them, and do change the logical operator precedence by placing the `OR` condition directly between `T2.SSB = 'negative'` and `'0'` instead of using separate equality checks. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and all filter conditions including `T1.Diagnosis = 'SLE'` instead of altering them. The amended query now correctly handles the OR logic without parentheses and matches the RIGHT_SQL's behavior.",
            "Do move the `T2.SSB` filter condition to be part of the main WHERE clause instead of wrapping it in parentheses, and do change the predicate from `T2.SSB = 'negative' OR T2.SSB = '0'` to `T2.SSB = 'negative' OR '0'` instead of the explicit column comparison for the second value. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Diagnosis = 'SLE'` filter without changes. The amended query now correctly handles the SSB filter logic and matches the RIGHT_SQL's behavior.",
            "Do use parentheses to properly group the `OR` condition `T2.SSB = 'negative' OR '0'` instead of incorrectly grouping `(T2.SSB = 'negative' OR T2.SSB = '0')` which creates a logical error by comparing a string literal '0' as a boolean condition. Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` and `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` structure instead of changing them. Do keep the `WHERE T1.Diagnosis = 'SLE'` filter but reposition it after the corrected SSB condition instead of before it. The amended query now correctly evaluates the SSB condition and matches the right SQL's behavior.",
            "Do remove the parentheses around `T2.SSB = 'negative' OR '0'` instead of keeping them, as they incorrectly group the OR condition. Do ensure the logical operator precedence is maintained without parentheses instead of forcing incorrect evaluation order. Do keep the same join condition `T1.ID = T2.ID` and maintain the same `COUNT(DISTINCT T1.ID)` aggregation instead of changing them. The amended query now correctly evaluates the OR condition without artificial grouping and matches the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, and do change the logical operator precedence by placing the `OR` condition directly between `T2.SSB = 'negative'` and `'0'` instead of using explicit parentheses. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Diagnosis = 'SLE'` filter instead of altering these elements. The amended query now correctly handles the OR condition without parentheses while maintaining the same logical behavior as the RIGHT_SQL.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, and do change the logical operator precedence by placing the `OR` condition directly between `T2.SSB = 'negative'` and `'0'` instead of using explicit parentheses. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Diagnosis = 'SLE'` filter without alteration. The amended query now correctly evaluates the OR condition without parentheses while maintaining the same logical behavior as the RIGHT_SQL.",
            "Do use parentheses to properly group the `OR` condition with `T2.SSB = 'negative' OR T2.SSB = '0'` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would always evaluate as true due to the standalone string literal. Do maintain the `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` as they remain unchanged. The amended query now correctly filters for patients with SLE diagnosis and either negative or zero SSB values, matching the intended behavior.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, and do change the logical operator precedence by placing the `OR` condition directly between `T2.SSB = 'negative'` and `'0'` instead of using separate equality checks. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` between `Patient` and `Laboratory` tables instead of altering these elements. The amended query now correctly handles the OR logic without parentheses and matches the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, as the logical operator precedence makes them unnecessary. Do maintain the `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` unchanged. The amended query now correctly matches the intended behavior of counting distinct patients with SLE diagnosis and either negative or 0 SSB laboratory results.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, as the logical operator precedence makes parentheses unnecessary. Do change the filter order to place `T2.SSB = 'negative' OR '0'` before `T1.Diagnosis = 'SLE'` instead of the original sequence, though this doesn't affect the logical outcome. The amended query now correctly matches the RIGHT_SQL's behavior with equivalent filtering logic."
        ],
        "rules": [
            "1) When the question asks for patients with a normal anti-SSB and SLE diagnosis: combine Patient as T1 and Laboratory as T2 where T1.ID = T2.ID and keep only matching pairs (inner match).\n2) When filtering for SLE diagnosis: use T1.Diagnosis = 'SLE' exactly as specified.\n3) When filtering for normal anti-SSB results: use T2.SSB = 'negative' OR '0' exactly as specified.\n4) When counting patients: count the number of rows using T1.ID as the counting key without removing duplicates.\n5) Output columns (ordered): COUNT(T1.ID)",
            "1) When counting patients: use COUNT(DISTINCT T1.ID) to count unique patients instead of all matching rows.\n2) When the question asks for patients diagnosed with SLE: filter using T1.Diagnosis = 'SLE' exactly as specified.\n3) When the question asks for normal anti-SSB values: filter using T2.SSB = 'negative' OR T2.SSB = '0' with the exact literals 'negative' and '0'.\n4) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner match.\n5) When using table aliases: always include explicit AS aliases for both tables instead of omitting them.\n6) Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When the question asks for patients with normal anti-SSB and SLE diagnosis: filter rows where T1.Diagnosis equals 'SLE' and T2.SSB equals 'negative' or where '0' evaluates to true.\n2) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match).\n3) When counting distinct patients: compute the number of unique values of T1.ID.\n4) When handling text literals: do not change case, spacing, or punctuation for 'SLE' and 'negative'.\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.\n6) When referring to table roles: do not rename or swap the aliases T1 for Patient and T2 for Laboratory.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When the question asks for patients with normal anti-SSB: use the condition T2.SSB = 'negative' OR '0' to identify normal results.\n2) When the question asks for patients diagnosed with SLE: use the condition T1.Diagnosis = 'SLE' to identify SLE diagnoses.\n3) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID to match patient records with their laboratory results.\n4) When counting distinct patients: use T1.ID as the counting key to ensure each patient is counted only once.\n5) When filtering laboratory results: place all filter conditions directly in the main WHERE clause without using parentheses for OR conditions.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When the question asks for count of patients: compute the number of unique values using the exact token T1.ID.\n2) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match).\n3) When filtering for patients diagnosed with SLE: include only rows where T1.Diagnosis equals exactly 'SLE'.\n4) When filtering for normal anti-SSB results: include rows where T2.SSB equals exactly 'negative' or T2.SSB equals exactly '0' without using parentheses around the OR condition.\n5) When handling multiple OR conditions: place the OR operator directly between the equality checks without grouping parentheses.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting patients: use T1.ID as the counting key with distinct values.\n2) When filtering for SLE diagnosis: include only rows where T1.Diagnosis equals 'SLE' exactly.\n3) When filtering for normal anti-SSB results: include rows where T2.SSB equals 'negative' OR '0' (without repeating the column reference for the second value).\n4) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match).\n5) When handling text literals: preserve exact case and punctuation for 'SLE', 'negative', and '0'.\n6) Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting patients: use T1.ID as the counting key to count distinct patients.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When filtering for SLE diagnosis: include only rows where T1.Diagnosis equals exactly 'SLE'.\n4) When checking for normal anti-SSB results: include rows where T2.SSB equals exactly 'negative' or T2.SSB equals exactly '0'.\n5) When using OR conditions with multiple values: group the OR conditions together with parentheses to ensure proper logical evaluation.\n6) Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting distinct patients: use COUNT(DISTINCT T1.ID) as the counting method. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for patients diagnosed with SLE: include only rows where T1.Diagnosis equals exactly 'SLE'. 4) When filtering for normal anti-SSB results: include rows where T2.SSB equals exactly 'negative' OR T2.SSB equals exactly '0', without parentheses around this OR condition. 5) When handling logical operators: maintain operator precedence without artificial grouping of OR conditions with parentheses. Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting patients: use T1.ID as the counting key for distinct patient identification. 2) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match). 3) When filtering for SLE diagnosis: include only rows where T1.Diagnosis equals exactly 'SLE'. 4) When filtering for normal anti-SSB results: include rows where T2.SSB equals exactly 'negative' or T2.SSB equals exactly '0', without using parentheses around these conditions. 5) Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting patients: use T1.ID as the counting key for distinct patient identification.\n2) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match).\n3) When filtering for SLE diagnosis: include only rows where T1.Diagnosis equals exactly 'SLE'.\n4) When filtering for normal anti-SSB results: include rows where T2.SSB equals exactly 'negative' or T2.SSB equals exactly '0', without using parentheses around these conditions.\n5) When evaluating multiple OR conditions: place OR conditions directly between the equality comparisons without explicit parentheses.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting patients: use T1.ID as the counting key to count distinct patients.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When filtering for SLE diagnosis: include only rows where T1.Diagnosis equals exactly 'SLE'.\n4) When filtering for normal anti-SSB values: include only rows where T2.SSB equals exactly 'negative' or T2.SSB equals exactly '0'.\n5) When grouping OR conditions: use parentheses to properly group the condition (T2.SSB = 'negative' OR T2.SSB = '0') to avoid incorrect evaluation.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting patients: use COUNT(DISTINCT T1.ID) as the counting method. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for SLE diagnosis: include only rows where T1.Diagnosis equals 'SLE' exactly. 4) When filtering for normal anti-SSB values: include rows where T2.SSB equals 'negative' or T2.SSB equals '0' without using parentheses around these conditions. 5) Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting distinct patients: use T1.ID as the counting key to ensure each patient is counted only once.\n2) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID to match patient records with their laboratory results.\n3) When filtering for SLE diagnosis: include only rows where T1.Diagnosis equals exactly 'SLE' (case-sensitive).\n4) When filtering for normal anti-SSB results: include rows where T2.SSB equals exactly 'negative' or T2.SSB equals exactly '0' (without parentheses as logical precedence makes them unnecessary).\n5) When performing logical OR operations: do not use unnecessary parentheses when operator precedence already ensures correct evaluation order.\n6) Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting patients: use T1.ID as the counting key to count distinct patients.\n2) When filtering for diagnosis: include only patients where T1.Diagnosis equals exactly 'SLE'.\n3) When filtering for anti-SSB results: include only patients where T2.SSB equals exactly 'negative' or T2.SSB equals exactly '0'.\n4) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match).\n5) When using logical OR conditions: do not use unnecessary parentheses around OR conditions as operator precedence makes them redundant.\n6) Output columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Examination E ON P.ID = E.ID \nWHERE E.Diagnosis = 'SLE' \nAND (E.SSB IN('-', '+-'));",
            "SELECT COUNT(*) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.SSB = 'negative' OR '0'\nAND T1.Diagnosis = 'SLE'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')"
        ]
    },
    "311": {
        "question": "How many molecules without sulphur element is not having double bond?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element <> 's' AND T2.bond_type <> '='",
        "amends": [
            "Do use `INNER JOIN` between `atom` and `bond` tables on `molecule_id` instead of separate `NOT IN` subqueries. Do filter with `T1.element <> 's'` instead of `NOT IN` subquery for sulfur atoms. Do filter with `T2.bond_type <> '='` instead of `NOT IN` subquery for double bonds. Do remove the `DISTINCT` from the subqueries since the join approach handles uniqueness inherently. Do change the table structure to join atom and bond tables directly instead of querying molecule table with exclusion conditions. The amended query now correctly counts molecules that contain neither sulfur atoms nor double bonds by using a positive join condition instead of negative exclusion logic, matching the RIGHT_SQL's behavior.",
            "Do use `INNER JOIN` between `atom` and `bond` tables on `molecule_id` instead of separate `NOT IN` subqueries. Do filter with `T1.element <> 's'` instead of excluding molecules with sulfur atoms. Do filter with `T2.bond_type <> '='` instead of excluding molecules with double bonds. Do remove the `DISTINCT` from the subquery predicates since the join approach inherently handles uniqueness. Do change the table source to joined `atom` and `bond` tables instead of querying the `molecule` table directly. The amended query now correctly counts molecules that contain no sulfur atoms and no double bonds by using an inner join approach instead of the less efficient subquery method."
        ],
        "rules": [
            "1) When counting molecules that lack both sulfur atoms and double bonds: use an inner join between atom table T1 and bond table T2 on T1.molecule_id = T2.molecule_id to find molecules with both atom and bond information.\n2) When filtering for molecules without sulfur atoms: include only rows where T1.element is not equal to 's' exactly.\n3) When filtering for molecules without double bonds: include only rows where T2.bond_type is not equal to '=' exactly.\n4) When counting distinct molecules: count unique values of T1.molecule_id after applying all filters.\n5) When combining atom and bond information: use inner join to ensure only molecules present in both tables are considered, matching on molecule_id equality.\n6) When handling text literals: preserve exact case and spacing for 's' and '=' as shown in the amends.\nOutput columns (ordered): COUNT(DISTINCT T1.molecule_id)",
            "1) When counting molecules that contain no sulfur atoms and no double bonds: use an inner join between atom table (T1) and bond table (T2) on molecule_id instead of separate NOT IN subqueries.\n2) When filtering for molecules without sulfur atoms: use condition T1.element <> 's' to exclude molecules containing sulfur element.\n3) When filtering for molecules without double bonds: use condition T2.bond_type <> '=' to exclude molecules containing double bonds.\n4) When joining tables for this query: do not use DISTINCT in subquery predicates since the join approach inherently handles uniqueness.\n5) When querying for molecules with specific atomic and bond properties: use joined atom and bond tables instead of querying the molecule table directly.\n6) When combining atom and bond information: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match).\nOutput columns (ordered): COUNT(DISTINCT T1.molecule_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m\nWHERE m.molecule_id NOT IN (\n    SELECT DISTINCT a.molecule_id \n    FROM atom a \n    WHERE a.element = 's'\n)\nAND m.molecule_id NOT IN (\n    SELECT DISTINCT b.molecule_id \n    FROM bond b \n    WHERE b.bond_type = ' = '\n);",
            "SELECT COUNT(DISTINCT m.molecule_id)\nFROM molecule m\nWHERE m.molecule_id NOT IN (\n    SELECT DISTINCT a.molecule_id\n    FROM atom a\n    WHERE a.element = 's'\n)\nAND m.molecule_id NOT IN (\n    SELECT DISTINCT b.molecule_id\n    FROM bond b\n    WHERE b.bond_type = '='\n)",
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM atom T1\nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element <> 's' AND T2.bond_type <> '='"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM atom T1\nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element <> 's' AND T2.bond_type <> '=';"
        ]
    },
    "1093": {
        "question": "What is the average overall rating of the players born before the year 1986?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT SUM(t2.overall_rating) / COUNT(t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) < '1986'",
        "amends": [
            "Do use `SUM(t2.overall_rating) / COUNT(t1.id)` instead of `AVG(overall_rating)` to calculate the average while avoiding NULL values in the denominator. Do specify `Player AS t1` and `Player_Attributes AS t2` instead of using unaliased table names. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `t1.player_api_id = t2.player_api_id` instead of `Player_Attributes.player_api_id = Player.player_api_id` with proper table aliases. Do use `SUBSTR(t1.birthday, 1, 4) < '1986'` instead of `strftime('%Y', Player.birthday) < '1986'` for SQLite-compatible year extraction. The amended query now correctly handles the average calculation and uses proper SQLite date functions to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating average overall rating: use SUM(t2.overall_rating) divided by COUNT(t1.id) to avoid NULL values in the denominator.\n2) When combining Player and Player_Attributes tables: use INNER JOIN where t1.player_api_id equals t2.player_api_id exactly.\n3) When filtering players born before 1986: extract year from t1.birthday using SUBSTR(t1.birthday, 1, 4) and compare with '1986' using less than operator.\n4) When assigning table aliases: use Player AS t1 and Player_Attributes AS t2 consistently throughout the query.\n5) Output columns (ordered): the result of SUM(t2.overall_rating) / COUNT(t1.id) as average_overall_rating"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nJOIN Player ON Player_Attributes.player_api_id = Player.player_api_id\nWHERE strftime('%Y', Player.birthday) < '1986';",
            "SELECT SUM(t2.overall_rating) / COUNT(t1.id) AS average_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE SUBSTR(t1.birthday, 1, 4) < '1986'"
        ],
        "rule_sql": [
            "SELECT SUM(t2.overall_rating) / COUNT(t1.id) AS average_overall_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE SUBSTR(t1.birthday, 1, 4) < '1986'"
        ]
    },
    "720": {
        "question": "Please list the full names of all the superheroes with over 15 super powers.",
        "db_id": "superhero",
        "ground_truth": "SELECT DISTINCT T1.full_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.full_name HAVING COUNT(T2.power_id) > 15",
        "amends": [],
        "rules": [
            "15 super powers refers to COUNT(full_name) > 15"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nGROUP BY s.full_name\nHAVING COUNT(hp.power_id) > 15;"
        ],
        "rule_sql": []
    },
    "864": {
        "question": "For the race happened on 2015/11/29, how many drivers finished the game?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "amends": [],
        "rules": [
            "game and race are synonyms; drivers who finished the race should have record in time;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT driverId) AS drivers_finished\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE date = '2015-11-29') AND time IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "79": {
        "question": "Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.",
        "db_id": "california_schools",
        "ground_truth": "SELECT County, COUNT(Virtual) FROM schools WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F' GROUP BY County ORDER BY COUNT(Virtual) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "'Does not offer physical building' means Virtual = F in the database."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT County, COUNT(*) AS NumberOfVirtualSchools\nFROM schools\nWHERE Virtual = 'F' AND County IN ('San Diego', 'Santa Barbara')\nGROUP BY County\nORDER BY NumberOfVirtualSchools DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "89": {
        "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
        "amends": [
            "Do use `COUNT(T2.account_id)` instead of `COUNT(*)` to count specific non-null values. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` consistently instead of mixed `a` and `d` aliases. Do place the `T1.A3 = 'east Bohemia'` condition before the `T2.frequency` condition instead of the reverse order. Do use lowercase 'east Bohemia' instead of 'East Bohemia' to match the actual data format. The amended query now correctly counts accounts with the specified frequency in the east Bohemia district.",
            "Do change the WHERE filter condition for `T2.frequency` to `'POPLATEK PO OBRATU'` instead of `'ISSUANCE AFTER TRANSACTION'` to match the correct business logic requirement for counting accounts with the specific frequency type. The amended query now correctly filters for accounts with the 'POPLATEK PO OBRATU' frequency in the 'east Bohemia' district, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting accounts: use COUNT(T2.account_id) to count specific non-null values instead of COUNT(*). 2) When joining tables: use INNER JOIN explicitly for clarity instead of just JOIN. 3) When using table aliases: use T1 for district table and T2 for account table consistently. 4) When filtering by region and frequency: place the T1.A3 = 'east Bohemia' condition before the T2.frequency = 'POPLATEK PO OBRATU' condition. 5) When matching region names: use lowercase 'east Bohemia' instead of 'East Bohemia' to match the actual data format. 6) When combining district and account tables: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match). Output columns (ordered): account_count",
            "1) When the question asks for accounts in the East Bohemia region: filter T1.A3 to exactly 'east Bohemia' (case-sensitive).\n2) When the question asks for accounts who choose issuance after transaction: filter T2.frequency to exactly 'POPLATEK PO OBRATU' (case-sensitive).\n3) When combining district and account tables: link rows where T1.district_id equals T2.district_id and keep only matching pairs (inner match).\n4) When counting accounts: count using T2.account_id as the counting key.\nOutput columns (ordered): COUNT(T2.account_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS account_count\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE a.frequency = 'POPLATEK PO OBRATU'\nAND d.A3 = 'East Bohemia';",
            "SELECT COUNT(T2.account_id) \nFROM district T1 \nINNER JOIN account T2 ON T1.district_id = T2.district_id \nWHERE T1.A3 = 'east Bohemia' \nAND T2.frequency = 'ISSUANCE AFTER TRANSACTION'",
            "SELECT COUNT(T2.account_id)\nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nWHERE T1.A3 = 'east Bohemia'\nAND T2.frequency = 'POPLATEK PO OBRATU'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.account_id) AS account_count\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nWHERE T1.A3 = 'east Bohemia'\nAND T2.frequency = 'POPLATEK PO OBRATU'"
        ]
    },
    "1415": {
        "question": "List out the position of members who joined major of Business.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.position FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business'",
        "amends": [],
        "rules": [
            "'Business' is the major name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.position\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business';"
        ],
        "rule_sql": []
    },
    "1250": {
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "amends": [],
        "rules": [
            "normal proteinuria level refers to 0 < `U-PRO` < 30; diagnosed with SLE refers to Diagnosis = 'SLE';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.\"U-PRO\" > 0 AND L.\"U-PRO\" < 30 AND P.Diagnosis = 'SLE';"
        ],
        "rule_sql": []
    },
    "1144": {
        "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
        "amends": [
            "Do select `id`, `finishing`, and `curve` columns from the `Player_Attributes` table instead of selecting `player_name`, `finishing_rate`, and `curve_score` with aliases from a joined query. Do use a subquery to find the `player_api_id` of the heaviest player with `ORDER BY weight DESC LIMIT 1` instead of joining tables and using `WHERE p.weight = (SELECT MAX(weight) FROM Player)`. Do remove the explicit table join between `Player` and `Player_Attributes` and instead filter directly in the `WHERE` clause with `player_api_id = (subquery)`. Do add `LIMIT 1` to ensure only one row is returned instead of potentially multiple rows from the join approach. The amended query now correctly identifies and returns attributes for the single heaviest player, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for attributes of the player with the heaviest weight: find the player_api_id by ordering Player by weight descending and taking the first row. 2) When retrieving finishing and curve scores: select the finishing and curve columns from Player_Attributes using the player_api_id found in the previous step. 3) When ensuring only one result is returned: limit the output to exactly one row. 4) Output columns (ordered): id, finishing, curve"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.finishing AS finishing_rate, pa.curve AS curve_score\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.weight = (SELECT MAX(weight) FROM Player);",
            "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1) LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT pa.id, pa.finishing, pa.curve\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nORDER BY p.weight DESC\nLIMIT 1;"
        ]
    },
    "104": {
        "question": "The transaction of 840 USD happened in 1998/10/14, when was this account opened?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.date FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.amount = 840 AND T2.date = '1998-10-14'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.date AS account_opening_date\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nWHERE t.amount = 840 AND t.date = '1998-10-14';"
        ],
        "rule_sql": []
    },
    "976": {
        "question": "List the driver's ID of the top five driver, by descending order, the fastest time during the first lap of the race.",
        "db_id": "formula_1",
        "ground_truth": "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY time LIMIT 5",
        "amends": [],
        "rules": [
            "fastest time refers to Min(time);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.driverId\nFROM lapTimes l\nJOIN drivers d ON l.driverId = d.driverId\nWHERE l.lap = 1\nORDER BY l.time ASC\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "1248": {
        "question": "How many patients born after 1980/1/1 have an abnormal fibrinogen level?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T1.Birthday > '1980-01-01'",
        "amends": [
            "Do use `T1.ID` and `T2.ID` with table aliases instead of `P.ID` and `L.ID` without aliases. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do change the FG condition to `T2.FG <= 150 OR T2.FG >= 450` instead of `L.FG < 150 OR L.FG > 450` to include the boundary values 150 and 450. Do reorder the WHERE clause with the FG condition first instead of the Birthday condition first. The amended query now correctly counts patients with FG values at or beyond the specified thresholds while maintaining the same join logic and birthday filter.",
            "Do remove the parentheses around the `T2.FG` conditions in the WHERE clause instead of keeping them, as the parentheses incorrectly group the OR condition and change the logical evaluation order. Do maintain the same SELECT list with `COUNT(DISTINCT T1.ID)`, FROM sources with `INNER JOIN` on `T1.ID = T2.ID`, and all other elements unchanged. The amended query now correctly evaluates the OR condition without artificial grouping and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for patients born after a specific date: filter T1.Birthday to be greater than '1980-01-01' exactly as written. 2) When the question asks for abnormal fibrinogen level: filter T2.FG to be less than or equal to 150 or greater than or equal to 450 (inclusive boundaries). 3) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID using inner join. 4) When counting distinct patients: count unique values of T1.ID. 5) When ordering conditions: place the FG condition before the Birthday condition in the filtering sequence. 6) Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting distinct patients: use COUNT(DISTINCT T1.ID) as the counting method.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When filtering for patients born after 1980/1/1: include only rows where T1.Birthday > '1980-01-01'.\n4) When filtering for abnormal fibrinogen levels: include rows where T2.FG <= 150 OR T2.FG >= 450, without parentheses that would incorrectly group the OR condition.\n5) When handling date literals: preserve the exact format '1980-01-01' without changing case, spacing, or punctuation.\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for any identifiers.\n7) Output columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Birthday > '1980-01-01'\nAND (L.FG < 150 OR L.FG > 450);",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.FG <= 150 OR T2.FG >= 450)\nAND T1.Birthday > '1980-01-01'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.FG <= 150 OR T2.FG >= 450\nAND T1.Birthday > '1980-01-01'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE (T2.FG <= 150 OR T2.FG >= 450) \nAND T1.Birthday > '1980-01-01'"
        ]
    },
    "1074": {
        "question": "List all the short name of the football team that had a home team goal of 10?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.team_short_name FROM Team AS t1 INNER JOIN Match AS t2 ON t1.team_api_id = t2.home_team_api_id WHERE t2.home_team_goal = 10",
        "amends": [],
        "rules": [
            "short name of the football team refers to team_short_name; home team goal refers to home_team_goal; home_team_goal = 10;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_short_name \nFROM Match m \nJOIN Team t ON m.home_team_api_id = t.team_api_id \nWHERE m.home_team_goal = 10;"
        ],
        "rule_sql": []
    },
    "54": {
        "question": "Please specify all of the schools and their related mailing zip codes that are under Avetik Atoian's administration.",
        "db_id": "california_schools",
        "ground_truth": "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian'",
        "amends": [
            "Do use `AND` logical operator instead of `OR` between the name condition pairs. Do remove the additional `OR` conditions for `AdmFName2`/`AdmLName2` and `AdmFName3`/`AdmLName3` instead of including them. Do simplify the `WHERE` clause to only check the first administrator fields instead of checking all three administrator positions. The amended query now correctly filters for records where both the first name and last name match in the primary administrator fields, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for schools under a specific administrator's administration: filter records where both the first administrator's first name and last name match the specified values exactly using AND logic between name conditions.\n2) When handling administrator name matching: use only the primary administrator fields (AdmFName1 and AdmLName1) instead of checking all administrator positions.\n3) When specifying exact name values: preserve the literal values 'Avetik' for first name and 'Atoian' for last name exactly as given, maintaining case and spelling.\n4) When selecting output columns: include both the school identifier and mailing zip code columns as requested.\nOutput columns (ordered): School, MailZip"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT School, MailZip FROM schools WHERE (AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian') OR (AdmFName2 = 'Avetik' AND AdmLName2 = 'Atoian') OR (AdmFName3 = 'Avetik' AND AdmLName3 = 'Atoian');",
            "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian';"
        ],
        "rule_sql": [
            "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian';"
        ]
    },
    "511": {
        "question": "What is the most common visual frame effects among the incredibly powerful foils?",
        "db_id": "card_games",
        "ground_truth": "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1",
        "amends": [
            "Do remove the `COUNT(frameEffects) AS effect_count` column from the SELECT list instead of including it, and do move the aggregate function `COUNT(frameEffects)` directly into the ORDER BY clause instead of referencing the alias `effect_count`. Do keep the same FROM source `cards`, WHERE filters `cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL`, GROUP BY clause `frameEffects`, and LIMIT 1, but do reference the aggregate function directly in ORDER BY instead of using the column alias. The amended query now correctly orders by the actual count value rather than an aliased column that would not be available in the ORDER BY clause of the original query structure, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the most common value of a column: count occurrences of that column's exact token and order by the count in descending order to find the highest frequency value.\n2) When filtering for specific entity types like \"incredibly powerful foils\": use the exact filter conditions shown in the amends where both cardKingdomFoilId and cardKingdomId are not null.\n3) When ordering by an aggregate result: reference the aggregate function directly in the ordering clause rather than using an alias from the select list.\n4) When limiting to the single most common result: take only the first row after ordering by count in descending order.\n5) When grouping by a categorical column: organize results by the exact column token frameEffects to count occurrences per distinct value.\n6) Output columns (ordered): frameEffects"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT frameEffects, COUNT(frameEffects) AS effect_count\nFROM cards\nWHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL\nGROUP BY frameEffects\nORDER BY effect_count DESC\nLIMIT 1;",
            "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT frameEffects\nFROM cards\nWHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL\nGROUP BY frameEffects\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "448": {
        "question": "Name the foreign name of the card that has abzan watermark? List out the type of this card.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'abzan'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do use table aliases `T1` and `T2` instead of `c` and `fd` for clarity. Do specify `INNER JOIN` explicitly instead of just `JOIN` to make the join type clear. Do reverse the join condition to `T2.uuid = T1.uuid` instead of `c.uuid = fd.uuid` while maintaining the same logical relationship. Do reference `T1.name` and `T1.type` instead of `fd.name AS foreign_name` and `c.type` to correctly select from the cards table rather than foreign_data. The amended query now correctly returns distinct card names and types from the cards table joined with foreign_data where the watermark condition is met, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"foreign name\" and \"type\" of a card: select T1.name and T1.type from the cards table (T1).\n2) When joining the cards table (T1) with foreign_data table (T2): use an inner match where T2.uuid = T1.uuid.\n3) When filtering for cards with abzan watermark: include only rows where T1.watermark equals 'abzan' exactly.\n4) When eliminating duplicate rows: use distinct selection to return unique combinations of the selected columns.\n5) Output columns (ordered): T1.name, T1.type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT fd.name AS foreign_name, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'abzan';",
            "SELECT DISTINCT T1.name, T1.type\nFROM cards T1\nINNER JOIN foreign_data T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'abzan'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name, T1.type\nFROM cards T1\nINNER JOIN foreign_data T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'abzan'"
        ]
    },
    "654": {
        "question": "Mention the display name and location of the user who owned the excerpt post with hypothesis-testing tag.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T3.DisplayName, T3.Location FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id INNER JOIN users AS T3 ON T3.Id = T2.OwnerUserId WHERE T1.TagName = 'hypothesis-testing'",
        "amends": [],
        "rules": [
            "user who owned the excerpt post with hypothesis-testing tag refers to OwnerUserId WHERE TagName = 'hypothesis-testing';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName, u.Location\nFROM tags t\nJOIN posts p ON t.ExcerptPostId = p.Id\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE t.TagName = 'hypothesis-testing';"
        ],
        "rule_sql": []
    },
    "1473": {
        "question": "What was the average monthly consumption of customers in SME for the year 2013?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT AVG(T2.Consumption) / 12 FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME'",
        "amends": [],
        "rules": [
            "Average Monthly consumption = AVG(Consumption) / 12; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(Consumption) / 12 AS AverageMonthlyConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Segment = 'SME' AND SUBSTR(ym.Date, 1, 4) = '2013';"
        ],
        "rule_sql": []
    },
    "1243": {
        "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
        "amends": [
            "Do use `CAST(SUM(...) AS REAL)` for precise division instead of implicit integer division. Do reference tables with aliases `T1` and `T2` instead of full table names. Do place the `PT >= 14` condition inside the CASE expression instead of in both numerator and denominator separately. Do use `COUNT(*)` in the denominator instead of `SUM(CASE WHEN L.PT >= 14 THEN 1 ELSE 0 END)` to count all joined records. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do use `CURRENT_TIMESTAMP` instead of `'now'` for the current time reference. Do remove the column alias `percentage_female_abnormal_PT` instead of keeping it. The amended query now correctly calculates the percentage using proper type casting and simplified counting logic."
        ],
        "rules": [
            "1) When calculating percentages with integer division: use CAST(SUM(...) AS REAL) for precise division instead of implicit integer division. 2) When referencing tables in joins: use aliases T1 and T2 instead of full table names, with T1 representing Patient and T2 representing Laboratory. 3) When filtering conditions for specific criteria: place the PT >= 14 condition inside the CASE expression for the numerator only. 4) When counting all records that meet join criteria: use COUNT(*) in the denominator instead of SUM(CASE WHEN condition THEN 1 ELSE 0 END). 5) When joining tables: use INNER JOIN explicitly instead of just JOIN. 6) When referencing current time for age calculations: use CURRENT_TIMESTAMP instead of 'now'. 7) When the question asks for a percentage without specifying an output column name: remove column aliases from the output. 8) When combining T1 (Patient) and T2 (Laboratory) for shared patients: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 9) When calculating age from birthday: compute (current year - birth year) > 55 for patients older than 55 years. 10) When counting female patients with abnormal PT: count cases where T1.SEX = 'F' and T2.PT >= 14. Output columns (ordered): (CAST(SUM(CASE WHEN T1.SEX = 'F' AND T2.PT >= 14 THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(*))"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN P.SEX = 'F' AND L.PT >= 14 THEN 1 ELSE 0 END) * 100.0 / \n    SUM(CASE WHEN L.PT >= 14 THEN 1 ELSE 0 END)) AS percentage_female_abnormal_PT\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 55;",
            "SELECT \n    CAST(SUM(CASE WHEN T1.SEX = 'F' AND T2.PT >= 14 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday)) > 55"
        ],
        "rule_sql": [
            "SELECT (CAST(SUM(CASE WHEN T1.SEX = 'F' AND T2.PT >= 14 THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(*)) FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday)) > 55"
        ]
    },
    "281": {
        "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
        "amends": [
            "Do use `DISTINCT T1.element` instead of `a.element, COUNT(*) AS tally` to return unique elements rather than counts. Do specify `FROM atom AS T1 INNER JOIN molecule AS T2` instead of `FROM molecule m JOIN atom a` to reverse the join direction and add explicit aliases. Do use `ON T1.molecule_id = T2.molecule_id` instead of `ON m.molecule_id = a.molecule_id` to maintain the same join logic with consistent aliases. Do keep `WHERE T2.label = '+'` instead of `WHERE m.label = '+'` with updated table reference. Do change to `SUBSTR(T1.atom_id, -1) = '4'` instead of `substr(a.atom_id, 7, 1) = '4'` to check the last character rather than position 7. Do add `AND LENGTH(T1.atom_id) = 7` instead of omitting this length validation. Do remove `GROUP BY a.element` instead of keeping it since aggregation is no longer needed. The amended query now correctly returns distinct elements meeting all specified conditions."
        ],
        "rules": [
            "1) When the question asks to tally toxicology elements: return distinct values of T1.element rather than counting them. 2) When joining atom and molecule tables: use T1 for atom and T2 for molecule with an inner match where T1.molecule_id equals T2.molecule_id. 3) When filtering for carcinogenic molecules: include only rows where T2.label equals '+'. 4) When identifying the 4th atom: include only rows where the last character of T1.atom_id equals '4' and the length of T1.atom_id is exactly 7. 5) When no aggregation is needed: do not group results. Output columns (ordered): T1.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.element, COUNT(*) AS tally\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+' AND substr(a.atom_id, 7, 1) = '4'\nGROUP BY a.element;",
            "SELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'\nAND SUBSTR(T1.atom_id, -1) = '4'\nAND LENGTH(T1.atom_id) = 7"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.element \nFROM atom T1 \nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.label = '+' \nAND LENGTH(T1.atom_id) = 7 \nAND SUBSTR(T1.atom_id, -1) = '4'"
        ]
    },
    "1477": {
        "question": "Which year recorded the most gas use paid in EUR?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUBSTRING(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY SUBSTRING(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do extract year using `SUBSTRING(T2.Date, 1, 4)` instead of `strftime('%Y', t.Date)` for date handling. Do join with `yearmonth AS T2` instead of `transactions_1k t` as the source table. Do use `INNER JOIN` with `T1.CustomerID = T2.CustomerID` instead of `JOIN` with `t.CustomerID = c.CustomerID` for the join condition. Do aggregate `SUM(T2.Consumption)` instead of `SUM(t.Amount)` for the calculation. Do order by `SUM(T2.Consumption) DESC` instead of `TotalGasUse DESC` using the actual aggregate expression rather than the alias. The amended query now correctly calculates annual gas consumption from the yearmonth table for EUR currency customers and matches the RIGHT_SQL behavior.",
            "Do reference `SUBSTRING(T2.Date, 1, 4)` directly in the GROUP BY clause instead of using the alias `Year`, as SQL requires grouping by the actual expression rather than column aliases. Do remove the column alias `AS Year` from the SELECT list instead of keeping it, since the RIGHT_SQL omits this explicit naming. Do remove the alias `AS TotalGasUse` from the aggregated column instead of including it, as the RIGHT_SQL returns the sum without an alias. The amended query now correctly groups by the year expression directly and matches RIGHT_SQL's behavior by returning unaliased results while maintaining the same aggregation logic and filtering conditions."
        ],
        "rules": [
            "1) When extracting year from a date column: use SUBSTRING(T2.Date, 1, 4) to get the 4-digit year from the beginning of the date string. 2) When joining tables for customer transactions: use INNER JOIN between customers as T1 and yearmonth as T2 where T1.CustomerID = T2.CustomerID. 3) When calculating gas consumption for EUR currency customers: aggregate using SUM(T2.Consumption) where T1.Currency = 'EUR'. 4) When ordering by aggregate results: use the actual aggregate expression SUM(T2.Consumption) DESC rather than an alias. 5) When grouping by year: use the extracted year from SUBSTRING(T2.Date, 1, 4) as the grouping key. 6) When finding the maximum value: order results in descending order and take the first result. Output columns (ordered): Year, TotalGasUse",
            "1) When the question asks for \"most gas use\" and requires ranking: rank years by total gas consumption in descending order and keep only the top 1 row.\n2) When filtering for payments in a specific currency: include only rows where T1.Currency equals exactly 'EUR'.\n3) When extracting year from a date field: use SUBSTRING(T2.Date, 1, 4) to get the year portion.\n4) When grouping by year: group by the exact SUBSTRING(T2.Date, 1, 4) expression rather than any alias.\n5) When computing total gas consumption: sum the T2.Consumption values for each group.\n6) When the query does not require explicit column aliases: return the year expression and sum without aliases.\n7) When combining T1 and T2 for customer data: link rows where T1.CustomerID equals T2.CustomerID and keep only matching pairs.\nOutput columns (ordered): SUBSTRING(T2.Date, 1, 4), SUM(T2.Consumption)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT strftime('%Y', t.Date) AS Year, SUM(t.Amount) AS TotalGasUse\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE c.Currency = 'EUR'\nGROUP BY Year\nORDER BY TotalGasUse DESC\nLIMIT 1;",
            "SELECT SUBSTRING(T2.Date, 1, 4) AS Year, SUM(T2.Consumption) AS TotalGasUse\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY Year\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
            "SELECT SUBSTRING(T2.Date, 1, 4) \nFROM yearmonth AS T2\nINNER JOIN customers AS T1 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY SUBSTRING(T2.Date, 1, 4)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT SUBSTRING(T2.Date, 1, 4) AS Year, SUM(T2.Consumption) AS TotalGasUse\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY SUBSTRING(T2.Date, 1, 4)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;"
        ]
    },
    "245": {
        "question": "What is the average number of bonds the atoms with the element iodine have?",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'i'",
        "amends": [
            "Do use `INNER JOIN` instead of `LEFT JOIN` to exclude atoms without bonds. Do join on `T1.atom_id = T2.atom_id` instead of the incorrect `OR` condition that included both join directions. Do remove the `DISTINCT` from `COUNT(T1.atom_id)` instead of counting distinct atom IDs since each bond connects to exactly one iodine atom. Do cast the bond count to `REAL` instead of multiplying by `1.0` for proper floating-point division. Do remove the unnecessary table aliases `a` and `c` instead of keeping them. The amended query now correctly calculates the average bonds per iodine atom by only counting actual bonds through proper inner joining and eliminates the double-counting issue from the original OR condition.",
            "Do calculate the average as `CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id)` instead of using `AVG(bond_count)` from a subquery. Do reference tables with aliases `T1` and `T2` instead of using unaliased table names. Do filter for element `'i'` instead of `'iodine'` to match the correct chemical symbol. Do remove the unnecessary subquery and `GROUP BY atom.atom_id` instead of keeping the nested aggregation structure. Do perform the division calculation directly in the main query instead of using an aggregate function on a subquery result. The amended query now correctly calculates the average bonds per iodine atom by counting bonds divided by atom count rather than averaging pre-counted bond values."
        ],
        "rules": [
            "1) When the question asks for average bonds per iodine atom: compute the ratio of total bonds to total iodine atoms with bonds. 2) When joining atom and connected tables: link rows where T1.atom_id equals T2.atom_id exactly and keep only matching pairs (inner match). 3) When filtering for iodine atoms: include only rows where T1.element equals 'i' exactly. 4) When counting bonds: count all T2.bond_id values. 5) When counting iodine atoms: count all T1.atom_id values (without distinct). 6) When computing the ratio: divide bond count by atom count using real number division. 7) Output columns (ordered): average_bonds_per_iodine_atom",
            "1) When the question asks for average number of bonds per atom with element iodine: calculate the ratio as CAST(COUNT(T2.bond_id) AS REAL) divided by COUNT(T1.atom_id) instead of using AVG on pre-counted values. 2) When filtering for iodine atoms: use the exact literal 'i' instead of 'iodine' to match the correct chemical symbol. 3) When combining atom and connected tables: link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner match). 4) When calculating averages directly: avoid unnecessary subqueries and GROUP BY operations that create nested aggregation structures. 5) Output columns (ordered): average_bonds"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(bond_id) * 1.0 / COUNT(DISTINCT a.atom_id) AS average_bonds_per_iodine_atom\nFROM atom a\nLEFT JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nWHERE a.element = 'i';",
            "SELECT AVG(bond_count) AS average_bonds\nFROM (\n    SELECT COUNT(connected.bond_id) AS bond_count\n    FROM atom\n    INNER JOIN connected ON atom.atom_id = connected.atom_id\n    WHERE atom.element = 'iodine'\n    GROUP BY atom.atom_id\n)",
            "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) AS average_bonds\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'i'"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) AS average_bonds_per_iodine_atom\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'i'"
        ]
    },
    "869": {
        "question": "For the constructor which got the highest point in the race No. 9 , what is its introduction website?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.url FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 9 ORDER BY T1.points DESC LIMIT 1",
        "amends": [],
        "rules": [
            "race number refers to raceId; constructor which got the highest point refers to MAX(constructorResults.points); introduction website of the constructor refers to url;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.url\nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nWHERE cr.raceId = 9\nORDER BY cr.points DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1299": {
        "question": "Among the patients with the normal level of triglyceride, how many of them have other symptoms observed?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows. Do reference `Examination AS T1` and `Laboratory AS T2` instead of `Patient P`, `Laboratory L`, and `Examination E` to join the correct tables. Do use `INNER JOIN` between Examination and Laboratory instead of joining both to Patient to properly relate test results. Do join on `T1.ID = T2.ID` instead of separate joins to Patient ID to directly connect examination and lab records. Do filter with `T2.TG < 200` and `T1.Symptoms IS NOT NULL` instead of the same conditions but on different table aliases. Do remove the Patient table entirely instead of including it since the count should be based on examination records with matching lab results. The amended query now correctly counts examination records that have corresponding laboratory results meeting the specified criteria."
        ],
        "rules": [
            "1) When counting patients with specific conditions: use COUNT(T1.ID) to count all matching rows instead of counting distinct IDs. 2) When relating examination and laboratory records: use Examination AS T1 and Laboratory AS T2 as the primary tables instead of joining through Patient. 3) When connecting examination and lab results: perform an INNER JOIN between T1 and T2 where T1.ID = T2.ID to directly match records. 4) When filtering for normal triglyceride levels: use T2.TG < 200 to identify patients with triglyceride below 200. 5) When checking for observed symptoms: use T1.Symptoms IS NOT NULL to identify patients with recorded symptoms. 6) When the question asks about patients with normal triglyceride levels having other symptoms: combine the conditions T2.TG < 200 AND T1.Symptoms IS NOT NULL. 7) Output columns (ordered): PatientCount"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.TG < 200 AND E.Symptoms IS NOT NULL;",
            "SELECT COUNT(T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) AS PatientCount\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL"
        ]
    },
    "65": {
        "question": "What is the ratio in percentage of Santa Clara County schools that are locally funded compared to all other types of charter school funding?",
        "db_id": "california_schools",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END) FROM schools WHERE County = 'Santa Clara' AND Charter = 1",
        "amends": [
            "Do use `SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN FundingType = 'Local' THEN 1 END)` to properly count matching rows with explicit ELSE 0. Do add `AND Charter = 1` to the WHERE clause instead of omitting this filter condition. Do calculate the ratio as `* 100 / SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END)` instead of `* 100.0 / COUNT(*)` to use the count of non-matching rows as the denominator rather than total rows. Do add explicit `CAST(... AS REAL)` instead of relying on decimal notation for proper floating-point division. The amended query now correctly calculates the percentage of locally funded charter schools in Santa Clara County."
        ],
        "rules": [
            "1) When the question asks for a ratio percentage of schools with specific funding type: compute (number of rows where FundingType equals 'Locally funded') multiplied by 100 divided by (number of rows where FundingType does not equal 'Locally funded'), using explicit casting to real numbers for floating-point division. 2) When counting rows matching a specific condition: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) to ensure proper counting with explicit ELSE 0. 3) When filtering for charter schools: include Charter = 1 in the filter conditions. 4) When the question specifies Santa Clara County: filter rows where County equals 'Santa Clara'. 5) Output columns (ordered): ratio_percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN FundingType = 'Local' THEN 1 END) * 100.0 / COUNT(*)) AS ratio_percentage\nFROM \n    schools\nWHERE \n    County = 'Santa Clara';",
            "SELECT \n    CAST(SUM(CASE WHEN s.FundingType = 'Locally funded' THEN 1 ELSE 0 END) * 100.0 / \n         SUM(CASE WHEN s.FundingType != 'Locally funded' THEN 1 ELSE 0 END) AS REAL) AS ratio_percentage\nFROM schools s\nWHERE s.County = 'Santa Clara' AND s.Charter = 1;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) AS REAL) * 100.0 / \n     CAST(SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END) AS REAL)) AS ratio_percentage\nFROM schools\nWHERE County = 'Santa Clara' AND Charter = 1;"
        ]
    },
    "140": {
        "question": "How many accounts are there in the district of \"Pisek\"?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Pisek'",
        "amends": [],
        "rules": [
            "A2 refers to district name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS account_count\nFROM account\nJOIN district ON account.district_id = district.district_id\nWHERE district.A2 = 'Pisek';"
        ],
        "rule_sql": []
    },
    "982": {
        "question": "How many American drivers have puncture status.",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN results AS T2 on T1.driverId = T2.driverId INNER JOIN status AS T3 on T2.statusId = T3.statusId WHERE T3.status = 'Puncture' AND T1.nationality = 'American'",
        "amends": [],
        "rules": [
            "puncture status refers to status = Puncture;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT d.driverId) AS american_drivers_with_puncture\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN status s ON r.statusId = s.statusId\nWHERE d.nationality = 'American' AND s.status = 'Puncture';"
        ],
        "rule_sql": []
    },
    "453": {
        "question": "What's the unconverted mana cost of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
        "amends": [
            "Do select `manaCost` instead of `convertedManaCost` and add `DISTINCT` instead of omitting it. Do use escaped apostrophes `''` in the string literal instead of a backtick `'` for the name filter condition. The amended query now correctly retrieves distinct mana cost values with proper string escaping."
        ],
        "rules": [
            "1) When the question asks for \"unconverted mana cost\": use the exact column token \"manaCost\" from table cards instead of \"convertedManaCost\". 2) When filtering for a specific card name with apostrophes: use escaped apostrophes '' in the string literal exactly as 'Ancestor''s Chosen' instead of using backticks or single apostrophes. 3) When retrieving values that may have duplicates: use DISTINCT to return only unique values. 4) Output columns (ordered): manaCost"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT convertedManaCost FROM cards WHERE name = 'Ancestor`s Chosen';",
            "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen';"
        ],
        "rule_sql": [
            "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'"
        ]
    },
    "833": {
        "question": "Name the superhero, otherwise known as Charles Chandler.",
        "db_id": "superhero",
        "ground_truth": "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler'",
        "amends": [],
        "rules": [
            "name the superhero refers to superhero_name; Charles Chandler is the full name of superhero;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';"
        ],
        "rule_sql": []
    },
    "286": {
        "question": "Among all chemical compounds identified in the database, what percent of compounds form a triple-bond.",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for total counts. Do calculate percentage directly using `COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END)` instead of counting distinct molecules with triple bonds. Do operate on the `bond` table directly instead of joining with the `molecule` table. Do use `COUNT(T.bond_id)` as the denominator instead of counting distinct molecules. Do cast the result to `REAL` instead of using decimal multiplication. Do remove the CTE structure and perform all calculations in the main SELECT instead of using cross-joined CTEs. The amended query now correctly calculates the percentage of triple bonds among all bonds rather than the percentage of molecules containing triple bonds, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating percentage of bonds that are triple bonds: compute (number of triple bonds) divided by (total number of bonds) and multiply by 100. 2) When identifying triple bonds: use the exact literal '#' for bond_type comparison. 3) When counting bonds: use T.bond_id as the counting key for both numerator and denominator. 4) When performing conditional counting: use CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END to count only triple bonds. 5) When casting the result: convert the percentage to REAL data type. 6) When operating on bond data: work directly on the bond table without joining to other tables. 7) Output columns (ordered): the calculated percentage value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH total_molecules AS (\n  SELECT COUNT(DISTINCT molecule_id) AS total\n  FROM molecule\n),\nmolecules_with_triple_bond AS (\n  SELECT COUNT(DISTINCT m.molecule_id) AS triple_bond_count\n  FROM molecule m\n  JOIN bond b ON m.molecule_id = b.molecule_id\n  WHERE b.bond_type = '#'\n)\nSELECT (triple_bond_count * 100.0 / total) AS percent_triple_bond\nFROM total_molecules, molecules_with_triple_bond;",
            "SELECT \n    CAST(COUNT(CASE WHEN bond_type = '#' THEN bond_id ELSE NULL END) AS REAL) * 100.0 / COUNT(bond_id) AS percentage\nFROM bond;"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN bond_type = '#' THEN bond_id ELSE NULL END) * 100.0 / COUNT(bond_id)) AS percentage\nFROM \n    bond"
        ]
    },
    "1419": {
        "question": "What is the category of event which was taken place in 2020-03-24T12:00:00?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_date = '2020-03-24T12:00:00'",
        "amends": [
            "Do select `T2.category` instead of `type` from the event table. Do add an `INNER JOIN` with the `budget` table as `T2` on `T1.event_id = T2.link_to_event` instead of querying only the event table. Do use table alias `T1` for the event table instead of no alias. The amended query now correctly joins to retrieve category information from the budget table rather than selecting type directly from event, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"category of event\": select T2.category instead of type from the event table. 2) When combining the event table with the budget table: link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match). 3) When the question specifies a timestamp \"2020-03-24T12:00:00\": filter rows where T1.event_date equals exactly '2020-03-24T12:00:00'. 4) When using table aliases: use T1 for the event table and T2 for the budget table. 5) Output columns (ordered): T2.category"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type FROM event WHERE event_date = '2020-03-24T12:00:00';",
            "SELECT T2.category \nFROM event T1 \nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_date = '2020-03-24T12:00:00'"
        ],
        "rule_sql": [
            "SELECT T2.category FROM event T1 INNER JOIN budget T2 ON T1.event_id = T2.link_to_event WHERE T1.event_date = '2020-03-24T12:00:00'"
        ]
    },
    "1063": {
        "question": "What is Aaron Doran's potential score?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
        "amends": [
            "Do select only `potential` instead of including `player_name` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `t1` and `t2` instead of implicit table names `p` and `pa`. Do reference `t2.potential` instead of `pa.potential` to correctly specify the source table. The amended query now matches RIGHT_SQL's behavior by focusing solely on retrieving the potential attribute from the joined tables."
        ],
        "rules": [
            "1) When the question asks for a specific player's attribute: filter rows where t1.player_name equals exactly 'Aaron Doran'. 2) When combining Player and Player_Attributes tables: link rows where t1.player_api_id equals t2.player_api_id using an inner match. 3) When selecting output columns: include only t2.potential in the result. 4) Output columns (ordered): t2.potential"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.potential\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Aaron Doran';",
            "SELECT t2.potential FROM Player t1 INNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'"
        ],
        "rule_sql": [
            "SELECT t2.potential FROM Player t1 INNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'"
        ]
    },
    "829": {
        "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "amends": [],
        "rules": [
            "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; difference = SUBTRACT(SUM(publisher_name = 'DC Comics'), SUM(publisher_name = 'Marvel Comics'));"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'DC Comics')) - \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) AS difference;"
        ],
        "rule_sql": []
    },
    "635": {
        "question": "How many posts by Matt Parker have more than 4 votes?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id INNER JOIN votes AS T4 ON T4.PostId = T3.Id WHERE T1.DisplayName = 'Matt Parker' GROUP BY T2.PostId, T4.Id HAVING COUNT(T4.Id) > 4",
        "amends": [
            "Do use `INNER JOIN` with `postHistory` table on `T1.Id = T2.UserId` instead of directly joining `posts` to `users`. Do join `posts` through `postHistory` via `T2.PostId = T3.Id` instead of directly on `u.Id = p.OwnerUserId`. Do change the vote join to `T4.PostId = T3.Id` instead of `p.Id = v.PostId`. Do remove the `DISTINCT` from the count and change to `COUNT(T1.Id)` instead of `COUNT(DISTINCT p.Id)`. Do modify the GROUP BY to `T2.PostId, T4.Id` instead of just `p.Id`. Do keep the HAVING condition `COUNT(T4.Id) > 4` but reference the correct vote table. The amended query now correctly navigates the user-post-vote relationship through the postHistory table and produces the intended result set."
        ],
        "rules": [
            "1) When the question asks for posts by a specific user with name 'Matt Parker': filter users where T1.DisplayName equals 'Matt Parker' exactly.\n2) When combining user and post information through postHistory: link rows where T1.Id equals T2.UserId and T2.PostId equals T3.Id (inner match).\n3) When counting votes for posts: link votes where T4.PostId equals T3.Id (inner match).\n4) When counting posts that meet vote criteria: count T1.Id (user identifier) without using DISTINCT.\n5) When grouping for vote count analysis: group by both T2.PostId and T4.Id to ensure correct vote counting per post.\n6) When filtering for posts with more than 4 votes: keep only groups where the count of T4.Id is greater than 4.\nOutput columns (ordered): PostCount"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.Id) AS PostCount\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nJOIN votes v ON p.Id = v.PostId\nWHERE u.DisplayName = 'Matt Parker'\nGROUP BY p.Id\nHAVING COUNT(v.Id) > 4;",
            "SELECT COUNT(T3.Id) \nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nINNER JOIN votes T4 ON T4.PostId = T3.Id\nWHERE T1.DisplayName = 'Matt Parker'\nGROUP BY T2.PostId, T4.Id\nHAVING COUNT(T4.Id) > 4"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) AS PostCount\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nINNER JOIN votes T4 ON T3.Id = T4.PostId\nWHERE T1.DisplayName = 'Matt Parker'\nGROUP BY T2.PostId, T4.Id\nHAVING COUNT(T4.Id) > 4"
        ]
    },
    "177": {
        "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
        "db_id": "financial",
        "ground_truth": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    t.balance AS sum_after_transaction,\n    c.gender AS account_owner_gender\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    client c ON d.client_id = c.client_id\nWHERE \n    c.client_id = 4\n    AND t.trans_id = 851;"
        ],
        "rule_sql": []
    },
    "1351": {
        "question": "What was Brent Thomason's major?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'",
        "amends": [],
        "rules": [
            "Brent Thomason is the full name; full name refers to first_name, last_name; major refers to major_name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.major_name \nFROM member mb \nJOIN major m ON mb.link_to_major = m.major_id \nWHERE mb.first_name = 'Brent' AND mb.last_name = 'Thomason';"
        ],
        "rule_sql": []
    },
    "816": {
        "question": "Provide the names of superheroes with attribute value between 75 to 80.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T2.attribute_value BETWEEN 75 AND 80",
        "amends": [],
        "rules": [
            "names of superheroes refers to superhero_name; attribute value between 75 to 80 refers to attribute_value BETWEEN 75 AND 80;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nWHERE ha.attribute_value BETWEEN 75 AND 80;"
        ],
        "rule_sql": []
    },
    "782": {
        "question": "List the heroes' names whose eyes and hair colours are both black.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id WHERE T2.colour = 'Black'",
        "amends": [],
        "rules": [
            "heroes' names refers to superhero_name; eyes and hair colours are both black refers to eye_colour_id AND hair_colour_id WHERE colour.colour = 'Black';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id\nWHERE eye_colour.colour = 'Black' AND hair_colour.colour = 'Black';"
        ],
        "rule_sql": []
    },
    "91": {
        "question": "The average unemployment ratio of 1995 and 1996, which one has higher percentage?",
        "db_id": "financial",
        "ground_truth": "SELECT DISTINCT IIF(AVG(A13) > AVG(A12), '1996', '1995') FROM district",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to return only unique comparison results. Do use `IIF(AVG(A13) > AVG(A12), '1996', '1995')` instead of a verbose `CASE` statement with multiple branches and redundant text output. Do remove the explicit column aliases `avg_unemployment_1995` and `avg_unemployment_1996` instead of keeping them since they're not needed in the final output. Do simplify the comparison logic to directly return the year with higher unemployment instead of descriptive text phrases. The amended query now correctly returns only distinct year identifiers indicating which year had higher average unemployment, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for average values of specific columns A12 and A13: compute the average of column A12 and the average of column A13 from table district. 2) When comparing two average values to determine which is higher: use IIF(AVG(A13) > AVG(A12), '1996', '1995') to return the year identifier of the higher average. 3) When ensuring unique comparison results: use DISTINCT to return only one row with the comparison result. 4) When the output only needs to show which year has higher unemployment: do not include explicit column aliases for the average calculations. 5) Output columns (ordered): the result of IIF(AVG(A13) > AVG(A12), '1996', '1995')"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    AVG(A12) AS avg_unemployment_1995,\n    AVG(A13) AS avg_unemployment_1996,\n    CASE \n        WHEN AVG(A12) > AVG(A13) THEN '1995 has a higher average unemployment rate'\n        WHEN AVG(A12) < AVG(A13) THEN '1996 has a higher average unemployment rate'\n        ELSE 'Both years have the same average unemployment rate'\n    END AS comparison\nFROM district;",
            "SELECT DISTINCT IIF(AVG(CASE WHEN strftime('%Y', date) = '1995' THEN A13 END) > AVG(CASE WHEN strftime('%Y', date) = '1996' THEN A13 END), '1996', '1995') AS higher_year FROM district d JOIN account a ON d.district_id = a.district_id WHERE strftime('%Y', a.date) IN ('1995', '1996')"
        ],
        "rule_sql": [
            "SELECT DISTINCT IIF(AVG(A13) > AVG(A12), '1996', '1995') FROM district;"
        ]
    },
    "563": {
        "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.CreationDate = '2014-04-23 20:29:39.0' AND T2.UserId = 3025",
        "amends": [
            "Do reference `posts` as `T1` and `comments` as `T2` instead of using original table names. Do use `INNER JOIN` with explicit `AS` aliases instead of simple `JOIN` without aliases. Do specify the join condition as `T1.Id = T2.PostId` instead of `c.PostId = p.Id` to maintain proper table reference consistency. Do place the `CreationDate` filter before the `UserId` filter in the `WHERE` clause instead of the reverse order. Do format the date literal as `'2014-04-23 20:29:39.0'` with hyphens instead of `'2014/4/23 20:29:39.0'` with slashes and inconsistent month padding. The amended query now correctly retrieves the FavoriteCount from posts based on the specified comment criteria."
        ],
        "rules": [
            "1) When the question asks about a comment from a specific user at a specific time: filter comments table (T2) where T2.UserId equals 3025 and T2.CreationDate equals '2014-04-23 20:29:39.0' exactly.\n2) When combining comments and posts tables: link rows where T1.Id equals T2.PostId using an inner match.\n3) When retrieving favorite counts for a post: select T1.FavoriteCount from the posts table.\n4) When formatting date literals: use 'YYYY-MM-DD HH:MM:SS.S' format with hyphens and consistent month padding instead of slashes.\n5) When ordering filter conditions: place date filters before user ID filters in the WHERE clause.\n6) Output columns (ordered): T1.FavoriteCount"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.FavoriteCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE c.UserId = 3025 AND c.CreationDate = '2014/4/23 20:29:39.0';",
            "SELECT T1.FavoriteCount \nFROM posts AS T1 \nINNER JOIN comments AS T2 ON T1.Id = T2.PostId \nWHERE T2.CreationDate = '2014-04-23 20:29:39.0' \nAND T2.UserId = 3025"
        ],
        "rule_sql": [
            "SELECT T1.FavoriteCount \nFROM posts T1\nINNER JOIN comments T2 ON T1.Id = T2.PostId\nWHERE T2.CreationDate = '2014-04-23 20:29:39.0'\nAND T2.UserId = 3025"
        ]
    },
    "115": {
        "error": "something went wrong, tool did not call.",
        "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
        "db_id": "financial",
        "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Percentage of the male clients = DIVIDE(COUNT(male clients), COUNT(clients)) * 100; Male refers to gender = 'M', A3 is the region name. A4 contains the information about inhabitants."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH max_inhabitants_district AS (\n    SELECT district_id\n    FROM district\n    WHERE A3 = 'south Bohemia'\n    ORDER BY A4 DESC\n    LIMIT 1\n),\nclient_counts AS (\n    SELECT \n        COUNT(*) AS total_clients,\n        SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) AS male_clients\n    FROM client\n    WHERE district_id = (SELECT district_id FROM max_inhabitants_district)\n)\nSELECT \n    (male_clients * 100.0 / total_clients) AS male_percentage\nFROM client_counts;"
        ],
        "rule_sql": []
    },
    "502": {
        "question": "What is the release date for the set \"Ola de fr\u00edo\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.releaseDate FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Ola de fr\u00edo'",
        "amends": [],
        "rules": [
            "release date is the date of card set being released; set \"Ola de fr\u00edo\" refers to translation = 'Ola de fr\u00edo'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.releaseDate \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Ola de fr\u00edo';"
        ],
        "rule_sql": []
    },
    "125": {
        "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
        "db_id": "financial",
        "ground_truth": "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
        "amends": [
            "Do calculate `(A13 - A12) * 100 / A12` instead of `((A13 - A12) / A12) * 100` to ensure proper mathematical precedence. Do join `account` table instead of `disp` and `client` tables, connecting `loan` to `district` through `account.district_id` instead of through `disp.client_id` and `client.district_id`. Do remove the explicit `GROUP BY` clause instead of keeping unnecessary grouping when no aggregation is performed. Do cast `(A13 - A12)` to `REAL` instead of using integer division which could truncate decimal results. Do use `INNER JOIN` consistently instead of mixing `JOIN` without explicit type specification. The amended query now correctly calculates unemployment rate percentage using proper mathematical operations and eliminates unnecessary table joins and grouping.",
            "Do remove `d.A2 AS district_name` and `d.A3 AS district_state` from the SELECT list instead of including them. Do change the unemployment rate calculation to reference `T3.A13` and `T3.A12` instead of `d.A13` and `d.A12` while maintaining the same CAST expression. Do use table aliases `T1` for loan, `T2` for account, and `T3` for district instead of the original table names. Do change the WHERE filter to `T1.status = 'D'` instead of `l.status = 'Running'`. The amended query now correctly calculates the unemployment rate increment percentage for loans with status 'D' while removing unnecessary district information from the output."
        ],
        "rules": [
            "1) When calculating percentage increment from year 1995 to 1996: compute (A13 - A12) * 100 / A12 instead of ((A13 - A12) / A12) * 100 to ensure proper mathematical precedence.\n2) When connecting loan contracts to district information: link loan to account using account_id, then link account to district using district_id instead of going through disp and client tables.\n3) When no aggregation is performed in the output: remove explicit GROUP BY clauses to avoid unnecessary grouping.\n4) When performing division operations that could result in decimal values: cast the numerator (A13 - A12) to REAL type instead of using integer division which could truncate results.\n5) When joining tables: use INNER JOIN consistently instead of mixing JOIN without explicit type specification.\n6) When filtering for loans that are still running where clients are in debt: use status = 'D' as the condition.\nOutput columns (ordered): d.A2, d.A3, (A13 - A12) * 100 / A12",
            "1) When the question asks for percentage unemployment rate increment from year 1995 to 1996: calculate (T3.A13 - T3.A12) * 100 / T3.A12 as the unemployment rate increment percentage.\n2) When filtering for loans with status indicating clients are in debt: use T1.status = 'D' as the filter condition.\n3) When combining loan, account, and district tables: link T1 to T2 using T1.account_id = T2.account_id, and link T2 to T3 using T2.district_id = T3.district_id, keeping only matching pairs (inner match).\n4) When the question does not require district name or state information: exclude T3.A2 and T3.A3 from the output columns.\n5) Output columns (ordered): (T3.A13 - T3.A12) * 100 / T3.A12"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    d.A2 AS district_name,\n    d.A3 AS state,\n    ((d.A13 - d.A12) / d.A12) * 100 AS unemployment_rate_increment_percentage\nFROM \n    loan l\nJOIN \n    disp dp ON l.account_id = dp.account_id\nJOIN \n    client c ON dp.client_id = c.client_id\nJOIN \n    district d ON c.district_id = d.district_id\nWHERE \n    l.status = 'D'\nGROUP BY \n    d.A2, d.A3, d.A12, d.A13;",
            "SELECT \n    d.A2 AS district_name,\n    d.A3 AS district_state,\n    CAST((d.A13 - d.A12) AS REAL) * 100 / d.A12 AS unemployment_rate_increment_percentage\nFROM \n    loan l\nINNER JOIN \n    account a ON l.account_id = a.account_id\nINNER JOIN \n    district d ON a.district_id = d.district_id\nWHERE \n    l.status = 'Running'",
            "SELECT \n    CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 AS unemployment_rate_increment\nFROM \n    loan T1\nINNER JOIN \n    account T2 ON T1.account_id = T2.account_id\nINNER JOIN \n    district T3 ON T2.district_id = T3.district_id\nWHERE \n    T1.status = 'D'"
        ],
        "rule_sql": [
            "SELECT \n    (d.A13 - d.A12) * 100.0 / d.A12 AS unemployment_rate_increment\nFROM \n    loan l\nINNER JOIN \n    account a ON l.account_id = a.account_id\nINNER JOIN \n    district d ON a.district_id = d.district_id\nWHERE \n    l.status = 'D'"
        ]
    },
    "1072": {
        "question": "What is the average overall rating of the football player Aaron Doran?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
        "amends": [],
        "rules": [
            "average overall rating = AVG(overall_rating);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Aaron Doran');"
        ],
        "rule_sql": []
    },
    "1122": {
        "question": "State the name of the most strongest player.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)",
        "amends": [],
        "rules": [
            "strongest players refers to player has MAX(overall_rating)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);"
        ],
        "rule_sql": []
    },
    "1158": {
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "amends": [
            "Do select only `T1.ID` instead of multiple columns including `P.ID`, `P.SEX`, `P.Birthday`, `P.Description`, `P.First Date`, `P.Admission`, and `P.Diagnosis`. Do use table aliases `T1` and `T2` instead of `P` and `L`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T1.Birthday` instead of `P.Birthday` in the STRFTIME function. Do reference `T2.T-CHO` instead of `L.T-CHO` in the filter condition. The amended query now correctly returns only patient IDs matching the specified criteria.",
            "Do add `DISTINCT` to the SELECT list instead of omitting it. Do change the WHERE condition from `T2.\"T-CHO\" IS NOT NULL AND (T2.\"T-CHO\" < 120 OR T2.\"T-CHO\" > 200)` to `T2.\"T-CHO\" >= 250` instead of the previous range-based filtering. The amended query now correctly returns distinct patient IDs with high cholesterol values rather than those outside the normal range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for patients with specific criteria: select only T1.ID as the output column. 2) When extracting year from a date column: use strftime('%Y', T1.Birthday) to get the year component. 3) When filtering for patients born in a specific year: match strftime('%Y', T1.Birthday) exactly to '1937'. 4) When checking for abnormal cholesterol levels: filter where T2.\"T-CHO\" is greater than or equal to 250. 5) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner join. 6) Output columns (ordered): T1.ID",
            "1) When the question asks for patients born in a specific year: filter rows where the year part of T1.Birthday equals '1937' exactly. 2) When the question asks for patients with total cholesterol beyond normal range: filter rows where T2.\"T-CHO\" is greater than or equal to 250. 3) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match). 4) When selecting patient identifiers: return distinct values of T1.ID to avoid duplicates. Output columns (ordered): T1.ID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT P.ID, P.SEX, P.Birthday, P.Description, P.`First Date`, P.Admission, P.Diagnosis\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE strftime('%Y', P.Birthday) = '1937'\nAND L.`T-CHO` >= 250;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.Birthday) = '1937'\nAND T2.`T-CHO` IS NOT NULL\nAND (T2.`T-CHO` < 120 OR T2.`T-CHO` > 200);",
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE strftime('%Y', T1.Birthday) = '1937'\nAND T2.\"T-CHO\" >= 250"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE strftime('%Y', T1.Birthday) = '1937'\nAND T2.\"T-CHO\" >= 250"
        ]
    },
    "1291": {
        "question": "How many male patients have a normal level of both albumin and total protein?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M'  AND T2.ALB > 3.5 AND T2.ALB < 5.5 AND T2.TP BETWEEN 6.0 AND 8.5",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T2.ALB` and `T2.TP` instead of `L.ALB` and `L.TP` to match the table alias change. The amended query now correctly counts all patient records meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior.",
            "Do use `SEX = 'M'` instead of `SEX = 'male'` for the gender filter. Do change the ALB condition to `ALB > 3.5 AND ALB < 5.5` instead of `ALB BETWEEN 3.5 AND 5.0` to expand the upper bound. Do adjust the TP range to `TP BETWEEN 6.0 AND 8.5` instead of `TP BETWEEN 6.0 AND 8.0` to include higher values. The amended query now correctly matches the intended filtering criteria and behavior of the RIGHT_SQL."
        ],
        "rules": [
            "1) When counting patients that meet specific laboratory criteria: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs. 2) When combining Patient and Laboratory tables: use INNER JOIN to link rows where T1.ID = T2.ID and keep only matching pairs. 3) When filtering for male patients: use the exact literal 'M' for T1.SEX. 4) When filtering for normal albumin levels: use T2.ALB > 3.5 AND T2.ALB < 5.5. 5) When filtering for normal total protein levels: use T2.TP BETWEEN 6.0 AND 8.5. 6) When choosing table aliases: use T1 for Patient table and T2 for Laboratory table. 7) Output columns (ordered): COUNT(T1.ID)",
            "1) When filtering for male patients: use T1.SEX = 'M' instead of 'male' for gender criteria. 2) When checking for normal albumin levels: use ALB > 3.5 AND ALB < 5.5 instead of BETWEEN 3.5 AND 5.0. 3) When checking for normal total protein levels: use TP BETWEEN 6.0 AND 8.5 instead of BETWEEN 6.0 AND 8.0. 4) When counting patients with normal lab values: count using T1.ID as the canonical patient identifier. 5) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID to find matching patient-lab pairs. 6) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' \nAND L.ALB > 3.5 AND L.ALB < 5.5 \nAND L.TP BETWEEN 6.0 AND 8.5;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'male' \nAND T2.ALB BETWEEN 3.5 AND 5.0 \nAND T2.TP BETWEEN 6.0 AND 8.0",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.ALB > 3.5 AND T2.ALB < 5.5\nAND T2.TP BETWEEN 6.0 AND 8.5"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.ALB > 3.5 AND T2.ALB < 5.5\nAND T2.TP BETWEEN 6.0 AND 8.5"
        ]
    },
    "1220": {
        "question": "Provide all ID, sex and birthday of patients whose urea nitrogen (UN) just within the borderline of passing?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN = 29",
        "amends": [],
        "rules": [
            "urea nitrogen (UN) just within the borderline of passing refers to UN = 29; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.UN = 29;"
        ],
        "rule_sql": []
    },
    "284": {
        "question": "Determine the bond type that is formed in the chemical compound containing element Carbon.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'",
        "amends": [
            "Do select only `DISTINCT T2.bond_type` instead of `b.bond_type, COUNT(*) AS count` with aggregation. Do use `atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id` instead of joining through `connected` table with multiple `atom` joins on `atom_id` and `bond` on `bond_id`. Do apply filter `WHERE T1.element = 'c'` instead of `WHERE a1.element = 'c' OR a2.element = 'c'`. Do remove `GROUP BY b.bond_type` and aggregation entirely instead of keeping it. The amended query now correctly finds distinct bond types associated with carbon atoms by directly joining atom to bond via molecule_id instead of the complex connected table path."
        ],
        "rules": [
            "1) When the question asks for distinct bond types associated with carbon atoms: select only distinct values of T2.bond_type instead of counting with aggregation. 2) When joining atom and bond tables: use T1.molecule_id = T2.molecule_id as the join condition instead of joining through the connected table with atom_id and bond_id. 3) When filtering for carbon atoms: apply the condition T1.element = 'c' instead of checking both atoms in a bond. 4) When the question does not require aggregation: remove GROUP BY and COUNT operations entirely. Output columns (ordered): T2.bond_type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_type, COUNT(*) AS count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a1.element = 'c' OR a2.element = 'c'\nGROUP BY b.bond_type;",
            "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.bond_type FROM atom T1 JOIN bond T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'"
        ]
    },
    "856": {
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.time \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.name = 'Sepang International Circuit';"
        ],
        "rule_sql": []
    },
    "181": {
        "question": "Please provide the IDs of the 3 female clients with the largest loans.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T4 on T1.client_id= T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id  INNER JOIN loan AS T3 ON T2.account_id = T3.account_id and T4.account_id = T3.account_id WHERE T1.gender = 'F' ORDER BY T3.amount DESC LIMIT 3",
        "amends": [],
        "rules": [
            "Female refers to gender = 'F'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.gender = 'F'\nORDER BY l.amount DESC\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "366": {
        "question": "What is the rule of playing card \"Benalish Knight\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "amends": [
            "Do select `T2.format` instead of `r.text` and use table alias `T1` for cards instead of `c`. Do join `legalities AS T2` instead of `rulings r` and use `INNER JOIN` instead of `JOIN` with the same join condition `ON T1.uuid = T2.uuid` instead of `ON r.uuid = c.uuid`. Do keep the WHERE filter `T1.name = 'Benalish Knight'` unchanged. The amended query now correctly retrieves format information from the legalities table instead of text from rulings, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the rule of a playing card: retrieve the format information from the legalities table instead of text from rulings. 2) When joining cards and legalities tables: use an inner join where T1.uuid = T2.uuid to match corresponding records. 3) When filtering for a specific card name: use the exact literal 'Benalish Knight' with T1.name. 4) Output columns (ordered): T2.format"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Benalish Knight';",
            "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'"
        ],
        "rule_sql": [
            "SELECT T2.format FROM cards T1 INNER JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'"
        ]
    },
    "416": {
        "question": "What percentage of cards without power are in French?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power = '*'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END)` with explicit ELSE 0 instead of `COUNT(CASE WHEN fd.language = 'French' THEN 1 END)` to properly count only French records. Do cast the sum to `REAL` before division instead of using `* 100.0` to ensure floating-point arithmetic. Do use `INNER JOIN` instead of `LEFT JOIN` to exclude cards without foreign data. Do count `T1.id` instead of `COUNT(*)` to avoid counting null rows from the join. Do reference tables with aliases `T1` and `T2` instead of `c` and `fd` for clarity. The amended query now correctly calculates the percentage of French cards while excluding non-matching records and ensuring proper numeric handling.",
            "Do cast the SUM result as REAL instead of using implicit casting with 100.0. Do use the literal string '*' instead of empty string '' in the WHERE condition for T1.power comparison. Do remove the column alias percentage instead of keeping it. The amended query now correctly handles the power field comparison and ensures proper numeric casting for the percentage calculation.",
            "Do cast the SUM result as REAL instead of using implicit casting with 100.0. Do change the WHERE filter to `T1.power IS NULL OR T1.power = '*'` instead of only `T1.power = '*'` to include NULL values. Do remove the parentheses around the entire calculation instead of keeping them, as they are unnecessary for the mathematical operation order. The amended query now correctly handles NULL power values and ensures proper numeric casting for accurate percentage calculation."
        ],
        "rules": [
            "1) When calculating percentages with conditional counting: use SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) with explicit ELSE 0 instead of COUNT(CASE) to properly count only matching records.\n2) When performing floating-point division: cast the numerator to REAL before division instead of using multiplication by 100.0 to ensure proper numeric handling.\n3) When combining tables where only matching records are needed: use INNER JOIN instead of LEFT JOIN to exclude non-matching records from the result.\n4) When counting rows after joining tables: count T1.id instead of using COUNT(*) to avoid counting null rows that may result from the join operation.\n5) When the question asks for percentage of cards without power that are in French: compute (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) cast as REAL) divided by (COUNT(T1.id)) where cards have no power (T1.power IS NULL OR T1.power = '*').\n6) When combining T1 and T2 for shared entities: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match).\nOutput columns (ordered): percentage",
            "1) When the question asks for a percentage of cards without power that are in French: compute (number of cards with T2.language = 'French' and without power) divided by (total number of cards without power), guarding division by zero.\n2) When checking for cards without power: use the condition T1.power = '*' exactly as specified in the amends.\n3) When combining cards and foreign_data tables: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match).\n4) When computing the percentage: cast the result as REAL type for proper numeric representation.\n5) When producing output: do not include column aliases in the final result.\n6) Output columns (ordered): (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id))",
            "1) When the question asks for a percentage calculation: cast the sum result as REAL instead of using implicit casting with 100.0. 2) When filtering for cards without power: use T1.power IS NULL OR T1.power = '*' instead of only T1.power = '*' to include NULL values. 3) When performing mathematical operations: remove unnecessary parentheses around the entire calculation as they are not needed for operation order. 4) When counting cards without power: use T1.id as the counting key. 5) When identifying French cards: use T2.language = 'French' as the condition. 6) When combining cards and foreign_data tables: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match). Output columns (ordered): (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id))"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN fd.language = 'French' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM cards c\nLEFT JOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.power IS NULL OR c.power = '*';",
            "SELECT \n    (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    cards T1\nINNER JOIN \n    foreign_data T2 ON T1.uuid = T2.uuid\nWHERE \n    T1.power IS NULL OR T1.power = '';",
            "SELECT (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) FROM cards T1 INNER JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T1.power = '*';",
            "SELECT (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) \nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.power IS NULL OR T1.power = '*';"
        ],
        "rule_sql": [
            "SELECT (CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(T1.id)) \nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.power IS NULL OR T1.power = '*';"
        ]
    },
    "1448": {
        "question": "Find the name and date of events with expenses for pizza that were more than fifty dollars but less than a hundred dollars.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.event_name, T1.event_date FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.expense_description = 'Pizza' AND T3.cost > 50 AND T3.cost < 100",
        "amends": [],
        "rules": [
            "name of event refers to event_name; date of event refers to event_date; expenses for pizza refers to expense_description = 'Pizza' where cost > 50 and cost < 100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name, e.event_date\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.expense_description LIKE '%pizza%'\nAND ex.cost > 50\nAND ex.cost < 100;"
        ],
        "rule_sql": []
    },
    "1235": {
        "question": "What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.Diagnosis, T1.ID , STRFTIME('%Y', CURRENT_TIMESTAMP) -STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate result rows. Do change the column order to `Diagnosis, ID` instead of `ID, Diagnosis`. Do use `STRFTIME('%Y', CURRENT_TIMESTAMP)` instead of `strftime('%Y', 'now')` for the current year calculation. Do remove the `Age` alias instead of keeping it for the calculated age column. Do use `INNER JOIN` with explicit keyword instead of just `JOIN`. Do use table aliases `T1` and `T2` instead of `P` and `L`. Do keep the same join condition `T1.ID = T2.ID` instead of changing it. Do use the same filter `T2.RBC < 3.5` instead of changing it. The amended query now correctly returns distinct patient records with proper current year calculation and matches the intended behavior.",
            "Do remove the age calculation adjustment `- (STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', T1.Birthday))` instead of including it, as the correct query only calculates the year difference without month/day adjustment. Do simplify the age expression to `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)` instead of the complex conditional subtraction. The amended query now correctly calculates age based solely on year difference and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for patient diagnosis with specific laboratory conditions: combine Patient table (T1) and Laboratory table (T2) where T1.ID equals T2.ID and keep only matching pairs (inner match). 2) When filtering for lower red blood cell count: include only rows where T2.RBC is less than 3.5. 3) When calculating patient age: compute current year minus birth year using STRFTIME('%Y', CURRENT_TIMESTAMP) minus STRFTIME('%Y', T1.Birthday). 4) When removing duplicate patient records: return only distinct combinations of the selected columns. 5) When the question specifies output column order: present Diagnosis before ID in the results. Output columns (ordered): T1.Diagnosis, T1.ID",
            "1) When calculating age from a birthday column: compute the difference between the current year and the birth year using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) without month/day adjustments.\n2) When the question asks for patients with lower red blood cell count: filter using T2.RBC < 3.5 as the condition.\n3) When combining Patient and Laboratory tables for shared patients: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n4) When the question asks for diagnosis, ID, and age: include T1.Diagnosis, T1.ID, and the calculated age expression in the output.\n5) When the question specifies \"those who has lower red blood blood cell\": ensure the Laboratory table is joined and filtered for RBC values below 3.5.\nOutput columns (ordered): T1.Diagnosis, T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, P.Diagnosis, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.RBC < 3.5;",
            "SELECT DISTINCT T1.Diagnosis, T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) - (STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', T1.Birthday)) FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5;",
            "SELECT DISTINCT T1.Diagnosis, T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5"
        ],
        "rule_sql": [
            "SELECT DISTINCT \n    T1.Diagnosis, \n    T1.ID, \n    STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) AS Age\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T2.RBC < 3.5\nORDER BY \n    T1.Diagnosis, T1.ID"
        ]
    },
    "652": {
        "question": "List the post IDs and badge names of the user Samuel in 2013.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.PostId, T2.Name FROM postHistory AS T1 INNER JOIN badges AS T2 ON T1.UserId = T2.UserId WHERE T1.UserDisplayName = 'Samuel' AND STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'",
        "amends": [
            "Do select `T1.PostId` and `T2.Name` instead of `p.Id AS PostId` and `b.Name AS BadgeName`. Do use `FROM postHistory AS T1` instead of `FROM users u JOIN posts p ON u.Id = p.OwnerUserId`. Do `INNER JOIN badges AS T2 ON T1.UserId = T2.UserId` instead of `JOIN badges b ON u.Id = b.UserId`. Do filter with `T1.UserDisplayName = 'Samuel'` instead of `u.DisplayName = 'Samuel'`. Do use `AND STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'` instead of `AND (strftime('%Y', p.CreaionDate) = '2013' OR strftime('%Y', b.Date) = '2013')`. The amended query now correctly joins postHistory with badges on UserId, filters for both dates being in 2013 instead of either, and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for post IDs and badge names: select T1.PostId and T2.Name as output columns. 2) When joining post history and badge data: use postHistory as T1 and badges as T2, linking rows where T1.UserId = T2.UserId (inner match). 3) When filtering for user Samuel: use T1.UserDisplayName = 'Samuel' exactly. 4) When filtering for year 2013: require both T1.CreationDate and T2.Date to be in 2013 using STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'. 5) Output columns (ordered): T1.PostId, T2.Name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Id AS PostId, b.Name AS BadgeName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nJOIN badges b ON u.Id = b.UserId\nWHERE u.DisplayName = 'Samuel'\nAND (strftime('%Y', p.CreaionDate) = '2013' OR strftime('%Y', b.Date) = '2013');",
            "SELECT T1.PostId, T2.Name\nFROM postHistory AS T1\nINNER JOIN badges AS T2 ON T1.UserId = T2.UserId\nWHERE T1.UserDisplayName = 'Samuel'\nAND STRFTIME('%Y', T1.CreationDate) = '2013'\nAND STRFTIME('%Y', T2.Date) = '2013'"
        ],
        "rule_sql": [
            "SELECT T1.PostId, T2.Name\nFROM postHistory AS T1\nINNER JOIN badges AS T2 ON T1.UserId = T2.UserId\nWHERE T1.UserDisplayName = 'Samuel'\nAND STRFTIME('%Y', T1.CreationDate) = '2013'\nAND STRFTIME('%Y', T2.Date) = '2013'"
        ]
    },
    "727": {
        "question": "Who is the publisher of Sauron?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Sauron'",
        "amends": [],
        "rules": [
            "the publisher refers to publisher_name; Sauron refers to superhero_name = 'Sauron'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Sauron';"
        ],
        "rule_sql": []
    },
    "820": {
        "question": "How strong is the Hulk?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = 'Hulk' AND T3.attribute_name = 'Strength'",
        "amends": [],
        "rules": [
            "how strong refers to attribute_value WHERE attribute_name = 'Strength'; the Hulk refers to superhero_name = 'Hulk';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ha.attribute_value\nFROM hero_attribute ha\nJOIN superhero sh ON ha.hero_id = sh.id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE sh.superhero_name = 'Hulk' AND a.attribute_name = 'Strength';"
        ],
        "rule_sql": []
    },
    "1356": {
        "question": "Which department was the President of the club in?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'President'",
        "amends": [],
        "rules": [
            "'President' is a position of Student Club"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.department\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'President';"
        ],
        "rule_sql": []
    },
    "206": {
        "question": "What elements are in the TR004_8_9 bond atoms?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'",
        "amends": [],
        "rules": [
            "TR004_8_9 bond atoms refers to bond_id = 'TR004_8_9';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.element \nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_id = 'TR004_8_9';\n"
        ],
        "rule_sql": []
    },
    "227": {
        "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
        "db_id": "toxicology",
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3) FROM molecule t",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ROUND((SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(molecule_id)), 3) AS percentage\nFROM molecule;"
        ],
        "rule_sql": []
    },
    "1492": {
        "question": "What percentage of KAM customers pay in euros?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST(SUM(Currency = 'EUR') AS FLOAT) * 100 / COUNT(CustomerID) FROM customers WHERE Segment = 'KAM'",
        "amends": [],
        "rules": [
            "Percentage of KAM uses Euro = (Total of KAM uses Euro / Total of KAM) * 100%."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.Currency = 'EUR' THEN 1 END) * 100.0 / COUNT(*)) AS Percentage_KAM_EUR\nFROM \n    customers c\nWHERE \n    c.Segment = 'KAM';"
        ],
        "rule_sql": []
    },
    "1081": {
        "question": "Which country is the Belgium Jupiler League from?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "amends": [],
        "rules": [
            "Belgium Jupiler League refers to League.name = 'Belgium Jupiler League';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name AS country_name\nFROM League l\nJOIN Country c ON l.country_id = c.id\nWHERE l.name = 'Belgium Jupiler League';"
        ],
        "rule_sql": []
    },
    "1040": {
        "question": "List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 GROUP BY t1.id ORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.`player_fifa_api_id`) DESC LIMIT 10",
        "amends": [
            "Do select only `player_name` instead of including `AVG(pa.heading_accuracy)` with an alias. Do use table aliases `t1` and `t2` instead of `p` and `pa`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do group by `t1.id` instead of `player_name` to ensure proper aggregation. Do order by the calculated average using `CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.player_fifa_api_id)` instead of the simple `AVG(pa.heading_accuracy)` to handle division properly. Do maintain the same `WHERE` filter on height and `LIMIT` clause. The amended query now correctly calculates the average heading accuracy while ensuring proper grouping and mathematical precision, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"top 10\" players: rank rows by average heading accuracy in descending order and keep the first 10 rows.\n2) When filtering players by height above 180: include only rows where t1.height > 180.\n3) When calculating average heading accuracy: compute (SUM(t2.heading_accuracy) divided by COUNT(t2.player_fifa_api_id)) with proper division handling.\n4) When grouping player data: organize results by t1.id to ensure proper aggregation instead of grouping by player_name.\n5) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id using an inner match.\n6) When ordering results: sort by the calculated average heading accuracy in descending order.\n7) Output columns (ordered): t1.player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, AVG(pa.heading_accuracy) AS avg_heading_accuracy\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height > 180\nGROUP BY p.player_name\nORDER BY avg_heading_accuracy DESC\nLIMIT 10;",
            "SELECT t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 180\nGROUP BY t1.id\nORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.player_fifa_api_id) DESC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 180\nGROUP BY t1.id\nORDER BY AVG(t2.heading_accuracy) DESC\nLIMIT 10"
        ]
    },
    "455": {
        "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "amends": [],
        "rules": [
            "are a promotional painting refers to isPromo = 1; have multiple faces on the same card refers to side is not Null"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE isPromo = 1 AND otherFaceIds IS NOT NULL AND otherFaceIds != '';"
        ],
        "rule_sql": []
    },
    "721": {
        "question": "How many superheroes have blue eyes?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue'",
        "amends": [],
        "rules": [
            "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS blue_eyed_superheroes\nFROM superhero\nWHERE eye_colour_id = (SELECT id FROM colour WHERE colour = 'Blue');"
        ],
        "rule_sql": []
    },
    "685": {
        "question": "Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.ViewCount, T3.DisplayName FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id WHERE T1.Text = 'Computer Game Datasets'",
        "amends": [
            "Do change the FROM clause to use `postHistory AS T1` instead of `posts p` and add `INNER JOIN posts AS T2` on `T1.PostId = T2.Id` instead of joining directly to users. Do change the join condition to `T2.LastEditorUserId = T3.Id` instead of `p.OwnerUserId = u.Id` when joining to users. Do change the WHERE filter to use `T1.Text = 'Computer Game Datasets'` instead of `p.Title = 'Computer Game Datasets'`. Do change the SELECT list to use `T2.ViewCount` and `T3.DisplayName` instead of `p.ViewCount AS TotalViews` and `u.DisplayName AS UserName`. The amended query now correctly filters on post history text rather than post title and joins through the appropriate relationships to match the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for views on a post with specific text 'Computer Game Datasets': use T1.Text = 'Computer Game Datasets' as the filter condition. 2) When combining post history and posts tables: link rows where T1.PostId = T2.Id and keep only matching pairs (inner match). 3) When joining to users table for the last editor: link rows where T2.LastEditorUserId = T3.Id and keep only matching pairs (inner match). 4) When selecting view count and display name: use T2.ViewCount for total views and T3.DisplayName for user name. 5) Output columns (ordered): T2.ViewCount, T3.DisplayName"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.ViewCount AS TotalViews, u.DisplayName AS UserName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Computer Game Datasets';",
            "SELECT T2.ViewCount, T3.DisplayName\nFROM postHistory AS T1\nINNER JOIN posts AS T2 ON T1.PostId = T2.Id\nINNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id\nWHERE T1.Text = 'Computer Game Datasets'"
        ],
        "rule_sql": [
            "SELECT T2.ViewCount, T3.DisplayName\nFROM posts T2\nINNER JOIN users T3 ON T2.LastEditorUserId = T3.Id\nWHERE T2.Title = 'Computer Game Datasets'"
        ]
    },
    "877": {
        "question": "For all the drivers who finished the game in race No. 872, who is the youngest?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 872 AND T2.time IS NOT NULL ORDER BY T1.dob DESC LIMIT 1",
        "amends": [
            "Do select only `forename` and `surname` instead of including `driverId` and `dob` in the SELECT list. Do use `INNER JOIN` instead of `JOIN` while maintaining the same join condition `T2.driverId = T1.driverId`. Do keep the WHERE filter on `raceId = 872` and `time IS NOT NULL` unchanged. Do maintain the ORDER BY `dob DESC` and LIMIT 1 clauses without modification. The amended query now correctly returns only the driver names instead of additional unnecessary columns while preserving the same result filtering and ordering logic."
        ],
        "rules": [
            "1) When the question asks for drivers who finished a specific race: filter results where raceId equals 872 and time is not null.\n2) When combining driver information with race results: link rows where T2.driverId equals T1.driverId using an inner match.\n3) When finding the youngest driver: order rows by dob in descending order and keep only the first result.\n4) When outputting driver names: include only forename and surname columns.\n5) Output columns (ordered): T2.forename, T2.surname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverId, d.forename, d.surname, d.dob\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 872 AND r.time IS NOT NULL\nORDER BY d.dob DESC\nLIMIT 1;",
            "SELECT forename, surname \nFROM results \nINNER JOIN drivers ON results.driverId = drivers.driverId \nWHERE raceId = 872 AND time IS NOT NULL \nORDER BY dob DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT d.forename, d.surname\nFROM results r\nINNER JOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 872 AND r.time IS NOT NULL\nORDER BY d.dob DESC\nLIMIT 1;"
        ]
    },
    "983": {
        "question": "Which of the Italian constructor got the highest point to date? Give its introduction website?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1",
        "amends": [
            "Do select only `T1.url` instead of `c.name, c.url AS introduction_website, SUM(cs.points) AS total_points`. Do use `INNER JOIN` with alias `T2` instead of `JOIN` with alias `cs`. Do reference `T1.constructorId = T2.constructorId` instead of `c.constructorId = cs.constructorId`. Do remove the `GROUP BY c.constructorId` clause instead of keeping it. Do order by `T2.points DESC` instead of `total_points DESC` to use the raw points value rather than a sum. The amended query now correctly retrieves the website URL of the Italian constructor with the highest points without unnecessary aggregation."
        ],
        "rules": [
            "1) When the question asks for an Italian constructor: filter rows where T1.nationality equals 'Italian' exactly. 2) When combining T1 and T2 for shared constructor entities: link rows where T1.constructorId equals T2.constructorId exactly; keep only matching pairs (inner match). 3) When the question asks for the highest points: order rows by T2.points in descending direction and keep the first 1 row. 4) When the question asks for an introduction website: select only T1.url as the output column. 5) Output columns (ordered): T1.url"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, c.url AS introduction_website, SUM(cs.points) AS total_points\nFROM constructors c\nJOIN constructorStandings cs ON c.constructorId = cs.constructorId\nWHERE c.nationality = 'Italian'\nGROUP BY c.constructorId\nORDER BY total_points DESC\nLIMIT 1;",
            "SELECT T1.url FROM constructors T1 INNER JOIN constructorStandings T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.url\nFROM constructors T1\nINNER JOIN constructorStandings T2 ON T1.constructorId = T2.constructorId\nWHERE T1.nationality = 'Italian'\nORDER BY T2.points DESC\nLIMIT 1;"
        ]
    },
    "541": {
        "question": "What is the display name of the user who is the owner of the most valuable post?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.FavoriteCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "most valuable post refers to Max(FavoriteCount)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Score = (SELECT MAX(Score) FROM posts);"
        ],
        "rule_sql": []
    },
    "132": {
        "question": "What is the average loan amount by male borrowers?",
        "db_id": "financial",
        "ground_truth": "SELECT AVG(T4.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'M'",
        "amends": [],
        "rules": [
            "Male refers to gender = 'M'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(l.amount) AS average_loan_amount\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE c.gender = 'M';"
        ],
        "rule_sql": []
    }
}