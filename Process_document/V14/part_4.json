{
    "1197": {
        "sql": [
            "SELECT p.`First Date`, e.Diagnosis FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE p.ID = 48473 ORDER BY p.`First Date` LIMIT 1;"
        ],
        "question": "When was the medical information on patient number 48473 first documented, and what disease did she have?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT `First Date`, Diagnosis FROM Patient WHERE ID = 48473",
        "amends": [],
        "rules": [
            "medical information first documented refers to Description; disease refers to diagnosis; patient number refers to id"
        ]
    },
    "1298": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.`T-CHO` < 250 AND E.`ANA Pattern` = 'P';",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T3.\"ANA Pattern\" = 'P'\nAND T2.\"T-CHO\" < 250"
        ],
        "question": "Among the patients whose total cholesterol is within the normal range, how many of them have a P pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T3.`ANA Pattern` = 'P' AND T2.`T-CHO` < 250",
        "amends": [
            "Do use `COUNT(T1.ID)` without `DISTINCT` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patients. Do specify `INNER JOIN` explicitly instead of just `JOIN` for both joins to clarify join type. Do use table aliases `T1`, `T2`, and `T3` instead of `P`, `L`, and `E` for consistency. Do place the `WHERE` condition `T3.ANA Pattern = 'P'` before `T2.T-CHO < 250` instead of the reverse order, though this is functionally equivalent. Do remove the column alias `AS PatientCount` instead of keeping it since the right query doesn't require it. The amended query now correctly counts all patient records meeting both laboratory and examination criteria without unnecessary distinct filtering."
        ],
        "rules": [
            "total cholesterol is within the normal range refers to `T-CHO` < 250; P pattern observed in the sheet of ANA examination refers to ANA Pattern = 'P';"
        ]
    },
    "303": {
        "sql": [
            "SELECT \n    COUNT(b.bond_id) AS double_bond_count,\n    m.label AS is_carcinogenic\nFROM \n    bond b\nJOIN \n    molecule m ON b.molecule_id = m.molecule_id\nWHERE \n    b.molecule_id = 'TR006' AND b.bond_type = ' = ';\nGROUP BY \n    m.label;",
            "SELECT COUNT(*) AS double_bond_count, T2.label = 'carcinogenic' AS is_carcinogenic\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.molecule_id = 'TR006' AND T1.bond_type = '='\nGROUP BY T2.label",
            "SELECT COUNT(T1.bond_id), T2.label\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '=' AND T2.molecule_id = 'TR006'\nGROUP BY T2.label"
        ],
        "question": "How many double bonds does TR006 have and is it carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.bond_id), T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' AND T2.molecule_id = 'TR006' GROUP BY T2.label",
        "amends": [
            "Do use `T1` and `T2` table aliases instead of `b` and `m` for consistency. Do place the `T2.molecule_id = 'TR006'` filter in the WHERE clause instead of filtering on `b.molecule_id` to correctly reference the joined table. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do remove the alias `double_bond_count` from the COUNT expression instead of keeping it to match the simpler output format. Do use single quotes around the equals sign in `bond_type = '='` instead of `' = '` with extra spaces to ensure exact string matching. The amended query now correctly filters on the molecule table's ID while maintaining the same join logic and grouping behavior.",
            "Do count `T1.bond_id` instead of `COUNT(*)` to avoid counting NULLs. Do include `T2.label` directly in the SELECT list instead of creating a boolean expression `T2.label = 'carcinogenic' AS is_carcinogenic`. Do remove the alias `double_bond_count` since it's no longer needed. Do reorder the WHERE clause predicates to `T1.bond_type = '=' AND T2.molecule_id = 'TR006'` instead of the original sequence, though this is functionally equivalent. The amended query now correctly counts specific bond instances and returns the actual label values rather than a boolean comparison, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; double bond refers to bond_type = ' = ';"
        ]
    },
    "891": {
        "sql": [
            "SELECT d.forename || ' ' || d.surname AS driver_name, ds.position\nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nJOIN races r ON ds.raceId = r.raceId\nWHERE r.year = 2010 AND r.name = 'Singapore Grand Prix'\nORDER BY ds.position;",
            "SELECT T3.forename, T3.surname \nFROM races T1 \nINNER JOIN driverStandings T2 ON T2.raceId = T1.raceId \nINNER JOIN drivers T3 ON T3.driverId = T2.driverId \nWHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010 \nORDER BY T2.position ASC"
        ],
        "question": "Name all drivers in the 2010 Singapore Grand Prix order by their position stands.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010 ORDER BY T2.position ASC",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `driver_name`. Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `ds`, and `d`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do fix the join condition to `T2.raceId = T1.raceId` instead of `ds.raceId = r.raceId`. Do change the WHERE clause order to `T1.name = 'Singapore Grand Prix' AND T1.year = 2010` instead of `r.year = 2010 AND r.name = 'Singapore Grand Prix'`. Do add explicit `ASC` to the ORDER BY instead of omitting the direction. Do remove the `position` column from the SELECT list instead of including it. The amended query now correctly retrieves only driver names without standings data while maintaining the same filtering logic."
        ],
        "rules": []
    },
    "1051": {
        "sql": [
            "SELECT p.player_name, pa.potential\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes);",
            "SELECT DISTINCT p.player_name\nFROM Player p\nINNER JOIN Player_Attributes t1 ON p.player_api_id = t1.player_api_id\nWHERE t1.potential = (SELECT MAX(t2.potential) FROM Player_Attributes t2)"
        ],
        "question": "List all the football player with the highest potential score.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT(t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = (SELECT MAX(potential) FROM Player_Attributes) ",
        "amends": [
            "Do use `DISTINCT` on `player_name` instead of selecting both `player_name` and `potential` which causes duplicate rows. Do use `INNER JOIN` with explicit table aliases `t1` and `t2` instead of simple `JOIN` with single-letter aliases. Do reference the joined table as `t2` in the `WHERE` clause instead of `pa` to maintain alias consistency. Do remove the explicit `potential` column from the `SELECT` list instead of including it since only distinct player names are needed. The amended query now correctly returns only distinct player names who have the maximum potential value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "potential score refers to potential; highest potential score refers to MAX(potential);"
        ]
    },
    "95": {
        "sql": [
            "WITH youngest_clients AS (\n    SELECT client_id, birth_date\n    FROM client\n    WHERE birth_date = (SELECT MAX(birth_date) FROM client)\n),\nhighest_salary_districts AS (\n    SELECT district_id\n    FROM district\n    WHERE A11 = (SELECT MAX(A11) FROM district)\n)\nSELECT a.account_id\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN youngest_clients yc ON d.client_id = yc.client_id\nJOIN client c ON d.client_id = c.client_id\nJOIN highest_salary_districts hsd ON c.district_id = hsd.district_id;",
            "SELECT T1.account_id\nFROM account T1\nJOIN disp T2 ON T1.account_id = T2.account_id\nJOIN client T3 ON T2.client_id = T3.client_id\nJOIN district T4 ON T3.district_id = T4.district_id\nWHERE T3.client_id = (SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1)\nGROUP BY T4.A11, T1.account_id\nORDER BY T4.A11 DESC\nLIMIT 1;"
        ],
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.A11, T1.account_id",
        "amends": [
            "Do use a direct subquery for the youngest client instead of a CTE, and do filter by `client_id = (SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1)` instead of joining on a CTE that finds maximum birth date. Do join the district table directly on `district_id` instead of using a CTE for highest salary districts, and do add `GROUP BY T4.A11, T1.account_id` instead of omitting aggregation. Do remove the redundant join to the client table through the youngest_clients CTE instead of keeping multiple client joins. Do move the district condition to a direct table join instead of using a separate CTE for highest salary districts. The amended query now correctly identifies accounts associated with the youngest client while properly handling district relationships through direct joins and appropriate grouping."
        ],
        "rules": [
            "If the person A's birthdate < B's birthdate, it means that person B is younger than person A; A11 refers to average salary"
        ]
    },
    "1137": {
        "sql": [
            "WITH total_players AS (\n    SELECT COUNT(DISTINCT player_api_id) AS total\n    FROM Player_Attributes\n),\nstrong_players AS (\n    SELECT COUNT(DISTINCT player_api_id) AS strong_count\n    FROM Player_Attributes\n    WHERE strength > 80 AND stamina > 80\n)\nSELECT (strong_count * 100.0 / total) AS percentage\nFROM total_players, strong_players;",
            "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) AS percentage\nFROM Player_Attributes;"
        ],
        "question": "What percentage of players have a strength and stamina score of more than 80?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) FROM Player_Attributes t",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs and cross join. Do calculate the percentage using `CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id)` instead of `(strong_count * 100.0 / total)` from cross-joined CTEs. Do reference `id` column instead of `player_api_id` for counting. Do remove the DISTINCT operations since we're counting individual records rather than distinct players. Do eliminate the CTE structure and cross join between total_players and strong_players in favor of direct aggregation. The amended query now correctly calculates the percentage of records meeting both strength and stamina conditions using proper conditional counting and avoids the unnecessary complexity of CTEs with cross join."
        ],
        "rules": [
            "strength and stamina score of more than 80 refers to stamina > 80 and strength > 80"
        ]
    },
    "733": {
        "sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE eye_colour_id = (SELECT id FROM colour WHERE colour = 'Gold') \nAND publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');"
        ],
        "question": "How many gold-eyed superheroes did Marvel Comics publish?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.colour = 'Gold'",
        "amends": [],
        "rules": [
            "gold-eyed refers to colour = 'Gold' where eye_colour_id = colour.id; superheroes that Marvel Comics published refers to publisher_name = 'Marvel Comics'"
        ]
    },
    "203": {
        "sql": [
            "SELECT COUNT(*) FROM atom WHERE element != 'br';"
        ],
        "question": "In how many atoms is there no bromine?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.atom_id) FROM atom AS T WHERE T.element <> 'br'",
        "amends": [],
        "rules": [
            "atoms with no bromine refers to element ! = 'br'"
        ]
    },
    "473": {
        "sql": [
            "SELECT s.isForeignOnly \nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE c.name = 'Adarkar Valkyrie';",
            "SELECT IIF(T2.isForeignOnly = 1, 'YES', 'NO') AS is_available_outside_us\nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Adarkar Valkyrie';"
        ],
        "question": "Is the set of cards with Adarkar Valkyrie only available outside the United States?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT IIF(isForeignOnly = 1, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Adarkar Valkyrie'",
        "amends": [
            "Do use `IIF(isForeignOnly = 1, 'YES', 'NO')` instead of selecting `s.isForeignOnly` directly to transform the boolean value into human-readable text. Do use `INNER JOIN` with explicit table aliases `T2` for sets and `T1` for cards instead of implicit aliases `s` and `c`. Do specify the join condition as `T2.code = T1.setCode` instead of `c.setCode = s.code` to maintain the same logical relationship but with clearer table reference. Do reference the card name filter as `T1.name` instead of `c.name` to match the explicit alias convention. The amended query now correctly transforms the boolean flag into a readable 'YES'/'NO' response while maintaining the same join logic and filtering behavior."
        ],
        "rules": [
            "card set Adarkar Valkyrie refers to name = 'Adarkar Valkyrie'; isForeignOnly = 1 means only available outside the United States;"
        ]
    },
    "460": {
        "sql": [
            "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer';"
        ],
        "question": "Which artist designed the card whose promotional name is \"Battra, Dark Destroyer\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer'",
        "amends": [],
        "rules": [
            "promotional name is \"Battra, Dark Destroyer\" refers to flavorName = 'Battra, Dark Destroyer'"
        ]
    },
    "745": {
        "sql": [
            "SELECT id FROM publisher WHERE publisher_name = 'Star Trek';"
        ],
        "question": "Give the publisher ID of Star Trek.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
        "amends": [],
        "rules": [
            "Star Trek is the publisher_name;"
        ]
    },
    "341": {
        "sql": [
            "SELECT * FROM cards WHERE borderColor = 'borderless' AND (cardKingdomFoilId IS NULL OR cardKingdomId IS NULL);",
            "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomFoilId IS NULL OR cardKingdomId IS NULL)",
            "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)"
        ],
        "question": "What are the borderless cards available without powerful foils?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)",
        "amends": [
            "Do select only `id` instead of all columns with `*`. Do use the correct condition `cardKingdomId IS NULL` in both parts of the OR clause instead of mixing `cardKingdomFoilId IS NULL` with `cardKingdomId IS NULL`. The amended query now correctly identifies borderless cards where either the cardKingdomId is missing in both checks, matching the intended logic.",
            "Do use `cardKingdomId IS NULL` in both conditions of the OR clause instead of having `cardKingdomFoilId IS NULL` as the first condition. Do maintain the same table source `cards` and WHERE filter structure instead of changing the join or grouping logic. The amended query now correctly checks for NULL values in the consistent `cardKingdomId` field in both parts of the OR condition, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "borderless' refers to borderColor; poweful foils refers to cardKingdomFoilId paired with cardKingdomId AND cardKingdomId is not null"
        ]
    },
    "583": {
        "sql": [
            "SELECT SUM(p.Score) AS TotalScore, u.WebsiteUrl\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE u.DisplayName = 'Yevgeny';\n"
        ],
        "question": "What is the total score of the posts edited by Yevgeny and include the user's website URL.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.Score), T2.WebsiteUrl FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Yevgeny' GROUP BY T2.WebsiteUrl",
        "amends": [],
        "rules": [
            "\"Yevgeny\" is the DisplayName; edited refers to LastEditorUserId"
        ]
    },
    "372": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE toughness = '99';"
        ],
        "question": "How many cards are there with toughness of 99?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE toughness = 99",
        "amends": [],
        "rules": []
    },
    "719": {
        "sql": [
            "SELECT COUNT(*) \nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Super Strength' AND s.height_cm > 200;"
        ],
        "question": "Among the superheroes with the super power of \"Super Strength\", how many of them have a height of over 200cm?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.height_cm > 200",
        "amends": [],
        "rules": [
            "super power of \"Super Strength\" refers to power_name = 'Super Strength'; a height of over 200cm refers to height_cm > 200"
        ]
    },
    "1162": {
        "sql": [
            "SELECT COUNT(*) \nFROM Patient \nWHERE SEX = 'F' \nAND strftime('%Y', Description) = '1997' \nAND Admission = '-';"
        ],
        "question": "How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM Patient WHERE STRFTIME('%Y', Description) = '1997' AND SEX = 'F' AND Admission = '-'",
        "amends": [],
        "rules": [
            "female refers to sex = 'F'; came at the hospital in 1997 refers to year(Description) = '1997'; immediately followed at the outpatient clinic refers to Admission = '-'"
        ]
    },
    "475": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') \nAND borderColor = 'black';"
        ],
        "question": "How many cards in the set Coldsnap have a black border color?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "amends": [],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; black border color refers to borderColor = 'black'"
        ]
    },
    "1407": {
        "sql": [
            "SELECT * FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3;",
            "SELECT budget_id FROM budget WHERE category = 'Advertising' ORDER BY amount DESC LIMIT 3;",
            "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3;"
        ],
        "question": "Among the budgets for Advertising, list out top three which have the most budgeted amount?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3",
        "amends": [
            "Do select only `budget_id` instead of all columns with `*` to return specific identifiers rather than the full row contents. The amended query now matches RIGHT_SQL's behavior by returning only the budget identifiers for the top 3 advertisement budgets by amount.",
            "Do filter on `category = 'Advertisement'` instead of `category = 'Advertising'` in the WHERE clause, correcting the category value to match the intended business logic. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "MAX(amount) where category = 'Advertisement'"
        ]
    },
    "187": {
        "sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS client_count\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'Owner';",
            "SELECT COUNT(T2.account_id)\nFROM account T1\nINNER JOIN disp T2 ON T1.account_id = T2.account_id\nWHERE T1.frequency = 'WEEKLY ISSUANCE'\nAND T2.type = 'OWNER'",
            "SELECT COUNT(T2.account_id) \nFROM account T1 \nINNER JOIN disp T2 ON T1.account_id = T2.account_id \nWHERE T1.frequency = 'POPLATEK TYDNE' \nAND T2.type = 'OWNER'"
        ],
        "question": "How many clients who choose statement of weekly issuance are Owner?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'",
        "amends": [
            "Do count `T2.account_id` instead of `COUNT(DISTINCT c.client_id)` to track accounts rather than clients. Do use `INNER JOIN` between `account` and `disp` instead of joining through `client` table, removing the unnecessary `client` table entirely. Do reference `T1.frequency` from the `account` table instead of `a.frequency` with different alias. Do filter for `T2.type = 'OWNER'` instead of `d.type = 'Owner'` with uppercase consistency. Do remove the `AS client_count` alias instead of keeping it since the result is an unlabeled count. The amended query now correctly counts accounts with weekly frequency statements owned by their primary holders, matching the intended behavior.",
            "Do use the literal string `'POPLATEK TYDNE'` for the frequency filter instead of `'WEEKLY ISSUANCE'` to match the correct business requirement. The amended query now correctly counts account owners with the specified frequency, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Frequency = 'POPLATEK TYDNE' refers to weekly issuance"
        ]
    },
    "808": {
        "sql": [
            "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.weight_kg = 108 AND s.height_cm = 188;"
        ],
        "question": "Find the race of the superhero who weighs 108kg and is 188cm tall.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 108 AND T1.height_cm = 188",
        "amends": [],
        "rules": [
            "weighs 108kg refers to weight_kg = 108; 188cm tall refers to height_cm = 188;"
        ]
    },
    "126": {
        "sql": [
            "WITH decin_accounts AS (\n    SELECT COUNT(*) AS decin_count\n    FROM account\n    JOIN district ON account.district_id = district.district_id\n    WHERE district.A2 = 'Decin'\n    AND strftime('%Y', account.date) = '1993'\n),\ntotal_1993_accounts AS (\n    SELECT COUNT(*) AS total_count\n    FROM account\n    WHERE strftime('%Y', account.date) = '1993'\n)\nSELECT (decin_count * 100.0 / total_count) AS percentage\nFROM decin_accounts, total_1993_accounts;"
        ],
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "amends": [],
        "rules": [
            "A2 contains the information about district."
        ]
    },
    "986": {
        "sql": [
            "SELECT r.raceId, r.name AS race_name, r.year, r.circuitId, lt.milliseconds AS fastest_lap_time\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nWHERE lt.lap = 1\nORDER BY lt.milliseconds ASC\nLIMIT 1;",
            "SELECT T1.milliseconds\nFROM lapTimes T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T1.lap = 1\nORDER BY T1.time\nLIMIT 1;"
        ],
        "question": "In which race did the fastest 1st lap time was recorded? Please indicate the time in milliseconds.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.milliseconds FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.lap = 1 ORDER BY T1.time LIMIT 1",
        "amends": [
            "Do select only `T1.milliseconds` instead of multiple columns including `r.raceId`, `r.name`, `r.year`, `r.circuitId`, and `lt.milliseconds`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of `JOIN` with aliases `lt` and `r`. Do join on `T1.raceId = T2.raceId` instead of `lt.raceId = r.raceId`. Do order by `T1.time` instead of `lt.milliseconds ASC`. Do remove the `AS race_name` alias instead of keeping it. The amended query now correctly returns only the fastest lap time from the first lap of races, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "fastest refers to Min(time);"
        ]
    },
    "1130": {
        "sql": [
            "SELECT t.team_short_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE ta.chanceCreationPassingClass = 'Safe';"
        ],
        "question": "What are the short name of team who played safe while creating chance of passing?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Safe'",
        "amends": [],
        "rules": [
            "played safe while creating chance of passing refers to chanceCreationPassingClass = 'Safe'; short name of team refers to team_short_name"
        ]
    },
    "195": {
        "sql": [
            "SELECT bond_type, COUNT(bond_type) AS count FROM bond GROUP BY bond_type ORDER BY count DESC LIMIT 1;",
            "SELECT T.bond_type FROM (SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1) AS T"
        ],
        "question": "What is the most common bond type?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_type FROM ( SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do select only `T.bond_type` in the outer query instead of including both `bond_type` and `COUNT(bond_type)`. Do count `bond_id` instead of `bond_type` in the subquery's aggregation. Do use a subquery with alias `AS T` to wrap the aggregation instead of querying the table directly. Do order by `COUNT(bond_id)` instead of the alias `count` in the subquery. The amended query now correctly identifies the bond_type with the highest count of bond_id records rather than counting bond_type values themselves."
        ],
        "rules": [
            "most common bond type refers MAX(COUNT(bond_type))"
        ]
    },
    "480": {
        "sql": [
            "SELECT fd.flavorText \nFROM foreign_data fd\nJOIN cards c ON fd.uuid = c.uuid\nWHERE c.name = 'Ancestor''s Chosen' AND fd.language = 'Italian';"
        ],
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "amends": [],
        "rules": [
            "Italian refers to language = 'Italian'; flavor text refers to flavorText; \"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'"
        ]
    },
    "283": {
        "sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'ca';",
            "SELECT T2.label AS flag_carcinogenic\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'ca'"
        ],
        "question": "Identify whether the chemical compound that contains Calcium is carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'",
        "amends": [
            "Do use `T2.label AS flag_carcinogenic` instead of `m.molecule_id, m.label` in the SELECT list. Do remove `DISTINCT` instead of keeping it. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do use table aliases `T1` for atom and `T2` for molecule instead of `a` and `m`. Do use `T1.element = 'ca'` instead of `a.element = 'ca'` in the WHERE clause. The amended query now correctly returns only the carcinogenic flag labels without molecule IDs and without unnecessary DISTINCT, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "calcium refers to element = 'ca'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic;"
        ]
    },
    "1490": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN y.Consumption > 46.73 THEN 1 END) * 100.0 / COUNT(*) AS Percentage\nFROM \n    customers c\nJOIN \n    yearmonth y ON c.CustomerID = y.CustomerID\nWHERE \n    c.Segment = 'LAM';",
            "SELECT \n    (CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) / COUNT(T1.CustomerID) * 100 AS Percentage\nFROM \n    customers T1\nINNER JOIN \n    yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Segment = 'LAM'",
            "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) \nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM'"
        ],
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "amends": [
            "Do use `CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT)` instead of `COUNT(CASE WHEN y.Consumption > 46.73 THEN 1 END)` for proper percentage calculation. Do reference `T1.CustomerID` in `COUNT(T1.CustomerID)` instead of `COUNT(*)` to count only customer records. Do use explicit `INNER JOIN` instead of just `JOIN` for clarity. Do add table aliases `T1` and `T2` instead of using `c` and `y` for better readability. Do remove the multiplication by `100.0` from the numerator and instead multiply the entire expression by `100` after the division. The amended query now correctly calculates the percentage of customers with consumption above 46.73 in the LAM segment.",
            "Do place the multiplication by 100 before the division instead of after it, changing the calculation order to `* 100 / COUNT(T1.CustomerID)` instead of `/ COUNT(T1.CustomerID) * 100` to ensure correct percentage calculation. Do remove the alias `AS Percentage` instead of keeping it since the RIGHT_SQL does not include an explicit column alias. The amended query now correctly calculates the percentage of customers with consumption over 46.73 in the LAM segment."
        ],
        "rules": [
            "Percentage of LAM customer consumed more than 46.73 = (Total no. of LAM customers who consumed more than 46.73 / Total no. of LAM customers) * 100."
        ]
    },
    "893": {
        "sql": [
            "SELECT d.forename || ' ' || d.surname AS driver_name, ds.points\nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nJOIN races r ON ds.raceId = r.raceId\nWHERE r.year = 2017 AND r.name = 'Chinese Grand Prix'\nORDER BY ds.points DESC\nLIMIT 3;",
            "SELECT T3.forename, T3.surname, T2.points\nFROM races T1\nINNER JOIN driverStandings T2 ON T1.raceId = T2.raceId\nINNER JOIN drivers T3 ON T2.driverId = T3.driverId\nWHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017\nORDER BY T2.points DESC\nLIMIT 3;"
        ],
        "question": "Name the top 3 drivers and the points they scored in the 2017 Chinese Grand Prix.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017 ORDER BY T2.points DESC LIMIT 3",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `driver_name`. Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `ds`, and `d`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do place the `year` filter after the `name` filter in the `WHERE` clause instead of before it. The amended query now correctly retrieves the top 3 drivers by points for the 2017 Chinese Grand Prix with proper column selection and explicit join specifications."
        ],
        "rules": []
    },
    "44": {
        "sql": [
            "SELECT s.AvgScrWrite, sc.City\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE s.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);"
        ],
        "question": "What is the average writing score of the school who has the highest number of test takers whose total SAT sscores are greater or equal to 1500? Indicate the city to where the school is situated.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.AvgScrWrite, T2.City FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [],
        "rules": []
    },
    "129": {
        "sql": [
            "SELECT d.A2 AS district_name, SUM(t.amount) AS total_withdrawal\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE t.type = 'VYDAJ' AND t.date LIKE '1996-01%'\nGROUP BY d.A2\nORDER BY total_withdrawal DESC\nLIMIT 10;",
            "SELECT DISTINCT T1.A2\nFROM district T1\nJOIN account T2 ON T1.district_id = T2.district_id\nJOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T3.type != 'credit card'\nAND strftime('%Y-%m', T3.date) = '1996-01'\nORDER BY T1.A2 ASC\nLIMIT 10"
        ],
        "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%' ORDER BY A2 ASC LIMIT 10",
        "amends": [
            "Do select only `DISTINCT T1.A2` instead of aggregating with `SUM(t.amount)` and aliasing as `total_withdrawal`. Do use table aliases `T1`, `T2`, and `T3` instead of `d`, `a`, and `t`. Do change the join condition from `a.district_id = d.district_id` to `T1.district_id = T2.district_id` for proper table reference alignment. Do remove the `GROUP BY d.A2` clause instead of keeping it since aggregation is no longer needed. Do change the `ORDER BY` clause to `A2 ASC` instead of `total_withdrawal DESC` to sort alphabetically rather than by sum. The amended query now matches RIGHT_SQL's behavior of returning distinct district names rather than aggregated withdrawal totals."
        ],
        "rules": [
            "Non-credit card withdraws refers to type = 'VYDAJ'; January 1996 can be found by date LIKE '1996-01%' in the database; A2 means district names"
        ]
    },
    "449": {
        "sql": [
            "SELECT fd.language, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'azorius';"
        ],
        "question": "What is the language of the card that has azorius watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.language, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'azorius'",
        "amends": [],
        "rules": []
    },
    "1112": {
        "sql": [
            "SELECT ta.chanceCreationCrossingClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'Hull City' \nAND ta.date = '2010-02-22 00:00:00';"
        ],
        "question": "What was the chance creation crossing class for \"Hull City\" on 2010/2/22?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.chanceCreationCrossingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hull City' AND SUBSTR(t2.`date`, 1, 10) = '2010-02-22'",
        "amends": [],
        "rules": [
            "\"Hull City\" refers to team_long_name = 'Hull City'; on 2010/2/22 refers to date = '2010-02-22 00:00:00'"
        ]
    },
    "994": {
        "sql": [
            "SELECT c.name, c.nationality, SUM(cr.points) AS total_points\nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nJOIN races r ON cr.raceId = r.raceId\nWHERE r.name = 'Monaco Grand Prix' AND r.year BETWEEN 1980 AND 2010\nGROUP BY c.constructorId, c.name, c.nationality\nORDER BY total_points DESC\nLIMIT 1;",
            "SELECT SUM(T1.points) AS total_points, T2.name, T2.nationality\nFROM constructorResults AS T1\nINNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId\nINNER JOIN races AS T3 ON T1.raceId = T3.raceId\nWHERE T3.name LIKE '%Monaco Grand Prix%' \nAND T3.year BETWEEN 1980 AND 2010\nGROUP BY T2.name\nORDER BY SUM(T1.points) DESC\nLIMIT 1;"
        ],
        "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
        "amends": [
            "Do use `SUM(T1.points)` as the first column instead of `c.name` in the SELECT list. Do include only `T2.name` and `T2.nationality` instead of grouping by `c.constructorId, c.name, c.nationality`. Do use table aliases `T1`, `T2`, and `T3` instead of full table names. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do join `races AS T3` with `T3.raceid = T1.raceid` instead of `cr.raceId = r.raceId`. Do group by only `T2.name` instead of `c.constructorId, c.name, c.nationality`. Do order by `SUM(T1.points)` instead of the alias `total_points`. The amended query now correctly aggregates constructor points for Monaco Grand Prix races between 1980 and 2010 while properly grouping by constructor name only."
        ],
        "rules": [
            "Monaco Grand Priz refers to the race; race in year between 1980 and 2010"
        ]
    },
    "1361": {
        "sql": [
            "SELECT SUM(cost) AS total_pizza_cost FROM expense WHERE expense_description LIKE '%pizza%';"
        ],
        "question": "What is the total cost of the pizzas for all the events?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza'",
        "amends": [],
        "rules": [
            "total cost of the pizzas refers to SUM(cost) where expense_description = 'Pizza'"
        ]
    },
    "580": {
        "sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Necromancer'\nLIMIT 10;"
        ],
        "question": "Name 10 users with the badge name 'Necromancer.'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Necromancer' LIMIT 10",
        "amends": [],
        "rules": [
            "\"Necromancer\" is the Name of badge; users refers to DisplayName"
        ]
    },
    "189": {
        "sql": [
            "WITH oldest_female_clients AS (\n    SELECT c.client_id, c.birth_date, d.A11 AS average_salary\n    FROM client c\n    JOIN district d ON c.district_id = d.district_id\n    WHERE c.gender = 'F'\n    ORDER BY c.birth_date ASC, d.A11 ASC\n    LIMIT 1\n)\nSELECT a.account_id\nFROM oldest_female_clients ofc\nJOIN disp dp ON ofc.client_id = dp.client_id\nJOIN account a ON dp.account_id = a.account_id;"
        ],
        "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Female refers to 'F' in the gender; A11 contains information about average salary"
        ]
    },
    "873": {
        "sql": [
            "SELECT r.time\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 743 AND d.forename = 'Bruce' AND d.surname = 'McLaren';"
        ],
        "question": "What is the actual finish time for Bruce McLaren in the race No.743?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.time FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 743 AND T1.forename = 'Bruce' AND T1.surname = 'McLaren'",
        "amends": [],
        "rules": [
            "race number refers to raceId;"
        ]
    },
    "147": {
        "sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS female_clients_in_south_bohemia\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE c.gender = 'F' AND di.A3 = 'south Bohemia';"
        ],
        "question": "How many female clients' accounts are in the region of South Bohemia?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A3 = 'south Bohemia'",
        "amends": [],
        "rules": [
            "Female refers to gender = 'F'; A3 contains the region 'south Bohemia'"
        ]
    },
    "395": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'UDON' \nAND availability LIKE '%mtgo%' \nAND hand = '-1';"
        ],
        "question": "How many cards designed by UDON and available in mtgo print type has a starting maximum hand size of -1?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE hAND = '-1' AND artist = 'UDON' AND Availability = 'mtgo' ",
        "amends": [],
        "rules": [
            "UDON refer to artist; availabe in mtgo refers to availability = 'mtgo'; starting maximum hand size of -1 refers to hand = -1"
        ]
    },
    "135": {
        "sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS negative_balance_accounts\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nWHERE a.frequency = 'POPLATEK MESICNE'\nAND t.operation = 'VYBER KARTOU'\nAND t.balance < 0;",
            "SELECT COUNT(T1.account_id)\nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.balance < 0\nAND T1.operation = 'Credit Card Withdrawal'\nAND T2.frequency = 'Monthly Issuance';",
            "SELECT COUNT(T1.account_id)\nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.balance < 0\nAND T1.operation = 'VYBER KARTOU'\nAND T2.frequency = 'POPLATEK MESICNE'"
        ],
        "question": "After making a credit card withdrawal, how many account/s with monthly issuance has a negative balance?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.balance < 0 AND T1.operation = 'VYBER KARTOU' AND T2.frequency = 'POPLATEK MESICNE'",
        "amends": [
            "Do use `COUNT(T1.account_id)` without `DISTINCT` instead of `COUNT(DISTINCT a.account_id)` to count all matching rows rather than unique accounts. Do reference `trans` as `T1` and `account` as `T2` instead of `a` and `t` aliases. Do use `INNER JOIN` with explicit `AS` keyword instead of simple `JOIN` for clarity. Do place the `balance < 0` condition first in the `WHERE` clause instead of last, and do combine all filter conditions in a single `WHERE` clause instead of separating them. Do remove the column alias `negative_balance_accounts` instead of keeping it since the result set only contains the count. The amended query now correctly counts all transactions meeting the criteria rather than unique accounts, matching the RIGHT_SQL's behavior.",
            "Do use the operation filter `'VYBER KARTOU'` instead of `'Credit Card Withdrawal'` in the WHERE clause, and do use the frequency filter `'POPLATEK MESICNE'` instead of `'Monthly Issuance'` in the WHERE clause, while keeping the same table structure with `INNER JOIN` on `T1.account_id = T2.account_id` and maintaining the count of accounts with negative balance. The amended query now correctly filters for the specific operation and frequency values used in the RIGHT_SQL."
        ],
        "rules": [
            "Negative balance means balance < 0; Operation = 'VYBER KARTOU' stands for credit card withdraw. Frequency = 'POPLATEK MESICNE' stands for monthly issurance"
        ]
    },
    "601": {
        "sql": [
            "SELECT p.Score, pl.LinkTypeId FROM posts p LEFT JOIN postLinks pl ON p.Id = pl.PostId WHERE p.Id = 395;"
        ],
        "question": "What is the score and the link type ID for post ID 395?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395",
        "amends": [],
        "rules": []
    },
    "1055": {
        "sql": [
            "SELECT p.birthday\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);"
        ],
        "question": "When is the birthday of the football player who has the highest overall rating?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.birthday FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
        "amends": [],
        "rules": [
            "football player who has the highest overall rating refers to MAX(overall_rating);"
        ]
    },
    "1443": {
        "sql": [
            "SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';"
        ],
        "question": "Give the event ID, location, and status of events conducted from November 2019 to March 2020.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT event_id, location, status FROM event WHERE date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-11-01' AND '2020-03-31'",
        "amends": [],
        "rules": [
            "event_date BETWEEN '2019-11-01' and '2020-03-31'"
        ]
    },
    "108": {
        "sql": [
            "WITH biggest_loan AS (\n    SELECT account_id, amount\n    FROM loan\n    ORDER BY amount DESC\n    LIMIT 1\n),\nclient_info AS (\n    SELECT c.client_id, c.gender, c.birth_date, d.account_id\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN biggest_loan bl ON d.account_id = bl.account_id\n    WHERE d.type = 'OWNER'\n),\naccount_opening_date AS (\n    SELECT a.account_id, a.date AS account_date\n    FROM account a\n    JOIN biggest_loan bl ON a.account_id = bl.account_id\n),\nfirst_transaction AS (\n    SELECT t.account_id, t.amount, t.date\n    FROM trans t\n    JOIN account_opening_date aod ON t.account_id = aod.account_id\n    WHERE t.date > aod.account_date\n    ORDER BY t.date ASC\n    LIMIT 1\n)\nSELECT ci.client_id, ci.gender, ci.birth_date, ft.amount AS first_transaction_amount\nFROM client_info ci\nJOIN first_transaction ft ON ci.account_id = ft.account_id;",
            "SELECT T3.amount\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN trans T3 ON T2.account_id = T3.account_id\nORDER BY T1.amount DESC, T3.date ASC\nLIMIT 1"
        ],
        "question": "For the client who applied the biggest loan, what was his/her first amount of transaction after opened the account?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY T1.amount DESC, T3.date ASC LIMIT 1",
        "amends": [
            "Do use a simple `SELECT` with joins instead of a complex CTE structure. Do join `loan`, `account`, and `trans` tables directly instead of creating multiple CTEs for biggest loan, client info, account dates, and first transactions. Do select only `T3.amount` instead of multiple client attributes like `client_id`, `gender`, and `birth_date`. Do use `INNER JOIN` between `loan` and `account` on `T1.account_id = T2.account_id` instead of the CTE-based approach. Do add a second `INNER JOIN` to `trans` on `T2.account_id = T3.account_id` instead of the separate first_transaction CTE. Do remove all WHERE conditions including the `d.type = 'OWNER'` filter and date comparisons. Do change the ordering to `ORDER BY T1.amount DESC, T3.date ASC` instead of separate ordering in CTEs. Do keep the `LIMIT 1` but apply it to the final result instead of intermediate CTEs. The amended query now correctly returns the transaction amount from the account with the largest loan, ordered by transaction date."
        ],
        "rules": []
    },
    "837": {
        "sql": [
            "SELECT hero_id FROM hero_attribute WHERE attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute);"
        ],
        "question": "Give the hero ID of superhero with the lowest attribute value.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT hero_id FROM hero_attribute WHERE attribute_value = ( SELECT MIN(attribute_value) FROM hero_attribute )",
        "amends": [],
        "rules": [
            "lowest attribute value refers to MIN(attribute_value);"
        ]
    },
    "1427": {
        "sql": [
            "SELECT b.category\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.location = 'MU 215'\n  AND e.type = 'Guest Speaker'\n  AND b.spent = 0;",
            "SELECT DISTINCT T2.category, T1.type\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nWHERE T1.location = 'MU 215' \nAND T1.type = 'Guest Speaker' \nAND T2.spent = 0"
        ],
        "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do include `T1.type` in the SELECT list instead of only selecting `b.category`. Do use table aliases `T1` and `T2` instead of `e` and `b`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do move the `T1.type = 'Guest Speaker'` filter to the WHERE clause instead of keeping it separate. Do ensure all column references use the correct table aliases throughout the query. The amended query now correctly returns distinct category and type combinations for events meeting all specified criteria."
        ],
        "rules": [
            "budget category refers to category; events located at refers to location; type = 'Guest Speaker'; 0 budget spent refers to spent = 0; "
        ]
    },
    "1278": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.IGG > 900 AND L.IGG < 2000 AND P.Admission = '+';",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGG < 2000 AND T1.Admission IS NOT NULL",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGG > 900 AND T2.IGG < 2000\nAND T1.Admission = '+'"
        ],
        "question": "Of the patients with an normal level of IGG, how many of them admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG > 900 AND T2.IGG <2000 AND  T1.Admission = '+'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do remove the space in `<2000` instead of keeping `< 2000` for formatting consistency. The amended query now correctly counts all patient records meeting the criteria rather than distinct patient IDs, matching the intended behavior.",
            "Do change the WHERE filter to `IGG > 900 AND IGG < 2000` instead of only `IGG < 2000` to properly bracket the IGG value range. Do change the Admission filter to `Admission = '+'` instead of `Admission IS NOT NULL` to specifically match positive admission indicators. The amended query now correctly counts patients with IGG values between 900 and 2000 who have positive admission status, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "normal level of IGG refers to 900 < IGG < 2000; admitted to the hospital refers to Admission = '+';"
        ]
    },
    "841": {
        "sql": [
            "SELECT s.weight_kg, r.race FROM superhero s JOIN race r ON s.race_id = r.id WHERE s.id = 40;"
        ],
        "question": "Provide the weight and race of the superhero with superhero ID 40.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.weight_kg, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.id = 40",
        "amends": [],
        "rules": [
            "weight refers to weight_kg; superhero ID 40 refers to superhero.id = 40;"
        ]
    },
    "695": {
        "sql": [
            "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Citizen Patrol';"
        ],
        "question": "How many users were awarded with 'Citizen Patrol' badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE `Name` = 'Citizen Patrol'",
        "amends": [],
        "rules": [
            "Citizen Patrol' is the name of the badge;"
        ]
    },
    "1316": {
        "sql": [
            "SELECT m.phone\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = \"Women's Soccer\";"
        ],
        "question": "Please list the phone numbers of the students from the Student_Club that has attended the event \"Women's Soccer\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.phone FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer'",
        "amends": [],
        "rules": [
            "Women's Soccer is an event name; phone numbers refers to phone"
        ]
    },
    "101": {
        "sql": [
            "SELECT a.account_id, a.district_id, a.frequency, a.date\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nWHERE t.date = (SELECT MIN(date) FROM trans WHERE strftime('%Y', date) = '1995')\nAND strftime('%Y', t.date) = '1995';",
            "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1;"
        ],
        "question": "List out the accounts who have the earliest trading date in 1995 ?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1",
        "amends": [
            "Do select only `account_id` instead of multiple columns including `account_id`, `district_id`, `frequency`, and `date`. Do query from `trans` table only instead of joining `account` and `trans` tables. Do use a simple `WHERE` filter with `STRFTIME('%Y', date) = '1995'` instead of a subquery to find the minimum date and additional join conditions. Do add `ORDER BY date ASC LIMIT 1` to get the earliest transaction instead of using a subquery to find the minimum date. Do remove the unnecessary table join and multiple column selection instead of keeping the complex structure. The amended query now correctly returns the account_id of the earliest transaction from 1995, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "1117": {
        "sql": [
            "SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10;"
        ],
        "question": "What are the player api id of 10 heaviest players?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10",
        "amends": [],
        "rules": [
            "heaviest refers to MAX(weight)"
        ]
    },
    "615": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN u.Age BETWEEN 13 AND 19 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_teenagers\nFROM \n    badges b\nJOIN \n    users u ON b.UserId = u.Id\nWHERE \n    b.Name = 'Organizer';"
        ],
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "amends": [],
        "rules": [
            "\"Organizer\" is the Name of badge; teenager refers to Age BETWEEN 13 AND 18; percentage = Divide (Count(UserId where Age BETWEEN 13 AND 18), Count(UserId)) *100"
        ]
    },
    "1348": {
        "sql": [
            "SELECT COUNT(*) \nFROM budget \nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'November Meeting') \nAND spent > amount;"
        ],
        "question": "For all the budgets for \"November Meeting\", how many of them had exceeded the budget?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.event_id) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Meeting' AND T1.remaining < 0",
        "amends": [],
        "rules": [
            "'November Meeting' is an event name; remaining < 0 means the cost had exceeded the budget"
        ]
    },
    "245": {
        "sql": [
            "SELECT COUNT(bond_id) * 1.0 / COUNT(DISTINCT a.atom_id) AS average_bonds_per_iodine_atom\nFROM atom a\nLEFT JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nWHERE a.element = 'i';",
            "SELECT AVG(bond_count) AS average_bonds\nFROM (\n    SELECT COUNT(connected.bond_id) AS bond_count\n    FROM atom\n    INNER JOIN connected ON atom.atom_id = connected.atom_id\n    WHERE atom.element = 'iodine'\n    GROUP BY atom.atom_id\n)",
            "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) AS average_bonds\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'i'"
        ],
        "question": "What is the average number of bonds the atoms with the element iodine have?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'i'",
        "amends": [
            "Do use `INNER JOIN` instead of `LEFT JOIN` to exclude atoms without bonds. Do join on `T1.atom_id = T2.atom_id` instead of the incorrect `OR` condition that included both join directions. Do remove the `DISTINCT` from `COUNT(T1.atom_id)` instead of counting distinct atom IDs since each bond connects to exactly one iodine atom. Do cast the bond count to `REAL` instead of multiplying by `1.0` for proper floating-point division. Do remove the unnecessary table aliases `a` and `c` instead of keeping them. The amended query now correctly calculates the average bonds per iodine atom by only counting actual bonds through proper inner joining and eliminates the double-counting issue from the original OR condition.",
            "Do calculate the average as `CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id)` instead of using `AVG(bond_count)` from a subquery. Do reference tables with aliases `T1` and `T2` instead of using unaliased table names. Do filter for element `'i'` instead of `'iodine'` to match the correct chemical symbol. Do remove the unnecessary subquery and `GROUP BY atom.atom_id` instead of keeping the nested aggregation structure. Do perform the division calculation directly in the main query instead of using an aggregate function on a subquery result. The amended query now correctly calculates the average bonds per iodine atom by counting bonds divided by atom count rather than averaging pre-counted bond values."
        ],
        "rules": [
            "atoms with the element iodine refers to element = 'i'; average = DIVIDE(COUND(bond_id), COUNT(atom_id)) where element = 'i'"
        ]
    },
    "600": {
        "sql": [
            "SELECT pl.PostId, pl.RelatedPostId, p.ViewCount AS Popularity\nFROM postLinks pl\nJOIN posts p ON pl.RelatedPostId = p.Id\nWHERE pl.RelatedPostId = 61217;\n\n-- To get the popularity of post ID 61217\nSELECT ViewCount AS Popularity\nFROM posts\nWHERE Id = 61217;",
            "SELECT T1.Id, T1.Title, T1.ViewCount AS Popularity\nFROM posts AS T1\nJOIN postLinks AS T2 ON T1.Id = T2.RelatedPostId\nWHERE T2.PostId = 61217",
            "SELECT T1.ViewCount\nFROM posts AS T1\nINNER JOIN postLinks AS T2 ON T1.Id = T2.PostId\nWHERE T2.RelatedPostId = 61217;",
            "SELECT T1.ViewCount\nFROM posts AS T1\nINNER JOIN postLinks AS T2 ON T1.Id = T2.PostId\nWHERE T2.PostId = 61217"
        ],
        "question": "List out all post that are related to post ID 61217 and what is the popularity of this post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.ViewCount FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 61217",
        "amends": [
            "Do select `T1.ViewCount` instead of `pl.PostId`, `pl.RelatedPostId`, and `p.ViewCount AS Popularity`. Do join `posts AS T1` with `postLinks AS T2` on `T1.Id = T2.PostId` instead of joining `postLinks pl` with `posts p` on `pl.RelatedPostId = p.Id`. Do filter on `T2.PostId = 61217` instead of `pl.RelatedPostId = 61217`. The amended query now correctly retrieves the view count from the posts table by joining on the proper PostId relationship rather than the RelatedPostId, matching the intended behavior of the right SQL.",
            "Do select only `T1.ViewCount` instead of `T1.Id`, `T1.Title`, and `T1.ViewCount AS Popularity`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do join on `T1.Id = T2.PostId` instead of `T1.Id = T2.RelatedPostId` to correctly link posts to their related post links. Do remove the alias `Popularity` since only the raw `ViewCount` is needed. The amended query now correctly retrieves view counts for posts linked to post ID 61217.",
            "Do filter on `T2.PostId = 61217` instead of `T2.RelatedPostId = 61217` to correctly identify the target post by its direct ID rather than a related post reference. The amended query now matches RIGHT_SQL's behavior by fixing the predicate to target the intended post directly."
        ],
        "rules": [
            "post related refers to RelatedPostId; popularity refers to ViewCount"
        ]
    },
    "188": {
        "sql": [
            "SELECT l.account_id, l.amount, a.date AS account_opening_date\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nWHERE l.duration > 24\nAND a.date < '1997-01-01'\nAND l.amount = (SELECT MIN(amount) FROM loan WHERE duration > 24);",
            "SELECT T1.account_id\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE T1.duration > 24\nAND STRFTIME('%Y', T2.date) < '1997'\nORDER BY T1.amount ASC\nLIMIT 1;"
        ],
        "question": "Among the accounts who have loan validity more than 24 months, list out the accounts that have the lowest approved amount and have account opening date before 1997.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.duration > 24 AND STRFTIME('%Y', T2.date) < '1997' ORDER BY T1.amount ASC LIMIT 1",
        "amends": [
            "Do select only `account_id` instead of including `amount` and `account_opening_date`. Do use `INNER JOIN` with explicit alias `T2` instead of `JOIN` with alias `a`. Do filter by year extraction `STRFTIME('%Y', T2.date)` instead of direct date comparison `a.date < '1997-01-01'`. Do remove the subquery for minimum amount and instead use `ORDER BY T1.amount ASC LIMIT 1` to get the single smallest amount record instead of comparing against all minimum amounts. Do add explicit `ORDER BY` and `LIMIT` clauses instead of omitting them. The amended query now correctly returns the account with the smallest loan amount from 1996 or earlier with duration over 24 months, matching the intended behavior."
        ],
        "rules": []
    },
    "901": {
        "sql": [
            "SELECT races.name AS race_name, circuits.name AS circuit_name, circuits.location\nFROM races\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE races.date BETWEEN '2005-09-01' AND '2005-09-30'"
        ],
        "question": "Name the races along with its circuit name and location for f1 races hosted in September 2005.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name, T1.name, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2005 AND STRFTIME('%m', T2.date) = '09'",
        "amends": [],
        "rules": [
            "in September 2005 refers to MONTH(date) = 9 and YEAR(date) = 2005"
        ]
    },
    "1385": {
        "sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN income i ON m.member_id = i.link_to_member\nWHERE i.amount > 40;"
        ],
        "question": "Which student was able to generate income more than $40?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.amount > 40",
        "amends": [],
        "rules": [
            "name of students means the full name; full name refers to first_name, last_name; generate income more than $50 refers to income.amount > 40"
        ]
    },
    "1508": {
        "sql": [
            "SELECT COUNT(*) \nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE' AND t.Price > 1000;"
        ],
        "question": "How many transactions taken place in the gas station in the Czech Republic are with a price of over 1000?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND T1.Price > 1000",
        "amends": [],
        "rules": [
            "Gas station in the Czech Republic implies that Country = 'CZE'"
        ]
    },
    "992": {
        "sql": [
            "SELECT \n    forename || ' ' || surname AS full_name,\n    url AS wikipedia_link,\n    dob AS date_of_birth\nFROM \n    drivers\nWHERE \n    nationality = 'German' \n    AND strftime('%Y', dob) BETWEEN '1971' AND '1985'\nORDER BY \n    dob DESC;",
            "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND dob BETWEEN '1971-01-01' AND '1985-12-31' ORDER BY dob DESC;"
        ],
        "question": "Find the full name, Wiki Pedia page link, and date of birth of German drivers born between 1971 and 1985. List it in descending order of date of birth.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND STRFTIME('%Y', dob) BETWEEN '1971' AND '1985' ORDER BY dob DESC",
        "amends": [
            "Do select individual columns `forename`, `surname`, `url`, and `dob` instead of concatenating `forename || ' ' || surname` as `full_name` and aliasing `url` as `wikipedia_link` and `dob` as `date_of_birth`. The amended query now matches RIGHT_SQL's behavior by returning the raw column values rather than transformed and aliased outputs."
        ],
        "rules": [
            "FFull name refers to forname+surname; Nationality refers to German; Date of birth refers to dob; year(dob) BETWEEN '1971' AND '1985'"
        ]
    },
    "731": {
        "sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'DC Comics');"
        ],
        "question": "How many superheroes did DC Comics publish?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics'",
        "amends": [],
        "rules": [
            "superheroes that DC Comics published refers to publisher_name = 'DC Comics'"
        ]
    },
    "1500": {
        "sql": [
            "SELECT DISTINCT p.Description\nFROM products p\nJOIN transactions_1k t ON p.ProductID = t.ProductID\nJOIN yearmonth ym ON t.CustomerID = ym.CustomerID AND ym.Date = '201309';"
        ],
        "question": "Please list the product description of the products consumed in September, 2013.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "amends": [],
        "rules": [
            "September 2013 refers to 201309; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
        ]
    },
    "1365": {
        "sql": [
            "SELECT e.expense_description\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nWHERE b.remaining = (SELECT MIN(remaining) FROM budget);",
            "SELECT T2.expense_id, T2.expense_description, T2.expense_date, T2.cost, T2.approved, T2.link_to_member, T2.link_to_budget FROM budget T1 INNER JOIN expense T2 ON T1.budget_id = T2.link_to_budget ORDER BY T1.remaining LIMIT 1",
            "SELECT T2.expense_description \nFROM budget T1 \nINNER JOIN expense T2 ON T1.budget_id = T2.link_to_budget \nORDER BY T1.remaining \nLIMIT 1"
        ],
        "question": "What are the expenses of the budget with the lowest remaining?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.expense_description FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget ORDER BY T1.remaining LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` instead of `JOIN` and specify the join condition as `T1.budget_id = T2.link_to_budget` instead of `e.link_to_budget = b.budget_id`. Do add `ORDER BY T1.remaining LIMIT 1` instead of using a subquery with `WHERE b.remaining = (SELECT MIN(remaining) FROM budget)`. Do remove the subquery entirely instead of keeping it. Do change the table aliases to `T1` and `T2` instead of `b` and `e`. The amended query now correctly finds the single expense with the smallest remaining budget amount using ordering and limiting instead of potentially returning multiple matches from the subquery approach.",
            "Do select only `T2.expense_description` instead of including multiple columns like `T2.expense_id`, `T2.expense_date`, `T2.cost`, `T2.approved`, `T2.link_to_member`, and `T2.link_to_budget`. Do maintain the `INNER JOIN` on `T1.budget_id = T2.link_to_budget` between `budget` and `expense` tables. Do preserve the `ORDER BY T1.remaining` and `LIMIT 1` clauses to return the single expense description from the budget with the smallest remaining amount. The amended query now correctly returns only the expense description instead of unnecessary expense details, matching the intended focused result set."
        ],
        "rules": [
            "expense of budget refers to expense_description; lowest remaining refers to MIN(remaining)"
        ]
    },
    "966": {
        "sql": [
            "SELECT COUNT(DISTINCT driverId) FROM results WHERE raceId = 18;",
            "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18;"
        ],
        "question": "How many driver participated in race ID number 18?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18",
        "amends": [
            "Do query the `driverStandings` table instead of the `results` table. Do remove the `DISTINCT` modifier from the `COUNT` function instead of keeping it. Do use `COUNT(driverId)` instead of `COUNT(DISTINCT driverId)` to count all driver entries rather than unique drivers. The amended query now correctly counts all driver entries in the driver standings for race 18, matching the intended behavior."
        ],
        "rules": []
    },
    "239": {
        "sql": [
            "SELECT COUNT(DISTINCT bond_id) AS connection_count FROM connected WHERE atom_id LIKE 'TR%_19' OR atom_id2 LIKE 'TR%_19';"
        ],
        "question": "How many connections does the atom 19 have?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
        "amends": [],
        "rules": [
            "connections refers to bond_id; atom 19 refers to atom_id like 'TR%_19';"
        ]
    },
    "326": {
        "sql": [
            "SELECT DISTINCT m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 's' AND b.bond_type = ' = ';",
            "SELECT T1.molecule_id\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 's' AND T2.bond_type = '='"
        ],
        "question": "Which molecule consisted of Sulphur atom with double bond?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='",
        "amends": [
            "Do select `molecule_id` instead of `label` and use table alias `T1` instead of `m`. Do use `INNER JOIN` with `bond AS T2` instead of multiple joins through `connected` and `bond` tables. Do join on `T1.molecule_id = T2.molecule_id` instead of complex join conditions involving `atom_id` and `bond_id`. Do filter for `T1.element = 's'` and `T2.bond_type = '='` instead of including spaces around the equals sign. Do remove the unnecessary `DISTINCT` if the query logic ensures uniqueness through the join conditions. The amended query now correctly identifies molecules containing sulfur atoms with double bonds by directly joining atom and bond tables on molecule_id, eliminating the need for the intermediate connected table and fixing the bond_type comparison."
        ],
        "rules": [
            "sulphur refers to element - 's'; double bond refers to bond_type = ' = ';"
        ]
    },
    "1414": {
        "sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Phillip' AND mb.last_name = 'Cullen';"
        ],
        "question": "State the name of major that Phillip Cullen has joined.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "amends": [],
        "rules": [
            "name of major refers to major_name"
        ]
    },
    "920": {
        "sql": [
            "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit';"
        ],
        "question": "Please list all the years that Silverstone Circuit was used in a Formula_1 race.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "amends": [],
        "rules": []
    },
    "899": {
        "sql": [
            "SELECT c.circuitId, c.name, c.location, c.country, COUNT(r.raceId) AS race_count\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nWHERE r.year BETWEEN 1990 AND 2000\nGROUP BY c.circuitId, c.name, c.location, c.country\nHAVING COUNT(r.raceId) = 4;",
            "SELECT DISTINCT T1.name\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000'\nGROUP BY T1.name\nHAVING COUNT(T2.raceId) = 4"
        ],
        "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
        "amends": [
            "Do use `DISTINCT` on `T1.name` instead of selecting multiple columns without distinct. Do select only `T1.name` instead of including `circuitId`, `location`, and `country`. Do use `INNER JOIN` with table aliases `T1` and `T2` instead of simple `JOIN` with aliases `c` and `r`. Do join on `T2.circuitID = T1.circuitId` instead of `c.circuitId = r.circuitId`. Do filter using `STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000'` instead of `r.year BETWEEN 1990 AND 2000`. Do group by only `T1.name` instead of grouping by all selected columns. Do keep the same `HAVING COUNT(T2.raceId) = 4` condition. The amended query now correctly filters by year extracted from date strings and returns only distinct circuit names with exactly 4 races in the specified date range."
        ],
        "rules": [
            "from year 1990 to 2000 refers to year(date) between 1990 and 2000;"
        ]
    },
    "588": {
        "sql": [
            "SELECT COUNT(*) AS TotalComments FROM comments WHERE UserId = 13;"
        ],
        "question": "Give the total number of comments posted by user ID 13.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13",
        "amends": [],
        "rules": []
    },
    "440": {
        "sql": [
            "SELECT DISTINCT fd.language FROM foreign_data fd JOIN cards c ON fd.uuid = c.uuid WHERE c.name = 'A Pedra Fellwar';",
            "SELECT language FROM foreign_data WHERE name = 'A Pedra Fellwar';"
        ],
        "question": "Which foreign language used by \"A Pedra Fellwar\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'",
        "amends": [
            "Do remove the `JOIN cards c ON fd.uuid = c.uuid` clause instead of including an unnecessary table join. Do change the WHERE filter to use `name = 'A Pedra Fellwar'` directly on the foreign_data table instead of filtering through the joined cards table. Do simplify the SELECT list to just `language` instead of qualifying it with the `fd.` table alias since only one table remains. The amended query now correctly retrieves language information directly from the foreign_data table without the redundant join, matching the right SQL's behavior."
        ],
        "rules": [
            "\"A Pedra Fellwar\" refers to name = 'A Pedra Fellwar'"
        ]
    },
    "1377": {
        "sql": [
            "SELECT COUNT(*) FROM member WHERE position = 'President';"
        ],
        "question": "How many student have the position of president?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(member_id) FROM member WHERE position = 'President'",
        "amends": [],
        "rules": [
            "'President' is a position of Student Club"
        ]
    },
    "1105": {
        "sql": [
            "SELECT p.player_name, pa.attacking_work_rate\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Francesco Migliore' AND pa.date LIKE '2015-05-01%';",
            "SELECT t2.attacking_work_rate\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.`date` = '2015/5/1'\nAND t1.player_name = 'Francesco Migliore';",
            "SELECT t2.attacking_work_rate \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t2.`date` LIKE '2015-05-01%' \nAND t1.player_name = 'Francesco Migliore'"
        ],
        "question": "How was Francesco Migliore's attacking work rate on 2015/5/1?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.`date` LIKE '2015-05-01%' AND t1.player_name = 'Francesco Migliore'",
        "amends": [
            "Do select only `t2.attacking_work_rate` instead of both `p.player_name` and `pa.attacking_work_rate`. Do use table aliases `t1` and `t2` instead of `p` and `pa`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do place the `date` filter before the `player_name` filter instead of after it. Do use backticks around `date` instead of leaving it unquoted. The amended query now correctly returns only the attacking work rate for the specified player on the given date, matching the RIGHT_SQL's behavior.",
            "Do use `LIKE '2015-05-01%'` for date matching instead of exact string comparison `= '2015/5/1'` to accommodate potential timestamp formats and ensure proper date filtering. The amended query now correctly matches the RIGHT_SQL's behavior with appropriate date handling."
        ],
        "rules": [
            "Francesco Migliore refers to player_name = 'Francesco Migliore'; on 2015/5/1 refers to date LIKE '2015-05-01%';"
        ]
    },
    "335": {
        "sql": [
            "SELECT COUNT(DISTINCT b.molecule_id) AS total_molecules\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = ' = '\nAND (a1.element = 'o' OR a2.element = 'o');",
            "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '=' AND T1.element = 'o'"
        ],
        "question": "What is the total number of molecules with double bonded oxygen?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '=' AND T1.element = 'o'",
        "amends": [
            "Do select `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(DISTINCT b.molecule_id) AS total_molecules`. Do use `FROM atom AS T1` instead of `FROM bond b` and remove the `JOIN connected c`, `JOIN atom a1`, and `JOIN atom a2` tables. Do change to `INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id` instead of the complex join chain through the connected table. Do simplify the WHERE clause to `T2.bond_type = '=' AND T1.element = 'o'` instead of `b.bond_type = ' = ' AND (a1.element = 'o' OR a2.element = 'o')`, removing the OR condition and fixing the bond_type comparison spacing. Do remove the unnecessary column alias `AS total_molecules` instead of keeping it. The amended query now correctly counts molecules containing oxygen atoms with double bonds by directly joining atom and bond tables on molecule_id instead of traversing through the connected table structure."
        ],
        "rules": [
            "oxygen refers to element = 'o'; double bond refers to bond_type = ' = ';"
        ]
    },
    "541": {
        "sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Score = (SELECT MAX(Score) FROM posts);"
        ],
        "question": "What is the display name of the user who is the owner of the most valuable post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.FavoriteCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "most valuable post refers to Max(FavoriteCount)"
        ]
    },
    "820": {
        "sql": [
            "SELECT ha.attribute_value\nFROM hero_attribute ha\nJOIN superhero sh ON ha.hero_id = sh.id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE sh.superhero_name = 'Hulk' AND a.attribute_name = 'Strength';"
        ],
        "question": "How strong is the Hulk?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = 'Hulk' AND T3.attribute_name = 'Strength'",
        "amends": [],
        "rules": [
            "how strong refers to attribute_value WHERE attribute_name = 'Strength'; the Hulk refers to superhero_name = 'Hulk';"
        ]
    },
    "1138": {
        "sql": [
            "SELECT c.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE l.name = 'Poland Ekstraklasa';"
        ],
        "question": "In what country did the Poland Ekstraklasa take place?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT name FROM Country WHERE id IN ( SELECT country_id FROM League WHERE name = 'Poland Ekstraklasa' )",
        "amends": [],
        "rules": []
    },
    "336": {
        "sql": [
            "SELECT COUNT(DISTINCT b.molecule_id) \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.bond_type = '#' AND m.label = '-';"
        ],
        "question": "in molecules with triple bonds, how many of them are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND T1.label = '-'",
        "amends": [],
        "rules": [
            "triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1027": {
        "sql": [
            "SELECT p.player_name, pa.penalties\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY pa.penalties DESC\nLIMIT 10;",
            "SELECT t2.player_name\nFROM Player_Attributes AS t1\nINNER JOIN Player AS t2 ON t1.id = t2.id\nORDER BY t1.penalties DESC\nLIMIT 10"
        ],
        "question": "Indicate the full names of the top 10 players with the highest number of penalties.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.player_name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.id = t2.id ORDER BY t1.penalties DESC LIMIT 10",
        "amends": [
            "Do join `Player_Attributes AS t1` instead of `Player_Attributes pa` and use `INNER JOIN` instead of `JOIN`. Do reference `t1.id = t2.id` instead of `p.player_api_id = pa.player_api_id` for the join condition. Do select only `t2.player_name` instead of both `p.player_name` and `pa.penalties`. Do order by `t1.penalties` instead of `pa.penalties` while maintaining the `DESC` ordering and `LIMIT 10`. The amended query now correctly retrieves only player names ordered by penalties from the properly joined tables."
        ],
        "rules": [
            "full name refers to player_name; players with highest number of penalties refers to MAX(penalties);"
        ]
    },
    "955": {
        "sql": [
            "SELECT r.year, AVG(\n    CAST(SUBSTR(res.time, 1, 2) AS INTEGER) * 3600 +\n    CAST(SUBSTR(res.time, 4, 2) AS INTEGER) * 60 +\n    CAST(SUBSTR(res.time, 7, 2) AS INTEGER) +\n    CAST(SUBSTR(res.time, 10, 3) AS REAL) / 1000\n) AS average_time_seconds\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nWHERE res.position = 1 AND res.time IS NOT NULL AND r.year < 1975\nGROUP BY r.year;",
            "WITH time_in_seconds AS (\n    SELECT \n        T2.year,\n        CASE \n            WHEN T1.positionOrder = 1 THEN\n                CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600 + \n                CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60 + \n                CAST(SUBSTR(T1.time, 6, 2) AS REAL) + \n                CAST(SUBSTR(T1.time, 9) AS REAL) / 1000\n            ELSE NULL\n        END AS time_seconds\n    FROM results T1\n    JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T2.year < 1975\n),\nchampion_time AS (\n    SELECT \n        year,\n        AVG(time_seconds) AS avg_champion_time_seconds\n    FROM time_in_seconds\n    GROUP BY year\n    HAVING AVG(time_seconds) IS NOT NULL\n)\nSELECT \n    year,\n    avg_champion_time_seconds\nFROM champion_time\nORDER BY year;"
        ],
        "question": "What is the average time in seconds of champion for each year, before year 1975?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
        "amends": [
            "Do use a CTE structure with `time_in_seconds` and `champion_time` instead of a single query. Do calculate time conversion for all positions with `CASE WHEN positionOrder = 1` instead of filtering only position 1 in WHERE. Do use `positionOrder = 1` instead of `position = 1` for champion identification. Do extract time components with different substring positions: `SUBSTR(T1.time, 1, 1)` for hours instead of `SUBSTR(res.time, 1, 2)`, `SUBSTR(T1.time, 3, 2)` for minutes instead of `SUBSTR(res.time, 4, 2)`, `SUBSTR(T1.time, 6, 2)` for seconds instead of `SUBSTR(res.time, 7, 2)`, and `SUBSTR(T1.time, 9)` for milliseconds instead of `SUBSTR(res.time, 10, 3)`. Do add `HAVING AVG(time_seconds) IS NOT NULL` instead of omitting it to filter out null averages. Do use table aliases `T1` and `T2` instead of `res` and `r`. The amended query now correctly handles time format parsing and ensures valid average calculations by excluding null results."
        ],
        "rules": [
            "only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null; before year 1975 refers to year < 1975;"
        ]
    },
    "1193": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'F' \nAND P.Birthday BETWEEN '1980-01-01' AND '1989-12-31'\nAND (E.`ANA Pattern` IS NULL OR E.`ANA Pattern` != 'P');",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nJOIN Examination T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F' \nAND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989'\nAND T2.\"ANA Pattern\" != 'P'"
        ],
        "question": "Excluding all P only ANA Pattern patients, how many of the remainder are women born between 1980 and 1989?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.`ANA Pattern` != 'P' AND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989' AND T1.SEX = 'F'",
        "amends": [
            "Do use `T1.ID` and `T2.ID` as table aliases instead of `P.ID` and `E.ID`. Do change the join condition to `T1.ID = T2.ID` instead of `P.ID = E.ID`. Do move the `ANA Pattern` filter from an OR condition with NULL check to a direct `T2.ANA Pattern != 'P'` instead of `(E.ANA Pattern IS NULL OR E.ANA Pattern != 'P')`. Do use `STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989'` for year extraction instead of `P.Birthday BETWEEN '1980-01-01' AND '1989-12-31'`. Do maintain `T1.SEX = 'F'` instead of `P.SEX = 'F'`. The amended query now correctly filters by year range using date functions and simplifies the ANA Pattern condition while maintaining the same join logic and distinct patient count."
        ],
        "rules": [
            "Excluding all P only ANA Pattern refers to `ANA Pattern`! = 'P'; women refers to SEX = 'F'; born between 1980 and 1989 refers to BIRTHDAY"
        ]
    },
    "954": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN r.time IS NOT NULL THEN 1 END) * 100.0 / COUNT(*)) AS race_completion_percentage\nFROM \n    results r\nJOIN \n    drivers d ON r.driverId = d.driverId\nJOIN \n    races rc ON r.raceId = rc.raceId\nWHERE \n    d.nationality = 'Japanese'\n    AND rc.year BETWEEN 2007 AND 2009;"
        ],
        "question": "Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.raceId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009",
        "amends": [],
        "rules": [
            "from 2007 to 2009 refers to year between 2007 and 2009; race completion refers to time is not null; percentage = Divide(COUNT(DriverID where time is not null and year between 2007 and 2009),Count (DriverID where year between 2007 and 2009))*100; "
        ]
    },
    "1009": {
        "sql": [
            "SELECT d.forename, d.surname, p.duration\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nJOIN races r ON p.raceId = r.raceId\nWHERE r.name = 'Australian Grand Prix' AND r.year = 2011;",
            "SELECT T1.duration\nFROM pitStops T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'"
        ],
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "amends": [
            "Do select only `T1.duration` instead of including `d.forename, d.surname, p.duration`. Do remove the `drivers` table join and all driver-related columns instead of keeping them. Do use table aliases `T1` for `pitStops` and `T2` for `races` instead of `p` and `r`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do place the `WHERE` conditions `T2.year = 2011 AND T2.name = 'Australian Grand Prix'` in the same logical order instead of a different sequence. The amended query now correctly retrieves only pit stop durations for the specified race without unnecessary driver information."
        ],
        "rules": [
            "time spent at pit stop refers to duration"
        ]
    },
    "401": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN isOnlineOnly = 1 AND frameEffects = 'legendary' THEN 1 END) * 100.0 / \n    COUNT(CASE WHEN frameEffects = 'legendary' THEN 1 END)) AS percentage\nFROM \n    cards\nWHERE \n    frameEffects = 'legendary';"
        ],
        "question": "What percentage of legendary frame effect cards that are only available in online game variations?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN isOnlineOnly = 1 THEN 1.0 ELSE 0 END) / COUNT(id) * 100 FROM cards WHERE frameEffects = 'legendary'",
        "amends": [],
        "rules": [
            "only available in online game variationsrefer to isOnlineOnly =1 ; legendary frame effect cards refer to frameEffects = 'legendary'; percentage refer to DIVIDE(COUNT(isOnlineOnly=1), COUNT(id)) from cards where frameEffects = 'legendary'"
        ]
    },
    "467": {
        "sql": [
            "SELECT s.baseSetSize \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Hauptset Zehnte Edition';"
        ],
        "question": "How many cards are there in the base set of \"Hauptset Zehnte Edition\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "amends": [],
        "rules": [
            "\"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; number of cards refers to baseSetSize"
        ]
    },
    "732": {
        "sql": [
            "SELECT p.publisher_name\nFROM publisher p\nJOIN superhero s ON p.id = s.publisher_id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nORDER BY ha.attribute_value ASC\nLIMIT 1;"
        ],
        "question": "Which publisher published the slowest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed' ORDER BY T3.attribute_value LIMIT 1",
        "amends": [],
        "rules": [
            "the slowest superhero refers to attribute_name = 'Speed' where MIN(attribute_value); publisher refers to publisher_name"
        ]
    },
    "1393": {
        "sql": [
            "SELECT first_name || ' ' || last_name AS full_name, email FROM member WHERE position = 'Secretary';",
            "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'"
        ],
        "question": "Provide the full name and email address of the Student_Club's Secretary.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'",
        "amends": [
            "Do select individual columns `first_name` and `last_name` instead of concatenating them with `|| ' ' ||` into a single `full_name` alias. Do remove the concatenation expression and alias while keeping the same `email` column and `WHERE position = 'Secretary'` filter unchanged. The amended query now matches RIGHT_SQL's behavior by returning separate first and last name columns rather than a combined full name string."
        ],
        "rules": [
            "full name refers to first_name, last_name; 'Secretary' is a position of Student Club"
        ]
    },
    "241": {
        "sql": [
            "SELECT COUNT(*) FROM molecule WHERE label = '-';"
        ],
        "question": "How many of the molecules are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1466": {
        "sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, ma.college\nFROM member m\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE m.position = 'Secretary';",
            "SELECT T1.first_name, T1.last_name, T2.college FROM member T1 INNER JOIN major T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Secretary'"
        ],
        "question": "Write the full name of the club member with the position of 'Secretary' and list which college the club member belongs to.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name, college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Secretary'",
        "amends": [
            "Do use separate columns `first_name` and `last_name` instead of concatenating them as `full_name`. Do reference the major table as `T2` instead of `ma` and use `T2.college` instead of `ma.college`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reverse the join condition to `T2.major_id = T1.link_to_major` instead of `m.link_to_major = ma.major_id` for clarity. Do use table alias `T1` consistently instead of mixing `m` and `T1`. The amended query now correctly selects individual name columns and maintains the same join logic with proper table aliasing."
        ],
        "rules": [
            "full name refers to first_name, last name"
        ]
    },
    "1152": {
        "sql": [
            "SELECT \n    (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '-') AS outpatient_count,\n    (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '+') AS inpatient_count,\n    (1.0 * (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '-') / \n    (SELECT COUNT(*) FROM Patient WHERE Diagnosis = 'SLE' AND Admission = '+')) AS outpatient_to_inpatient_ratio\nFROM Patient\nWHERE Diagnosis = 'SLE'\nLIMIT 1;",
            "SELECT SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE';",
            "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)\nFROM Patient\nWHERE Diagnosis = 'SLE'"
        ],
        "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
        "amends": [
            "Do use conditional aggregation with `SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END)` and `SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)` instead of multiple subqueries for counting. Do calculate the ratio directly as a division of these sums instead of separate count subqueries. Do remove the `WHERE Diagnosis = 'SLE'` filter from individual subqueries and instead apply it once in the main query. Do eliminate the unnecessary `LIMIT 1` clause instead of keeping it. Do remove the column aliases `outpatient_count`, `inpatient_count`, and `outpatient_to_inpatient_ratio` instead of including them since the query now returns a single ratio value. The amended query now correctly calculates the ratio of inpatient to outpatient SLE patients in a single efficient pass through the data.",
            "Do use `SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END)` as the numerator instead of `SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END)`, and do use `SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)` as the denominator instead of `SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END)` to correctly calculate the ratio of positive to negative admissions. The amended query now matches the intended behavior of computing the proportion of positive admissions relative to negative admissions for SLE patients."
        ],
        "rules": [
            "'SLE' diagnosed patient means Diagnosis = 'SLE'; inpatient refers to Admission = '+'; outpatient refers to Admission = '-'; calculation =  DIVIDE(COUNT(ID) where Diagnosis = 'SLE' and Admission = '+', COUNT(ID) where Diagnosis = 'SLE' and Admission = '-')"
        ]
    },
    "12": {
        "sql": [
            "SELECT MAX(f.`Free Meal Count (Ages 5-17)` / f.`Enrollment (Ages 5-17)`) AS highest_eligible_free_rate\nFROM satscores s\nJOIN frpm f ON s.cds = f.CDSCode\nWHERE (s.NumGE1500 * 1.0 / s.NumTstTakr) > 0.3;"
        ],
        "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT MAX(CAST(T1.`Free Meal Count (Ages 5-17)` AS REAL) / T1.`Enrollment (Ages 5-17)`) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3",
        "amends": [],
        "rules": [
            "Excellence rate = NumGE1500 / NumTstTakr; Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`"
        ]
    },
    "1121": {
        "sql": [
            "SELECT SUM(m.home_team_goal) AS total_home_goals\nFROM Match m\nJOIN Player p ON m.home_player_1 = p.player_api_id OR m.home_player_2 = p.player_api_id OR m.home_player_3 = p.player_api_id OR m.home_player_4 = p.player_api_id OR m.home_player_5 = p.player_api_id OR m.home_player_6 = p.player_api_id OR m.home_player_7 = p.player_api_id OR m.home_player_8 = p.player_api_id OR m.home_player_9 = p.player_api_id OR m.home_player_10 = p.player_api_id OR m.home_player_11 = p.player_api_id\nWHERE (julianday('now') - julianday(p.birthday)) / 365.25 <= 30;",
            "SELECT SUM(t2.home_team_goal) AS total_home_goals\nFROM Player t1\nINNER JOIN Match t2 ON t1.player_api_id = t2.away_player_1\nWHERE (datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(t1.birthday)) < 31"
        ],
        "question": "Calculate the total home team goal scored by players whose age are 30 years old and below.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_1 WHERE datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31",
        "amends": [
            "Do use `INNER JOIN` on `t1.player_api_id = t2.away_player_1` instead of `JOIN` with multiple `OR` conditions on home players. Do filter with `datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31` instead of `(julianday('now') - julianday(p.birthday)) / 365.25 <= 30`. Do reference `t2.home_team_goal` instead of `m.home_team_goal` and use table aliases `t1` and `t2` instead of `p` and `m`. The amended query now correctly calculates age using datetime functions and joins on away players instead of home players, matching the intended behavior."
        ],
        "rules": [
            "age are 30 years old and below refers to SUBTRACT(datetime(CURRENT_TIMESTAMP,'localtime'), datetime(birthday) < 31)"
        ]
    },
    "1250": {
        "sql": [
            "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.\"U-PRO\" > 0 AND L.\"U-PRO\" < 30 AND P.Diagnosis = 'SLE';"
        ],
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "amends": [],
        "rules": [
            "normal proteinuria level refers to 0 < `U-PRO` < 30; diagnosed with SLE refers to Diagnosis = 'SLE';"
        ]
    },
    "1194": {
        "sql": [
            "SELECT p.SEX\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nJOIN Laboratory l ON p.ID = l.ID\nWHERE e.Diagnosis = 'PSS'\nAND l.CRP = '2+'\nAND l.CRE = 1\nAND l.LDH = 123;"
        ],
        "question": "What sex is the patient who in a medical examination was diagnosed with PSS and in a laboratory examination had a blood level of C-reactive protein de 2+, createnine 1 and LDH 123?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T3.ID = T2.ID WHERE T2.Diagnosis = 'PSS' AND T3.CRP = '2+' AND T3.CRE = 1.0 AND T3.LDH = 123",
        "amends": [],
        "rules": [
            "PSS' refers to diagnosis; blood level of C-reactive protein de 2+refers to CRP > 2; createnine 1 refers to CRE = 1; LDH 123 refers to LDH = 123"
        ]
    },
    "6": {
        "sql": [
            "SELECT s.CDSCode, s.School, s.District, s.County, sc.NumTstTakr, sc.AvgScrRead, sc.AvgScrMath, sc.AvgScrWrite\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.Magnet = 1 AND sc.NumTstTakr > 500;",
            "SELECT T2.School \nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.NumTstTakr > 500\nAND T2.Magnet = 1"
        ],
        "question": "Among the schools with the SAT test takers of over 500, please list the schools that are magnet schools or offer a magnet program.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Magnet = 1 AND T1.NumTstTakr > 500",
        "amends": [
            "Do select only `T2.School` instead of multiple columns including `s.CDSCode`, `s.School`, `s.District`, `s.County`, `sc.NumTstTakr`, `sc.AvgScrRead`, `sc.AvgScrMath`, and `sc.AvgScrWrite`. Do use explicit `INNER JOIN` with table aliases `T1` and `T2` instead of implicit `JOIN` with aliases `s` and `sc`. Do join on `T1.cds = T2.CDSCode` instead of `s.CDSCode = sc.cds`. Do apply the `Magnet = 1` filter to `T2` instead of `s` and the `NumTstTakr > 500` filter to `T1` instead of `sc`. The amended query now correctly focuses on retrieving only school names from magnet schools with sufficient test takers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Magnet schools or offer a magnet program means that Magnet = 1"
        ]
    },
    "446": {
        "sql": [
            "WITH abyssal_horror_set AS (\n    SELECT code FROM sets WHERE name = 'Abyssal Horror'\n),\ntotal_cards AS (\n    SELECT COUNT(*) AS total FROM cards WHERE setCode = (SELECT code FROM abyssal_horror_set)\n),\ncmc_10_cards AS (\n    SELECT COUNT(*) AS cmc_10 FROM cards WHERE setCode = (SELECT code FROM abyssal_horror_set) AND convertedManaCost = 10\n)\nSELECT (cmc_10 * 100.0 / NULLIF(total, 0)) AS percentage\nFROM total_cards, cmc_10_cards;",
            "SELECT \n    T1.name,\n    CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM \n    cards T1\nINNER JOIN \n    sets T2 ON T2.code = T1.setCode\nWHERE \n    T1.name = 'Abyssal Horror';",
            "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror';"
        ],
        "question": "What is percentage of the cards with a converted Mana Cost of 10 in set of Abyssal Horror?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'",
        "amends": [
            "Do use a single query with `INNER JOIN` between `cards` and `sets` on `T2.code = T1.setCode` instead of using CTEs with subqueries. Do filter with `WHERE T1.name = 'Abyssal Horror'` instead of filtering sets by name in a separate CTE. Do calculate the percentage using `CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)` instead of separate counts and division with `NULLIF`. Do include `T1.name` in the SELECT list instead of omitting it. The amended query now correctly joins the tables and filters for the specific card name while calculating the percentage of cards with converted mana cost of 10 within that set, matching the RIGHT_SQL's behavior.",
            "Do place the `T1.name` column at the end of the SELECT list instead of at the beginning, maintaining the same calculation expression `CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)` but without the alias `percentage`. Do use explicit table aliasing with `AS T1` instead of implicit `T1` in the FROM clause, while keeping the same `INNER JOIN` on `T2.code = T1.setCode` and identical `WHERE T1.name = 'Abyssal Horror'` filter. The amended query now matches RIGHT_SQL's behavior with identical logic and output structure."
        ],
        "rules": [
            "set of Abyssal Horror refers to name = 'Abyssal Horror'; percentage refers to DIVIDE(COUNT(convertedManaCost = 16),COUNT(convertedManaCost))*100"
        ]
    },
    "427": {
        "sql": [
            "SELECT DISTINCT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.code = 'ARC';"
        ],
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "amends": [],
        "rules": [
            "known as Archenemy refers to mcmName = 'Archenemy'; having the code ARC refers to setCode = 'ARC'"
        ]
    },
    "316": {
        "sql": [
            "SELECT DISTINCT a.molecule_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'c' AND m.label = '-';"
        ],
        "question": "Among the molecules which contain \"c\" element, which of them are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1066": {
        "sql": [
            "SELECT t.team_short_name, ta.buildUpPlayPassingClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_short_name = 'CLB';",
            "SELECT DISTINCT t2.buildUpPlayPassingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_short_name = 'CLB';"
        ],
        "question": "What is the passing class of CLB team?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'CLB'",
        "amends": [
            "Do select only `buildUpPlayPassingClass` instead of including `team_short_name`. Do use `DISTINCT` to eliminate duplicates instead of omitting it. Do use table aliases `t1` and `t2` instead of `t` and `ta`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do reference `t2.buildUpPlayPassingClass` instead of `ta.buildUpPlayPassingClass` in the SELECT clause. The amended query now correctly returns only distinct buildUpPlayPassingClass values for the specified team."
        ],
        "rules": [
            "passing class refers to buildUpPlayPassingClass; CLB refers to team_short_name = 'CLB';"
        ]
    },
    "947": {
        "sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) > '1980';"
        ],
        "question": "How many British drivers were born after 1980?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) > '1980'",
        "amends": [],
        "rules": [
            "born after 1980 refers to year (dob) >1980;"
        ]
    },
    "164": {
        "sql": [
            "SELECT c.client_id, c.gender, c.birth_date, c.district_id\nFROM `order` o\nJOIN disp d ON o.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE o.order_id = 32423;",
            "SELECT T3.client_id\nFROM `order` T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T4 ON T4.account_id = T2.account_id\nINNER JOIN client T3 ON T4.client_id = T3.client_id\nWHERE T1.order_id = 32423;"
        ],
        "question": "Who placed the order with the id 32423?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.client_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T4.account_id = T2.account_id  INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE T1.order_id = 32423",
        "amends": [
            "Do select only `client_id` instead of including `gender`, `birth_date`, and `district_id`. Do add `account` table with `INNER JOIN` on `T1.account_id = T2.account_id` instead of omitting it. Do change the join path from directly joining `disp` to `order` to instead join `disp` to `account` on `T4.account_id = T2.account_id`. Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of no aliases. The amended query now correctly follows the account relationship path and matches RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "642": {
        "sql": [
            "SELECT COUNT(*) FROM posts WHERE CreationDate BETWEEN '2010-07-21 00:00:00' AND '2010-07-21 23:59:59';",
            "SELECT COUNT(Id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'"
        ],
        "question": "How many posts were created on 21st July, 2010?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do query from `postHistory` table instead of `posts` to access the correct data source. Do use `date(CreationDate) = '2010-07-21'` instead of `BETWEEN '2010-07-21 00:00:00' AND '2010-07-21 23:59:59'` for more precise date filtering that handles timezone considerations properly. The amended query now correctly counts post history entries from the specified date."
        ],
        "rules": [
            "created on 21st July, 2010 refers to CreationDate BETWEEN '2010-07-21 00:00:00' and '2012-07-21 23:59:59';"
        ]
    },
    "1038": {
        "sql": [
            "SELECT l.name AS league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM Match m\nJOIN League l ON m.league_id = l.id\nGROUP BY m.league_id\nORDER BY total_goals ASC\nLIMIT 5;"
        ],
        "question": "List the top 5 leagues in ascending order of the number of goals made in all seasons combined.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name, SUM(t2.home_team_goal) + SUM(t2.away_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id GROUP BY t1.name ORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC LIMIT 5",
        "amends": [],
        "rules": [
            "number of goals made in all seasons combine = SUM(home_team_goal, away_team_goal);"
        ]
    },
    "1430": {
        "sql": [
            "SELECT m.last_name, m.position\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.expense_description = 'Pizza' AND e.expense_date = '2019-09-10';"
        ],
        "question": "What is the last name and position of the student that bought pizza on 09/10/2019?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.last_name, T1.position FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.expense_date = '2019-09-10' AND T2.expense_description = 'Pizza'",
        "amends": [],
        "rules": [
            "bought pizza on 09/10/2019 refers to expense_description = 'Pizza' where expense_date = '2019-09-10'"
        ]
    },
    "714": {
        "sql": [
            "SELECT c.Id, c.Text, c.CreationDate\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE u.DisplayName = 'Harvey Motulsky';",
            "SELECT T1.Text FROM comments T1 INNER JOIN users T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky'"
        ],
        "question": "List the comments commented by the user with a username of Harvey Motulsky.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky'",
        "amends": [
            "Do select only `T1.Text` instead of including `c.Id` and `c.CreationDate`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `c` and `u`. Do maintain the same join condition `T1.UserId = T2.Id` instead of changing it. Do keep the same WHERE filter `T2.DisplayName = 'Harvey Motulsky'` instead of modifying it. The amended query now correctly returns only comment text for the specified user, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "comments refer to Text; username of Harvey Motulsky refers to DisplayName = 'Harvey Motulsky';"
        ]
    },
    "1452": {
        "sql": [
            "SELECT SUM(e.cost) / COUNT(DISTINCT a.link_to_event) AS average_amount_paid\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN attendance a ON m.member_id = a.link_to_member\nWHERE m.position != 'Member';",
            "SELECT AVG(T1.cost) AS average_amount\nFROM expense AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nWHERE T2.position != 'Member';"
        ],
        "question": "What is the average amount paid by students in a position other than a member?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN member as T2 ON T1.link_to_member = T2.member_id WHERE T2.position != 'Member'",
        "amends": [
            "Do use `AVG(T1.cost)` instead of `SUM(e.cost) / COUNT(DISTINCT a.link_to_event)` to calculate the average expense amount directly. Do join only `expense AS T1` with `member as T2` instead of including an unnecessary `attendance a` table join. Do use `INNER JOIN` with `T1.link_to_member = T2.member_id` instead of the multi-table join structure. Do apply the filter `T2.position != 'Member'` directly in the WHERE clause instead of the original approach. Do remove the unnecessary DISTINCT operation and attendance table reference that incorrectly attempted to calculate average per event instead of average expense amount per member. The amended query now correctly calculates the average expense amount for non-Member positions by focusing only on the relevant expense and member tables."
        ],
        "rules": [
            "position other than a member refers to position ! = 'Member'; average amount paid = DIVIDE( SUM(cost), COUNT(event_id))"
        ]
    },
    "1381": {
        "sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nGROUP BY m.member_id, m.first_name, m.last_name\nHAVING COUNT(a.link_to_event) > 7;"
        ],
        "question": "List the name of students that have attended more than 7 events.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "amends": [],
        "rules": [
            "name of students means the full name; full name refers to first_name, last_name; attended more than 7 events refers to COUNT(link_to_event) > 7"
        ]
    },
    "1400": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN type = 'Community Service' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_share\nFROM \n    event\nWHERE \n    strftime('%Y', event_date) = '2019';"
        ],
        "question": "Among all events hold by the Student_Club in 2019, find the percentage share of events related to 'Community Service'",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(type) FROM event WHERE SUBSTR(event_date, 1, 4) = '2019'",
        "amends": [],
        "rules": [
            "DIVIDE(SUM(type = 'Community Service'), COUNT(event_id)) * 100 where event_date BETWEEN' 2019-01-01' and '2019-12-31'"
        ]
    },
    "759": {
        "sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.weight_kg = (SELECT MAX(weight_kg) FROM superhero);"
        ],
        "question": "What is the eye clolour of the heaviest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id ORDER BY T1.weight_kg DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the heaviest superhero refers to MAX(weight_kg); eye colour refers to colour where eye_colour_id = colour.id;"
        ]
    },
    "581": {
        "sql": [
            "SELECT u.DisplayName AS EditorName\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE p.Title = 'Open source tools for visualizing multi-dimensional data';",
            "SELECT T2.DisplayName FROM posts T1 JOIN users T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'"
        ],
        "question": "Who is the editor of the post titled 'Open source tools for visualizing multi-dimensional data?'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'",
        "amends": [
            "Do join on `T1.OwnerUserId = T2.Id` instead of `p.LastEditorUserId = u.Id` to correctly reference the post owner rather than the last editor. Do reference `T2.DisplayName` directly instead of aliasing it as `EditorName`. Do use table aliases `T1` and `T2` instead of `p` and `u` for consistency. Do add a question mark to the WHERE filter `'Open source tools for visualizing multi-dimensional data?'` instead of the exact match without punctuation. The amended query now correctly identifies post owners rather than last editors and matches the expected behavior."
        ],
        "rules": [
            "'Open source tools for visualizing multi-dimensional data' is the Title of Post; editor refers to DisplayName;"
        ]
    },
    "626": {
        "sql": [
            "SELECT COUNT(*) AS vote_count FROM votes WHERE strftime('%Y', CreationDate) = '2010';"
        ],
        "question": "How many votes were made in 2010?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM votes WHERE STRFTIME('%Y', CreationDate) = '2010'",
        "amends": [],
        "rules": [
            "YEAR(CreationDate) = 2010;"
        ]
    },
    "9": {
        "sql": [
            "SELECT COUNT(*) AS NumberOfCharterFundedSchools\nFROM satscores\nJOIN schools ON satscores.cds = schools.CDSCode\nWHERE satscores.AvgScrMath > 560\nAND schools.FundingType = 'Charter';",
            "SELECT COUNT(T2.\"School Code\") \nFROM satscores AS T1\nINNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath > 560 \nAND T2.\"Charter Funding Type\" = 'Directly funded'"
        ],
        "question": "Among the schools with the average score in Math over 560 in the SAT test, how many schools are directly charter-funded?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.`School Code`) FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath > 560 AND T2.`Charter Funding Type` = 'Directly funded'",
        "amends": [
            "Do join `frpm` as `T2` instead of `schools`, and use `INNER JOIN` instead of `JOIN` with the join condition `T1.cds = T2.CDSCode` instead of `satscores.cds = schools.CDSCode`. Do filter on `T2.`Charter Funding Type` = 'Directly funded'` instead of `schools.FundingType = 'Charter'`. Do count `T2.`School Code`` instead of `COUNT(*)` and remove the alias `NumberOfCharterFundedSchools` instead of keeping it. The amended query now correctly identifies directly funded charter schools through the appropriate table and filtering criteria."
        ],
        "rules": []
    },
    "157": {
        "sql": [
            "SELECT A15 AS number_of_crimes_1995 FROM district WHERE district_id = (SELECT district_id FROM account WHERE account_id = 532);"
        ],
        "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
        "amends": [],
        "rules": [
            "A15 contains information about number of committed crimes in 1995"
        ]
    },
    "62": {
        "sql": [
            "SELECT COUNT(*) AS TotalNonCharteredSchools\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.Charter = 0\nAND s.County = 'Los Angeles'\nAND (f.[Free Meal Count (K-12)] * 100.0 / f.[Enrollment (K-12)]) < 0.18;"
        ],
        "question": "What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.School) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.Charter = 0 AND CAST(T1.`Free Meal Count (K-12)` AS REAL) * 100 / T1.`Enrollment (K-12)` < 0.18",
        "amends": [],
        "rules": [
            "non-chartered schools refer to schools whose Charter = 0; K-12 means grades 1 through 12; percent of eligible free rate for K-12 = `Free Meal Count (K-12)` * 100 / `Enrollment (K-12)`"
        ]
    },
    "15": {
        "sql": [
            "SELECT s.District, AVG(sc.AvgScrRead) AS AvgReadingScore\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.StatusType = 'Active' AND sc.rtype = 'D'\nGROUP BY s.District\nORDER BY AvgReadingScore DESC\nLIMIT 1;",
            "SELECT s.District \nFROM schools s\nINNER JOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.StatusType = 'Active'\nORDER BY sc.AvgScrRead DESC\nLIMIT 1"
        ],
        "question": "Which active district has the highest average score in Reading?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1",
        "amends": [
            "Do select only `District` instead of selecting both `District` and `AVG(sc.AvgScrRead)` with an alias. Do use `INNER JOIN` instead of just `JOIN` while keeping the same join condition `T1.CDSCode = T2.cds`. Do remove the filter `sc.rtype = 'D'` instead of keeping it. Do remove the `GROUP BY s.District` clause instead of including it. Do order by `T2.AvgScrRead` directly instead of ordering by the computed average alias. The amended query now correctly returns the district with the highest reading score from active schools without unnecessary aggregation and filtering."
        ],
        "rules": []
    },
    "1224": {
        "sql": [
            "SELECT p.ID, p.SEX, p.Birthday, l.`T-BIL`\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory);",
            "SELECT T2.\"T-BIL\", T1.ID, T1.SEX, T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;"
        ],
        "question": "What is the highest total bilirubin level recorded? List out the patient details with ID, sex and birthday with that index.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.`T-BIL`, T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-BIL` DESC LIMIT 1",
        "amends": [
            "Do select `T-BIL` first instead of `ID` first in the column list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with `p` and `l`. Do remove the subquery filter for maximum `T-BIL` value instead of keeping it, and instead add `ORDER BY T-BIL DESC LIMIT 1` to get the single row with the highest value. Do add explicit table aliases `AS T1` and `AS T2` instead of omitting them. The amended query now correctly retrieves the patient with the highest T-BIL value by sorting and limiting rather than using a potentially problematic subquery approach that could return multiple rows if there are ties for maximum value."
        ],
        "rules": [
            "the highest total bilirubin refers to MAX(T-BIL)"
        ]
    },
    "906": {
        "sql": [
            "WITH hamilton_first_race AS (\n    SELECT r.raceId, r.year, r.round, r.name AS race_name, r.date\n    FROM results res\n    JOIN drivers d ON res.driverId = d.driverId\n    JOIN races r ON res.raceId = r.raceId\n    WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\n    ORDER BY r.year, r.round\n    LIMIT 1\n)\nSELECT hfr.race_name AS first_race, hfr.date, res.points\nFROM hamilton_first_race hfr\nJOIN results res ON hfr.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
            "SELECT T1.name, T2.points \nFROM races T1 \nJOIN driverStandings T2 ON T1.raceId = T2.raceId \nJOIN drivers T3 ON T2.driverId = T3.driverId \nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' \nORDER BY T1.year ASC \nLIMIT 1"
        ],
        "question": "Which was Lewis Hamilton first race? What was his points recorded for his first race event?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year ASC LIMIT 1",
        "amends": [
            "Do use `driverStandings` table instead of `results` table to get points data. Do join `races` directly with `driverStandings` on `raceId` instead of using a CTE with complex joins. Do remove the CTE structure entirely instead of keeping the nested query approach. Do reference tables with aliases `T1`, `T2`, and `T3` instead of full table names. Do filter directly in the main query's `WHERE` clause instead of using a CTE with separate filtering. Do add `ORDER BY T1.year ASC` instead of ordering by both `year` and `round`. Do select `T1.name` and `T2.points` instead of `race_name`, `date`, and `points`. Do remove the `date` column from the output instead of including it. The amended query now correctly retrieves Hamilton's points from the driver standings table for his first race year."
        ],
        "rules": [
            "first race refers to min(Year); Lewis Hamiltonrefers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;"
        ]
    },
    "1195": {
        "sql": [
            "SELECT AVG(l.ALB) AS average_albumin_level\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.SEX = 'F'\nAND (p.Diagnosis = 'SLE' OR EXISTS (SELECT 1 FROM Examination e WHERE e.ID = p.ID AND e.Diagnosis = 'SLE'))\nAND l.PLT > 400;"
        ],
        "question": "What is the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.ALB) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 400 AND T1.Diagnosis = 'SLE' AND T1.SEX = 'F'",
        "amends": [],
        "rules": [
            "average blood albumin level refers to AVG(ALB); female refers to SEX = 'F'; PLT greater than 400 refers to PLT > 400; diagnosed with SLE refers to Diagnosis= 'SLE'"
        ]
    },
    "223": {
        "sql": [
            "SELECT atom_id, atom_id2 FROM connected WHERE bond_id = 'TR000_2_5';",
            "SELECT T.atom_id FROM connected T WHERE T.bond_id = 'TR000_2_5'"
        ],
        "question": "What are the atom IDs of the bond TR000_2_5?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.atom_id FROM connected AS T WHERE T.bond_id = 'TR000_2_5'",
        "amends": [
            "Do select only `atom_id` instead of both `atom_id` and `atom_id2`. Do add table alias `T` for the `connected` table instead of omitting it. Do reference the column as `T.atom_id` instead of just `atom_id` in the SELECT clause. Do reference the column as `T.bond_id` instead of just `bond_id` in the WHERE filter. The amended query now correctly returns only the atom_id values from the specified bond, matching the intended behavior."
        ],
        "rules": [
            "TR000_2_5 is the bond id"
        ]
    },
    "721": {
        "sql": [
            "SELECT COUNT(*) AS blue_eyed_superheroes\nFROM superhero\nWHERE eye_colour_id = (SELECT id FROM colour WHERE colour = 'Blue');"
        ],
        "question": "How many superheroes have blue eyes?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue'",
        "amends": [],
        "rules": [
            "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id;"
        ]
    },
    "762": {
        "sql": [
            "SELECT sp.power_name, COUNT(hp.power_id) AS power_count\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nGROUP BY sp.power_name\nORDER BY power_count DESC\nLIMIT 1;",
            "SELECT T2.power_name, COUNT(T1.hero_id) \nFROM hero_power T1 \nINNER JOIN superpower T2 ON T1.power_id = T2.id \nGROUP BY T2.power_name \nORDER BY COUNT(T1.hero_id) DESC \nLIMIT 1;",
            "SELECT T2.power_name\nFROM hero_power T1\nINNER JOIN superpower T2 ON T1.power_id = T2.id\nGROUP BY T2.power_name\nORDER BY COUNT(T1.hero_id) DESC\nLIMIT 1"
        ],
        "question": "Which power do superheroes have the most of?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T1.hero_id) DESC LIMIT 1",
        "amends": [
            "Do use `T2.power_name` in the SELECT list instead of `sp.power_name` and remove the alias `power_count` instead of keeping it. Do use table aliases `T1` and `T2` instead of full table names and specify `INNER JOIN` explicitly instead of just `JOIN`. Do change the COUNT expression to `COUNT(T1.hero_id)` instead of `COUNT(hp.power_id)` to count heroes rather than power instances. Do move the ordering to use `ORDER BY COUNT(T1.hero_id) DESC` instead of ordering by the removed alias `power_count DESC`. The amended query now correctly identifies the most common power by counting distinct heroes who possess each power rather than counting power instances, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(T1.hero_id)` from the SELECT list instead of including it, as the query only needs to return the power name with the highest count rather than displaying the count value itself. Do keep the same `FROM` sources with `INNER JOIN` on `T1.power_id = T2.id` instead of changing the join logic. Do maintain the `GROUP BY T2.power_name` instead of altering the grouping. Do preserve the `ORDER BY COUNT(T1.hero_id) DESC` instead of modifying the ordering, as this correctly identifies the power with the maximum occurrence. Do retain `LIMIT 1` instead of removing the limit, ensuring only the top result is returned. The amended query now correctly returns only the power name with the highest frequency count while maintaining the same logical behavior as the RIGHT_SQL."
        ],
        "rules": [
            "power that superheroes have the most refers to MAX(COUNT(power_name))"
        ]
    },
    "1271": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.SSA IN ('-', '+-') \nAND YEAR(P.`First Date`) < 2000;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.SSA IN ('negative', '0')\nAND STRFTIME('%Y', T2.Date) < '2000';"
        ],
        "question": "How many patients with a normal anti-SSA came to the hospital before 2000?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '2000'",
        "amends": [
            "Do use `T1.ID` and `T2.ID` as table aliases instead of `P.ID` and `L.ID`. Do change the SSA filter to `IN ('negative', '0')` instead of `IN ('-', '+-')`. Do use `STRFTIME('%Y', T2.Date)` for year extraction instead of `YEAR(P.\"First Date\")`. Do reference `T2.Date` instead of `P.\"First Date\"` for the date comparison. The amended query now correctly filters laboratory results with specific SSA values and uses the laboratory date for year comparison, matching the intended behavior."
        ],
        "rules": [
            "normal anti-SSA refers to SSA IN('-','+-'); came to the hospital before 2000 refers to YEAR(`First Date`) < 2000; Should compute the number of distinct ones"
        ]
    },
    "527": {
        "sql": [
            "SELECT r.date, r.text\nFROM rulings r\nJOIN cards c ON r.uuid = c.uuid\nWHERE c.artist = 'Kev Walker'\nORDER BY r.date DESC;",
            "SELECT T2.text \nFROM cards T1\nINNER JOIN rulings T2 ON T2.uuid = T1.uuid\nWHERE T1.artist = 'Kev Walker'\nORDER BY T2.date DESC"
        ],
        "question": "What are the rulings for the card named and designed by Kev Walker? List them in descending order of dates.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Kev Walker' ORDER BY T2.date DESC",
        "amends": [
            "Do reference the `text` column from the `rulings` table instead of selecting both `date` and `text` columns. Do use `INNER JOIN` with the join condition `T2.uuid = T1.uuid` instead of `JOIN` with `r.uuid = c.uuid`. Do filter on `T1.artist = 'Kev Walker'` in the WHERE clause instead of `c.artist = 'Kev Walker'`. Do order by `T2.date DESC` instead of `r.date DESC`. The amended query now correctly retrieves only the text column from rulings for cards by the specified artist, ordered by date."
        ],
        "rules": [
            "rulings refers to text; card named and designed by Kev Walker refers to artist = 'Kev Walker'; descending order of dates refers to MAX(date);"
        ]
    },
    "320": {
        "sql": [
            "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR000_1' AND c.atom_id2 = 'TR000_2') OR (c.atom_id = 'TR000_2' AND c.atom_id2 = 'TR000_1');"
        ],
        "question": "What is the type of the bond which is presenting the connection between two atoms TR000_1 and TR000_2?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'",
        "amends": [],
        "rules": [
            "type of bond refers to bond_type; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ]
    },
    "1314": {
        "sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.department = 'Art and Design';",
            "SELECT T1.first_name || ' ' || T1.last_name AS full_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.department = 'Art and Design Department';",
            "SELECT T1.first_name, T1.last_name FROM member T1 INNER JOIN major T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'"
        ],
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of single-letter aliases `m` and `maj`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use the full department name `'Art and Design Department'` in the WHERE filter instead of the truncated `'Art and Design'`. The amended query now correctly matches the intended logic by joining member and major tables with proper aliases and filtering for the complete department name.",
            "Do select individual columns `first_name` and `last_name` instead of concatenating them into a single `full_name` column. The amended query now matches RIGHT_SQL's behavior by returning separate first and last name fields rather than a combined full name string."
        ],
        "rules": [
            "full name refers to first_name, last_name;"
        ]
    },
    "943": {
        "sql": [
            "WITH race_info AS (\n    SELECT raceId\n    FROM races\n    WHERE year = 2008 AND name = 'Australian Grand Prix'\n),\ncompleted_laps AS (\n    SELECT COUNT(*) AS completed\n    FROM results\n    WHERE raceId = (SELECT raceId FROM race_info) AND time IS NOT NULL\n),\ntotal_drivers AS (\n    SELECT COUNT(*) AS total\n    FROM results\n    WHERE raceId = (SELECT raceId FROM race_info)\n)\nSELECT CAST(completed AS REAL) / CAST(total AS REAL) AS completion_rate\nFROM completed_laps, total_drivers;",
            "SELECT \n    (SUM(IIF(T1.time IS NOT NULL, 1, 0)) * 100.0 / COUNT(T1.resultId)) AS completion_rate\nFROM \n    results T1\nINNER JOIN \n    races T2 ON T1.raceId = T2.raceId\nWHERE \n    T2.name = 'Australian Grand Prix' AND T2.year = 2008;"
        ],
        "question": "What is the rate of drivers completing all the laps in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.resultId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008",
        "amends": [
            "Do use a single query with `INNER JOIN` between `results` and `races` on `raceId` instead of using CTEs with subqueries. Do calculate completion rate using `SUM(IIF(time IS NOT NULL, 1, 0))` for completed laps instead of separate CTEs for completed and total counts. Do multiply by `100` to get percentage instead of returning a decimal fraction. Do filter directly in the `WHERE` clause with `name = 'Australian Grand Prix' AND year = 2008` instead of using a CTE to first find the raceId. Do reference tables with aliases `T1` and `T2` instead of no aliases. Do count using `resultId` instead of generic `COUNT(*)` for more precise results. The amended query now correctly calculates the percentage completion rate for the specified race directly without unnecessary subqueries and CTEs."
        ],
        "rules": [
            "completing all the laps refers to time is not null; rate = divide(COUNT(raceID where time is not null), COUNT(raceID))"
        ]
    },
    "1366": {
        "sql": [
            "SELECT m.member_id, m.first_name, m.last_name, m.email, m.position, m.t_shirt_size, m.phone, m.zip, m.link_to_major\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'October Meeting';",
            "SELECT DISTINCT T3.member_id\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = 'October Meeting'"
        ],
        "question": "List all the members who attended the event \"October Meeting\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.member_id FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'October Meeting'",
        "amends": [
            "Do select only `member_id` instead of multiple columns including `first_name`, `last_name`, `email`, `position`, `t_shirt_size`, `phone`, `zip`, and `link_to_major`. Do add `DISTINCT` to eliminate duplicate member records instead of returning all attendance instances. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for both table joins. Do change the join condition from `m.member_id = a.link_to_member` to `T2.link_to_member = T3.member_id` for proper member table reference. Do use table aliases `T1`, `T2`, and `T3` instead of single-letter aliases `m`, `a`, and `e` for better clarity. The amended query now correctly returns only unique member IDs who attended the October Meeting instead of potentially duplicate member records with full details."
        ],
        "rules": [
            "'October Meeting' is an event name;"
        ]
    },
    "66": {
        "sql": [
            "SELECT COUNT(*) AS NumberOfDirectlyFundedSchools\nFROM schools\nWHERE County = 'Stanislaus'\nAND FundingType = 'Directly Funded'\nAND OpenDate BETWEEN '2000-01-01' AND '2005-12-31';",
            "SELECT COUNT(School) \nFROM schools \nWHERE County = 'Stanislaus' \nAND LOWER(FundingType) = 'directly funded' \nAND strftime('%Y', OpenDate) BETWEEN '2000' AND '2005'"
        ],
        "question": "Between 1/1/2000 to 12/31/2005, how many directly funded schools opened in the county of Stanislaus?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', OpenDate) BETWEEN '2000' AND '2005' AND County = 'Stanislaus' AND FundingType = 'Directly funded'",
        "amends": [
            "Do count `School` column instead of `COUNT(*)` to exclude NULL values. Do use `strftime('%Y', OpenDate)` for year extraction instead of `BETWEEN` with full date strings to properly handle year-only comparison. Do change `FundingType` filter to lowercase 'Directly funded' instead of 'Directly Funded' to match the actual case-sensitive data. Do remove the explicit `BETWEEN` date range condition and instead filter by year only through the strftime function. The amended query now correctly counts non-NULL School values within the specified year range while maintaining proper case sensitivity for the FundingType filter."
        ],
        "rules": [
            "Directly funded schools refers to FundingType = 'Directly Funded'"
        ]
    },
    "334": {
        "sql": [
            "SELECT a.element \nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.atom_id = 'TR004_7' AND m.label != 'carcinogenic';"
        ],
        "question": "What is the element with the atom ID of TR004_7 in molecule that is not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR004_7' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "1318": {
        "sql": [
            "SELECT e.event_id, e.event_name, COUNT(a.link_to_member) AS attendance_count\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nGROUP BY e.event_id, e.event_name\nORDER BY attendance_count DESC\nLIMIT 1;",
            "SELECT T1.event_name\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_name\nORDER BY COUNT(T2.link_to_event) DESC\nLIMIT 1;"
        ],
        "question": "What is the event that has the highest attendance of the students from the Student_Club?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_name ORDER BY COUNT(T2.link_to_event) DESC LIMIT 1",
        "amends": [
            "Do select only `event_name` instead of including `event_id` and `attendance_count`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `e` and `a`. Do join on `T1.event_id = T2.link_to_event` instead of `e.event_id = a.link_to_event`. Do group by only `event_name` instead of both `event_id` and `event_name`. Do order by `COUNT(T2.link_to_event)` instead of the alias `attendance_count`. The amended query now correctly returns only the event name with the highest attendance count, matching the intended behavior."
        ],
        "rules": [
            "event with highest attendance refers to MAX(COUNT(link_to_event))"
        ]
    },
    "913": {
        "sql": [
            "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1;"
        ],
        "question": "In which country can I find the circuit with the highest altitude?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1",
        "amends": [],
        "rules": [
            "highest altitude refers to max(alt)"
        ]
    },
    "793": {
        "sql": [
            "SELECT COUNT(*) FROM superhero WHERE race_id = 21 AND gender_id = 1;"
        ],
        "question": "Among the superheroes with the race of god/eternal, how many of them are male",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T1.race_id = 21 AND T1.gender_id = 1",
        "amends": [],
        "rules": [
            "race \"god/eternal\" refers to race_id = 21; male refers to gender.id = 1"
        ]
    },
    "1259": {
        "sql": [
            "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Birthday >= '1985-01-01'\nAND l.RA IN('-', '+-');"
        ],
        "question": "Please list the diseases of the patients born after 1985-1-1 and have a normal Rhuematoid Factor.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > '1985-01-01'",
        "amends": [],
        "rules": [
            "diseases refers to Diagnosis; born after 1985/1/1 refers to YEAR(Birthday) > = 1985; normal Rhuematoid Factor refers to RA IN('-', '+-');"
        ]
    },
    "422": {
        "sql": [
            "SELECT language FROM foreign_data WHERE multiverseid = 149934;"
        ],
        "question": "What is the language of the card with the multiverse number 149934?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT language FROM foreign_data WHERE multiverseid = 149934",
        "amends": [],
        "rules": [
            "multiverse number 149934 refers to multiverseid = 149934;"
        ]
    },
    "112": {
        "sql": [
            "SELECT d.A2 AS district_name\nFROM client c\nJOIN disp dp ON c.client_id = dp.client_id\nJOIN account a ON dp.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE c.gender = 'F' AND c.birth_date = '1976-01-29';"
        ],
        "question": "For the female client who was born in 1976/1/29, which district did she opened her account?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.A2 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.birth_date = '1976-01-29' AND T2.gender = 'F'",
        "amends": [],
        "rules": [
            "Female refers to gender = 'F'; A2 refers to district names"
        ]
    },
    "481": {
        "sql": [
            "SELECT DISTINCT fd.language\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.name = 'Ancestor''s Chosen' AND fd.flavorText IS NOT NULL;"
        ],
        "question": "Please list all the foreign languages in which the card \"Ancestor's Chosen\" has a flavor text.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.flavorText IS NOT NULL",
        "amends": [],
        "rules": [
            "\"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'; has a flavor text refers to flavorText is not null"
        ]
    },
    "1531": {
        "sql": [
            "WITH customer_spending AS (\n    SELECT \n        CustomerID,\n        SUM(Price * Amount) AS total_spending\n    FROM \n        transactions_1k\n    GROUP BY \n        CustomerID\n    ORDER BY \n        total_spending DESC\n    LIMIT 1\n),\naverage_price AS (\n    SELECT \n        t.CustomerID,\n        SUM(t.Price) / SUM(t.Amount) AS avg_price_per_item\n    FROM \n        transactions_1k t\n    JOIN \n        customer_spending cs ON t.CustomerID = cs.CustomerID\n    GROUP BY \n        t.CustomerID\n)\nSELECT \n    c.CustomerID,\n    cs.total_spending,\n    ap.avg_price_per_item,\n    c.Currency\nFROM \n    customer_spending cs\nJOIN \n    average_price ap ON cs.CustomerID = ap.CustomerID\nJOIN \n    customers c ON cs.CustomerID = c.CustomerID;",
            "SELECT \n    T2.CustomerID,\n    T1.Currency,\n    SUM(T2.Price / T2.Amount) AS avg_price_per_item\nFROM \n    transactions_1k T2\nJOIN \n    customers T1 ON T2.CustomerID = T1.CustomerID\nWHERE \n    T2.CustomerID = (\n        SELECT CustomerID \n        FROM yearmonth \n        GROUP BY CustomerID \n        ORDER BY SUM(Consumption) DESC \n        LIMIT 1\n    )\nGROUP BY \n    T2.CustomerID, T1.Currency;",
            "SELECT \n    T2.CustomerID,\n    SUM(T2.Price / T2.Amount) AS avg_price_per_item,\n    T1.Currency\nFROM \n    transactions_1k T2\nINNER JOIN \n    customers T1 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T2.CustomerID = (\n        SELECT CustomerID \n        FROM yearmonth \n        ORDER BY Consumption DESC \n        LIMIT 1\n    )\nGROUP BY \n    T2.CustomerID, T1.Currency;"
        ],
        "question": "Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.CustomerID, SUM(T2.Price / T2.Amount), T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.CustomerID = ( SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1 ) GROUP BY T2.CustomerID, T1.Currency",
        "amends": [
            "Do use `SUM(T2.Price / T2.Amount)` instead of calculating `SUM(t.Price) / SUM(t.Amount)` for average price per item. Do join `customers` directly with `transactions_1k` instead of using multiple CTEs. Do filter with `WHERE T2.CustomerID = (subquery)` instead of joining with a customer spending CTE. Do reference `yearmonth` table's `Consumption` column instead of calculating total spending from transactions. Do group by both `T2.CustomerID` and `T1.Currency` instead of just CustomerID. Do remove the ORDER BY and LIMIT from the CTE and place it in a subquery instead. Do select only the necessary columns instead of including total_spending. The amended query now correctly identifies the top customer by consumption from yearmonth and calculates their average price per item with proper currency grouping.",
            "Do use `INNER JOIN` instead of `JOIN` for explicit join clarity. Do correct the join condition to `T1.CustomerID = T2.CustomerID` instead of `T2.CustomerID = T1.CustomerID` to maintain consistent table reference order. Do simplify the subquery by removing the unnecessary `GROUP BY` and `SUM` aggregation, instead using direct `ORDER BY Consumption DESC` to find the top customer. Do adjust the column order in the SELECT list to place the aggregate function `SUM(T2.Price / T2.Amount)` before `T1.Currency` instead of after it with an alias. The amended query now correctly identifies the customer with highest consumption and calculates average price per item, matching the intended behavior."
        ],
        "rules": [
            "average price per single item = Total(price) / Total(amount)"
        ]
    },
    "1372": {
        "sql": [
            "SELECT i.date_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.first_name = 'Casey' AND m.last_name = 'Mason';"
        ],
        "question": "When did the member, Casey Mason, received the income?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "amends": [],
        "rules": [
            "when the income was received refers to date_received"
        ]
    },
    "698": {
        "sql": [
            "WITH target_post AS (\n    SELECT Id FROM posts WHERE Title = 'Clustering 1D data'\n)\nSELECT \n    (SELECT COUNT(*) FROM comments WHERE PostId = (SELECT Id FROM target_post)) AS comment_count,\n    (SELECT COUNT(*) FROM posts WHERE ParentId = (SELECT Id FROM target_post)) AS answer_count;"
        ],
        "question": "How many comments and answers were left by the users on the post with the title 'Clustering 1D data'?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CommentCount, AnswerCount FROM posts WHERE Title = 'Clustering 1D data'",
        "amends": [],
        "rules": []
    },
    "96": {
        "sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS customer_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'OWNER';"
        ],
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK TYDNE'",
        "amends": [],
        "rules": [
            "'POPLATEK TYDNE' stands for weekly issuance"
        ]
    },
    "476": {
        "sql": [
            "WITH ColdsnapCards AS (\n    SELECT c.name, c.convertedManaCost\n    FROM cards c\n    JOIN sets s ON c.setCode = s.code\n    WHERE s.name = 'Coldsnap'\n),\nMaxManaCost AS (\n    SELECT MAX(convertedManaCost) AS maxCost\n    FROM ColdsnapCards\n)\nSELECT name\nFROM ColdsnapCards\nWHERE convertedManaCost = (SELECT maxCost FROM MaxManaCost);",
            "SELECT c.name \nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.code = 'Coldsnap'\nORDER BY c.convertedManaCost DESC\nLIMIT 1;",
            "SELECT T1.name \nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Coldsnap'\nORDER BY T1.convertedManaCost DESC\nLIMIT 1"
        ],
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "amends": [
            "Do use a simple `SELECT` with `ORDER BY` and `LIMIT` instead of a complex CTE structure with subqueries. Do join `cards` and `sets` tables directly in the main query instead of creating a separate CTE for filtering. Do add `ORDER BY T1.convertedManaCost DESC` instead of using a subquery to find the maximum value. Do include `LIMIT 1` to get the single highest cost card instead of potentially returning multiple cards with equal maximum costs. Do remove the CTE and subquery structure entirely instead of maintaining the nested approach. The amended query now correctly returns the single card with the highest converted mana cost from the Coldsnap set, matching the RIGHT_SQL's behavior.",
            "Do reference `T1.name` instead of `c.name` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `c` and `s`. Do join on `T2.code = T1.setCode` instead of `c.setCode = s.code`. Do filter on `T2.name = 'Coldsnap'` instead of `s.code = 'Coldsnap'` to match by set name rather than set code. The amended query now correctly retrieves cards from the Coldsnap set by name rather than code, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'"
        ]
    },
    "236": {
        "sql": [
            "SELECT b.bond_type, c.atom_id, c.atom_id2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.bond_id = 'TR001_6_9';"
        ],
        "question": "What are the bond type and the atoms of the bond ID of TR001_6_9?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_id = 'TR001_6_9'",
        "amends": [],
        "rules": [
            "atoms refer to atom_id or atom_id2"
        ]
    },
    "1192": {
        "sql": [
            "SELECT DISTINCT P.ID, P.SEX, P.Birthday, P.Description, P.`First Date`, P.Admission, P.Diagnosis\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Admission = '-'\nAND L.Date LIKE '1991-10%'\nAND L.`T-BIL` < 2.0;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '-'\nAND T2.Date LIKE '1991-10-%'\nAND T2.\"T-BIL\" < 2.0"
        ],
        "question": "List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.`T-BIL` < 2.0 AND T2.Date LIKE '1991-10-%'",
        "amends": [
            "Do select only `T1.ID` instead of multiple columns including `P.SEX`, `P.Birthday`, `P.Description`, `P.First Date`, `P.Admission`, and `P.Diagnosis`. Do use table aliases `T1` and `T2` instead of `P` and `L`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T2.T-BIL` and `T2.Date` in the WHERE clause instead of `L.T-BIL` and `L.Date`. Do use exact pattern matching `1991-10-%` instead of `1991-10%` for the date filter. Do remove the redundant `P.Admission = '-'` condition since it's already implied by the join logic. The amended query now correctly filters patients with admission status '-' who have laboratory results with T-BIL < 2.0 in October 1991, matching the intended behavior."
        ],
        "rules": [
            "followed up at the outpatient clinic refers to Admission = '-'; laboratory test in April 1981 refers to Date like '1991-10%'; blood bilirubin level within the normal range refers to T-BIL < 2.0; "
        ]
    },
    "1389": {
        "sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.cost = (SELECT MIN(cost) FROM expense);",
            "SELECT T1.event_name\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nORDER BY T3.cost\nLIMIT 1;"
        ],
        "question": "Which event has the lowest cost?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` for both joins instead of just `JOIN` and add table aliases `T1`, `T2`, `T3` instead of `e`, `b`, `ex`. Do remove the WHERE clause with subquery `(SELECT MIN(cost) FROM expense)` instead of keeping it. Do add `ORDER BY T3.cost` and `LIMIT 1` instead of omitting them to find the single event with minimum cost. Do change the SELECT list to reference `T1.event_name` with alias instead of `e.event_name`. The amended query now correctly returns the event with the minimum expense cost by ordering and limiting instead of using a subquery that could return multiple matches."
        ],
        "rules": [
            "event refers to event_name; lowest cost means MIN(cost)"
        ]
    },
    "339": {
        "sql": [
            "SELECT a.atom_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+' AND a.element = 'o';"
        ],
        "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; oxygen refers to element = 'o'"
        ]
    },
    "500": {
        "sql": [
            "SELECT st.translation AS japanese_set_name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode\nWHERE c.name = 'Fellwar Stone' AND st.language = 'Japanese';",
            "SELECT T2.translation\nFROM cards T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.setCode\nWHERE T1.name = 'Fellwar Stone'\nAND T2.language = 'Japanese'\nAND T2.translation IS NOT NULL"
        ],
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "amends": [
            "Do reference `set_translations` directly as `T2` instead of joining through an intermediate `sets` table. Do use `INNER JOIN` between `cards` and `set_translations` on `T2.setCode = T1.setCode` instead of chaining through `sets` with `c.setCode = s.code` and `s.code = st.setCode`. Do add `AND T2.translation IS NOT NULL` to filter out null translations instead of omitting this null check. Do remove the alias `japanese_set_name` for the translation column instead of keeping it. The amended query now correctly retrieves Japanese set translations for the specified card while ensuring non-null results, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Japanese name refers to language = 'Japanese'; card \"Fellwar Stone\" refers to name = 'Fellwar Stone'"
        ]
    },
    "655": {
        "sql": [
            "SELECT p.Title, pl.LinkTypeId\nFROM postLinks pl\nJOIN posts p ON pl.RelatedPostId = p.Id\nWHERE pl.PostId = (SELECT Id FROM posts WHERE Title = 'What are principal component scores?');"
        ],
        "question": "Write down the related posts titles and link type IDs of the post \"What are principal component scores?\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Title, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId INNER JOIN posts AS T3 ON T2.RelatedPostId = T3.Id WHERE T1.Title = 'What are principal component scores?'",
        "amends": [],
        "rules": [
            "Title = 'What are principal component scores?';"
        ]
    },
    "1438": {
        "sql": [
            "SELECT m.college\nFROM member AS mem\nJOIN major AS m ON mem.link_to_major = m.major_id\nWHERE mem.first_name = 'Katy' AND mem.link_to_major = 'rec1N0upiVLy5esTO';"
        ],
        "question": "Please indicate the college of the person whose first name is Katy with the link to the major \"rec1N0upiVLy5esTO\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.link_to_major = 'rec1N0upiVLy5esTO' AND T1.first_name = 'Katy'",
        "amends": [],
        "rules": []
    },
    "304": {
        "sql": [
            "SELECT m.molecule_id, m.label, a.element\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+'\nGROUP BY m.molecule_id, a.element;",
            "SELECT DISTINCT T2.molecule_id, T1.element\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = 'carcinogenic';",
            "SELECT DISTINCT T2.molecule_id, T1.element\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'"
        ],
        "question": "List all carcinogenic molecules and their elements.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [
            "Do use `DISTINCT` instead of `GROUP BY` with incomplete column selection. Do select `T1.element` instead of including `m.label` which is already filtered. Do use table aliases `T1` and `T2` consistently instead of mixed naming. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T2.molecule_id` in SELECT instead of `m.molecule_id` for consistency with joined tables. Do remove the unnecessary `GROUP BY` clause entirely instead of keeping it with columns that don't require aggregation. The amended query now correctly returns distinct molecule-element pairs for labeled molecules without redundant grouping.",
            "Do use `T2.label = '+'` instead of `T2.label = 'carcinogenic'` in the WHERE filter. End with confirmation that the amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "label = '+' mean molecules are carcinogenic; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ]
    },
    "825": {
        "sql": [
            "SELECT g.gender\nFROM gender g\nJOIN superhero s ON g.id = s.gender_id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Phoenix Force';"
        ],
        "question": "Identify the gender of the superhero who has the ability of Phoenix Force.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Phoenix Force'",
        "amends": [],
        "rules": [
            "ability of Phoenix Force refers to power_name = 'Phoenix Force';"
        ]
    },
    "1421": {
        "sql": [
            "SELECT (COUNT(CASE WHEN m.major_name = 'Business' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_business_majors\nFROM member\nLEFT JOIN major m ON member.link_to_major = m.major_id;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id) AS percentage\nFROM \n    member T1\nINNER JOIN \n    major T2 ON T2.major_id = T1.link_to_major\nWHERE \n    T1.position = 'Member';"
        ],
        "question": "Calculate the percentage of members who are major Business in the list?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member'",
        "amends": [
            "Do use `INNER JOIN` on `T2.major_id = T1.link_to_major` instead of `LEFT JOIN` on `member.link_to_major = m.major_id` to exclude members without majors. Do add `WHERE T1.position = 'Member'` instead of omitting it to filter only members with that position. Do change the calculation to `CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id)` instead of `(COUNT(CASE WHEN m.major_name = 'Business' THEN 1 END) * 100.0 / COUNT(*))` to properly handle the percentage calculation with explicit casting and member-specific counting. Do use table aliases `T1` and `T2` instead of no aliases for clarity. The amended query now correctly calculates the percentage of Business majors among members with a valid position, matching the intended behavior."
        ],
        "rules": [
            "DIVIDE(SUM(position = 'Member' and major_name = 'Business'), COUNT(member_id)) * 100"
        ]
    },
    "402": {
        "sql": [
            "WITH total_cards AS (\n    SELECT COUNT(*) AS total FROM cards\n),\nstory_spotlight_cards AS (\n    SELECT COUNT(*) AS spotlight_count, GROUP_CONCAT(id) AS spotlight_ids \n    FROM cards \n    WHERE isStorySpotlight = 1 AND isTextless = 0\n)\nSELECT \n    (spotlight_count * 100.0 / total) AS percentage,\n    spotlight_ids AS story_spotlight_card_ids\nFROM total_cards, story_spotlight_cards;",
            "SELECT \n    CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) AS percentage\nFROM cards\nWHERE isStorySpotlight = 1;"
        ],
        "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
        "amends": [
            "Do use a single query with conditional aggregation instead of multiple CTEs and cross join. Do calculate the percentage directly with `CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)` instead of computing separate counts and dividing them. Do apply the `isStorySpotlight = 1` filter in the `WHERE` clause instead of handling it in a separate CTE. Do remove the `GROUP_CONCAT` operation for spotlight IDs instead of including them in the result. Do eliminate the cross join between CTEs instead of using `FROM total_cards, story_spotlight_cards`. The amended query now correctly calculates the percentage of non-textless cards among story spotlight cards and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 0; Percentage = DIVIDE(SUM(count(id) where isStorylight = 1 AND isTextless = 0 ), SUM(count(id))) * 100"
        ]
    },
    "1309": {
        "sql": [
            "SELECT P.ID, L.PLT\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'MCTD'\nAND L.PLT > 100 AND L.PLT < 400;",
            "SELECT T2.PLT \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'MCTD' \nAND T2.PLT BETWEEN 100 AND 400"
        ],
        "question": "Please list a patient's platelet level if it is within the normal range and if he or she is diagnosed with MCTD.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.PLT FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'MCTD' AND T2.PLT BETWEEN 100 AND 400",
        "amends": [
            "Do select only `T2.PLT` instead of selecting both `P.ID` and `L.PLT`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `P` and `L`. Do use `BETWEEN 100 AND 400` for the PLT range condition instead of separate `> 100 AND < 400` conditions. Do remove the selection of patient ID `P.ID` instead of including it in the output. The amended query now correctly returns only platelet values for MCTD patients within the specified range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "PLT > 100 and PLT < 400 means platelet level is within the normal range; PLT < 100 and PLT > 400 means platelet level is not within the normal range; diagnosed with MCTD refers to Diagnosis = 'MCTD';"
        ]
    },
    "340": {
        "sql": [
            "SELECT * FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
            "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "Which are the cards that have incredibly powerful foils.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
        "amends": [
            "Do select only the `id` column instead of selecting all columns with `*`. Do keep the same `WHERE` clause with both `cardKingdomFoilId IS NOT NULL` and `cardKingdomId IS NOT NULL` conditions instead of changing them. The amended query now correctly returns only the id values from matching rows instead of all columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "incredibly poweful foils refers to cardKingdomFoilId is not null AND cardKingdomId is not null"
        ]
    },
    "597": {
        "sql": [
            "SELECT COUNT(DISTINCT u.Id) \nFROM users u \nJOIN badges b ON u.Id = b.UserId \nWHERE u.Location = 'India' AND b.Name = 'Teacher';"
        ],
        "question": "How many users from India have the teacher badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Location = 'India' AND T1.Name = 'Teacher'",
        "amends": [],
        "rules": [
            "\"India\" is the Location; \"Teacher\" is the Name of badge"
        ]
    },
    "705": {
        "sql": [
            "SELECT u.Reputation, u.UpVotes\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text = 'fine, you win :)';"
        ],
        "question": "Give the user's reputation and up vote number of the user that commented \"fine, you win :)\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Reputation, T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'fine, you win :)'",
        "amends": [],
        "rules": [
            "Text = 'fine, you win :)';"
        ]
    },
    "247": {
        "sql": [
            "SELECT DISTINCT a.element FROM atom a WHERE a.atom_id NOT IN (SELECT atom_id FROM connected) AND a.atom_id NOT IN (SELECT atom_id2 FROM connected);",
            "SELECT DISTINCT T.element\nFROM atom AS T\nWHERE T.element NOT IN (\n    SELECT DISTINCT T1.element\n    FROM atom AS T1\n    INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\n)"
        ],
        "question": "List all the elements of atoms that can not bond with any other atoms.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.element NOT IN ( SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id )",
        "amends": [
            "Do reference the table as `T` instead of `a` in the SELECT clause. Do filter by `T.element NOT IN` instead of `a.atom_id NOT IN` to check for elements rather than atom IDs. Do use a single subquery with `SELECT DISTINCT T1.element` instead of two separate subqueries checking different columns. Do perform an `INNER JOIN` between `atom AS T1` and `connected AS T2` on `T1.atom_id = T2.atom_id` instead of using NOT IN with separate subqueries against the connected table. Do remove the second NOT IN condition checking `atom_id2` instead of keeping it, as the join approach captures all relevant connections. The amended query now correctly identifies elements that have no connections by checking against joined data rather than individual column comparisons, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            " atoms cannot bond with other atoms means atom_id NOT in connected table;"
        ]
    },
    "1182": {
        "sql": [
            "SELECT COUNT(*) AS TotalLabTestsIn1995\nFROM Laboratory\nWHERE ID = (SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS')\nAND strftime('%Y', Date) = '1995';"
        ],
        "question": "For the patient who first came to the hospital on 1991/6/13 who was diagnosed with SJS, what is the total number of his/her Laboratory tests in 1995?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM Laboratory WHERE ID = ( SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS' ) AND STRFTIME('%Y', Date) = '1995'",
        "amends": [],
        "rules": [
            "1991/6/13 refers to `First Date` = '1991-06-13'; 'SJS' refers to Diagnosis; total number of his/her Laboratory tests refers to COUNT(ID); 1995 refers to Date"
        ]
    },
    "1360": {
        "sql": [
            "SELECT \n    (b1.amount * 100.0 / SUM(b2.amount)) AS percentage\nFROM \n    event e\nJOIN \n    budget b1 ON e.event_id = b1.link_to_event\nJOIN \n    budget b2 ON e.event_id = b2.link_to_event\nWHERE \n    e.event_name = 'November Speaker' AND b1.category = 'Parking'\nGROUP BY \n    b1.amount;"
        ],
        "question": "What percentage was the budget for Parking to the total budget for the \"November Speaker\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Speaker'",
        "amends": [],
        "rules": [
            "DIVDE(SUM( amount where category = 'Parking' and event_name = 'November Speaker'), COUNT(event_name = 'November Speaker)) * 100"
        ]
    },
    "1095": {
        "sql": [
            "SELECT AVG(buildUpPlaySpeed) AS average_build_up_play_speed\nFROM Team_Attributes\nJOIN Team ON Team_Attributes.team_api_id = Team.team_api_id\nWHERE Team.team_long_name = 'Heart of Midlothian';"
        ],
        "question": "How much is the average build up play speed of the Heart of Midlothian team?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Heart of Midlothian'",
        "amends": [],
        "rules": [
            "Heart of Midlothian refers to team_long_name = 'Heart of Midlothian'; average build up play speed refers to\u00a0 AVG(buildUpPlaySpeed)"
        ]
    },
    "1261": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.RF < 20 AND E.Thrombosis = 0;"
        ],
        "question": "How many patients with a normal RF don't have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND T1.Thrombosis = 0",
        "amends": [],
        "rules": [
            "normal RF refers to RF < 20; don't have thrombosis refers to Thrombosis = '0';"
        ]
    },
    "593": {
        "sql": [
            "SELECT COUNT(DISTINCT u.Id) AS UserCount\nFROM users u\nJOIN badges b1 ON u.Id = b1.UserId AND b1.Name = 'Teacher'\nJOIN badges b2 ON u.Id = b2.UserId AND b2.Name = 'Supporter'\nWHERE u.Location = 'New York';",
            "SELECT COUNT(DISTINCT users.Id) \nFROM badges \nINNER JOIN users ON badges.UserId = users.Id \nWHERE users.Location = 'New York' \nAND badges.Name IN ('Supporter', 'Teacher')",
            "SELECT COUNT(DISTINCT T2.Id) \nFROM badges T1 \nINNER JOIN users T2 ON T1.UserId = T2.Id \nWHERE T1.Name IN ('Supporter', 'Teacher') \nAND T2.Location = 'New York'",
            "SELECT COUNT(DISTINCT T1.Id) \nFROM badges T1 \nINNER JOIN users T2 ON T1.UserId = T2.Id \nWHERE T1.Name IN ('Supporter', 'Teacher') \nAND T2.Location = 'New York'"
        ],
        "question": "How many users from New York have a teacher and supporter badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name IN ('Supporter', 'Teacher') AND T2.Location = 'New York'",
        "amends": [
            "Do join `badges` as the primary table instead of starting from `users`, and use `INNER JOIN` with `users` on `badges.UserId = users.Id` instead of multiple joins from `users` to `badges`. Do filter badge names with `IN ('Supporter', 'Teacher')` instead of separate joins for each badge type. Do move the location filter to the `WHERE` clause on the joined `users` table instead of applying it to the original `users` table. Do count distinct user IDs from the `users` table instead of from the original `users` table, and remove the alias `UserCount` instead of keeping it. The amended query now correctly counts users who have both badge types in New York by using a single join with an IN condition rather than multiple joins that would require both badges to exist separately.",
            "Do reference `T1.Id` instead of `users.Id` in the SELECT clause, and use table aliases `T1` for `badges` and `T2` for `users` instead of the original table names. Do place the filter on `T1.Name IN ('Supporter', 'Teacher')` before the `T2.Location = 'New York'` condition in the WHERE clause instead of the reverse order, and ensure the join condition uses `T1.UserId = T2.Id` with proper alias references instead of `badges.UserId = users.Id`. The amended query now correctly counts distinct user IDs from the badges table that have specific badge names while belonging to users located in New York, matching the RIGHT_SQL's behavior.",
            "Do count `T1.Id` instead of `T2.Id` in the SELECT clause, as the badges table contains the relevant IDs for counting distinct badge recipients rather than counting user IDs from the users table. The amended query now correctly counts distinct badge IDs from the badges table while maintaining the same join condition and filtering logic, ensuring it matches the RIGHT_SQL's behavior of accurately counting badges rather than users."
        ],
        "rules": [
            "\"Supporter\" and \"Teachers\" are both Name of badge; 'New York' is the Location; user refers to UserId"
        ]
    },
    "1020": {
        "sql": [
            "SELECT p.player_api_id, p.player_name, pa.overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);",
            "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;"
        ],
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
        "amends": [
            "Do select only `player_api_id` instead of including `p.player_api_id`, `p.player_name`, and `pa.overall_rating`. Do query from `Player_Attributes` alone instead of joining `Player` with `Player_Attributes` on `p.player_api_id = pa.player_api_id`. Do remove the subquery that finds the maximum rating and instead use `ORDER BY overall_rating DESC LIMIT 1` to get the single highest-rated player. Do omit the `WHERE` clause entirely instead of filtering for maximum rating through a subquery comparison. The amended query correctly identifies the player with the highest overall rating by sorting and limiting rather than attempting to match all players with the maximum rating value, which could return multiple players if there are ties."
        ],
        "rules": [
            "highest overall rating refers to MAX(overall_rating);"
        ]
    },
    "1156": {
        "sql": [
            "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE E.RVVT = '+';"
        ],
        "question": "State the ID and age of patient with positive degree of coagulation.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.RVVT = '+'",
        "amends": [],
        "rules": [
            "age refers to SUBTRACT(year(current_timestamp), year(Birthday)); positive degree of coagulation refers to RVVT = '+';"
        ]
    },
    "272": {
        "sql": [
            "SELECT DISTINCT m.molecule_id\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '-'\nAND b.bond_type = '#'\nAND a.element = 'c'\nLIMIT 2;"
        ],
        "question": "List down two molecule id of triple bond non carcinogenic molecules with element carbon.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element = 'c' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "carbon refers to element = 'c'; triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "185": {
        "sql": [
            "WITH prague_accounts AS (\n    SELECT account_id\n    FROM account\n    WHERE district_id IN (SELECT district_id FROM district WHERE A3 LIKE '%Prague%')\n),\nprague_clients AS (\n    SELECT c.client_id, c.gender\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN prague_accounts pa ON d.account_id = pa.account_id\n)\nSELECT \n    (COUNT(CASE WHEN gender = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS female_percentage\nFROM prague_clients;",
            "SELECT \n    CAST(SUM(CASE WHEN c.gender = 'F' THEN 1 ELSE 0 END) AS REAL) / COUNT(c.client_id) * 100 AS female_percentage\nFROM \n    client c\nINNER JOIN \n    district d ON c.district_id = d.district_id\nWHERE \n    d.A3 = 'Prague';"
        ],
        "question": "What proportion of customers who have accounts at the Prague branch are female?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id) * 100 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'Prague'",
        "amends": [
            "Do use a direct `INNER JOIN` between `district` and `client` tables on `district_id` instead of the complex CTE approach with multiple joins through `account` and `disp` tables. Do filter with `T1.A3 = 'Prague'` instead of using `LIKE '%Prague%'` for exact matching. Do calculate the percentage using `CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id) * 100` instead of `(COUNT(CASE WHEN gender = 'F' THEN 1 END) * 100.0 / COUNT(*))` for more efficient boolean aggregation. Do remove the unnecessary gender column selection and CTE structure instead of maintaining the complex nested query approach. The amended query now correctly calculates the percentage of female clients in Prague districts with direct table relationships and proper aggregation."
        ],
        "rules": [
            "Female refers to gender = 'F'; Percentage of female clients in Prague branch = count[female clients with accounts in Prague branch / count(clients with accounts in Prague branch)] * 100%; A3 may contain information about Prague"
        ]
    },
    "761": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Male'\nAND s.weight_kg > (\n    SELECT AVG(weight_kg) * 0.79\n    FROM superhero\n);"
        ],
        "question": "Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79",
        "amends": [],
        "rules": [
            "super hero names refers to superhero_name;male superheros refers to gender = 'Male';Calculation = weight_kg > MULTIPLY(AVG(weight_kg), 0.79)"
        ]
    },
    "1196": {
        "sql": [
            "SELECT Symptoms, COUNT(*) AS Frequency\nFROM Examination\nWHERE Diagnosis = 'SLE'\nGROUP BY Symptoms\nORDER BY Frequency DESC\nLIMIT 1;",
            "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1;"
        ],
        "question": "What is the most common sign of patients with SLE disease?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1",
        "amends": [
            "Do select only `Symptoms` instead of including `COUNT(*) AS Frequency` in the SELECT list. Do order by `COUNT(Symptoms) DESC` instead of ordering by the alias `Frequency DESC`. Do remove the explicit column alias `AS Frequency` instead of keeping it since it's no longer needed in the ORDER BY clause. The amended query now correctly returns the most frequent symptom for SLE diagnoses by counting occurrences per symptom and ordering by that count directly rather than through an alias that isn't available in the ORDER BY context."
        ],
        "rules": [
            "the most common sign refers to MAX(symptoms); 'SLE' refers to diagnosis"
        ]
    },
    "1433": {
        "sql": [
            "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box';",
            "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL"
        ],
        "question": "Which countries have zip codes with post office boxes?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL",
        "amends": [
            "Do add `AND county IS NOT NULL` to the WHERE clause instead of omitting this null check, ensuring only non-null county values are returned while preserving the DISTINCT selection from the zip_code table where type equals 'PO Box'. The amended query now matches RIGHT_SQL's behavior by excluding null county entries from the result set."
        ],
        "rules": [
            "zip codes that have post office boxes refers to type = 'PO Box'"
        ]
    },
    "347": {
        "sql": [
            "SELECT c.id, r.text AS ruling_text, c.hasContentWarning\nFROM cards c\nLEFT JOIN rulings r ON c.uuid = r.uuid\nWHERE c.artist = 'Stephen Daniele';\n",
            "SELECT T1.name, T1.artist, T2.text, \n       CASE \n           WHEN T1.power IS NULL OR T1.power = '' THEN 'Missing power' \n           WHEN T1.toughness IS NULL OR T1.toughness = '' THEN 'Missing toughness' \n           WHEN T1.manaCost IS NULL OR T1.manaCost = '' THEN 'Missing mana cost' \n           WHEN T1.convertedManaCost IS NULL THEN 'Missing converted mana cost' \n           ELSE 'No missing or degraded properties' \n       END AS property_status\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniel';",
            "SELECT T1.id, T1.hasContentWarning, T2.text\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele';",
            "SELECT T1.id, T2.text, T1.hasContentWarning\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele';"
        ],
        "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
        "amends": [
            "Do use `INNER JOIN` instead of `LEFT JOIN` to ensure only matching records are returned. Do reference the joined table as `T2` instead of `r` for the text column. Do use table aliases `T1` and `T2` consistently throughout the query instead of mixing aliased and non-aliased references. Do remove the column alias `ruling_text` for the text column instead of keeping it. The amended query now correctly returns only cards that have corresponding rulings, matching the RIGHT_SQL's behavior.",
            "Do select `T1.id` and `T1.hasContentWarning` instead of `T1.name`, `T1.artist`, and the CASE expression for property_status. Do remove the entire CASE expression checking for NULL or empty power, toughness, manaCost, and convertedManaCost instead of including it. Do change the artist filter to `Stephen Daniele` instead of `Stephen Daniel` to match the correct spelling. Do keep the `INNER JOIN` on `T1.uuid = T2.uuid` unchanged. The amended query now correctly selects only the required columns and uses the proper artist name filter, matching the RIGHT_SQL's behavior.",
            "Do maintain the same column selection order `T1.id, T2.text, T1.hasContentWarning` instead of reordering to `T1.id, T1.hasContentWarning, T2.text`. Do add the explicit table alias `AS T1` instead of omitting it. The join condition, table sources, and WHERE filter remain identical with no changes needed to the INNER JOIN on `T1.uuid = T2.uuid` or the artist filter. The amended query now correctly matches the RIGHT_SQL's behavior with identical column output and logic."
        ],
        "rules": [
            "cards have missing or degraded properties and value refers to hasContentWarning = 1; 'Stephen Daniele' is artist; Find all cards refers to return card id"
        ]
    },
    "1525": {
        "sql": [
            "WITH total_customers AS (\n    SELECT COUNT(DISTINCT CustomerID) AS total\n    FROM transactions_1k\n    WHERE Date = '2012-08-25'\n),\neur_customers AS (\n    SELECT COUNT(DISTINCT t.CustomerID) AS eur_count\n    FROM transactions_1k t\n    JOIN customers c ON t.CustomerID = c.CustomerID\n    WHERE t.Date = '2012-08-25' AND c.Currency = 'EUR'\n)\nSELECT \n    CASE \n        WHEN total > 0 THEN (eur_count * 100.0 / total)\n        ELSE 0\n    END AS percentage\nFROM total_customers, eur_customers;",
            "SELECT \n    CAST(SUM(IIF(c.Currency = 'EUR', 1, 0)) AS FLOAT) * 100.0 / COUNT(t.CustomerID) AS Percentage\nFROM transactions_1k t\nINNER JOIN customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-25';"
        ],
        "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
        "amends": [
            "Do use a single query with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of separate CTEs with a cross join. Do calculate the percentage directly using `SUM(IIF(T2.Currency = 'EUR', 1, 0)) * 100 / COUNT(T1.CustomerID)` instead of separate counts and division. Do filter with `WHERE T1.Date = '2012-08-25'` instead of duplicating the date condition in both CTEs. Do remove the `DISTINCT` from customer counting and instead count all joined rows to properly calculate the percentage. Do add explicit `CAST` to `FLOAT` for accurate division instead of relying on implicit conversion. Do eliminate the `CASE` statement for zero division protection since the join ensures at least one row when filtering by date. The amended query now correctly calculates the percentage of EUR customers on the specified date by joining and counting in a single pass."
        ],
        "rules": [
            "'2012/8/25' can be represented by '2012-08-25'"
        ]
    },
    "1416": {
        "sql": [
            "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Business' AND member.t_shirt_size = 'Medium';"
        ],
        "question": "How many members of Business have the Medium size of tee shirt?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business' AND T2.t_shirt_size = 'Medium'",
        "amends": [],
        "rules": [
            "members of Economics refers to major_name = 'Business'; t_shirt_size = 'Medium'"
        ]
    },
    "201": {
        "sql": [
            "SELECT (SUM(CASE WHEN a.element = 'c' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS percentage_carbon\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = '=';",
            "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) AS percentage\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.bond_type = '='"
        ],
        "question": "What is the percentage of carbon in double-bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
        "amends": [
            "Do use `CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id)` instead of `SUM(CASE WHEN a.element = 'c' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)` for proper percentage calculation with distinct atom counting. Do join only `atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id` instead of joining both molecule and bond tables with unnecessary intermediate table. Do remove the redundant `molecule` table join instead of including it. Do use `WHERE T2.bond_type = '='` instead of the same filter but with unnecessary table joins. The amended query now correctly calculates the percentage of carbon atoms in molecules with double bonds by using distinct counts and proper casting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "carbon refers to element = 'c'; double-bond molecules refers to bond_type = '='; percentage = DIVIDE(SUM(element = 'c'), COUNT(atom_id))"
        ]
    },
    "688": {
        "sql": [
            "SELECT COUNT(*) \nFROM posts \nWHERE ViewCount > 35000 AND (CommentCount = 0 OR CommentCount IS NULL);"
        ],
        "question": "Identify the number of posts that have been viewed over 35000 times but have received no comments from other users.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM posts WHERE ViewCount > 35000 AND CommentCount = 0",
        "amends": [],
        "rules": [
            "have been viewed over 35000 times refers to ViewCount > 35000; received no comments refers to CommentCount = 0;"
        ]
    },
    "215": {
        "sql": [
            "SELECT COUNT(DISTINCT a.atom_id) AS total_atoms\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.element IN ('i', 's') AND b.bond_type = '-';",
            "SELECT \n    COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_atoms,\n    COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_atoms\nFROM \n    atom AS T1\nJOIN \n    connected AS T2 ON T1.atom_id = T2.atom_id\nJOIN \n    bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE \n    T3.bond_type = '-'"
        ],
        "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
        "amends": [
            "Do use `COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END)` and `COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END)` as separate columns instead of a single `COUNT(DISTINCT a.atom_id)` aggregate. Do join `connected AS T2` on `T1.atom_id = T2.atom_id` instead of omitting this table. Do join `bond AS T3` on `T2.bond_id = T3.bond_id` instead of joining directly on `a.molecule_id = b.molecule_id`. Do remove the filter `a.element IN ('i', 's')` from the WHERE clause instead of keeping it, as the element filtering is now handled in the CASE expressions. Do keep `T3.bond_type = '-'` in the WHERE clause instead of changing it. The amended query now correctly counts iodine and sulfur atoms separately through connected bonds rather than counting all atoms in molecules with single bonds."
        ],
        "rules": [
            "with iodine element refer to element = 'i'; with sulfur element refers to element = 's'; single type bond refers to bond_type = '-'; Should consider the distinct atoms when counting;"
        ]
    },
    "708": {
        "sql": [
            "SELECT u.CreationDate, u.Age\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text LIKE '%http://%';"
        ],
        "question": "List the creation date and age of the user that commented with webiste.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.CreationDate, T2.Age FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.text LIKE '%http://%'",
        "amends": [],
        "rules": [
            "commented with webiste refers to the value contains 'http://'"
        ]
    },
    "21": {
        "sql": [
            "SELECT COUNT(*) \nFROM frpm \nJOIN schools ON frpm.CDSCode = schools.CDSCode \nWHERE schools.County = 'Los Angeles' \nAND frpm.\"Free Meal Count (K-12)\" > 500 \nAND frpm.\"FRPM Count (K-12)\" < 700;"
        ],
        "question": "In Los Angeles how many schools have more than 500 free meals but less than 700 free or reduced price meals for K-12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(CDSCode) FROM frpm WHERE `County Name` = 'Los Angeles' AND `Free Meal Count (K-12)` > 500 AND `FRPM Count (K-12)`< 700",
        "amends": [],
        "rules": []
    },
    "840": {
        "sql": [
            "SELECT a.attribute_name, ha.attribute_value\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE s.superhero_name = 'Aquababy';",
            "SELECT T2.attribute_value\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Aquababy'"
        ],
        "question": "List the attribute value of the superhero named Aquababy.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Aquababy'",
        "amends": [
            "Do select only `T2.attribute_value` instead of including `a.attribute_name` from the SELECT list. Do remove the JOIN to the `attribute` table (aliased as `a`) instead of keeping it, as the attribute values are directly available in the hero_attribute table. Do use `INNER JOIN` with table aliases `T1` for superhero and `T2` for hero_attribute instead of the original JOIN syntax without aliases. Do remove the unnecessary join condition `ha.attribute_id = a.id` instead of including it, since the attribute table is no longer needed. The amended query now correctly retrieves only the attribute values for the specified superhero without requiring the additional attribute table join."
        ],
        "rules": []
    },
    "1164": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Examination E ON P.ID = E.ID \nWHERE E.Thrombosis = 1 \nAND strftime('%Y', E.`Examination Date`) = '1997' \nAND P.SEX = 'F';"
        ],
        "question": "How many of the patients with the most serious thrombosis cases examined in 1997 are women?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT  COUNT(*) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND STRFTIME('%Y', T2.`Examination Date`) = '1997' AND T2.Thrombosis = 1",
        "amends": [],
        "rules": [
            "the most serious thrombosis refers to Thrombosis = '1' (the most severe one); women refers to sex = 'F'"
        ]
    },
    "416": {
        "sql": [
            "SELECT (COUNT(CASE WHEN fd.language = 'French' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM cards c\nLEFT JOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.power IS NULL OR c.power = '*';",
            "SELECT \n    (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    cards T1\nINNER JOIN \n    foreign_data T2 ON T1.uuid = T2.uuid\nWHERE \n    T1.power IS NULL OR T1.power = '';",
            "SELECT (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) FROM cards T1 INNER JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T1.power = '*';",
            "SELECT (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) \nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.power IS NULL OR T1.power = '*';"
        ],
        "question": "What percentage of cards without power are in French?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power = '*'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END)` with explicit ELSE 0 instead of `COUNT(CASE WHEN fd.language = 'French' THEN 1 END)` to properly count only French records. Do cast the sum to `REAL` before division instead of using `* 100.0` to ensure floating-point arithmetic. Do use `INNER JOIN` instead of `LEFT JOIN` to exclude cards without foreign data. Do count `T1.id` instead of `COUNT(*)` to avoid counting null rows from the join. Do reference tables with aliases `T1` and `T2` instead of `c` and `fd` for clarity. The amended query now correctly calculates the percentage of French cards while excluding non-matching records and ensuring proper numeric handling.",
            "Do cast the SUM result as REAL instead of using implicit casting with 100.0. Do use the literal string '*' instead of empty string '' in the WHERE condition for T1.power comparison. Do remove the column alias percentage instead of keeping it. The amended query now correctly handles the power field comparison and ensures proper numeric casting for the percentage calculation.",
            "Do cast the SUM result as REAL instead of using implicit casting with 100.0. Do change the WHERE filter to `T1.power IS NULL OR T1.power = '*'` instead of only `T1.power = '*'` to include NULL values. Do remove the parentheses around the entire calculation instead of keeping them, as they are unnecessary for the mathematical operation order. The amended query now correctly handles NULL power values and ensures proper numeric casting for accurate percentage calculation."
        ],
        "rules": [
            "in French refers to language = 'French'; cards without power refers to power IS NULL OR power = '*'; percentage = DIVIDE(COUNT(language = 'French' and power is NULL or power = '*'), COUNT( power is NULL or power = '*'))*100"
        ]
    },
    "388": {
        "sql": [
            "SELECT c.name, st.language\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE c.setCode = '10E' AND c.convertedManaCost = 5;",
            "SELECT st.id, st.language \nFROM set_translations st \nWHERE st.setCode = '10E' \nAND st.id IN (\n    SELECT c.id \n    FROM cards c \n    WHERE c.convertedManaCost = 5\n)"
        ],
        "question": "What are the cards in set 10E with converted mana of 5 have translation and what are the languages?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id, language FROM set_translations WHERE id = ( SELECT id FROM cards WHERE convertedManaCost = 5 ) AND setCode = '10E'",
        "amends": [
            "Do select `id` and `language` from `set_translations` instead of `name` from `cards` and `language` from `set_translations`. Do use a subquery to get `id` from `cards` where `convertedManaCost = 5` instead of joining directly on `setCode`. Do filter `set_translations` with `setCode = '10E'` instead of applying this filter to both joined tables. Do remove the direct table join and instead correlate through the subquery predicate. The amended query now correctly retrieves translation data based on card criteria while maintaining the set code constraint."
        ],
        "rules": [
            "set 10E refers to setCode = '10E'; converted mana of 5 refers to convertedManaCost = 5;"
        ]
    },
    "789": {
        "sql": [
            "SELECT AVG(s.weight_kg) AS average_weight\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Alien';"
        ],
        "question": "Find the average weight of the heroes who are aliens.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "amends": [],
        "rules": [
            "average = AVG(weight_kg); aliens refers to race = 'Alien';"
        ]
    },
    "1513": {
        "sql": [
            "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-25'\nORDER BY t.Time ASC\nLIMIT 1;"
        ],
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "amends": [],
        "rules": [
            "'2012/8/25' can be represented by '2012-08-25'"
        ]
    },
    "736": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Intelligence'\nORDER BY ha.attribute_value ASC\nLIMIT 1;"
        ],
        "question": "Who is the dumbest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' ORDER BY T2.attribute_value LIMIT 1",
        "amends": [],
        "rules": [
            "the dumbest superhero refers to MIN(attribute_value) where attribute_name = 'Intelligence'"
        ]
    },
    "370": {
        "sql": [
            "SELECT COUNT(DISTINCT c.id) \nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.borderColor = 'borderless' AND fd.language = 'Russian';"
        ],
        "question": "How many borderless cards are illustrated in Russian?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.borderColor = 'borderless' AND T2.language = 'Russian'",
        "amends": [],
        "rules": [
            "borderless card refers to borderColor = 'borderless'; 'Russian' is the language;"
        ]
    },
    "672": {
        "sql": [
            "SELECT COUNT(DISTINCT u.Id) AS UserCount\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE u.Location = 'United Kingdom' AND p.FavoriteCount >= 4;",
            "SELECT COUNT(T1.Id) \nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.Location = 'United Kingdom' \nAND T2.FavoriteCount >= 4"
        ],
        "question": "Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4",
        "amends": [
            "Do use `COUNT(T1.Id)` instead of `COUNT(DISTINCT u.Id) AS UserCount` to count all matching rows rather than distinct user IDs. Do reference tables as `T1` and `T2` instead of `u` and `p` for table aliases. Do use `INNER JOIN` instead of `JOIN` for explicit join type specification. Do remove the `AS UserCount` alias instead of keeping it since the column alias is not needed. The amended query now correctly counts all users from the United Kingdom with posts having at least 4 favorites, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "favorite amount of 4 or more refers to FavoriteCount > = 4; Location = 'United Kingdom';"
        ]
    },
    "678": {
        "sql": [
            "SELECT p.Id, p.Title\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'Harvey Motulsky'\nORDER BY p.ViewCount DESC\nLIMIT 1;"
        ],
        "question": "Which post by Harvey Motulsky has the most views? Please give the id and title of this post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Harvey Motulsky' ORDER BY T2.ViewCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "DisplayName = 'Harvey Motulsky'; the most views refer to MAX(ViewCount);"
        ]
    },
    "507": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN c.isOnlineOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_online_only\nFROM \n    set_translations st\nJOIN \n    cards c ON st.setCode = c.setCode\nWHERE \n    st.language = 'Portuguese (Brazil)';",
            "SELECT \n    (CAST(COUNT(CASE WHEN isOnlineOnly = 1 THEN id END) AS REAL) / CAST(COUNT(id) AS REAL)) * 100 AS percentage_online_only\nFROM \n    sets\nWHERE \n    code IN (SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)');"
        ],
        "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
        "amends": [
            "Do use `sets` table instead of `set_translations` and `cards` tables, and do change the FROM clause to reference only `sets` instead of joining multiple tables. Do calculate percentage from `COUNT(id)` instead of `COUNT(*)` to count specific identifiers. Do add explicit `CAST` to `REAL` instead of implicit decimal conversion for accurate division. Do move the language filter to a subquery with `WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)')` instead of joining directly on set_translations. Do reference `isOnlineOnly` directly from the sets table instead of through a joined cards table. The amended query now correctly calculates the percentage of online-only sets for Brazilian Portuguese translations by querying the appropriate source table and using proper counting and casting semantics."
        ],
        "rules": [
            "Brazil Portuguese translation refers to language = 'Portuguese (Brazil)'; only available online refers to isOnlineOnly = 1; percentage of online only Brazil Portuguese in all Brazil Portuguese cards refers to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)))*100"
        ]
    },
    "1174": {
        "sql": [
            "SELECT AVG(1999 - strftime('%Y', p.Birthday)) AS average_age\nFROM Laboratory l\nJOIN Patient p ON l.ID = p.ID\nWHERE l.Date BETWEEN '1991-10-01' AND '1991-10-31';",
            "SELECT AVG(1999 - strftime('%Y', T2.Birthday)) \nFROM Laboratory T1\nINNER JOIN Patient T2 ON T1.ID = T2.ID\nWHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'"
        ],
        "question": "What is the average age of patients as of year 1999 examined in the laboratory for the October of the year 1991?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG('1999'  - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "amends": [
            "Do use `'1999'` as a string literal instead of `1999` as a numeric value in the age calculation. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table alias `T2` for the Patient table instead of `p` and `T1` for Laboratory instead of `l`. Do change the upper bound of the date range to `'1991-10-30'` instead of `'1991-10-31'` to properly capture only October 1991 dates. Do remove the column alias `average_age` instead of keeping it for a more concise output. The amended query now correctly calculates average age using proper string handling and precise date filtering to match the intended behavior."
        ],
        "rules": [
            "average age of patients as of year 1999 refers to AVG(SUBTRACT('1999', year(Birthday))); October of 1991 refers to Date BETWEEN '1991-10-01' AND '1991-10-30'"
        ]
    },
    "531": {
        "sql": [
            "SELECT DisplayName, Reputation FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') ORDER BY Reputation DESC;",
            "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = (SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon'))"
        ],
        "question": "Which user has a higher reputation, Harlan or Jarrod Dixon?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = ( SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') )",
        "amends": [
            "Do remove `Reputation` from the SELECT list instead of including it, and do add a WHERE filter with `Reputation = (SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon'))` instead of the simple `ORDER BY Reputation DESC`, which only sorted results rather than filtering to the maximum reputation. Do remove the `ORDER BY Reputation DESC` clause instead of keeping it, as the subquery-based filtering now ensures only the user(s) with maximum reputation are returned. The amended query now correctly identifies and returns only the user(s) with the highest reputation among those specified, matching the intended behavior."
        ],
        "rules": [
            "\"Harlan\" and \"Jarrod Dixon\" are both DisplayName; highest reputation refers to Max(Reputation)"
        ]
    },
    "878": {
        "sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name\nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nWHERE lt.raceId = 348\nORDER BY lt.time ASC\nLIMIT 1;",
            "SELECT T2.forename, T2.surname\nFROM lapTimes T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T1.raceId = 348\nORDER BY T1.milliseconds ASC\nLIMIT 1;"
        ],
        "question": "Who was the driver that got the best lap time in the race No. 348? Give his full name.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.forename, T2.surname FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 348 ORDER BY T1.time ASC LIMIT 1",
        "amends": [
            "Do select `forename` and `surname` as separate columns instead of concatenating them with `|| ' ' ||` into a single `full_name` alias. Do use `INNER JOIN` instead of just `JOIN` for explicit clarity. Do reverse the join condition to `T2.driverId = T1.driverId` instead of `lt.driverId = d.driverId` while maintaining the same logical relationship. Do use table aliases `T1` and `T2` consistently throughout instead of mixing `lt`/`d` with full table names. The amended query now correctly returns separate name columns while maintaining the same join logic and result filtering behavior."
        ],
        "rules": [
            "race number refers to raceId; the best lap time refers to MIN(time)"
        ]
    },
    "1419": {
        "sql": [
            "SELECT type FROM event WHERE event_date = '2020-03-24T12:00:00';",
            "SELECT T2.category \nFROM event T1 \nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_date = '2020-03-24T12:00:00'"
        ],
        "question": "What is the category of event which was taken place in 2020-03-24T12:00:00?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_date = '2020-03-24T12:00:00'",
        "amends": [
            "Do select `T2.category` instead of `type` from the event table. Do add an `INNER JOIN` with the `budget` table as `T2` on `T1.event_id = T2.link_to_event` instead of querying only the event table. Do use table alias `T1` for the event table instead of no alias. The amended query now correctly joins to retrieve category information from the budget table rather than selecting type directly from event, matching the intended behavior."
        ],
        "rules": [
            "taken place in 2020-03-24T12:00:00 refers to event_date = '2020-03-24T12:00:00'"
        ]
    },
    "734": {
        "sql": [
            "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Blue Beetle II';"
        ],
        "question": "What is the publisher's name of Blue Beetle II?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Blue Beetle II'",
        "amends": [],
        "rules": [
            "Blue Beetle II refers to superhero_name = 'Blue Beetle II'"
        ]
    },
    "975": {
        "sql": [
            "SELECT r.year\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nGROUP BY r.year\nORDER BY MAX(lt.time) DESC\nLIMIT 1;"
        ],
        "question": "Which year has the lowest speed of lap time?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId ORDER BY T1.time DESC LIMIT 1",
        "amends": [],
        "rules": [
            "lowest speed of lap time refers to Max(time);"
        ]
    },
    "1232": {
        "sql": [
            "SELECT P.ID, P.SEX, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.GLU >= 180 AND L.`T-CHO` < 250;"
        ],
        "question": "Provide ID, sex and age of patient who has blood glucose (GLU) not within normal range but with total cholesterol(T-CHO) within normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX , STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU >= 180 AND T2.`T-CHO` < 250",
        "amends": [],
        "rules": [
            "age = SUBTRACT(year(current_timestamp), year(Birthday)); blood glucose (GLU) not within normal range refers to GLU > = 180; total cholesterol(T-CHO) within normal range refers to `T-CHO` < 250; "
        ]
    },
    "1236": {
        "sql": [
            "SELECT P.ID, P.SEX, P.Birthday, \n       (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age,\n       L.RBC, P.Admission\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'F'\n  AND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) >= 50\n  AND (L.RBC <= 3.5 OR L.RBC >= 6.0);",
            "SELECT DISTINCT T1.ID, T1.Admission\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'female'\n  AND (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday) >= 50\n  AND T2.RBC IS NOT NULL\n  AND T2.RBC < (SELECT AVG(RBC) FROM Laboratory WHERE RBC IS NOT NULL)",
            "SELECT DISTINCT T1.ID, T1.Admission\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'\nAND (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) >= 50\nAND (T2.RBC <= 3.5 OR T2.RBC >= 6.0)"
        ],
        "question": "For all the female patient age 50 and above, who has abnormal red blood cell count. State if they were admitted to hospital.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND (T2.RBC <= 3.5 OR T2.RBC >= 6.0) AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50",
        "amends": [
            "Do select only `ID` and `Admission` columns instead of including `SEX`, `Birthday`, `Age`, and `RBC`. Do add `DISTINCT` to eliminate duplicate rows instead of returning all matches. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `P` and `L`. Do reference `T2.RBC` in the WHERE clause instead of `L.RBC`. Do use `CURRENT_TIMESTAMP` for the current year calculation instead of `'now'` string literal. Do remove the redundant `Age` column calculation from the SELECT list since it's only used in filtering. Do maintain the same join condition `T1.ID = T2.ID` and filter logic for female patients with abnormal RBC values aged 50 or older. The amended query now correctly returns distinct patient IDs and admission dates matching the intended result set.",
            "Do use `T1.SEX = 'F'` instead of `T1.SEX = 'female'` for gender filtering. Do replace the complex subquery condition with `T2.RBC <= 3.5 OR T2.RBC >= 6.0` instead of checking against an average value. Do remove the `T2.RBC IS NOT NULL` filter since the RBC range condition implicitly handles null exclusion. Do maintain the same `SELECT DISTINCT T1.ID, T1.Admission` column selection and `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` join structure. Do preserve the age calculation `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50` unchanged. The amended query now correctly identifies patients with abnormal RBC values rather than comparing to an average, matching the intended logic."
        ],
        "rules": [
            "female patient refers to Sex = 'F'; age 50 and above = SUBTRACT(year(current_timestamp), year(Birthday)) > = 50; abnormal red blood cell count refers to RBC < = 3.5 or RBC > = 6.0; Admission = '+' means the patient was admitted to the hospital; Admission = '-' means the patient was not admitted to the hospital;"
        ]
    },
    "1040": {
        "sql": [
            "SELECT p.player_name, AVG(pa.heading_accuracy) AS avg_heading_accuracy\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height > 180\nGROUP BY p.player_name\nORDER BY avg_heading_accuracy DESC\nLIMIT 10;",
            "SELECT t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 180\nGROUP BY t1.id\nORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.player_fifa_api_id) DESC\nLIMIT 10"
        ],
        "question": "List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 GROUP BY t1.id ORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.`player_fifa_api_id`) DESC LIMIT 10",
        "amends": [
            "Do select only `player_name` instead of including `AVG(pa.heading_accuracy)` with an alias. Do use table aliases `t1` and `t2` instead of `p` and `pa`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do group by `t1.id` instead of `player_name` to ensure proper aggregation. Do order by the calculated average using `CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.player_fifa_api_id)` instead of the simple `AVG(pa.heading_accuracy)` to handle division properly. Do maintain the same `WHERE` filter on height and `LIMIT` clause. The amended query now correctly calculates the average heading accuracy while ensuring proper grouping and mathematical precision, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "heights are above 180 refers to Player.height > 180; average heading accuracy = DIVIDE(SUM(heading_accuracy), COUNT(player_fifa_api_id));"
        ]
    },
    "499": {
        "sql": [
            "SELECT COUNT(*) AS translation_count\nFROM set_translations\nWHERE setCode = (SELECT code FROM sets WHERE name = 'Tenth Edition');",
            "SELECT COUNT(DISTINCT T2.translation) \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code \nWHERE T1.name = 'Tenth Edition' \nAND T2.translation IS NOT NULL"
        ],
        "question": "How many translations of the name of the set \"Tenth Edition\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL",
        "amends": [
            "Do count `DISTINCT T2.translation` instead of `COUNT(*)` to avoid duplicate translations. Do join `sets AS T1` with `set_translations AS T2` using `INNER JOIN` on `T2.setCode = T1.code` instead of using a subquery for set code lookup. Do add filter `T2.translation IS NOT NULL` instead of omitting null value handling. Do move the set name filter to the main `WHERE` clause with `T1.name = 'Tenth Edition'` instead of using a correlated subquery. The amended query now correctly counts distinct non-null translations for the specified set."
        ],
        "rules": [
            "translations of the name refers to translation; translation is not NULL; set \"Salvat 2011\" refers to name = 'Tenth Edition'"
        ]
    },
    "863": {
        "sql": [
            "SELECT s.url \nFROM seasons s \nJOIN races r ON s.year = r.year \nWHERE r.raceId = 901;"
        ],
        "question": "Show me the season page of year when the race No. 901 took place.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "amends": [],
        "rules": [
            "race number refers to raceId;"
        ]
    },
    "394": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;"
        ],
        "question": "How many white bordered cards are powerful?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "amends": [],
        "rules": [
            "white bordered cards refer to borderColor = 'white'; powerful cards refers to cardKingdomFoilId is not null AND cardKingdomId is not null (replace)"
        ]
    },
    "1003": {
        "sql": [
            "WITH canadian_gp AS (\n    SELECT raceId\n    FROM races\n    WHERE name = 'Canadian Grand Prix'\n),\naccident_counts AS (\n    SELECT r.driverId, d.forename, d.surname, COUNT(*) AS accident_count\n    FROM results r\n    JOIN canadian_gp c ON r.raceId = c.raceId\n    JOIN drivers d ON r.driverId = d.driverId\n    WHERE r.statusId = 3\n    GROUP BY r.driverId, d.forename, d.surname\n)\nSELECT forename, surname, accident_count\nFROM accident_counts\nORDER BY accident_count DESC\nLIMIT 1;",
            "SELECT COUNT(T1.driverId) \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nJOIN status AS T3 ON T1.statusId = T3.statusId \nWHERE T2.name = 'Canadian Grand Prix' \nAND T3.statusId = 3 \nGROUP BY T1.driverId \nORDER BY COUNT(T1.driverId) DESC \nLIMIT 1"
        ],
        "question": "How many accidents did the driver who had the highest number accidents in the Canadian Grand Prix have?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN status AS T3 on T1.statusId = T3.statusId WHERE T3.statusId = 3 AND T2.name = 'Canadian Grand Prix' GROUP BY T1.driverId ORDER BY COUNT(T1.driverId) DESC LIMIT 1",
        "amends": [
            "Do use `COUNT(T1.driverId)` instead of `COUNT(*) AS accident_count` to count specific driver incidents. Do join `status AS T3 on T1.statusId = T3.statusId` instead of omitting the status table join. Do move the `T2.name = 'Canadian Grand Prix'` filter from the CTE to the main WHERE clause instead of using a separate CTE. Do remove the driver name columns `forename` and `surname` instead of including them in the output. Do change the GROUP BY to only `T1.driverId` instead of grouping by multiple driver attributes. Do remove the CTE structure entirely instead of using nested common table expressions. The amended query now correctly counts accidents by driver ID for Canadian Grand Prix races with status 3, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "number of accidents refers to the number where statusid = 3; Canadian Grand Prix refers to the race of name\n"
        ]
    },
    "928": {
        "sql": [
            "SELECT d.driverRef\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.name = 'Canadian Grand Prix' AND rc.year = 2007 AND r.position = 1;",
            "SELECT T3.forename, T3.surname, T3.driverRef \nFROM races AS T1\nINNER JOIN results AS T2 ON T1.raceId = T2.raceId\nINNER JOIN drivers AS T3 ON T2.driverId = T3.driverId\nWHERE T1.name = 'Canadian Grand Prix' \nAND T1.year = 2007 \nAND T2.rank = 1;"
        ],
        "question": "Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname, T3.driverRef FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Canadian Grand Prix' AND T2.rank = 1 AND T1.year = 2007",
        "amends": [
            "Do select `forename`, `surname`, and `driverRef` instead of only `driverRef`. Do use table aliases `T1`, `T2`, and `T3` instead of full table names. Do join `races AS T1` instead of `races rc`. Do use `INNER JOIN` consistently instead of mixing `JOIN` syntax. Do filter on `T2.rank = 1` instead of `r.position = 1`. Do maintain the same join conditions between `raceId` and `driverId` columns. The amended query now correctly identifies the winner using the rank column instead of position and returns the complete driver name information."
        ],
        "rules": [
            "reference name refers to driverRef; Canadian Grand Prix refers to races.name = 'Canadian Grand Prix';"
        ]
    },
    "1487": {
        "sql": [
            "SELECT c.CustomerID, c.Segment, c.Currency, y.Consumption\nFROM customers c\nJOIN yearmonth y ON c.CustomerID = y.CustomerID\nWHERE c.Segment = 'LAM' AND c.Currency = 'Euro' AND y.Date = '201310'\nORDER BY y.Consumption DESC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' \nAND T1.Currency = 'EUR'\nAND T2.Date LIKE '2013-10%'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' AND T1.Currency = 'EUR' AND T2.Date = '201310'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "question": "Which LAM customer used the Euro as their currency and had the highest consumption in October 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date = '201310' AND T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do select only `CustomerID` instead of including `Segment`, `Currency`, and `Consumption`. Do use `INNER JOIN` with explicit aliases `T1` and `T2` instead of simple `JOIN` with `c` and `y`. Do change the currency filter to `EUR` instead of `Euro`. Do add `GROUP BY T1.CustomerID` instead of omitting aggregation. Do order by `SUM(T2.Consumption)` instead of raw `Consumption`. Do remove the direct selection of `Consumption` and instead aggregate it in the ORDER BY clause. The amended query now correctly identifies the customer with the highest total consumption for the given segment and date period rather than returning a single consumption value.",
            "Do use exact equality `T2.Date = '201310'` instead of pattern matching `T2.Date LIKE '2013-10%'` for the date filter. Do maintain the same join condition `T1.CustomerID = T2.CustomerID` with `INNER JOIN` and keep all other elements including the `SUM(T2.Consumption)` aggregation, `GROUP BY T1.CustomerID`, and `LIMIT 1` unchanged. The amended query now correctly filters for the specific month using exact date comparison instead of pattern matching, ensuring precise date handling while maintaining the same logical behavior for identifying the customer with highest consumption."
        ],
        "rules": [
            "October 2013 refers to 201310 in the yearmonth.date"
        ]
    },
    "213": {
        "sql": [
            "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR004_8' AND c.atom_id2 = 'TR004_20') OR (c.atom_id = 'TR004_20' AND c.atom_id2 = 'TR004_8');"
        ],
        "question": "What type of bond is there between the atoms TR004_8 and TR004_20?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20'",
        "amends": [],
        "rules": [
            "type of bond refers to bond_type; between the atoms TR004_8 and TR004_20 refers to atom_id = 'TR004_8' AND atom_id2 = 'TR004_20' OR another way around"
        ]
    },
    "1369": {
        "sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.amount = (SELECT MAX(amount) FROM budget);"
        ],
        "question": "Which event has the highest budget amount?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id ORDER BY T1.amount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "event refers to event_name; highest budget amount refers to MAX(amount)"
        ]
    },
    "497": {
        "sql": [
            "SELECT s.type \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Huiti\u00e8me \u00e9dition';"
        ],
        "question": "List the expansion type of the set \"Huiti\u00e8me \u00e9dition\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition' )",
        "amends": [],
        "rules": [
            "the set \"Huiti\u00e8me \u00e9dition\" refers to translation = 'Huiti\u00e8me \u00e9dition'; expansion type refers to type"
        ]
    },
    "180": {
        "sql": [
            "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE c.birth_date BETWEEN '1983-01-01' AND '1987-12-31'\nAND di.A2 = 'East Bohemia';",
            "SELECT T1.client_id, T3.account_id\nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nINNER JOIN disp T4 ON T1.client_id = T4.client_id\nINNER JOIN account T3 ON T4.account_id = T3.account_id\nWHERE STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'\nAND T2.A3 = 'east Bohemia';"
        ],
        "question": "Please provide a list of clients who were born between 1983 and 1987 and whose account branch is in East Bohemia, along with their IDs.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.client_id, T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id and T4.account_id = T3.account_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'",
        "amends": [
            "Do select both `client_id` and `account_id` instead of only `client_id`. Do join `district` directly to `client` via `district_id` instead of through the account-disposition chain. Do use `INNER JOIN` with `T1.district_id = T2.district_id` instead of joining district through account. Do add the join condition `T4.account_id = T3.account_id` to the account join instead of only joining on district_id. Do filter on `T2.A3 = 'east Bohemia'` instead of `di.A2 = 'East Bohemia'` with corrected case sensitivity. Do use `STRFTIME('%Y', T1.birth_date)` to extract year and compare against string years '1983' to '1987' instead of date range filtering with `BETWEEN` on full dates. The amended query now correctly handles the district filtering through proper table relationships and year extraction for birth date comparison."
        ],
        "rules": []
    },
    "1054": {
        "sql": [
            "SELECT pa.defensive_work_rate \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'David Wilson';"
        ],
        "question": "What is the defensive work rate of the football player David Wilson\n?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.defensive_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'David Wilson'",
        "amends": [],
        "rules": []
    },
    "259": {
        "sql": [
            "SELECT COUNT(DISTINCT a.element) AS element_count\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a ON c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id\nWHERE b.bond_type = '-';",
            "SELECT COUNT(DISTINCT T.element) \nFROM (\n    SELECT DISTINCT T2.molecule_id, T1.element\n    FROM atom AS T1\n    JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n    JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\n    WHERE T3.bond_type = '-'\n) AS T"
        ],
        "question": "How many elements are there for single bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "amends": [
            "Do count distinct `T.element` from a subquery instead of counting distinct `a.element` directly from joined tables. Do use a subquery that selects distinct `T2.molecule_id` and `T1.element` instead of omitting molecule context. Do join `atom AS T1` with `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of joining directly with bond and connected tables. Do join `molecule AS T2` with `bond AS T3` on `T2.molecule_id = T3.molecule_id` instead of using connected table joins with atom ID matching. Do filter on `T3.bond_type = '-'` in the subquery instead of applying the filter in the outer query. Do remove the complex `OR` condition `c.atom_id2 = a.atom_id` and the connected table entirely instead of keeping unnecessary table relationships. The amended query now correctly counts distinct elements within molecules containing specific bond types, matching the intended behavior."
        ],
        "rules": [
            "single bond refers to bond_type = '-';"
        ]
    },
    "177": {
        "sql": [
            "SELECT \n    t.balance AS sum_after_transaction,\n    c.gender AS account_owner_gender\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    client c ON d.client_id = c.client_id\nWHERE \n    c.client_id = 4\n    AND t.trans_id = 851;"
        ],
        "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
        "amends": [],
        "rules": []
    },
    "1485": {
        "sql": [
            "SELECT \n    (SELECT Consumption FROM yearmonth WHERE CustomerID = 7 AND Date = '201304') - \n    (SELECT Consumption FROM yearmonth WHERE CustomerID = 5 AND Date = '201304') AS ConsumptionDifference;"
        ],
        "question": "How much more was customer 7 consuming in April 2013 than customer 5?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0)) FROM yearmonth WHERE Date = '201304'",
        "amends": [],
        "rules": [
            "April 2013 refers to 201304 in the yearmonth.date"
        ]
    },
    "877": {
        "sql": [
            "SELECT d.driverId, d.forename, d.surname, d.dob\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 872 AND r.time IS NOT NULL\nORDER BY d.dob DESC\nLIMIT 1;",
            "SELECT forename, surname \nFROM results \nINNER JOIN drivers ON results.driverId = drivers.driverId \nWHERE raceId = 872 AND time IS NOT NULL \nORDER BY dob DESC \nLIMIT 1"
        ],
        "question": "For all the drivers who finished the game in race No. 872, who is the youngest?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 872 AND T2.time IS NOT NULL ORDER BY T1.dob DESC LIMIT 1",
        "amends": [
            "Do select only `forename` and `surname` instead of including `driverId` and `dob` in the SELECT list. Do use `INNER JOIN` instead of `JOIN` while maintaining the same join condition `T2.driverId = T1.driverId`. Do keep the WHERE filter on `raceId = 872` and `time IS NOT NULL` unchanged. Do maintain the ORDER BY `dob DESC` and LIMIT 1 clauses without modification. The amended query now correctly returns only the driver names instead of additional unnecessary columns while preserving the same result filtering and ordering logic."
        ],
        "rules": [
            "race number refers to raceId; drivers who finished the race refers to time has value; the youngest is a driver where MAX(dob);"
        ]
    },
    "1457": {
        "sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, m.phone AS contact_number\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost > (SELECT AVG(cost) FROM expense);",
            "SELECT DISTINCT m.first_name, m.last_name, m.phone\nFROM expense e\nINNER JOIN budget b ON e.link_to_budget = b.budget_id\nINNER JOIN member m ON e.link_to_member = m.member_id\nWHERE e.cost > (\n    SELECT AVG(e2.cost)\n    FROM expense e2\n    INNER JOIN budget b2 ON e2.link_to_budget = b2.budget_id\n    INNER JOIN member m2 ON e2.link_to_member = m2.member_id\n)"
        ],
        "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
        "amends": [
            "Do select individual columns `first_name`, `last_name`, and `phone` instead of concatenating them as `full_name` and aliasing `phone` as `contact_number`. Do add `DISTINCT` to eliminate duplicate rows instead of omitting it. Do add `INNER JOIN` with `budget` table on `T1.link_to_budget = T2.budget_id` instead of omitting this table entirely. Do change the subquery to include the same joins with `budget` and `member` tables on `T1.link_to_budget = T2.budget_id` and `T3.member_id = T1.link_to_member` instead of using a simple `AVG(cost) FROM expense` without joins. The amended query now correctly matches the RIGHT_SQL's behavior by properly joining all required tables in both the main query and subquery to ensure accurate filtering based on the average cost calculation."
        ],
        "rules": [
            "full name refers to first_name, last_name; contact number refers to phone; had spent more than average on each expense refers to cost > AVG(cost)"
        ]
    },
    "1072": {
        "sql": [
            "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Aaron Doran');"
        ],
        "question": "What is the average overall rating of the football player Aaron Doran?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
        "amends": [],
        "rules": [
            "average overall rating = AVG(overall_rating);"
        ]
    },
    "1000": {
        "sql": [
            "SELECT c.name AS racetrack, c.location || ', ' || c.country AS full_location\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.date = (SELECT MAX(date) FROM races);",
            "SELECT T1.location FROM circuits T1 INNER JOIN races T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1;"
        ],
        "question": "Which racetrack hosted the most recent race? Indicate the full location.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1",
        "amends": [
            "Do select only `location` instead of `racetrack` and `full_location` concatenation. Do use `INNER JOIN` with aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do remove the WHERE clause with subquery instead of keeping it. Do add `ORDER BY T2.date DESC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limitation. The amended query now correctly returns the single most recent race location by joining circuits and races tables and ordering by date descending with limit 1."
        ],
        "rules": [
            "full location refers to location+country; most recent race = MAX(date)\n\n"
        ]
    },
    "1367": {
        "sql": [
            "SELECT m.college\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nGROUP BY m.college\nORDER BY COUNT(mb.member_id) DESC\nLIMIT 1;"
        ],
        "question": "Which college do most of the members go to?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "college most members go refers to MAX(COUNT(major.college))"
        ]
    },
    "1155": {
        "sql": [
            "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.LDH > 500;"
        ],
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "amends": [],
        "rules": [
            "LDH beyond normal range refers to LDH > '500';"
        ]
    },
    "1029": {
        "sql": [
            "SELECT t.team_long_name, ta.buildUpPlaySpeed\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nORDER BY ta.buildUpPlaySpeed DESC\nLIMIT 4;",
            "SELECT t1.buildUpPlaySpeed \nFROM Team_Attributes t1 \nINNER JOIN Team t2 ON t1.team_api_id = t2.team_api_id \nORDER BY t1.buildUpPlaySpeed ASC \nLIMIT 4"
        ],
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4",
        "amends": [
            "Do reference `buildUpPlaySpeed` from the `Team_Attributes` table instead of selecting `team_long_name` from the `Team` table. Do use `INNER JOIN` instead of `JOIN` while maintaining the same join condition `team_api_id = team_api_id`. Do order by `buildUpPlaySpeed` in ascending order instead of descending order. Do use table aliases `t1` and `t2` instead of `ta` and `t` respectively. The amended query now correctly returns only the buildUpPlaySpeed values in ascending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "speed in which attacks are put together refers to buildUpPlaySpeed;highest build up play speed refers to MAX(buildUpPlaySpeed)"
        ]
    },
    "555": {
        "sql": [
            "SELECT AVG(p.Score) AS AverageScore\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';"
        ],
        "question": "What is the average score of the posts owned by the user csgillespie?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.Score) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; average score refers to AVG(Score)"
        ]
    },
    "89": {
        "sql": [
            "SELECT COUNT(*) AS account_count\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE a.frequency = 'POPLATEK PO OBRATU'\nAND d.A3 = 'East Bohemia';",
            "SELECT COUNT(T2.account_id) \nFROM district T1 \nINNER JOIN account T2 ON T1.district_id = T2.district_id \nWHERE T1.A3 = 'east Bohemia' \nAND T2.frequency = 'ISSUANCE AFTER TRANSACTION'",
            "SELECT COUNT(T2.account_id)\nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nWHERE T1.A3 = 'east Bohemia'\nAND T2.frequency = 'POPLATEK PO OBRATU'"
        ],
        "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
        "amends": [
            "Do use `COUNT(T2.account_id)` instead of `COUNT(*)` to count specific non-null values. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` consistently instead of mixed `a` and `d` aliases. Do place the `T1.A3 = 'east Bohemia'` condition before the `T2.frequency` condition instead of the reverse order. Do use lowercase 'east Bohemia' instead of 'East Bohemia' to match the actual data format. The amended query now correctly counts accounts with the specified frequency in the east Bohemia district.",
            "Do change the WHERE filter condition for `T2.frequency` to `'POPLATEK PO OBRATU'` instead of `'ISSUANCE AFTER TRANSACTION'` to match the correct business logic requirement for counting accounts with the specific frequency type. The amended query now correctly filters for accounts with the 'POPLATEK PO OBRATU' frequency in the 'east Bohemia' district, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "A3 contains the data of region; 'POPLATEK PO OBRATU' represents for 'issuance after transaction'."
        ]
    },
    "760": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_marvel\nFROM \n    superhero s\nLEFT JOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    s.height_cm BETWEEN 150 AND 180;"
        ],
        "question": "In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180",
        "amends": [],
        "rules": [
            "height between 150 to 180 refers to height_cm BETWEEN 150 AND 180; heroes published by Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = MULTIPLY(DIVIDE(SUM(publisher.id = 13)), COUNT(publisher.id), 100)"
        ]
    },
    "216": {
        "sql": [
            "SELECT c.atom_id, c.atom_id2, c.bond_id\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '#';",
            "SELECT T2.atom_id, T2.atom_id2 FROM bond T1 INNER JOIN connected T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'"
        ],
        "question": "Identify all connected atoms with a triple bond.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select only `atom_id` and `atom_id2` instead of including `bond_id` in the SELECT list. Do use `INNER JOIN` with table aliases `T1` for `bond` and `T2` for `connected` instead of joining without aliases. Do join on `T1.bond_id = T2.bond_id` instead of `c.bond_id = b.bond_id`. Do filter on `T1.bond_type = '#'` instead of `b.bond_type = '#'`. The amended query now correctly retrieves only the atom identifiers from connected bonds of type '#' without redundant bond_id output."
        ],
        "rules": [
            "triple bond refers to bond_type = '#';"
        ]
    },
    "926": {
        "sql": [
            "SELECT MIN(r.fastestLapTime) AS fastest_lap_time\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';"
        ],
        "question": "What's the fastest lap time ever in a race for Lewis Hamilton?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.fastestLapTime FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "amends": [],
        "rules": [
            "fastest lap time ever refers to min(fastestLapTime)"
        ]
    },
    "1047": {
        "sql": [
            "SELECT p.player_name, pa.heading_accuracy\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Francois Affolter'\nAND pa.date = '2014-09-18 00:00:00';",
            "SELECT t1.heading_accuracy\nFROM Player_Attributes t1\nINNER JOIN Player t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.player_name = 'Francois Affolter'\nAND SUBSTR(t1.date, 1, 10) = '2014-09-18'"
        ],
        "question": "What is the football player Francois Affolter header's finishing rate on 18/09/2014?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.heading_accuracy FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Francois Affolter' AND SUBSTR(t2.`date`, 1, 10) = '2014-09-18'",
        "amends": [
            "Do select only `heading_accuracy` instead of both `player_name` and `heading_accuracy`. Do use `INNER JOIN` instead of `JOIN` (which are equivalent, but explicit). Do use table aliases `t1` and `t2` instead of full table names. Do change the date filter to use `SUBSTR(t2.date, 1, 10)` to extract just the date portion instead of comparing the full timestamp string. Do remove the explicit `00:00:00` time component from the date comparison. The amended query now correctly handles date filtering by extracting only the date part and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "header's finishing rate refers to heading_accuracy; on 18/09/2014 refers to date = '2014-09-18 00:00:00';"
        ]
    },
    "256": {
        "sql": [
            "SELECT COUNT(*) AS total_atoms FROM atom WHERE element IN ('C', 'H');",
            "SELECT COUNT(T.atom_id) FROM atom T WHERE T.element = 'c' OR T.element = 'h'"
        ],
        "question": "Calculate the total atoms consisting of the element carbon and hydrogen.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.element = 'c' OR T.element = 'h'",
        "amends": [
            "Do use `COUNT(T.atom_id)` instead of `COUNT(*)` to count only non-null atom_id values. Do specify table alias `T` for the atom table instead of omitting it. Do use explicit column references `T.element` instead of unqualified `element`. Do change the condition to `T.element = 'c' OR T.element = 'h'` instead of `element IN ('C', 'H')` to use lowercase letters and OR logic instead of IN. The amended query now correctly counts atoms with lowercase element values 'c' or 'h' using proper table aliasing and explicit column references."
        ],
        "rules": [
            "consisting of element carbon and hydrogen refers to element in('c', 'h')"
        ]
    },
    "1280": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.GOT < 60;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60 AND T1.SEX = 'M'"
        ],
        "question": "How many male patients have their glutamic oxaloacetic transaminase in the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T2.GOT < 60` condition before `T1.SEX = 'M'` in the WHERE clause instead of the reverse order, though this is functionally equivalent. The amended query now correctly counts all patient records meeting the criteria rather than unique patients, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "male refers to Sex = 'M'; glutamic oxaloacetic transaminase in the normal range refers to GOT < 60;"
        ]
    },
    "1406": {
        "sql": [
            "SELECT * FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food');",
            "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget);"
        ],
        "question": "Among the budgets for Food, which one has the highest budgeted amount?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget )",
        "amends": [
            "Do select only `budget_id` instead of all columns with `*`. Do remove the redundant `WHERE category = 'Food'` condition from the subquery instead of keeping it, as the maximum amount calculation should consider all categories to correctly identify the highest food budget amount. Do maintain the outer query's filter on `category = 'Food'` instead of removing it to ensure only food category records are returned. The amended query now correctly identifies budget records in the food category that have the maximum budget amount across all categories."
        ],
        "rules": [
            "MAX(amount) where category = 'Food'"
        ]
    },
    "741": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nGROUP BY s.superhero_name\nORDER BY COUNT(hp.power_id) DESC\nLIMIT 1;"
        ],
        "question": "What is the name of the superhero that has the most powers?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "name of the superhero refers to superhero_name; superhero that has the most powers refers to MAX(COUNT(superhero_name))"
        ]
    },
    "350": {
        "sql": [
            "SELECT DISTINCT fd.language\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.name = 'Annul' AND c.number = '29';"
        ],
        "question": "State the alternative languages available for card named Annul numbered 29.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Annul' AND T1.number = 29",
        "amends": [],
        "rules": [
            "annul refers to name = 'annul'; numbered 29 refers to number = '29';"
        ]
    },
    "1388": {
        "sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, i.source\nFROM member m\nJOIN income i ON m.member_id = i.link_to_member\nWHERE i.amount = (SELECT MAX(amount) FROM income);",
            "SELECT first_name, last_name, source, SUM(amount) as total_income\nFROM member\nJOIN income ON member.member_id = income.link_to_member\nGROUP BY first_name, last_name, source\nORDER BY total_income DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.last_name, T2.source\nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nGROUP BY T1.first_name, T1.last_name, T2.source\nORDER BY SUM(T2.amount) DESC\nLIMIT 1"
        ],
        "question": "Which students manage to generate the highest income. State his/her full name along with the income source.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name, T2.source FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.first_name, T1.last_name, T2.source ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "amends": [
            "Do select individual columns `first_name`, `last_name`, and `source` instead of concatenating them into a single `full_name` column. Do add `GROUP BY` with `first_name`, `last_name`, and `source` instead of omitting grouping. Do add `ORDER BY SUM(amount) DESC` instead of using a subquery to find maximum amount. Do add `LIMIT 1` instead of returning all rows with maximum amount. Do remove the WHERE clause with subquery instead of keeping it. The amended query now correctly returns the member with the highest total income rather than all members who have any income matching the maximum single income amount, matching the RIGHT_SQL's behavior.",
            "Do remove `SUM(amount) as total_income` from the SELECT list instead of including it, and do use explicit table aliases `T1` and `T2` instead of omitting them. Do specify `INNER JOIN` instead of just `JOIN` for clarity. Do reference the aggregate function `SUM(T2.amount)` directly in the ORDER BY clause instead of using the alias `total_income`, and do ensure all GROUP BY columns use the explicit table aliases `T1.first_name`, `T1.last_name`, and `T2.source` instead of unqualified column names. The amended query now correctly orders by the sum of amounts while selecting only the member and source details without including the aggregate value in the output, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "name of students means the full name; full name refers to first_name, last_name; generate the highest income refers to MAX(income.amount);"
        ]
    },
    "617": {
        "sql": [
            "SELECT c.Text \nFROM comments c \nJOIN posts p ON c.PostId = p.Id \nWHERE p.CreaionDate = '2010-07-19 19:37:33.0';",
            "SELECT T1.Text \nFROM comments T1 \nINNER JOIN posts T2 ON T1.PostId = T2.Id \nWHERE T1.CreationDate = '2010-07-19 19:37:33'",
            "SELECT T1.Text \nFROM comments T1 \nINNER JOIN posts T2 ON T1.PostId = T2.Id \nWHERE T1.CreationDate = '2010-07-19 19:37:33.0'"
        ],
        "question": "What is the detailed content of the comment of the post which was created on 7/19/2010 7:37:33 PM?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:37:33.0'",
        "amends": [
            "Do reference the `Text` column from `comments` table instead of using an ambiguous column reference. Do use table alias `T1` for `comments` instead of `c` and `T2` for `posts` instead of `p`. Do filter on `T1.CreationDate` instead of `p.CreationDate` to correctly query the comment creation date rather than the post creation date. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. The amended query now correctly filters comments by their own creation date rather than incorrectly filtering by post creation date, matching the intended behavior.",
            "Do use the full timestamp format '2010-07-19 19:37:33.0' instead of the truncated '2010-07-19 19:37:33' in the WHERE clause to ensure precise timestamp matching. The amended query now correctly matches the RIGHT_SQL's behavior with the complete timestamp specification."
        ],
        "rules": [
            "detailed content of the comment refers to Text; created on 7/19/2010 7:37:33 PM CreationDate = 2010-07-19 19:37:33.0'"
        ]
    },
    "18": {
        "sql": [
            "SELECT COUNT(*) \nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.County = 'Fresno' \nAND s.FundingType = 'Directly Funded' \nAND sc.NumTstTakr <= 250;",
            "SELECT COUNT(T1.CDSCode) \nFROM frpm AS T1 \nINNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds \nWHERE T1.\"County Name\" = 'Fresno' \nAND T1.\"Charter Funding Type\" = 'Directly funded' \nAND T2.NumTstTakr <= 250"
        ],
        "question": "How many schools in Fresno (directly funded) have number of test takers not more than 250?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.CDSCode) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`County Name` = 'Fresno' AND T2.NumTstTakr <= 250",
        "amends": [
            "Do use `COUNT(T1.CDSCode)` instead of `COUNT(*)` to count specific non-null values. Do join from `frpm AS T1` instead of `schools s` as the primary table. Do use `INNER JOIN` with `satscores AS T2` instead of `JOIN` with `sc` for explicit join type clarity. Do reference `T1.`Charter Funding Type` = 'Directly funded'` instead of `s.FundingType = 'Directly Funded'` with corrected case sensitivity and column name. Do reference `T1.`County Name` = 'Fresno'` instead of `s.County = 'Fresno'` with the proper column name. Do maintain the condition `T2.NumTstTakr <= 250` instead of `sc.NumTstTakr <= 250` with consistent table alias. The amended query now correctly joins the appropriate tables with accurate column references and filtering conditions to match the intended behavior."
        ],
        "rules": []
    },
    "40": {
        "sql": [
            "SELECT s.Phone\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.District = 'Fresno Unified'\nORDER BY sc.AvgScrRead ASC\nLIMIT 1;",
            "SELECT T2.Phone\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.District = 'Fresno Unified'\nAND T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;"
        ],
        "question": "What is the telephone number for the school with the lowest average score in reading in Fresno Unified?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "amends": [
            "Do reference the `Phone` column from the `schools` table instead of the `satscores` table. Do use `INNER JOIN` with the join condition `T1.cds = T2.CDSCode` instead of `JOIN` with `s.CDSCode = sc.cds`. Do add the filter `AND T1.AvgScrRead IS NOT NULL` to exclude null values instead of omitting this condition. Do use table aliases `T1` for `satscores` and `T2` for `schools` instead of `s` and `sc`. The amended query now correctly filters out null average reading scores and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Fresno Unified is a name of district;"
        ]
    },
    "265": {
        "sql": [
            "SELECT molecule_id FROM molecule WHERE label = '-';"
        ],
        "question": "List down the molecule id for non carcinogenic molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM molecule AS T WHERE T.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic"
        ]
    },
    "816": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nWHERE ha.attribute_value BETWEEN 75 AND 80;"
        ],
        "question": "Provide the names of superheroes with attribute value between 75 to 80.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T2.attribute_value BETWEEN 75 AND 80",
        "amends": [],
        "rules": [
            "names of superheroes refers to superhero_name; attribute value between 75 to 80 refers to attribute_value BETWEEN 75 AND 80;"
        ]
    },
    "310": {
        "sql": [
            "WITH double_bond_molecules AS (\n  SELECT DISTINCT molecule_id\n  FROM bond\n  WHERE bond_type = ' = '\n)\nSELECT \n  COUNT(*) AS total_molecules_with_double_bond,\n  SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) AS carcinogenic_molecules_with_double_bond\nFROM double_bond_molecules dbm\nJOIN molecule m ON dbm.molecule_id = m.molecule_id;",
            "SELECT \n    COUNT(DISTINCT T1.molecule_id) AS total_molecules_with_double_bonds,\n    COUNT(DISTINCT CASE WHEN T2.label = 'carcinogenic compound' THEN T1.molecule_id END) AS carcinogenic_molecules\nFROM \n    bond T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T1.bond_type = '='",
            "SELECT \n    COUNT(DISTINCT T2.molecule_id) AS total_molecules_with_double_bonds,\n    SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS carcinogenic_molecules\nFROM \n    bond T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T1.bond_type = '='"
        ],
        "question": "How many molecules have a double bond type and among these molecule, how many are labeled as carcinogenic compound?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id), SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '='",
        "amends": [
            "Do use `COUNT(DISTINCT T2.molecule_id)` instead of `COUNT(*)` to avoid counting duplicate molecules with multiple double bonds. Do move the `bond_type = '='` filter from the CTE to the main `WHERE` clause instead of keeping it in a separate CTE. Do remove the unnecessary CTE structure and perform a direct `INNER JOIN` between `bond` and `molecule` tables instead of using a CTE intermediate. Do use table aliases `T1` and `T2` instead of `dbm` and `m` for clarity. Do change the bond type comparison from `' = '` (with spaces) to `'='` (without spaces) to match the actual data format. The amended query now correctly handles molecules with multiple double bonds by using DISTINCT counting and matches the RIGHT_SQL's behavior.",
            "Do use `COUNT(DISTINCT T2.molecule_id)` instead of `COUNT(DISTINCT T1.molecule_id)` for the first aggregate. Do replace `COUNT(DISTINCT CASE WHEN T2.label = 'carcinogenic compound' THEN T1.molecule_id END)` with `SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END)` instead of counting distinct molecule IDs with a different condition. Do remove the column aliases `total_molecules_with_double_bonds` and `carcinogenic_molecules` instead of keeping them. Do use `T2.label = '+'` instead of `T2.label = 'carcinogenic compound'` in the CASE condition. The amended query now correctly counts distinct molecules from the molecule table and sums cases where the label equals '+' rather than using carcinogenic compound filtering with distinct counts."
        ],
        "rules": [
            "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic;"
        ]
    },
    "458": {
        "sql": [
            "SELECT COUNT(DISTINCT artist) AS artist_count\nFROM cards\nWHERE borderColor = 'black'\nAND availability LIKE '%arena%'\nAND availability LIKE '%mtgo%';",
            "SELECT COUNT(DISTINCT CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN artist ELSE NULL END) FROM cards;",
            "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards;"
        ],
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards",
        "amends": [
            "Do use a conditional COUNT with `CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END` instead of COUNT(DISTINCT artist) with separate LIKE conditions. Do combine the availability check into a single pattern `'%arena,mtgo%'` instead of separate `LIKE '%arena%'` and `LIKE '%mtgo%'` conditions. Do remove the artist column reference and DISTINCT aggregation instead of counting distinct artists. Do eliminate the alias `artist_count` instead of keeping it. The amended query now correctly counts cards where availability contains both arena and mtgo together in a comma-separated format with black border color, matching the RIGHT_SQL's behavior.",
            "Do remove `DISTINCT` from the aggregate function instead of keeping it, as the COUNT function inherently handles uniqueness when counting non-null values. Do change the CASE expression to return `1` instead of `artist` when conditions are met, since we want to count occurrences rather than distinct artist values. Do keep the same `LIKE '%arena,mtgo%'` and `borderColor = 'black'` conditions in the WHERE clause logic instead of changing them. The amended query now correctly counts all matching rows rather than distinct artists, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "available in both \"arena\" and \"mtgo\" refers to availability like '%arena,mtgo%'"
        ]
    },
    "1111": {
        "sql": [
            "SELECT ta.chanceCreationPassingClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'PEC Zwolle' \nAND ta.date = '2013-09-20 00:00:00';"
        ],
        "question": "State the chance creation passing class for \"PEC Zwolle\" on 2013/9/20.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'PEC Zwolle' AND SUBSTR(t2.`date`, 1, 10) = '2013-09-20'",
        "amends": [],
        "rules": [
            "\"PEC Zwolle\" refers to team_long_name = 'PEC Zwolle'; on 2013/9/20 refers to date = '2013-09-20 00:00:00'"
        ]
    },
    "278": {
        "sql": [
            "SELECT COUNT(DISTINCT b.molecule_id) \nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '-' AND m.label = '-';"
        ],
        "question": "How many of the single bond type molecules are non-carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; single bond refers to bond_type = '-';"
        ]
    },
    "183": {
        "sql": [
            "SELECT COUNT(*) AS account_count\nFROM account\nJOIN district ON account.district_id = district.district_id\nWHERE district.A2 = 'Beroun' AND strftime('%Y', account.date) > '1996';"
        ],
        "question": "How many accounts in Beroun were opened after 1996?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) > '1996' AND T2.A2 = 'Beroun'",
        "amends": [],
        "rules": []
    },
    "1376": {
        "sql": [
            "SELECT e.event_id, e.event_name, e.event_date, e.type, e.notes, e.location, e.status, b.budget_id, b.category, b.spent, b.remaining, b.amount, (b.spent / b.amount) AS spend_to_budget_ratio\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.status = 'Closed'\nORDER BY spend_to_budget_ratio DESC\nLIMIT 1;",
            "SELECT T2.event_name\nFROM budget T1\nINNER JOIN event T2 ON T1.link_to_event = T2.event_id\nWHERE T2.status = 'Closed'\nORDER BY (T1.spent / T1.amount) DESC\nLIMIT 1"
        ],
        "question": "Among all the closed events, which event has the highest spend-to-budget ratio?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
        "amends": [
            "Do select only `event_name` instead of including multiple columns like `event_id`, `event_date`, `type`, `notes`, `location`, `status`, `budget_id`, `category`, `spent`, `remaining`, and `amount`. Do use `INNER JOIN` with `T1.link_to_event = T2.event_id` instead of `JOIN` with `e.event_id = b.link_to_event`. Do reference tables as `T1` and `T2` with aliases instead of `e` and `b`. Do place the ratio calculation `T1.spent / T1.amount` directly in the `ORDER BY` clause instead of creating an alias `spend_to_budget_ratio` in the SELECT list. Do maintain the same `WHERE` filter for `status = 'Closed'` and `LIMIT 1` with descending order. The amended query now correctly focuses on retrieving only the event name with the highest spend-to-budget ratio for closed events."
        ],
        "rules": [
            "closed events refers to event_name where status = 'Closed'; highest spend-to budget ratio refers to MAX(DIVIDE(spent, amount))"
        ]
    },
    "430": {
        "sql": [
            "SELECT s.code AS set_code, c.id AS card_id\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nJOIN sets s ON c.setCode = s.code\nWHERE fd.language = 'Italian' AND s.block = 'Shadowmoor'\nORDER BY s.code ASC\nLIMIT 2;",
            "SELECT T1.name, T1.id\nFROM sets T1\nJOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Italian' AND T1.block = 'Shadowmoor'\nORDER BY T1.id ASC\nLIMIT 2;"
        ],
        "question": "Please list top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block in alphabetical order.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Shadowmoor' AND T2.language = 'Italian' ORDER BY T1.id LIMIT 2",
        "amends": [
            "Do select `T1.name` and `T1.id` instead of `s.code AS set_code` and `c.id AS card_id`. Do join `set_translations AS T2` on `T1.code = T2.setCode` instead of joining `foreign_data fd` on `c.uuid = fd.uuid` and `sets s` on `c.setCode = s.code`. Do filter with `T2.language = 'Italian'` instead of `fd.language = 'Italian'` while keeping `T1.block = 'Shadowmoor'`. Do order by `T1.id` instead of `s.code ASC`. The amended query now correctly retrieves Italian-translated Shadowmoor sets from the appropriate translation table rather than attempting to join through unrelated card and foreign data tables."
        ],
        "rules": []
    },
    "1041": {
        "sql": [
            "WITH AvgChanceCreation AS (\n    SELECT AVG(chanceCreationPassing) AS avg_chance_creation\n    FROM Team_Attributes\n),\nTeamsIn2014 AS (\n    SELECT team_api_id, chanceCreationPassing\n    FROM Team_Attributes\n    WHERE buildUpPlayDribblingClass = 'Normal'\n    AND date >= '2014-01-01 00:00:00' AND date <= '2014-12-31 23:59:59'\n)\nSELECT t.team_long_name, ti.chanceCreationPassing\nFROM TeamsIn2014 ti\nJOIN Team t ON ti.team_api_id = t.team_api_id\nJOIN AvgChanceCreation ac ON ti.chanceCreationPassing < ac.avg_chance_creation\nORDER BY ti.chanceCreationPassing DESC;",
            "SELECT t3.team_long_name\nFROM Team_Attributes t2\nJOIN Team t3 ON t2.team_api_id = t3.team_api_id\nWHERE t2.buildUpPlayDribblingClass = 'Normal'\nAND SUBSTR(t2.date, 1, 4) = '2014'\nAND t2.chanceCreationPassing < (\n    SELECT CAST(SUM(t4.chanceCreationPassing) AS REAL) / COUNT(t4.id)\n    FROM Team_Attributes t4\n    JOIN Team t5 ON t4.team_api_id = t5.team_api_id\n    WHERE t4.buildUpPlayDribblingClass = 'Normal'\n    AND SUBSTR(t4.date, 1, 4) = '2014'\n)\nORDER BY t2.chanceCreationPassing DESC;",
            "SELECT t3.team_long_name\nFROM Team_Attributes t4\nINNER JOIN Team t3 ON t4.team_api_id = t3.team_api_id\nWHERE t4.buildUpPlayDribblingClass = 'Normal'\nAND t4.chanceCreationPassing < (\n    SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)\n    FROM Team t1\n    INNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id\n    WHERE t2.buildUpPlayDribblingClass = 'Normal'\n    AND SUBSTR(t2.`date`, 1, 4) = '2014'\n)\nORDER BY t4.chanceCreationPassing DESC;"
        ],
        "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
        "amends": [
            "Do use a single query with subquery instead of CTEs, and move the date filter from the CTE to the main WHERE clause. Do change the join condition from `JOIN AvgChanceCreation ac ON ti.chanceCreationPassing < ac.avg_chance_creation` to a subquery comparison `t4.chanceCreationPassing < (SELECT ...)` instead of joining on a CTE. Do add the correct average calculation using `CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)` instead of simple `AVG(chanceCreationPassing)` to handle potential division issues. Do change the date filtering from range comparison `date >= '2014-01-01 00:00:00' AND date <= '2014-12-31 23:59:59'` to year extraction `SUBSTR(t2.date, 1, 4) = '2014'` instead of exact timestamp matching. Do remove the explicit column `ti.chanceCreationPassing` from SELECT list instead of including it, keeping only `t3.team_long_name`. Do maintain the same `ORDER BY t4.chanceCreationPassing DESC` instead of changing the sort order. The amended query now correctly calculates the average chance creation for 2014 teams with normal dribbling and filters teams below that average.",
            "Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference `Team_Attributes` as `t4` in the main query instead of `t2` and `Team` as `t3` instead of maintaining the original aliases. Do remove the `SUBSTR(t2.date, 1, 4) = '2014'` filter from the main WHERE clause instead of keeping it, as the date filtering should only apply to the subquery. Do change the subquery to reference `Team` as `t1` and `Team_Attributes` as `t2` instead of `t4` and `t5` for consistency. Do use backticks around `date` column in the subquery instead of unquoted to handle reserved keywords. Do reference `t4.chanceCreationPassing` in the ORDER BY instead of `t2.chanceCreationPassing` to match the main query's table alias. The amended query now correctly filters teams based on 2014 average chance creation passing values while maintaining proper table references throughout."
        ],
        "rules": [
            "normal build-up play dribbling class refers to buildUpPlayDribblingClass = 'Normal'; in 2014 refers to date > = '2014-01-01 00:00:00' AND date < = '2014-01-31 00:00:00'; names of the teams refers to team_long_name; less than average chance creation passing = DIVIDE(SUM(chanceCreationPassing), COUNT(id)) > chanceCreationPassing;"
        ]
    },
    "1114": {
        "sql": [
            "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Marko Arnautovic')\nAND date BETWEEN '2007-02-22' AND '2016-04-21';",
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_rating\nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\nWHERE t1.player_name = 'Marko Arnautovic'\nAND SUBSTR(t2.\"date\", 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'"
        ],
        "question": "What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Marko Arnautovic' AND SUBSTR(t2.`date`, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'",
        "amends": [
            "Do use `CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id)` instead of `AVG(overall_rating)` to ensure proper floating-point division. Do join `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id` instead of querying `Player_Attributes` directly with a subquery. Do filter on `t1.player_name = 'Marko Arnautovic'` in the main WHERE clause instead of using a subquery for player lookup. Do use `SUBSTR(t2.\"date\", 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'` instead of direct date comparison to handle datetime values properly. The amended query now correctly calculates the average rating by joining on the proper foreign key relationship and handling date formatting appropriately."
        ],
        "rules": [
            "average overall rating refers to avg(overall_rating); Marko Arnautovic refers to player_name = 'Marko Arnautovic'; from 2007/2/22 to 2016/4/21 refers to the first 10 characters of date BETWEEN '2007-02-22' and '2016-04-21'"
        ]
    },
    "219": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN b.bond_type = '#' THEN 1 ELSE 0 END) * 100.0 / COUNT(b.bond_id)) AS percentage\nFROM \n    molecule m\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nWHERE \n    m.label = '+';",
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN m.label = '+' THEN m.molecule_id END) AS REAL) / \n     COUNT(DISTINCT m.molecule_id)) * 100.0 AS percentage\nFROM \n    molecule m\nINNER JOIN \n    bond b ON m.molecule_id = b.molecule_id\nINNER JOIN \n    connected c ON b.bond_id = c.bond_id\nINNER JOIN \n    atom a1 ON c.atom_id = a1.atom_id\nINNER JOIN \n    atom a2 ON c.atom_id2 = a2.atom_id\nWHERE \n    b.bond_type = '#'",
            "SELECT \n    (COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id END) * 100.0 / \n     COUNT(DISTINCT T2.molecule_id)) AS percentage\nFROM \n    molecule AS T2\nINNER JOIN \n    atom AS T1 ON T1.molecule_id = T2.molecule_id\nINNER JOIN \n    connected AS T4 ON T1.atom_id = T4.atom_id OR T1.atom_id = T4.atom_id2\nINNER JOIN \n    bond AS T3 ON T4.bond_id = T3.bond_id\nWHERE \n    T3.bond_type = '#'"
        ],
        "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
        "amends": [
            "Do calculate the percentage of distinct `molecule_id` values where `label = '+'` instead of counting bond occurrences. Do join `atom` and `molecule` tables with `INNER JOIN` on `molecule_id` instead of only joining `molecule` and `bond`. Do add `atom` table to the FROM clause instead of omitting it. Do filter on `bond_type = '#'` in the WHERE clause instead of using it in a CASE expression. Do use `COUNT(DISTINCT molecule_id)` for both numerator and denominator instead of SUM and COUNT on bond_id. Do cast the numerator to REAL for precise division instead of using 100.0 multiplication. Do remove the bond counting logic and CASE expression instead of keeping them. The amended query now correctly calculates the percentage of distinct molecules with '+' label that have bonds of type '#', matching the RIGHT_SQL's behavior.",
            "Do calculate the percentage using `T2.molecule_id` from the molecule table instead of `m.molecule_id` from the original join structure. Do join `atom AS T1` to `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of the complex multi-table join chain involving bond, connected, and two atom tables. Do remove the unnecessary joins to `connected`, `atom a1`, and `atom a2` instead of including them. Do simplify the WHERE clause to filter only on `T3.bond_type = '#'` instead of the previous complex join conditions. Do maintain the same aggregate logic with `COUNT(DISTINCT CASE)` for percentage calculation but with corrected table references. The amended query now correctly calculates the percentage of molecules with '+' label among those containing '#' bond types by properly joining only the necessary tables."
        ],
        "rules": [
            "label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(bond_type = '#') * 100, COUNT(bond_id)) as percent where label = '+'"
        ]
    },
    "23": {
        "sql": [
            "SELECT f.`School Name`, s.Street, s.City, s.State, s.Zip\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE (f.`Enrollment (K-12)` - f.`Enrollment (Ages 5-17)`) > 30;",
            "SELECT T1.School, T1.Street\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE ABS(T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\") > 30;"
        ],
        "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
        "amends": [
            "Do select `T1.School` and `T1.Street` instead of `f.School Name`, `s.Street`, `s.City`, `s.State`, and `s.Zip`. Do use table aliases `T1` for `schools` and `T2` for `frpm` instead of `s` and `f`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use the join condition `T1.CDSCode = T2.CDSCode` instead of `f.CDSCode = s.CDSCode`. Do reference the calculation as `T2.Enrollment (K-12)` - `T2.Enrollment (Ages 5-17)` instead of `f.Enrollment (K-12)` - `f.Enrollment (Ages 5-17)`. The amended query now correctly selects only the school name and street columns from the appropriate tables with proper table aliasing and join specification."
        ],
        "rules": [
            "Diffrence in enrollement = `Enrollment (K-12)` - `Enrollment (Ages 5-17)`"
        ]
    },
    "79": {
        "sql": [
            "SELECT County, COUNT(*) AS NumberOfVirtualSchools\nFROM schools\nWHERE Virtual = 'F' AND County IN ('San Diego', 'Santa Barbara')\nGROUP BY County\nORDER BY NumberOfVirtualSchools DESC\nLIMIT 1;"
        ],
        "question": "Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT County, COUNT(Virtual) FROM schools WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F' GROUP BY County ORDER BY COUNT(Virtual) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "'Does not offer physical building' means Virtual = F in the database."
        ]
    },
    "408": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE (power IS NULL OR power = '*') \nAND text LIKE '%triggered ability%';",
            "SELECT T2.text \nFROM cards AS T1 \nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid \nWHERE T1.power = 'unknown' \nAND T2.text LIKE '%triggered ability%';",
            "SELECT T2.text \nFROM cards AS T1 \nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid \nWHERE (T1.power IS NULL OR T1.power = '*') \nAND T2.text LIKE '%triggered ability%';"
        ],
        "question": "How many unknown power cards contain info about the triggered ability",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power = '*') AND T2.text LIKE '%triggered ability%'",
        "amends": [
            "Do select `T2.text` instead of `COUNT(*)` to return actual ruling text rather than just a count. Do add `INNER JOIN rulings AS T2` on `T1.uuid = T2.uuid` instead of querying only the `cards` table to properly join with rulings data. Do reference `T1.power` instead of just `power` to qualify the column with its table alias. Do reference `T2.text` instead of just `text` in the LIKE condition to filter on the ruling text rather than card text. The amended query now correctly joins cards with their rulings and returns the actual ruling text containing triggered ability references instead of just counting them.",
            "Do change the WHERE condition to `T1.power IS NULL OR T1.power = '*'` instead of `T1.power = 'unknown'` to properly handle both NULL values and the asterisk wildcard character that represents unknown power values. The amended query now correctly matches the RIGHT_SQL's behavior by addressing the NULL semantics and alternative representation of unknown power values."
        ],
        "rules": [
            "unknown power cards refers to power is null or power = '*';contain info about the triggered ability refers to text contains 'triggered ability'"
        ]
    },
    "229": {
        "sql": [
            "SELECT b.bond_type FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR000';"
        ],
        "question": "What is the type of bond that molecule TR000 has when involved in any bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.bond_type FROM bond AS T WHERE T.molecule_id = 'TR000'",
        "amends": [],
        "rules": [
            "type of bond refers to bond_type; TR000 is the molecule id"
        ]
    },
    "182": {
        "sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS male_customers_count\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN trans t ON a.account_id = t.account_id\nWHERE c.gender = 'M'\n  AND strftime('%Y', c.birth_date) BETWEEN '1974' AND '1976'\n  AND t.k_symbol = 'SIPO'\n  AND t.amount > 4000;",
            "SELECT COUNT(DISTINCT T4.account_id)\nFROM trans T1\nINNER JOIN account T4 ON T1.account_id = T4.account_id\nINNER JOIN disp T3 ON T4.account_id = T3.account_id\nINNER JOIN client T2 ON T3.client_id = T2.client_id\nWHERE T2.gender = 'M'\nAND T2.birth_date BETWEEN '1974-01-01' AND '1976-12-31'\nAND T1.amount > 4000\nAND T1.k_symbol = 'HOME PAYMENT'",
            "SELECT COUNT(T1.account_id)\nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T4 ON T2.account_id = T4.account_id\nINNER JOIN client T3 ON T4.client_id = T3.client_id\nWHERE T3.gender = 'M'\nAND STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976'\nAND T1.amount > 4000\nAND T1.k_symbol = 'SIPO'"
        ],
        "question": "How many male customers who were born between 1974 and 1976 have made a payment on their home in excess of $4000?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T2.account_id = T4.account_id INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976' AND T3.gender = 'M' AND T1.amount > 4000 AND T1.k_symbol = 'SIPO'",
        "amends": [
            "Do count `account_id` instead of `DISTINCT client_id` for the aggregate function. Do use `INNER JOIN` consistently instead of mixing `JOIN` without explicit type. Do correct the join order by connecting `trans` to `account` first instead of starting from `client`. Do fix the join condition between `disp` and `account` to use `T2.account_id = T4.account_id` instead of potentially incorrect column references. Do maintain the same filter conditions for `gender`, `birth_date`, `amount`, and `k_symbol` but ensure proper table aliasing. The amended query now correctly counts accounts rather than distinct clients and maintains proper join relationships to match the RIGHT_SQL's behavior.",
            "Do count `T1.account_id` without `DISTINCT` instead of counting distinct `T4.account_id`. Do use table aliases `T2` for account and `T3` for client instead of `T4` for account and `T2` for client. Do filter by `STRFTIME('%Y', T3.birth_date)` between '1974' and '1976' instead of `T2.birth_date` between date literals. Do filter by `T1.k_symbol = 'SIPO'` instead of `'HOME PAYMENT'`. The amended query now correctly counts transactions with the specified criteria."
        ],
        "rules": [
            "Man and male refers to gender = 'M'; 'SIPO' stands for household payment"
        ]
    },
    "960": {
        "sql": [
            "SELECT AVG(CAST(fastestLapSpeed AS REAL)) AS average_fastest_lap_speed\nFROM results\nJOIN races ON results.raceId = races.raceId\nWHERE races.year = 2009 AND races.name = 'Spanish Grand Prix';"
        ],
        "question": "What is the average of fastest lap speed in the 2009 Spanish Grand Prix race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "amends": [],
        "rules": [
            "Spanish Grand Prix is the name of race refers to name = 'Spanish Grand Prix'; average fastest lap speed refers to avg(fastestLapSpeed);"
        ]
    },
    "558": {
        "sql": [
            "SELECT COUNT(*) AS vote_count FROM votes WHERE UserId = 58 AND DATE(CreationDate) = '2010-07-19';"
        ],
        "question": "How many votes did the user No.58 take on 2010/7/19?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19'",
        "amends": [],
        "rules": [
            "user no. 58 refers to UserId = 58; on 2010/7/19 refers to CreationDate = '2010-07-19'"
        ]
    },
    "1505": {
        "sql": [
            "SELECT COUNT(DISTINCT c.CustomerID) \nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Currency = 'EUR' AND ym.Consumption > 1000;",
            "SELECT COUNT(*)\nFROM yearmonth T1\nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Currency = 'EUR'\nAND T1.Consumption > 1000.00"
        ],
        "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
        "amends": [
            "Do use `COUNT(*)` instead of `COUNT(DISTINCT c.CustomerID)` to count all matching rows rather than distinct customer IDs. Do reference the tables as `T1` for yearmonth and `T2` for customers instead of `c` and `ym` aliases. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do place the join condition `T1.CustomerID = T2.CustomerID` instead of `c.CustomerID = ym.CustomerID` with consistent table reference order. Do specify the consumption value as `1000.00` instead of `1000` for explicit decimal precision. The amended query now correctly counts all matching records between customers with EUR currency and yearmonth entries with consumption over 1000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Pays in euro = Currency = 'EUR'."
        ]
    },
    "1167": {
        "sql": [
            "SELECT COUNT(DISTINCT L.ID) / 12.0 AS average_male_patients_per_month\nFROM Laboratory L\nJOIN Patient P ON L.ID = P.ID\nWHERE P.SEX = 'M'\nAND L.Date BETWEEN '1998-01-01' AND '1998-12-31';",
            "SELECT CAST(COUNT(T1.ID) AS REAL) / 12\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'male' AND STRFTIME('%Y', T2.Date) = '1998'",
            "SELECT CAST(COUNT(T1.ID) AS REAL) / 12\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND STRFTIME('%Y', T2.Date) = '1998'"
        ],
        "question": "For the year that concluded on December 31, 1998, how many male patients on average were tested in the lab each month?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T1.ID) AS REAL) / 12 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.Date) = '1998' AND T1.SEX = 'M'",
        "amends": [
            "Do use `CAST(COUNT(T1.ID) AS REAL)` instead of `COUNT(DISTINCT L.ID)` to count all matching records without deduplication and ensure real number division. Do reference `Patient AS T1` as the primary table instead of `Laboratory L` and join with `Laboratory AS T2` instead of the reverse join direction. Do use `STRFTIME('%Y', T2.Date) = '1998'` instead of `BETWEEN '1998-01-01' AND '1998-12-31'` for proper year extraction from the date field. Do remove the division by `12.0` decimal literal and instead use integer `12` since the CAST to REAL handles the numeric conversion. Do eliminate the redundant alias `average_male_patients_per_month` instead of keeping it. The amended query now correctly calculates the average monthly count of male patients with laboratory records in 1998 without overcounting due to DISTINCT and with proper date handling.",
            "Do use `T1.SEX = 'M'` instead of `T1.SEX = 'male'` for the gender filter. Do keep the same `SELECT` clause with `CAST(COUNT(T1.ID) AS REAL) / 12` and maintain the `INNER JOIN` on `T1.ID = T2.ID`. Do preserve the `WHERE` clause with `STRFTIME('%Y', T2.Date) = '1998'` but ensure the gender condition uses the correct value format. The amended query now correctly filters for male patients using the appropriate 'M' value instead of 'male', matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "the year that concluded on December 31, 1998 refers to Date BETWEEN '1998-01-01' AND '1998-12-31'; male refers to SEX = 'M'; calculation = DIVIDE(COUNT(ID), 12)"
        ]
    }
}