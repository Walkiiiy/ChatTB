{
    "1053": {
        "sql": [
            "SELECT t.team_short_name\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE ta.chanceCreationPassingClass = 'Risky';"
        ],
        "question": "List the football teams that has a chance creation passing class of Risky. Inidcate its short name only.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Risky'",
        "amends": [],
        "rules": [
            "chance creation passing class refers to chanceCreationPassingClass; chanceCreationPassingClass = 'Risky'; short name refers to team_short_name;"
        ]
    },
    "651": {
        "sql": [
            "SELECT p2.Title AS RelatedPostTitle\nFROM posts p1\nJOIN postLinks pl ON p1.Id = pl.PostId\nJOIN posts p2 ON pl.RelatedPostId = p2.Id\nWHERE p1.Title = 'How to tell if something happened in a data set which monitors a value over time';"
        ],
        "question": "Provide the related post title of \"How to tell if something happened in a data set which monitors a value over time\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Title FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN posts AS T3 ON T1.RelatedPostId = T3.Id WHERE T2.Title = 'How to tell if something happened in a data set which monitors a value over time'",
        "amends": [],
        "rules": []
    },
    "718": {
        "sql": [
            "SELECT COUNT(DISTINCT hero_id) \nFROM hero_power \nWHERE power_id = (SELECT id FROM superpower WHERE power_name = 'Super Strength');"
        ],
        "question": "How many superheroes have the super power of \"Super Strength\"?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Super Strength'",
        "amends": [],
        "rules": [
            "super power of \"Super Strength\" refers to power_name = 'Super Strength'"
        ]
    },
    "505": {
        "sql": [
            "SELECT st.translation FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE st.language = 'Chinese Simplified' AND s.name = 'Mirrodin';"
        ],
        "question": "Show the Simplified Chinese translation of the name of the set \"Mirrodin\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT code FROM sets WHERE name = 'Mirrodin' ) AND language = 'Chinese Simplified'",
        "amends": [],
        "rules": [
            "Simplified Chinese translation refers to language = 'Chinese Simplified'; name of the set \"Mirrodin\" refers to name = 'Mirrodin'"
        ]
    },
    "171": {
        "sql": [
            "SELECT \n    (SELECT SUM(A16) FROM district WHERE A3 = 'North Bohemia') - \n    (SELECT SUM(A16) FROM district WHERE A3 = 'East Bohemia') AS crime_difference;",
            "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district WHERE A16 IS NOT NULL;"
        ],
        "question": "What was the difference in the number of crimes committed in East and North Bohemia in 1996?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district",
        "amends": [
            "Do use a single query with conditional aggregation using `IIF` functions instead of separate subqueries for each region. Do calculate the difference as `SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0))` instead of subtracting North Bohemia from East Bohemia in reverse order. Do handle case sensitivity by using lowercase region names `'east Bohemia'` and `'north Bohemia'` instead of title case `'North Bohemia'` and `'East Bohemia'`. Do remove the `AS crime_difference` alias instead of keeping it since the right query doesn't include an explicit alias. The amended query now correctly calculates the crime difference between east and north Bohemia regions in a single table scan with proper case handling."
        ],
        "rules": [
            "Difference in no. of committed crimes between 2 regions = Total no. of committed crimes in 1996 in north Bohemia - Total no. of committed crimes in 1996 in e ast Bohemia. A3 refers to region. Data about no. of committed crimes 1996 appears in A16"
        ]
    },
    "413": {
        "sql": [
            "SELECT COUNT(DISTINCT c.id) \nFROM cards c \nJOIN rulings r ON c.uuid = r.uuid \nWHERE c.rarity = 'rare' AND r.date = '2007-02-01';"
        ],
        "question": "How many cards with print rarity have ruling text printed on 01/02/2007?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'rare' AND T2.date = '2007-02-01'",
        "amends": [],
        "rules": [
            "with print rarity refers to rarity = 'rare'; on 01/02/2007 refers to date = '2007-02-01'"
        ]
    },
    "105": {
        "sql": [
            "SELECT a.district_id\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.date = '1994-08-25';"
        ],
        "question": "There was a loan approved in 1994/8/25, where was that account opened, give the district Id of the branch.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'",
        "amends": [],
        "rules": []
    },
    "1529": {
        "sql": [
            "-- Total amount spent by customer 38508 at gas stations\nSELECT SUM(Amount * Price) AS TotalAmountSpent\nFROM transactions_1k\nWHERE CustomerID = 38508;\n\n-- Amount spent by customer 38508 in January 2012\nSELECT SUM(Amount * Price) AS January2012AmountSpent\nFROM transactions_1k\nWHERE CustomerID = 38508 AND Date LIKE '201201%';",
            "SELECT \n    SUM(T1.Price) AS TotalAmountSpent,\n    SUM(IIF(T3.Date = '201201', T1.Price, 0)) AS January2012Spending\nFROM \n    transactions_1k T1\nJOIN \n    gasstations T2 ON T1.GasStationID = T2.GasStationID\nJOIN \n    yearmonth T3 ON T1.CustomerID = T3.CustomerID\nWHERE \n    T1.CustomerID = '38508'"
        ],
        "question": "What is the amount spent by customer \"38508\" at the gas stations? How much had the customer spent in January 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.Price) , SUM(IIF(T3.Date = '201201', T1.Price, 0)) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.CustomerID = '38508'",
        "amends": [
            "Do join `gasstations` and `yearmonth` tables instead of querying `transactions_1k` alone. Do use `SUM(T1.Price)` instead of `SUM(Amount * Price)` for the total amount calculation. Do add `IIF(T3.Date = '201201', T1.Price, 0)` instead of a separate query for January 2012 spending. Do filter by `T1.CustomerID = '38508'` with string comparison instead of numeric comparison. Do remove the `Amount` multiplication and instead use `Price` directly in the aggregation. The amended query now correctly calculates both total spending and January 2012 spending in a single query with proper table joins."
        ],
        "rules": [
            "January 2012 refers to the Date value = '201201'"
        ]
    },
    "1158": {
        "sql": [
            "SELECT DISTINCT P.ID, P.SEX, P.Birthday, P.Description, P.`First Date`, P.Admission, P.Diagnosis\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE strftime('%Y', P.Birthday) = '1937'\nAND L.`T-CHO` >= 250;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.Birthday) = '1937'\nAND T2.`T-CHO` IS NOT NULL\nAND (T2.`T-CHO` < 120 OR T2.`T-CHO` > 200);",
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE strftime('%Y', T1.Birthday) = '1937'\nAND T2.\"T-CHO\" >= 250"
        ],
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "amends": [
            "Do select only `T1.ID` instead of multiple columns including `P.ID`, `P.SEX`, `P.Birthday`, `P.Description`, `P.First Date`, `P.Admission`, and `P.Diagnosis`. Do use table aliases `T1` and `T2` instead of `P` and `L`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T1.Birthday` instead of `P.Birthday` in the STRFTIME function. Do reference `T2.T-CHO` instead of `L.T-CHO` in the filter condition. The amended query now correctly returns only patient IDs matching the specified criteria.",
            "Do add `DISTINCT` to the SELECT list instead of omitting it. Do change the WHERE condition from `T2.\"T-CHO\" IS NOT NULL AND (T2.\"T-CHO\" < 120 OR T2.\"T-CHO\" > 200)` to `T2.\"T-CHO\" >= 250` instead of the previous range-based filtering. The amended query now correctly returns distinct patient IDs with high cholesterol values rather than those outside the normal range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "who were born in 1937 refers to year(birthday) = '1937'; total cholesterol was beyond the normal range refers to `T-CHO` > = '250'"
        ]
    },
    "944": {
        "sql": [
            "WITH race_info AS (\n    SELECT raceId FROM races \n    WHERE year = 2008 AND name = 'Australian Grand Prix'\n),\nchampion_time AS (\n    SELECT time FROM results \n    WHERE raceId = (SELECT raceId FROM race_info) AND position = 1\n),\nlast_driver_time AS (\n    SELECT time FROM results \n    WHERE raceId = (SELECT raceId FROM race_info) AND time IS NOT NULL\n    ORDER BY time DESC LIMIT 1\n)\nSELECT \n    ((julianday((SELECT time FROM last_driver_time)) - julianday((SELECT time FROM champion_time))) / \n    julianday((SELECT time FROM last_driver_time)) * 100 AS percentage_faster\nFROM champion_time, last_driver_time;",
            "WITH time_in_seconds AS (\n  SELECT \n    r.raceId,\n    r.driverId,\n    r.positionOrder,\n    CASE \n      WHEN r.time LIKE '%:%:%' THEN \n        (CAST(SUBSTR(r.time, 1, 2) AS REAL) * 3600 + \n        (CAST(SUBSTR(r.time, 4, 2) AS REAL) * 60 + \n        CAST(SUBSTR(r.time, 7) AS REAL)\n      WHEN r.time LIKE '%:%' THEN \n        (CAST(SUBSTR(r.time, 1, 2) AS REAL) * 60 + \n        CAST(SUBSTR(r.time, 4) AS REAL)\n      ELSE CAST(r.time AS REAL)\n    END AS time_seconds\n  FROM results r\n  INNER JOIN races rc ON r.raceId = rc.raceId\n  WHERE rc.year = 2008 \n    AND rc.name = 'Australian Grand Prix'\n    AND r.time IS NOT NULL\n)\nSELECT \n  (MAX(t2.time_seconds) * 100.0 / (MIN(t1.time_seconds) + MAX(t2.time_seconds)) AS percentage_faster\nFROM time_in_seconds t1\nCROSS JOIN time_in_seconds t2\nWHERE t1.positionOrder = 1\n  AND t2.positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds);",
            "WITH time_in_seconds AS (\n    SELECT \n        T1.positionOrder,\n        CASE \n            WHEN T1.positionOrder = 1 THEN \n                CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600 + \n                CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60 + \n                CAST(SUBSTR(T1.time, 6) AS REAL)\n            ELSE \n                CAST(SUBSTR(T1.time, 2) AS REAL)\n        END AS time_seconds\n    FROM results T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T2.year = 2008 \n    AND T2.name = 'Australian Grand Prix'\n    AND T1.time IS NOT NULL\n),\nchampion_time AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = 1\n),\nlast_driver_incremental AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds)\n)\nSELECT \n    ((SELECT time_seconds FROM last_driver_incremental) * 100.0) / \n    ((SELECT time_seconds FROM champion_time) + (SELECT time_seconds FROM last_driver_incremental)) \n    AS percentage_faster"
        ],
        "question": "How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "WITH time_in_seconds AS ( SELECT T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6) AS REAL) ELSE CAST(SUBSTR(T1.time, 2) AS REAL) END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL AND T2.year = 2008 ), champion_time AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = 1), last_driver_incremental AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds) ) SELECT (CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)",
        "amends": [
            "Do use a CTE `time_in_seconds` to convert time strings to numeric seconds instead of relying on `julianday` functions. Do add proper `positionOrder` filtering with `WHERE positionOrder = 1` for champion instead of `position = 1`. Do calculate last driver using `MAX(positionOrder)` instead of `ORDER BY time DESC LIMIT 1`. Do convert time format with `SUBSTR` and arithmetic operations instead of date functions. Do fix the percentage calculation formula to use `(last_driver_time * 100) / (champion_time + last_driver_time)` instead of the incorrect `julianday` difference division. Do add explicit `INNER JOIN` between `results` and `races` with `ON T1.raceId = T2.raceId` instead of separate subqueries. Do handle both time formats with `CASE` statement instead of assuming single format. The amended query now correctly calculates the percentage difference in race times.",
            "Do use `T1.positionOrder` in the CTE SELECT list instead of omitting it, and do change the time parsing logic to handle `positionOrder = 1` with `SUBSTR(T1.time, 1, 1)` for hours, `SUBSTR(T1.time, 3, 2)` for minutes, and `SUBSTR(T1.time, 6)` for seconds instead of the general colon-based parsing, while using `CAST(SUBSTR(T1.time, 2) AS REAL)` for other positions instead of the original approach. Do remove `r.raceId` and `r.driverId` from the CTE SELECT list instead of including them. Do change table aliases to `T1` and `T2` instead of `r` and `rc`. Do restructure the query with separate CTEs `champion_time` and `last_driver_incremental` instead of a single CTE with CROSS JOIN. Do use subqueries `(SELECT time_seconds FROM last_driver_incremental)` and `(SELECT time_seconds FROM champion_time)` in the final calculation instead of the MAX/MIN approach with CROSS JOIN. Do change the percentage calculation to `(last_driver_time * 100) / (champion_time + last_driver_time)` instead of `(MAX(t2.time_seconds) * 100.0 / (MIN(t1.time_seconds) + MAX(t2.time_seconds))`. The amended query now correctly isolates the champion's time and last driver's time in separate CTEs and performs the accurate percentage calculation."
        ],
        "rules": [
            "how much faster in percentage = divide(subtract(incremental time, champion time), last_driver time) * 100; last driver finished time = incremental time + champion time; only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null"
        ]
    },
    "382": {
        "sql": [
            "SELECT DISTINCT c.* FROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.availability = 'paper' AND fd.language = 'Japanese';",
            "SELECT T1.name\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.availability = 'paper'\nAND T2.language = 'Japanese'"
        ],
        "question": "What are the cards that only available in paper and Japanese language?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'Japanese'",
        "amends": [
            "Do select only `T1.name` instead of `c.*` and remove `DISTINCT` instead of keeping it. Do use `INNER JOIN` instead of `JOIN` while maintaining the same join condition `T1.uuid = T2.uuid`. Do keep the same `WHERE` filters for `T1.availability = 'paper'` and `T2.language = 'Japanese'` but use table aliases `T1` and `T2` instead of `c` and `fd`. The amended query now correctly returns only Japanese paper card names without duplicates, matching the intended behavior."
        ],
        "rules": [
            "available in paper refers to availability = 'paper'; 'Japanese is the language;"
        ]
    },
    "605": {
        "sql": [
            "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Announcer';",
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Announcer';"
        ],
        "question": "How many users obtained the \"Announcer\" badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE Name = 'Announcer'",
        "amends": [
            "Do count `id` instead of `DISTINCT UserId` to count all badge instances rather than unique users, since multiple users can have the same badge type. Do remove the `DISTINCT` modifier instead of keeping it to avoid unnecessary deduplication when counting total badge occurrences. The amended query now correctly counts all Announcer badges rather than unique users who have them, matching the intended behavior."
        ],
        "rules": [
            "\"Announcer\" is the Name of badge; user refers to UserId"
        ]
    },
    "1139": {
        "sql": [
            "SELECT home_team_goal, away_team_goal \nFROM Match \nWHERE date LIKE '2008-09-24%' \nAND league_id = (SELECT id FROM League WHERE name = 'Belgium Jupiler League');"
        ],
        "question": "What was the final score for the match on September 24, 2008, in the Belgian Jupiler League between the home team and the away team?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.home_team_goal, t2.away_team_goal FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND t2.`date` LIKE '2008-09-24%'",
        "amends": [],
        "rules": [
            "September 24, 2008 refers to date like '2008-09-24%'; in the Belgian Jupiler League refers to League.name = 'Belgium Jupiler League'; final score for home team refers to home_team_goal; final score for away team refers to away_team_goal"
        ]
    },
    "634": {
        "sql": [
            "WITH user_view_counts AS (\n    SELECT \n        u.DisplayName,\n        SUM(p.ViewCount) AS total_views\n    FROM \n        users u\n    JOIN \n        posts p ON u.Id = p.OwnerUserId\n    WHERE \n        u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')\n    GROUP BY \n        u.DisplayName\n)\nSELECT \n    DisplayName,\n    total_views\nFROM \n    user_view_counts\nORDER BY \n    total_views DESC\nLIMIT 1;",
            "SELECT \n    T1.DisplayName,\n    SUM(T3.ViewCount) AS total_views\nFROM \n    users T1\nINNER JOIN \n    postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN \n    posts T3 ON T2.PostId = T3.Id\nWHERE \n    T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder'\nGROUP BY \n    T1.DisplayName\nORDER BY \n    total_views DESC\nLIMIT 1",
            "SELECT T1.DisplayName\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nWHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder'\nGROUP BY T1.DisplayName\nORDER BY SUM(T3.ViewCount) DESC\nLIMIT 1"
        ],
        "question": "Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1",
        "amends": [
            "Do join `postHistory` and `posts` tables instead of directly joining `users` with `posts`. Do use `INNER JOIN` on `T1.Id = T2.UserId` and `T2.PostId = T3.Id` instead of `JOIN` on `u.Id = p.OwnerUserId`. Do change the WHERE condition to use `OR` logic with `T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder'` instead of `IN` clause. Do aggregate with `SUM(T3.ViewCount)` in the ORDER BY instead of calculating total_views in a CTE. Do remove the CTE structure and perform aggregation directly in the main query instead of using a separate WITH clause. Do reference `T3.ViewCount` for summation instead of `p.ViewCount`. The amended query now correctly calculates view counts through the postHistory relationship and matches the RIGHT_SQL's behavior.",
            "Do remove `SUM(T3.ViewCount) AS total_views` from the SELECT list instead of including it, and do move the `SUM(T3.ViewCount)` aggregate function to the ORDER BY clause instead of keeping it in SELECT. Do maintain the same FROM sources with `INNER JOIN` on `T1.Id = T2.UserId` and `INNER JOIN` on `T2.PostId = T3.Id`, and preserve the WHERE filter on `T1.DisplayName` with OR conditions. Do keep the GROUP BY on `T1.DisplayName` and LIMIT 1, but do order by `SUM(T3.ViewCount) DESC` instead of by the removed alias `total_views`. The amended query now correctly returns only the display name while ordering by the sum of view counts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Has higher popularity means the post has higher view count ; calculation = MAX(SUM(ViewCount)) where DisplayName = 'Harvey Motulsky' OR DisplayName = 'Noah Snyder';"
        ]
    },
    "1151": {
        "sql": [
            "SELECT \n    ROUND((COUNT(CASE WHEN Admission = '+' THEN 1 END) * 100.0 / COUNT(*)), 2) AS Percentage_Inpatient\nFROM \n    Patient\nWHERE \n    strftime('%Y', Birthday) BETWEEN '1930' AND '1940';",
            "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100 / COUNT(*) AS Percentage_Inpatient\nFROM \n    Patient\nWHERE \n    Birthday BETWEEN '1930-01-01' AND '1940-12-31'",
            "SELECT SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100 / COUNT(*) FROM Patient WHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940'",
            "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940'"
        ],
        "question": "For patient born between Year 1930 to 1940, how many percent of them were inpatient?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940'",
        "amends": [
            "Do use `SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN Admission = '+' THEN 1 END)` to properly count positive admissions. Do cast the sum to `REAL` instead of using `ROUND` to ensure floating-point division. Do remove the `ROUND` function and alias `Percentage_Inpatient` instead of keeping them. Do use direct arithmetic division `* 100 / COUNT(*)` instead of `* 100.0 / COUNT(*)` with explicit rounding. The amended query now correctly calculates the percentage without unnecessary rounding and matches the right SQL's behavior.",
            "Do cast the SUM result as `REAL` instead of using integer division, and do use `STRFTIME('%Y', Birthday)` to extract the year instead of comparing full date ranges with `BETWEEN '1930-01-01' AND '1940-12-31'`, which would miss patients born in 1940 after December 31st. Do remove the alias `Percentage_Inpatient` instead of keeping it. The amended query now correctly calculates the percentage using floating-point division and accurately filters patients born in any year between 1930 and 1940 inclusive, matching the RIGHT_SQL's behavior.",
            "Do add `CAST(SUM(...) AS REAL)` instead of using integer division which truncates decimal results, ensuring proper percentage calculation with fractional values instead of integer truncation. The amended query now correctly handles floating-point division to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "patient born between Year 1930 to 1940 refers to year(Birthday) BETWEEN '1930-01-01' AND '1940-12-31'; inpatient refers to Admission = '+'"
        ]
    },
    "959": {
        "sql": [
            "SELECT r.fastestLap\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN driverStandings ds ON r.driverId = ds.driverId AND r.raceId = ds.raceId\nWHERE rc.year = 2009 AND ds.position = 1\nORDER BY r.fastestLap ASC\nLIMIT 1;",
            "SELECT T1.fastestLap \nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2009 \nAND T1.time LIKE '_:%:__.___'"
        ],
        "question": "What is the fastest lap number of the champion in 2009?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "amends": [
            "Do remove the `JOIN` on `driverStandings` table and its `ds.position = 1` condition instead of including them. Do change the `WHERE` filter to use `T1.time LIKE '_:%:__.___'` instead of the removed driver standings condition. Do keep the `rc.year = 2009` filter but reference it as `T2.year = 2009` instead. Do remove the `ORDER BY r.fastestLap ASC` and `LIMIT 1` clauses instead of keeping them, as the query now filters for specific time patterns rather than finding the minimum fastest lap. The amended query now correctly filters for results from 2009 with specific time format patterns rather than attempting to find the fastest lap among championship leaders."
        ],
        "rules": [
            "in 2009 refers to year = 2009; Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\""
        ]
    },
    "1275": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS MalePatientsWithNormalLevels\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M'\nAND L.CENTROMEA IN ('-', '+-')\nAND L.SSB IN ('-', '+-');",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.CENTROMEA IN ('negative', '0')\nAND T2.SSB IN ('negative', '0')\nAND T1.SEX = 'M'"
        ],
        "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(DISTINCT P.ID) AS MalePatientsWithNormalLevels` to remove the unnecessary alias. Do reference `T1.ID` and `T2.ID` instead of `P.ID` and `L.ID` with table aliases. Do change the join condition to `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of `JOIN Laboratory L ON P.ID = L.ID` to use explicit INNER JOIN and proper aliasing. Do update the CENTROMEA filter to `T2.CENTROMEA IN ('negative', '0')` instead of `L.CENTROMEA IN ('-', '+-')` to use the correct categorical values. Do update the SSB filter to `T2.SSB IN ('negative', '0')` instead of `L.SSB IN ('-', '+-')` to match the proper value encoding. Do maintain the sex filter as `T1.SEX = 'M'` instead of `P.SEX = 'M'` with the updated alias. The amended query now correctly counts male patients with laboratory results categorized as negative or zero instead of using placeholder symbols, matching the intended logic."
        ],
        "rules": [
            "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;"
        ]
    },
    "866": {
        "sql": [
            "SELECT d.url \nFROM drivers d \nJOIN lapTimes l ON d.driverId = l.driverId \nWHERE l.raceId = 161 AND l.time = '0:01:27';",
            "SELECT DISTINCT T2.forename, T2.surname, T2.url\nFROM lapTimes AS T1\nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 161 AND T1.time LIKE '1:27%'"
        ],
        "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
        "amends": [
            "Do select `T2.forename`, `T2.surname`, and `T2.url` instead of only `d.url`. Do add `DISTINCT` to eliminate duplicate rows instead of omitting it. Do use `INNER JOIN` with `drivers AS T2` and `lapTimes AS T1` instead of `JOIN drivers d` and `lapTimes l`. Do change the join condition to `T2.driverId = T1.driverId` instead of `d.driverId = l.driverId`. Do use `LIKE '1:27%'` for pattern matching instead of exact match `= '0:01:27'`. The amended query now correctly retrieves distinct driver names and URLs for lap times starting with '1:27' in race 161, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "player and driver are synonyms; the lap time of 0:0M:SS refers to lapTime.time LIKE 'M:SS%';race number refers to raceId; introduction website of the drivers refers to url;"
        ]
    },
    "826": {
        "sql": [
            "SELECT s.superhero_name, s.weight_kg\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'DC Comics'\nAND s.weight_kg = (SELECT MAX(weight_kg) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'DC Comics'));",
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'DC Comics'\nORDER BY T1.weight_kg DESC\nLIMIT 1;"
        ],
        "question": "Identify the heaviest superhero in DC Comics.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "amends": [
            "Do select only `superhero_name` instead of including `weight_kg` in the SELECT list. Do use `INNER JOIN` with table aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do remove the subquery that finds maximum weight and instead use `ORDER BY T1.weight_kg DESC LIMIT 1` to get the heaviest superhero directly. Do omit the weight comparison condition in WHERE and instead handle the ranking through the ORDER BY and LIMIT clause. The amended query now correctly returns only the name of the heaviest DC Comics superhero by sorting and limiting rather than using a complex subquery approach."
        ],
        "rules": [
            "heaviest refers to MAX(weight_kg); DC Comics refers to publisher_name = 'DC Comics'; superhero refers to superhero_name;"
        ]
    },
    "415": {
        "sql": [
            "SELECT (COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'commander' AND l.status = 'legal';",
            "SELECT \n    (SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    cards T1\nJOIN \n    legalities T2 ON T1.uuid = T2.uuid\nWHERE \n    T2.format = 'commander' \n    AND T2.status = 'Legal';"
        ],
        "question": "What percentage of cards with format commander and legal status do not have a content warning?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END)` to properly count only true cases. Do add explicit `ELSE 0` instead of omitting it to ensure correct summation. Do cast the sum as `REAL` instead of using decimal notation for proper floating-point division. Do reference `T1.id` in `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do use table aliases `T1` and `T2` instead of single letters for clarity. Do capitalize `'Legal'` instead of using lowercase `'legal'` to match the actual data values. The amended query now correctly calculates the percentage by properly handling the case logic and ensuring accurate floating-point division."
        ],
        "rules": [
            "do not have a content warning refers to hasContentWarning = 0; percentage refers to DIVIDE(COUNT(hasContentWarning = 0),COUNT(ID))*100 where format = 'commander' AND Status = 'legal';"
        ]
    },
    "452": {
        "sql": [
            "SELECT name FROM cards WHERE isTextless = 0;"
        ],
        "question": "Please list the names of the cards that have a text box.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE isTextless = 0",
        "amends": [],
        "rules": [
            "have a text box refers to isTextless = 0"
        ]
    },
    "1470": {
        "sql": [
            "SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium';"
        ],
        "question": "How many gas stations in CZE has Premium gas?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium'",
        "amends": [],
        "rules": []
    },
    "755": {
        "sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Demi-God'\nLIMIT 5;"
        ],
        "question": "List down at least five full name of Demi-God superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Demi-God'",
        "amends": [],
        "rules": [
            "Demi-God superheroes refers to race = 'Demi-God'"
        ]
    },
    "630": {
        "sql": [
            "SELECT DISTINCT p.Tags\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'John Salvatier';"
        ],
        "question": "What is the name of tags used by John Salvatier's?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'John Salvatier'",
        "amends": [],
        "rules": [
            "DisplayName = 'John Salvatier';"
        ]
    },
    "1252": {
        "sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.IGG > 900 AND l.IGG < 2000 AND e.Symptoms IS NOT NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nJOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.IGG BETWEEN 900 AND 2000\nAND T3.Symptoms IS NOT NULL"
        ],
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT p.ID)` to count all matching rows rather than distinct patient IDs. Do use `T2.IGG BETWEEN 900 AND 2000` instead of separate `l.IGG > 900 AND l.IGG < 2000` conditions for inclusive range checking. Do join `Examination AS T3 ON T3.ID = T2.ID` instead of `ON p.ID = e.ID` to properly connect the examination to the laboratory record rather than directly to the patient. Do remove the unnecessary `DISTINCT` modifier from the count instead of keeping it. The amended query now correctly matches the behavior of counting patients with laboratory results in the specified IGG range who have associated examination records with symptoms present."
        ],
        "rules": [
            "normal Ig G level refers to IGG > 900 and IGG < 2000; have symptoms refers to Symptoms IS NOT NULL;"
        ]
    },
    "338": {
        "sql": [
            "SELECT DISTINCT a.atom_id\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = 'TR012' AND a.element = 'c' AND b.bond_type = ' = ';",
            "SELECT T1.atom_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T2.molecule_id = 'TR012'\nAND T3.bond_type = '='\nAND T1.element = 'c'"
        ],
        "question": "What is the atom ID of double bonded carbon in TR012 molecule?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T2.molecule_id = 'TR012' AND T3.bond_type = '=' AND T1.element = 'c'",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it. Do change the `SELECT` list to reference `T1.atom_id` instead of `a.atom_id`. Do replace the complex join structure with `INNER JOIN molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of joining through `connected` and `bond` tables. Do add `INNER JOIN bond AS T3` on `T2.molecule_id = T3.molecule_id` instead of joining through `connected`. Do change the `WHERE` condition to use `T2.molecule_id = 'TR012'` instead of `m.label = 'TR012'`. Do modify the bond type filter to use `T3.bond_type = '='` instead of `b.bond_type = ' = '` (removing the extra space). Do keep the element filter as `T1.element = 'c'` but with proper table alias. The amended query now correctly filters atoms by molecule ID directly rather than through a complex join path, ensuring proper relationship between molecules and bonds."
        ],
        "rules": [
            "carbon refers to element = 'c'; double bond refers to bond_type = ' = ';"
        ]
    },
    "772": {
        "sql": [
            "SELECT \n    eye_colour.colour AS eyes, \n    hair_colour.colour AS hair, \n    skin_colour.colour AS skin\nFROM \n    superhero\nJOIN \n    gender ON superhero.gender_id = gender.id\nJOIN \n    publisher ON superhero.publisher_id = publisher.id\nJOIN \n    colour AS eye_colour ON superhero.eye_colour_id = eye_colour.id\nJOIN \n    colour AS hair_colour ON superhero.hair_colour_id = hair_colour.id\nJOIN \n    colour AS skin_colour ON superhero.skin_colour_id = skin_colour.id\nWHERE \n    gender.gender = 'Female'\n    AND publisher.publisher_name = 'Dark Horse Comics';",
            "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T2.id = T1.publisher_id\nINNER JOIN gender AS T3 ON T3.id = T1.gender_id\nWHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female';"
        ],
        "question": "List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'",
        "amends": [
            "Do select `T1.eye_colour_id`, `T1.hair_colour_id`, and `T1.skin_colour_id` instead of joining colour tables to get `eyes`, `hair`, and `skin` aliases. Do join `publisher AS T2` on `T2.id = T1.publisher_id` instead of joining `publisher` without table aliases. Do join `gender AS T3` on `T3.id = T1.gender_id` instead of joining `gender` without table aliases. Do remove all colour table joins (`eye_colour`, `hair_colour`, `skin_colour`) instead of including them unnecessarily. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for clarity. Do place both filter conditions in the `WHERE` clause instead of keeping them separate. The amended query now correctly retrieves the ID values directly from the superhero table without unnecessary joins to colour tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "eyes refers to eye_colour_id; hair refers to hair_colour_id; skin colour refers to skin_colour_id; female superheroes refers to gender = 'Female'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';"
        ]
    },
    "1523": {
        "sql": [
            "SELECT g.Country \nFROM transactions_1k t \nJOIN gasstations g ON t.GasStationID = g.GasStationID \nWHERE t.CardID = 667467;"
        ],
        "question": "Which country was the card owner of No.667467 in?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.CardID = '667467'",
        "amends": [],
        "rules": []
    },
    "58": {
        "sql": [
            "SELECT School, Phone, Ext FROM schools WHERE Zip = '95203-3704';",
            "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704'"
        ],
        "question": "What is the phone number and extension number for the school with the zip code 95203-3704? Indicate the school's name.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704'",
        "amends": [
            "Do reorder the SELECT list to `Phone, Ext, School` instead of `School, Phone, Ext` while maintaining the same WHERE filter on `Zip = '95203-3704'` without any changes to the FROM clause, join conditions, aggregates, window functions, subqueries, or sorting logic. The amended query now matches RIGHT_SQL's behavior by presenting the columns in the specified order while preserving the identical filtering and data retrieval logic."
        ],
        "rules": []
    },
    "799": {
        "sql": [
            "SELECT COUNT(*) FROM superhero WHERE publisher_id IS NULL;",
            "SELECT COUNT(T1.id) \nFROM superhero T1 \nINNER JOIN publisher T2 ON T1.publisher_id = T2.id \nWHERE T2.id = 1"
        ],
        "question": "How many superheroes didn't have any publisher?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.id = 1",
        "amends": [
            "Do add an `INNER JOIN` on `publisher` with predicate `T1.publisher_id = T2.id` instead of querying `superhero` alone. Do change the count expression to `COUNT(T1.id)` instead of `COUNT(*)`. Do add a `WHERE` filter for `T2.id = 1` instead of checking for `publisher_id IS NULL`. Do remove the null check condition entirely instead of including it. The amended query now correctly counts superheroes from a specific publisher rather than those without any publisher association."
        ],
        "rules": [
            "didn't have any publisher refers to publisher.id = 1;"
        ]
    },
    "867": {
        "sql": [
            "SELECT d.nationality\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE r.raceId = 933\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;"
        ],
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [],
        "rules": [
            "fastest lap speed refers to MAX(fastestLapSpeed);"
        ]
    },
    "251": {
        "sql": [
            "SELECT a.element, COUNT(a.element) AS element_count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+'\nGROUP BY a.element\nORDER BY element_count ASC\nLIMIT 1;",
            "SELECT T.element\nFROM (\n    SELECT T2.element, COUNT(DISTINCT T2.molecule_id) AS molecule_count\n    FROM atom AS T2\n    INNER JOIN molecule AS T1 ON T2.molecule_id = T1.molecule_id\n    WHERE T1.label = 'carcinogenic'\n    GROUP BY T2.element\n    ORDER BY molecule_count ASC\n    LIMIT 1\n) AS T",
            "SELECT t.element\nFROM (\n    SELECT T2.element, COUNT(DISTINCT T2.molecule_id) \n    FROM molecule AS T1\n    INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T1.label = '+'\n    GROUP BY T2.element\n    ORDER BY COUNT(DISTINCT T2.molecule_id)\n    LIMIT 1\n) AS t"
        ],
        "question": "What is the least common element of all carcinogenic molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "amends": [
            "Do select only `T.element` instead of both `a.element` and `COUNT(a.element)`. Do use a subquery instead of a simple query structure. Do add table aliases `T1` and `T2` instead of no aliases. Do use `INNER JOIN` with explicit keyword instead of implicit `JOIN`. Do count `DISTINCT T2.molecule_id` instead of counting `a.element`. Do group by `T2.element` instead of `a.element`. Do order by `COUNT(DISTINCT T2.molecule_id)` instead of `element_count ASC`. Do remove the explicit alias `element_count` from the output. The amended query now correctly counts distinct molecules per element rather than total atoms, matching the intended behavior.",
            "Do remove the alias `molecule_count` from the COUNT expression instead of keeping it. Do change the WHERE filter to `T1.label = '+'` instead of `T1.label = 'carcinogenic'`. Do use the COUNT expression directly in ORDER BY instead of referencing the removed alias. Do remove the ASC keyword from ORDER BY instead of specifying ascending order explicitly. Do use lowercase `t` as the subquery alias instead of uppercase `T`. The amended query now correctly counts molecules with '+' label and orders by the count directly without an alias."
        ],
        "rules": [
            "label = '+' mean molecules are carcinogenic"
        ]
    },
    "8": {
        "sql": [
            "SELECT s.NumTstTakr\nFROM satscores s\nJOIN frpm f ON s.cds = f.CDSCode\nWHERE f.\"FRPM Count (K-12)\" = (SELECT MAX(\"FRPM Count (K-12)\") FROM frpm);"
        ],
        "question": "What is the number of SAT test takers of the schools with the highest FRPM count for K-12 students?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT NumTstTakr FROM satscores WHERE cds = ( SELECT CDSCode FROM frpm ORDER BY `FRPM Count (K-12)` DESC LIMIT 1 )",
        "amends": [],
        "rules": []
    },
    "1257": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.CRE >= 1.5 \nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) < 70;"
        ],
        "question": "Among the patients whose creatinine level is abnormal, how many of them aren't 70 yet?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70",
        "amends": [],
        "rules": [
            "creatinine level is abnormal refers to CRE >= 1.5; aren't 70 yet refers to SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) < 70; "
        ]
    },
    "1460": {
        "sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, e.cost\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.expense_description = 'Water, Veggie tray, supplies';",
            "SELECT T2.first_name, T2.last_name, T1.cost\nFROM expense T1\nINNER JOIN member T2 ON T1.link_to_member = T2.member_id\nWHERE T1.expense_description IN ('water', 'veggie tray', 'supplies');",
            "SELECT T2.first_name, T2.last_name, T1.cost\nFROM expense T1\nINNER JOIN member T2 ON T1.link_to_member = T2.member_id\nWHERE T1.expense_description = 'Water, Veggie tray, supplies'"
        ],
        "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.first_name, T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
        "amends": [
            "Do select `first_name` and `last_name` as separate columns instead of concatenating them into `full_name`. Do use `INNER JOIN` with the explicit keyword instead of just `JOIN`. Do reverse the join condition to `T1.link_to_member = T2.member_id` instead of `m.member_id = e.link_to_member` to maintain proper table reference consistency. Do use table aliases `T1` and `T2` instead of single-letter aliases `m` and `e` for better readability. The amended query now correctly retrieves individual name components and maintains proper join semantics while matching the RIGHT_SQL's behavior.",
            "Do use a single equality comparison with `expense_description = 'Water, Veggie tray, supplies'` instead of the `IN` operator with separate values `('water', 'veggie tray', 'supplies')` to match the exact combined string value. Do maintain the same `INNER JOIN` on `T1.link_to_member = T2.member_id` without changes to the join condition. Do preserve the same column selection of `T2.first_name, T2.last_name, T1.cost` from the same tables. The amended query now correctly filters for the specific combined description string instead of multiple separate values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "full name refers to first_name, last name; spent money for refers expense description; expense_description = 'Water, Veggie tray, supplies'"
        ]
    },
    "16": {
        "sql": [
            "SELECT COUNT(*) \nFROM satscores \nJOIN schools ON satscores.cds = schools.CDSCode \nWHERE schools.County = 'Alameda' AND satscores.NumTstTakr < 100;",
            "SELECT COUNT(T1.CDSCode) \nFROM schools T1 \nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds \nWHERE T1.StatusType = 'Merged' \nAND T1.County = 'Lake' \nAND T2.NumTstTakr < 100"
        ],
        "question": "How many schools in merged Alameda have number of test takers less than 100?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.CDSCode) FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Merged' AND T2.NumTstTakr < 100 AND T1.County = 'Lake'",
        "amends": [
            "Do specify `COUNT(T1.CDSCode)` instead of `COUNT(*)` to count specific non-null values. Do use table aliases `T1` for `schools` and `T2` for `satscores` instead of no aliases. Do change the join to `INNER JOIN` with explicit `ON T1.CDSCode = T2.cds` instead of implicit join syntax. Do add filter `T1.StatusType = 'Merged'` instead of omitting this status condition. Do change the county filter to `T1.County = 'Lake'` instead of `'Alameda'` to target different geographic data. The amended query now correctly filters for merged schools in Lake County with appropriate test taker counts, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "431": {
        "sql": [
            "SELECT s.id, s.code, s.name\nFROM sets s\nJOIN cards c ON s.code = c.setCode\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE s.isForeignOnly = 0\nAND s.isFoilOnly = 1\nAND fd.language = 'Japanese'\nGROUP BY s.id, s.code, s.name;",
            "SELECT s.name, s.id\nFROM sets s\nINNER JOIN set_translations st ON s.code = st.setCode AND st.language = 'Japanese'\nWHERE s.isForeignOnly = 1\nAND s.isFoilOnly = 1;",
            "SELECT T1.name, T1.id\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.isFoilOnly = 1\nAND T1.isForeignOnly = 0\nAND T2.language = 'Japanese'"
        ],
        "question": "Which set is not available outside of the United States and has foil cards with Japanese writing on them? Please include the set ID in your response.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Japanese' AND T1.isFoilOnly = 1 AND T1.isForeignOnly = 0",
        "amends": [
            "Do select only `name` and `id` instead of including `code` in the SELECT list. Do join `set_translations` instead of joining `cards` and `foreign_data` tables. Do use `INNER JOIN` on `T1.code = T2.setCode` instead of multiple joins on `s.code = c.setCode` and `c.uuid = fd.uuid`. Do move the `language = 'Japanese'` filter to the `set_translations` join condition instead of applying it to `foreign_data`. Do remove the GROUP BY clause instead of grouping by `s.id, s.code, s.name` since aggregation is no longer needed. The amended query now correctly filters for Japanese set translations while maintaining the same foil-only and foreign-only conditions, matching the RIGHT_SQL's behavior.",
            "Do use table aliases `T1` and `T2` instead of `s` and `st`. Do move the `language = 'Japanese'` filter from the JOIN condition to the WHERE clause instead of keeping it in the ON predicate. Do change the `isForeignOnly` condition to `= 0` instead of `= 1`. Do remove the redundant `AND` conjunction between the WHERE conditions instead of keeping it. The amended query now correctly filters for non-foreign sets with Japanese translations and foil-only sets, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "available outside of the United States refers to isForeignOnly = 1; has foil cards refers to isFoilOnly = 1; with Japanese writing on them refers to language = 'Japanese'"
        ]
    },
    "1384": {
        "sql": [
            "SELECT SUM(amount) AS total_income FROM income WHERE link_to_member = (SELECT member_id FROM member WHERE first_name = 'Grant' AND last_name = 'Gilmour');"
        ],
        "question": "How many income generated by Grant Gilmour?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'",
        "amends": [],
        "rules": [
            "income generated refers to income.amount"
        ]
    },
    "594": {
        "sql": [
            "SELECT u.DisplayName, u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Id = 1;",
            "SELECT T2.Id, T2.Reputation \nFROM comments AS T1 \nINNER JOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T1.PostId = 1"
        ],
        "question": "Which user created post ID 1 and what is the reputation of this user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Id, T2.Reputation FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.PostId = 1",
        "amends": [
            "Do select `T2.Id` and `T2.Reputation` instead of `u.DisplayName` and `u.Reputation`. Do join from `comments AS T1` instead of `posts p`. Do use `INNER JOIN users AS T2` instead of `JOIN users u`. Do join on `T1.UserId = T2.Id` instead of `p.OwnerUserId = u.Id`. Do filter with `T1.PostId = 1` instead of `p.Id = 1`. The amended query now correctly retrieves user information from comments rather than posts for the specified post ID."
        ],
        "rules": []
    },
    "1244": {
        "sql": [
            "SELECT DISTINCT P.ID, P.SEX, P.Birthday, P.Description, P.`First Date`, P.Admission, P.Diagnosis\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE strftime('%Y', P.`First Date`) > '1992'\nAND L.PT < 14;",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.First_Date) > '1992'\nAND T2.PT IS NOT NULL",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.`First Date`) > '1992'\nAND T2.PT < 14"
        ],
        "question": "List all patients who first came to the hospital after year 1992 with prothrombin time (PT) level that are normal.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) > '1992' AND T2.PT < 14",
        "amends": [
            "Do select only `T1.ID` instead of multiple columns including `P.ID`, `P.SEX`, `P.Birthday`, `P.Description`, `P.First Date`, `P.Admission`, and `P.Diagnosis`. Do use `INNER JOIN` with explicit `AS T2` alias instead of `JOIN` with `L` alias. Do reference `T1.First Date` instead of `P.First Date` in the STRFTIME function. Do reference `T2.PT` instead of `L.PT` in the filter condition. Do remove `DISTINCT` instead of keeping it. The amended query now correctly returns only patient IDs meeting the date and laboratory criteria without unnecessary columns or distinct filtering.",
            "Do use backticks around `First Date` instead of First_Date to handle the column name with spaces. Do change the WHERE condition to `T2.PT < 14` instead of `T2.PT IS NOT NULL` to filter for specific values rather than just non-null values. The amended query now correctly filters laboratory results with PT values below 14 instead of merely checking for non-null PT values, matching the intended behavior."
        ],
        "rules": [
            "first came to the hospital after year 1992 refers to year(`First Date`) > 1992; prothrombin time (PT) level that are normal refers to PT < 14;"
        ]
    },
    "489": {
        "sql": [
            "SELECT keyruneCode FROM sets WHERE code = 'PKHC';"
        ],
        "question": "List the keyrune code for the set whose code is 'PKHC'.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT keyruneCode FROM sets WHERE code = 'PKHC'",
        "amends": [],
        "rules": [
            "keyrune code refers to keyruneCode"
        ]
    },
    "151": {
        "sql": [
            "SELECT DISTINCT d.A2 AS district_name\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE t.type = 'VYDAJ';"
        ],
        "question": "Please list the name of the districts with accounts that made withdrawal transactions.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ'",
        "amends": [],
        "rules": [
            "A2 refers to district name; type = 'VYDAJ' stands for withdrawal transactions"
        ]
    },
    "1317": {
        "sql": [
            "SELECT COUNT(*) AS medium_shirt_attendees\nFROM member\nJOIN attendance ON member.member_id = attendance.link_to_member\nJOIN event ON attendance.link_to_event = event.event_id\nWHERE event.event_name = 'Women\\'s Soccer' AND member.t_shirt_size = 'Medium';",
            "SELECT COUNT(*) \nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = \"Women's Soccer\"\nAND T3.t_shirt_size = 'medium';",
            "SELECT COUNT(T1.event_id) \nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = \"Women's Soccer\" \nAND T3.t_shirt_size = 'Medium'"
        ],
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
        "amends": [
            "Do count `T1.event_id` instead of `COUNT(*)` to ensure accurate counting of distinct events. Do use explicit `INNER JOIN` syntax with table aliases `T1`, `T2`, and `T3` instead of implicit joins without aliases. Do join `event AS T1` with `attendance AS T2` on `T1.event_id = T2.link_to_event` instead of the original join order. Do join `attendance AS T2` with `member AS T3` on `T2.link_to_member = T3.member_id` instead of the reverse direction. Do use double quotes in the string literal `Women''s Soccer` instead of escaped single quotes for proper SQL string handling. The amended query now correctly counts medium shirt attendees for Women's Soccer events with proper join relationships and string formatting.",
            "Do count `T1.event_id` instead of `COUNT(*)` to ensure accurate counting of specific event records. Do use uppercase 'Medium' in `T3.t_shirt_size = 'Medium'` instead of lowercase 'medium' to match the proper case-sensitive value format in the database. The amended query now correctly counts event records for Women's Soccer attendees with medium t-shirt sizes using proper case matching and specific column counting."
        ],
        "rules": [
            "Women's Soccer is an event name; T-shirt that is in medium size refers to t_shirt_size = 'Medium'"
        ]
    },
    "1170": {
        "sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE (strftime('%Y', e.`Examination Date`) - strftime('%Y', p.`First Date`)) >= 1;",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '+'\nAND STRFTIME('%Y', T2.\"Examination Date\") - STRFTIME('%Y', T1.\"First Date\") >= 1"
        ],
        "question": "How many patients hadn't undergone a medical examination until at least a year following their initial hospital visit?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '+' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.`First Date`) >= 1",
        "amends": [
            "Do add `T1.Admission = '+'` filter in the WHERE clause instead of omitting it. Do use `INNER JOIN` with explicit `AS` aliases `T1` and `T2` instead of simple `JOIN` with aliases `p` and `e`. Do keep the same join condition `T1.ID = T2.ID` instead of changing it. Do maintain the same date difference calculation `STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.`First Date`) >= 1` instead of altering it. The amended query now correctly filters for patients with Admission status '+' while preserving the examination date difference logic, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "hadn't undergone a medical examination until at least a year refers to SUBTRACT(year(`Examination Date`), year(`First Date`)) > = 1"
        ]
    },
    "592": {
        "sql": [
            "SELECT COUNT(*) AS UserCount\nFROM (\n    SELECT UserId\n    FROM badges\n    GROUP BY UserId\n    HAVING COUNT(*) > 5\n) AS UsersWithMoreThan5Badges;"
        ],
        "question": "How many users are awarded with more than 5 badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(UserId) FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "amends": [],
        "rules": [
            "more than 5 badges refers to Count (Name) > 5; user refers to UserId"
        ]
    },
    "1401": {
        "sql": [
            "SELECT e.cost\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'September Speaker' AND (b.category = 'posters' OR e.expense_description LIKE '%posters%');"
        ],
        "question": "Indicate the cost of posters for 'September Speaker' event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Posters'",
        "amends": [],
        "rules": [
            "'Posters' is the expense description; 'September Speaker' is an event name"
        ]
    },
    "1077": {
        "sql": [
            "SELECT team_long_name FROM Team WHERE team_short_name = 'GEN';"
        ],
        "question": "What's the long name for the team GEN?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT team_long_name FROM Team WHERE team_short_name = 'GEN'",
        "amends": [],
        "rules": [
            "long name for the team refers to team_long_name; team_short_name = 'GEN';"
        ]
    },
    "11": {
        "sql": [
            "SELECT CDSCode FROM frpm WHERE (\"Enrollment (K-12)\" + \"Enrollment (Ages 5-17)\") > 500;"
        ],
        "question": "Please list the codes of the schools with a total enrollment of over 500.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.CDSCode FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` + T2.`Enrollment (Ages 5-17)` > 500",
        "amends": [],
        "rules": [
            "Total enrollment can be represented by `Enrollment (K-12)` + `Enrollment (Ages 5-17)`"
        ]
    },
    "87": {
        "sql": [
            "SELECT AdmEmail1, AdmEmail2, AdmEmail3\nFROM schools\nWHERE County = 'San Bernardino'\n  AND City = 'San Bernardino'\n  AND District = 'San Bernardino City Unified'\n  AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31'\n  AND SOC = '62'\n  AND DOC = '54';",
            "SELECT T2.AdmEmail1, T2.AdmEmail2\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'San Bernardino'\n  AND T2.City = 'San Bernardino'\n  AND strftime('%Y', T2.OpenDate) IN ('2009', '2010')\n  AND T2.DOC = 54\n  AND T2.SOC = 62"
        ],
        "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
        "amends": [
            "Do select only `AdmEmail1` and `AdmEmail2` instead of including `AdmEmail3`. Do join `frpm AS T1` with `schools AS T2` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do reference all columns with table aliases (`T2.County`, `T2.City`, etc.) instead of unqualified column names. Do use numeric comparison `T2.DOC = 54` instead of string comparison `DOC = '54'`. Do extract year from `OpenDate` using `strftime('%Y', T2.OpenDate)` and compare to year strings `'2009'` and `'2010'` instead of date range `BETWEEN '2009-01-01' AND '2010-12-31'`. Do use numeric comparison `T2.SOC = 62` instead of string comparison `SOC = '62'`. Do remove the `District` filter instead of keeping `District = 'San Bernardino City Unified'`. The amended query now correctly joins the required tables and handles date and numeric comparisons appropriately to match the intended behavior."
        ],
        "rules": [
            "Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; years between 2009 and 2010 can refer to 'between 1/1/2009 to 12/31/2010'"
        ]
    },
    "495": {
        "sql": [
            "SELECT s.releaseDate \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Evacuation';"
        ],
        "question": "What was the release date for the set which card \"Evacuation\" in it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Evacuation'",
        "amends": [],
        "rules": [
            "\"Evacuation\" refers to name = 'Evacuation'; release date refers to releaseDate"
        ]
    },
    "804": {
        "sql": [
            "SELECT superhero_name FROM superhero WHERE id = 294;"
        ],
        "question": "Provide the name of superhero with superhero ID 294.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero WHERE id = 294",
        "amends": [],
        "rules": [
            "name of superhero refers to superhero_name; superhero ID 294 refers to superhero.id = 294;"
        ]
    },
    "1044": {
        "sql": [
            "SELECT player_name, birthday FROM Player WHERE substr(birthday, 1, 7) = '1970-10';",
            "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10';"
        ],
        "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
        "amends": [
            "Do remove the `birthday` column from the SELECT list instead of including it, as the right query only needs player names. Do keep the WHERE filter using `SUBSTR(birthday, 1, 7)` unchanged since the date extraction logic remains correct for finding players born in October 1970. The amended query now matches the right SQL's behavior of returning only player names without exposing their full birth dates."
        ],
        "rules": [
            "players with a birthyear of 1970 and a birthmonth of October refers to substr(birthday,1,7) AS 'year-month',WHERE year = '1970' AND month = '10';"
        ]
    },
    "621": {
        "sql": [
            "SELECT DISTINCT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Reputation = (SELECT MIN(Reputation) FROM users);"
        ],
        "question": "What are the name of badges that users who have the lowest reputation obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
        "amends": [],
        "rules": [
            "lowest reputation refers to Min(Reputation); user refers to UserId"
        ]
    },
    "1310": {
        "sql": [
            "SELECT AVG(L.PT) AS AverageProthrombinTime\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.PT < 14;"
        ],
        "question": "For the male patients that have a normal prothrombin time, what is their average prothrombin time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.PT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PT < 14 AND T1.SEX = 'M'",
        "amends": [],
        "rules": [
            "male refers to Sex = 'M'; normal prothrombin time refer to PT < 14; average prothrombin time = AVG(PT);"
        ]
    },
    "857": {
        "sql": [
            "SELECT c.lat, c.lng \nFROM circuits c \nJOIN races r ON c.circuitId = r.circuitId \nWHERE r.name = 'Abu Dhabi Grand Prix';"
        ],
        "question": "Give the coordinate position for Abu Dhabi Grand Prix.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Abu Dhabi Grand Prix'",
        "amends": [],
        "rules": [
            "coordinate position/location refers to lat, lng; Abu Dhabi Grand Prix refers to races.name = 'Abu Dhabi Grand Prix'"
        ]
    },
    "1480": {
        "sql": [
            "SELECT \n    SUBSTR(ym.Date, 5, 2) AS Month,\n    SUM(ym.Consumption) AS TotalConsumption\nFROM \n    yearmonth ym\nJOIN \n    customers c ON ym.CustomerID = c.CustomerID\nWHERE \n    c.Segment = 'SME' AND \n    SUBSTR(ym.Date, 1, 4) = '2013'\nGROUP BY \n    Month\nORDER BY \n    TotalConsumption DESC\nLIMIT 1;",
            "SELECT SUBSTR(T2.Date, 5, 2) AS Month\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND T2.Date LIKE '2013%'\nGROUP BY SUBSTR(T2.Date, 5, 2)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;"
        ],
        "question": "What was the gas consumption peak month for SME customers in 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUBSTR(T2.Date, 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME' GROUP BY SUBSTR(T2.Date, 5, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do reference the table aliases `T1` and `T2` instead of `c` and `ym` for consistency with the right query. Do use `INNER JOIN` explicitly instead of just `JOIN` to clarify the join type. Do place the `Segment = 'SME'` filter in the `WHERE` clause instead of keeping it there since it's already correct. Do reference `SUM(T2.Consumption)` directly in the `ORDER BY` clause instead of using the alias `TotalConsumption`. Do group by the expression `SUBSTR(T2.Date, 5, 2)` instead of the alias `Month` to ensure proper grouping. Do remove the column alias `Month` from the `SELECT` list and only keep the expression itself instead of including both. Do remove the alias `TotalConsumption` from the `SELECT` list since it's not needed in the final output. The amended query now correctly identifies the month with the highest total consumption for SME customers in 2013 by properly grouping on the month expression and ordering by the sum directly."
        ],
        "rules": [
            "Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
        ]
    },
    "1153": {
        "sql": [
            "SELECT p.Diagnosis AS Disease, l.Date AS LaboratoryTestDate\nFROM Patient p\nLEFT JOIN Laboratory l ON p.ID = l.ID\nWHERE p.ID = 30609\nUNION\nSELECT e.Diagnosis AS Disease, l.Date AS LaboratoryTestDate\nFROM Examination e\nLEFT JOIN Laboratory l ON e.ID = l.ID\nWHERE e.ID = 30609;"
        ],
        "question": "What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis, T2.Date FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 30609",
        "amends": [],
        "rules": [
            "'30609' is the Patient ID; disease means Diagnosis"
        ]
    },
    "609": {
        "sql": [
            "SELECT COUNT(*) FROM posts WHERE Score = 10;"
        ],
        "question": "How many posts have a score of 10 on the list?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score = 10",
        "amends": [],
        "rules": [
            "score of 10 refers to Score = 10; post refers to Id"
        ]
    },
    "1076": {
        "sql": [
            "WITH diallo_avg AS (\n    SELECT AVG(pa.ball_control) AS avg_ball_control\n    FROM Player_Attributes pa\n    JOIN Player p ON pa.player_api_id = p.player_api_id\n    WHERE p.player_name = 'Abdou Diallo'\n),\nappindangoye_avg AS (\n    SELECT AVG(pa.ball_control) AS avg_ball_control\n    FROM Player_Attributes pa\n    JOIN Player p ON pa.player_api_id = p.player_api_id\n    WHERE p.player_name = 'Aaron Appindangoye'\n)\nSELECT diallo_avg.avg_ball_control - appindangoye_avg.avg_ball_control AS difference_in_avg_ball_control\nFROM diallo_avg, appindangoye_avg;"
        ],
        "question": "What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye\n?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.id ELSE NULL END) - CAST(SUM(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.id ELSE NULL END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "amends": [],
        "rules": [
            "difference of the average ball control = SUBTRACT(AVG(ball_control WHERE player_name = 'Abdou Diallo'), AVG(ball_control WHERE player_name = 'Aaron Appindangoye')); AVG(ball_control WHERE player_name = 'XX XX') = SUM(CASE WHEN player_name = 'XX XX' THEN ball_control ELSE 0 END) / COUNT(CASE WHEN player_name = 'XX XX' THEN id ELSE NULL END)"
        ]
    },
    "173": {
        "sql": [
            "-- Query to find how often account number 3 requests an account statement to be released\nSELECT COUNT(*) AS statement_request_count\nFROM trans\nWHERE account_id = 3 AND k_symbol LIKE '%statement%';\n\n-- Query to find the aim of debiting 3539 in total\nSELECT k_symbol, SUM(amount) AS total_debit\nFROM trans\nGROUP BY k_symbol\nHAVING SUM(amount) = 3539;",
            "SELECT T1.frequency, T2.k_symbol\nFROM account AS T1\nJOIN (\n    SELECT account_id, k_symbol, SUM(amount) AS total_amount\n    FROM `order`\n    GROUP BY account_id, k_symbol\n) AS T2 ON T1.account_id = T2.account_id\nWHERE T1.account_id = 3 AND T2.total_amount = 3539"
        ],
        "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
        "amends": [
            "Do join `account` table as `T1` instead of querying only `trans` table. Do use a subquery on `order` table with `SUM(amount)` grouped by `account_id` and `k_symbol` instead of aggregating directly on `trans` table. Do filter on `account_id = 3` in the WHERE clause instead of in a separate query. Do check for `total_amount = 3539` instead of using HAVING with the same value. Do select `T1.frequency` and `T2.k_symbol` instead of counting statement requests or showing k_symbol with total debit. Do remove the LIKE filter on k_symbol for statements instead of keeping it. The amended query now correctly identifies accounts with specific transaction totals rather than counting statement requests or showing aggregate amounts by k_symbol alone."
        ],
        "rules": [
            "k_symbol refers to the purpose of payments"
        ]
    },
    "633": {
        "sql": [
            "SELECT p.Id\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'slashnick'\nORDER BY p.AnswerCount DESC\nLIMIT 1;"
        ],
        "question": "Which post by slashnick has the most answers count? State the post ID.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.PostId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'slashnick' ORDER BY T3.AnswerCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "most answers count refers to MAX(AnswerCount); post by slashnick refers to DisplayName = 'slashnick';"
        ]
    },
    "985": {
        "sql": [
            "SELECT d.driverId, d.forename, d.surname, lt.time\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nJOIN drivers d ON lt.driverId = d.driverId\nWHERE r.name LIKE '%French Grand Prix%' AND lt.lap = 3\nORDER BY lt.time DESC\nLIMIT 1;",
            "SELECT T1.driverId\nFROM lapTimes AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nWHERE T2.name = 'French Grand Prix' AND T1.lap = 3\nORDER BY T1.time DESC\nLIMIT 1;"
        ],
        "question": "Among the drivers who participated in the French Grand Prix, who has the slowest time in the 3rd lap.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.driverId FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'French Grand Prix' AND T1.lap = 3 ORDER BY T1.time DESC LIMIT 1",
        "amends": [
            "Do select only `driverId` instead of including `forename`, `surname`, and `time` columns. Do use `INNER JOIN` with explicit `AS` table aliases `T1` and `T2` instead of implicit aliases and multiple joins. Do use exact equality `T2.name = 'French Grand Prix'` instead of pattern matching with `LIKE '%French Grand Prix%'`. Do remove the unnecessary `drivers` table join since `driverId` is available directly from `lapTimes`. Do maintain the same `ORDER BY T1.time DESC LIMIT 1` structure for finding the slowest lap time. The amended query now correctly identifies the driver with the slowest lap time in the third lap of the French Grand Prix using precise table relationships and filtering."
        ],
        "rules": [
            "slowest time refers to Max(time);"
        ]
    },
    "292": {
        "sql": [
            "SELECT a.atom_id, a.molecule_id, a.element\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE substr(m.molecule_id, 3, 3) >= 10 AND substr(m.molecule_id, 3, 3) <= 50\nAND a.element = 'c';",
            "SELECT atom_id FROM atom WHERE molecule_id BETWEEN 'TR010' AND 'TR050' AND element = 'carbon'",
            "SELECT T.atom_id FROM atom T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'c'"
        ],
        "question": "Identify the atoms belong to the molecule with ID between TR010 to TR050 that contain the element carbon.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'c'",
        "amends": [
            "Do select only `atom_id` instead of including `molecule_id` and `element` in the SELECT list. Do remove the JOIN with `molecule` table instead of keeping it. Do use `BETWEEN 'TR010' AND 'TR050'` for molecule_id filtering instead of `substr(m.molecule_id, 3, 3) >= 10 AND substr(m.molecule_id, 3, 3) <= 50`. Do apply the molecule_id filter directly to the atom table instead of through a joined table. Do use table alias `T` instead of `a`. The amended query now correctly filters atom records by molecule_id range and element without unnecessary joins or column selections.",
            "Do use table alias `T` for the `atom` table instead of omitting it. Do reference `T.atom_id` in the SELECT list instead of just `atom_id`. Do change the element filter to `T.element = 'c'` instead of `element = 'carbon'` to match the correct value format. Do maintain the same `BETWEEN 'TR010' AND 'TR050'` predicate on `T.molecule_id` as in the original query. The amended query now correctly uses table aliasing and the proper element value format while preserving the same filtering logic."
        ],
        "rules": [
            "carbon refers to element = 'c'; between TR010 to TR050 refers to substr(molecule_id, 3, 3)>=10 AND substr(molecule_id, 3, 3) <= 50"
        ]
    },
    "1371": {
        "sql": [
            "SELECT COUNT(DISTINCT link_to_member) AS member_count\nFROM attendance\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = \"Women's Soccer\");"
        ],
        "question": "How many members attended the \"Women's Soccer\" event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
        "amends": [],
        "rules": [
            "'Women's Soccer' is the event name;"
        ]
    },
    "757": {
        "sql": [
            "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.weight_kg = 169;"
        ],
        "question": "Identify the race of the superhero who weighed 169 kg.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 169",
        "amends": [],
        "rules": [
            "weighed 169 kg refers to weight_kg = 169"
        ]
    },
    "391": {
        "sql": [
            "SELECT DISTINCT c.*\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.originalType = 'Artifact'\n  AND c.colors = 'B'\n  AND fd.language IS NOT NULL;",
            "SELECT DISTINCT T1.name \nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.types LIKE '%Artifact%' \nAND T1.colors LIKE '%B%'",
            "SELECT DISTINCT T1.name\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.originalType = 'Artifact'\nAND T1.colors = 'B'"
        ],
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "amends": [
            "Do select only `T1.name` instead of `c.*` to return specific columns rather than all columns from the cards table. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity, though both are equivalent. Do reference tables as `T1` and `T2` with aliases instead of `c` and `fd` for consistent naming. Do remove the condition `fd.language IS NOT NULL` instead of keeping it, as this filter was unnecessarily restricting results. The amended query now correctly returns only distinct card names matching the artifact type and black color criteria without the extraneous language filter.",
            "Do use `originalType = 'Artifact'` instead of `types LIKE '%Artifact%'` for exact type matching. Do use `colors = 'B'` instead of `colors LIKE '%B%'` for exact color value comparison. Do keep the `DISTINCT` selection, `INNER JOIN` on `T1.uuid = T2.uuid`, and table aliases unchanged as they match the correct logic. The amended query now correctly filters for exact artifact type and single black color instead of pattern matching, ensuring precise results that match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data"
        ]
    },
    "1334": {
        "sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE z.state = 'Illinois';",
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T2.state = 'Illinois';"
        ],
        "question": "List the full name of the Student_Club members that grew up in Illinois state.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'",
        "amends": [
            "Do select individual columns `first_name` and `last_name` instead of concatenating them with `||` into a single `full_name` alias. Do use table aliases `T1` and `T2` instead of single letters `m` and `z`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly returns separate first and last name columns while maintaining the same join logic and filtering behavior."
        ],
        "rules": [
            "full name of member refers to first_name, last_name"
        ]
    },
    "353": {
        "sql": [
            "SELECT s.code, s.name, s.totalSetSize\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Italian';",
            "SELECT T1.name, T1.totalSetSize\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Italian';"
        ],
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "amends": [
            "Do select `name` and `totalSetSize` instead of including `code` in the SELECT list. Do use `INNER JOIN` with alias `T2` instead of `JOIN` with alias `st`. Do reference `T1.code = T2.setCode` instead of `s.code = st.setCode` in the join condition. Do filter on `T2.language` instead of `st.language`. The amended query now correctly retrieves only the set name and total size for Italian translations without exposing the code field."
        ],
        "rules": [
            "Italian translation refers to language = 'Italian'; total number of card per set refers to totalSetSize;"
        ]
    },
    "868": {
        "sql": [
            "SELECT c.lat, c.lng\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Malaysian Grand Prix';"
        ],
        "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix'",
        "amends": [],
        "rules": [
            "location coordinates refers to (lat, lng); Malaysian Grand Prix refers to races.name = 'Malaysian Grand Prix'"
        ]
    },
    "739": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Death Touch';"
        ],
        "question": "What are the names of the superheroes with the power of death touch?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'",
        "amends": [],
        "rules": [
            "name of superheroes refers to refers to superhero_name; the power of death touch refers to power_name = 'Death Touch'"
        ]
    },
    "1049": {
        "sql": [
            "SELECT COUNT(*) \nFROM \"Match\" \nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Scotland Premier League') \nAND season = '2015/2016';"
        ],
        "question": "How many matches in the 2015/2016 season were held in Scotland Premier League\n?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' AND t1.name = 'Scotland Premier League'",
        "amends": [],
        "rules": [
            "Scotland Premier League refers to League.name = 'Scotland Premier League';"
        ]
    },
    "859": {
        "sql": [
            "SELECT q.q1\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE d.forename = 'Bruno' AND d.surname = 'Senna' AND q.raceId = 354;"
        ],
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "amends": [],
        "rules": [
            "race number refers to raceId; Bruno Senna refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;"
        ]
    },
    "191": {
        "sql": [
            "SELECT COUNT(*) AS loan_account_count\nFROM loan\nJOIN account ON loan.account_id = account.account_id\nWHERE loan.duration = 24\nAND account.frequency = 'POPLATEK TYDNE';"
        ],
        "question": "How many loan accounts are for pre-payment of duration of 24 months with weekly issuance of statement.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.duration = 24 AND T1.frequency = 'POPLATEK TYDNE'",
        "amends": [],
        "rules": [
            "Frequency = 'POPLATEK TYDNE' referes to weekly statement"
        ]
    },
    "379": {
        "sql": [
            "SELECT id FROM cards WHERE duelDeck = 'a';"
        ],
        "question": "What are the cards belong to duel deck a? List the ID.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE duelDeck = 'a'",
        "amends": [],
        "rules": [
            "duel deck a refers to duelDeck = a;"
        ]
    },
    "574": {
        "sql": [
            "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com';"
        ],
        "question": "Which user has the website URL listed at 'http://stackoverflow.com'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com'",
        "amends": [],
        "rules": [
            "\"http://stackoverflow.com\" is the WebsiteUrl; user refers to DisplayName"
        ]
    },
    "438": {
        "sql": [
            "SELECT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.id = 174;",
            "SELECT language FROM set_translations WHERE id = 174"
        ],
        "question": "Point out the language of set id \"174\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT language FROM set_translations WHERE id = 174",
        "amends": [
            "Do select only `language` instead of `st.language` with table alias. Do remove the `JOIN sets s ON st.setCode = s.code` clause instead of including an unnecessary join to the sets table. Do change the filter to `WHERE id = 174` instead of `WHERE s.id = 174` to directly filter on the set_translations table's primary key. The amended query now correctly retrieves languages directly from set_translations without the redundant join, matching the right SQL's behavior."
        ],
        "rules": []
    },
    "514": {
        "sql": [
            "SELECT c.name, c.convertedManaCost\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'duel'\nORDER BY c.convertedManaCost DESC\nLIMIT 10;",
            "SELECT DISTINCT name FROM cards WHERE uuid IN (SELECT uuid FROM legalities WHERE format = 'duel') ORDER BY manaCost DESC LIMIT 0, 10"
        ],
        "question": "In duels, what are the top 10 cards with the highest uncoverted mana cost?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 0, 10",
        "amends": [
            "Do select only `name` instead of including `convertedManaCost` in the SELECT list. Do use `DISTINCT` to eliminate duplicate card names instead of returning potentially repeated entries. Do use a subquery with `uuid IN (SELECT uuid FROM legalities WHERE format = 'duel')` instead of a direct JOIN on the legalities table. Do remove the explicit table alias `c` from the FROM clause instead of keeping it. Do reference `manaCost` in the ORDER BY instead of `convertedManaCost` for the sorting criteria. Do use `LIMIT 0, 10` with an offset parameter instead of `LIMIT 10` without offset specification. The amended query now correctly returns distinct card names legal in the duel format, ordered by mana cost with proper pagination handling."
        ],
        "rules": [
            "duels refer to format = 'duel'; the highest uncoverted mana cost refers to MAX(manaCost)"
        ]
    },
    "532": {
        "sql": [
            "SELECT DisplayName FROM users WHERE strftime('%Y', CreationDate) = '2011';"
        ],
        "question": "Please list the display names of all the users whose accounts were created in the year 2011.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE STRFTIME('%Y', CreationDate) = '2011'",
        "amends": [],
        "rules": [
            "account created in the year 2011 refers to year(CreationDate) = 2011"
        ]
    },
    "766": {
        "sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'strength'\nORDER BY ha.attribute_value DESC\nLIMIT 1;",
            "SELECT T1.full_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Strength'\nORDER BY T2.attribute_value DESC\nLIMIT 1"
        ],
        "question": "What is the hero's full name with the highest attribute in strength?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of full table names throughout the query. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do capitalize the string literal `'Strength'` instead of using lowercase `'strength'` to match the exact case in the data. Do maintain the same column selection `full_name`, join conditions `T1.id = T2.hero_id` and `T2.attribute_id = T3.id`, filter on `attribute_name`, ordering by `attribute_value DESC`, and `LIMIT 1` as these elements remain functionally identical. The amended query now correctly matches the case-sensitive attribute name while preserving the original logic to find the superhero with the highest strength value."
        ],
        "rules": [
            "highest attribute in strength refers to MAX(attribute_value) WHERE attribute_name = 'strength';"
        ]
    },
    "1028": {
        "sql": [
            "SELECT t.team_long_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nWHERE l.name = 'Scotland Premier League'\n  AND m.season = '2009/2010'\n  AND m.away_team_goal > m.home_team_goal\nGROUP BY m.away_team_api_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Final result should return the Team.team_long_name; Scotland Premier League refers to League.name = 'Scotland Premier League'; away team refers to away_team_api_id; away team that won the most refers to MAX(SUBTRACT(away_team_goal, home_team_goal) > 0); 2010 season refers to season = '2009/2010'; won the most refers to MAX(COUNT(*));"
        ]
    },
    "1266": {
        "sql": [
            "SELECT p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.RNP IS NOT NULL AND l.RNP != ''\nORDER BY p.Birthday DESC\nLIMIT 1;"
        ],
        "question": "Which is the youngest patient with an abnormal anti-ribonuclear protein level? Please list his or her date of birth.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP != '-' OR '+-' ORDER BY T1.Birthday DESC LIMIT 1",
        "amends": [],
        "rules": [
            "youngest patient refers to MAX(Birthday); abnormal anti-ribonuclear protein level refers to RNP NOT IN('-', '+-'); date of birth refers to Birthday;"
        ]
    },
    "1327": {
        "sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Laugh Out Loud';",
            "SELECT T1.first_name, T1.last_name\nFROM member T1\nINNER JOIN attendance T2 ON T1.member_id = T2.link_to_member\nINNER JOIN event T3 ON T2.link_to_event = T3.event_id\nWHERE T3.event_name = 'Laugh Out Loud';"
        ],
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "amends": [
            "Do select individual columns `first_name` and `last_name` instead of concatenating them with `|| ' ' ||` into a single `full_name` alias. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for both table joins. Do use table aliases `T1`, `T2`, and `T3` instead of single-letter aliases `m`, `a`, and `e`. The amended query now correctly returns separate first and last name columns while maintaining the same join logic and filtering condition."
        ],
        "rules": [
            "full name of members refers to first_name, last_name; 'Laugh Out Loud' is an event name;"
        ]
    },
    "345": {
        "sql": [
            "SELECT c.name, l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.types LIKE '%Artifact%'\nAND c.side IS NULL\nAND l.format = 'vintage';",
            "SELECT DISTINCT T2.status\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.type = 'Artifact' \nAND T2.format = 'Vintage'\nAND T1.side IS NULL",
            "SELECT DISTINCT T2.status\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T1.type = 'Artifact'\nAND T1.side IS NULL\nAND T2.format = 'vintage'"
        ],
        "question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL",
        "amends": [
            "Do select only `T2.status` instead of `c.name, l.status` and add `DISTINCT` instead of omitting it. Do use `INNER JOIN` with table aliases `T1` and `T2` instead of `JOIN` with `c` and `l`. Do filter with exact equality `T1.type = 'Artifact'` instead of pattern matching `LIKE '%Artifact%'`. The amended query now correctly retrieves distinct legality statuses for vintage format artifacts without side designations, matching the intended behavior.",
            "Do use lowercase `vintage` instead of uppercase `Vintage` in the WHERE clause filter on `T2.format`. Do maintain the same SELECT list with `T2.status`, FROM sources with `cards AS T1` and `legalities AS T2`, INNER JOIN condition on `T1.uuid = T2.uuid`, and all other filters including `T1.type = 'Artifact'` and `T1.side IS NULL`. The amended query now correctly matches the case-sensitive format value and produces the same result behavior as the RIGHT_SQL."
        ],
        "rules": [
            "Artifact type of cards refers to types = 'Artifact'; card does not have multiple faces on the same card refers to side is NULL'; vintage play format refers to format = 'vintage';"
        ]
    },
    "276": {
        "sql": [
            "SELECT c.atom_id, c.atom_id2\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '#';"
        ],
        "question": "Write down the atom IDs of the first and second atoms of triple bond type molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "amends": [],
        "rules": [
            "first atom refers to atom_id; second atom refers to atom_id2; triple bond refers to bond_type = '#';"
        ]
    },
    "329": {
        "sql": [
            "SELECT a.molecule_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+'\nGROUP BY a.molecule_id\nORDER BY COUNT(a.atom_id) DESC\nLIMIT 1;"
        ],
        "question": "Which carcinogenic molecule have the highest number of atoms consisted in it?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T2.molecule_id, COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T2.molecule_id ORDER BY COUNT(T1.atom_id) DESC LIMIT 1 ) t",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; molecule that have the highest number of atoms consisted in in refers to MAX(COUNT(atom.molecule_id))"
        ]
    },
    "141": {
        "sql": [
            "SELECT d.A2 AS district_name\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE strftime('%Y', t.date) = '1997'\nAND t.amount > 10000\nGROUP BY d.A2;",
            "SELECT T1.district_id\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T1.account_id = T3.account_id\nWHERE STRFTIME('%Y', T3.date) = '1997'\nGROUP BY T1.district_id\nHAVING SUM(T3.amount) > 10000"
        ],
        "question": "Which districts have transactions greater than USS$10,000 in 1997?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date) = '1997' GROUP BY T1.district_id HAVING SUM(T3.amount) > 10000",
        "amends": [
            "Do select `T1.district_id` instead of `d.A2 AS district_name` in the SELECT list. Do use `account AS T1` as the primary table instead of starting with `trans t`. Do change the join order to `INNER JOIN district AS T2 ON T1.district_id = T2.district_id` instead of joining district last. Do use `INNER JOIN trans AS T3 ON T1.account_id = T3.account_id` instead of joining trans first. Do keep the `STRFTIME('%Y', T3.date) = '1997'` filter in WHERE instead of changing it. Do remove the `t.amount > 10000` filter from WHERE and instead add `HAVING SUM(T3.amount) > 10000` to aggregate the total amount per district. Do group by `T1.district_id` instead of `d.A2`. The amended query now correctly aggregates total transaction amounts per district for 1997 and filters for districts exceeding 10000 in total rather than individual transactions, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "352": {
        "sql": [
            "SELECT (COUNT(DISTINCT CASE WHEN language = 'Chinese Simplified' THEN uuid END) * 100.0 / COUNT(DISTINCT uuid)) AS percentage\nFROM foreign_data;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage_chinese_simplified\nFROM \n    cards AS T1\nINNER JOIN \n    foreign_data AS T2 ON T1.uuid = T2.uuid;"
        ],
        "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
        "amends": [
            "Do use `SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT CASE WHEN language = 'Chinese Simplified' THEN uuid END)` for counting Chinese Simplified records. Do add explicit table aliases `T1` and `T2` instead of omitting them. Do use `INNER JOIN cards AS T1 ON T1.uuid = T2.uuid` instead of querying only `foreign_data` table. Do calculate percentage using `CAST(... AS REAL) * 100 / COUNT(T1.id)` instead of `* 100.0 / COUNT(DISTINCT uuid)` to avoid double-counting issues with DISTINCT. Do reference `T1.id` for the total count instead of `uuid` from the joined table. The amended query now correctly calculates the percentage of Chinese Simplified records by properly joining tables and avoiding duplicate counting issues."
        ],
        "rules": [
            "Chinese Simplified' is the language; percentage = Divide(Sum(id where language = 'Chinese Simplified'), Count(id)) *100"
        ]
    },
    "1052": {
        "sql": [
            "SELECT COUNT(*) AS left_footed_players_under_130_weight\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.weight < 130 AND pa.preferred_foot = 'left';",
            "SELECT COUNT(DISTINCT t1.id) \nFROM Player t1 \nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.weight < 130 AND t2.preferred_foot = 'left';"
        ],
        "question": "Among all the players whose weight is under 130, how many of them preferred foot in attacking is left?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.weight < 130 AND t2.preferred_foot = 'left'",
        "amends": [
            "Do use `COUNT(DISTINCT t1.id)` instead of `COUNT(*)` to avoid counting duplicate player records. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `t1` and `t2` instead of `p` and `pa` for consistency. Do reference `t1.weight` and `t2.preferred_foot` in the WHERE clause instead of `p.weight` and `pa.preferred_foot` to match the aliased table names. The amended query now correctly counts distinct players rather than all matching rows, ensuring accurate results when players have multiple attribute records."
        ],
        "rules": [
            "weight < 130; preferred foot in attacking refers to preferred_foot; preferred_foot = 'left';"
        ]
    },
    "568": {
        "sql": [
            "SELECT u.DisplayName\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE v.Id = 6347;"
        ],
        "question": "Provide the display name of the user who made the vote No.6347.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T2.Id = 6347",
        "amends": [],
        "rules": [
            "vote no. 6347 refers to Id = '6347'"
        ]
    },
    "512": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE (power IS NULL OR power = '*') AND hasFoil = 0 AND duelDeck = 'a';"
        ],
        "question": "How many cards with unknown power that can't be found in foil is in duel deck A?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE hasFoil = 0 AND duelDeck = 'a'",
        "amends": [],
        "rules": [
            "unknown power refers to power IS NULL or power = '*'; can't be found in foil refers to hasFoil = 0; duel deck A refers to duelDeck = 'a'"
        ]
    },
    "149": {
        "sql": [
            "SELECT DISTINCT d.type\nFROM disp d\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE d.type != 'OWNER'\nAND di.A11 > 8000 AND di.A11 <= 9000;"
        ],
        "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
        "amends": [],
        "rules": [
            "A11 represents the average salary; Salary and income share the similar meanings; when the account type = 'OWNER', it's eligible for loans"
        ]
    },
    "1004": {
        "sql": [
            "WITH oldest_driver AS (\n    SELECT driverId, forename, surname, dob\n    FROM drivers\n    ORDER BY dob ASC\n    LIMIT 1\n)\nSELECT d.forename || ' ' || d.surname AS full_name, SUM(ds.wins) AS total_wins\nFROM oldest_driver od\nJOIN driverStandings ds ON od.driverId = ds.driverId\nJOIN drivers d ON od.driverId = d.driverId\nGROUP BY od.driverId;",
            "SELECT SUM(T1.wins) AS total_wins, T2.forename, T2.surname\nFROM driverStandings AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nORDER BY T2.dob ASC\nLIMIT 1;"
        ],
        "question": "How many wins was achieved by the oldest racer? Indicate his/her full name.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.wins),T2.forename, T2.surname FROM driverStandings AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId ORDER BY T2.dob ASC LIMIT 1",
        "amends": [
            "Do select `SUM(T1.wins)`, `T2.forename`, and `T2.surname` instead of `full_name` and `SUM(ds.wins) AS total_wins`. Do use a direct `INNER JOIN` between `driverStandings AS T1` and `drivers AS T2` on `T1.driverId = T2.driverId` instead of the CTE approach with multiple joins through `oldest_driver`. Do remove the `GROUP BY od.driverId` clause instead of keeping it. Do add `ORDER BY T2.dob ASC LIMIT 1` to get the oldest driver's record instead of using a CTE to find the oldest driver first. The amended query now correctly identifies the oldest driver and sums their wins in a single efficient query rather than the previous approach that would return wins for all drivers grouped by driverId."
        ],
        "rules": [
            "oldest racer refers to MIN(dob); full name refers to forename, surname."
        ]
    },
    "355": {
        "sql": [
            "SELECT keywords FROM cards WHERE name = 'Angel of Mercy';"
        ],
        "question": "What is the keyword found on card 'Angel of Mercy'?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy'",
        "amends": [],
        "rules": [
            "Angel of Mercy' is the name of card;"
        ]
    },
    "765": {
        "sql": [
            "SELECT COUNT(DISTINCT hero_id) AS hero_count\nFROM hero_power\nWHERE power_id = (SELECT id FROM superpower WHERE power_name = 'stealth');",
            "SELECT COUNT(T1.hero_id) \nFROM hero_power AS T1 \nINNER JOIN superpower AS T2 ON T1.power_id = T2.id \nWHERE T2.power_name = 'Stealth'"
        ],
        "question": "How many heroes have stealth power?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'",
        "amends": [
            "Do use `COUNT(T1.hero_id)` without DISTINCT instead of `COUNT(DISTINCT hero_id)` to count all hero occurrences rather than unique heroes. Do add `INNER JOIN superpower AS T2 ON T1.power_id = T2.id` instead of using a subquery for the power lookup. Do move the filter to `WHERE T2.power_name = 'Stealth'` instead of the subquery condition `power_id = (SELECT id FROM superpower WHERE power_name = 'stealth')`. Do use proper table aliases `T1` and `T2` instead of unaliased table references. The amended query now correctly joins the tables and filters on the power name directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "stealth power refers to power_name = 'stealth';"
        ]
    },
    "542": {
        "sql": [
            "SELECT SUM(p.CommentCount) AS TotalComments\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';"
        ],
        "question": "What is the total number of comments of all the posts owned by csgillespie?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.CommentCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; total number of comments refers to Sum(CommentCount)"
        ]
    },
    "595": {
        "sql": [
            "SELECT u.Id, u.DisplayName\nFROM users u\nJOIN postHistory ph ON u.Id = ph.UserId\nWHERE u.Views >= 1000\nGROUP BY u.Id, ph.PostId\nHAVING COUNT(ph.Id) = 1;",
            "SELECT T2.UserId\nFROM postHistory AS T2\nINNER JOIN posts AS T3 ON T2.PostId = T3.Id\nWHERE T3.ViewCount >= 1000\nGROUP BY T2.UserId\nHAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1"
        ],
        "question": "Which user have only one post history per post and having at least 1000 views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
        "amends": [
            "Do select `T2.UserId` instead of `u.Id, u.DisplayName` and remove the DisplayName column. Do add `INNER JOIN posts AS T3` on `T2.PostId = T3.Id` instead of omitting the posts table entirely. Do change the WHERE filter to `T3.ViewCount >= 1000` instead of `u.Views >= 1000` to filter on post views rather than user views. Do modify the GROUP BY to `T2.UserId` instead of `u.Id, ph.PostId` to group by user only. Do change the HAVING clause to `COUNT(DISTINCT T2.PostHistoryTypeId) = 1` instead of `COUNT(ph.Id) = 1` to count distinct post history types rather than all post history entries. The amended query now correctly filters based on post view counts and counts unique post history types per user, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "having at least 1000 view refers to Views > = 1000; user refers to UserId"
        ]
    },
    "660": {
        "sql": [
            "SELECT OwnerUserId FROM posts WHERE Score = (SELECT MAX(Score) FROM posts);"
        ],
        "question": "What is the owner user id of the most valuable post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT OwnerUserId FROM posts WHERE FavoriteCount = ( SELECT MAX(FavoriteCount) FROM posts )",
        "amends": [],
        "rules": [
            "the most valuable post refers to MAX(FavoriteCount);"
        ]
    },
    "60": {
        "sql": [
            "SELECT Website FROM schools WHERE Virtual = 'P' AND Charter = 1 AND County = 'San Joaquin';"
        ],
        "question": "What are the websites for all the partially virtual chartered schools located in San Joaquin?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT Website FROM schools WHERE County = 'San Joaquin' AND Virtual = 'P' AND Charter = 1",
        "amends": [],
        "rules": [
            "Virtual = 'P' means partially virtual; Charter schools refers to Charter = 1 in the table schools"
        ]
    },
    "337": {
        "sql": [
            "SELECT a.element, b.bond_type\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.molecule_id = 'TR002';\n"
        ],
        "question": "List the element and bond type included in the molecule with molecule ID of TR002.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element, T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR002'",
        "amends": [],
        "rules": [
            "TR002 is the molecule id"
        ]
    },
    "523": {
        "sql": [
            "WITH yearly_set_counts AS (\n    SELECT \n        strftime('%Y', releaseDate) AS year,\n        COUNT(*) AS set_count\n    FROM \n        sets\n    WHERE \n        releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\n    GROUP BY \n        year\n),\ncommon_language AS (\n    SELECT \n        language,\n        COUNT(*) AS language_count\n    FROM \n        foreign_data\n    GROUP BY \n        language\n    ORDER BY \n        language_count DESC\n    LIMIT 1\n)\nSELECT \n    AVG(set_count) AS annual_average_sets,\n    (SELECT language FROM common_language) AS common_language\nFROM \n    yearly_set_counts;",
            "SELECT \n    SUM(T1.id)/COUNT(T1.id)/4 AS annual_average,\n    T2.language AS common_language\nFROM \n    sets AS T1\nJOIN \n    set_translations AS T2 ON T1.id = T2.id\nWHERE \n    T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\nGROUP BY \n    T1.releaseDate\nORDER BY \n    COUNT(T2.language) DESC\nLIMIT 1;",
            "SELECT \n    CAST(SUM(T1.id) AS REAL) / COUNT(T1.id) / 4, \n    T2.language\nFROM \n    sets AS T1\nINNER JOIN \n    set_translations AS T2 ON T1.id = T2.id\nWHERE \n    T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\nGROUP BY \n    T1.releaseDate\nORDER BY \n    COUNT(T2.language) DESC\nLIMIT 1"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "What is the annual average number of sets that were released between 1/1/2012 to 12/31/2015? Indicate the common langugage of the card.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4, T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.id = T2.id WHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY T1.releaseDate ORDER BY COUNT(T2.language) DESC LIMIT 1",
        "amends": [
            "Do use `SUM(T1.id)/COUNT(T1.id)/4` instead of `AVG(set_count)` for the annual average calculation. Do join `sets AS T1` with `set_translations AS T2` on `T1.id = T2.id` instead of using separate CTEs for yearly counts and language analysis. Do filter on `T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'` in the WHERE clause instead of in a CTE. Do group by `T1.releaseDate` instead of grouping by year in a separate CTE. Do order by `COUNT(T2.language) DESC` and add `LIMIT 1` instead of using a separate CTE with ORDER BY and LIMIT for language analysis. Do remove the CTE structure entirely instead of maintaining separate common table expressions. The amended query now correctly calculates the average set value and identifies the most common language within the specified date range, matching the RIGHT_SQL's behavior.",
            "Do cast the `SUM(T1.id)` as `REAL` instead of performing integer division, and do remove the `annual_average` alias instead of keeping it. Do use `INNER JOIN` explicitly instead of just `JOIN`, and do remove the `AS` keyword from column aliases instead of including it. Do keep all other elements including the `SELECT` list expressions, `FROM` sources with join condition, `WHERE` filters, `GROUP BY` clause, `ORDER BY` expression, and `LIMIT` unchanged as they match between both queries. The amended query now correctly handles numeric division with proper casting and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "AVG(id); releaseDate BETWEEN 1/1/2012 AND 12/31/2015; the common language refers to MAX(COUNT(language))"
        ]
    },
    "1094": {
        "sql": [
            "SELECT ((A.overall_rating - P.overall_rating) * 100.0 / P.overall_rating) AS percentage_higher\nFROM Player_Attributes A\nJOIN Player PA ON A.player_api_id = PA.player_api_id\nJOIN Player_Attributes P\nJOIN Player PP ON P.player_api_id = PP.player_api_id\nWHERE PA.player_name = 'Ariel Borysiuk' AND PP.player_name = 'Paulin Puel';\n",
            "SELECT \n    (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) AS percentage_difference\nFROM \n    Player AS t1\nJOIN \n    Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.player_name IN ('Ariel Borysiuk', 'Paulin Puel');"
        ],
        "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "amends": [
            "Do use conditional aggregation with `SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END)` instead of direct column subtraction `A.overall_rating - P.overall_rating`. Do join `Player AS t1` with `Player_Attributes AS t2` on `t1.player_api_id = t2.player_api_id` instead of separate joins for each player with incorrect table aliases. Do remove the explicit player name filters in the WHERE clause and instead incorporate them into the conditional aggregation logic. Do calculate the percentage difference using the aggregated sums instead of individual row comparisons. Do use proper table aliases `t1` and `t2` for clarity instead of ambiguous aliases like `A`, `P`, `PA`, and `PP`. The amended query now correctly calculates the percentage difference between the aggregated overall ratings of the two specified players."
        ],
        "rules": [
            "how much higher in percentage = MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100);"
        ]
    },
    "770": {
        "sql": [
            "SELECT c.colour \nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.full_name = 'Abraham Sapien';"
        ],
        "question": "What is the eyes colour of Abraham Sapien?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Abraham Sapien'",
        "amends": [],
        "rules": [
            "eye colour refers to colour.colour where eye_colour_id = colour.id; Abraham Sapien is the full name of superhero;"
        ]
    },
    "612": {
        "sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'Pierre';"
        ],
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "amends": [],
        "rules": []
    },
    "584": {
        "sql": [
            "WITH target_post AS (\n    SELECT Id \n    FROM posts \n    WHERE Title = 'Why square the difference instead of taking the absolute value in standard deviation?'\n),\neditors AS (\n    SELECT DISTINCT UserId \n    FROM postHistory \n    WHERE PostId IN (SELECT Id FROM target_post)\n)\nSELECT c.* \nFROM comments c\nWHERE c.UserId IN (SELECT UserId FROM editors);",
            "SELECT T2.Comment\nFROM posts T1\nINNER JOIN postHistory T2 ON T1.Id = T2.PostId\nWHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'"
        ],
        "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "amends": [
            "Do use `INNER JOIN` between `posts` and `postHistory` instead of querying `comments` table with a subquery. Do select `T2.Comment` instead of selecting all columns from `comments`. Do filter directly on `T1.Title` in the `WHERE` clause instead of using a CTE with a subquery. Do remove the `DISTINCT` operation and CTE structure instead of keeping the complex nested query approach. Do eliminate the unnecessary `comments` table join and subquery filtering instead of maintaining the indirect relationship through user IDs. The amended query now correctly retrieves comments directly from postHistory for the specified post title, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "\"Why square the difference instead of taking the absolute value in standard deviation?\" is the Title of post;"
        ]
    },
    "1099": {
        "sql": [
            "SELECT pa.preferred_foot \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Abdou Diallo';"
        ],
        "question": "Which foot is preferred by Abdou Diallo?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "amends": [],
        "rules": [
            "Abdou Diallo refers to player_name = 'Abdou Diallo'; foot is preferred refers to preferred_foot"
        ]
    },
    "818": {
        "sql": [
            "SELECT (COUNT(CASE WHEN s.gender_id = 2 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female_bad_superheroes\nFROM superhero s\nWHERE s.alignment_id = 2;"
        ],
        "question": "Among the bad superheroes, what is the percentage of female superheroes?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Bad'",
        "amends": [],
        "rules": [
            "bad superheroes refers to alignment.id = 2; percentage = MULTIPLY(DIVIDE(SUM(gender.id = 2 WHERE alignment.id = 2), COUNT(alignment.id = 2)), 100.0); female refers to gender.id = 2;"
        ]
    },
    "971": {
        "sql": [
            "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY dob ASC LIMIT 1;"
        ],
        "question": "Please state the reference name of the oldest German driver.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1",
        "amends": [],
        "rules": [
            "oldest refers to MIN(year(dob)); reference names appear in drverRef."
        ]
    },
    "264": {
        "sql": [
            "SELECT molecule_id, label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');"
        ],
        "question": "What are the labels for TR000, TR001 and TR002?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
        "amends": [],
        "rules": [
            "TR000, TR001 and TR002 are molecule id; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "547": {
        "sql": [
            "SELECT COUNT(*) AS NumberOfPosts\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.Age > 65 AND p.Score >= 20;"
        ],
        "question": "Among the posts owned by an elder user, how many of them have a score of over 19?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score >= 20 AND T2.Age > 65",
        "amends": [],
        "rules": [
            "elder users refers to Age > 65; Score of over 19 refers to Score > = 20"
        ]
    },
    "1293": {
        "sql": [
            "SELECT MAX(e.ANA) AS Highest_ANA\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE l.CRE < 1.5;"
        ],
        "question": "What is the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.ANA FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 ORDER BY T2.ANA DESC LIMIT 1",
        "amends": [],
        "rules": [
            "highest anti-nucleus antibody concentration level refers to MAX(ANA); normal creatinine level refers to CRE < 1.5;"
        ]
    },
    "1380": {
        "sql": [
            "SELECT SUM(spent) AS total_spent_food FROM budget WHERE category = 'Food';"
        ],
        "question": "What is the total amount of money spent for food?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(spent) FROM budget WHERE category = 'Food'",
        "amends": [],
        "rules": [
            "total amount of money spent refers to SUM(spent); spent for food refers to category = 'Food'"
        ]
    },
    "369": {
        "sql": [
            "SELECT COUNT(DISTINCT c.uuid) \nFROM cards c \nJOIN foreign_data fd ON c.uuid = fd.uuid \nWHERE fd.language = 'German' AND c.isReprint = 1;"
        ],
        "question": "How many cards that illusrtated in German have been reprinted?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.isReprint = 1",
        "amends": [],
        "rules": [
            "German' is the language; reprinted refers to isReprint = 1;"
        ]
    },
    "1526": {
        "sql": [
            "WITH customer_payment AS (\n    SELECT CustomerID\n    FROM transactions_1k\n    WHERE Date = '2012-08-25' AND Price = 634.8\n    LIMIT 1\n),\nconsumption_2012 AS (\n    SELECT Consumption\n    FROM yearmonth\n    WHERE CustomerID = (SELECT CustomerID FROM customer_payment) AND Date LIKE '2012%'\n),\nconsumption_2013 AS (\n    SELECT Consumption\n    FROM yearmonth\n    WHERE CustomerID = (SELECT CustomerID FROM customer_payment) AND Date LIKE '2013%'\n)\nSELECT \n    ((SELECT Consumption FROM consumption_2012) - (SELECT Consumption FROM consumption_2013)) / \n    (SELECT Consumption FROM consumption_2012) AS ConsumptionDecreaseRate;",
            "WITH target_customer AS (\n    SELECT DISTINCT t.CustomerID\n    FROM transactions_1k t\n    INNER JOIN gasstations g ON t.GasStationID = g.GasStationID\n    WHERE t.Date = '2012/8/25' AND t.Price = 634.8\n)\nSELECT \n    tc.CustomerID,\n    CAST(\n        (SUM(IIF(SUBSTR(ym.Date, 1, 4) = '2012', ym.Consumption, 0)) - \n         SUM(IIF(SUBSTR(ym.Date, 1, 4) = '2013', ym.Consumption, 0))) / \n        SUM(IIF(SUBSTR(ym.Date, 1, 4) = '2012', ym.Consumption, 0)) * 100.0 \n        AS FLOAT\n    ) AS consumption_decrease_rate\nFROM target_customer tc\nINNER JOIN yearmonth ym ON tc.CustomerID = ym.CustomerID\nGROUP BY tc.CustomerID",
            "SELECT \n    (SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0))) / \n    CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) AS FLOAT) AS ConsumptionDecreaseRate\nFROM yearmonth\nWHERE CustomerID = (\n    SELECT t.CustomerID\n    FROM transactions_1k t\n    INNER JOIN gasstations g ON t.GasStationID = g.GasStationID\n    WHERE t.Date = '2012-08-25' AND t.Price = 634.8\n    LIMIT 1\n)"
        ],
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "amends": [
            "Do use `SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0))` and `SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0))` instead of separate CTEs for each year's consumption. Do add `INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID` instead of omitting the gasstations table join. Do use `CAST(... AS FLOAT)` for the division instead of implicit casting. Do move the CustomerID subquery directly into the WHERE clause instead of using multiple CTEs. Do calculate the consumption decrease rate with proper aggregation instead of single row assumptions. Do handle multiple year records with conditional aggregation instead of assuming single records per year. The amended query now correctly handles multiple consumption records and properly joins with the gasstations table to match RIGHT_SQL's behavior.",
            "Do remove the CTE `target_customer` and instead use a scalar subquery in the `WHERE` clause. Do change the date format from `'2012/8/25'` to `'2012-08-25'` for proper date handling. Do remove the explicit `GROUP BY tc.CustomerID` since the query now returns a single aggregate value instead of per-customer results. Do eliminate the unnecessary `DISTINCT` in the subquery as the scalar subquery expects a single value. Do remove the table alias `ym` and reference columns directly from the `yearmonth` table. Do simplify the calculation by removing the multiplication by `100.0` since the right query calculates a ratio rather than a percentage rate. The amended query now correctly returns a single aggregate consumption difference ratio for the specific customer matching the transaction criteria."
        ],
        "rules": [
            "'2012/8/24' can be represented by '2012-08-24'; Consumption decrease rate = (consumption_2012 - consumption_2013) / consumption_2012"
        ]
    },
    "641": {
        "sql": [
            "SELECT COUNT(DISTINCT UserId) AS NumberOfUsers\nFROM badges\nWHERE Name = 'Commentator' AND strftime('%Y', Date) = '2014';"
        ],
        "question": "How many users received commentator badges in 2014?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'",
        "amends": [],
        "rules": [
            "Commentator is the name of the badge; year(Date) = 2014;"
        ]
    },
    "1270": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.SC170 IN('negative', '0') \nAND P.SEX = 'F' \nAND E.Symptoms IS NULL;"
        ],
        "question": "Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.SC170 = 'negative' OR T2.SC170 = '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL",
        "amends": [],
        "rules": [
            "normal anti-scl70 refers to SC170 IN('negative', '0'); female refers to Sex = 'F'; does not have any symptom refers to symptoms IS NULL; Should consider DISTINCT in the final result;"
        ]
    },
    "74": {
        "sql": [
            "SELECT frpm.\"Low Grade\"\nFROM schools\nJOIN frpm ON schools.CDSCode = frpm.CDSCode\nWHERE schools.NCESDist = '0613360' AND schools.EdOpsCode = 'SPECON';"
        ],
        "question": "What is the lowest grade for the District Special Education Consortia School with National Center for Educational Statistics school district identification number of 0613360?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT MIN(T1.`Low Grade`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.NCESDist = '0613360' AND T2.EdOpsCode = 'SPECON'",
        "amends": [],
        "rules": [
            "District Special Education Consortia School refers to EdOpsCode = 'SPECON'."
        ]
    },
    "1229": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.TG >= 200 \nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 50;"
        ],
        "question": "For all patients with triglyceride (TG) level beyond the normal range, how many are age more than 50 years?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200 AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 50",
        "amends": [],
        "rules": [
            "triglyceride (TG) level beyond the normal range refers to TG > = 200; more than 50 years of age = SUBTRACT(year(current_timestamp), year(Birthday)) > 50; Should consider DISTINCT in the final result;"
        ]
    },
    "374": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo';"
        ],
        "question": "How many black border cards are only available on mtgo?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE availability = 'mtgo' AND borderColor = 'black'",
        "amends": [],
        "rules": [
            "black border card refers to borderColor = black; available on mtgo refers to availability = mtgo;\n\nadd quotes for string = 'black' and = 'mtgo'"
        ]
    },
    "1254": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.IGA > 80 AND L.IGA < 500 \nAND YEAR(P.`First Date`) >= 1990;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGA BETWEEN 80 AND 500\nAND strftime('%Y', T1.\"First Date\") > '1990'"
        ],
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND  strftime('%Y',  T1.`First Date`) > '1990'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use `BETWEEN 80 AND 500` instead of separate `L.IGA > 80 AND L.IGA < 500` conditions for the IGA range filter. Do use `strftime('%Y', T1.First Date) > '1990'` instead of `YEAR(P.First Date) >= 1990` to extract the year and compare as string with proper SQLite date function. Do use table aliases `T1` and `T2` consistently instead of `P` and `L` for better readability. The amended query now correctly counts patients with IGA values in the 80-500 range who had their first date after 1990, matching the intended behavior."
        ],
        "rules": [
            "normal Ig A level refers to IGA > 80 AND IGA < 500; came to the hospital after 1990/1/1 refers to YEAR(`First Date`) > = 1990;"
        ]
    },
    "536": {
        "sql": [
            "SELECT COUNT(*) \nFROM users \nWHERE Views > 10 \nAND strftime('%Y', CreationDate) > '2013';"
        ],
        "question": "How many users with more than 10 views created their account after the year 2013?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM users WHERE STRFTIME('%Y', CreationDate) > '2013' AND Views > 10",
        "amends": [],
        "rules": [
            "more than 10 views refers to Views > 10; created after the year 2013 refers to year (CreationDate) > 2013"
        ]
    },
    "749": {
        "sql": [
            "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Deathlok';"
        ],
        "question": "Provide the superpowers of the superhero called Deathlok.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Deathlok'",
        "amends": [],
        "rules": [
            "superpowers refers to power_name; Deathlok refers to superhero_name = 'Deathlok'"
        ]
    },
    "961": {
        "sql": [
            "SELECT r.name AS race_name, r.year\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nWHERE res.milliseconds IS NOT NULL\nORDER BY res.milliseconds ASC\nLIMIT 1;"
        ],
        "question": "Which race has the shortest actual finishing time? Please give the name and year.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN results AS T2 on T1.raceId = T2.raceId WHERE T2.milliseconds IS NOT NULL ORDER BY T2.milliseconds LIMIT 1",
        "amends": [],
        "rules": [
            "shortest actual finishing time refers to Min(milliseconds) except milliseconds = null;"
        ]
    },
    "951": {
        "sql": [
            "SELECT c.constructorId, c.name, COUNT(cr.raceId) AS races_with_zero_points\nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nWHERE c.nationality = 'Japanese' AND cr.points = 0\nGROUP BY c.constructorId, c.name\nHAVING COUNT(cr.raceId) = 2;",
            "SELECT COUNT(T1.raceId) \nFROM constructorStandings T1\nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId\nWHERE T2.nationality = 'Japanese' AND T1.points = 0\nGROUP BY T1.constructorId\nHAVING COUNT(T1.raceId) = 2"
        ],
        "question": "How many Japanese constructors have 0 points in 2 races?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.raceId) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T2.nationality = 'Japanese' GROUP BY T1.constructorId HAVING COUNT(raceId) = 2",
        "amends": [
            "Do use `constructorStandings` table instead of `constructorResults` for the join. Do change the join to `INNER JOIN` on `T1.constructorId = T2.constructorId` instead of `JOIN` on `c.constructorId = cr.constructorId`. Do move the `nationality` filter to the `WHERE` clause instead of keeping it in the original position. Do change the `points` filter to reference `T1.points` instead of `cr.points`. Do simplify the `GROUP BY` to only `T1.constructorId` instead of grouping by both `c.constructorId` and `c.name`. Do remove the `c.name` column from the `SELECT` list instead of including it. Do change the aggregate to `COUNT(T1.raceId)` instead of `COUNT(cr.raceId)`. The amended query now correctly counts races with zero points for Japanese constructors using the appropriate standings table."
        ],
        "rules": [
            "2 races refers to COUNT(raceID) = 2; Japanese refers to constructors.nationality = 'Japanese';"
        ]
    },
    "646": {
        "sql": [
            "SELECT p.Title AS PostTitle, c.Text AS CommentText, u.DisplayName AS UserDisplayName\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nJOIN users u ON c.UserId = u.Id\nWHERE c.Score > 60;",
            "SELECT p.Title, c.UserDisplayName \nFROM posts p\nINNER JOIN comments c ON p.Id = c.PostId\nWHERE c.Score > 60",
            "SELECT T1.Title, T2.UserDisplayName \nFROM posts T1 \nINNER JOIN comments T2 ON T2.PostId = T1.Id \nWHERE T1.Score > 60",
            "SELECT T1.Title, T2.UserDisplayName \nFROM posts T1 \nINNER JOIN comments T2 ON T2.PostId = T2.Id \nWHERE T1.Score > 60"
        ],
        "question": "Describe the post title which got positive comments and display names of the users who posted those comments.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title, T2.UserDisplayName FROM posts AS T1 INNER JOIN comments AS T2 ON T2.PostId = T2.Id WHERE T1.Score > 60",
        "amends": [
            "Do select only `Title` and `UserDisplayName` instead of including `PostTitle`, `CommentText`, and `UserDisplayName`. Do join `posts` with `comments` instead of joining `comments` with `posts` and `users`. Do use `INNER JOIN` on `T2.PostId = T2.Id` instead of joining on `c.PostId = p.Id` and `c.UserId = u.Id`. Do filter on `T1.Score > 60` instead of filtering on `c.Score > 60`. Do remove the `users` table join and the `comments` table alias instead of keeping them. The amended query now correctly filters posts by score and joins with comments using the proper join condition.",
            "Do use table aliases `T1` and `T2` instead of `p` and `c` for consistency. Do correct the JOIN condition to `T2.PostId = T1.Id` instead of the incorrect `T2.PostId = T2.Id` which would create a self-join condition. Do move the filter to `T1.Score > 60` instead of `T2.Score > 60` to filter on the posts table score rather than comments score. The amended query now correctly joins posts and comments tables with proper join conditions and applies the score filter to the appropriate table.",
            "Do use the join condition `T2.PostId = T2.Id` instead of `T2.PostId = T1.Id` in the INNER JOIN predicate. The amended query now correctly matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "positive comments refer to Score > 60;"
        ]
    },
    "1025": {
        "sql": [
            "SELECT l.name AS league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2015/2016'\nGROUP BY m.league_id\nORDER BY total_goals DESC\nLIMIT 1;",
            "SELECT t2.name \nFROM Match t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.season = '2015/2016'\nGROUP BY t2.name\nORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC\nLIMIT 1;"
        ],
        "question": "Give the name of the league had the most goals in the 2016 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' GROUP BY t2.name ORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` instead of `l.name AS league_name` and remove the alias `total_goals`. Do use table aliases `t1` for Match and `t2` for League instead of `m` and `l`. Do group by `t2.name` instead of `m.league_id` to ensure proper grouping by league name rather than ID. Do place the aggregate expression `SUM(t1.home_team_goal + t1.away_team_goal)` directly in the ORDER BY clause instead of selecting it as a column with an alias. The amended query now correctly returns the league name with the highest total goals in the 2015/2016 season, matching the intended behavior."
        ],
        "rules": [
            "league that had the most goals refers to MAX(SUM(home_team_goal, away_team_goal)); 2016 season refers to season = '2015/2016';"
        ]
    },
    "396": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE frameVersion = '1993' \nAND (hasNonFoil = 1 OR hasFoil = 1) \nAND hasContentWarning = 1;"
        ],
        "question": "How many cards with a 1993 frame version and available on paper have a sensitive content warning?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE frameVersion = 1993 AND availability = 'paper' AND hasContentWarning = 1",
        "amends": [],
        "rules": [
            "sensitive content warning refer to hasContentWarning = 1; available on paper refer to availability = 'paper' 1993 refer to frameVersion"
        ]
    },
    "1391": {
        "sql": [
            "SELECT \n    CAST(SUM(CASE WHEN major.major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN major.major_name = 'Physics' THEN 1 ELSE 0 END), 0) AS finance_to_physics_ratio\nFROM \n    member\nJOIN \n    major ON member.link_to_major = major.major_id;",
            "SELECT \n    (SELECT COUNT(*) FROM member WHERE link_to_major IN (SELECT major_id FROM major WHERE major_name = 'Finance')) * 1.0 / \n    (SELECT COUNT(*) FROM member WHERE link_to_major IN (SELECT major_id FROM major WHERE major_name = 'Physics')) AS ratio",
            "SELECT \n    CAST(SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END), 0) AS ratio\nFROM \n    major"
        ],
        "question": "What is the ratio between students majored in finance and physics?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) / SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END) AS ratio FROM major",
        "amends": [
            "Do remove the `member` table join and instead query directly from the `major` table. Do remove the `CAST` to `REAL` and `NULLIF` function and instead use direct division between the sums. Do change the alias from `finance_to_physics_ratio` to `ratio` instead of keeping the longer name. Do remove the unnecessary `CASE` condition checks for `major.major_name` and instead use `major_name` directly. The amended query now correctly calculates the ratio of Finance to Physics majors without unnecessary joins and type conversions, matching the right SQL's behavior.",
            "Do use a single query with conditional aggregation using `SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END)` instead of nested subqueries with `COUNT(*)` and `IN` clauses. Do reference the `major` table directly in the `FROM` clause instead of using multiple subqueries against the `member` table. Do calculate the ratio directly from the `major` table's `major_name` field instead of joining through the `member` table's `link_to_major` foreign key. Do remove the unnecessary multiplication by `1.0` for type conversion since the division of integers in this context will produce the correct numeric result. The amended query now correctly calculates the ratio of Finance to Physics majors directly from the source data without the potential data integrity issues of the nested subquery approach."
        ],
        "rules": [
            "DIVDE(SUM(major_name = 'Finance'), SUM(major_name = 'Physics'))"
        ]
    },
    "392": {
        "sql": [
            "SELECT c.name\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.rarity = 'uncommon'\nORDER BY r.date ASC\nLIMIT 3;",
            "SELECT DISTINCT T1.name\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'uncommon'\nORDER BY T2.date ASC\nLIMIT 3;"
        ],
        "question": "Pick 3 cards with rarity of uncommon, list down name these cards according to ascending order of it's ruling date.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3",
        "amends": [
            "Do use `DISTINCT` in the SELECT clause instead of omitting it to eliminate duplicate card names. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `c` and `r` for consistent naming. Do maintain the same join condition `T1.uuid = T2.uuid` instead of changing it. Do keep the WHERE filter on `T1.rarity = 'uncommon'` unchanged. Do preserve the ORDER BY on `T2.date ASC` and LIMIT 3 without modification. The amended query now correctly returns distinct card names while maintaining the same filtering, joining, and sorting logic."
        ],
        "rules": [
            "uncommon refers to rarity = 'uncommon';"
        ]
    },
    "572": {
        "sql": [
            "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';"
        ],
        "question": "How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'",
        "amends": [],
        "rules": [
            "\"Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer\" is the Title of post; views refers to ViewCount"
        ]
    },
    "1142": {
        "sql": [
            "SELECT COUNT(*) AS total_games\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Italy Serie A')\nAND season = '2015/2016';"
        ],
        "question": "In the 2015\u20132016 season, how many games were played in the Italian Serie A league?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Italy Serie A' AND t2.season = '2015/2016'",
        "amends": [],
        "rules": [
            "In the 2015\u20132016 season refers to season = '2015/2016'"
        ]
    },
    "1060": {
        "sql": [
            "SELECT COUNT(*) FROM Player WHERE strftime('%Y', birthday) > '1990';"
        ],
        "question": "How many players were born after 1990?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990'",
        "amends": [],
        "rules": [
            "born after 1990 refers to strftime('%Y', birthday) = '1990';"
        ]
    },
    "794": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nGROUP BY s.superhero_name\nORDER BY MAX(ha.attribute_value) DESC\nLIMIT 1;",
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Speed'\nORDER BY T2.attribute_value DESC\nLIMIT 1"
        ],
        "question": "Which hero was the fastest?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do remove the `GROUP BY s.superhero_name` and `MAX(ha.attribute_value)` aggregation instead of grouping and using an aggregate function, since the query only needs to return a single row. Do use `T2.attribute_value` directly in the `ORDER BY` clause instead of applying `MAX()` to it, as there's no grouping requirement. Do change the table aliases to `T1`, `T2`, and `T3` instead of `s`, `ha`, and `a` for consistency with the target query structure. Do add explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. The amended query now correctly returns the superhero with the highest Speed attribute value without unnecessary aggregation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "which hero refers to superhero_name; fastest refers to MAX(attribute_value) WHERE attribute_name = 'Speed';"
        ]
    },
    "693": {
        "sql": [
            "WITH LatestUser AS (\n    SELECT Id\n    FROM users\n    ORDER BY CreationDate DESC\n    LIMIT 1\n)\nSELECT \n    (SELECT COUNT(*) FROM posts WHERE OwnerUserId = (SELECT Id FROM LatestUser)) AS post_count,\n    (SELECT COUNT(*) FROM comments WHERE UserId = (SELECT Id FROM LatestUser)) AS comment_count;",
            "SELECT \n    COUNT(DISTINCT T2.Id) AS post_count,\n    COUNT(DISTINCT T3.Id) AS comment_count\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId\nINNER JOIN \n    comments T3 ON T3.PostId = T2.Id\nORDER BY \n    T1.CreationDate DESC \nLIMIT 1",
            "SELECT COUNT(T2.Id) \nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nINNER JOIN comments T3 ON T3.PostId = T2.Id\nORDER BY T1.CreationDate DESC\nLIMIT 1"
        ],
        "question": "Identify the number of posts and comments left by the user, who has the latest created user account.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T3.PostId = T2.Id ORDER BY T1.CreationDate DESC LIMIT 1",
        "amends": [
            "Do use a single query with `INNER JOIN` between `users`, `posts`, and `comments` instead of using CTE and multiple subqueries. Do join `posts` on `T1.Id = T2.OwnerUserId` instead of filtering by subquery. Do join `comments` on `T3.PostId = T2.Id` instead of filtering by separate subquery. Do count `T2.Id` from the joined result instead of counting posts and comments separately. Do add `ORDER BY T1.CreationDate DESC LIMIT 1` to get the latest user's data instead of using a CTE to find the latest user first. The amended query now correctly counts posts with comments for the most recent user, matching the RIGHT_SQL's behavior.",
            "Do remove `DISTINCT` from `COUNT(DISTINCT T2.Id)` instead of keeping it, and do remove the entire `COUNT(DISTINCT T3.Id) AS comment_count` column instead of including it. Do change the SELECT list to only include `COUNT(T2.Id)` instead of multiple aggregated columns. Do remove the alias `AS post_count` instead of keeping it. Do maintain the same `FROM` sources with `users T1`, `posts T2`, and `comments T3` instead of changing them. Do keep the same join conditions with `INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId` and `INNER JOIN comments T3 ON T3.PostId = T2.Id` instead of modifying them. Do maintain the same `ORDER BY T1.CreationDate DESC` and `LIMIT 1` instead of altering them. The amended query now correctly counts all posts without unnecessary distinct operations and removed comment counting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "the latest created user account refers to MAX(CreationDate);"
        ]
    },
    "1042": {
        "sql": [
            "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2009/2010'\nGROUP BY l.name\nHAVING AVG(m.home_team_goal) > AVG(m.away_team_goal);"
        ],
        "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0",
        "amends": [],
        "rules": [
            "name of league refers to League.name; average goals by the home team is higher than the away team = AVG(home_team_goal) > AVG(away_team_goal); AVG(xx_goal) = SUM(xx_goal) / COUNT(DISTINCT Match.id); 2009/2010 season refers to season = '2009/2010'"
        ]
    },
    "1502": {
        "sql": [
            "SELECT DISTINCT g.ChainID\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE c.Currency = 'EUR';"
        ],
        "question": "Please list the chains of the gas stations with transactions in euro.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.ChainID FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN gasstations AS T3 ON T1.GasStationID = T3.GasStationID WHERE T2.Currency = 'EUR'",
        "amends": [],
        "rules": []
    },
    "1268": {
        "sql": [
            "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.SM NOT IN ('negative', '0')\nORDER BY p.Birthday DESC\nLIMIT 3;"
        ],
        "question": "For the patients with an abnormal anti-SM, please list the IDs of the three youngest ones.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM NOT IN ('negative','0') ORDER BY T1.Birthday DESC LIMIT 3",
        "amends": [],
        "rules": [
            "abnormal anti-SM refers to SM NOT IN ('negative', '0'); youngest refers to MAX(Birthday);"
        ]
    },
    "1087": {
        "sql": [
            "SELECT COUNT(DISTINCT p.player_api_id) \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE p.height > 180 AND pa.volleys > 70;"
        ],
        "question": "Among the players whose height is over 180, how many of them have a volley score of over 70?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 AND t2.volleys > 70",
        "amends": [],
        "rules": [
            "height > 180; volley score refers to volleys; volleys > 70;"
        ]
    },
    "1183": {
        "sql": [
            "SELECT p.Diagnosis\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE e.Diagnosis = 'SLE' AND e.`Examination Date` = '1997-01-27' AND p.`First Date` IS NOT NULL;"
        ],
        "question": "For the patient who was diagnosed SLE on 1997/1/27, what was his/her original diagnose when he/she came to the hospital for the first time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = ( SELECT ID FROM Examination WHERE `Examination Date` = '1997-01-27' AND Diagnosis = 'SLE' ) AND T2.`Examination Date` = T1.`First Date`",
        "amends": [],
        "rules": [
            "'SLE' AND original diagnose refers to diagnosis; 1997/1/27 refer to `Examination Date` = '1997-01-27'; first came to the hospital refers to patient.`First Date`"
        ]
    },
    "1398": {
        "sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.category = 'Advertisement'\nORDER BY b.spent DESC\nLIMIT 1;"
        ],
        "question": "Name the event with the highest amount spent on advertisement.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' ORDER BY T1.spent DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Name of event refers to event_name; highest amount spent on advertisement refers to MAX(spent) where category = 'Advertisement'"
        ]
    },
    "313": {
        "sql": [
            "SELECT COUNT(*) FROM atom WHERE molecule_id = 'TR001';"
        ],
        "question": "How many atoms belong to molecule id TR001?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR001'",
        "amends": [],
        "rules": []
    },
    "167": {
        "sql": [
            "SELECT DISTINCT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.type = 'junior' AND strftime('%Y', ca.issued) > '1996';"
        ],
        "question": "List all the clients' IDs whose junior credit cards were issued after 1996.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.client_id FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'junior' AND T1.issued >= '1997-01-01'",
        "amends": [],
        "rules": [
            "After 1996 means date > = '1997-01-01"
        ]
    },
    "38": {
        "sql": [
            "SELECT s.Website\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.County = 'Los Angeles'\nAND sc.NumTstTakr BETWEEN 2000 AND 3000;"
        ],
        "question": "What are the webpages for the Los Angeles County school that has between 2,000 and 3,000 test takers?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Website FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumTstTakr BETWEEN 2000 AND 3000 AND T2.County = 'Los Angeles'",
        "amends": [],
        "rules": []
    },
    "1034": {
        "sql": [
            "WITH AvgRating2010 AS (\n    SELECT AVG(overall_rating) AS avg_rating\n    FROM Player_Attributes\n    WHERE strftime('%Y', date) = '2010'\n),\nAboveAveragePlayers AS (\n    SELECT player_api_id, overall_rating\n    FROM Player_Attributes\n    WHERE strftime('%Y', date) = '2010'\n    AND overall_rating > (SELECT avg_rating FROM AvgRating2010)\n),\nMaxAboveAverage AS (\n    SELECT MAX(overall_rating) AS max_rating\n    FROM AboveAveragePlayers\n)\nSELECT player_api_id\nFROM AboveAveragePlayers\nWHERE overall_rating = (SELECT max_rating FROM MaxAboveAverage);",
            "SELECT player_api_id \nFROM Player_Attributes \nWHERE SUBSTR(date, 1, 4) = '2010' \nORDER BY overall_rating DESC \nLIMIT 1;"
        ],
        "question": "List the players' api id who had the highest above average overall ratings in 2010.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_api_id FROM Player_Attributes WHERE SUBSTR(`date`, 1, 4) = '2010' ORDER BY overall_rating DESC LIMIT 1",
        "amends": [
            "Do use `SUBSTR(date, 1, 4)` for year extraction instead of `strftime('%Y', date)` to match the right SQL's date handling approach. Do remove the CTE structure with `AvgRating2010`, `AboveAveragePlayers`, and `MaxAboveAverage` instead of maintaining multiple nested subqueries. Do add `ORDER BY overall_rating DESC LIMIT 1` instead of using complex filtering to find the maximum rating through separate CTEs and equality comparisons. Do simplify the query to a single direct selection from `Player_Attributes` instead of using multiple CTE layers. The amended query now correctly identifies the player with the highest rating in 2010 using a more efficient top-N approach rather than calculating averages and maximums through multiple processing steps."
        ],
        "rules": [
            "highest above average overall ratings refers to MAX(overall_rating); in 2010 refers to substr(date,1,4) = '2010';"
        ]
    },
    "1510": {
        "sql": [
            "SELECT AVG(Amount * Price) AS average_total_price\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE';",
            "SELECT AVG(T1.Price) \nFROM transactions_1k AS T1 \nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID \nWHERE T2.Country = 'CZE'"
        ],
        "question": "What is the average total price of the transactions taken place in gas stations in the Czech Republic?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE'",
        "amends": [
            "Do calculate `AVG(T1.Price)` instead of `AVG(Amount * Price)` to average only the price column rather than multiplying amount by price. Do use `INNER JOIN` with explicit keyword instead of just `JOIN` while maintaining the same join condition `T1.GasStationID = T2.GasStationID`. Do use table aliases `T1` and `T2` instead of `t` and `g` for consistency. Do keep the filter `T2.Country = 'CZE'` unchanged in the WHERE clause. The amended query now correctly calculates the average price for Czech gas stations instead of incorrectly computing the average of amount multiplied by price."
        ],
        "rules": [
            "Gas station in the Czech Republic implies that Country = 'CZE'"
        ]
    },
    "1127": {
        "sql": [
            "SELECT DISTINCT p.player_name, c.name AS country_name\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nJOIN Match m ON (p.player_api_id = m.home_player_1 OR p.player_api_id = m.home_player_2 OR p.player_api_id = m.home_player_3 OR p.player_api_id = m.home_player_4 OR p.player_api_id = m.home_player_5 OR p.player_api_id = m.home_player_6 OR p.player_api_id = m.home_player_7 OR p.player_api_id = m.home_player_8 OR p.player_api_id = m.home_player_9 OR p.player_api_id = m.home_player_10 OR p.player_api_id = m.home_player_11 OR p.player_api_id = m.away_player_1 OR p.player_api_id = m.away_player_2 OR p.player_api_id = m.away_player_3 OR p.player_api_id = m.away_player_4 OR p.player_api_id = m.away_player_5 OR p.player_api_id = m.away_player_6 OR p.player_api_id = m.away_player_7 OR p.player_api_id = m.away_player_8 OR p.player_api_id = m.away_player_9 OR p.player_api_id = m.away_player_10 OR p.player_api_id = m.away_player_11)\nJOIN Country c ON m.country_id = c.id\nWHERE pa.vision >= 90;",
            "SELECT t4.name\nFROM Player_Attributes t1\nJOIN Player t2 ON t1.player_api_id = t2.player_api_id\nJOIN Match t3 ON t2.player_api_id = t3.home_player_8\nJOIN Country t4 ON t3.country_id = t4.id\nWHERE t1.vision > 89"
        ],
        "question": "Locate players with vision scores of 90 and above, state the country of these players.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t4.name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id INNER JOIN Match AS t3 ON t2.player_api_id = t3.home_player_8 INNER JOIN Country AS t4 ON t3.country_id = t4.id WHERE t1.vision > 89",
        "amends": [
            "Do remove `p.player_name` and change `c.name AS country_name` to `t4.name` in the SELECT list instead of including both columns. Do change the join condition from matching on any of 22 player position columns to specifically joining on `t2.player_api_id = t3.home_player_8` instead of the OR chain across all player positions. Do change the WHERE filter from `pa.vision >= 90` to `t1.vision > 89` instead of using the greater-than-or-equal operator. Do remove the unnecessary DISTINCT modifier instead of keeping it, as the specific join condition on a single player position eliminates duplicate rows. The amended query now correctly filters for players with vision greater than 89 who specifically played in the home_player_8 position, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "vision scores of 90 and above refers to vision > 89"
        ]
    },
    "553": {
        "sql": [
            "SELECT COUNT(*) AS BadgeCount\nFROM badges\nJOIN users ON badges.UserId = users.Id\nWHERE users.DisplayName = 'csgillespie'\nAND strftime('%Y', badges.Date) = '2011';"
        ],
        "question": "Among the badges obtained by csgillespie, how many of them were obtained in the year 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE STRFTIME('%Y', T1.Date) = '2011' AND T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; obtained in 2011 refers to YEAR (Date) = 2011"
        ]
    },
    "715": {
        "sql": [
            "SELECT DISTINCT u.DisplayName\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE c.Score BETWEEN 1 AND 5\nAND u.DownVotes = 0;"
        ],
        "question": "In comments with score between 1 to 5, list down the display names of the users with 0 down votes.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score BETWEEN 1 AND 5 AND T2.DownVotes = 0",
        "amends": [],
        "rules": [
            "DownVotes = 0; Score BETWEEN 1 and 5"
        ]
    },
    "1234": {
        "sql": [
            "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.WBC <= 3.5 OR l.WBC >= 9.0\nGROUP BY p.SEX\nORDER BY (julianday('now') - julianday(p.Birthday)) / 365.25 ASC;",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.WBC IS NOT NULL\nGROUP BY T1.SEX, T1.ID\nORDER BY T1.Birthday ASC;",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0\nGROUP BY T1.SEX, T1.ID\nORDER BY T1.Birthday ASC"
        ],
        "question": "List the patient ID, sex and birthday who has abnormal white blood cell count. Group them by sex and list the patient by age in ascending order.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0 GROUP BY T1.SEX,T1.ID ORDER BY T1.Birthday ASC",
        "amends": [
            "Do add `DISTINCT` instead of omitting it, and do include `T1.ID` in the `GROUP BY` clause instead of grouping only by `T1.SEX`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `p` and `l`. Do reference `T2.WBC` in the WHERE condition instead of `l.WBC`. Do order by `T1.Birthday ASC` instead of calculating age with `(julianday('now') - julianday(p.Birthday)) / 365.25`. The amended query now correctly handles distinct patient records while maintaining proper grouping and ordering semantics.",
            "Do change the WHERE filter to `T2.WBC <= 3.5 OR T2.WBC >= 9.0` instead of `T2.WBC IS NOT NULL` to select patients with abnormal WBC values rather than simply those with any WBC measurement. The amended query now correctly identifies patients with WBC levels outside the normal range (3.5-9.0) instead of including all patients with any WBC measurement, matching the intended behavior."
        ],
        "rules": [
            "abnormal white blood cell count refers to WBC < = 3.5 or WBC > = 9.0;"
        ]
    },
    "939": {
        "sql": [
            "SELECT COUNT(DISTINCT d.driverId) AS numberOfBritishDrivers\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE r.year = 2008 AND r.name = 'Australian Grand Prix' AND d.nationality = 'British';"
        ],
        "question": "How many drivers from the UN participated in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T1.nationality = 'British' AND T3.year = 2008",
        "amends": [],
        "rules": [
            "from the UN refers to nationality = 'British'"
        ]
    },
    "874": {
        "sql": [
            "SELECT d.forename, d.surname\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE rc.name = 'San Marino Grand Prix' AND rc.year = 2006 AND r.position = 2;"
        ],
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
        "amends": [],
        "rules": [
            "finished second refers to position = 2;"
        ]
    },
    "492": {
        "sql": [
            "SELECT type FROM sets WHERE name = 'From the Vault: Lore';"
        ],
        "question": "For the set \"From the Vault: Lore\", what is its expansion type?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT type FROM sets WHERE name LIKE '%FROM the Vault: Lore%'",
        "amends": [],
        "rules": [
            "set \"From the Vault refers to name which contains 'From the Vault: Lore'; expansion type refers to type"
        ]
    },
    "1340": {
        "sql": [
            "SELECT \n    (SELECT COALESCE(SUM(b.spent), 0) \n     FROM budget b \n     JOIN event e ON b.link_to_event = e.event_id \n     WHERE SUBSTR(e.event_date, 1, 4) = '2019') -\n    (SELECT COALESCE(SUM(b.spent), 0) \n     FROM budget b \n     JOIN event e ON b.link_to_event = e.event_id \n     WHERE SUBSTR(e.event_date, 1, 4) = '2020') AS difference_in_spending;"
        ],
        "question": "Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS num FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
        "amends": [],
        "rules": [
            "The first 4 strings of the event_date values in the event table can represent year; The difference of the total amount spent = SUBTRACT(spent where YEAR(event_date) = 2019, spent where YEAR(event_date) = 2020)"
        ]
    },
    "128": {
        "sql": [
            "SELECT d.A2 AS district_name, COUNT(*) AS female_account_holders\nFROM client c\nJOIN disp dp ON c.client_id = dp.client_id\nJOIN account a ON dp.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE c.gender = 'F'\nGROUP BY d.A2\nORDER BY female_account_holders DESC\nLIMIT 9;",
            "SELECT d.district_id, d.A2, COUNT(c.client_id) AS female_account_holders\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.gender = 'F'\nGROUP BY d.district_id, d.A2\nORDER BY female_account_holders DESC\nLIMIT 9;",
            "SELECT T2.district_id, T2.A2, COUNT(T1.client_id) AS female_account_holders\nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\nGROUP BY T2.district_id, T2.A2\nORDER BY COUNT(T1.client_id) DESC\nLIMIT 9",
            "SELECT T2.A2, COUNT(T1.client_id) AS female_account_holders\nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\nGROUP BY T2.district_id, T2.A2\nORDER BY COUNT(T1.client_id) DESC\nLIMIT 9"
        ],
        "question": "List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 9",
        "amends": [
            "Do join `client` directly to `district` on `district_id` instead of joining through `disp` and `account` tables. Do use `COUNT(T1.client_id)` instead of `COUNT(*)` to count only female clients. Do group by both `T2.district_id` and `T2.A2` instead of only `d.A2` to ensure proper aggregation. Do reference `T1.client_id` in the COUNT instead of using the asterisk to avoid counting duplicate records from unnecessary joins. Do remove the intermediate table joins that were incorrectly filtering the dataset, as the relationship between client and district is direct through district_id rather than through account relationships.",
            "Do use `T2.A2` and `COUNT(T1.client_id)` in the SELECT list instead of `d.district_id, d.A2` and `COUNT(c.client_id) AS female_account_holders`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do use table aliases `T1` and `T2` instead of `c` and `d`. Do reference `T2.district_id` and `T2.A2` in GROUP BY instead of `d.district_id, d.A2`. Do order by `COUNT(T1.client_id) DESC` instead of the alias `female_account_holders DESC`. The amended query now correctly matches the RIGHT_SQL's behavior.",
            "Do remove `T2.district_id` from the SELECT list instead of including it, while keeping `T2.A2` and the aggregate function. Do maintain the same `INNER JOIN` on `T1.district_id = T2.district_id` instead of changing the join condition. Do preserve the `WHERE T1.gender = 'F'` filter instead of altering it. Do keep the same `GROUP BY T2.district_id, T2.A2` clause instead of modifying the grouping. Do maintain the `ORDER BY COUNT(T1.client_id) DESC` and `LIMIT 9` instead of changing the sorting or limiting. The amended query now correctly focuses on district names rather than IDs while maintaining the same join logic, filtering, grouping, and result ordering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "A2 refers to districts; Female refers to gender = 'F'"
        ]
    },
    "1135": {
        "sql": [
            "SELECT player_api_id\nFROM Player_Attributes\nWHERE preferred_foot = 'right'\nORDER BY potential ASC\nLIMIT 5;",
            "SELECT id \nFROM Player_Attributes \nWHERE preferred_foot = 'right' \nORDER BY potential DESC \nLIMIT 5"
        ],
        "question": "Please provide top five football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential DESC LIMIT 5",
        "amends": [
            "Do select `id` instead of `player_api_id` as the column to return from the query. Do order by `potential DESC` instead of `potential ASC` to sort in descending order rather than ascending order. The amended query now correctly returns the id column with the highest potential values for right-footed players, matching the intended behavior."
        ],
        "rules": [
            "lowest potential players refers to MIN(potential); prefer to use the right foot when attacking refers to preferred_foot = 'right'"
        ]
    },
    "170": {
        "sql": [
            "SELECT COUNT(*) AS credit_card_withdrawals_after_1995\nFROM trans\nWHERE operation = 'VYBER KARTOU' AND date > '1995-12-31';"
        ],
        "question": "How many credit card withdrawals were recorded after 1995?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
        "amends": [],
        "rules": [
            "Operation = 'VYBER KARTOU' means credit card withdrawals"
        ]
    },
    "1150": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN year(Birthday) > 1930 AND SEX = 'F' THEN 1 END) * 100.0 / \n    COUNT(CASE WHEN SEX = 'F' THEN 1 END)) AS percentage\nFROM \n    Patient;",
            "SELECT \n    CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100 AS percentage\nFROM Patient\nWHERE SEX = 'F';",
            "SELECT \n    CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(*) \nFROM Patient \nWHERE SEX = 'F';"
        ],
        "question": "What is the percentage of female patient were born after 1930?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'",
        "amends": [
            "Do use `SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN year(Birthday) > 1930 AND SEX = 'F' THEN 1 END)` for counting eligible records. Do move the `SEX = 'F'` filter to the `WHERE` clause instead of including it in both CASE expressions. Do use `CAST(... AS REAL)` for the percentage calculation instead of implicit casting with `100.0`. Do use `COUNT(*)` in the denominator instead of `COUNT(CASE WHEN SEX = 'F' THEN 1 END)` since the WHERE clause already filters for female patients. Do use SQLite's `STRFTIME('%Y', Birthday)` function instead of `year(Birthday)` for year extraction. The amended query now correctly calculates the percentage of female patients born after 1930 among all female patients.",
            "Do place the multiplication by 100 before the division instead of after it, changing `* 100 / COUNT(*)` instead of `/ COUNT(*) * 100`, to correctly calculate the percentage by first scaling the sum before dividing by the total count. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "female refers to Sex = 'F'; patient who were born after 1930 refers to year(Birthday) > '1930'; calculation = DIVIDE(COUNT(ID) where year(Birthday) > '1930' and SEX = 'F'), (COUNT(ID) where SEX = 'F')"
        ]
    },
    "280": {
        "sql": [
            "SELECT b.bond_id, m.label AS carcinogenic_status\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '#';"
        ],
        "question": "Enumerate the bond ID of triple bond type molecules and tell me if they are carcinogenic or not.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.bond_id, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "amends": [],
        "rules": [
            "triple bond refers to bond_type = '#'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "674": {
        "sql": [
            "SELECT DisplayName FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "question": "Who has the highest reputation? Please give the display name.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "amends": [],
        "rules": [
            "the highest reputation refers to MAX(Reputation);"
        ]
    },
    "30": {
        "sql": [
            "SELECT s.City, SUM(f.\"Enrollment (K-12)\") AS TotalEnrollment\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nGROUP BY s.City\nORDER BY TotalEnrollment ASC\nLIMIT 5;",
            "SELECT T2.City\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nGROUP BY T2.City\nORDER BY SUM(T1.\"Enrollment (K-12)\") ASC\nLIMIT 5"
        ],
        "question": "Which cities have the top 5 lowest enrollment number for students in grades 1 through 12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode GROUP BY T2.City ORDER BY SUM(T1.`Enrollment (K-12)`) ASC LIMIT 5",
        "amends": [
            "Do reference `T2.City` in the SELECT list instead of `s.City`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `f` and `s`. Do join on `T1.CDSCode = T2.CDSCode` instead of `f.CDSCode = s.CDSCode`. Do remove the `SUM(f.\"Enrollment (K-12)\") AS TotalEnrollment` column from the SELECT list instead of including it. Do move the `SUM(T1.\"Enrollment (K-12)\")` aggregate function to the ORDER BY clause instead of keeping it in the SELECT list. Do order by `SUM(T1.\"Enrollment (K-12)\") ASC` instead of ordering by the alias `TotalEnrollment ASC`. The amended query now correctly selects only city names while ordering by the enrollment sum, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "K-12 refers to students in grades 1 through 12."
        ]
    },
    "1321": {
        "sql": [
            "SELECT COUNT(*) AS event_count\nFROM attendance a\nJOIN member m ON a.link_to_member = m.member_id\nJOIN event e ON a.link_to_event = e.event_id\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison'\nAND strftime('%Y', e.event_date) = '2019';"
        ],
        "question": "How many events of the Student_Club did Sacha Harrison attend in 2019?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Sacha' AND T3.last_name = 'Harrison' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "amends": [],
        "rules": [
            "events attended in 2019 refers to YEAR(event_date) = 2019"
        ]
    },
    "1455": {
        "sql": [
            "SELECT b.budget_id, b.category, b.amount, b.spent, b.remaining, b.event_status\nFROM budget b\nJOIN expense e ON b.budget_id = e.link_to_budget\nWHERE e.expense_description = 'Water, chips, cookies'\nORDER BY e.cost DESC\nLIMIT 1;",
            "SELECT T2.budget_id\nFROM expense AS T1\nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\nWHERE T1.expense_description = 'Water, chips, cookies'\nORDER BY T1.cost DESC\nLIMIT 1;"
        ],
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "amends": [
            "Do select only `budget_id` instead of multiple columns including `category`, `amount`, `spent`, `remaining`, and `event_status`. Do use `INNER JOIN` with `expense AS T1` and `budget AS T2` instead of joining `budget b` with `expense e`. Do use the join condition `T1.link_to_budget = T2.budget_id` instead of `b.budget_id = e.link_to_budget`. Do keep the WHERE filter on `expense_description = 'Water, chips, cookies'` and ORDER BY `cost DESC` with LIMIT 1, but reference them through table alias `T1` instead of `e`. The amended query now correctly returns only the budget_id associated with the specified expense description, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "budget allowed refers to expense_description; expense_description = 'Water, chips, cookies'; most money refers to MAX(cost)"
        ]
    },
    "586": {
        "sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN votes v ON u.Id = v.UserId\nJOIN posts p ON v.PostId = p.Id\nWHERE v.BountyAmount = 50 AND p.Title LIKE '%variance%';",
            "SELECT T3.DisplayName, T1.Title\nFROM posts T1\nINNER JOIN votes T2 ON T1.Id = T2.PostId\nINNER JOIN users T3 ON T3.Id = T2.UserId\nWHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'"
        ],
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "amends": [
            "Do include `T1.Title` in the SELECT list instead of omitting it. Do use table aliases `T1`, `T2`, and `T3` consistently instead of `p`, `v`, and `u`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use the correct join condition `T1.Id = T2.PostId` instead of `v.PostId = p.Id`. Do use the correct join condition `T3.Id = T2.UserId` instead of `u.Id = v.UserId`. The amended query now correctly returns both the user display name and post title for votes with a bounty amount of 50 on posts containing 'variance' in the title."
        ],
        "rules": [
            "bounty amount of 50 refers to BountyAmount = 50; user refers to DisplayName; title mentioning variance refers to Title include 'variance'"
        ]
    },
    "756": {
        "sql": [
            "SELECT COUNT(*) AS bad_superheroes_count\nFROM superhero\nWHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'Bad');"
        ],
        "question": "How many bad superheroes are there?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Bad'",
        "amends": [],
        "rules": [
            "bad superheroes refers to alignment_id = Bad"
        ]
    },
    "227": {
        "sql": [
            "SELECT ROUND((SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(molecule_id)), 3) AS percentage\nFROM molecule;"
        ],
        "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3) FROM molecule t",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent"
        ]
    },
    "1146": {
        "sql": [
            "SELECT t.team_long_name\nFROM Match m\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nGROUP BY m.away_team_api_id\nORDER BY SUM(m.away_team_goal) DESC\nLIMIT 1;",
            "SELECT t2.team_long_name \nFROM Match AS t1 \nINNER JOIN Team AS t2 ON t1.away_team_api_id = t2.team_api_id \nORDER BY t1.away_team_goal DESC \nLIMIT 1"
        ],
        "question": "Please provide the full name of the away team that scored the most goals.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.team_long_name FROM Match AS t1 INNER JOIN Team AS t2 ON t1.away_team_api_id = t2.team_api_id ORDER BY t1.away_team_goal DESC LIMIT 1",
        "amends": [
            "Do use `t2.team_long_name` with alias `t2` instead of `t.team_long_name` with alias `t`. Do remove the `GROUP BY m.away_team_api_id` clause instead of keeping it. Do order by `t1.away_team_goal DESC` directly instead of using `SUM(m.away_team_goal) DESC` with aggregation. Do use explicit `INNER JOIN` with table aliases `t1` and `t2` instead of simple `JOIN` with aliases `m` and `t`. The amended query now correctly retrieves the single team with the highest away team goal in a match rather than attempting to aggregate goals across multiple matches per team."
        ],
        "rules": [
            "full name refers to team_long_name; away team refers to away_team_api_id; scored the most goals refers to MAX(away_team_goal)"
        ]
    },
    "1200": {
        "sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN p.Diagnosis LIKE '%SLE%' THEN e.ID END) * 100.0 / \n    COUNT(DISTINCT CASE WHEN e.Symptoms LIKE '%thrombocytopenia%' THEN e.ID END)) AS proportion\nFROM \n    Examination e\nJOIN \n    Patient p ON e.ID = p.ID\nWHERE \n    e.Symptoms LIKE '%thrombocytopenia%';",
            "SELECT \n    CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) AS proportion\nFROM Examination\nWHERE Symptoms = 'thrombocytopenia'"
        ],
        "question": "What proportion of patients who had signs of thrombocytopenia had SLE diagnosed?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Examination WHERE Symptoms = 'thrombocytopenia'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID)` instead of `(COUNT(DISTINCT CASE WHEN p.Diagnosis LIKE '%SLE%' THEN e.ID END) * 100.0 / COUNT(DISTINCT CASE WHEN e.Symptoms LIKE '%thrombocytopenia%' THEN e.ID END))` for the proportion calculation. Do remove the `JOIN Patient p ON e.ID = p.ID` instead of including an unnecessary table join. Do use exact equality filter `Symptoms = 'thrombocytopenia'` instead of pattern matching `LIKE '%thrombocytopenia%'` in the WHERE clause. Do eliminate the DISTINCT operations and CASE statements in both numerator and denominator instead of using them unnecessarily. Do calculate the proportion directly from the Examination table instead of joining with Patient table. The amended query now correctly calculates the percentage of SLE diagnoses among thrombocytopenia cases without redundant operations."
        ],
        "rules": [
            "thrombocytopenia' refers to symptoms; 'SLE' refers to diagnosis; calculation =  DIVIDE(SUM(DIAGNOSIS LIKE '%ITP%'), SUM(DIAGNOSIS LIKE '%SLE%')) MULTIPLY 100"
        ]
    },
    "653": {
        "sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ViewCount = (SELECT MAX(ViewCount) FROM posts);"
        ],
        "question": "What is the owner's display name of the most popular post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "amends": [],
        "rules": [
            "Higher view count means the post has higher popularity; the most popular post refers to MAX(ViewCount);"
        ]
    },
    "1456": {
        "sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, SUM(e.cost) AS total_spending\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nGROUP BY m.member_id\nORDER BY total_spending DESC\nLIMIT 5;",
            "SELECT T3.first_name, T3.last_name\nFROM expense AS T1\nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\nINNER JOIN member AS T3 ON T1.link_to_member = T3.member_id\nORDER BY T2.spent DESC\nLIMIT 5"
        ],
        "question": "List the full name of the top five members who spend the most money in the descending order of spending.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.first_name, T3.last_name FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id ORDER BY T2.spent DESC LIMIT 5",
        "amends": [
            "Do select `first_name` and `last_name` as separate columns instead of concatenating them as `full_name`, and do remove the `SUM(e.cost)` aggregation instead of including it. Do change the FROM clause to use `expense AS T1` as the primary source instead of `member m`, and do add `INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id` instead of omitting the budget table join. Do keep `INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id` but change the alias from `m` to `T3` instead of using `m`. Do remove the GROUP BY clause entirely instead of grouping by `m.member_id`. Do change the ORDER BY to use `T2.spent DESC` instead of `total_spending DESC`, and do keep the `LIMIT 5` unchanged. The amended query now correctly joins the expense, budget, and member tables to retrieve members ordered by budget spending rather than calculating total expense costs."
        ],
        "rules": [
            "full name refers to first_name, last_name; spend the most money refers to MAX(expense.cost)"
        ]
    },
    "1225": {
        "sql": [
            "SELECT \n    p.SEX,\n    GROUP_CONCAT(DISTINCT p.ID) AS Patient_List\nFROM \n    Patient p\nJOIN \n    Laboratory l ON p.ID = l.ID\nWHERE \n    l.`T-BIL` >= 2.0\nGROUP BY \n    p.SEX;",
            "SELECT T1.ID, T1.SEX\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.\"T-BIL\" IS NOT NULL AND (T2.\"T-BIL\" < 0.2 OR T2.\"T-BIL\" > 1.2)\nGROUP BY T1.ID, T1.SEX",
            "SELECT T1.ID, T1.SEX\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.\"T-BIL\" >= 2.0\nGROUP BY T1.ID, T1.SEX"
        ],
        "question": "List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID,T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 GROUP BY T1.SEX,T1.ID",
        "amends": [
            "Do select `T1.ID` and `T1.SEX` instead of `p.SEX` and `GROUP_CONCAT(DISTINCT p.ID) AS Patient_List`. Do use `INNER JOIN` with alias `Laboratory AS T2` instead of `JOIN` with alias `l`. Do add `T1.ID` to the `GROUP BY` clause instead of grouping only by `T1.SEX`. Do remove the `GROUP_CONCAT` aggregation and distinct patient list concatenation instead of keeping it. The amended query now correctly selects individual patient IDs with their sex rather than concatenating them, and properly groups by both ID and sex to avoid aggregation issues.",
            "Do change the WHERE condition to `T-BIL >= 2.0` instead of `T-BIL IS NOT NULL AND (T-BIL < 0.2 OR T-BIL > 1.2)` to filter for higher bilirubin values. Do maintain the same `INNER JOIN` on `T1.ID = T2.ID` and keep the same `SELECT` list with `T1.ID, T1.SEX`. Do preserve the `GROUP BY` clause but note the column order change from `T1.ID, T1.SEX` to `T1.SEX, T1.ID` which is functionally equivalent. The amended query now correctly identifies patients with elevated bilirubin levels (\u22652.0) instead of the previous complex range exclusion logic."
        ],
        "rules": [
            "List refers to GROUP_CONCAT(DISTINCT ID); total bilirubin (T-BIL) not within normal range refers to T-BIL > = 2.0"
        ]
    },
    "255": {
        "sql": [
            "SELECT \n    ROUND((SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100.0) / COUNT(b.bond_id), 5) AS proportion\nFROM \n    bond b\nJOIN \n    molecule m ON b.molecule_id = m.molecule_id\nWHERE \n    b.bond_type = '-';"
        ],
        "question": "What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id),5) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'",
        "amends": [],
        "rules": [
            "single bond refers to bond_type = '-'; label = '+' mean molecules are carcinogenic; proportion = DIVIDE(SUM(label = '+') * 100, COUNT(bond_id)) where bond_type = '-'"
        ]
    },
    "834": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    gender g ON s.gender_id = g.id\nWHERE \n    p.publisher_name = 'George Lucas';"
        ],
        "question": "Among all superheroes created by George Lucas, identify the percentage of female superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas'",
        "amends": [],
        "rules": [
            "created by George Lucas refers to publisher_name = 'George Lucas'; percentage = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'George Lucas'), COUNT(publisher_name = 'George Lucas')), 100.0); female refers to gender = 'Female';"
        ]
    },
    "493": {
        "sql": [
            "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized';"
        ],
        "question": "For the set \"Commander 2014 Oversized\" , give its parent code.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized'",
        "amends": [],
        "rules": [
            "the set \"Commander 2014 Oversized\" refers to name = 'Commander 2014 Oversized';"
        ]
    },
    "425": {
        "sql": [
            "SELECT number FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%';",
            "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL"
        ],
        "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
        "amends": [
            "Do select `id` instead of `number` as the output column. Do use exact equality comparison `subtypes = 'Angel,Wizard'` instead of multiple `LIKE` conditions with wildcards. Do keep the `side IS NULL` filter unchanged. The amended query now correctly identifies cards with the exact 'Angel,Wizard' subtype combination rather than cards containing both Angel and Wizard anywhere in their subtypes, matching the intended behavior."
        ],
        "rules": [
            "don't have multiple faces on a single card side is null"
        ]
    },
    "457": {
        "sql": [
            "SELECT purchaseUrls FROM cards WHERE promoTypes LIKE '%bundle%';"
        ],
        "question": "Please list the websites where I can purchase the cards that have the promotional type of \"bundle\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
        "amends": [],
        "rules": [
            "promotional type of \"bundle\" refers to promoTypes = 'bundle'; websites refers to purchaseUrls"
        ]
    },
    "506": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN c.isNonFoilOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_non_foil_only\nFROM \n    sets s\nJOIN \n    set_translations st ON s.code = st.setCode\nJOIN \n    cards c ON s.code = c.setCode\nWHERE \n    st.language = 'Japanese';",
            "SELECT \n    CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) / COUNT(id) * 100\nFROM \n    sets\nWHERE \n    code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese');"
        ],
        "question": "For all the set of cards that has Japanese translation, what is the percentage of them are only available in non-foil?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Japanese' )",
        "amends": [
            "Do use `CAST(SUM(...) AS REAL)` instead of omitting the explicit cast to ensure proper floating-point division. Do calculate percentage from `COUNT(id)` instead of `COUNT(*)` to count only cards with valid IDs. Do move the language filter to a subquery in the `WHERE` clause with `code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese')` instead of joining the set_translations table directly. Do remove the unnecessary joins to `set_translations` and `cards` tables instead of keeping them, as the calculation can be done directly from the sets table using the subquery result. Do omit the column alias `percentage_non_foil_only` instead of including it since the right query doesn't use an alias. The amended query now correctly calculates the percentage of non-foil only sets for Japanese translations using proper type casting and more efficient filtering."
        ],
        "rules": [
            "Japanese translation refers to language = 'Japanese'; in non-foil refers to isNonFoilOnly = 1; percentage of Japanese non foil in Japanese cards refers to DIVIDE(SUM(isNonFoilOnly = 1), SUM(language = 'Japanese'))*100"
        ]
    },
    "244": {
        "sql": [
            "WITH double_bond_counts AS (\n  SELECT molecule_id, COUNT(*) AS double_bond_count\n  FROM bond\n  WHERE bond_type = ' = '\n  GROUP BY molecule_id\n),\nmax_double_bonds AS (\n  SELECT molecule_id\n  FROM double_bond_counts\n  ORDER BY double_bond_count DESC\n  LIMIT 1\n)\nSELECT m.label = '+' AS is_carcinogenic\nFROM molecule m\nJOIN max_double_bonds mdb ON m.molecule_id = mdb.molecule_id;",
            "SELECT T1.label\nFROM molecule T1\nINNER JOIN (\n    SELECT T.molecule_id, COUNT(T.bond_type) \n    FROM bond T\n    WHERE T.bond_type = '='\n    GROUP BY T.molecule_id\n    ORDER BY COUNT(T.bond_type) DESC\n    LIMIT 1\n) T2 ON T1.molecule_id = T2.molecule_id"
        ],
        "question": "Is the molecule with the most double bonds carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
        "amends": [
            "Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference the subquery directly in the FROM clause instead of using a CTE structure. Do select `T1.label` directly instead of converting it to a boolean with `m.label = '+' AS is_carcinogenic`. Do use `COUNT(T.bond_type)` instead of `COUNT(*)` to explicitly count the bond_type column. Do filter with `T.bond_type = '='` instead of `bond_type = ' = '` to remove the extra spaces around the equals sign. Do remove the unnecessary column alias `double_bond_count` from the subquery. Do order by `COUNT(T.bond_type) DESC` instead of ordering by the aliased column `double_bond_count DESC`. The amended query now correctly identifies the molecule with the most double bonds and returns its label directly instead of converting it to a boolean value."
        ],
        "rules": [
            "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic"
        ]
    },
    "169": {
        "sql": [
            "WITH male_accounts AS (\n    SELECT a.account_id\n    FROM account a\n    JOIN disp d ON a.account_id = d.account_id\n    JOIN client c ON d.client_id = c.client_id\n    WHERE c.gender = 'M'\n),\nloans_1996 AS (\n    SELECT SUM(amount) AS total_amount\n    FROM loan\n    WHERE account_id IN (SELECT account_id FROM male_accounts)\n    AND strftime('%Y', date) = '1996'\n),\nloans_1997 AS (\n    SELECT SUM(amount) AS total_amount\n    FROM loan\n    WHERE account_id IN (SELECT account_id FROM male_accounts)\n    AND strftime('%Y', date) = '1997'\n)\nSELECT \n    ((loans_1997.total_amount - loans_1996.total_amount) / loans_1996.total_amount) * 100 AS growth_rate\nFROM loans_1996, loans_1997;",
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END) > 0 \n        THEN ROUND((\n            (SUM(CASE WHEN strftime('%Y', l.date) = '1997' THEN l.amount ELSE 0 END) - \n             SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END)) * 100.0 / \n            SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END)\n        ), 2)\n        ELSE NULL \n    END AS growth_rate\nFROM loan l\nINNER JOIN account a ON l.account_id = a.account_id\nINNER JOIN disp d ON a.account_id = d.account_id AND d.type = 'OWNER'\nINNER JOIN client c ON d.client_id = c.client_id\nWHERE c.gender = 'M' \nAND (strftime('%Y', l.date) IN ('1996', '1997')",
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN strftime('%Y', T4.date) = '1996' THEN T4.amount ELSE 0 END) > 0 \n        THEN CAST(\n            (SUM(CASE WHEN strftime('%Y', T4.date) = '1997' THEN T4.amount ELSE 0 END) - \n             SUM(CASE WHEN strftime('%Y', T4.date) = '1996' THEN T4.amount ELSE 0 END)\n        ) AS REAL) / \n             SUM(CASE WHEN strftime('%Y', T4.date) = '1996' THEN T4.amount ELSE 0 END) * 100 \n        ELSE NULL \n    END AS growth_rate\nFROM \n    loan T4\nINNER JOIN \n    account T1 ON T4.account_id = T1.account_id\nINNER JOIN \n    disp T2 ON T1.account_id = T2.account_id\nINNER JOIN \n    client T3 ON T2.client_id = T3.client_id\nWHERE \n    T3.gender = 'M' \n    AND T2.type = 'OWNER'",
            "SELECT \n    (SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - \n     SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS growth_rate\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T3 ON T2.account_id = T3.account_id\nINNER JOIN client T4 ON T3.client_id = T4.client_id\nWHERE T3.type = 'OWNER' \n    AND T4.gender = 'MALE'",
            "SELECT \n    (SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - \n     SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS growth_rate\nFROM \n    loan T1\n    INNER JOIN account T2 ON T1.account_id = T2.account_id\n    INNER JOIN disp T3 ON T2.account_id = T3.account_id\n    INNER JOIN client T4 ON T3.client_id = T4.client_id\nWHERE \n    T3.type = 'OWNER' \n    AND T4.gender = 'M'"
        ],
        "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for each year. Do add `INNER JOIN` on `disp` with `type = 'OWNER'` filter instead of omitting the owner requirement. Do move the gender filter to the main `WHERE` clause instead of using a CTE. Do calculate the growth rate directly with `CASE` expressions for each year's sum instead of subtracting CTE results. Do cast the difference to `REAL` for proper division instead of implicit integer division. Do remove the unnecessary CTE structure and cross join instead of using a more efficient single-pass aggregation. The amended query now correctly filters for owner accounts only and handles the percentage calculation with proper type casting.",
            "Do remove the CASE wrapper and directly compute the growth calculation instead of conditionally handling zero denominators. Do cast the numerator difference to REAL for proper decimal division instead of implicit integer division. Do move the `type = 'OWNER'` filter from the JOIN condition to the WHERE clause instead of keeping it in the ON predicate. Do remove the explicit year filter `strftime('%Y', l.date) IN ('1996', '1997')` since the CASE expressions already handle specific years instead of redundant filtering. Do simplify table aliases to T1, T2, T3, T4 instead of single letters for consistency. The amended query now correctly performs the growth rate calculation with proper numeric handling and streamlined filtering.",
            "Do use `T1` as the loan table alias instead of `T4` and reference `T1.date` instead of `T4.date` in all date calculations. Do simplify the CASE expression by removing the conditional check for 1996 data presence and directly calculate the growth rate formula instead of wrapping it in a conditional. Do change the mathematical operation order to perform multiplication before division instead of division before multiplication. Do use table aliases `T2` for account, `T3` for disp, and `T4` for client instead of the original `T1`, `T2`, and `T3` assignments. Do reference `T3.type` in the WHERE clause instead of `T2.type` to match the corrected table alias assignments. Do remove the column alias `growth_rate` instead of keeping it for a cleaner single-value output. The amended query now correctly calculates the growth rate without unnecessary conditional logic and with proper table alias references.",
            "Do cast the difference calculation as `REAL` instead of performing direct arithmetic on integer values to ensure proper decimal division. Do use `T4.gender = 'M'` instead of `T4.gender = 'MALE'` to match the correct gender code format. Do adjust the join condition between `disp` and `account` tables to use `T3.account_id = T2.account_id` instead of `T2.account_id = T3.account_id` for proper relationship direction. Do remove the alias `growth_rate` from the calculation instead of keeping it to match the output format. The amended query now correctly calculates the percentage growth with proper type casting and accurate join relationships."
        ],
        "rules": [
            "Growth rate = (sum of amount_1997 - sum of amount_1996) / (sum of amount_1996) * 100%; Male refers to gender = 'M'"
        ]
    },
    "952": {
        "sql": [
            "SELECT DISTINCT c.name \nFROM constructors c \nJOIN constructorStandings cs ON c.constructorId = cs.constructorId \nWHERE cs.position = 1;",
            "SELECT DISTINCT T2.name \nFROM results T1 \nJOIN constructors T2 ON T1.constructorId = T2.constructorId \nWHERE T1.rank = 1"
        ],
        "question": "Which constructors have been ranked 1?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.rank = 1",
        "amends": [
            "Do join `results` instead of `constructorStandings` as the source table. Do use `T1.constructorId = T2.constructorId` instead of `c.constructorId = cs.constructorId` for the join condition. Do filter on `T1.rank = 1` instead of `cs.position = 1` for the winning condition. Do reference `T2.name` instead of `c.name` in the SELECT list while maintaining the DISTINCT modifier. The amended query now correctly identifies constructors with winning race results rather than constructor championship standings."
        ],
        "rules": []
    },
    "199": {
        "sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE a.element = 'na' AND m.label = '-';"
        ],
        "question": "In the molecule containing sodium atoms, how many are non-carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'na' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "non-carcinogenic refers to label = '-'; sodium atoms refers to element = 'na'"
        ]
    },
    "540": {
        "sql": [
            "SELECT p.Title\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie'\nORDER BY p.ViewCount DESC\nLIMIT 1;"
        ],
        "question": "What is the title of the post that is owned by csgillespie and has the highest popularity?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' ORDER BY T1.ViewCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; highest popularity refers to Max(ViewCount)"
        ]
    },
    "384": {
        "sql": [
            "SELECT DISTINCT l.uuid, fd.language\nFROM legalities l\nJOIN foreign_data fd ON l.uuid = fd.uuid\nWHERE l.format = 'legacy' AND l.status = 'legal';",
            "SELECT T1.uuid, T3.language\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nINNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid\nWHERE T2.format = 'legacy'"
        ],
        "question": "List down the uuid for legacy cards and the foreign language of these cards.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'",
        "amends": [
            "Do add the `cards` table as the primary source instead of omitting it, and use `INNER JOIN` with `cards AS T1` instead of starting directly from `legalities`. Do change the join structure to connect `legalities AS T2` and `foreign_data AS T3` both to `cards` instead of joining `legalities` directly to `foreign_data`. Do remove the `DISTINCT` modifier instead of keeping it, and do remove the `l.status = 'legal'` filter condition instead of including it. Do use table aliases `T1`, `T2`, and `T3` consistently instead of the original `l` and `fd` aliases. The amended query now correctly retrieves card data through the proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "legacy card refers to format = 'legacy'; foreign language refers to language in foreign_data"
        ]
    },
    "469": {
        "sql": [
            "SELECT DISTINCT CASE WHEN s.mtgoCode IS NOT NULL THEN 'Yes' ELSE 'No' END AS appeared_on_mtgo\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE c.name = 'Angel of Mercy';",
            "SELECT IIF(COUNT(*) > 0, 'YES', 'NO') AS appears_on_mtgo\nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Angel of Mercy' AND T2.mtgoCode IS NOT NULL;",
            "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards T1 INNER JOIN sets T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'"
        ],
        "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
        "amends": [
            "Do use `IIF` function with uppercase 'YES'/'NO' instead of `CASE WHEN` with 'Yes'/'No' for the conditional logic. Do remove `DISTINCT` instead of keeping it since the join condition ensures uniqueness. Do use table aliases `T1` and `T2` instead of full table names `c` and `s`. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reverse the join condition to `T2.code = T1.setCode` instead of `c.setCode = s.code` while maintaining the same logical relationship. The amended query now correctly returns the MTGO appearance status without unnecessary DISTINCT and with consistent conditional formatting.",
            "Do check `T2.mtgoCode IS NOT NULL` directly in the `SELECT` expression instead of using `COUNT(*) > 0` to determine the result. Do remove the `WHERE` condition `T2.mtgoCode IS NOT NULL` since it's now handled in the `SELECT` clause instead of filtering rows. Do omit the `AS appears_on_mtgo` alias from the `SELECT` list instead of including it. The amended query now correctly evaluates the mtgoCode presence directly for each matching row rather than counting filtered results, ensuring accurate boolean determination for the specified card name."
        ],
        "rules": [
            "card set \"Angel of Mercy\" refers to name = 'Angel of Mercy'; appear on Magic: The Gathering Online refers to mtgoCode is NOT NULL and vice versa"
        ]
    },
    "1093": {
        "sql": [
            "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nJOIN Player ON Player_Attributes.player_api_id = Player.player_api_id\nWHERE strftime('%Y', Player.birthday) < '1986';",
            "SELECT SUM(t2.overall_rating) / COUNT(t1.id) AS average_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE SUBSTR(t1.birthday, 1, 4) < '1986'"
        ],
        "question": "What is the average overall rating of the players born before the year 1986?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.overall_rating) / COUNT(t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) < '1986'",
        "amends": [
            "Do use `SUM(t2.overall_rating) / COUNT(t1.id)` instead of `AVG(overall_rating)` to calculate the average while avoiding NULL values in the denominator. Do specify `Player AS t1` and `Player_Attributes AS t2` instead of using unaliased table names. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `t1.player_api_id = t2.player_api_id` instead of `Player_Attributes.player_api_id = Player.player_api_id` with proper table aliases. Do use `SUBSTR(t1.birthday, 1, 4) < '1986'` instead of `strftime('%Y', Player.birthday) < '1986'` for SQLite-compatible year extraction. The amended query now correctly handles the average calculation and uses proper SQLite date functions to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "average overall rating = DIVIDE(SUM(overall_rating), COUNT(id)); born before the year 1986 refers to strftime('%Y', birthday) < '1986';"
        ]
    },
    "1107": {
        "sql": [
            "WITH KevinConstant AS (\n    SELECT player_api_id\n    FROM Player\n    WHERE player_name = 'Kevin Constant'\n),\nMaxCrossing AS (\n    SELECT MAX(crossing) AS max_crossing\n    FROM Player_Attributes\n    WHERE player_api_id IN (SELECT player_api_id FROM KevinConstant)\n)\nSELECT MIN(date) AS first_date\nFROM Player_Attributes\nWHERE player_api_id IN (SELECT player_api_id FROM KevinConstant)\nAND crossing = (SELECT max_crossing FROM MaxCrossing);",
            "SELECT pa.date\nFROM Player_Attributes pa\nINNER JOIN Player p ON pa.player_fifa_api_id = p.player_fifa_api_id\nWHERE p.player_name = 'Kevin Constant'\nORDER BY pa.crossing DESC, pa.date DESC\nLIMIT 1;",
            "SELECT date\nFROM Player_Attributes t2\nINNER JOIN Player t1 ON t2.player_fifa_api_id = t1.player_fifa_api_id\nWHERE t1.player_name = 'Kevin Constant'\nORDER BY t2.crossing DESC, t2.date DESC\nLIMIT 1;",
            "SELECT t2.date\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\nWHERE t1.player_name = 'Kevin Constant'\nORDER BY t2.crossing DESC, t2.date DESC\nLIMIT 1;",
            "SELECT date\nFROM (\n    SELECT t2.crossing, t2.date\n    FROM Player t1\n    INNER JOIN Player_Attributes t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\n    WHERE t1.player_name = 'Kevin Constant'\n    ORDER BY t2.crossing DESC\n)\nORDER BY date DESC\nLIMIT 1;"
        ],
        "question": "When was the first time did Kevin Constant have his highest crossing score? Give the date.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT `date` FROM ( SELECT t2.crossing, t2.`date` FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Kevin Constant' ORDER BY t2.crossing DESC) ORDER BY date DESC LIMIT 1",
        "amends": [
            "Do use `player_fifa_api_id` for joining instead of `player_api_id` to ensure proper table relationships. Do join `Player` and `Player_Attributes` tables directly with `INNER JOIN` instead of using CTEs and subqueries for filtering. Do select the actual `date` column instead of using `MIN(date)` to find the earliest date. Do order by `crossing DESC` to get the highest crossing value instead of using a separate CTE to calculate `MAX(crossing)`. Do add `LIMIT 1` with `ORDER BY date DESC` to get the most recent date with the maximum crossing instead of finding the first occurrence. Do remove the unnecessary `KevinConstant` and `MaxCrossing` CTEs instead of maintaining complex subquery structures. The amended query now correctly retrieves the most recent date when Kevin Constant achieved his maximum crossing rating, matching the RIGHT_SQL's behavior.",
            "Do use a subquery to first select `crossing` and `date` with ordering by `crossing DESC` instead of directly ordering by both `crossing DESC` and `date DESC` in the main query. Do reference the subquery result's `date` column in the outer query's `ORDER BY` instead of ordering by `pa.date DESC` in the main query. Do remove the explicit table alias `pa` from the `SELECT` clause and use just `date` instead of `pa.date`. Do add table aliases `t1` for `Player` and `t2` for `Player_Attributes` instead of using `p` and `pa`. Do maintain the same `INNER JOIN` on `player_fifa_api_id` and `WHERE` filter for `player_name = 'Kevin Constant'` instead of changing the join logic. The amended query now correctly prioritizes finding the record with the highest crossing value first, then returns the most recent date among those top crossing records, matching the RIGHT_SQL's behavior.",
            "Do use a subquery to first select `crossing` and `date` columns instead of selecting only `date` directly. Do move the `ORDER BY t2.crossing DESC` into the subquery instead of having it in the outer query. Do keep the final `ORDER BY date DESC` in the outer query instead of ordering by both `crossing` and `date` in a single clause. Do maintain the same `INNER JOIN` on `player_fifa_api_id` and the same `WHERE` filter for `player_name = 'Kevin Constant'` instead of changing the join conditions or filters. Do preserve the `LIMIT 1` to return only one record instead of modifying the result set size. The amended query now correctly prioritizes finding the record with the highest crossing value first, then returns the most recent date among those top crossing performances, matching the RIGHT_SQL's behavior.",
            "Do select only `date` from a subquery instead of selecting `t2.date` directly from the main query. Do include `t2.crossing` in the subquery's SELECT list instead of omitting it, as it's needed for the ordering. Do move the `ORDER BY t2.crossing DESC` into the subquery instead of having it in the outer query, and do add an outer `ORDER BY date DESC` instead of ordering by both `t2.crossing DESC` and `t2.date DESC` in the same clause. This ensures the query correctly retrieves the most recent date for the player with the highest crossing attribute value, rather than potentially returning an arbitrary row that happens to have the highest crossing value but not necessarily the most recent date for that crossing value."
        ],
        "rules": [
            "Kevin Constant refers to player_name = 'Kevin Constant'; highest crossing score refers to MAX(crossing)"
        ]
    },
    "591": {
        "sql": [
            "SELECT COUNT(DISTINCT UserId) AS NumberOfUsers\nFROM badges\nWHERE Name = 'Supporter' AND strftime('%Y', Date) = '2011';"
        ],
        "question": "How many users are awarded with supporter badge during year 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE STRFTIME('%Y', Date) = '2011' AND Name = 'Supporter'",
        "amends": [],
        "rules": [
            "\"Supporter\" is the Name of badge; in year 2011 refers to year(Date) = 2011"
        ]
    },
    "767": {
        "sql": [
            "SELECT COUNT(*) * 1.0 / SUM(CASE WHEN skin_colour_id = 1 THEN 1 ELSE 0 END) AS average_no_skin_colour\nFROM superhero;"
        ],
        "question": "What is the average of superheroes with no skin colour?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id",
        "amends": [],
        "rules": [
            "average = DIVIDE(COUNT(superhero.id), SUM(skin_colour_id = 1)); no skin colour refers to skin_colour_id WHERE colour.id = 1;"
        ]
    },
    "210": {
        "sql": [
            "SELECT a1.atom_id AS atom1_id, a1.element AS atom1_element, a2.atom_id AS atom2_id, a2.element AS atom2_element\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = '-';",
            "SELECT T2.atom_id, T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '-'"
        ],
        "question": "What atoms are connected in single type bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "amends": [
            "Do select `T2.atom_id` and `T2.atom_id2` instead of selecting `a1.atom_id`, `a1.element`, `a2.atom_id`, and `a2.element`. Do use `INNER JOIN` between `bond AS T1` and `connected AS T2` on `T1.bond_id = T2.bond_id` instead of joining `connected c` with `bond b` and then joining with `atom a1` and `atom a2`. Do remove the unnecessary joins with `atom` table instead of keeping them. Do keep the filter `WHERE T1.bond_type = '-'` instead of filtering on the same condition. The amended query now correctly retrieves only the connected atom pairs for single bonds without the unnecessary element information and extra table joins, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "single type bond refers to bond_type = '-';"
        ]
    },
    "1527": {
        "sql": [
            "SELECT g.GasStationID, g.Country, g.Segment, SUM(t.Amount * t.Price) AS TotalRevenue\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nGROUP BY g.GasStationID, g.Country, g.Segment\nORDER BY TotalRevenue DESC\nLIMIT 1;",
            "SELECT GasStationID FROM transactions_1k GROUP BY GasStationID ORDER BY SUM(Price) DESC LIMIT 1;"
        ],
        "question": "Which gas station has the highest amount of revenue?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT GasStationID FROM transactions_1k GROUP BY GasStationID ORDER BY SUM(Price) DESC LIMIT 1",
        "amends": [
            "Do select only `GasStationID` instead of including `Country`, `Segment`, and `TotalRevenue` alias. Do use `FROM transactions_1k` alone instead of joining with `gasstations` table. Do aggregate with `SUM(Price)` instead of `SUM(t.Amount * t.Price)`. Do group by only `GasStationID` instead of grouping by multiple columns. Do order by `SUM(Price)` directly instead of ordering by an alias. The amended query now correctly identifies the gas station with highest total price revenue from transactions alone."
        ],
        "rules": []
    },
    "637": {
        "sql": [
            "WITH MarkMeckesPosts AS (\n    SELECT Id, Tags\n    FROM posts\n    WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Mark Meckes')\n    AND CommentCount = 0\n)\nSELECT DISTINCT REPLACE(REPLACE(REPLACE(t.value, '<', ''), '>', ''), ' ', '') AS Tag\nFROM MarkMeckesPosts,\n     json_each('[\"' || REPLACE(REPLACE(Tags, '<', '\",\"'), '>', '\",\"') || '\"]') AS t\nWHERE t.value <> '';",
            "SELECT DISTINCT T3.Tags\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T3.Id = T2.PostId\nWHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0 AND T3.Tags IS NOT NULL AND T3.Tags != '';",
            "SELECT T3.Tags\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T3.Id = T2.PostId\nWHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
        "amends": [
            "Do use `INNER JOIN` with `users` and `postHistory` on `T1.Id = T2.UserId` instead of a CTE with a subquery for user lookup. Do add `INNER JOIN` with `posts` on `T3.Id = T2.PostId` instead of querying `posts` directly. Do select `T3.Tags` directly instead of complex JSON parsing with `REPLACE` and `json_each`. Do remove the `DISTINCT` clause and JSON manipulation instead of keeping them. Do move the `CommentCount = 0` filter to the `WHERE` clause instead of the CTE. Do remove the empty value filter instead of keeping it. The amended query now correctly retrieves tags from posts through the proper join relationships instead of attempting to parse malformed tag strings.",
            "Do remove `DISTINCT` instead of keeping it, and do remove the filters `T3.Tags IS NOT NULL` and `T3.Tags != ''` instead of including them, while keeping the same `SELECT T3.Tags` column, `FROM` sources with `INNER JOIN` on `T1.Id = T2.UserId` and `T3.Id = T2.PostId`, and `WHERE` filters for `T1.DisplayName = 'Mark Meckes'` and `T3.CommentCount = 0`. The amended query now matches RIGHT_SQL's behavior by eliminating unnecessary distinct processing and redundant null/empty string checks on the Tags column."
        ],
        "rules": [
            "used by Mark Meckes refers to DisplayName = 'Mark Meckes'; Doen't have comments refers to CommentCount = 0;"
        ]
    },
    "405": {
        "sql": [
            "SELECT COUNT(DISTINCT s.code) AS brazilian_portuguese_translated_sets\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Commander' AND st.language = 'Portuguese (Brasil)'",
            "SELECT COUNT(T1.id) \nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.block = 'Commander' \nAND T2.language = 'Portuguese (Brazil)'"
        ],
        "question": "How many Brazilian Portuguese translated sets are inside the Commander block?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(DISTINCT s.code)` to count set IDs rather than distinct set codes. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `s` and `st` for consistency. Do correct the language filter to `'Portuguese (Brazil)'` instead of `'Portuguese (Brasil)'` to match the proper localization. Do maintain the `T1.block = 'Commander'` filter in the WHERE clause instead of changing its position. The amended query now correctly counts Portuguese Brazilian translated Commander sets by fixing the language specification and counting methodology."
        ],
        "rules": [
            "Commander block refer to block = 'Commander'; sets refer to code = setCode; Portuguese refer to language = 'Portuguese (Brasil)'"
        ]
    },
    "1519": {
        "sql": [
            "SELECT ProductID FROM transactions_1k WHERE Date = '2012-08-23' AND Time = '21:20:00';"
        ],
        "question": "What was the product id of the transaction happened at 2012/8/23 21:20:00?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.ProductID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'",
        "amends": [],
        "rules": [
            "'2012/8/23 21:20:00' can refer to date = '2012-08-23' AND T1.time = '21:20:00' in the database"
        ]
    },
    "1330": {
        "sql": [
            "SELECT m.college\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Tyler' AND mb.last_name = 'Hewitt';"
        ],
        "question": "What college offers the major that Tyler Hewitt took?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'",
        "amends": [],
        "rules": []
    },
    "1412": {
        "sql": [
            "SELECT DISTINCT e.expense_description\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE m.t_shirt_size = 'X-Large';"
        ],
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "amends": [],
        "rules": [
            "kind of expenses refers to expense_description; t_shirt_size = 'X-Large'"
        ]
    },
    "230": {
        "sql": [
            "SELECT a.element, m.label FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR060';"
        ],
        "question": "What are the elements of the toxicology and label of molecule TR060?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'",
        "amends": [],
        "rules": [
            "TR060 is the molecule id; "
        ]
    },
    "327": {
        "sql": [
            "SELECT m.molecule_id, m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '-'\nGROUP BY m.molecule_id, m.label\nHAVING COUNT(a.atom_id) > 5;",
            "SELECT T1.molecule_id\nFROM molecule T1\nINNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.label != 'carcinogenic'\nGROUP BY T1.molecule_id\nHAVING COUNT(T2.atom_id) > 5",
            "SELECT molecule_id FROM (SELECT T1.molecule_id, COUNT(T2.atom_id) AS atom_count FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING atom_count > 5) AS t"
        ],
        "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
        "amends": [
            "Do select only `molecule_id` instead of including `label` in the SELECT list. Do use table aliases `T1` and `T2` instead of `m` and `a`. Do wrap the query in a subquery with alias `T` instead of querying directly. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do group by only `molecule_id` instead of both `molecule_id` and `label`. Do reference `T2.atom_id` in the COUNT instead of `a.atom_id`. Do remove the redundant `m.label` from GROUP BY since it's filtered in WHERE. The amended query now correctly returns only molecule IDs meeting the criteria without redundant columns.",
            "Do use a subquery with `T1.molecule_id` and `COUNT(T2.atom_id)` in the SELECT list instead of only selecting `T1.molecule_id`. Do change the WHERE filter to `T1.label = '-'` instead of `T1.label != 'carcinogenic'`. Do alias the subquery as `t` instead of omitting the alias. Do remove the explicit table alias `T1` and `T2` from the outer query's SELECT clause instead of keeping them. The amended query now correctly filters for molecules with a dash label and counts atoms within a subquery structure, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; molecules consisted more than 5 atoms refers to COUNT(molecule_id) > 5"
        ]
    },
    "445": {
        "sql": [
            "SELECT fd.language, fd.flavorText, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'colorpie';",
            "SELECT DISTINCT T1.language, T1.flavorText\nFROM foreign_data T1\nINNER JOIN cards T2 ON T2.uuid = T1.uuid\nWHERE T2.watermark = 'colorpie'"
        ],
        "question": "What is the language and flavor text of the card that has colorpie watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.language, T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'colorpie'",
        "amends": [
            "Do use `DISTINCT` to eliminate duplicate rows instead of omitting it. Do select only `language` and `flavorText` columns instead of including `c.type`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do specify the join condition as `T2.uuid = T1.uuid` instead of `c.uuid = fd.uuid`. Do remove the table alias from the `watermark` filter instead of keeping it. The amended query now correctly returns distinct language and flavor text combinations for cards with the specified watermark."
        ],
        "rules": []
    },
    "152": {
        "sql": [
            "SELECT AVG(d.A15) AS average_crimes_1995\nFROM district d\nJOIN account a ON d.district_id = a.district_id\nWHERE d.A15 > 4000\nAND a.date >= '1997-01-01';"
        ],
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "amends": [],
        "rules": [
            "A3 refers to region names; A15 stands for the average number of crimes commited in 1995."
        ]
    },
    "543": {
        "sql": [
            "SELECT MAX(AnswerCount) AS MaxAnswerCount\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');"
        ],
        "question": "For the post that got the most number of answers owned by csgillespie, how many answers did it get?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT MAX(T1.AnswerCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; the most number of answer refers to Max(AnswerCount)"
        ]
    },
    "813": {
        "sql": [
            "SELECT AVG(ha.attribute_value) AS average_attribute_value\nFROM superhero sh\nJOIN hero_attribute ha ON sh.id = ha.hero_id\nWHERE sh.alignment_id = 3;"
        ],
        "question": "Calculate the average attribute value of all neutral superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.attribute_value) FROM hero_attribute AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id INNER JOIN alignment AS T3 ON T2.alignment_id = T3.id WHERE T3.alignment = 'Neutral'",
        "amends": [],
        "rules": [
            "average = AVG(attribute_value); neutral superheroes refers to alignment_id = 3;"
        ]
    },
    "225": {
        "sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = ' = '\nORDER BY m.label ASC\nLIMIT 5;",
            "SELECT DISTINCT molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY molecule_id LIMIT 5"
        ],
        "question": "Please list top five molecules that have double bonds in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id LIMIT 5",
        "amends": [
            "Do select only `T.molecule_id` instead of including `m.label` and remove the alias prefix. Do use `FROM bond AS T` instead of joining with `molecule` table. Do change the filter to `T.bond_type = '='` instead of `' = '` with spaces. Do remove the `ORDER BY m.label ASC` clause instead of keeping it and change to `ORDER BY T.molecule_id` without direction. Do keep `LIMIT 5` and `DISTINCT` as they are correctly preserved. The amended query now correctly focuses on bond table data only without unnecessary molecule table joins and label ordering."
        ],
        "rules": [
            "double bond refers to bond_type = ' = ';"
        ]
    },
    "1005": {
        "sql": [
            "SELECT d.forename, d.surname, MAX(p.duration) AS longest_pitstop_duration\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId;",
            "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1;"
        ],
        "question": "What was the longest time a driver had ever spent at a pit stop?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1",
        "amends": [
            "Do select only `duration` instead of `d.forename`, `d.surname`, and `MAX(p.duration)` with an alias. Do use a single table `pitStops` instead of joining with `drivers d` on `p.driverId = d.driverId`. Do remove the aggregation function `MAX` and instead use `ORDER BY duration DESC` with `LIMIT 1` to find the maximum value. Do omit the `GROUP BY` clause entirely instead of having an implicit grouping. The amended query now correctly returns the single longest pitstop duration without unnecessary driver information and joins."
        ],
        "rules": [
            "longest time spent at pitstop refers to MAX(duration)"
        ]
    },
    "511": {
        "sql": [
            "SELECT frameEffects, COUNT(frameEffects) AS effect_count\nFROM cards\nWHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL\nGROUP BY frameEffects\nORDER BY effect_count DESC\nLIMIT 1;",
            "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1;"
        ],
        "question": "What is the most common visual frame effects among the incredibly powerful foils?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1",
        "amends": [
            "Do remove the `COUNT(frameEffects) AS effect_count` column from the SELECT list instead of including it, and do move the aggregate function `COUNT(frameEffects)` directly into the ORDER BY clause instead of referencing the alias `effect_count`. Do keep the same FROM source `cards`, WHERE filters `cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL`, GROUP BY clause `frameEffects`, and LIMIT 1, but do reference the aggregate function directly in ORDER BY instead of using the column alias. The amended query now correctly orders by the actual count value rather than an aliased column that would not be available in the ORDER BY clause of the original query structure, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "when both cardKingdomFoilId and cardKingdomId are not null, this foil is incredibly powerful; most common visual frame effects refers to MAX(frameEffects)"
        ]
    },
    "821": {
        "sql": [
            "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Ajax';"
        ],
        "question": "List down Ajax's superpowers.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Ajax'",
        "amends": [],
        "rules": [
            "Ajax refers to superhero_name = 'Ajax'; superpowers refers to power_name;"
        ]
    },
    "1092": {
        "sql": [
            "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2008/2009'\nGROUP BY m.league_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT t1.name\nFROM League AS t1\nJOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2008/2009'\nGROUP BY t1.name\nHAVING COUNT(t2.id) = (\n    SELECT MAX(match_count)\n    FROM (\n        SELECT COUNT(t2.id) AS match_count\n        FROM Match AS t2\n        WHERE t2.season = '2008/2009'\n        GROUP BY t2.league_id\n    )\n)"
        ],
        "question": "Give the name of the league had the most matches in the 2008/2009 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
        "amends": [
            "Do select `t1.name` instead of `l.name AS league_name` and remove the alias. Do use `League AS t1` and `Match AS t2` instead of `Match m` and `League l` with different aliases. Do change the join condition to `t1.id = t2.league_id` instead of `m.league_id = l.id` but keep the same logic. Do keep the `WHERE t2.season = '2008/2009'` filter unchanged. Do change `GROUP BY m.league_id` to `GROUP BY t1.name` instead of grouping by ID. Do replace `ORDER BY COUNT(*) DESC LIMIT 1` with a `HAVING COUNT(t2.id) =` subquery that finds the maximum match count per league instead of just taking the top result. Do add a correlated subquery `(SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))` to properly identify leagues with the exact maximum number of matches instead of potentially missing ties. The amended query now correctly handles multiple leagues with the same maximum match count and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "league that had the most matches in the 2008/2009 season refers to MAX(league_name WHERE season = '2008/2009');"
        ]
    },
    "99": {
        "sql": [
            "SELECT a.account_id, a.date AS account_opening_date, l.amount AS approved_loan_amount\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.duration > 12\nAND strftime('%Y', a.date) = '1993'\nORDER BY l.amount DESC\nLIMIT 1;",
            "SELECT T1.account_id\nFROM account T1\nINNER JOIN loan T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T2.date) = '1993'\nAND T2.duration > 12\nORDER BY T1.amount DESC\nLIMIT 1;",
            "SELECT T1.account_id\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T2.date) = '1993'\nAND T1.duration > 12\nORDER BY T1.amount DESC\nLIMIT 1;"
        ],
        "question": "Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1",
        "amends": [
            "Do select only `account_id` instead of including `account_opening_date` and `approved_loan_amount`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `a` and `l`. Do place the `STRFTIME` filter on `T2.date` before the `duration` filter instead of after it. Do order by `T1.amount` instead of `l.amount`. The amended query now correctly returns only the account_id with the highest loan amount from 1993 accounts with loans longer than 12 months, matching the intended behavior.",
            "Do use `loan AS T1` as the primary table instead of `account T1` and join with `account AS T2` instead of `loan T2`, reversing the join direction. Do apply the duration filter on `T1.duration` instead of `T2.duration` to reference the correct table. Do maintain the same `STRFTIME` condition on `T2.date`, `ORDER BY T1.amount DESC`, and `LIMIT 1` as these remain functionally equivalent. The amended query now correctly filters duration from the loan table and maintains the proper table relationships to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Loan validity more than 12 months refers to duration > 12"
        ]
    },
    "743": {
        "sql": [
            "WITH total_superheroes AS (\n    SELECT COUNT(*) AS total_count FROM superhero\n),\nbad_superheroes AS (\n    SELECT COUNT(*) AS bad_count FROM superhero\n    JOIN alignment ON superhero.alignment_id = alignment.id\n    WHERE alignment.alignment = 'Bad'\n),\nmarvel_bad_superheroes AS (\n    SELECT COUNT(*) AS marvel_bad_count FROM superhero\n    JOIN alignment ON superhero.alignment_id = alignment.id\n    JOIN publisher ON superhero.publisher_id = publisher.id\n    WHERE alignment.alignment = 'Bad' AND publisher.publisher_name = 'Marvel Comics'\n)\nSELECT \n    (bad_superheroes.bad_count * 100.0 / total_superheroes.total_count) AS percentage_bad,\n    marvel_bad_superheroes.marvel_bad_count AS marvel_bad_count\nFROM \n    total_superheroes, \n    bad_superheroes, \n    marvel_bad_superheroes;"
        ],
        "question": "What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT (CAST(COUNT(*) AS REAL) * 100 / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE T3.alignment = 'Bad'",
        "amends": [],
        "rules": [
            "published by Marvel Comics refers to publisher_name = 'Marvel Comics'; superheroes who act in their own self-interest or make decisions based on their own moral code refers to alignment = 'Bad'; calculation = MULTIPLY(DIVIDE(SUM(alignment = 'Bad); count(id)), 100)"
        ]
    },
    "1461": {
        "sql": [
            "SELECT m.last_name, m.phone\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Elementary Education';"
        ],
        "question": "List the last names of students under the Elementary Education major and include their phone numbers.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.last_name, T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T2.major_name = 'Elementary Education'",
        "amends": [],
        "rules": [
            "'Elementary Education' is the major name; phone numbers refers to phone"
        ]
    },
    "3": {
        "sql": [
            "SELECT s.MailStreet\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE f.\"FRPM Count (K-12)\" = (SELECT MAX(\"FRPM Count (K-12)\") FROM frpm);"
        ],
        "question": "What is the unabbreviated mailing street address of the school with the highest FRPM count for K-12 students?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.MailStreet FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 1",
        "amends": [],
        "rules": []
    },
    "324": {
        "sql": [
            "SELECT (SUM(CASE WHEN bond_type = '-' THEN 1 ELSE 0 END) * 100.0 / COUNT(bond_id)) AS percentage_single_bonds FROM bond;"
        ],
        "question": "Find the percentage of atoms with single bond.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond t",
        "amends": [],
        "rules": [
            "single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(bond_type = '-'), COUNT(bond_id)) as percentage"
        ]
    },
    "548": {
        "sql": [
            "SELECT u.Location\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Title = 'Eliciting priors from experts';"
        ],
        "question": "What is the location of the owner of the post \"Eliciting priors from experts\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'",
        "amends": [],
        "rules": [
            "Owner refers to OwnerUserId; 'Eliciting priors from experts' is the Title of post"
        ]
    },
    "208": {
        "sql": [
            "SELECT m.label, COUNT(*) AS count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'h'\nGROUP BY m.label\nORDER BY count DESC\nLIMIT 1;",
            "SELECT T.label\nFROM (\n    SELECT T1.molecule_id, COUNT(T2.molecule_id) AS hydrogen_count\n    FROM atom AS T1\n    INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T1.element = 'H'\n    GROUP BY T1.molecule_id\n) AS t\nINNER JOIN molecule AS T ON t.molecule_id = T.molecule_id\nORDER BY hydrogen_count DESC\nLIMIT 1",
            "SELECT T.label\nFROM (\n    SELECT T2.label, COUNT(T2.molecule_id) AS count\n    FROM atom T1\n    INNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T1.element = 'h'\n    GROUP BY T2.label\n    ORDER BY COUNT(T2.molecule_id) DESC\n    LIMIT 1\n) t"
        ],
        "question": "Which type of label is the most numerous in atoms with hydrogen?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t",
        "amends": [
            "Do use a subquery with explicit table aliases `T1` and `T2` instead of direct table references. Do select only `T.label` in the outer query instead of both `m.label` and `COUNT(*) AS count`. Do use `COUNT(T2.molecule_id)` instead of `COUNT(*)` to count specific non-null values. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do wrap the entire grouped query in a subquery and alias it as `t` instead of selecting directly from the grouped result. Do reference the count column in `ORDER BY` as `COUNT(T2.molecule_id)` instead of the alias `count`. The amended query now correctly returns only the label of the molecule with the highest hydrogen atom count.",
            "Do include `T2.label` in the SELECT list and GROUP BY clause instead of omitting it from the subquery. Do change the WHERE filter to use lowercase `'h'` instead of uppercase `'H'` for the element comparison. Do remove the unnecessary outer query and join with the molecule table instead of keeping the redundant structure. Do move the ORDER BY and LIMIT clauses inside the subquery instead of placing them in the outer query. Do change the aggregate function to count `T2.molecule_id` directly instead of using an alias that references the wrong table. The amended query now correctly counts hydrogen atoms per molecule label and returns the label with the highest count, matching the intended behavior."
        ],
        "rules": [
            "with hydrogen refers to element = 'h'; label most numerous in atoms refers to MAX(COUNT(label)); "
        ]
    },
    "675": {
        "sql": [
            "SELECT COUNT(*) FROM users WHERE Reputation > 2000 AND Views > 1000;"
        ],
        "question": "How many users whose reputations are higher than 2000 and the number of views is higher than 1000?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Reputation > 2000 AND Views > 1000",
        "amends": [],
        "rules": [
            "reputations are higher than 2000 refer to Reputation > 2000; number of views is higher than 1000 refers to Views > 1000;"
        ]
    },
    "1292": {
        "sql": [
            "SELECT e.\"aCL IgG\", e.\"aCL IgM\", e.\"aCL IgA\"\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE p.SEX = 'F'\n  AND l.UA = (SELECT MAX(UA) FROM Laboratory WHERE UA > 6.50 AND ID IN (SELECT ID FROM Patient WHERE SEX = 'F'))\nLIMIT 1;",
            "SELECT T3.\"aCL IgG\", T3.\"aCL IgM\", T3.\"aCL IgA\" \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nJOIN Examination T3 ON T2.ID = T3.ID \nWHERE T1.SEX = 'F' AND T2.UA > 6.5 \nORDER BY T2.UA DESC \nLIMIT 1"
        ],
        "question": "What is the anti Cardiolipin antibody concentration of the female patient with the highest uric acid level in the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T1.SEX = 'F' AND T2.UA > 6.5 ORDER BY T2.UA DESC LIMIT 1",
        "amends": [
            "Do use `T3` aliases for column references instead of direct table references. Do change the join condition from `p.ID = e.ID` to `T3.ID = T2.ID` to properly connect Examination to Laboratory instead of directly to Patient. Do replace the complex subquery with a simple `T2.UA > 6.5` filter instead of the nested maximum calculation. Do add `ORDER BY T2.UA DESC` to find the highest UA value instead of relying on a subquery maximum. Do remove the unnecessary subqueries and nested ID lookups instead of maintaining the complex structure. The amended query now correctly retrieves the examination results for female patients with the highest UA value above 6.5, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "anti Cardiolipin antibody concentration refers to `aCL IgG`, `aCL IgM`, `aCL IgA`; female patient refers to Sex = F'; highest uric acid level in the normal range refers to MAX(UA > 6.50);"
        ]
    },
    "942": {
        "sql": [
            "WITH hamilton_races AS (\n    SELECT d.driverId, r.raceId, res.fastestLapTime\n    FROM drivers d\n    JOIN results res ON d.driverId = res.driverId\n    JOIN races r ON res.raceId = r.raceId\n    WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\n    AND res.fastestLapTime IS NOT NULL\n)\nSELECT AVG(\n    CAST(SUBSTR(fastestLapTime, 1, 2) AS INTEGER) * 60 + -- minutes to seconds\n    CAST(SUBSTR(fastestLapTime, 4, 2) AS INTEGER) + -- seconds\n    CAST(SUBSTR(fastestLapTime, 7, 3) AS REAL) / 1000 -- milliseconds to seconds\n) AS average_fastest_lap_seconds\nFROM hamilton_races;",
            "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS REAL) * 60 + \n       CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) AS avg_fastest_lap_seconds\nFROM results T2\nINNER JOIN drivers T1 ON T2.driverId = T1.driverId\nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL;"
        ],
        "question": "What is the average fastest lap time in seconds for Lewis Hamilton in all the Formula_1 races?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.surname = 'Hamilton' AND T1.forename = 'Lewis'",
        "amends": [
            "Do use `INNER JOIN` instead of multiple explicit joins, and reference `T2.fastestLapTime` directly instead of through a CTE. Do parse the time format dynamically using `INSTR` to locate the colon position instead of fixed substring positions, which handles variable-length minute components. Do remove the CTE wrapper and move the filtering directly into the main query's `WHERE` clause instead of separating it. Do simplify the time conversion by combining seconds and milliseconds in a single `CAST` operation instead of separate conversions. Do eliminate the explicit `races` table join since it's not needed for the calculation. The amended query now correctly handles variable time formats and produces the same average fastest lap time calculation."
        ],
        "rules": [
            "average fastest lap time = avg(fastestLapTime); The time is recorded on 'MM:SS.mmm'"
        ]
    },
    "360": {
        "sql": [
            "SELECT DISTINCT st.language\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode\nWHERE c.name = 'Angel of Mercy';",
            "SELECT language FROM set_translations WHERE id IN (SELECT id FROM cards WHERE name = 'Angel of Mercy')"
        ],
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "amends": [
            "Do remove the `DISTINCT` keyword instead of keeping it. Do change the SELECT list to only `language` instead of `st.language`. Do remove the `FROM cards c` table and `JOIN sets s ON c.setCode = s.code` join instead of including them. Do change the FROM clause to only `set_translations` instead of multiple joined tables. Do replace the WHERE condition with a subquery `WHERE id IN (SELECT id FROM cards WHERE name = 'Angel of Mercy')` instead of directly filtering on `c.name = 'Angel of Mercy'` through table joins. The amended query now correctly retrieves languages by finding card IDs first through a subquery rather than attempting to join through multiple tables that may not have the necessary relationships."
        ],
        "rules": [
            "Angel of Mercy' is the name of card;"
        ]
    },
    "882": {
        "sql": [
            "SELECT MIN(year) AS first_year FROM races WHERE name LIKE '%Singapore Grand Prix%';"
        ],
        "question": "Which year was the first Singapore Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT year FROM races WHERE name = 'Singapore Grand Prix' ORDER BY year ASC LIMIT 1",
        "amends": [],
        "rules": [
            "the first race refers to race happened in min(year);"
        ]
    },
    "598": {
        "sql": [
            "WITH \nbadges_2010 AS (\n    SELECT COUNT(*) AS count_2010\n    FROM badges\n    WHERE Name = 'Student' AND strftime('%Y', Date) = '2010'\n),\nbadges_2011 AS (\n    SELECT COUNT(*) AS count_2011\n    FROM badges\n    WHERE Name = 'Student' AND strftime('%Y', Date) = '2011'\n),\ntotal_badges_2010 AS (\n    SELECT COUNT(*) AS total_2010\n    FROM badges\n    WHERE strftime('%Y', Date) = '2010'\n),\ntotal_badges_2011 AS (\n    SELECT COUNT(*) AS total_2011\n    FROM badges\n    WHERE strftime('%Y', Date) = '2011'\n)\nSELECT \n    ((b2010.count_2010 * 100.0 / t2010.total_2010) - (b2011.count_2011 * 100.0 / t2011.total_2011)) AS percentage_difference\nFROM \n    badges_2010 b2010, \n    badges_2011 b2011, \n    total_badges_2010 t2010, \n    total_badges_2011 t2011;",
            "SELECT \n    (SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) * 100.0 / COUNT(Id) - \n    (SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) * 100.0 / COUNT(Id)) AS percentage_difference\nFROM badges\nWHERE Name = 'Student'",
            "SELECT \n    (CAST(SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) AS REAL) * 100.0 / COUNT(Id) - \n     CAST(SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) AS REAL) * 100.0 / COUNT(Id)) \nFROM badges \nWHERE Name = 'Student'"
        ],
        "question": "What is the percentage difference of student badges given during 2010 and 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) AS REAL) * 100 / COUNT(Id) - CAST(SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) AS REAL) * 100 / COUNT(Id) FROM badges WHERE Name = 'Student'",
        "amends": [
            "Do use a single query with conditional aggregation instead of multiple CTEs and cross joins. Do calculate percentages directly with `SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) * 100 / COUNT(Id)` instead of separate counts for each year. Do apply the `Name = 'Student'` filter once in the main query instead of duplicating it across multiple CTEs. Do remove the unnecessary CTE structure and cross join operations that could produce incorrect Cartesian products. Do use proper casting with `CAST(... AS REAL)` instead of implicit type conversions. The amended query now correctly calculates the percentage difference between Student badges in 2010 and 2011 using a single efficient aggregation.",
            "Do cast the `SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0))` as `REAL` instead of using integer division, and do cast the `SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0))` as `REAL` instead of integer division to ensure proper percentage calculation. Do remove the alias `percentage_difference` instead of keeping it, and do remove the parentheses grouping around the entire expression instead of having them. Do maintain the same `WHERE Name = 'Student'` filter instead of changing it. The amended query now correctly handles floating-point division for accurate percentage difference calculation and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "student badges refers to badge's name = 'Student'; during 2010 refers to Year(Date) = 2010; during 2011 refers to Year(Date) = 2011; percentage difference = Subtract (Divide(Count(Name where Year(Date) = 2010), Count (Name)) *100, Divide(Count(Name where Year(Date) = 2011), Count(Name)) * 100)"
        ]
    },
    "1258": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nJOIN Laboratory L ON P.ID = L.ID\nWHERE E.KCT = '+' AND L.RA IN ('-', '+-');"
        ],
        "question": "How many patients with a normal Rhuematoid Factor has a positive measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T3.KCT = '+'",
        "amends": [],
        "rules": [
            "normal Rhuematoid Factor refers TO RA IN('-', '+-'); positive measure of degree of coagulation refers to KCT = '+'; Should compute the number of distinct ones"
        ]
    },
    "805": {
        "sql": [
            "SELECT full_name FROM superhero WHERE weight_kg = 0 OR weight_kg IS NULL;",
            "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0)"
        ],
        "question": "List the full names of superheroes with missing weight.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0)",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate full names. Do add `full_name IS NOT NULL` filter instead of omitting it to exclude null names. Do move the weight condition to parentheses `(weight_kg IS NULL OR weight_kg = 0)` instead of `weight_kg = 0 OR weight_kg IS NULL` for equivalent but clearer logic. The amended query now correctly returns distinct non-null superhero names where weight is either null or zero, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "missing weight refers to weight_kg = 0 OR weight_kg = NULL;"
        ]
    },
    "418": {
        "sql": [
            "SELECT availability FROM cards WHERE artist = 'Daren Bader';"
        ],
        "question": "What kind of printing is on the card that Daren Bader created?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT availability FROM cards WHERE artist = 'Daren Bader'",
        "amends": [],
        "rules": [
            "kind of printing refers to availability; Daren Bader created refers to artist = 'Daren Bader'"
        ]
    },
    "999": {
        "sql": [
            "SELECT r.name AS race_name\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nWHERE res.fastestLapTime IS NOT NULL\nORDER BY res.fastestLapTime ASC\nLIMIT 1;"
        ],
        "question": "In terms of the fastest lap time, what is the name of the race which recorded the fastest lap speed by a racer?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Fastest lap speed refers to MIN(fastestLapTime)\n\n"
        ]
    },
    "603": {
        "sql": [
            "SELECT SUM(FavoriteCount) AS TotalFavoriteCount FROM posts WHERE OwnerUserId = 686 AND strftime('%Y', CreaionDate) = '2011';",
            "SELECT SUM(DISTINCT p.FavoriteCount) \nFROM posts p \nWHERE p.Id IN (\n    SELECT ph.PostId \n    FROM postHistory ph \n    WHERE ph.UserId = 686 \n    AND strftime('%Y', ph.CreationDate) = '2011'\n)"
        ],
        "question": "What is the sum of favourite count gained by user ID 686 in 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(DISTINCT FavoriteCount) FROM posts WHERE Id IN ( SELECT PostId FROM postHistory WHERE UserId = 686 AND STRFTIME('%Y', CreationDate) = '2011' )",
        "amends": [
            "Do use `SUM(DISTINCT FavoriteCount)` instead of `SUM(FavoriteCount)` to avoid double-counting duplicate values. Do change the source table by filtering `posts` where `Id IN` a subquery instead of directly filtering on `OwnerUserId`. Do replace the direct `WHERE OwnerUserId = 686` condition with a subquery that selects `PostId` from `postHistory` where `UserId = 686` instead. Do correct the table reference from `posts` to `postHistory` for the date filter and fix the column name from `CreaionDate` to `CreationDate` in the subquery. Do remove the alias `AS TotalFavoriteCount` instead of keeping it. The amended query now correctly calculates distinct favorite counts for posts with history entries from the specified user and year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "in 2011 refers to year (CreatinDate) = 2011"
        ]
    },
    "163": {
        "sql": [
            "SELECT d.A2 AS district_name, COUNT(a.account_id) AS account_count\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.status = 'A'\nGROUP BY d.A2\nORDER BY account_count DESC\nLIMIT 1;",
            "SELECT T1.A2\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T2.account_id = T3.account_id\nWHERE T3.status = 'A'\nGROUP BY T1.district_id\nORDER BY COUNT(T2.account_id) DESC\nLIMIT 1;"
        ],
        "question": "Which district has the most accounts with loan contracts finished with no problems?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.A2 FROM District AS T1 INNER JOIN Account AS T2 ON T1.District_id = T2.District_id INNER JOIN Loan AS T3 ON T2.Account_id = T3.Account_id WHERE T3.status = 'A' GROUP BY T1.District_id ORDER BY COUNT(T2.Account_id) DESC LIMIT 1",
        "amends": [
            "Do select `T1.A2` instead of `d.A2 AS district_name` and remove the alias. Do use `INNER JOIN` consistently instead of mixing `JOIN` syntax. Do join `Account AS T2` on `T1.District_id = T2.District_id` instead of `d.district_id = a.district_id`. Do join `Loan AS T3` on `T2.Account_id = T3.Account_id` instead of `l.account_id = a.account_id`. Do group by `T1.District_id` instead of `d.A2` to ensure proper aggregation. Do order by `COUNT(T2.Account_id)` instead of `account_count` to reference the actual aggregate function rather than the alias. The amended query now correctly groups by district ID rather than district name, ensuring accurate counting of accounts per district for loans with status 'A', and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "status = 'A' refers to loan contracts finished with no problems"
        ]
    },
    "613": {
        "sql": [
            "SELECT b.Date\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Location = 'Rochester, NY';\n"
        ],
        "question": "List out the dates that users who are located in Rochester, NY obtained their badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Date FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'Rochester, NY'",
        "amends": [],
        "rules": [
            "\"Rochester, NY\" is the Location of user; user refers to UserId"
        ]
    },
    "796": {
        "sql": [
            "SELECT a.attribute_name, ha.attribute_value\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE s.superhero_name = '3-D Man';"
        ],
        "question": "State all of 3-D Man's attributes along with their values.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.attribute_name, T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = '3-D Man'",
        "amends": [],
        "rules": [
            "3-D Man is the superhero_name. attributes refers to attribute_name; values refers to attribute_value;"
        ]
    },
    "657": {
        "sql": [
            "SELECT u.DisplayName, u.WebsiteUrl\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE v.VoteTypeId = 8\nAND v.BountyAmount = (SELECT MAX(BountyAmount) FROM votes WHERE VoteTypeId = 8);"
        ],
        "question": "Under the vote type of 8, provide the display names and websites URLs of the user who got the highest bounty amount.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName, WebsiteUrl FROM users WHERE Id = ( SELECT UserId FROM votes WHERE VoteTypeId = 8 ORDER BY BountyAmount DESC LIMIT 1 )",
        "amends": [],
        "rules": [
            "vote type of 8 refers to VoteTypeId = 8; the highest bounty amount refers to MAX(BountyAmount);"
        ]
    },
    "7": {
        "sql": [
            "SELECT s.Phone\nFROM schools s\nJOIN satscores sat ON s.CDSCode = sat.cds\nWHERE sat.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);"
        ],
        "question": "What is the phone number of the school that has the highest number of test takers with an SAT score of over 1500?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [],
        "rules": []
    },
    "114": {
        "sql": [
            "SELECT a.account_id\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN district di ON c.district_id = di.district_id\nWHERE di.A3 = 'Prague'\nORDER BY a.date ASC\nLIMIT 1;",
            "SELECT account_id\nFROM account\nINNER JOIN district ON account.district_id = district.district_id\nWHERE district.A3 = 'Prague'\nORDER BY account.date ASC\nLIMIT 1;"
        ],
        "question": "For the first client who opened his/her account in Prague, what is his/her account ID?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'Prague' ORDER BY T1.date ASC LIMIT 1",
        "amends": [
            "Do join `account` directly with `district` on `district_id` instead of joining through `disp` and `client` tables. Do use `INNER JOIN` with predicate `T1.district_id = T2.district_id` instead of multiple joins with different join conditions. Do filter on `T2.A3 = 'Prague'` in the WHERE clause instead of the same condition but through an unnecessary table chain. Do remove the unnecessary `disp` and `client` table joins instead of including them. Do maintain the same `ORDER BY T1.date ASC` and `LIMIT 1` clauses as the original query. The amended query now correctly retrieves accounts from Prague district directly through the district relationship instead of through an indirect client-based path."
        ],
        "rules": [
            "A3 stands for region names"
        ]
    },
    "196": {
        "sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '-' AND a.element = 'cl';"
        ],
        "question": "In the non-carcinogenic molecules, how many contain chlorine atoms?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'cl' AND T1.label = '-'",
        "amends": [],
        "rules": [
            "non-carcinogenic molecules refers to label = '-'; chlorine atoms refers to element = 'cl'"
        ]
    },
    "130": {
        "sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS account_holders_without_credit_cards\nFROM district d\nJOIN account a ON d.district_id = a.district_id\nJOIN disp dp ON a.account_id = dp.account_id\nJOIN client c ON dp.client_id = c.client_id\nLEFT JOIN card cd ON dp.disp_id = cd.disp_id\nWHERE d.A3 = 'South Bohemia' AND dp.type = 'OWNER' AND cd.card_id IS NULL;",
            "SELECT COUNT(DISTINCT T3.account_id) AS account_holders_without_credit_cards\nFROM district AS T1\nJOIN client AS T2 ON T1.district_id = T2.district_id\nJOIN disp AS T3 ON T2.client_id = T3.client_id\nWHERE T1.A3 = 'South Bohemia' AND T3.type != 'OWNER'",
            "SELECT COUNT(T3.account_id) \nFROM district AS T1 \nJOIN client AS T2 ON T1.district_id = T2.district_id \nJOIN disp AS T3 ON T2.client_id = T3.client_id \nWHERE T1.A2 = 'south Bohemia' AND T3.type != 'OWNER'",
            "SELECT COUNT(T3.account_id)\nFROM district AS T1\nINNER JOIN client AS T2 ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3 ON T2.client_id = T3.client_id\nWHERE T1.A3 = 'south Bohemia' AND T3.type != 'OWNER'"
        ],
        "question": "How many of the account holders in South Bohemia still do not own credit cards?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.account_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.client_id = T3.client_id WHERE T1.A3 = 'south Bohemia' AND T3.type != 'OWNER'",
        "amends": [
            "Do count `T3.account_id` instead of `COUNT(DISTINCT c.client_id)` as `account_holders_without_credit_cards`. Do join `district AS T1` with `client AS T2` on `T1.district_id = T2.district_id` instead of joining district with account first. Do join `client AS T2` with `disp AS T3` on `T2.client_id = T3.client_id` instead of joining account with disp. Do remove the `LEFT JOIN card` table and `cd.card_id IS NULL` condition entirely instead of including them. Do filter with `T3.type != 'OWNER'` instead of `dp.type = 'OWNER'`. Do omit the `account` table and aliases like `AS account_holders_without_credit_cards` instead of including them. The amended query now correctly counts accounts for non-owner dispositions in South Bohemia district without involving credit card logic.",
            "Do remove `DISTINCT` from the count instead of keeping it, as the query should count all matching records rather than unique account IDs. Do change the case sensitivity in the filter from `'South Bohemia'` to `'south Bohemia'` instead of preserving the original capitalization to ensure proper string matching. Do omit the alias `account_holders_without_credit_cards` instead of including it, as the result column name is not required. The amended query now correctly counts all account IDs from non-OWNER disposition types in the specified region without unnecessary distinct counting or aliasing.",
            "Do filter on `T1.A3` instead of `T1.A2` in the WHERE clause to correctly reference the district name column. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for clarity, though this is functionally equivalent. The amended query now correctly counts accounts in the 'south Bohemia' district for non-OWNER disposition types, matching the intended behavior."
        ],
        "rules": [
            "A3 contains the region names; South Bohemia is one of region names."
        ]
    },
    "1411": {
        "sql": [
            "SELECT e.expense_description\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison';"
        ],
        "question": "State what kind of expenses that Sacha Harrison incurred?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
        "amends": [],
        "rules": [
            "kind of expenses refers to expense_description; Sacha Harrison is the full name; full name refers to first_name, last_name;"
        ]
    },
    "472": {
        "sql": [
            "SELECT COUNT(DISTINCT s.code) AS italian_translated_sets_count\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Ice Age' AND st.language = 'Italian' AND st.translation IS NOT NULL;"
        ],
        "question": "Among the sets in the block \"Ice Age\", how many of them have an Italian translation?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block = 'Ice Age' AND T2.language = 'Italian' AND T2.translation IS NOT NULL",
        "amends": [],
        "rules": [
            "sets in the block \"Ice Age\" refers to block = 'Ice Age'; Italian translation refers to language = 'Italian' and translation is not null"
        ]
    },
    "502": {
        "sql": [
            "SELECT s.releaseDate \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Ola de fr\u00edo';"
        ],
        "question": "What is the release date for the set \"Ola de fr\u00edo\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.releaseDate FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Ola de fr\u00edo'",
        "amends": [],
        "rules": [
            "release date is the date of card set being released; set \"Ola de fr\u00edo\" refers to translation = 'Ola de fr\u00edo'"
        ]
    },
    "679": {
        "sql": [
            "SELECT Id, Title FROM posts WHERE Score = (SELECT MAX(Score) FROM posts);",
            "SELECT T1.Id, T2.Title \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nORDER BY T2.Score DESC \nLIMIT 1;"
        ],
        "question": "Which post has the highest score? Please give its id and title's name.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1",
        "amends": [
            "Do select `T1.Id` and `T2.Title` from joined tables instead of `Id` and `Title` from a single table. Do use `INNER JOIN` between `users AS T1` and `posts AS T2` on `T1.Id = T2.OwnerUserId` instead of querying only the `posts` table. Do remove the subquery with `MAX(Score)` condition and instead add `ORDER BY T2.Score DESC LIMIT 1` to get the highest-scoring post instead of all posts with the maximum score. Do add table aliases `T1` and `T2` for clarity instead of using unqualified column names. The amended query now correctly retrieves the user ID and title of the highest-scoring post by joining users with posts and limiting to the top result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "the highest score refers to MAX(Score); owner's name refers to DisplayName;"
        ]
    },
    "1102": {
        "sql": [
            "SELECT p.player_name\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE pa.overall_rating = 77 AND pa.date LIKE '2016-06-23%'\nORDER BY p.birthday ASC\nLIMIT 1;"
        ],
        "question": "For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-06-23' AND t2.overall_rating = 77 ORDER BY t1.birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "77 points overall rating refers to overall_rating = 77; on 2016/6/23 refers to date LIKE '2016-06-23%'; The larger the birthday value, the younger the person is, and vice versa;"
        ]
    },
    "783": {
        "sql": [
            "SELECT DISTINCT c.colour AS eye_colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.skin_colour_id = (SELECT id FROM colour WHERE colour = 'Gold');"
        ],
        "question": "Provide the eye colours of the heroes whose skin colours are gold.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T3.colour = 'Gold'",
        "amends": [],
        "rules": [
            "skin colours are gold refers to colour.colour = 'Gold' WHERE skin_colour_id = colour.id;"
        ]
    },
    "551": {
        "sql": [
            "SELECT COUNT(*) AS badge_count\nFROM badges\nWHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');"
        ],
        "question": "How many badges has the user csgillespie obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user"
        ]
    },
    "844": {
        "sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.superhero_name = 'Blackwulf';"
        ],
        "question": "Give the eye colour of Blackwulf.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf'",
        "amends": [],
        "rules": [
            "eye colour refers to colour.colour where eye_colour_id = colour.id; Blackwulf refers to superhero_name = 'Blackwulf';"
        ]
    },
    "389": {
        "sql": [
            "SELECT c.name, r.date\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.originalType = 'Creature - Elf';",
            "SELECT T1.id, T2.date\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.originalType = 'Creature - Elf'"
        ],
        "question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'",
        "amends": [
            "Do select `T1.id` and `T2.date` instead of `c.name` and `r.date`. Do use table aliases `T1` and `T2` instead of `c` and `r`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T1.uuid = T2.uuid` in the join condition instead of `c.uuid = r.uuid`. Do filter on `T1.originalType = 'Creature - Elf'` instead of `c.originalType = 'Creature - Elf'`. The amended query now correctly retrieves card IDs with ruling dates while maintaining the same join logic and filtering criteria."
        ],
        "rules": [
            "Creature - Elf is the originalType;"
        ]
    },
    "364": {
        "sql": [
            "SELECT l.status FROM legalities l JOIN cards c ON l.uuid = c.uuid WHERE c.name = 'Cloudchaser Eagle';"
        ],
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "amends": [],
        "rules": [
            "Cloudchaser Eagle is the name of card;"
        ]
    },
    "31": {
        "sql": [
            "SELECT \n    `School Name`,\n    `Free Meal Count (K-12)` / `Enrollment (K-12)` AS `Eligible Free Rate`\nFROM \n    frpm\nORDER BY \n    `Enrollment (K-12)` DESC\nLIMIT 10, 2;",
            "SELECT \n    CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\" AS eligible_free_rate\nFROM frpm\nWHERE \"Enrollment (K-12)\" IS NOT NULL \n    AND \"Free Meal Count (K-12)\" IS NOT NULL\nORDER BY \"Enrollment (K-12)\" DESC\nLIMIT 9, 2"
        ],
        "question": "What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)` FROM frpm ORDER BY `Enrollment (K-12)` DESC LIMIT 9, 2",
        "amends": [
            "Do cast `Free Meal Count (K-12)` as `REAL` instead of using it directly in division to ensure proper numeric handling. Do remove the `School Name` column and the `Eligible Free Rate` alias instead of including them in the SELECT list. Do change the LIMIT clause to `9, 2` instead of `10, 2` to adjust the row offset and count. The amended query now correctly calculates the free meal eligibility rate with proper type casting and returns the appropriate result set."
        ],
        "rules": [
            "K-12 refers to students in grades 1 through 12; Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`"
        ]
    },
    "1133": {
        "sql": [
            "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Aaron%' AND birthday > '1990-12-31';",
            "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'"
        ],
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do place the `birthday` filter before the `player_name` filter instead of after it for potential performance optimization. Do use `birthday > '1990'` instead of `birthday > '1990-12-31'` to include all players born after the year 1990 rather than only those born after December 31st, 1990. The amended query now correctly counts players with 'Aaron' names born after 1990."
        ],
        "rules": [
            "first name \"Aaron\" refers to player_name LIKE 'Aaron%'; born after the 1990s refers to birthday > '1990'"
        ]
    },
    "1476": {
        "sql": [
            "SELECT \n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'CZK' AND ym.Date LIKE '2012%') -\n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'EUR' AND ym.Date LIKE '2012%') AS ConsumptionDifference;"
        ],
        "question": "What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(T1.Currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.Currency = 'EUR', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2012'",
        "amends": [],
        "rules": [
            "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year; Difference in Consumption = CZK customers consumption in 2012 - EUR customers consumption in 2012"
        ]
    },
    "501": {
        "sql": [
            "SELECT c.name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Journey into Nyx Hero''s Path'\nORDER BY c.convertedManaCost DESC\nLIMIT 1;"
        ],
        "question": "Which card name in the set 'Journey into Nyx Hero's Path' has the highest converted mana cost.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Journey into Nyx Hero''s Path' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "amends": [],
        "rules": [
            "set 'Journey into Nyx Hero's Path' refers to name = 'Journey into Nyx Hero''s Path'"
        ]
    },
    "1431": {
        "sql": [
            "SELECT m.last_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Women''s Soccer' AND m.position = 'Member';"
        ],
        "question": "List the last name of the members of the club that attended the women's soccer event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.last_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T2.event_name = 'Women''s Soccer' AND T3.position = 'Member'",
        "amends": [],
        "rules": [
            "members of the club refers to position = 'Member'; 'Women's Soccer' is event name;"
        ]
    },
    "573": {
        "sql": [
            "SELECT Text FROM comments WHERE Score = 17;"
        ],
        "question": "Write the contents of comments with a score of 17.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Text FROM comments WHERE Score = 17",
        "amends": [],
        "rules": [
            "score of 17 refers to Score = 17; contents of comments refers to Text"
        ]
    },
    "1520": {
        "sql": [
            "WITH target_customer AS (\n    SELECT CustomerID\n    FROM transactions_1k\n    WHERE Price = 124.05 AND Date = '2012-08-24'\n)\nSELECT Date, Consumption\nFROM yearmonth\nWHERE CustomerID IN (SELECT CustomerID FROM target_customer) AND Date LIKE '2012-01%';",
            "SELECT T1.CustomerID, T2.Date, T2.Consumption\nFROM transactions_1k T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Date = '2012-08-24' \nAND T1.Price = 124.05\nAND T2.Date = '201201';"
        ],
        "question": "For the customer who paid 124.05 in 2012/8/24, how much did he/she spend during the January of 2012? And what is the date and expenses exactly?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID, T2.Date, T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Price = 124.05 AND T2.Date = '201201'",
        "amends": [
            "Do use an `INNER JOIN` between `transactions_1k` and `yearmonth` on `CustomerID` instead of a subquery with `IN`. Do select `T1.CustomerID`, `T2.Date`, and `T2.Consumption` instead of only `Date` and `Consumption`. Do filter `T1.Date` to `'2012-08-24'` and `T1.Price` to `124.05` in the `WHERE` clause instead of in a CTE. Do filter `T2.Date` to `'201201'` instead of using `LIKE '2012-01%'`. Do remove the CTE wrapper and instead perform the join directly in the main query. The amended query now correctly joins the tables and filters the dates appropriately to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "'2012/8/24' can be represented by '2012-08-24'; expense and the consumption has the similar meaning."
        ]
    },
    "131": {
        "sql": [
            "SELECT d.A3 AS district_name, COUNT(l.loan_id) AS active_loan_count\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.status IN ('C', 'D')\nGROUP BY d.A3\nORDER BY active_loan_count DESC\nLIMIT 1;",
            "SELECT T2.A3\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.status = 'A'\nGROUP BY T2.A3\nORDER BY SUM(T3.amount) DESC\nLIMIT 1;",
            "SELECT T2.A3\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.status IN ('C', 'D')\nGROUP BY T2.A3\nORDER BY SUM(T3.amount) DESC\nLIMIT 1"
        ],
        "question": "Which district has highest active loan?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.status IN ('C', 'D') GROUP BY T2.A3 ORDER BY SUM(T3.amount) DESC LIMIT 1",
        "amends": [
            "Do select only `T2.A3` instead of selecting both `d.A3` and `COUNT(l.loan_id)`. Do use table aliases `T1`, `T2`, and `T3` instead of `a`, `d`, and `l`. Do change the join order to start with `account AS T1` instead of starting with `loan l`. Do use `INNER JOIN` consistently for all joins instead of mixing `JOIN` and `INNER JOIN`. Do change the WHERE filter to reference `T3.status` instead of `l.status`. Do remove the `COUNT(l.loan_id)` aggregation and instead use `SUM(T3.amount)` in the ORDER BY clause instead of ordering by `active_loan_count`. Do remove the alias `active_loan_count` from the output since it's no longer selected. Do change the GROUP BY to reference `T2.A3` instead of `d.A3`. The amended query now correctly orders by the sum of loan amounts for active loans rather than counting loans, matching the RIGHT_SQL's behavior.",
            "Do filter on `T3.status IN ('C', 'D')` instead of `T3.status = 'A'` in the WHERE clause to include different loan status values. The amended query now matches RIGHT_SQL's behavior by correctly filtering for the specified status conditions."
        ],
        "rules": [
            "A3 refers to district names; Active loan refers to running contracts; Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt"
        ]
    },
    "881": {
        "sql": [
            "WITH race_on_date AS (\n    SELECT raceId FROM races WHERE date = '1983-07-16'\n),\ndriver_participation AS (\n    SELECT r.driverId, s.status\n    FROM results r\n    JOIN race_on_date rod ON r.raceId = rod.raceId\n    JOIN status s ON r.statusId = s.statusId\n),\ncompletion_stats AS (\n    SELECT \n        COUNT(*) AS total_drivers,\n        SUM(CASE WHEN status = 'Finished' THEN 1 ELSE 0 END) AS completed_drivers\n    FROM driver_participation\n)\nSELECT \n    (completed_drivers * 100.0 / total_drivers) AS completion_rate_percentage\nFROM completion_stats;"
        ],
        "question": "For the drivers who took part in the race in 1983/7/16, what's their race completion rate?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'",
        "amends": [],
        "rules": [
            "DIVIDE(COUNT(driverid when time has value ), (COUNT(driverid )) as percentage; in 1983/7/16 refers to when date = '1983-07-16'"
        ]
    },
    "1303": {
        "sql": [
            "SELECT MIN(P.Birthday) AS OldestPatientBirthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.GLU > 180;"
        ],
        "question": "When is the birthday of the oldest patient whose blood glucose is abnormal?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU > 180 ORDER BY T1.Birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "oldest patient refers to MIN(Birthday); blood glucose is abnormal refers to GLU > 180;"
        ]
    },
    "49": {
        "sql": [
            "WITH ClosedSchools AS (\n    SELECT County, School, ClosedDate\n    FROM schools\n    WHERE StatusType = 'Closed'\n),\nCountyCount AS (\n    SELECT County, COUNT(*) AS SchoolCount\n    FROM ClosedSchools\n    GROUP BY County\n    ORDER BY SchoolCount DESC\n    LIMIT 1\n)\nSELECT cs.County, cs.School, cs.ClosedDate\nFROM ClosedSchools cs\nJOIN CountyCount cc ON cs.County = cc.County\nORDER BY cs.ClosedDate;",
            "SELECT s.County, s.School, s.ClosedDate \nFROM schools s \nWHERE s.StatusType = 'Closed' \nAND s.School IS NOT NULL \nAND s.County = (\n    SELECT s2.County \n    FROM schools s2 \n    WHERE s2.StatusType = 'Closed' \n    AND s2.School IS NOT NULL \n    GROUP BY s2.County \n    ORDER BY COUNT(s2.School) DESC \n    LIMIT 1\n)"
        ],
        "question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Closed' AND school IS NOT NULL",
        "amends": [
            "Do use a subquery to find the county with the most closed schools instead of a CTE with JOIN. Do filter directly on `StatusType = 'Closed'` in the main query instead of using a CTE. Do add `DISTINCT` to eliminate duplicates instead of omitting it. Do add `school IS NOT NULL` filter instead of omitting it. Do remove the explicit ordering by `ClosedDate` instead of keeping it. Do use `COUNT(School)` in the subquery instead of `COUNT(*)` to count actual schools. The amended query now correctly identifies the county with the most closed schools and returns all closed schools from that county while ensuring no null school values."
        ],
        "rules": [
            "Closure date and closed date are synonyms; 'Closed' was mentioned in schools.StatusType."
        ]
    },
    "1160": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN (P.SEX = 'F' AND (L.TP < 6.0 OR L.TP > 8.5)) THEN 1 END) * 100.0 / \n    COUNT(CASE WHEN P.SEX = 'F' THEN 1 END)) AS percentage\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.SEX = 'F' AND L.TP IS NOT NULL;",
            "SELECT \n    (SUM(CASE WHEN T2.TP < 6.5 OR T2.TP > 8.2 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient T1\nJOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100.0 AS percentage\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'"
        ],
        "question": "What is the percentage of female patient had total protein not within the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F'",
        "amends": [
            "Do use `SUM(CASE ... THEN 1 ELSE 0 END)` with explicit ELSE instead of `COUNT(CASE ... THEN 1 END)` for conditional counting. Do cast the sum to `REAL` instead of using decimal literal `100.0` for proper floating-point division. Do use `COUNT(*)` in the denominator instead of `COUNT(CASE WHEN P.SEX = 'F' THEN 1 END)` since the WHERE clause already filters for female patients. Do remove the redundant `L.TP IS NOT NULL` condition from the WHERE clause instead of keeping it, as the CASE statement already handles NULL values implicitly. Do use table aliases `T1` and `T2` instead of full table names for better readability. The amended query now correctly calculates the percentage without redundant filtering and ensures proper numeric handling.",
            "Do add `T1.SEX = 'F'` condition inside the CASE expression instead of only in the WHERE clause, to ensure the percentage calculation only counts female patients. Do change the TP threshold range from `< 6.5 OR > 8.2` to `< 6.0 OR > 8.5` to use the correct medical reference values. Do add explicit `CAST(... AS REAL)` instead of implicit type conversion to ensure proper floating-point division. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. The amended query now correctly calculates the percentage of female patients with abnormal TP values using the proper clinical thresholds and ensures accurate type handling for the division operation."
        ],
        "rules": [
            "female refers to sex = 'F'; total protein not within the normal range refers to TP < '6.0' or TP > '8.5'; calculation = DIVIDE((ID where sex = 'F' and TP < '6.0' or TP > '8.5'), COUNT(ID)) * 100"
        ]
    },
    "538": {
        "sql": [
            "SELECT p.Title \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE u.DisplayName = 'csgillespie';"
        ],
        "question": "Please list the titles of the posts owned by the user csgillespie?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user"
        ]
    },
    "399": {
        "sql": [
            "SELECT DISTINCT types FROM cards WHERE availability = 'arena';",
            "SELECT DISTINCT subtypes, supertypes \nFROM cards \nWHERE mtgArenaId IS NOT NULL \nAND subtypes IS NOT NULL \nAND supertypes IS NOT NULL;",
            "SELECT DISTINCT subtypes, supertypes\nFROM cards\nWHERE availability = 'arena'\nAND subtypes IS NOT NULL\nAND supertypes IS NOT NULL;"
        ],
        "question": "Lists all types of cards available in arena.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL",
        "amends": [
            "Do select both `subtypes` and `supertypes` instead of only `types`. Do add `AND subtypes IS NOT NULL` and `AND supertypes IS NOT NULL` filters instead of omitting null checks. The amended query now correctly retrieves distinct non-null subtype and supertype combinations from arena-available cards, matching the intended behavior.",
            "Do filter by `availability = 'arena'` instead of `mtgArenaId IS NOT NULL` in the WHERE clause, as this more accurately identifies Arena-available cards through a dedicated availability field rather than checking for the presence of an ID. Do keep the DISTINCT selection of `subtypes` and `supertuples` from the `cards` table while maintaining the NOT NULL constraints on both fields, but replace the ID-based filter with the proper availability condition. The amended query now correctly identifies Arena cards using the designated availability field rather than inferring availability through ID presence."
        ],
        "rules": [
            "all types refer to subtypes and supertypes\n\navailble in arena refers to availability = 'arena'"
        ]
    },
    "916": {
        "sql": [
            "SELECT surname FROM drivers WHERE nationality = 'Italian';"
        ],
        "question": "Please list the surnames of all the Italian drivers.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT surname FROM drivers WHERE nationality = 'Italian'",
        "amends": [],
        "rules": [
            "Italian refers to nationality = 'italian'"
        ]
    },
    "691": {
        "sql": [
            "SELECT COUNT(*) AS NumberOfAdultUsersWithHighUpvotes\nFROM users\nWHERE Age >= 18 AND UpVotes > 5000;"
        ],
        "question": "Identify the number of adult users who have cast over 5000 upvotes.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000",
        "amends": [],
        "rules": [
            "adult users refer to Age BETWEEN 19 and 65; over 5000 upvotes refer to UpVotes > 5000;"
        ]
    }
}