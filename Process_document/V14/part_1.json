{
    "1143": {
        "question": "What was the highest score of the home team in the Netherlands Eredivisie league?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT MAX(t2.home_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Netherlands Eredivisie'",
        "amends": [],
        "rules": [
            "highest score of the home team refers to MAX(home_team_goal)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(home_team_goal) AS highest_home_score\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Netherlands Eredivisie');"
        ],
        "rule_sql": []
    },
    "355": {
        "question": "What is the keyword found on card 'Angel of Mercy'?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy'",
        "amends": [],
        "rules": [
            "Angel of Mercy' is the name of card;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT keywords FROM cards WHERE name = 'Angel of Mercy';"
        ],
        "rule_sql": []
    },
    "166": {
        "question": "How many of the accounts are from Jesenik district?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A2 = 'Jesenik'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM account \nWHERE district_id = (SELECT district_id FROM district WHERE A2 = 'Jesenik');"
        ],
        "rule_sql": []
    },
    "1321": {
        "question": "How many events of the Student_Club did Sacha Harrison attend in 2019?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Sacha' AND T3.last_name = 'Harrison' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "amends": [],
        "rules": [
            "events attended in 2019 refers to YEAR(event_date) = 2019"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS event_count\nFROM attendance a\nJOIN member m ON a.link_to_member = m.member_id\nJOIN event e ON a.link_to_event = e.event_id\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison'\nAND strftime('%Y', e.event_date) = '2019';"
        ],
        "rule_sql": []
    },
    "1495": {
        "question": "Which client ID consumed the most in September 2013?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do add the `customers` table with an `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `yearmonth` table. Do reference `T2.Date` in the WHERE clause instead of just `Date`. Do calculate the SUM of `T2.Consumption` in the ORDER BY clause instead of selecting it as a column in the SELECT list. Do remove the explicit `TotalConsumption` alias from the SELECT list instead of including it. The amended query now correctly joins customer data with consumption records and properly orders by the aggregated sum while matching the RIGHT_SQL's behavior.",
            "Do use exact equality `T2.Date = '201309'` instead of pattern matching `T2.Date LIKE '2013-09%'` for the date filter. Do remove the unnecessary table alias `T1.` prefix from `CustomerID` in the SELECT list instead of keeping it. The amended query now correctly matches the right SQL's behavior by using precise date comparison and cleaner column reference."
        ],
        "rules": [
            "1) When the question asks for \"client ID\" and the schema contains \"CustomerID\": use the exact identifier \"CustomerID\" from the customers table with alias T2.\n2) When joining the yearmonth table (T1) with customers table (T2): link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match).\n3) When filtering for September 2013: use the exact literal '201309' with the exact identifier T2.Date.\n4) When calculating consumption for a specific period: compute the sum of T2.Consumption grouped by CustomerID.\n5) When finding the \"most\" consumed: rank rows by the sum of T2.Consumption in descending order and keep the first 1 row.\n6) When outputting results: include only CustomerID from the customers table.\n7) Output columns (ordered): T2.CustomerID",
            "1) When filtering for a specific year and month in the format YYYYMM: use exact equality comparison with the literal value '201309' instead of pattern matching. 2) When selecting columns that are unambiguous across joined tables: use the column name directly without table alias prefix (e.g., CustomerID instead of T1.CustomerID). 3) When the question asks for the client with maximum consumption: rank rows by the sum of T2.Consumption in descending order and keep the first 1 row. 4) When combining customers and yearmonth tables: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs. 5) When grouping by CustomerID: organize results by CustomerID and compute the sum of T2.Consumption per group. Output columns (ordered): CustomerID"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT CustomerID, SUM(Consumption) AS TotalConsumption\nFROM yearmonth\nWHERE Date = '201309'\nGROUP BY CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date LIKE '2013-09%'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT CustomerID\nFROM customers T2\nINNER JOIN yearmonth T1 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Date = '201309'\nGROUP BY CustomerID\nORDER BY SUM(T1.Consumption) DESC\nLIMIT 1"
        ]
    },
    "599": {
        "question": "What are the post history type IDs for post ID 3720 and how many unique users have commented on the post?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory AS T1 WHERE T1.PostId = 3720",
        "amends": [
            "Do combine both queries into a single SELECT statement instead of executing them separately. Do include `T1.PostHistoryTypeId` in the main SELECT list instead of selecting only `PostHistoryTypeId` without table alias. Do add a correlated subquery `(SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers` instead of omitting this calculation from the main result. Do use table alias `T1` for `postHistory` instead of referencing it without alias. Do keep the filter `WHERE T1.PostId = 3720` instead of changing its logic. Do remove the DISTINCT keyword from the main query instead of keeping it, as the subquery handles distinct counting separately. The amended query now correctly returns both the post history type IDs and the count of unique commenting users in a single result set matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining multiple data requirements for the same entity (post ID 3720): use a single query that includes both the post history type IDs and the count of unique commenting users instead of separate queries.\n2) When selecting from the postHistory table: use table alias T1 for all column references instead of unaliased column names.\n3) When retrieving post history type IDs: include T1.PostHistoryTypeId in the main SELECT list instead of selecting only PostHistoryTypeId.\n4) When counting unique users who commented on a post: use a correlated subquery (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers instead of omitting this calculation.\n5) When filtering for a specific post: keep the condition WHERE T1.PostId = 3720 to filter for post ID 3720.\n6) When selecting post history type IDs: remove the DISTINCT keyword from the main query since the subquery handles distinct counting separately.\nOutput columns (ordered): T1.PostHistoryTypeId, NumberOfUsers"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "-- Query to find post history type IDs for post ID 3720\nSELECT DISTINCT PostHistoryTypeId\nFROM postHistory\nWHERE PostId = 3720;\n\n-- Query to count unique users who commented on post ID 3720\nSELECT COUNT(DISTINCT UserId) AS UniqueCommentingUsers\nFROM comments\nWHERE PostId = 3720;",
            "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory T1 WHERE T1.PostId = 3720"
        ],
        "rule_sql": [
            "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory T1 WHERE T1.PostId = 3720"
        ]
    },
    "1151": {
        "question": "For patient born between Year 1930 to 1940, how many percent of them were inpatient?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940'",
        "amends": [
            "Do use `SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN Admission = '+' THEN 1 END)` to properly count positive admissions. Do cast the sum to `REAL` instead of using `ROUND` to ensure floating-point division. Do remove the `ROUND` function and alias `Percentage_Inpatient` instead of keeping them. Do use direct arithmetic division `* 100 / COUNT(*)` instead of `* 100.0 / COUNT(*)` with explicit rounding. The amended query now correctly calculates the percentage without unnecessary rounding and matches the right SQL's behavior.",
            "Do cast the SUM result as `REAL` instead of using integer division, and do use `STRFTIME('%Y', Birthday)` to extract the year instead of comparing full date ranges with `BETWEEN '1930-01-01' AND '1940-12-31'`, which would miss patients born in 1940 after December 31st. Do remove the alias `Percentage_Inpatient` instead of keeping it. The amended query now correctly calculates the percentage using floating-point division and accurately filters patients born in any year between 1930 and 1940 inclusive, matching the RIGHT_SQL's behavior.",
            "Do add `CAST(SUM(...) AS REAL)` instead of using integer division which truncates decimal results, ensuring proper percentage calculation with fractional values instead of integer truncation. The amended query now correctly handles floating-point division to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating percentages for binary conditions: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) to properly count positive cases.\n2) When performing percentage calculations: cast the numerator to REAL type to ensure floating-point division occurs.\n3) When the question asks for \"how many percent\": use direct arithmetic division (* 100 / total_count) without rounding functions.\n4) When filtering patients by birth year range: extract the year from the Birthday column and filter for values between 1930 and 1940 inclusive.\n5) When counting inpatient admissions: use the exact literal '+' to identify positive admission cases.\n6) Output columns (ordered): Percentage_Inpatient",
            "1) When calculating percentages that require floating-point precision: cast the numerator to REAL type before division to avoid integer division.\n2) When filtering by year ranges for date columns: extract the year component using STRFTIME('%Y', column_name) and compare against numeric year values instead of using full date ranges that may exclude partial years.\n3) When the question asks for \"percent of them were inpatient\": compute (count of rows where Admission equals '+') divided by (total count of rows) multiplied by 100, using floating-point division.\n4) When handling exact string matching for categorical values: use the exact literal '+' for Admission column comparisons.\n5) When output formatting: do not include column aliases in the final result when not explicitly requested.\n6) Output columns (ordered): the computed percentage value without alias",
            "1) When calculating percentages that require fractional precision: use real number division instead of integer division to preserve decimal values in the result.\n2) When the question asks for \"how many percent\": ensure the calculation produces a floating-point percentage value rather than truncating to an integer.\n3) When converting counts to percentages: cast the numerator to real type before division to maintain fractional precision.\n4) Output columns (ordered): the percentage result"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    ROUND((COUNT(CASE WHEN Admission = '+' THEN 1 END) * 100.0 / COUNT(*)), 2) AS Percentage_Inpatient\nFROM \n    Patient\nWHERE \n    strftime('%Y', Birthday) BETWEEN '1930' AND '1940';",
            "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100 / COUNT(*) AS Percentage_Inpatient\nFROM \n    Patient\nWHERE \n    Birthday BETWEEN '1930-01-01' AND '1940-12-31'",
            "SELECT SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100 / COUNT(*) FROM Patient WHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940'",
            "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN p.Admission = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS Percentage_Inpatient\nFROM \n    Patient p\nWHERE \n    CAST(STRFTIME('%Y', p.Birthday) AS INTEGER) BETWEEN 1930 AND 1940;"
        ]
    },
    "975": {
        "question": "Which year has the lowest speed of lap time?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId ORDER BY T1.time DESC LIMIT 1",
        "amends": [],
        "rules": [
            "lowest speed of lap time refers to Max(time);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.year\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nGROUP BY r.year\nORDER BY MAX(lt.time) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "524": {
        "question": "List the artists who illustrated cards with black borders which are available only in arena.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT artist FROM cards WHERE availability = 'arena' AND BorderColor = 'black'",
        "amends": [],
        "rules": [
            "black borders refers to BorderColor = 'black'; available only in arena refers to availability = 'arena'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT artist FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability NOT LIKE '%paper%' AND availability NOT LIKE '%mtgo%';"
        ],
        "rule_sql": []
    },
    "745": {
        "question": "Give the publisher ID of Star Trek.",
        "db_id": "superhero",
        "ground_truth": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
        "amends": [],
        "rules": [
            "Star Trek is the publisher_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM publisher WHERE publisher_name = 'Star Trek';"
        ],
        "rule_sql": []
    },
    "332": {
        "question": "Among the molecules between TR004 to TR010, how many of them has single bonds?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.molecule_id BETWEEN 'TR004' AND 'TR010' AND T.bond_type = '-'",
        "amends": [],
        "rules": [
            "single bond refers to bond_type = '-'; molecules between TR004 to TR010 refers molecule_id BETWEEN 'TR004' and 'TR010';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT molecule_id) \nFROM bond \nWHERE bond_type = '-' \nAND molecule_id BETWEEN 'TR004' AND 'TR010';"
        ],
        "rule_sql": []
    },
    "865": {
        "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
        "amends": [
            "Do select only `forename` and `surname` instead of including `driverId` and `dob` in the SELECT list. Do add filter `T1.dob IS NOT NULL` to the WHERE clause instead of omitting it, ensuring only drivers with known birthdates are considered. Do use table aliases `T1` for drivers and `T2` for results instead of single-letter aliases, though this is cosmetic. The amended query now correctly identifies the youngest driver with a valid time in race 592 by ensuring dob is not null before ordering.",
            "Do filter on `T2.time IS NOT NULL` instead of `T2.position IS NOT NULL` in the WHERE clause. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do maintain the same join condition `T2.driverId = T1.driverId` instead of `T1.driverId = T2.driverId` while preserving the same logical relationship. The amended query now correctly filters drivers who completed the race with a recorded time rather than just having a position, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for drivers who finished a specific race: filter results to only include rows where T2.raceId equals the exact race number specified (592). 2) When identifying drivers who finished a race: include only rows where T2.time is not null, indicating a completed race. 3) When determining driver age: include only drivers with known birthdates by filtering where T1.dob is not null. 4) When finding the oldest driver: order drivers by birthdate in ascending order (oldest first) and take the first result. 5) When outputting driver information: include only the forename and surname columns. 6) When combining driver and race result information: link rows where T1.driverId equals T2.driverId to match drivers with their race results. Output columns (ordered): T1.forename, T1.surname",
            "1) When the question asks for drivers who finished the game in a specific race: filter results where T2.raceId equals 592 and T2.time is not null to identify drivers who completed the race with a recorded time.\n2) When determining the oldest driver among those who finished: order the results by T1.dob in ascending order (earliest date of birth first) and take the first row.\n3) When combining driver information with race results: link rows where T2.driverId equals T1.driverId using an inner join to keep only matching driver-race pairs.\n4) When selecting output columns for driver identification: include both T1.forename and T1.surname to fully identify each driver.\nOutput columns (ordered): T1.forename, T1.surname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverId, d.forename, d.surname, d.dob\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 592 AND r.time IS NOT NULL\nORDER BY d.dob ASC\nLIMIT 1;",
            "SELECT T1.forename, T1.surname\nFROM drivers T1\nJOIN results T2 ON T1.driverId = T2.driverId\nWHERE T2.raceId = 592 \nAND T2.position IS NOT NULL \nAND T1.dob IS NOT NULL\nORDER BY T1.dob ASC\nLIMIT 1",
            "SELECT T1.forename, T1.surname\nFROM drivers T1\nINNER JOIN results T2 ON T2.driverId = T1.driverId\nWHERE T2.raceId = 592\nAND T2.time IS NOT NULL\nAND T1.dob IS NOT NULL\nORDER BY T1.dob ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT d.forename, d.surname\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE r.raceId = 592\nAND r.time IS NOT NULL\nAND d.dob IS NOT NULL\nORDER BY d.dob ASC\nLIMIT 1;"
        ]
    },
    "105": {
        "question": "There was a loan approved in 1994/8/25, where was that account opened, give the district Id of the branch.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.district_id\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.date = '1994-08-25';"
        ],
        "rule_sql": []
    },
    "440": {
        "question": "Which foreign language used by \"A Pedra Fellwar\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'",
        "amends": [
            "Do remove the `JOIN cards c ON fd.uuid = c.uuid` clause instead of including an unnecessary table join. Do change the WHERE filter to use `name = 'A Pedra Fellwar'` directly on the foreign_data table instead of filtering through the joined cards table. Do simplify the SELECT list to just `language` instead of qualifying it with the `fd.` table alias since only one table remains. The amended query now correctly retrieves language information directly from the foreign_data table without the redundant join, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about a specific entity by name \"A Pedra Fellwar\": filter rows where the name column equals exactly 'A Pedra Fellwar'. 2) When retrieving information about language usage: select the language column directly from the table containing language data. 3) When only one table is needed to answer the question: do not include unnecessary joins to other tables. 4) When selecting from a single table: use unqualified column names without table aliases. 5) Output columns (ordered): language"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT fd.language FROM foreign_data fd JOIN cards c ON fd.uuid = c.uuid WHERE c.name = 'A Pedra Fellwar';",
            "SELECT language FROM foreign_data WHERE name = 'A Pedra Fellwar';"
        ],
        "rule_sql": [
            "SELECT language FROM foreign_data WHERE name = 'A Pedra Fellwar'"
        ]
    },
    "1417": {
        "question": "List out the type of events which have remaining budget more than 30 USD.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 30",
        "amends": [],
        "rules": [
            "remaining budget more than 30 USD refers to remaining > 30"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT e.type\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.remaining > 30;"
        ],
        "rule_sql": []
    },
    "443": {
        "question": "Give the code of sets have expansion type of 'expansion'?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'expansion' GROUP BY T2.setCode",
        "amends": [
            "Do use `T2.setCode` in the SELECT list instead of `code` from the original table. Do add an `INNER JOIN` with `set_translations AS T2` on `T2.setCode = T1.code` instead of querying only the `sets` table. Do alias the sets table as `T1` instead of using it directly without an alias. Do add a `GROUP BY T2.setCode` clause instead of omitting any grouping. Do keep the `WHERE T1.type = 'expansion'` filter but reference it through the table alias instead of directly. The amended query now correctly joins the translation data and groups by the set code to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"code of sets\": use T2.setCode as the output column instead of code from the original table. 2) When combining sets and set_translations tables: link rows where T2.setCode = T1.code and keep only matching pairs (inner match). 3) When filtering for expansion type: apply the condition T1.type = 'expansion' exactly as specified. 4) When grouping results by set code: organize results by T2.setCode to match the intended behavior. 5) Output columns (ordered): T2.setCode"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM sets WHERE type = 'expansion';",
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'expansion' GROUP BY T2.setCode"
        ],
        "rule_sql": [
            "SELECT T2.setCode \nFROM sets T1 \nINNER JOIN set_translations T2 ON T2.setCode = T1.code \nWHERE T1.type = 'expansion' \nGROUP BY T2.setCode"
        ]
    },
    "951": {
        "question": "How many Japanese constructors have 0 points in 2 races?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T1.raceId) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T2.nationality = 'Japanese' GROUP BY T1.constructorId HAVING COUNT(raceId) = 2",
        "amends": [
            "Do use `constructorStandings` table instead of `constructorResults` for the join. Do change the join to `INNER JOIN` on `T1.constructorId = T2.constructorId` instead of `JOIN` on `c.constructorId = cr.constructorId`. Do move the `nationality` filter to the `WHERE` clause instead of keeping it in the original position. Do change the `points` filter to reference `T1.points` instead of `cr.points`. Do simplify the `GROUP BY` to only `T1.constructorId` instead of grouping by both `c.constructorId` and `c.name`. Do remove the `c.name` column from the `SELECT` list instead of including it. Do change the aggregate to `COUNT(T1.raceId)` instead of `COUNT(cr.raceId)`. The amended query now correctly counts races with zero points for Japanese constructors using the appropriate standings table."
        ],
        "rules": [
            "1) When the question asks about constructors with a specific nationality: filter T1.nationality to exactly 'Japanese' using the exact literal case and spelling.\n2) When the question asks about zero points in races: filter T1.points to exactly 0 using numeric equality.\n3) When counting races per constructor: use COUNT(T1.raceId) as the counting mechanism for races.\n4) When grouping by constructor: group results by T1.constructorId only, not including additional columns.\n5) When the question specifies exactly 2 races: filter groups to those having exactly 2 races with COUNT(T1.raceId) = 2.\n6) When combining constructor and standings data: link rows where T1.constructorId = T2.constructorId using inner matching only.\n7) Output columns (ordered): T1.constructorId"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.constructorId, c.name, COUNT(cr.raceId) AS races_with_zero_points\nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nWHERE c.nationality = 'Japanese' AND cr.points = 0\nGROUP BY c.constructorId, c.name\nHAVING COUNT(cr.raceId) = 2;",
            "SELECT COUNT(T1.raceId) \nFROM constructorStandings T1\nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId\nWHERE T2.nationality = 'Japanese' AND T1.points = 0\nGROUP BY T1.constructorId\nHAVING COUNT(T1.raceId) = 2"
        ],
        "rule_sql": [
            "SELECT T1.constructorId\nFROM constructorStandings T1\nJOIN constructors T2 ON T1.constructorId = T2.constructorId\nWHERE T2.nationality = 'Japanese'\nAND T1.points = 0\nGROUP BY T1.constructorId\nHAVING COUNT(T1.raceId) = 2"
        ]
    },
    "536": {
        "question": "How many users with more than 10 views created their account after the year 2013?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM users WHERE STRFTIME('%Y', CreationDate) > '2013' AND Views > 10",
        "amends": [],
        "rules": [
            "more than 10 views refers to Views > 10; created after the year 2013 refers to year (CreationDate) > 2013"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM users \nWHERE Views > 10 \nAND strftime('%Y', CreationDate) > '2013';"
        ],
        "rule_sql": []
    },
    "1376": {
        "question": "Among all the closed events, which event has the highest spend-to-budget ratio?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
        "amends": [
            "Do select only `event_name` instead of including multiple columns like `event_id`, `event_date`, `type`, `notes`, `location`, `status`, `budget_id`, `category`, `spent`, `remaining`, and `amount`. Do use `INNER JOIN` with `T1.link_to_event = T2.event_id` instead of `JOIN` with `e.event_id = b.link_to_event`. Do reference tables as `T1` and `T2` with aliases instead of `e` and `b`. Do place the ratio calculation `T1.spent / T1.amount` directly in the `ORDER BY` clause instead of creating an alias `spend_to_budget_ratio` in the SELECT list. Do maintain the same `WHERE` filter for `status = 'Closed'` and `LIMIT 1` with descending order. The amended query now correctly focuses on retrieving only the event name with the highest spend-to-budget ratio for closed events."
        ],
        "rules": [
            "1) When the question asks for the highest spend-to-budget ratio among closed events: select only T2.event_name as the output column. 2) When combining budget (T1) and event (T2) tables: link rows where T1.link_to_event = T2.event_id using an inner match. 3) When filtering for closed events: include only rows where T2.status = 'Closed'. 4) When calculating the spend-to-budget ratio: compute T1.spent / T1.amount directly in the ordering clause. 5) When finding the highest ratio: order rows by (T1.spent / T1.amount) in descending order and keep only the first row. Output columns (ordered): T2.event_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_id, e.event_name, e.event_date, e.type, e.notes, e.location, e.status, b.budget_id, b.category, b.spent, b.remaining, b.amount, (b.spent / b.amount) AS spend_to_budget_ratio\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.status = 'Closed'\nORDER BY spend_to_budget_ratio DESC\nLIMIT 1;",
            "SELECT T2.event_name\nFROM budget T1\nINNER JOIN event T2 ON T1.link_to_event = T2.event_id\nWHERE T2.status = 'Closed'\nORDER BY (T1.spent / T1.amount) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.event_name\nFROM budget T1\nINNER JOIN event T2 ON T1.link_to_event = T2.event_id\nWHERE T2.status = 'Closed'\nORDER BY (T1.spent / T1.amount) DESC\nLIMIT 1;"
        ]
    },
    "549": {
        "question": "From which post is the tag \"bayesian\" excerpted from? Please give the body of the post.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Body FROM tags AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.ExcerptPostId WHERE T1.TagName = 'bayesian'",
        "amends": [],
        "rules": [
            "\"bayesian\" is the TagName; excerpt from refers to ExcerptPostId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Body \nFROM tags t \nJOIN posts p ON t.ExcerptPostId = p.Id \nWHERE t.TagName = 'bayesian';"
        ],
        "rule_sql": []
    },
    "1459": {
        "question": "What is the major of Garrett Gerke and which department does it belong to?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.major_name, T2.department FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'",
        "amends": [],
        "rules": [
            "major refers to major name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.major_name, m.department\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Garrett' AND mb.last_name = 'Gerke';"
        ],
        "rule_sql": []
    },
    "406": {
        "question": "Lists by ID all Creature-type cards with legal status.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
        "amends": [
            "Do join `rulings AS T2` on `T1.uuid = T2.uuid` instead of omitting this table entirely. Do change the join type to `INNER JOIN` for both joins instead of just `JOIN`. Do use exact equality `T1.types = 'Creature'` instead of the pattern match `LIKE '%Creature%'`. Do capitalize the status comparison to `'Legal'` instead of `'legal'`. Do add table aliases `T1`, `T2`, and `T3` instead of using simple aliases `c` and `l`. The amended query now correctly joins the rulings table, uses precise type matching, and proper case sensitivity for status values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining tables for card information: combine cards as T1, legalities as T3, and rulings as T2 using inner matches where T1.uuid = T2.uuid and T1.uuid = T3.uuid. 2) When filtering for Creature-type cards: use exact equality T1.types = 'Creature' instead of pattern matching. 3) When checking legal status: use exact literal comparison T3.status = 'Legal' with proper capitalization. 4) When selecting output columns: use T1.id as the identifier column. Output columns (ordered): T1.id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.id\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.types LIKE '%Creature%'\nAND l.status = 'legal';",
            "SELECT T1.id\nFROM cards AS T1\nINNER JOIN legalities AS T3 ON T1.uuid = T3.uuid\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.types = 'Creature'\nAND T3.status = 'Legal';"
        ],
        "rule_sql": [
            "SELECT T1.id\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nINNER JOIN legalities AS T3 ON T1.uuid = T3.uuid\nWHERE T1.types = 'Creature'\nAND T3.status = 'Legal'"
        ]
    },
    "985": {
        "question": "Among the drivers who participated in the French Grand Prix, who has the slowest time in the 3rd lap.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.driverId FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'French Grand Prix' AND T1.lap = 3 ORDER BY T1.time DESC LIMIT 1",
        "amends": [
            "Do select only `driverId` instead of including `forename`, `surname`, and `time` columns. Do use `INNER JOIN` with explicit `AS` table aliases `T1` and `T2` instead of implicit aliases and multiple joins. Do use exact equality `T2.name = 'French Grand Prix'` instead of pattern matching with `LIKE '%French Grand Prix%'`. Do remove the unnecessary `drivers` table join since `driverId` is available directly from `lapTimes`. Do maintain the same `ORDER BY T1.time DESC LIMIT 1` structure for finding the slowest lap time. The amended query now correctly identifies the driver with the slowest lap time in the third lap of the French Grand Prix using precise table relationships and filtering."
        ],
        "rules": [
            "1) When the question asks about drivers who participated in the French Grand Prix: use exact equality T2.name = 'French Grand Prix' instead of pattern matching.\n2) When the question asks for the slowest time in the 3rd lap: order by T1.time in descending direction and keep only the first row.\n3) When the question asks about drivers who participated in a specific race: combine T1 (lapTimes) and T2 (races) where T1.raceId equals T2.raceId and keep only matching pairs.\n4) When filtering for lap number: use exact equality T1.lap = 3.\n5) When selecting output columns: include only driverId from T1 since it's available directly from lapTimes without needing the drivers table.\n6) When handling table relationships: use explicit aliases T1 for lapTimes and T2 for races with INNER JOIN.\nOutput columns (ordered): T1.driverId"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverId, d.forename, d.surname, lt.time\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nJOIN drivers d ON lt.driverId = d.driverId\nWHERE r.name LIKE '%French Grand Prix%' AND lt.lap = 3\nORDER BY lt.time DESC\nLIMIT 1;",
            "SELECT T1.driverId\nFROM lapTimes AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nWHERE T2.name = 'French Grand Prix' AND T1.lap = 3\nORDER BY T1.time DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.driverId \nFROM lapTimes T1 \nINNER JOIN races T2 ON T1.raceId = T2.raceId \nWHERE T2.name = 'French Grand Prix' \nAND T1.lap = 3 \nORDER BY T1.time DESC \nLIMIT 1"
        ]
    },
    "19": {
        "question": "What is the phone number of the school that has the highest average score in Math?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY T2.AvgScrMath DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` with alias `T2` instead of `JOIN` with alias `sc`. Do change the join condition to `T1.CDSCode = T2.cds` instead of `s.CDSCode = sc.cds`. Do remove the subquery filter `WHERE sc.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores)` instead of keeping it. Do add `ORDER BY T2.AvgScrMath DESC LIMIT 1` instead of omitting it, which correctly retrieves the school with the highest math score rather than potentially returning multiple schools tied for maximum score. The amended query now matches RIGHT_SQL's behavior by using ordering and limiting to find the single highest-scoring school."
        ],
        "rules": [
            "1) When the question asks for the highest average score in Math: rank rows by T2.AvgScrMath in descending order and keep the first 1 row.\n2) When combining T1 and T2 for shared entities: link rows where T1.CDSCode = T2.cds exactly as shown; keep only matching pairs (inner match).\n3) When the question asks for a phone number: output the exact token T1.Phone.\n4) When handling ordering ties: break ties using the canonical key if needed, though the amends specify LIMIT 1 which returns exactly one row.\nOutput columns (ordered): T1.Phone"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.Phone\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores);",
            "SELECT s.Phone \nFROM schools s\nINNER JOIN satscores T2 ON s.CDSCode = T2.cds\nORDER BY T2.AvgScrMath DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Phone\nFROM schools T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nORDER BY T2.AvgScrMath DESC\nLIMIT 1;"
        ]
    },
    "527": {
        "question": "What are the rulings for the card named and designed by Kev Walker? List them in descending order of dates.",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Kev Walker' ORDER BY T2.date DESC",
        "amends": [
            "Do reference the `text` column from the `rulings` table instead of selecting both `date` and `text` columns. Do use `INNER JOIN` with the join condition `T2.uuid = T1.uuid` instead of `JOIN` with `r.uuid = c.uuid`. Do filter on `T1.artist = 'Kev Walker'` in the WHERE clause instead of `c.artist = 'Kev Walker'`. Do order by `T2.date DESC` instead of `r.date DESC`. The amended query now correctly retrieves only the text column from rulings for cards by the specified artist, ordered by date."
        ],
        "rules": [
            "1) When the question asks for rulings for cards by a specific artist: filter rows where T1.artist equals 'Kev Walker' exactly as specified. 2) When combining rulings and cards tables: link rows where T2.uuid equals T1.uuid to find matching pairs (inner match). 3) When ordering rulings by date: sort T2.date in descending order (most recent first). 4) When selecting output columns: include only T2.text from the rulings table. 5) Output columns (ordered): T2.text"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.date, r.text\nFROM rulings r\nJOIN cards c ON r.uuid = c.uuid\nWHERE c.artist = 'Kev Walker'\nORDER BY r.date DESC;",
            "SELECT T2.text \nFROM cards T1\nINNER JOIN rulings T2 ON T2.uuid = T1.uuid\nWHERE T1.artist = 'Kev Walker'\nORDER BY T2.date DESC"
        ],
        "rule_sql": [
            "SELECT T2.text \nFROM cards T1 \nINNER JOIN rulings T2 ON T2.uuid = T1.uuid \nWHERE T1.artist = 'Kev Walker' \nORDER BY T2.date DESC"
        ]
    },
    "472": {
        "question": "Among the sets in the block \"Ice Age\", how many of them have an Italian translation?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block = 'Ice Age' AND T2.language = 'Italian' AND T2.translation IS NOT NULL",
        "amends": [],
        "rules": [
            "sets in the block \"Ice Age\" refers to block = 'Ice Age'; Italian translation refers to language = 'Italian' and translation is not null"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT s.code) AS italian_translated_sets_count\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Ice Age' AND st.language = 'Italian' AND st.translation IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "543": {
        "question": "For the post that got the most number of answers owned by csgillespie, how many answers did it get?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT MAX(T1.AnswerCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; the most number of answer refers to Max(AnswerCount)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(AnswerCount) AS MaxAnswerCount\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');"
        ],
        "rule_sql": []
    },
    "205": {
        "question": "Identify by their ID the molecules in which there is carbon.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.molecule_id FROM atom AS T WHERE T.element = 'c'",
        "amends": [],
        "rules": [
            "carbon refers to element = 'c';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.molecule_id FROM atom a WHERE a.element = 'c';"
        ],
        "rule_sql": []
    },
    "579": {
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'",
        "amends": [],
        "rules": [
            "\"How does gentle boosting differ from AdaBoost?\" is the Title of post; comments refers to Text"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Text \nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.Title = 'How does gentle boosting differ from AdaBoost?';"
        ],
        "rule_sql": []
    },
    "537": {
        "question": "How many posts does the user csgillespie own?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS post_count\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');"
        ],
        "rule_sql": []
    },
    "258": {
        "question": "What are the bond type for atoms with element Tin?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "amends": [],
        "rules": [
            "element Tin refers to element = 'sn'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'sn';"
        ],
        "rule_sql": []
    },
    "1346": {
        "question": "Tell the phone number of \"Carlo Jacobs\".",
        "db_id": "student_club",
        "ground_truth": "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs'",
        "amends": [],
        "rules": [
            "Carlo Jacobs is the full name; full name refers to first_name, last_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs';"
        ],
        "rule_sql": []
    },
    "1203": {
        "question": "How many patients who were female got white blood cells that were below 3.5?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC < 3.5 AND T1.SEX = 'F'",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patient IDs. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T2.WBC < 3.5` filter before `T1.SEX = 'F'` in the WHERE clause instead of the reverse order, though this is functionally equivalent. The amended query now correctly counts all laboratory results meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting patients with laboratory results: use COUNT(T1.ID) without DISTINCT to count all matching rows rather than unique patient IDs.\n2) When combining Patient and Laboratory tables: use table aliases T1 for Patient and T2 for Laboratory for consistency.\n3) When filtering for female patients and low white blood cells: apply both conditions T1.SEX = 'F' and T2.WBC < 3.5, though the order is functionally equivalent.\n4) When joining Patient and Laboratory tables: link rows where T1.ID = T2.ID to match patient records with their laboratory results.\n5) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'F' AND L.WBC < 3.5;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.WBC < 3.5 AND T1.SEX = 'F'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F' AND T2.WBC < 3.5"
        ]
    },
    "358": {
        "question": "What is the border color of card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT borderColor FROM cards WHERE name = 'Ancestor''s Chosen'",
        "amends": [],
        "rules": [
            "name of card  = 'Ancestor''s Chosen' ;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT borderColor FROM cards WHERE name = 'Ancestor''s Chosen';"
        ],
        "rule_sql": []
    },
    "718": {
        "question": "How many superheroes have the super power of \"Super Strength\"?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Super Strength'",
        "amends": [],
        "rules": [
            "super power of \"Super Strength\" refers to power_name = 'Super Strength'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT hero_id) \nFROM hero_power \nWHERE power_id = (SELECT id FROM superpower WHERE power_name = 'Super Strength');"
        ],
        "rule_sql": []
    },
    "1067": {
        "question": "Which teams have build up play passing more than 70? Please list their short names.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayPassing > 70",
        "amends": [],
        "rules": [
            "build up play passing refers to buildUpPlayPassing; buildUpPlayPassing > 70; short names refers to team_short_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_short_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE ta.buildUpPlayPassing > 70;"
        ],
        "rule_sql": []
    },
    "1406": {
        "question": "Among the budgets for Food, which one has the highest budgeted amount?",
        "db_id": "student_club",
        "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget )",
        "amends": [
            "Do select only `budget_id` instead of all columns with `*`. Do remove the redundant `WHERE category = 'Food'` condition from the subquery instead of keeping it, as the maximum amount calculation should consider all categories to correctly identify the highest food budget amount. Do maintain the outer query's filter on `category = 'Food'` instead of removing it to ensure only food category records are returned. The amended query now correctly identifies budget records in the food category that have the maximum budget amount across all categories."
        ],
        "rules": [
            "1) When the question asks for a specific budget among food budgets: select only the budget_id column instead of all columns. 2) When calculating the maximum amount across all categories: do not filter by category in the subquery to consider all categories for maximum calculation. 3) When filtering for food category records: maintain the outer query filter on category = 'Food' to ensure only food category records are returned. 4) When identifying records with maximum budget amount: compare the amount to the maximum amount calculated across all categories. Output columns (ordered): budget_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food');",
            "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget);"
        ],
        "rule_sql": [
            "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget);"
        ]
    },
    "658": {
        "question": "What are the titles of the top 5 posts with the highest popularity?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5",
        "amends": [],
        "rules": [
            "Higher view count means the post has higher popularity; the highest popularity refers to MAX(ViewCount);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "681": {
        "question": "Please list the users' display names whose posts had over 20000 views in 2011.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2011' AND T2.ViewCount > 20000",
        "amends": [],
        "rules": [
            "had over 20000 views in 2011 refers to ViewCount > 20000 where YEAR(CreationDate) = 2011;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ViewCount > 20000\nAND strftime('%Y', p.CreaionDate) = '2011';"
        ],
        "rule_sql": []
    },
    "944": {
        "question": "How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "WITH time_in_seconds AS ( SELECT T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6) AS REAL) ELSE CAST(SUBSTR(T1.time, 2) AS REAL) END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL AND T2.year = 2008 ), champion_time AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = 1), last_driver_incremental AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds) ) SELECT (CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)",
        "amends": [
            "Do use a CTE `time_in_seconds` to convert time strings to numeric seconds instead of relying on `julianday` functions. Do add proper `positionOrder` filtering with `WHERE positionOrder = 1` for champion instead of `position = 1`. Do calculate last driver using `MAX(positionOrder)` instead of `ORDER BY time DESC LIMIT 1`. Do convert time format with `SUBSTR` and arithmetic operations instead of date functions. Do fix the percentage calculation formula to use `(last_driver_time * 100) / (champion_time + last_driver_time)` instead of the incorrect `julianday` difference division. Do add explicit `INNER JOIN` between `results` and `races` with `ON T1.raceId = T2.raceId` instead of separate subqueries. Do handle both time formats with `CASE` statement instead of assuming single format. The amended query now correctly calculates the percentage difference in race times.",
            "Do use `T1.positionOrder` in the CTE SELECT list instead of omitting it, and do change the time parsing logic to handle `positionOrder = 1` with `SUBSTR(T1.time, 1, 1)` for hours, `SUBSTR(T1.time, 3, 2)` for minutes, and `SUBSTR(T1.time, 6)` for seconds instead of the general colon-based parsing, while using `CAST(SUBSTR(T1.time, 2) AS REAL)` for other positions instead of the original approach. Do remove `r.raceId` and `r.driverId` from the CTE SELECT list instead of including them. Do change table aliases to `T1` and `T2` instead of `r` and `rc`. Do restructure the query with separate CTEs `champion_time` and `last_driver_incremental` instead of a single CTE with CROSS JOIN. Do use subqueries `(SELECT time_seconds FROM last_driver_incremental)` and `(SELECT time_seconds FROM champion_time)` in the final calculation instead of the MAX/MIN approach with CROSS JOIN. Do change the percentage calculation to `(last_driver_time * 100) / (champion_time + last_driver_time)` instead of `(MAX(t2.time_seconds) * 100.0 / (MIN(t1.time_seconds) + MAX(t2.time_seconds))`. The amended query now correctly isolates the champion's time and last driver's time in separate CTEs and performs the accurate percentage calculation."
        ],
        "rules": [
            "1) When the question asks about a specific Grand Prix and year: filter races using exact literals \"Australian Grand Prix\" and 2008. 2) When combining results and races tables: link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match). 3) When identifying the champion driver: use positionOrder = 1 instead of position = 1. 4) When identifying the last driver: use the maximum positionOrder value instead of ordering by time. 5) When converting time strings to numeric seconds: handle multiple time formats using CASE statements with SUBSTR and arithmetic operations instead of date functions. 6) When calculating percentage difference between champion and last driver times: use the formula (last_driver_time * 100) / (champion_time + last_driver_time) instead of date difference division. 7) Output columns (ordered): percentage_faster",
            "1) When the question asks for percentage difference between champion and last driver: compute (last driver time * 100) / (champion time + last driver time) instead of using MAX/MIN with cross join.\n2) When handling time parsing for positionOrder = 1: use SUBSTR(T1.time, 1, 1) for hours, SUBSTR(T1.time, 3, 2) for minutes, and SUBSTR(T1.time, 6) for seconds instead of general colon-based parsing.\n3) When handling time parsing for other positions: use CAST(SUBSTR(T1.time, 2) AS REAL) instead of the original approach.\n4) When selecting columns for time calculation: include T1.positionOrder in the CTE SELECT list instead of omitting it.\n5) When structuring the query: use separate CTEs champion_time and last_driver_incremental instead of a single CTE with CROSS JOIN.\n6) When referencing time values: use subqueries (SELECT time_seconds FROM last_driver_incremental) and (SELECT time_seconds FROM champion_time) instead of MAX/MIN approach.\n7) When filtering for Australian Grand Prix 2008: use rc.year = 2008 AND rc.name = 'Australian Grand Prix' with exact case and spacing.\n8) When joining tables: use T1.raceId = T2.raceId for the inner join between results and races tables.\n9) When handling null values: exclude rows where r.time IS NOT NULL.\n10) Output columns (ordered): percentage_faster"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH race_info AS (\n    SELECT raceId FROM races \n    WHERE year = 2008 AND name = 'Australian Grand Prix'\n),\nchampion_time AS (\n    SELECT time FROM results \n    WHERE raceId = (SELECT raceId FROM race_info) AND position = 1\n),\nlast_driver_time AS (\n    SELECT time FROM results \n    WHERE raceId = (SELECT raceId FROM race_info) AND time IS NOT NULL\n    ORDER BY time DESC LIMIT 1\n)\nSELECT \n    ((julianday((SELECT time FROM last_driver_time)) - julianday((SELECT time FROM champion_time))) / \n    julianday((SELECT time FROM last_driver_time)) * 100 AS percentage_faster\nFROM champion_time, last_driver_time;",
            "WITH time_in_seconds AS (\n  SELECT \n    r.raceId,\n    r.driverId,\n    r.positionOrder,\n    CASE \n      WHEN r.time LIKE '%:%:%' THEN \n        (CAST(SUBSTR(r.time, 1, 2) AS REAL) * 3600 + \n        (CAST(SUBSTR(r.time, 4, 2) AS REAL) * 60 + \n        CAST(SUBSTR(r.time, 7) AS REAL)\n      WHEN r.time LIKE '%:%' THEN \n        (CAST(SUBSTR(r.time, 1, 2) AS REAL) * 60 + \n        CAST(SUBSTR(r.time, 4) AS REAL)\n      ELSE CAST(r.time AS REAL)\n    END AS time_seconds\n  FROM results r\n  INNER JOIN races rc ON r.raceId = rc.raceId\n  WHERE rc.year = 2008 \n    AND rc.name = 'Australian Grand Prix'\n    AND r.time IS NOT NULL\n)\nSELECT \n  (MAX(t2.time_seconds) * 100.0 / (MIN(t1.time_seconds) + MAX(t2.time_seconds)) AS percentage_faster\nFROM time_in_seconds t1\nCROSS JOIN time_in_seconds t2\nWHERE t1.positionOrder = 1\n  AND t2.positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds);",
            "WITH time_in_seconds AS (\n    SELECT \n        T1.positionOrder,\n        CASE \n            WHEN T1.positionOrder = 1 THEN \n                CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600 + \n                CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60 + \n                CAST(SUBSTR(T1.time, 6) AS REAL)\n            ELSE \n                CAST(SUBSTR(T1.time, 2) AS REAL)\n        END AS time_seconds\n    FROM results T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T2.year = 2008 \n    AND T2.name = 'Australian Grand Prix'\n    AND T1.time IS NOT NULL\n),\nchampion_time AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = 1\n),\nlast_driver_incremental AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds)\n)\nSELECT \n    ((SELECT time_seconds FROM last_driver_incremental) * 100.0) / \n    ((SELECT time_seconds FROM champion_time) + (SELECT time_seconds FROM last_driver_incremental)) \n    AS percentage_faster"
        ],
        "rule_sql": [
            "WITH champion_time AS (\n    SELECT \n        CAST(SUBSTR(r.time, 1, 1) AS REAL) * 3600 + \n        CAST(SUBSTR(r.time, 3, 2) AS REAL) * 60 + \n        CAST(SUBSTR(r.time, 6) AS REAL) AS time_seconds\n    FROM results r\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE rc.year = 2008 \n      AND rc.name = 'Australian Grand Prix'\n      AND r.positionOrder = 1\n      AND r.time IS NOT NULL\n),\nlast_driver_incremental AS (\n    SELECT \n        CAST(SUBSTR(r.time, 2) AS REAL) AS time_seconds\n    FROM results r\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE rc.year = 2008 \n      AND rc.name = 'Australian Grand Prix'\n      AND r.positionOrder = (SELECT MAX(positionOrder) FROM results r2 JOIN races rc2 ON r2.raceId = rc2.raceId WHERE rc2.year = 2008 AND rc2.name = 'Australian Grand Prix')\n      AND r.time IS NOT NULL\n)\nSELECT \n    (last_driver_incremental.time_seconds * 100) / (champion_time.time_seconds + last_driver_incremental.time_seconds) AS percentage_faster\nFROM champion_time, last_driver_incremental;"
        ]
    },
    "667": {
        "question": "What is the title of the post with the oldest post link?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY T1.CreaionDate LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` with `T2.PostId = T1.Id` instead of `JOIN` with `p.Id = pl.PostId`. Do add `ORDER BY T1.CreationDate LIMIT 1` instead of the subquery `WHERE pl.CreationDate = (SELECT MIN(CreationDate) FROM postLinks)`. Do remove the subquery filter instead of keeping it. Do change table aliases to `T1` and `T2` instead of `p` and `pl`. The amended query now correctly retrieves the earliest post by creation date using proper ordering and limiting instead of an inefficient subquery approach.",
            "Do use `AS` for table aliases in both the `posts AS T1` and `postLinks AS T2` clauses instead of omitting the explicit alias keyword. Do correct the column reference to `T1.CreationDate` instead of the misspelled `T1.CreaionDate` in the ORDER BY clause. The amended query now matches RIGHT_SQL's behavior with proper alias syntax and correct column spelling.",
            "Do use `T1.CreaionDate` instead of `T1.CreationDate` in the ORDER BY clause to match the correct column name. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining posts and postLinks tables: link rows where T2.PostId equals T1.Id exactly and keep only matching pairs (inner match). 2) When the question asks for the oldest post by creation date: order rows by T1.CreationDate in ascending direction and keep only the first 1 row. 3) When choosing table aliases: use T1 for posts table and T2 for postLinks table. 4) Output columns (ordered): T1.Title",
            "1) When the question asks for the title of the oldest post: order rows by T1.CreationDate in ascending order and keep the first 1 row.\n2) When combining posts and postLinks tables: link rows where T2.PostId = T1.Id and keep only matching pairs (inner match).\n3) When using table aliases: always use explicit AS keyword for both posts AS T1 and postLinks AS T2.\n4) When referring to the CreationDate column: use the exact spelling T1.CreationDate, not T1.CreaionDate.\n5) Output columns (ordered): T1.Title",
            "1) When the question asks for the oldest post link: order rows by T1.CreaionDate in ascending order and keep the first 1 row.\n2) When combining posts and postLinks tables: link rows where T2.PostId equals T1.Id exactly as shown; keep only matching pairs (inner match).\n3) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.\n4) When handling text literals: do not change case, spacing, or punctuation.\n5) When referring to table roles: do not rename or swap the aliases T1, T2 once set for this schema.\n6) Output columns (ordered): T1.Title"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Title \nFROM posts p \nJOIN postLinks pl ON p.Id = pl.PostId \nWHERE pl.CreationDate = (SELECT MIN(CreationDate) FROM postLinks);",
            "SELECT T1.Title FROM posts T1 INNER JOIN postLinks T2 ON T2.PostId = T1.Id ORDER BY T1.CreationDate LIMIT 1",
            "SELECT T1.Title \nFROM posts AS T1 \nINNER JOIN postLinks AS T2 ON T2.PostId = T1.Id \nORDER BY T1.CreationDate \nLIMIT 1",
            "SELECT T1.Title \nFROM posts AS T1 \nINNER JOIN postLinks AS T2 ON T2.PostId = T1.Id \nORDER BY T1.CreaionDate \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Title\nFROM posts AS T1\nINNER JOIN postLinks AS T2 ON T2.PostId = T1.Id\nORDER BY T1.CreaionDate ASC\nLIMIT 1;"
        ]
    },
    "20": {
        "question": "How many schools in Amador which the Low Grade is 9 and the High Grade is 12?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(T1.`School Name`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Amador' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT CDSCode) \nFROM frpm \nWHERE `County Name` = 'Amador' \nAND `Low Grade` = '9' \nAND `High Grade` = '12';"
        ],
        "rule_sql": []
    },
    "957": {
        "question": "How many Italian drivers haven't finished the race?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Italian' AND T1.time IS NULL",
        "amends": [
            "Do use `COUNT(T1.driverId)` without DISTINCT instead of `COUNT(DISTINCT d.driverId)` to count all Italian drivers who didn't finish rather than unique ones. Do reference `results AS T1` and `drivers AS T2` instead of `drivers d` and `results r` for table aliases. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do place the join condition `T1.driverId = T2.driverId` instead of `d.driverId = r.driverId` to maintain the same logical relationship. Do keep the filter `T2.nationality = 'Italian'` instead of `d.nationality = 'Italian'` and `T1.time IS NULL` instead of `r.time IS NULL` to maintain the same filtering logic. Do remove the column alias `AS italian_drivers_not_finished` instead of keeping it since the right query doesn't include it. The amended query now correctly counts all Italian drivers who didn't finish races rather than just distinct ones, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When counting Italian drivers who haven't finished races: use COUNT(T1.driverId) without DISTINCT to count all occurrences rather than unique drivers.\n2) When combining drivers and results tables: use INNER JOIN with condition T1.driverId = T2.driverId to link race results to drivers.\n3) When filtering for Italian drivers: use T2.nationality = 'Italian' with exact case and spacing.\n4) When identifying unfinished races: use T1.time IS NULL to find races where no finish time was recorded.\n5) When producing output: do not include column aliases like AS italian_drivers_not_finished.\n6) When assigning table aliases: use results AS T1 and drivers AS T2 as the canonical reference.\nOutput columns (ordered): COUNT(T1.driverId)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT d.driverId) AS italian_drivers_not_finished\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE d.nationality = 'Italian' AND r.time IS NULL;",
            "SELECT COUNT(T1.driverId)\nFROM results AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'Italian' AND T1.time IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.nationality = 'Italian' AND T1.time IS NULL"
        ]
    },
    "1065": {
        "question": "Please list all team names which the speed class is fast.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "amends": [],
        "rules": [
            "team names refers to team_long_name; speed class refers to buildUpPlaySpeedClass; buildUpPlaySpeedClass = 'Fast';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_long_name \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE ta.buildUpPlaySpeedClass = 'Fast';"
        ],
        "rule_sql": []
    },
    "902": {
        "question": "Which race was Alex Yoong in when he was in track number less than 20?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
        "amends": [
            "Do select only `name` instead of multiple columns `race_name`, `date`, `year`, `round`. Do join `driverStandings` instead of `results` as the primary table. Do use `INNER JOIN` on `driverStandings.raceId = races.raceId` instead of joining directly on `results.raceId = races.raceId`. Do join `drivers` through `driverStandings.driverId` instead of `results.driverId`. Do filter on `driverStandings.position < 20` instead of `results.position < 20`. Do remove the `AS` aliases for table names instead of keeping them. The amended query now correctly uses the driver standings data instead of race results to find positions, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for a race name: select only the \"name\" column from the races table instead of multiple columns like \"date\", \"year\", and \"round\".\n2) When joining tables to find driver positions: use the driverStandings table as the primary table instead of the results table.\n3) When combining driverStandings and races tables: link rows where driverStandings.raceId equals races.raceId using an inner join.\n4) When joining drivers table: connect through driverStandings.driverId instead of results.driverId.\n5) When filtering by position less than 20: use driverStandings.position < 20 instead of results.position < 20.\n6) When selecting columns: do not use AS aliases for table names in the output.\n7) When searching for driver Alex Yoong: use exact literals 'Alex' for forename and 'Yoong' for surname.\nOutput columns (ordered): races.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name AS race_name, r.date, r.year, r.round \nFROM results res \nJOIN drivers d ON res.driverId = d.driverId \nJOIN races r ON res.raceId = r.raceId \nWHERE d.forename = 'Alex' AND d.surname = 'Yoong' AND res.position < 20;",
            "SELECT races.name FROM races INNER JOIN driverStandings ON driverStandings.raceId = races.raceId INNER JOIN drivers ON drivers.driverId = driverStandings.driverId WHERE drivers.forename = 'Alex' AND drivers.surname = 'Yoong' AND driverStandings.position < 20"
        ],
        "rule_sql": [
            "SELECT races.name FROM driverStandings JOIN races ON driverStandings.raceId = races.raceId JOIN drivers ON driverStandings.driverId = drivers.driverId WHERE drivers.forename = 'Alex' AND drivers.surname = 'Yoong' AND driverStandings.position < 20"
        ]
    },
    "1391": {
        "question": "What is the ratio between students majored in finance and physics?",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) / SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END) AS ratio FROM major",
        "amends": [
            "Do remove the `member` table join and instead query directly from the `major` table. Do remove the `CAST` to `REAL` and `NULLIF` function and instead use direct division between the sums. Do change the alias from `finance_to_physics_ratio` to `ratio` instead of keeping the longer name. Do remove the unnecessary `CASE` condition checks for `major.major_name` and instead use `major_name` directly. The amended query now correctly calculates the ratio of Finance to Physics majors without unnecessary joins and type conversions, matching the right SQL's behavior.",
            "Do use a single query with conditional aggregation using `SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END)` instead of nested subqueries with `COUNT(*)` and `IN` clauses. Do reference the `major` table directly in the `FROM` clause instead of using multiple subqueries against the `member` table. Do calculate the ratio directly from the `major` table's `major_name` field instead of joining through the `member` table's `link_to_major` foreign key. Do remove the unnecessary multiplication by `1.0` for type conversion since the division of integers in this context will produce the correct numeric result. The amended query now correctly calculates the ratio of Finance to Physics majors directly from the source data without the potential data integrity issues of the nested subquery approach."
        ],
        "rules": [
            "1) When calculating a ratio between two specific values in a column: compute (number of rows where major.major_name equals 'Finance') divided by (number of rows where major.major_name equals 'Physics'). 2) When the question asks for a ratio between two categories: use direct division between the counts without type conversion functions. 3) When the output column represents a ratio: name the output column as 'ratio'. 4) When querying from a single table that contains all needed information: do not join additional tables. 5) When counting occurrences of specific text values: use the exact literal values 'Finance' and 'Physics' with matching case and spelling. Output columns (ordered): ratio",
            "1) When calculating ratios between counts of different categories: use conditional aggregation with SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of nested subqueries with COUNT(*) and IN clauses.\n2) When the question asks for a ratio between students majored in 'Finance' and 'Physics': compute (number of rows where major_name = 'Finance') divided by (number of rows where major_name = 'Physics'), guarding division by zero.\n3) When working with the major table: reference the table directly in the FROM clause instead of using multiple subqueries through foreign key relationships.\n4) When handling text literals for major names: preserve exact case and spelling as 'Finance' and 'Physics'.\n5) When performing division of integer counts: do not multiply by 1.0 for type conversion as the division will produce the correct numeric result.\n6) Output columns (ordered): ratio"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN major.major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN major.major_name = 'Physics' THEN 1 ELSE 0 END), 0) AS finance_to_physics_ratio\nFROM \n    member\nJOIN \n    major ON member.link_to_major = major.major_id;",
            "SELECT \n    (SELECT COUNT(*) FROM member WHERE link_to_major IN (SELECT major_id FROM major WHERE major_name = 'Finance')) * 1.0 / \n    (SELECT COUNT(*) FROM member WHERE link_to_major IN (SELECT major_id FROM major WHERE major_name = 'Physics')) AS ratio",
            "SELECT \n    CAST(SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END), 0) AS ratio\nFROM \n    major"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END), 0) AS ratio\nFROM major;"
        ]
    },
    "929": {
        "question": "Please list the Formula_1 races that Lewis Hamilton participated.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "amends": [
            "Do select only `T1.name` instead of including `r.name AS race_name`, `r.year`, and `c.name AS circuit_name`. Do remove the `JOIN circuits c` table entirely instead of keeping it. Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `res`, and `d`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use `T2.raceId = T1.raceId` instead of `res.raceId = r.raceId` for the join condition. Do use `T3.driverId = T2.driverId` instead of `res.driverId = d.driverId` for the driver join. The amended query now correctly returns only race names for Lewis Hamilton's races without unnecessary circuit information."
        ],
        "rules": [
            "1) When the question asks for Formula_1 races that Lewis Hamilton participated: select only T1.name from the races table (T1). 2) When joining tables for driver participation information: use INNER JOIN between T1 (races) and T2 (results) where T2.raceId = T1.raceId. 3) When filtering for Lewis Hamilton: use INNER JOIN between T2 (results) and T3 (drivers) where T3.driverId = T2.driverId and apply conditions T3.forename = 'Lewis' AND T3.surname = 'Hamilton'. 4) When the schema includes circuit information but the question doesn't require it: do not include the circuits table or any circuit-related columns. 5) Output columns (ordered): T1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name AS race_name, r.year, c.name AS circuit_name\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nJOIN drivers d ON res.driverId = d.driverId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';\n",
            "SELECT T1.name FROM races T1 INNER JOIN results T2 ON T2.raceId = T1.raceId INNER JOIN drivers T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM races T1\nINNER JOIN results T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'"
        ]
    },
    "1292": {
        "question": "What is the anti Cardiolipin antibody concentration of the female patient with the highest uric acid level in the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T1.SEX = 'F' AND T2.UA > 6.5 ORDER BY T2.UA DESC LIMIT 1",
        "amends": [
            "Do use `T3` aliases for column references instead of direct table references. Do change the join condition from `p.ID = e.ID` to `T3.ID = T2.ID` to properly connect Examination to Laboratory instead of directly to Patient. Do replace the complex subquery with a simple `T2.UA > 6.5` filter instead of the nested maximum calculation. Do add `ORDER BY T2.UA DESC` to find the highest UA value instead of relying on a subquery maximum. Do remove the unnecessary subqueries and nested ID lookups instead of maintaining the complex structure. The amended query now correctly retrieves the examination results for female patients with the highest UA value above 6.5, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for anti Cardiolipin antibody concentration: include columns T3.\"aCL IgG\", T3.\"aCL IgM\", and T3.\"aCL IgA\" in the output.\n2) When filtering for female patients: include only rows where T1.SEX equals 'F' exactly.\n3) When filtering for uric acid levels in the normal range: include only rows where T2.UA is greater than 6.5.\n4) When finding the patient with the highest uric acid level: order all matching rows by T2.UA in descending order and take only the first row.\n5) When combining Patient, Laboratory, and Examination tables: link rows where T1.ID = T2.ID and T3.ID = T2.ID to ensure proper table connections.\n6) Output columns (ordered): T3.\"aCL IgG\", T3.\"aCL IgM\", T3.\"aCL IgA\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.\"aCL IgG\", e.\"aCL IgM\", e.\"aCL IgA\"\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE p.SEX = 'F'\n  AND l.UA = (SELECT MAX(UA) FROM Laboratory WHERE UA > 6.50 AND ID IN (SELECT ID FROM Patient WHERE SEX = 'F'))\nLIMIT 1;",
            "SELECT T3.\"aCL IgG\", T3.\"aCL IgM\", T3.\"aCL IgA\" \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nJOIN Examination T3 ON T2.ID = T3.ID \nWHERE T1.SEX = 'F' AND T2.UA > 6.5 \nORDER BY T2.UA DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T3.\"aCL IgG\", T3.\"aCL IgM\", T3.\"aCL IgA\"\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nJOIN Examination T3 ON T2.ID = T3.ID\nWHERE T1.SEX = 'F'\nAND T2.UA > 6.5\nORDER BY T2.UA DESC\nLIMIT 1"
        ]
    },
    "989": {
        "question": "Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___'",
        "amends": [
            "Do select only `T1.time` instead of including `d.forename` and `d.surname`. Do use `INNER JOIN races AS T2` instead of joining with `drivers d`. Do remove the `JOIN drivers` condition entirely instead of keeping it. Do change the filter to `T1.time LIKE '_:%:__.___'` instead of `r.positionOrder = 1`. Do use table aliases `T1` for `results` and `T2` for `races` instead of `r`, `ra`, and `d`. The amended query now correctly filters for time format patterns instead of position order and eliminates unnecessary driver information."
        ],
        "rules": [
            "1) When the question asks for the champion of a specific Grand Prix and year: filter T2.name to exactly 'Canadian Grand Prix' and T2.year to exactly 2008.\n2) When identifying the champion by finish time pattern: filter T1.time using the pattern '_:%:__.___' to match time format.\n3) When selecting output columns: include only T1.time as the finish time.\n4) When combining results and races tables: link rows where T1.raceId equals T2.raceId using inner match.\n5) Output columns (ordered): T1.time"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname, r.time\nFROM races ra\nJOIN results r ON ra.raceId = r.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.name = 'Canadian Grand Prix' AND ra.year = 2008 AND r.positionOrder = 1;",
            "SELECT T1.time \nFROM results AS T1 \nINNER JOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T2.name = 'Canadian Grand Prix' \nAND T2.year = 2008 \nAND T1.time LIKE '_:%:__.___'"
        ],
        "rule_sql": [
            "SELECT T1.time \nFROM results T1 \nINNER JOIN races T2 ON T1.raceId = T2.raceId \nWHERE T2.name = 'Canadian Grand Prix' \nAND T2.year = 2008 \nAND T1.time LIKE '_:%:__.___' \nAND T1.position = 1"
        ]
    },
    "611": {
        "question": "Mention the reputation of users who had obtained the badge on 7/19/2010 7:39:08 PM.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'",
        "amends": [
            "Do use `T1.Reputation` instead of `u.Reputation, u.DisplayName` to select only the reputation column instead of both reputation and display name. Do use `users AS T1` and `badges AS T2` instead of `users u` and `badges b` for explicit table aliasing. Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do use `T1.Id = T2.UserId` instead of `b.UserId = u.Id` for the join condition, maintaining the same logical relationship but with consistent alias usage. Do use `T2.Date` instead of `b.Date` in the WHERE clause filter, ensuring the date condition is applied to the badges table with the correct alias. The amended query now correctly returns only reputation data for users with badges on the specified date, matching the RIGHT_SQL's behavior.",
            "Do use the exact timestamp format '2010-07-19 19:39:08.0' with milliseconds precision in the WHERE filter instead of '2010-07-19 19:39:08' without milliseconds to ensure proper date matching with the stored timestamp values in the database. The amended query now correctly matches the RIGHT_SQL's behavior by using the precise timestamp format that includes milliseconds for accurate date comparison."
        ],
        "rules": [
            "1) When the question asks for reputation of users who obtained a badge on a specific date: select only T1.Reputation from the users table. 2) When combining users and badges tables: link rows where T1.Id = T2.UserId using an inner match. 3) When filtering for badges obtained on '2010-07-19 19:39:08.0': apply the date condition to T2.Date column. 4) When using table aliases: refer to users as T1 and badges as T2 consistently throughout the query. 5) Output columns (ordered): T1.Reputation",
            "1) When the question asks for reputation of users who obtained a badge at a specific timestamp: filter badges using the exact timestamp format '2010-07-19 19:39:08.0' with milliseconds precision to match stored timestamp values.\n2) When combining users and badges tables: link rows where T1.Id = T2.UserId to find users who obtained badges.\n3) Output columns (ordered): T1.Reputation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.Reputation, u.DisplayName\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE b.Date = '2010-07-19 19:39:08.0';",
            "SELECT T1.Reputation\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.Id = T2.UserId\nWHERE T2.Date = '2010-07-19 19:39:08'",
            "SELECT T1.Reputation\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.Id = T2.UserId\nWHERE T2.Date = '2010-07-19 19:39:08.0'"
        ],
        "rule_sql": [
            "SELECT T1.Reputation \nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T2.Date = '2010-07-19 19:39:08.0'"
        ]
    },
    "1483": {
        "question": "How much did customer 6 consume in total between August and November 2013?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUM(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'",
        "amends": [],
        "rules": [
            "Between August And November 2013 refers to Between 201308 And 201311; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(Consumption) AS TotalConsumption FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311';"
        ],
        "rule_sql": []
    },
    "1317": {
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
        "amends": [
            "Do count `T1.event_id` instead of `COUNT(*)` to ensure accurate counting of distinct events. Do use explicit `INNER JOIN` syntax with table aliases `T1`, `T2`, and `T3` instead of implicit joins without aliases. Do join `event AS T1` with `attendance AS T2` on `T1.event_id = T2.link_to_event` instead of the original join order. Do join `attendance AS T2` with `member AS T3` on `T2.link_to_member = T3.member_id` instead of the reverse direction. Do use double quotes in the string literal `Women''s Soccer` instead of escaped single quotes for proper SQL string handling. The amended query now correctly counts medium shirt attendees for Women's Soccer events with proper join relationships and string formatting.",
            "Do count `T1.event_id` instead of `COUNT(*)` to ensure accurate counting of specific event records. Do use uppercase 'Medium' in `T3.t_shirt_size = 'Medium'` instead of lowercase 'medium' to match the proper case-sensitive value format in the database. The amended query now correctly counts event records for Women's Soccer attendees with medium t-shirt sizes using proper case matching and specific column counting."
        ],
        "rules": [
            "1) When counting attendees for a specific event: count using the exact event identifier token T1.event_id instead of counting all rows. 2) When joining tables for event attendance relationships: use explicit INNER JOIN syntax with table aliases T1 for event, T2 for attendance, and T3 for member. 3) When linking event and attendance tables: match rows where T1.event_id equals T2.link_to_event exactly. 4) When linking attendance and member tables: match rows where T2.link_to_member equals T3.member_id exactly. 5) When filtering for the event \"Women's Soccer\": use the exact string literal \"Women''s Soccer\" with double quotes and proper SQL string formatting. 6) When filtering for medium T-shirt size: use the exact column token T3.t_shirt_size and the exact literal value 'Medium'. 7) Output columns (ordered): COUNT(T1.event_id) AS medium_shirt_attendees",
            "1) When counting event records for attendees: count using the exact identifier T1.event_id instead of a generic count of all columns. 2) When filtering for t-shirt size values: use the exact literal 'Medium' with uppercase M instead of 'medium' to match case-sensitive database format. 3) When the question asks about students from Student_Club who attended \"Women's Soccer\": filter for T1.event_name = \"Women's Soccer\" and T3.t_shirt_size = 'Medium'. 4) When combining tables for attendance records: link rows where T1.event_id = T2.link_to_event and T2.link_to_member = T3.member_id, keeping only matching pairs (inner match). 5) Output columns (ordered): COUNT(T1.event_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS medium_shirt_attendees\nFROM member\nJOIN attendance ON member.member_id = attendance.link_to_member\nJOIN event ON attendance.link_to_event = event.event_id\nWHERE event.event_name = 'Women\\'s Soccer' AND member.t_shirt_size = 'Medium';",
            "SELECT COUNT(*) \nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = \"Women's Soccer\"\nAND T3.t_shirt_size = 'medium';",
            "SELECT COUNT(T1.event_id) \nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = \"Women's Soccer\" \nAND T3.t_shirt_size = 'Medium'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.event_id) AS medium_shirt_attendees\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = \"Women's Soccer\"\nAND T3.t_shirt_size = 'Medium';"
        ]
    },
    "295": {
        "question": "How many atoms belong to the molecule that element is hydrogen and labeled with carcinogenic compound?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T1.atom_id) AS atomnums_h FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'h'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; hydrogen refers to element = h'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'h' AND m.label = '+';"
        ],
        "rule_sql": []
    },
    "396": {
        "question": "How many cards with a 1993 frame version and available on paper have a sensitive content warning?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE frameVersion = 1993 AND availability = 'paper' AND hasContentWarning = 1",
        "amends": [],
        "rules": [
            "sensitive content warning refer to hasContentWarning = 1; available on paper refer to availability = 'paper' 1993 refer to frameVersion"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE frameVersion = '1993' \nAND (hasNonFoil = 1 OR hasFoil = 1) \nAND hasContentWarning = 1;"
        ],
        "rule_sql": []
    },
    "553": {
        "question": "Among the badges obtained by csgillespie, how many of them were obtained in the year 2011?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE STRFTIME('%Y', T1.Date) = '2011' AND T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; obtained in 2011 refers to YEAR (Date) = 2011"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS BadgeCount\nFROM badges\nJOIN users ON badges.UserId = users.Id\nWHERE users.DisplayName = 'csgillespie'\nAND strftime('%Y', badges.Date) = '2011';"
        ],
        "rule_sql": []
    },
    "1486": {
        "question": "Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') FROM customers WHERE Segment = 'SME'",
        "amends": [
            "Do use `SUM(Currency = 'CZK') - SUM(Currency = 'EUR')` instead of `COUNT(CASE WHEN c.Currency = 'CZK' THEN 1 END) - COUNT(CASE WHEN c.Currency = 'EUR' THEN 1 END)` for more efficient boolean aggregation. Do remove the unnecessary `JOIN transactions_1k t ON c.CustomerID = t.CustomerID` instead of including it, as the customer currency data is already available in the customers table. Do keep the `WHERE Segment = 'SME'` filter in the same position. The amended query now correctly calculates the difference between CZK and EUR customers without the extraneous join that could distort counts through duplicate transactions."
        ],
        "rules": [
            "1) When the question asks for a count difference between two currency types for SME customers: compute the difference between the count of customers with Currency = 'CZK' and the count of customers with Currency = 'EUR'.\n2) When filtering for SME customers: apply the condition Segment = 'SME' to the customers table.\n3) When counting boolean conditions: use SUM() aggregation with direct boolean comparisons (Currency = 'CZK') instead of CASE statements for efficiency.\n4) When the schema shows currency data is available directly in the customers table: do not join to additional tables like transactions_1k that could introduce duplicate counts.\n5) Output columns (ordered): MoreSMEsInCZK"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.Currency = 'CZK' THEN 1 END) - COUNT(CASE WHEN c.Currency = 'EUR' THEN 1 END)) AS MoreSMEsInCZK\nFROM \n    customers c\nJOIN \n    transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE \n    c.Segment = 'SME';",
            "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') AS difference\nFROM customers\nWHERE Segment = 'SME';"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END) - SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS MoreSMEsInCZK\nFROM customers\nWHERE Segment = 'SME';"
        ]
    },
    "923": {
        "question": "How many Formula_1 races took place on the circuits in Italy?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Italy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS race_count\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Italy';"
        ],
        "rule_sql": []
    },
    "826": {
        "question": "Identify the heaviest superhero in DC Comics.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "amends": [
            "Do select only `superhero_name` instead of including `weight_kg` in the SELECT list. Do use `INNER JOIN` with table aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do remove the subquery that finds maximum weight and instead use `ORDER BY T1.weight_kg DESC LIMIT 1` to get the heaviest superhero directly. Do omit the weight comparison condition in WHERE and instead handle the ranking through the ORDER BY and LIMIT clause. The amended query now correctly returns only the name of the heaviest DC Comics superhero by sorting and limiting rather than using a complex subquery approach."
        ],
        "rules": [
            "1) When the question asks for the \"heaviest\" superhero: rank rows by T1.weight_kg in descending order and keep the first 1 row.\n2) When the question specifies \"DC Comics\" publisher: filter rows where T2.publisher_name equals 'DC Comics' exactly.\n3) When combining T1 and T2 for shared entities: link rows where T1.publisher_id = T2.id; keep only matching pairs (inner match).\n4) When the question asks to identify a superhero: output only the superhero_name column.\n5) When handling text literals: preserve the exact case and spacing of 'DC Comics'.\nOutput columns (ordered): T1.superhero_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name, s.weight_kg\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'DC Comics'\nAND s.weight_kg = (SELECT MAX(weight_kg) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'DC Comics'));",
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'DC Comics'\nORDER BY T1.weight_kg DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'DC Comics'\nORDER BY s.weight_kg DESC\nLIMIT 1;"
        ]
    },
    "1071": {
        "question": "List the football team that has a build up play speed of 31, build up plan dribbling of 53, and build up play passing of 32. Only indicate the short name of the team.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeed = 31 AND t2.buildUpPlayDribbling = 53 AND t2.buildUpPlayPassing = 32",
        "amends": [],
        "rules": [
            "build up play speed refers to buildUpPlaySpeed; buildUpPlaySpeed = 31; build up play dribbling refers to buildUpPlayDribbling; buildUpPlayDribbling = 53; build up play passing refers to buildUpPlayPassing; buildUpPlayPassing = 32; short name of the team refers to team_short_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_short_name \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE ta.buildUpPlaySpeed = 31 \nAND ta.buildUpPlayDribbling = 53 \nAND ta.buildUpPlayPassing = 32;"
        ],
        "rule_sql": []
    },
    "1444": {
        "question": "List the expenses that spend more than fifty dollars on average.",
        "db_id": "student_club",
        "ground_truth": "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50",
        "amends": [
            "Do select only `expense_description` instead of multiple columns including `expense_id`, `expense_date`, `cost`, `approved`, `link_to_member`, and `link_to_budget`. Do use `GROUP BY expense_description` with `HAVING AVG(cost) > 50` instead of filtering individual rows with `WHERE cost > (SELECT AVG(cost) FROM expense)` and an additional subquery condition. Do remove the redundant subquery that calculated the same average twice instead of keeping it. Do eliminate the unnecessary subquery correlation that didn't reference outer scope instead of maintaining it. The amended query now correctly groups expenses by description and filters for groups where the average cost exceeds 50, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for expenses that spend more than fifty dollars on average: group rows by expense_description and compute the average cost per group. 2) When filtering groups by average cost: only keep groups where the average cost exceeds 50. 3) When selecting output for expense descriptions: return only the expense_description column instead of multiple columns. 4) When computing averages for groups: use the HAVING clause instead of filtering individual rows with WHERE and subqueries. 5) When the question mentions \"on average\": calculate the average cost per expense description group. Output columns (ordered): expense_description"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT expense_id, expense_description, expense_date, cost, approved, link_to_member, link_to_budget FROM expense WHERE cost > (SELECT AVG(cost) FROM expense) AND (SELECT AVG(cost) FROM expense) > 50;",
            "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50"
        ],
        "rule_sql": [
            "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50;"
        ]
    },
    "882": {
        "question": "Which year was the first Singapore Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT year FROM races WHERE name = 'Singapore Grand Prix' ORDER BY year ASC LIMIT 1",
        "amends": [],
        "rules": [
            "the first race refers to race happened in min(year);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(year) AS first_year FROM races WHERE name LIKE '%Singapore Grand Prix%';"
        ],
        "rule_sql": []
    },
    "494": {
        "question": "For all cards illustrated by Jim Pavelec. and describe the text of the ruling of these cards. Do these cards have missing or degraded properties and values.",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.text , CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec'",
        "amends": [
            "Do use `T2.text` without an alias instead of `r.text AS ruling_text` for the ruling text column. Do use `CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END` with uppercase 'YES'/'NO' instead of mixed case 'Yes'/'No' and omit the alias `has_missing_or_degraded_properties`. Do remove `c.name AS card_name` instead of including it in the SELECT list. Do specify `INNER JOIN` explicitly instead of just `JOIN` for the join type. Do use `T2.uuid = T1.uuid` instead of `c.uuid = r.uuid` for the join condition while maintaining the same logical relationship. Do use table aliases `T1` and `T2` instead of `c` and `r` while keeping the same table references. The amended query now correctly focuses only on the ruling text and content warning status without the unnecessary card name column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cards illustrated by a specific artist: filter rows where T1.artist equals exactly 'Jim Pavelec.' with the period included. 2) When combining card and ruling information: link rows where T2.uuid = T1.uuid using an inner match. 3) When the question asks about missing or degraded properties: output 'YES' when T1.hasContentWarning equals 1 and 'NO' otherwise, using exact uppercase values. 4) When describing the text of rulings: include T2.text without any alias. 5) When the question does not request card names: exclude T1.name from the output. Output columns (ordered): T2.text, CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name AS card_name, r.text AS ruling_text, \n       CASE WHEN c.hasContentWarning = 1 THEN 'Yes' ELSE 'No' END AS has_missing_or_degraded_properties\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.artist = 'Jim Pavelec';",
            "SELECT T2.text, CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards T1 INNER JOIN rulings T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec'"
        ],
        "rule_sql": [
            "SELECT T2.text, CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards T1 INNER JOIN rulings T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec.'"
        ]
    },
    "70": {
        "question": "How many active and closed District Community Day Schools are there in the county of Alpine?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69 AND County = 'Alpine'",
        "amends": [
            "Do select `COUNT(School)` instead of `StatusType, COUNT(*) AS NumberOfSchools` and remove the GROUP BY clause entirely. Do change the WHERE filter to include `(StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69` instead of `(District LIKE '%Community Day School%' OR School LIKE '%Community Day School%')` while keeping `County = 'Alpine'`. The amended query now correctly counts schools meeting the specific status and SOC criteria in Alpine County, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for count of schools: compute the number of rows using the exact token \"School\" as the counting key. 2) When filtering for specific status types \"Active\" and \"Closed\": include only rows where StatusType equals exactly 'Active' or exactly 'Closed'. 3) When filtering for a specific county: include only rows where County equals exactly 'Alpine'. 4) When filtering for District Community Day Schools: include only rows where SOC equals exactly 69. 5) When the question does not require grouping by status type: do not organize results by StatusType. 6) Output columns (ordered): COUNT(School)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT StatusType, COUNT(*) AS NumberOfSchools\nFROM schools\nWHERE County = 'Alpine' AND (District LIKE '%Community Day School%' OR School LIKE '%Community Day School%')\nGROUP BY StatusType;",
            "SELECT COUNT(School) FROM schools WHERE County = 'Alpine' AND (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = '69';"
        ],
        "rule_sql": [
            "SELECT COUNT(School) FROM schools WHERE County = 'Alpine' AND SOC = '69' AND StatusType IN ('Active', 'Closed')"
        ]
    },
    "630": {
        "question": "What is the name of tags used by John Salvatier's?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'John Salvatier'",
        "amends": [],
        "rules": [
            "DisplayName = 'John Salvatier';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.Tags\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'John Salvatier';"
        ],
        "rule_sql": []
    },
    "456": {
        "question": "What's the list of all types for the card \"Molimo, Maro-Sorcerer\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'",
        "amends": [],
        "rules": [
            "card \"Molimo, Maro-Sorcerer\" refers to name = 'Molimo, Maro-Sorcerer'; list of all types refers to subtypes,supertypes"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';"
        ],
        "rule_sql": []
    },
    "1233": {
        "question": "List each patient's ID and blood glucose (GLU) index that were within normal range for patient's whose data was first recorded in 1991.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T2.GLU FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) = '1991' AND T2.GLU < 180",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do reference `T1.ID` and `T2.GLU` instead of `p.ID` and `l.GLU` with different aliases. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do filter on `T1.First Date` instead of `p.Description` to correctly identify patients from 1991. Do maintain the same join condition `T1.ID = T2.ID` and glucose filter `T2.GLU < 180`. The amended query now correctly identifies distinct patients from 1991 with glucose readings below 180, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"each patient's ID and blood glucose (GLU) index\": output columns T1.ID and T2.GLU. 2) When eliminating duplicate rows: use DISTINCT to return only unique combinations of the output columns. 3) When filtering for patients whose data was first recorded in 1991: filter on T1.\"First Date\" to identify patients from that year. 4) When filtering for glucose readings within normal range: filter on T2.GLU < 180. 5) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 6) Output columns (ordered): T1.ID, T2.GLU"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, l.GLU\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE strftime('%Y', p.Description) = '1991'\nAND l.GLU < 180;",
            "SELECT DISTINCT T1.ID, T2.GLU\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE strftime('%Y', T1.\"First Date\") = '1991'\nAND T2.GLU < 180;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T2.GLU\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE strftime('%Y', T1.\"First Date\") = '1991'\nAND T2.GLU < 180;"
        ]
    },
    "734": {
        "question": "What is the publisher's name of Blue Beetle II?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Blue Beetle II'",
        "amends": [],
        "rules": [
            "Blue Beetle II refers to superhero_name = 'Blue Beetle II'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Blue Beetle II';"
        ],
        "rule_sql": []
    },
    "146": {
        "question": "Who are the female account holders who own credit cards and also have loans?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T5 ON T2.account_id = T5.account_id INNER JOIN loan AS T3 ON T5.account_id = T3.account_id INNER JOIN card AS T4 ON T2.disp_id = T4.disp_id WHERE T1.gender = 'F'",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it. Do remove columns `gender` and `birth_date` from the SELECT list instead of including them. Do use `INNER JOIN` consistently for all joins instead of mixing `JOIN` (which implies INNER) with explicit `INNER JOIN`. Do change the join order to place `loan` before `card` instead of the reverse sequence. Do remove the filter `cd.type = 'credit'` from the WHERE clause instead of keeping it. Do use table aliases `T1`, `T2`, `T3`, `T4`, `T5` instead of single-letter aliases. The amended query now correctly returns only female clients with associated accounts, loans, and cards without unnecessary filtering on card type or distinct results."
        ],
        "rules": [
            "1) When the question asks for female account holders: filter T1.gender to exactly 'F'.\n2) When combining client and account information: link T1.client_id to T2.client_id using inner match.\n3) When combining account and loan information: link T2.account_id to T3.account_id using inner match.\n4) When combining account and card information: link T2.account_id to T4.account_id using inner match.\n5) When the question asks for account holders who own credit cards and have loans: ensure the client has both loan and card relationships through their accounts.\n6) When selecting output columns: include only T1.client_id instead of additional columns like gender or birth_date.\n7) When the question does not require distinct results: do not apply distinct filtering.\n8) When the question does not specify card type filtering: do not filter on card type.\n9) Output columns (ordered): T1.client_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.client_id, c.gender, c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN card cd ON d.disp_id = cd.disp_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.gender = 'F' AND cd.type = 'credit';",
            "SELECT T1.client_id\nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN account T3 ON T2.account_id = T3.account_id\nINNER JOIN loan T4 ON T3.account_id = T4.account_id\nINNER JOIN card T5 ON T2.disp_id = T5.disp_id\nWHERE T1.gender = 'F'"
        ],
        "rule_sql": [
            "SELECT T1.client_id\nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN loan T3 ON T2.account_id = T3.account_id\nINNER JOIN card T4 ON T2.disp_id = T4.disp_id\nWHERE T1.gender = 'F'"
        ]
    },
    "1028": {
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Final result should return the Team.team_long_name; Scotland Premier League refers to League.name = 'Scotland Premier League'; away team refers to away_team_api_id; away team that won the most refers to MAX(SUBTRACT(away_team_goal, home_team_goal) > 0); 2010 season refers to season = '2009/2010'; won the most refers to MAX(COUNT(*));"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_long_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nWHERE l.name = 'Scotland Premier League'\n  AND m.season = '2009/2010'\n  AND m.away_team_goal > m.home_team_goal\nGROUP BY m.away_team_api_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "444": {
        "question": "Name the foreign name of the card that has boros watermark? List out the type of this card.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'boros'",
        "amends": [
            "Do use `DISTINCT` to eliminate duplicate rows instead of omitting it. Do reference `T1.name` and `T1.type` with table aliases instead of `fd.name AS foreign_name` and `c.type`. Do use `INNER JOIN` with explicit table aliases `AS T1` and `AS T2` instead of simple `JOIN` without aliases. Do specify the join condition as `T2.uuid = T1.uuid` instead of `c.uuid = fd.uuid`. Do reference the watermark filter with the aliased table `T1.watermark` instead of `c.watermark`. The amended query now correctly returns distinct card names and types with proper table aliasing and join direction.",
            "Do use `cards AS T1` as the primary table instead of `foreign_data AS T1` to correctly establish the table relationships. Do maintain the `INNER JOIN` on `T2.uuid = T1.uuid` but ensure the join direction aligns with the primary table selection. Do keep the `WHERE T1.watermark = 'boros'` filter unchanged as it correctly references the primary table. Do preserve the `SELECT DISTINCT T1.name, T1.type` column selection since the column names remain consistent despite the table role reversal. The amended query now correctly uses cards as the base table while maintaining the same join logic and filtering conditions to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for foreign name and type of cards: select T1.name and T1.type from the appropriate tables. 2) When joining tables for card information: use INNER JOIN between T2 and T1 where T2.uuid = T1.uuid to match related records. 3) When filtering for cards with specific watermark: include only rows where T1.watermark equals 'boros' exactly. 4) When eliminating duplicate results: use DISTINCT to return only unique combinations of name and type. 5) When using table aliases: refer to the foreign data table as T1 and the cards table as T2 consistently. 6) Output columns (ordered): T1.name, T1.type",
            "1) When the question asks for cards with specific watermark properties: use \"cards AS T1\" as the primary table to establish the correct table relationships.\n2) When joining with foreign data information: perform an inner match where T2.uuid = T1.uuid to link cards with their foreign data counterparts.\n3) When filtering for boros watermark: apply the condition T1.watermark = 'boros' exactly as specified, preserving the lowercase spelling and quotes.\n4) When selecting output columns: return the distinct values of T1.name and T1.type to avoid duplicate entries.\n5) When handling identifier delimiters: do not replace double quotes with backticks or unquoted forms for any column or table names.\n6) When referring to table roles: do not rename or swap the aliases T1 (cards) and T2 (foreign_data) once established for this schema.\nOutput columns (ordered): T1.name, T1.type"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT fd.name AS foreign_name, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'boros';",
            "SELECT DISTINCT T1.name, T1.type\nFROM foreign_data AS T1\nINNER JOIN cards AS T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'boros'",
            "SELECT DISTINCT T1.name, T1.type\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'boros'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.name, T2.type\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'boros'"
        ]
    },
    "755": {
        "question": "List down at least five full name of Demi-God superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Demi-God'",
        "amends": [],
        "rules": [
            "Demi-God superheroes refers to race = 'Demi-God'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Demi-God'\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "560": {
        "question": "Give the number of \"Revival\" badges.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE Name = 'Revival'",
        "amends": [],
        "rules": [
            "number refers to Id; 'Revival' is the Name of badge"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM badges WHERE Name = 'Revival';"
        ],
        "rule_sql": []
    },
    "521": {
        "question": "Among the cards whose version of frame style is 1997, what is the status of the card illustrated by D. Alexander Gregory in legacy play format that has sensitive content or Wizards of the Coast?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.frameVersion = 1997 AND T1.hasContentWarning = 1 AND T1.artist = 'D. Alexander Gregory' AND T2.format = 'legacy'",
        "amends": [],
        "rules": [
            "version of frame style is 1997 refers to frameVersion = '1997'; illustrated by D. Alexander Gregory refers to artist = 'D. Alexander Gregory'; sensitive content refers to hasContentWarning = 1; legacy play format refers to format = 'legacy'; status of the card refers to status"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.frameVersion = '1997'\nAND c.artist = 'D. Alexander Gregory'\nAND (c.hasContentWarning = 1 OR c.flavorText LIKE '%Wizards of the Coast%')\nAND l.format = 'legacy';"
        ],
        "rule_sql": []
    },
    "964": {
        "question": "List out the code for drivers who have nationality in America.",
        "db_id": "formula_1",
        "ground_truth": "SELECT code FROM drivers WHERE Nationality = 'American'",
        "amends": [
            "Do use the exact string literal `'American'` instead of `'America'` in the WHERE filter condition. Do maintain the same column name `nationality` but ensure proper capitalization consistency. The amended query now correctly filters for drivers with American nationality instead of the incorrect 'America' value, matching the intended behavior."
        ],
        "rules": [
            "1) When filtering for drivers with American nationality: use the exact string literal 'American' (not 'America') in the nationality column filter condition. 2) When selecting driver codes: output the code column from the drivers table. 3) Output columns (ordered): code"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM drivers WHERE nationality = 'America';",
            "SELECT code FROM drivers WHERE nationality = 'American';"
        ],
        "rule_sql": [
            "SELECT code FROM drivers WHERE nationality = 'American';"
        ]
    },
    "168": {
        "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
        "db_id": "financial",
        "ground_truth": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
        "amends": [
            "Do use a direct `INNER JOIN` between `district` and `client` on `district_id` instead of multiple CTEs with nested subqueries and joins through account and disposition tables. Do calculate the percentage directly with `CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id)` instead of separate CTEs for total and female counts with cross join. Do filter with `WHERE T1.A11 > 10000` directly in the main query instead of using a CTE for high salary districts. Do remove the unnecessary joins through `account` and `disp` tables instead of including them in the client filtering logic. The amended query now correctly calculates the percentage of female clients in high salary districts by directly joining the relevant tables and using proper aggregate functions."
        ],
        "rules": [
            "1) When the question asks for clients who opened accounts in districts with average salary over 10000: filter districts using T1.A11 > 10000.\n2) When combining district and client tables: link rows where T1.district_id = T2.district_id using inner match.\n3) When calculating percentage of female clients: compute (number of clients with T2.gender = 'F') divided by (total number of clients) multiplied by 100.\n4) When counting clients: use T2.client_id as the counting key for both total and female counts.\n5) When handling text literals: use exact value 'F' for gender comparison without changing case.\n6) Output columns (ordered): percentage_female"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH high_salary_districts AS (\n    SELECT district_id\n    FROM district\n    WHERE A11 > 10000\n),\naccounts_in_high_salary_districts AS (\n    SELECT account_id\n    FROM account\n    WHERE district_id IN (SELECT district_id FROM high_salary_districts)\n),\nclients_in_high_salary_districts AS (\n    SELECT c.client_id, c.gender\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN accounts_in_high_salary_districts a ON d.account_id = a.account_id\n),\ntotal_clients AS (\n    SELECT COUNT(*) AS total\n    FROM clients_in_high_salary_districts\n),\nfemale_clients AS (\n    SELECT COUNT(*) AS female_count\n    FROM clients_in_high_salary_districts\n    WHERE gender = 'F'\n)\nSELECT (female_count * 100.0 / total) AS percentage_female\nFROM female_clients, total_clients;",
            "SELECT \n    CAST(SUM(CASE WHEN c.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(c.client_id) AS percentage_female\nFROM \n    client c\nINNER JOIN \n    district d ON c.district_id = d.district_id\nWHERE \n    d.A11 > 10000;"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.gender = 'F' THEN c.client_id END) * 100.0 / COUNT(c.client_id)) AS percentage_female\nFROM \n    client c\nINNER JOIN \n    account a ON c.district_id = a.district_id\nINNER JOIN \n    district d ON c.district_id = d.district_id\nWHERE \n    d.A11 > 10000\nGROUP BY \n    c.district_id"
        ]
    },
    "618": {
        "question": "List out the age of users who located in Vienna, Austria obtained the badge?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Age FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'Vienna, Austria'",
        "amends": [],
        "rules": [
            "\"Vienna, Austria\" is the Location"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.Age\nFROM users u\nINNER JOIN badges b ON u.Id = b.UserId\nWHERE u.Location = 'Vienna, Austria';"
        ],
        "rule_sql": []
    },
    "817": {
        "question": "Give the race of the blue-haired male superhero.",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T2.colour = 'Blue' AND T4.gender = 'Male'",
        "amends": [
            "Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of `s`, `c_hair`, `r`, and `g`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do change the join order to `colour`, `race`, then `gender` instead of `colour`, `gender`, then `race`. Do capitalize filter values `'Blue'` and `'Male'` instead of lowercase `'blue'` and `'male'`. The amended query now correctly matches the RIGHT_SQL's behavior with proper table aliasing, explicit join types, optimized join order, and case-sensitive value matching."
        ],
        "rules": [
            "1) When joining tables for superhero attributes: use INNER JOIN to combine T1 (colour), T2 (race), and T3 (gender) tables in the order colour \u2192 race \u2192 gender. 2) When filtering for blue hair colour: use the exact literal value 'Blue' (capitalized) for T1.colour. 3) When filtering for male gender: use the exact literal value 'Male' (capitalized) for T3.gender. 4) When selecting the race of matching superheroes: output the race column from T2 (race table). 5) Output columns (ordered): T2.race"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.race\nFROM superhero s\nJOIN colour c_hair ON s.hair_colour_id = c_hair.id\nJOIN gender g ON s.gender_id = g.id\nJOIN race r ON s.race_id = r.id\nWHERE c_hair.colour = 'blue' AND g.gender = 'male';",
            "SELECT T3.race\nFROM superhero T1\nINNER JOIN colour T2 ON T1.hair_colour_id = T2.id\nINNER JOIN race T3 ON T1.race_id = T3.id\nINNER JOIN gender T4 ON T1.gender_id = T4.id\nWHERE T2.colour = 'Blue' AND T4.gender = 'Male'"
        ],
        "rule_sql": [
            "SELECT T2.race\nFROM superhero s\nINNER JOIN colour T1 ON s.hair_colour_id = T1.id\nINNER JOIN race T2 ON s.race_id = T2.id\nINNER JOIN gender T3 ON s.gender_id = T3.id\nWHERE T1.colour = 'Blue' AND T3.gender = 'Male'"
        ]
    },
    "643": {
        "question": "What are the display names and ages of user who got the highest in views?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName, Age FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "amends": [],
        "rules": [
            "the highest in views refers to MAX(Views);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DisplayName, Age FROM users ORDER BY Views DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "557": {
        "question": "Among the posts with a score of over 5, what is the percentage of them being owned by an elder user?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age > 65, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score > 5",
        "amends": [],
        "rules": [
            "score of over 5 refers to Score > 5; elder user refers to Age > 65; percentage = Divide (Count(Id where Age>65), Count(Id)) * 100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.Age > 65 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nWHERE \n    p.Score > 5;"
        ],
        "rule_sql": []
    },
    "828": {
        "question": "Count the fastest superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' AND T1.attribute_value = 100",
        "amends": [],
        "rules": [
            "fastest refers to attribute_value = 100 WHERE attribute_name = 'Speed';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT hero_id) AS fastest_superheroes_count\nFROM hero_attribute\nJOIN attribute ON hero_attribute.attribute_id = attribute.id\nWHERE attribute.attribute_name = 'Speed' AND hero_attribute.attribute_value = 100;"
        ],
        "rule_sql": []
    },
    "294": {
        "question": "Which bond ids are double-bond with carcinogenic compound?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.bond_type = '='",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `b` and `m` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do remove the space around the equals sign in `'='` instead of `' = '` to match the actual data format. Do maintain the same join condition `T1.molecule_id = T2.molecule_id` instead of changing it. The amended query now correctly filters for bonds with type '=' on molecules labeled '+', matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for bond ids: output the exact column T1.bond_id. 2) When combining bond and molecule tables: link rows where T1.molecule_id equals T2.molecule_id using an inner match. 3) When filtering for carcinogenic compounds: include only rows where T2.label equals exactly '+'. 4) When filtering for double bonds: include only rows where T1.bond_type equals exactly '=' (without spaces). Output columns (ordered): T1.bond_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_id\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE m.label = '+' AND b.bond_type = ' = ';",
            "SELECT T1.bond_id\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '=' AND T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT T1.bond_id FROM bond T1 INNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.bond_type = '='"
        ]
    },
    "1026": {
        "question": "Which home team had lost the fewest matches in the 2016 season?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT teamDetails.team_long_name FROM Match AS matchData INNER JOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id WHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0 GROUP BY matchData.home_team_api_id ORDER BY COUNT(*) ASC LIMIT 1",
        "amends": [
            "Do reference the table alias `teamDetails.team_long_name` instead of `t.team_long_name` in the SELECT list. Do use the condition `home_team_goal - away_team_goal < 0` instead of `home_team_goal < away_team_goal` in the WHERE clause to explicitly calculate the goal difference. Do order by `COUNT(*) ASC` instead of the alias `loss_count ASC` to reference the aggregate function directly. Do maintain the same table joins, grouping, and limit structure while ensuring the logic correctly identifies matches where the home team scored fewer goals than the away team. The amended query now matches RIGHT_SQL's behavior by using explicit goal difference calculation and direct aggregate reference in ordering.",
            "Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do filter by season `'2015/2016'` instead of `'2016'` to match the correct season format. Do remove the alias `loss_count` from the `COUNT(*)` expression instead of keeping it since it's not needed in the final output. Do reference the table as `matchData` instead of `m` for consistency with the right query's naming convention. The amended query now correctly identifies teams with losses in the 2015/2016 season and returns the team with the fewest losses, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) AS loss_count` from the SELECT list instead of including it. Do change the GROUP BY clause to use `matchData.home_team_api_id` instead of `teamDetails.team_long_name`. Do keep the same FROM source with `INNER JOIN` on `matchData.home_team_api_id = teamDetails.team_api_id`, maintain the WHERE filter for `season = '2015/2016'` and `home_team_goal - away_team_goal < 0`, preserve the ORDER BY `COUNT(*) ASC`, and retain the LIMIT 1. The amended query now correctly groups by the join key instead of the team name, ensuring accurate counting while maintaining the same result behavior."
        ],
        "rules": [
            "1) When the question asks for home teams and match results: use the exact identifier \"teamDetails.team_long_name\" for the home team name output. 2) When identifying matches where the home team lost: use the condition home_team_goal - away_team_goal < 0 to explicitly calculate goal difference. 3) When ordering by the count of losses: order by COUNT(*) ASC instead of using an alias reference. 4) When filtering for the 2016 season: use the exact literal '2015/2016' as the season value. 5) When counting losses per team: group by the home team identifier and count using the match occurrences. 6) When finding the team with fewest losses: take only the first result after ascending ordering by loss count. 7) Output columns (ordered): teamDetails.team_long_name, COUNT(*)",
            "1) When the question asks about the 2016 season: use the exact season literal '2015/2016' to match the database's season format. 2) When counting losses for home teams: count matches where the home team lost (home_team_goal < away_team_goal) in the specified season. 3) When grouping by teams: group by the team identifier (home_team_api_id) to aggregate results per team. 4) When finding the team with fewest losses: order the results by loss count in ascending order and take the first result. 5) When joining tables: use INNER JOIN to combine match and team data where matchData.home_team_api_id equals teamDetails.team_api_id. 6) When selecting output columns: include only team_long_name from teamDetails and the loss count. 7) Output columns (ordered): teamDetails.team_long_name, COUNT(*)",
            "1) When the question asks for the home team with fewest lost matches: count losses using the canonical key matchData.home_team_api_id instead of teamDetails.team_long_name. 2) When filtering for the 2016 season: use the exact literal '2015/2016' for the season value. 3) When identifying a home team loss: use the condition home_team_goal - away_team_goal < 0. 4) When combining Match and Team tables: link rows where matchData.home_team_api_id = teamDetails.team_api_id using an inner match. 5) When ordering by fewest losses: sort by the count in ascending order and keep only the top result. 6) Output columns (ordered): teamDetails.team_long_name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.team_long_name, COUNT(*) AS loss_count\nFROM Match m\nJOIN Team t ON m.home_team_api_id = t.team_api_id\nWHERE m.season = '2015/2016' AND m.home_team_goal < m.away_team_goal\nGROUP BY m.home_team_api_id\nORDER BY loss_count ASC\nLIMIT 1;",
            "SELECT teamDetails.team_long_name, COUNT(*) AS loss_count\nFROM Match m\nJOIN Team teamDetails ON m.home_team_api_id = teamDetails.team_api_id\nWHERE m.season = '2016' AND (m.home_team_goal - m.away_team_goal) < 0\nGROUP BY m.home_team_api_id\nORDER BY COUNT(*) ASC\nLIMIT 1;",
            "SELECT teamDetails.team_long_name, COUNT(*) AS loss_count\nFROM Match matchData\nINNER JOIN Team teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id\nWHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0\nGROUP BY teamDetails.team_long_name\nORDER BY COUNT(*) ASC\nLIMIT 1;",
            "SELECT teamDetails.team_long_name\nFROM Match AS matchData\nINNER JOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id\nWHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0\nGROUP BY matchData.home_team_api_id\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT teamDetails.team_long_name, COUNT(*) \nFROM Match AS matchData\nINNER JOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id\nWHERE matchData.season = '2015/2016' \nAND matchData.home_team_goal - matchData.away_team_goal < 0\nGROUP BY matchData.home_team_api_id\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ]
    },
    "464": {
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "amends": [],
        "rules": [
            "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE st.translation = 'Hauptset Zehnte Edition';"
        ],
        "rule_sql": []
    },
    "365": {
        "question": "What is the type of card \"Benalish Knight\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "amends": [],
        "rules": [
            "Benalish Knight' is the name of card;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type FROM cards WHERE name = 'Benalish Knight';"
        ],
        "rule_sql": []
    },
    "783": {
        "question": "Provide the eye colours of the heroes whose skin colours are gold.",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T3.colour = 'Gold'",
        "amends": [],
        "rules": [
            "skin colours are gold refers to colour.colour = 'Gold' WHERE skin_colour_id = colour.id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.colour AS eye_colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.skin_colour_id = (SELECT id FROM colour WHERE colour = 'Gold');"
        ],
        "rule_sql": []
    },
    "1005": {
        "question": "What was the longest time a driver had ever spent at a pit stop?",
        "db_id": "formula_1",
        "ground_truth": "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1",
        "amends": [
            "Do select only `duration` instead of `d.forename`, `d.surname`, and `MAX(p.duration)` with an alias. Do use a single table `pitStops` instead of joining with `drivers d` on `p.driverId = d.driverId`. Do remove the aggregation function `MAX` and instead use `ORDER BY duration DESC` with `LIMIT 1` to find the maximum value. Do omit the `GROUP BY` clause entirely instead of having an implicit grouping. The amended query now correctly returns the single longest pitstop duration without unnecessary driver information and joins."
        ],
        "rules": [
            "1) When the question asks for the longest time from a duration column: use the exact column token \"duration\" from table pitStops. 2) When finding the maximum value of a column: order rows by the column in descending direction and take the first row. 3) When the question asks about pit stop duration specifically: use only the pitStops table without joining to other tables. 4) When the question asks for a single maximum value: return only one result row. 5) Output columns (ordered): duration"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname, MAX(p.duration) AS longest_pitstop_duration\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId;",
            "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1;"
        ]
    },
    "1314": {
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of single-letter aliases `m` and `maj`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use the full department name `'Art and Design Department'` in the WHERE filter instead of the truncated `'Art and Design'`. The amended query now correctly matches the intended logic by joining member and major tables with proper aliases and filtering for the complete department name.",
            "Do select individual columns `first_name` and `last_name` instead of concatenating them into a single `full_name` column. The amended query now matches RIGHT_SQL's behavior by returning separate first and last name fields rather than a combined full name string."
        ],
        "rules": [
            "1) When joining tables member and major: use T1 as alias for member table and T2 as alias for major table, and perform an inner join where T1.link_to_major equals T2.major_id. 2) When filtering for department: use the exact literal 'Art and Design Department' (not 'Art and Design') to match T2.department. 3) When selecting student names: output both T1.first_name and T1.last_name columns. 4) Output columns (ordered): T1.first_name, T1.last_name",
            "1) When the question asks for student names from the Student_Club: use table member as T1 and table major as T2, linking them where T1.link_to_major = T2.major_id.\n2) When filtering for students from the Art and Design Department: include only rows where T2.department equals 'Art and Design Department' exactly.\n3) When outputting student names: return first_name and last_name as separate columns instead of concatenating them into a full name.\nOutput columns (ordered): T1.first_name, T1.last_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.department = 'Art and Design';",
            "SELECT T1.first_name || ' ' || T1.last_name AS full_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.department = 'Art and Design Department';",
            "SELECT T1.first_name, T1.last_name FROM member T1 INNER JOIN major T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.department = 'Art and Design Department';"
        ]
    },
    "1199": {
        "question": "How many patients who underwent testing in 1997 had protein levels outside the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(ID) FROM Laboratory WHERE (ALB <= 6.0 OR ALB >= 8.5) AND STRFTIME('%Y', Date) = '1997'",
        "amends": [
            "Do use `COUNT(ID)` instead of `COUNT(DISTINCT ID)` to count all records rather than distinct values. Do reference column `ALB` instead of `TP` for the albumin measurements. Do use comparison operators `<= 6.0` and `>= 8.5` instead of `< 6` and `> 8.5` to include the boundary values. Do place the albumin condition first with parentheses `(ALB <= 6.0 OR ALB >= 8.5)` instead of the year condition for logical grouping. The amended query now correctly counts all laboratory records from 1997 where albumin levels are outside the normal range of 6.0 to 8.5, inclusive of the boundary values."
        ],
        "rules": [
            "1) When counting patients who underwent testing: use COUNT(ID) to count all records rather than distinct values.\n2) When checking for protein levels outside normal range: reference column ALB instead of TP for albumin measurements.\n3) When defining the normal range boundary for albumin: use comparison operators <= 6.0 and >= 8.5 instead of < 6 and > 8.5 to include the boundary values.\n4) When structuring conditions for albumin levels: place the albumin condition first with parentheses (ALB <= 6.0 OR ALB >= 8.5) instead of the year condition for logical grouping.\n5) When filtering for testing year: use strftime('%Y', Date) = '1997' to identify records from 1997.\nOutput columns (ordered): COUNT(ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT ID) \nFROM Laboratory \nWHERE strftime('%Y', Date) = '1997' \nAND (TP < 6 OR TP > 8.5);",
            "SELECT COUNT(ID) \nFROM Laboratory \nWHERE Date LIKE '1997%' \nAND (ALB <= 6.0 OR ALB >= 8.5)"
        ],
        "rule_sql": [
            "SELECT COUNT(ID) \nFROM Laboratory \nWHERE (ALB <= 6.0 OR ALB >= 8.5) \nAND strftime('%Y', Date) = '1997'"
        ]
    },
    "297": {
        "question": "Among the atoms that contain element carbon, which one does not contain compound carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; carbon refers to element = 'c'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.atom_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'c' AND m.label = '-';"
        ],
        "rule_sql": []
    },
    "439": {
        "question": "List out the set name of the set code \"ALL\".",
        "db_id": "card_games",
        "ground_truth": "SELECT name FROM sets WHERE code = 'ALL'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM sets WHERE code = 'ALL';"
        ],
        "rule_sql": []
    },
    "1073": {
        "question": "How many matches were held in the league Germany 1. Bundesliga\nfrom August to October 2008?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Germany 1. Bundesliga' AND SUBSTR(t2.`date`, 1, 7) BETWEEN '2008-08' AND '2008-10'",
        "amends": [],
        "rules": [
            "Germany 1. Bundesliga refers to League.name = 'Germany 1. Bundesliga'; from August to October 2008 refers to strftime('%Y-%m', date) BETWEEN '2008-08' AND '2008-10';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS match_count\nFROM Match\nWHERE league_id = (SELECT id FROM League WHERE name = 'Germany 1. Bundesliga')\nAND strftime('%Y-%m', date) BETWEEN '2008-08' AND '2008-10';"
        ],
        "rule_sql": []
    },
    "1153": {
        "question": "What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Diagnosis, T2.Date FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 30609",
        "amends": [],
        "rules": [
            "'30609' is the Patient ID; disease means Diagnosis"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Diagnosis AS Disease, l.Date AS LaboratoryTestDate\nFROM Patient p\nLEFT JOIN Laboratory l ON p.ID = l.ID\nWHERE p.ID = 30609\nUNION\nSELECT e.Diagnosis AS Disease, l.Date AS LaboratoryTestDate\nFROM Examination e\nLEFT JOIN Laboratory l ON e.ID = l.ID\nWHERE e.ID = 30609;"
        ],
        "rule_sql": []
    },
    "409": {
        "question": "Indicates the number of cards with pre-modern format, ruling text \"This is a triggered mana ability.\" that do not have multiple faces.",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN rulings AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'premodern' AND T3.text = 'This is a triggered mana ability.' AND T1.Side IS NULL",
        "amends": [],
        "rules": [
            "pre-modern format refers to format = 'premodern' ;do not have multiple faces refers to side IS NULL"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.id) \nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nJOIN rulings r ON c.uuid = r.uuid\nWHERE l.format = 'premodern' \nAND r.text = 'This is a triggered mana ability.' \nAND c.side IS NULL;"
        ],
        "rule_sql": []
    },
    "859": {
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "amends": [],
        "rules": [
            "race number refers to raceId; Bruno Senna refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT q.q1\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE d.forename = 'Bruno' AND d.surname = 'Senna' AND q.raceId = 354;"
        ],
        "rule_sql": []
    },
    "325": {
        "question": "How many carcinogenic molecules that consisted of Nitrogen?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'n' AND T1.label = '+'",
        "amends": [],
        "rules": [
            "nitrogen refers to element = 'n'; label = '+' mean molecules are carcinogenic;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '+' AND a.element = 'n';"
        ],
        "rule_sql": []
    },
    "1484": {
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "amends": [
            "Do use a single query with conditional aggregation using `SUM(IIF(Country = 'CZE', 1, 0))` and `SUM(IIF(Country = 'SVK', 1, 0))` instead of separate subqueries with `COUNT(*)` for each country. Do apply the `Segment = 'Discount'` filter once in the main `WHERE` clause instead of repeating it in each subquery. Do use consistent case sensitivity with `'Discount'` instead of `'discount'` for the segment value. The amended query now correctly calculates the difference in discount gas station counts between Czech Republic and Slovakia with proper filtering and aggregation."
        ],
        "rules": [
            "1) When the question asks for a count difference between two countries: compute the difference between the count for 'CZE' and the count for 'SVK' using conditional aggregation.\n2) When filtering for discount gas stations: apply the condition Segment = 'Discount' exactly once in the main filter.\n3) When handling country values: use exact literals 'CZE' for Czech Republic and 'SVK' for Slovakia with proper case sensitivity.\n4) When handling segment values: use exact literal 'Discount' with capital D instead of 'discount'.\n5) When performing conditional counting: use SUM(IIF(Country = 'CZE', 1, 0)) for Czech Republic and SUM(IIF(Country = 'SVK', 1, 0)) for Slovakia.\n6) Output columns (ordered): MoreDiscountGasStations"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'discount') - \n    (SELECT COUNT(*) FROM gasstations WHERE Country = 'SVK' AND Segment = 'discount') AS MoreDiscountGasStations;",
            "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) AS difference\nFROM gasstations\nWHERE Segment = 'Discount';"
        ],
        "rule_sql": [
            "SELECT \n    SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) AS MoreDiscountGasStations\nFROM \n    gasstations\nWHERE \n    Segment = 'Discount';"
        ]
    },
    "1050": {
        "question": "What is the preferred foot when attacking of the youngest football player?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday DESC LIMIT 1",
        "amends": [],
        "rules": [
            "preferred foot when attacking refers to preferred_foot; youngest football player refers to latest birthday;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pa.preferred_foot\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY p.birthday DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1361": {
        "question": "What is the total cost of the pizzas for all the events?",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza'",
        "amends": [],
        "rules": [
            "total cost of the pizzas refers to SUM(cost) where expense_description = 'Pizza'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(cost) AS total_pizza_cost FROM expense WHERE expense_description LIKE '%pizza%';"
        ],
        "rule_sql": []
    },
    "532": {
        "question": "Please list the display names of all the users whose accounts were created in the year 2011.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName FROM users WHERE STRFTIME('%Y', CreationDate) = '2011'",
        "amends": [],
        "rules": [
            "account created in the year 2011 refers to year(CreationDate) = 2011"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DisplayName FROM users WHERE strftime('%Y', CreationDate) = '2011';"
        ],
        "rule_sql": []
    },
    "421": {
        "question": "Please list top three unknown power cards that have promotional types for arena league in alphabetical order.",
        "db_id": "card_games",
        "ground_truth": "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3",
        "amends": [
            "Do remove `power` and `promoTypes` from the SELECT list instead of including them. Do change the power filter to `power LIKE '%*%'` instead of `power = '*'` to catch any string containing an asterisk rather than requiring an exact match. Do remove the explicit `ASC` from ORDER BY instead of specifying it since ascending is the default. The amended query now correctly filters for cards where power contains an asterisk character and returns only the name column as specified in the RIGHT_SQL.",
            "Do add `(power IS NULL OR power LIKE '%*%')` instead of only `power LIKE '%*%'` to properly handle NULL values. Do change `promoTypes LIKE '%arena league%'` to `promoTypes = 'arenaleague'` instead of using a pattern match for exact string comparison. The amended query now correctly handles NULL power values and uses exact string matching for promoTypes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"top three\" cards: rank rows by name in alphabetical order and keep the first 3 rows.\n2) When filtering for \"unknown power cards\": include only rows where power contains an asterisk character (power LIKE '%*%').\n3) When filtering for cards with \"promotional types for arena league\": include only rows where promoTypes equals 'arenaleague' exactly.\n4) When selecting output columns: include only the name column in the results.\n5) When ordering results alphabetically: sort rows by name in ascending order (default alphabetical order).\nOutput columns (ordered): name",
            "1) When the question mentions \"top three\" and requires alphabetical order: rank rows by name in ascending order and keep the first 3 rows.\n2) When the question asks for cards with unknown power: include rows where power is NULL or power contains '*' character.\n3) When the question specifies promotional types for arena league: filter rows where promoTypes equals exactly 'arenaleague' (case-sensitive exact match).\n4) When handling text literals: preserve the exact string 'arenaleague' without changing case, spacing, or punctuation.\n5) When producing output: return only the name column for the matching cards.\nOutput columns (ordered): name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, power, promoTypes\nFROM cards\nWHERE (power IS NULL OR power = '*') AND promoTypes = 'arenaleague'\nORDER BY name ASC\nLIMIT 3;",
            "SELECT name FROM cards WHERE power LIKE '%*%' AND promoTypes LIKE '%arena league%' ORDER BY name LIMIT 3;",
            "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT name FROM cards WHERE power LIKE '%*%' AND promoTypes = 'arenaleague' ORDER BY name ASC LIMIT 3"
        ]
    },
    "112": {
        "question": "For the female client who was born in 1976/1/29, which district did she opened her account?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.A2 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.birth_date = '1976-01-29' AND T2.gender = 'F'",
        "amends": [],
        "rules": [
            "Female refers to gender = 'F'; A2 refers to district names"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.A2 AS district_name\nFROM client c\nJOIN disp dp ON c.client_id = dp.client_id\nJOIN account a ON dp.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE c.gender = 'F' AND c.birth_date = '1976-01-29';"
        ],
        "rule_sql": []
    },
    "1006": {
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "db_id": "formula_1",
        "ground_truth": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "amends": [
            "Do remove the `MIN(milliseconds)` aggregate and `fastest_lap_milliseconds` alias instead of calculating the minimum milliseconds value. Do completely change the SELECT list to only include `time` instead of selecting both milliseconds and time. Do remove the FROM clause entirely instead of keeping the table reference. Do add a complex ORDER BY clause that parses and converts the time string to seconds for proper sorting instead of ordering by milliseconds. Do add a LIMIT 1 clause to return only the single fastest lap time instead of returning all rows. The amended query now correctly identifies the fastest lap by parsing and converting the time format rather than relying on milliseconds, matching the RIGHT_SQL's behavior.",
            "Do use a comprehensive CASE expression to handle both minute:second.millisecond and hour:minute:second.millisecond time formats instead of assuming only minute:second format. Do add proper hour conversion with `* 3600` when detecting a second colon instead of omitting hour handling. Do fix the minute extraction logic to account for position variations instead of using a simple substring from the colon. Do add proper millisecond handling with division by 1000 instead of ignoring fractional seconds. Do include all time components (hours, minutes, seconds, milliseconds) in the sorting calculation instead of only minutes and seconds. The amended query now correctly handles various time formats and matches RIGHT_SQL's behavior.",
            "Do use a single CASE expression that checks for the presence of multiple colons with `INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')` instead of using `LIKE '%:%:%'` to detect time format. Do calculate hours component as `CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600` only when multiple colons exist instead of the complex nested substring approach. Do handle minutes calculation with conditional logic based on colon count using `INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')` instead of separate ELSE branch. Do extract seconds with proper decimal handling using `CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)` instead of simple substring. Do add millisecond precision with `CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000` instead of omitting fractional seconds. Do combine all time components into a single arithmetic expression for ordering instead of separate CASE branches. Do specify explicit `ASC` ordering instead of relying on default behavior. The amended query now correctly handles both time formats with proper decimal second precision and matches RIGHT_SQL's behavior.",
            "Do use a simplified arithmetic expression with proper conditional logic for time parsing instead of the complex nested CASE structure with incorrect substring calculations. Do add explicit ELSE 0 for the hour component instead of omitting it when there's only one colon. Do fix the minute extraction logic by using proper conditional positioning instead of the flawed INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') approach. Do maintain the same ORDER BY ASC and LIMIT 1 structure but with corrected time conversion that properly handles both mm:ss.fff and hh:mm:ss.fff formats. The amended query now correctly parses lap times by extracting hours only when two colons are present and properly calculates total seconds for accurate ordering.",
            "Do use a single CASE expression that checks `INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')` to detect three-part time format instead of nested INSTR checks. Do calculate hours component as `CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600` only for three-part times instead of using multiple conditional branches. Do extract minutes using `CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60` with proper position calculation instead of simple substring extraction. Do handle seconds and milliseconds separately with `CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)` for seconds and `CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000` for milliseconds instead of treating time as whole seconds. Do combine all time components with addition instead of using different calculation paths for different time formats. The amended query now correctly handles time parsing with milliseconds and matches RIGHT_SQL's behavior.",
            "Do use a simplified arithmetic expression with separate CASE and arithmetic components instead of nested conditional logic with complex substring calculations. Do add explicit ELSE 0 for the hour component instead of omitting it in the first CASE. Do restructure the minute calculation with proper conditional logic based on colon count instead of relying on complex nested substring operations. Do maintain the same second and millisecond extraction logic but with proper positioning instead of the incorrect offset calculations. Do fix the ORDER BY expression to properly handle both mm:ss.SSS and hh:mm:ss.SSS formats instead of the flawed conditional logic that miscalculated time component positions. The amended query now correctly parses and orders lap times by converting them to seconds regardless of whether they contain hours or not, matching the RIGHT_SQL's behavior.",
            "Do simplify the ORDER BY expression by removing redundant CASE statements and complex substring calculations instead of using nested CASE statements with repeated INSTR checks. Do use direct arithmetic operations for minute conversion instead of conditional logic that incorrectly handles single vs double colon formats. Do fix the minute extraction by using proper substring positioning with `INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':'))` instead of the flawed conditional approach that miscalculated minute values. Do streamline the second extraction by using `INSTR(time, '.') - INSTR(time, ':') - 1` for proper positioning instead of the complex nested CASE structure that incorrectly adjusted for colon positions. The amended query now correctly handles time format conversion for proper sorting while maintaining the same result behavior.",
            "Do simplify the CASE expression by removing the ELSE branch and instead adding an explicit `ELSE 0` for the hour component instead of having two separate calculation branches. Do restructure the time conversion calculation by breaking it into separate additive components with parentheses instead of having a single complex expression. Do maintain the same `ORDER BY` logic and `LIMIT 1` clause instead of changing the overall query structure. The amended query now correctly handles time conversion for both formats while maintaining the same result behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for the fastest lap time: parse and convert the time string to seconds for proper sorting instead of using milliseconds. 2) When identifying the single fastest record: order rows by the converted time value in ascending order and keep only the first row. 3) When outputting results: include only the time column instead of both milliseconds and time. 4) Output columns (ordered): time",
            "1) When handling time values in multiple formats (minute:second.millisecond and hour:minute:second.millisecond): convert all time components to seconds using a comprehensive conversion that accounts for hours, minutes, seconds, and milliseconds. 2) When extracting time components: use proper position detection for colons instead of simple substring operations to handle format variations. 3) When converting time to seconds: multiply hours by 3600, minutes by 60, and include milliseconds divided by 1000. 4) When finding the fastest lap time: sort the converted time values in ascending order and take the first result. 5) Output columns (ordered): time",
            "1) When the question asks for the fastest lap time: convert the time string to a numerical value using proper decimal handling for seconds and milliseconds. 2) When handling time format detection: use INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') to detect multiple colons instead of LIKE '%:%:%'. 3) When multiple colons exist: calculate hours as CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600. 4) When extracting minutes: use conditional logic based on colon count using INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':'). 5) When extracting seconds: use CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) for proper decimal handling. 6) When handling milliseconds: add CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 for fractional second precision. 7) When ordering for fastest time: combine all time components into a single arithmetic expression and order by the result in ASCending order. 8) When limiting results: take only the first row after ordering. Output columns (ordered): time",
            "1) When the question asks for the fastest lap time: find the minimum time value from the lapTimes table. 2) When handling time values in mm:ss.fff or hh:mm:ss.fff format: convert to total seconds for proper numerical comparison. 3) When there are two colons in the time string: extract hours, minutes, and seconds components separately. 4) When there is only one colon in the time string: extract only minutes and seconds components, treating hours as zero. 5) When ordering by converted time values: sort in ascending order to find the smallest (fastest) time. 6) When retrieving the fastest record: take only the first result after proper ordering. Output columns (ordered): time",
            "1) When the question asks for the fastest lap time: find the minimum time value from the lapTimes table. 2) When handling time values with potential milliseconds: parse time strings by extracting hours, minutes, seconds, and milliseconds components separately using position calculations. 3) When detecting three-part time formats: use the condition INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') to identify times with hours, minutes, and seconds. 4) When calculating total seconds from time components: convert hours to seconds by multiplying by 3600, minutes to seconds by multiplying by 60, and add seconds plus milliseconds divided by 1000. 5) When ordering by time for fastest record: sort in ascending order by the calculated total seconds value. 6) When retrieving the single fastest time: take only the first result after ordering. Output columns (ordered): time",
            "1) When the question asks for the fastest lap time: find the minimum time value from the lapTimes table without converting time formats. 2) When ordering lap times: sort the time column in ascending order to find the fastest time. 3) When limiting results to the fastest record: return only the first row after ordering by time ascending. 4) Output columns (ordered): time",
            "1) When the question asks for the fastest lap time: find the minimum time value from the lapTimes table. 2) When handling time format conversion for ordering: convert time strings to numerical values using proper arithmetic operations for hours, minutes, and seconds conversion. 3) When extracting time components: use proper substring positioning with INSTR functions to handle both single and double colon formats correctly. 4) When ordering by converted time values: sort in ascending order to find the smallest (fastest) time. 5) When retrieving the fastest record: return only the top result after proper ordering. 6) Output columns (ordered): time",
            "1) When the question asks for the fastest lap time: convert the time string to seconds using the exact conversion logic shown in the amends, with separate additive components for hours, minutes, seconds, and milliseconds. 2) When ordering by converted time to find the fastest: sort rows in ascending order of the converted time value. 3) When retrieving only the top result: keep only the first row after ordering. 4) Output columns (ordered): time"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(milliseconds) AS fastest_lap_milliseconds, time AS fastest_lap_time FROM lapTimes;",
            "SELECT time FROM lapTimes ORDER BY (CAST(substr(time, 1, instr(time, ':') - 1) AS REAL) * 60 + CAST(substr(time, instr(time, ':') + 1) AS REAL)) ASC LIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE \n        WHEN time LIKE '%:%:%' THEN \n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 + \n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 + \n            CAST(SUBSTR(time, INSTR(time, ':', INSTR(time, ':') + 1) + 1) AS REAL)\n        ELSE \n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n            CAST(SUBSTR(time, INSTR(time, ':') + 1) AS REAL)\n    END \nLIMIT 1;",
            "SELECT time\nFROM lapTimes\nORDER BY \n    CASE \n        WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - INSTR(time, ':') - 1) AS REAL) +\n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n        ELSE\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n    END ASC\nLIMIT 1;",
            "SELECT time\nFROM lapTimes\nORDER BY \n    CASE \n        WHEN INSTR(time, ':') = 0 THEN CAST(time AS REAL)\n        WHEN INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') > 0 THEN\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(time, ':') + INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + 1) AS REAL)\n        ELSE\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1) AS REAL)\n    END ASC\nLIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE \n        WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - INSTR(time, ':') - 1) AS REAL) +\n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n        ELSE\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n    END ASC\nLIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n         THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 \n         ELSE 0 \n    END +\n    CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n         THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 \n         ELSE CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 \n    END +\n    CAST(SUBSTR(time, INSTR(time, ':') + 1 + CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n                                               THEN INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + 1 \n                                               ELSE 0 \n                                          END, \n               INSTR(time, '.') - INSTR(time, ':') - 1 - CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n                                                           THEN INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + 1 \n                                                           ELSE 0 \n                                                      END) AS REAL) +\n    CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 \nASC \nLIMIT 1;",
            "SELECT time\nFROM lapTimes\nORDER BY \n    CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN\n        CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 +\n        CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n        CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n    ELSE\n        CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n        CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n    END ASC\nLIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE \n        WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n        THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 \n        ELSE 0 \n    END +\n    CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60 +\n    CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n    CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 \nASC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT time\nFROM lapTimes\nORDER BY \n    CASE \n        WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 + \n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 + \n            CAST(SUBSTR(time, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - INSTR(time, ':') - 1) AS REAL) + \n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n        ELSE\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) + \n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n    END ASC\nLIMIT 1;"
        ]
    },
    "223": {
        "question": "What are the atom IDs of the bond TR000_2_5?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.atom_id FROM connected AS T WHERE T.bond_id = 'TR000_2_5'",
        "amends": [
            "Do select only `atom_id` instead of both `atom_id` and `atom_id2`. Do add table alias `T` for the `connected` table instead of omitting it. Do reference the column as `T.atom_id` instead of just `atom_id` in the SELECT clause. Do reference the column as `T.bond_id` instead of just `bond_id` in the WHERE filter. The amended query now correctly returns only the atom_id values from the specified bond, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for atom IDs of a specific bond: select only the atom_id column from the connected table. 2) When referencing columns from the connected table: use table alias T and reference columns as T.atom_id and T.bond_id. 3) When filtering for a specific bond ID: use exact literal matching with the bond_id value 'TR000_2_5'. 4) Output columns (ordered): T.atom_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_id, atom_id2 FROM connected WHERE bond_id = 'TR000_2_5';",
            "SELECT T.atom_id FROM connected T WHERE T.bond_id = 'TR000_2_5'"
        ],
        "rule_sql": [
            "SELECT T.atom_id FROM connected T WHERE T.bond_id = 'TR000_2_5'"
        ]
    },
    "624": {
        "question": "What is the name of user with the ID of 30?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = 30",
        "amends": [],
        "rules": [
            "name of user refers to DisplayName;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DisplayName FROM users WHERE Id = 30;"
        ],
        "rule_sql": []
    },
    "1338": {
        "question": "Was each expense in October Meeting on October 8, 2019 approved?",
        "db_id": "student_club",
        "ground_truth": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
        "amends": [
            "Do select only `T3.approved` instead of `e.expense_id, e.expense_description, e.approved`. Do use `INNER JOIN` consistently instead of mixing `JOIN` without explicit type. Do use table aliases `T1`, `T2`, `T3` instead of full table names `ev`, `b`, `e`. Do use `LIKE '2019-10-08%'` for date matching instead of exact equality `= '2019-10-08'` to accommodate potential timestamp values. The amended query now correctly returns only the approved status with proper date filtering that handles potential time components."
        ],
        "rules": [
            "1) When the question asks about expenses for a specific meeting: combine tables T1 (event), T2 (budget), and T3 (expense) using inner matches where T1.event_id = T2.link_to_event and T2.budget_id = T3.link_to_budget.\n2) When filtering by event name \"October Meeting\": include only rows where T1.event_name equals exactly \"October Meeting\".\n3) When filtering by date October 8, 2019: include only rows where T1.event_date starts with \"2019-10-08\" using pattern matching to accommodate potential timestamp values.\n4) When the question asks for approval status of expenses: output only the T3.approved column.\n5) Output columns (ordered): T3.approved"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.expense_id, e.expense_description, e.approved\nFROM event ev\nJOIN budget b ON ev.event_id = b.link_to_event\nJOIN expense e ON b.budget_id = e.link_to_budget\nWHERE ev.event_name = 'October Meeting' AND ev.event_date = '2019-10-08';",
            "SELECT T3.approved\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'"
        ],
        "rule_sql": [
            "SELECT e.approved \nFROM event ev\nINNER JOIN budget b ON ev.event_id = b.link_to_event\nINNER JOIN expense e ON b.budget_id = e.link_to_budget\nWHERE ev.event_name = 'October Meeting' \nAND ev.event_date LIKE '2019-10-08%';"
        ]
    },
    "1319": {
        "question": "Which college is the vice president of the Student_Club from?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position LIKE 'vice president'",
        "amends": [],
        "rules": [
            "Vice President is a position of the Student Club"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.college\nFROM member AS mem\nJOIN major AS m ON mem.link_to_major = m.major_id\nWHERE mem.position = 'Vice President';"
        ],
        "rule_sql": []
    },
    "709": {
        "question": "In comments with 0 score, how many of the posts have view count lower than 5?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ViewCount < 5 AND T2.Score = 0",
        "amends": [
            "Do use `COUNT(T1.Id)` instead of `COUNT(DISTINCT p.Id) AS PostCount` to count comment IDs without distinct aggregation. Do join `comments AS T1` with `posts AS T2` instead of joining `posts` with `comments` to properly establish the relationship from comments to posts. Do use join condition `T1.PostId = T2.Id` instead of `p.Id = c.PostId` to correctly reference the foreign key relationship. Do move the `Score = 0` filter from comments to posts by using `T2.Score = 0` instead of `c.Score = 0` to filter based on post score rather than comment score. Do keep the `ViewCount < 5` filter on posts but reference it as `T2.ViewCount < 5` instead of `p.ViewCount < 5` to match the new table alias. Do remove the unnecessary DISTINCT modifier and column alias instead of keeping them. The amended query now correctly counts comments from posts with low view count and zero score, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"comments with 0 score\": filter rows where T2.Score equals 0 exactly. 2) When the question asks for posts with \"view count lower than 5\": filter rows where T2.ViewCount is less than 5. 3) When combining comments and posts tables: link rows where T1.PostId equals T2.Id exactly and keep only matching pairs (inner match). 4) When counting comments: compute the number of rows using T1.Id as the counting key without distinct aggregation. Output columns (ordered): COUNT(T1.Id)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.Id) AS PostCount\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE c.Score = 0 AND p.ViewCount < 5;",
            "SELECT COUNT(T1.Id) \nFROM comments AS T1 \nJOIN posts AS T2 ON T1.PostId = T2.Id \nWHERE T2.Score = 0 AND T2.ViewCount < 5"
        ],
        "rule_sql": [
            "SELECT COUNT(comments.Id) \nFROM comments \nJOIN posts ON comments.PostId = posts.Id \nWHERE comments.Score = 0 \nAND posts.ViewCount < 5"
        ]
    },
    "399": {
        "question": "Lists all types of cards available in arena.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL",
        "amends": [
            "Do select both `subtypes` and `supertypes` instead of only `types`. Do add `AND subtypes IS NOT NULL` and `AND supertypes IS NOT NULL` filters instead of omitting null checks. The amended query now correctly retrieves distinct non-null subtype and supertype combinations from arena-available cards, matching the intended behavior.",
            "Do filter by `availability = 'arena'` instead of `mtgArenaId IS NOT NULL` in the WHERE clause, as this more accurately identifies Arena-available cards through a dedicated availability field rather than checking for the presence of an ID. Do keep the DISTINCT selection of `subtypes` and `supertuples` from the `cards` table while maintaining the NOT NULL constraints on both fields, but replace the ID-based filter with the proper availability condition. The amended query now correctly identifies Arena cards using the designated availability field rather than inferring availability through ID presence."
        ],
        "rules": [
            "1) When the question asks for \"types of cards\": include both \"subtypes\" and \"supertypes\" columns from table cards. 2) When filtering for arena-available cards: use the condition availability = 'arena' exactly as specified. 3) When handling null values: add filters AND subtypes IS NOT NULL and AND supertypes IS NOT NULL to exclude null values. 4) When retrieving distinct combinations: ensure the result shows unique combinations of subtypes and supertypes. 5) Output columns (ordered): cards.subtypes, cards.supertypes",
            "1) When the question asks for types of cards available in arena: filter cards where availability equals exactly 'arena' using the exact literal 'arena'.\n2) When selecting distinct card types: return only unique combinations of subtypes and supertypes from the cards table.\n3) When ensuring data quality for type fields: exclude rows where subtypes is null and supertypes is null.\n4) Output columns (ordered): subtypes, supertypes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT types FROM cards WHERE availability = 'arena';",
            "SELECT DISTINCT subtypes, supertypes \nFROM cards \nWHERE mtgArenaId IS NOT NULL \nAND subtypes IS NOT NULL \nAND supertypes IS NOT NULL;",
            "SELECT DISTINCT subtypes, supertypes\nFROM cards\nWHERE availability = 'arena'\nAND subtypes IS NOT NULL\nAND supertypes IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT DISTINCT subtypes, supertypes \nFROM cards \nWHERE availability = 'arena' \nAND subtypes IS NOT NULL \nAND supertypes IS NOT NULL;"
        ]
    },
    "4": {
        "question": "Please list the phone numbers of the direct charter-funded schools that are opened after 2000/1/1.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.Phone FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`Charter School (Y/N)` = 1 AND T2.OpenDate > '2000-01-01'",
        "amends": [
            "Do join `frpm AS T1` with `schools AS T2` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table without any join. Do select `T2.Phone` instead of just `Phone` to specify the table source. Do filter on `T1.Charter Funding Type = 'Directly funded'` instead of `FundingType LIKE '%Direct%'` for more precise matching. Do add the condition `T1.Charter School (Y/N) = 1` instead of omitting this charter school filter. Do keep the `T2.OpenDate > '2000-01-01'` filter but reference it through the joined table instead of the original table. The amended query now correctly joins the necessary tables and applies precise filtering conditions to match the intended logic."
        ],
        "rules": [
            "1) When the question asks for phone numbers of charter-funded schools: join frpm as T1 with schools as T2 where T1.CDSCode equals T2.CDSCode to combine charter funding information with school details.\n2) When filtering for direct charter funding: use T1.\"Charter Funding Type\" = 'Directly funded' for exact matching instead of pattern matching.\n3) When identifying charter schools: include the condition T1.\"Charter School (Y/N)\" = 1 to ensure only charter schools are considered.\n4) When filtering for schools opened after 2000/1/1: use T2.OpenDate > '2000-01-01' to select schools opened after the specified date.\n5) When selecting phone numbers: use T2.Phone to specify the exact source table for the phone number column.\nOutput columns (ordered): T2.Phone"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Phone FROM schools WHERE FundingType LIKE '%Direct%' AND OpenDate > '2000-01-01';",
            "SELECT T2.Phone\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Charter School (Y/N)\" = 1\nAND T1.\"Charter Funding Type\" = 'Directly funded'\nAND T2.OpenDate > '2000-01-01'"
        ],
        "rule_sql": [
            "SELECT T2.Phone\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Charter School (Y/N)\" = 1\nAND T1.\"Charter Funding Type\" = 'Directly funded'\nAND T2.OpenDate > '2000-01-01'"
        ]
    },
    "1051": {
        "question": "List all the football player with the highest potential score.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT(t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = (SELECT MAX(potential) FROM Player_Attributes) ",
        "amends": [
            "Do use `DISTINCT` on `player_name` instead of selecting both `player_name` and `potential` which causes duplicate rows. Do use `INNER JOIN` with explicit table aliases `t1` and `t2` instead of simple `JOIN` with single-letter aliases. Do reference the joined table as `t2` in the `WHERE` clause instead of `pa` to maintain alias consistency. Do remove the explicit `potential` column from the `SELECT` list instead of including it since only distinct player names are needed. The amended query now correctly returns only distinct player names who have the maximum potential value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"highest potential score\": find the maximum value from the \"potential\" column in table T2 (Player_Attributes).\n2) When joining T1 (Player) and T2 (Player_Attributes): link rows where T1.player_api_id equals T2.player_api_id exactly and keep only matching pairs (inner match).\n3) When selecting player names with the highest potential: filter rows where T2.potential equals the maximum potential value found.\n4) When the question asks for \"all football players\" with a specific attribute: return distinct player names to avoid duplicates.\n5) Output columns (ordered): T1.player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.potential\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes);",
            "SELECT DISTINCT p.player_name\nFROM Player p\nINNER JOIN Player_Attributes t1 ON p.player_api_id = t1.player_api_id\nWHERE t1.potential = (SELECT MAX(t2.potential) FROM Player_Attributes t2)"
        ],
        "rule_sql": [
            "SELECT DISTINCT p.player_name\nFROM Player p\nINNER JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes)"
        ]
    },
    "1414": {
        "question": "State the name of major that Phillip Cullen has joined.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "amends": [],
        "rules": [
            "name of major refers to major_name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Phillip' AND mb.last_name = 'Cullen';"
        ],
        "rule_sql": []
    },
    "274": {
        "question": "List the toxicology elements associated with molecule TR001.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR001'",
        "amends": [],
        "rules": [
            "TR001 is the molecule id"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT element FROM atom WHERE molecule_id = 'TR001';"
        ],
        "rule_sql": []
    },
    "293": {
        "question": "How many atoms belong to the molecule labeled with carcinogenic compounds?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS atom_count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+';"
        ],
        "rule_sql": []
    },
    "934": {
        "question": "Which driver was in the no. 4 grid formation when starting the race in 1989's Australian Grand Prix? Please give his forename and surname.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T2.grid = 4 AND T1.name = 'Australian Grand Prix' AND T1.year = 1989",
        "amends": [],
        "rules": [
            "the no. 4 grid formation refers to grid = 4"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 1989 AND rc.name = 'Australian Grand Prix' AND r.grid = 4;"
        ],
        "rule_sql": []
    },
    "1009": {
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "amends": [
            "Do select only `T1.duration` instead of including `d.forename, d.surname, p.duration`. Do remove the `drivers` table join and all driver-related columns instead of keeping them. Do use table aliases `T1` for `pitStops` and `T2` for `races` instead of `p` and `r`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do place the `WHERE` conditions `T2.year = 2011 AND T2.name = 'Australian Grand Prix'` in the same logical order instead of a different sequence. The amended query now correctly retrieves only pit stop durations for the specified race without unnecessary driver information."
        ],
        "rules": [
            "1) When the question asks for \"time each driver spent at the pit stop\": select only the duration column from the pit stops table instead of including driver name information. 2) When joining pit stops and races tables: use an inner join where T1.raceId equals T2.raceId to match pit stops with their corresponding races. 3) When filtering for the 2011 Australian Grand Prix: apply conditions T2.year = 2011 AND T2.name = 'Australian Grand Prix' exactly as specified. 4) When using table aliases: assign T1 to pitStops and T2 to races consistently throughout the query. 5) Output columns (ordered): T1.duration"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname, p.duration\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nJOIN races r ON p.raceId = r.raceId\nWHERE r.name = 'Australian Grand Prix' AND r.year = 2011;",
            "SELECT T1.duration\nFROM pitStops T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'"
        ],
        "rule_sql": [
            "SELECT T1.duration FROM pitStops T1 INNER JOIN races T2 ON T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'"
        ]
    },
    "513": {
        "question": "Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1",
        "amends": [],
        "rules": [
            "expansion type refers to type where type = 'commander'; totalSetSize: The total number of cards in the set, including promotional and related supplemental products but excluding Alchemy modifications; highest total number of cards refers to MAX(totalSetSize)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "520": {
        "question": "Who is the illustrator that illustrated the least amount of cards? List the format of play of the cards that he/she illustrated.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.artist, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid GROUP BY T1.artist ORDER BY COUNT(T1.id) ASC LIMIT 1",
        "amends": [
            "Do select `T1.artist` and `T2.format` instead of only `l.format` with `DISTINCT`. Do use a direct `INNER JOIN` between `cards AS T1` and `legalities AS T2` on `T2.uuid = T1.uuid` instead of a separate CTE and join on `c.uuid = l.uuid`. Do remove the `WHERE c.artist = (SELECT artist FROM MinIllustrator)` subquery condition instead of keeping it. Do add `GROUP BY T1.artist` instead of omitting grouping. Do order by `COUNT(T1.id) ASC` instead of ordering by `card_count ASC` in the CTE. Do apply `LIMIT 1` at the main query level instead of in a CTE. The amended query now correctly returns the artist with the fewest cards along with their format, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When finding the illustrator with the least amount of cards: count the number of cards using T1.id as the counting key for each T1.artist, then order by this count in ascending order and keep only the first row.\n2) When combining cards table (T1) and legalities table (T2): link rows where T2.uuid equals T1.uuid exactly and keep only matching pairs (inner match).\n3) When selecting output for this question: include both T1.artist and T2.format in the results instead of only one column.\n4) When grouping results: organize by T1.artist to compute aggregates per illustrator.\n5) When applying limit constraints: apply LIMIT 1 at the main query level to get only the illustrator with the minimum count.\nOutput columns (ordered): T1.artist, T2.format"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH MinIllustrator AS (\n    SELECT artist, COUNT(*) AS card_count\n    FROM cards\n    WHERE artist IS NOT NULL\n    GROUP BY artist\n    ORDER BY card_count ASC\n    LIMIT 1\n)\nSELECT DISTINCT l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.artist = (SELECT artist FROM MinIllustrator);",
            "SELECT T1.artist, T2.format\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T2.uuid = T1.uuid\nGROUP BY T1.artist\nORDER BY COUNT(T1.id) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.artist, T2.format\nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nWHERE T1.artist IS NOT NULL\nGROUP BY T1.artist\nORDER BY COUNT(T1.id) ASC\nLIMIT 1;"
        ]
    },
    "1100": {
        "question": "What is the highest overall rating received by Dorlan Pabon?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT MAX(t2.overall_rating) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Dorlan Pabon'",
        "amends": [],
        "rules": [
            "Dorlan Pabon refers to T2.player_name = 'Dorlan Pabon'; highest overall rating refers to MAX(overall_rating)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(pa.overall_rating) AS highest_overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Dorlan Pabon';"
        ],
        "rule_sql": []
    },
    "719": {
        "question": "Among the superheroes with the super power of \"Super Strength\", how many of them have a height of over 200cm?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.height_cm > 200",
        "amends": [],
        "rules": [
            "super power of \"Super Strength\" refers to power_name = 'Super Strength'; a height of over 200cm refers to height_cm > 200"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Super Strength' AND s.height_cm > 200;"
        ],
        "rule_sql": []
    },
    "1334": {
        "question": "List the full name of the Student_Club members that grew up in Illinois state.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'",
        "amends": [
            "Do select individual columns `first_name` and `last_name` instead of concatenating them with `||` into a single `full_name` alias. Do use table aliases `T1` and `T2` instead of single letters `m` and `z`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly returns separate first and last name columns while maintaining the same join logic and filtering behavior."
        ],
        "rules": [
            "1) When selecting names from the member table: return first_name and last_name as separate columns instead of concatenating them into a single full_name alias. 2) When joining member and zip_code tables: use table aliases T1 for member and T2 for zip_code instead of single-letter aliases. 3) When combining T1 and T2 for shared zip codes: link rows where T1.zip = T2.zip_code and keep only matching pairs (inner match). 4) When filtering by state: include only rows where T2.state equals exactly 'Illinois' (case-sensitive). Output columns (ordered): T1.first_name, T1.last_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE z.state = 'Illinois';",
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T2.state = 'Illinois';"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name FROM member T1 JOIN zip_code T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'"
        ]
    },
    "1358": {
        "question": "Who was the first one paid his/her dues? Tell the full name.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.source = 'Dues' ORDER BY T2.date_received LIMIT 1",
        "amends": [],
        "rules": [
            "full name refers to first_name, last_name; first paid dues refers to MIN(received_date) where source = 'Dues'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nORDER BY i.date_received ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "891": {
        "question": "Name all drivers in the 2010 Singapore Grand Prix order by their position stands.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010 ORDER BY T2.position ASC",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `driver_name`. Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `ds`, and `d`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do fix the join condition to `T2.raceId = T1.raceId` instead of `ds.raceId = r.raceId`. Do change the WHERE clause order to `T1.name = 'Singapore Grand Prix' AND T1.year = 2010` instead of `r.year = 2010 AND r.name = 'Singapore Grand Prix'`. Do add explicit `ASC` to the ORDER BY instead of omitting the direction. Do remove the `position` column from the SELECT list instead of including it. The amended query now correctly retrieves only driver names without standings data while maintaining the same filtering logic."
        ],
        "rules": [
            "1) When the question asks for driver names: select T3.forename and T3.surname as separate columns instead of concatenating them.\n2) When joining tables races, results, and drivers: use aliases T1 for races, T2 for results, and T3 for drivers consistently.\n3) When combining T1 and T2: link rows where T2.raceId = T1.raceId using an inner match.\n4) When combining T2 and T3: link rows where T2.driverId = T3.driverId using an inner match.\n5) When filtering for the 2010 Singapore Grand Prix: use the exact condition T1.name = 'Singapore Grand Prix' AND T1.year = 2010 with the literals preserved exactly.\n6) When ordering by position: order by T2.position in ascending direction (ASC) but do not include the position column in the output.\n7) Output columns (ordered): T3.forename, T3.surname"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.forename || ' ' || d.surname AS driver_name, ds.position\nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nJOIN races r ON ds.raceId = r.raceId\nWHERE r.year = 2010 AND r.name = 'Singapore Grand Prix'\nORDER BY ds.position;",
            "SELECT T3.forename, T3.surname \nFROM races T1 \nINNER JOIN driverStandings T2 ON T2.raceId = T1.raceId \nINNER JOIN drivers T3 ON T3.driverId = T2.driverId \nWHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010 \nORDER BY T2.position ASC"
        ],
        "rule_sql": [
            "SELECT T3.forename, T3.surname\nFROM races T1\nINNER JOIN results T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers T3 ON T2.driverId = T3.driverId\nWHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010\nORDER BY T2.position ASC"
        ]
    },
    "585": {
        "question": "How much is the total bounty amount of the post titled about 'data'",
        "db_id": "codebase_community",
        "ground_truth": "SELECT SUM(T2.BountyAmount) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data%'",
        "amends": [],
        "rules": [
            "About data means the title contains 'data'; total bounty Amount refers to Sum(BountyAmount)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(v.BountyAmount) AS TotalBountyAmount\nFROM posts p\nJOIN votes v ON p.Id = v.PostId\nWHERE p.Title LIKE '%data%';"
        ],
        "rule_sql": []
    },
    "1375": {
        "question": "List all the members of the \"School of Applied Sciences, Technology and Education\" department.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'",
        "amends": [],
        "rules": [
            "list all members means to list all the full name; full name refers to first_name, last_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.department = 'School of Applied Sciences, Technology and Education';"
        ],
        "rule_sql": []
    },
    "889": {
        "question": "When was the last f1 season whereby Brands Hatch hosted the British Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Brands Hatch' AND T2.name = 'British Grand Prix' ORDER BY T2.year DESC LIMIT 1",
        "amends": [
            "Do select `T2.date` instead of `MAX(r.year) AS last_season` to retrieve the actual date rather than just the maximum year. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with `r` and `c` aliases for better clarity. Do join on `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId` to ensure proper column matching. Do filter with exact equality `T2.name = 'British Grand Prix'` instead of pattern matching `LIKE '%British Grand Prix%'` for precise race name matching. Do add `ORDER BY T2.year DESC LIMIT 1` instead of omitting ordering and limiting to get the most recent single result. The amended query now correctly retrieves the date of the most recent British Grand Prix at Brands Hatch circuit."
        ],
        "rules": [
            "1) When the question asks for the last occurrence of an event at a specific location: retrieve the most recent date using the exact date column token (T2.date) instead of aggregating by year. 2) When joining tables for circuit and race information: link rows where T2.circuitID = T1.circuitId to ensure proper column matching between circuits and races. 3) When filtering for a specific circuit name: use exact equality T1.name = 'Brands Hatch' to match the circuit precisely. 4) When filtering for a specific race name: use exact equality T2.name = 'British Grand Prix' instead of pattern matching for precise race name matching. 5) When retrieving the most recent single result: order by T2.year in descending order and limit to 1 row to get the most recent occurrence. Output columns (ordered): T2.date"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(r.year) AS last_season\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Brands Hatch' AND r.name LIKE '%British Grand Prix%';",
            "SELECT T2.date \nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Brands Hatch' \nAND T2.name = 'British Grand Prix'\nORDER BY T2.year DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.date \nFROM circuits T1 \nJOIN races T2 ON T2.circuitId = T1.circuitId \nWHERE T1.name = 'Brands Hatch' \nAND T2.name = 'British Grand Prix' \nORDER BY T2.year DESC \nLIMIT 1"
        ]
    },
    "392": {
        "question": "Pick 3 cards with rarity of uncommon, list down name these cards according to ascending order of it's ruling date.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3",
        "amends": [
            "Do use `DISTINCT` in the SELECT clause instead of omitting it to eliminate duplicate card names. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `c` and `r` for consistent naming. Do maintain the same join condition `T1.uuid = T2.uuid` instead of changing it. Do keep the WHERE filter on `T1.rarity = 'uncommon'` unchanged. Do preserve the ORDER BY on `T2.date ASC` and LIMIT 3 without modification. The amended query now correctly returns distinct card names while maintaining the same filtering, joining, and sorting logic."
        ],
        "rules": [
            "1) When the question asks for cards with rarity of \"uncommon\": filter rows where T1.rarity equals exactly 'uncommon'. 2) When combining cards and rulings tables: link rows where T1.uuid equals T2.uuid and keep only matching pairs (inner match). 3) When the question asks for distinct card names: eliminate duplicate values of T1.name. 4) When the question requires ordering by ruling date in ascending order: sort rows by T2.date in ascending order. 5) When the question asks for the top 3 results: keep the first 3 rows after sorting. 6) Output columns (ordered): T1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.rarity = 'uncommon'\nORDER BY r.date ASC\nLIMIT 3;",
            "SELECT DISTINCT T1.name\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'uncommon'\nORDER BY T2.date ASC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'uncommon'\nORDER BY T2.date ASC\nLIMIT 3"
        ]
    },
    "740": {
        "question": "How many female superheroes have a strength value of 100?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.attribute_name = 'Strength' AND T2.attribute_value = 100 AND T4.gender = 'Female'",
        "amends": [],
        "rules": [
            "female refers to gender = 'Female'; strength value of 100 refers to attribute_name = 'Strength' AND attribute_value = 100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT s.id) AS female_heroes_with_strength_100\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE g.gender = 'Female'\nAND a.attribute_name = 'Strength'\nAND ha.attribute_value = 100;"
        ],
        "rule_sql": []
    },
    "330": {
        "question": "Calculate the percentage of carcinogenic molecules with triple bonded Hidrogen atoms.",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T2.element = 'h'",
        "amends": [
            "Do use explicit `CAST` to `REAL` for the sum calculation instead of implicit conversion. Do reference the molecule table as `T1` instead of `m` and use table aliases consistently throughout. Do join directly to `bond` table on `molecule_id` instead of through the complex `atom-connected-atom-bond` chain. Do simplify the FROM clause with `INNER JOIN` on `molecule_id` instead of multiple joins through connected atoms. Do move both filter conditions to the `WHERE` clause instead of having them scattered. Do remove the unnecessary `DISTINCT` from the molecule count since molecule_id should already be unique per molecule. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. The amended query now correctly calculates the percentage of '+' labeled molecules with hydrogen atoms and triple bonds by simplifying the join logic and ensuring proper numeric conversion.",
            "Do use `SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT CASE WHEN T1.label = '+' THEN T1.molecule_id END)` to count positive labels without unnecessary distinct operations. Do remove the explicit `CAST(REAL)` conversions around the count operations since the division will handle type conversion. Do change the bond filter to `T3.bond_type = '#'` instead of `b.bond_type = 'triple'` to match the correct bond type notation. Do change the element filter to `T2.element = 'h'` instead of `a.element = 'H'` to use lowercase matching. Do remove the table aliases `a` and `b` in favor of `T2` and `T3` for consistency. Do remove the multiplication by `100.0` at the end and instead place `* 100` after the division to maintain the same percentage calculation logic. The amended query now correctly calculates the percentage of molecules with positive labels among those containing hydrogen atoms and triple bonds.",
            "Do add `CAST(... AS REAL)` around the SUM expression instead of omitting it to ensure proper floating-point division. Do remove the `100.0` decimal notation and use integer `100` instead while maintaining the same mathematical operation. Do reorder the WHERE clause predicates to `T3.bond_type = '#' AND T2.element = 'h'` instead of the original order, though this is functionally equivalent. Do remove the explicit table aliases `AS` keyword from the FROM clause while keeping the same table references. The amended query now correctly handles the floating-point division by casting the SUM result to REAL before multiplication and division, ensuring accurate percentage calculation while maintaining the same logical behavior as the RIGHT_SQL.",
            "Do keep the identical SELECT list with `CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id)` instead of changing it. Do maintain the same FROM sources with `molecule T1 INNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond T3 ON T1.molecule_id = T3.molecule_id` instead of altering the join structure. Do preserve the identical WHERE filters with `T3.bond_type = '#' AND T2.element = 'h'` instead of modifying the conditions. The amended query now matches RIGHT_SQL's behavior by maintaining all the same logic and calculations without any substantive changes to the query structure or semantics."
        ],
        "rules": [
            "1) When calculating percentages involving counts: cast the sum calculation to REAL type for proper numeric conversion. 2) When referencing the molecule table: use alias T1 consistently throughout the query. 3) When joining molecule and bond tables: use INNER JOIN on molecule_id directly instead of complex join chains through connected atoms. 4) When filtering for hydrogen atoms and triple bonds: place both conditions (T1.element = 'h' and T2.bond_type = '#') in the WHERE clause. 5) When counting molecules: do not use DISTINCT on molecule_id since it should already be unique per molecule. 6) When the question asks for percentage of carcinogenic molecules with triple bonded Hydrogen atoms: compute (number of molecules with label '+' that have hydrogen atoms and triple bonds) divided by (total number of molecules with hydrogen atoms and triple bonds), cast to REAL and multiplied by 100.0. Output columns (ordered): percentage",
            "1) When counting molecules with positive labels: use SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) instead of COUNT(DISTINCT) operations to avoid unnecessary distinct operations.\n2) When filtering for hydrogen atoms: use T2.element = 'h' with lowercase matching instead of 'H'.\n3) When filtering for triple bonds: use T3.bond_type = '#' instead of 'triple' to match the correct bond type notation.\n4) When calculating percentages: place * 100 after the division operation rather than multiplying by 100.0 at the end.\n5) When combining tables: use consistent aliases T2 for atom table and T3 for bond table instead of arbitrary aliases a and b.\n6) When performing division operations: do not use explicit CAST(REAL) conversions around count operations as the division will handle type conversion automatically.\n7) Output columns (ordered): percentage",
            "1) When calculating percentages involving division: cast the numerator to REAL before multiplication and division to ensure proper floating-point arithmetic. 2) When using numeric constants in percentage calculations: use integer 100 instead of decimal 100.0 while maintaining the same mathematical operation. 3) When filtering for triple bonded Hydrogen atoms: use the exact literal '#' for bond_type and exact literal 'h' for element. 4) When joining molecule, atom, and bond tables: link them using molecule_id equality to ensure proper relationship matching. 5) When counting carcinogenic molecules: use the exact condition T1.label = '+' to identify positive cases. 6) When computing percentage of carcinogenic molecules: calculate (number of molecules with label = '+') divided by (total distinct molecules) multiplied by 100. Output columns (ordered): the calculated percentage value",
            "1) When calculating percentages of carcinogenic molecules: use the exact formula CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id).\n2) When joining molecule, atom, and bond tables: combine them using molecule_id as the linking key with inner matches (T1.molecule_id = T2.molecule_id and T1.molecule_id = T3.molecule_id).\n3) When filtering for triple bonded Hydrogen atoms: apply the exact conditions T3.bond_type = '#' AND T2.element = 'h'.\n4) When counting distinct molecules: use T1.molecule_id as the counting key.\n5) When identifying carcinogenic molecules: use the exact condition T1.label = '+'.\n6) Output columns (ordered): the single calculated percentage value from the formula."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM molecule m\nJOIN atom a1 ON m.molecule_id = a1.molecule_id\nJOIN connected c ON a1.atom_id = c.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a1.element = 'h' AND b.bond_type = '#';",
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN T1.label = '+' THEN T1.molecule_id END) AS REAL) / \n     CAST(COUNT(DISTINCT T1.molecule_id) AS REAL)) * 100.0 AS percentage\nFROM \n    molecule T1\nINNER JOIN \n    atom a ON T1.molecule_id = a.molecule_id\nINNER JOIN \n    bond b ON T1.molecule_id = b.molecule_id\nWHERE \n    a.element = 'H' \n    AND b.bond_type = 'triple'",
            "SELECT \n    (SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT T1.molecule_id)\nFROM \n    molecule T1\n    INNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN bond T3 ON T1.molecule_id = T3.molecule_id\nWHERE \n    T2.element = 'h' AND \n    T3.bond_type = '#'",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id)\nFROM \n    molecule T1\n    INNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN bond T3 ON T1.molecule_id = T3.molecule_id\nWHERE \n    T3.bond_type = '#' AND T2.element = 'h'",
            "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id)\nFROM molecule T1 \nINNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id \nINNER JOIN bond T3 ON T1.molecule_id = T3.molecule_id\nWHERE T3.bond_type = '#' AND T2.element = 'h'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) AS percentage\nFROM \n    molecule T1\nINNER JOIN \n    atom T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN \n    bond T3 ON T1.molecule_id = T3.molecule_id\nWHERE \n    T2.element = 'h' \n    AND T3.bond_type = '#'"
        ]
    },
    "213": {
        "question": "What type of bond is there between the atoms TR004_8 and TR004_20?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20'",
        "amends": [],
        "rules": [
            "type of bond refers to bond_type; between the atoms TR004_8 and TR004_20 refers to atom_id = 'TR004_8' AND atom_id2 = 'TR004_20' OR another way around"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR004_8' AND c.atom_id2 = 'TR004_20') OR (c.atom_id = 'TR004_20' AND c.atom_id2 = 'TR004_8');"
        ],
        "rule_sql": []
    },
    "1318": {
        "question": "What is the event that has the highest attendance of the students from the Student_Club?",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_name ORDER BY COUNT(T2.link_to_event) DESC LIMIT 1",
        "amends": [
            "Do select only `event_name` instead of including `event_id` and `attendance_count`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `e` and `a`. Do join on `T1.event_id = T2.link_to_event` instead of `e.event_id = a.link_to_event`. Do group by only `event_name` instead of both `event_id` and `event_name`. Do order by `COUNT(T2.link_to_event)` instead of the alias `attendance_count`. The amended query now correctly returns only the event name with the highest attendance count, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the event with highest attendance: rank events by attendance count in descending order and keep the first 1 row.\n2) When joining tables T1 (event) and T2 (attendance): link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match).\n3) When counting attendance: compute the number of rows using T2.link_to_event as the counting key.\n4) When grouping results: organize by T1.event_name and compute aggregates per event.\n5) When ordering results: sort by the attendance count (COUNT(T2.link_to_event)) in descending order.\n6) When selecting output columns: return only T1.event_name instead of including event_id or count values.\nOutput columns (ordered): T1.event_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_id, e.event_name, COUNT(a.link_to_member) AS attendance_count\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nGROUP BY e.event_id, e.event_name\nORDER BY attendance_count DESC\nLIMIT 1;",
            "SELECT T1.event_name\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_name\nORDER BY COUNT(T2.link_to_event) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT e.event_name\nFROM event e\nINNER JOIN attendance a ON e.event_id = a.link_to_event\nGROUP BY e.event_name\nORDER BY COUNT(a.link_to_event) DESC\nLIMIT 1;"
        ]
    },
    "1316": {
        "question": "Please list the phone numbers of the students from the Student_Club that has attended the event \"Women's Soccer\".",
        "db_id": "student_club",
        "ground_truth": "SELECT T3.phone FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer'",
        "amends": [],
        "rules": [
            "Women's Soccer is an event name; phone numbers refers to phone"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.phone\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = \"Women's Soccer\";"
        ],
        "rule_sql": []
    },
    "251": {
        "question": "What is the least common element of all carcinogenic molecules?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "amends": [
            "Do select only `T.element` instead of both `a.element` and `COUNT(a.element)`. Do use a subquery instead of a simple query structure. Do add table aliases `T1` and `T2` instead of no aliases. Do use `INNER JOIN` with explicit keyword instead of implicit `JOIN`. Do count `DISTINCT T2.molecule_id` instead of counting `a.element`. Do group by `T2.element` instead of `a.element`. Do order by `COUNT(DISTINCT T2.molecule_id)` instead of `element_count ASC`. Do remove the explicit alias `element_count` from the output. The amended query now correctly counts distinct molecules per element rather than total atoms, matching the intended behavior.",
            "Do remove the alias `molecule_count` from the COUNT expression instead of keeping it. Do change the WHERE filter to `T1.label = '+'` instead of `T1.label = 'carcinogenic'`. Do use the COUNT expression directly in ORDER BY instead of referencing the removed alias. Do remove the ASC keyword from ORDER BY instead of specifying ascending order explicitly. Do use lowercase `t` as the subquery alias instead of uppercase `T`. The amended query now correctly counts molecules with '+' label and orders by the count directly without an alias."
        ],
        "rules": [
            "1) When the question asks for the \"least common element\": rank elements by their molecule count in ascending order and keep the first 1 row.\n2) When counting molecules per element: compute the number of unique T2.molecule_id values for each T2.element.\n3) When organizing results by element: group by T2.element to compute aggregates per element.\n4) When selecting output columns: include only T2.element in the final result.\n5) When ordering results: sort by the count of distinct T2.molecule_id in ascending order.\n6) When handling text literals: preserve exact case and punctuation as shown in the schema.\n7) When using table aliases: maintain T1 for the base table and T2 for related tables as established in the amends.\nOutput columns (ordered): T2.element",
            "1) When the question asks for the least common element: rank elements by their molecule count in ascending order and keep the first 1 row. 2) When counting molecules per element: compute the number of distinct T2.molecule_id values for each T2.element. 3) When filtering for carcinogenic molecules: use the exact literal T1.label = '+' instead of 'carcinogenic'. 4) When ordering by count: use the COUNT(DISTINCT T2.molecule_id) expression directly without an alias. 5) When using subquery aliases: use lowercase t instead of uppercase T. 6) When combining atom and molecule tables: link rows where T2.molecule_id = T1.molecule_id and keep only matching pairs (inner match). Output columns (ordered): t.element"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.element, COUNT(a.element) AS element_count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+'\nGROUP BY a.element\nORDER BY element_count ASC\nLIMIT 1;",
            "SELECT T.element\nFROM (\n    SELECT T2.element, COUNT(DISTINCT T2.molecule_id) AS molecule_count\n    FROM atom AS T2\n    INNER JOIN molecule AS T1 ON T2.molecule_id = T1.molecule_id\n    WHERE T1.label = 'carcinogenic'\n    GROUP BY T2.element\n    ORDER BY molecule_count ASC\n    LIMIT 1\n) AS T",
            "SELECT t.element\nFROM (\n    SELECT T2.element, COUNT(DISTINCT T2.molecule_id) \n    FROM molecule AS T1\n    INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T1.label = '+'\n    GROUP BY T2.element\n    ORDER BY COUNT(DISTINCT T2.molecule_id)\n    LIMIT 1\n) AS t"
        ],
        "rule_sql": [
            "SELECT t.element\nFROM molecule t1\nJOIN atom t2 ON t1.molecule_id = t2.molecule_id\nWHERE t1.label = '+'\nGROUP BY t2.element\nORDER BY COUNT(DISTINCT t2.molecule_id) ASC\nLIMIT 1"
        ]
    },
    "1171": {
        "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.Birthday) < 18",
        "amends": [],
        "rules": [
            "underage patients refers to year(Birthday) < 18; three-year period from 1990 to 1993 refers to year(`Examination Date`) between '1990' and '1993'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS UnderagePatientsExamined\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE E.`Examination Date` BETWEEN '1990-01-01' AND '1993-12-31'\nAND (strftime('%Y', E.`Examination Date`) - strftime('%Y', P.Birthday) - \n    (strftime('%m-%d', E.`Examination Date`) < strftime('%m-%d', P.Birthday))) < 18;"
        ],
        "rule_sql": []
    },
    "1237": {
        "question": "Among all outpatients, list out those have low hemoglobin level. State the different IDs and their sex.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HGB < 10 AND T1.Admission = '-'",
        "amends": [],
        "rules": [
            "outpatients refers to Admission = '-'; low hemoglobin level refers to HBG < 10;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.ID, p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Admission = '-' AND l.HGB < 10;"
        ],
        "rule_sql": []
    },
    "1354": {
        "question": "State the major name for the Vice President of the club.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Vice President'",
        "amends": [],
        "rules": [
            "'Vice President' is a position of Student Club"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'Vice President';"
        ],
        "rule_sql": []
    },
    "614": {
        "question": "Among the users who obtained the \"Teacher\" badge, calculate their percentage of users",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) * 100 / (SELECT COUNT(Id) FROM users) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Teacher'",
        "amends": [],
        "rules": [
            "\"Teacher\" is the Name of badge;  percentage = Divide (Count(UserId where it's \"Teacher\"), Count(UserId)) * 100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(DISTINCT b.UserId) * 100.0 / NULLIF(COUNT(DISTINCT u.Id), 0)) AS percentage_teacher_badge_users\nFROM \n    users u\nLEFT JOIN \n    badges b ON u.Id = b.UserId AND b.Name = 'Teacher';"
        ],
        "rule_sql": []
    },
    "124": {
        "question": "List the loan ID, district and average salary for loan with duration of 60 months.",
        "db_id": "financial",
        "ground_truth": "SELECT T3.loan_id, T2.A2, T2.A11 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.duration = 60",
        "amends": [],
        "rules": [
            "A3 refers to regions; A11 refers to average salary"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.loan_id, d.A2 AS district, d.A11 AS average_salary\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.duration = 60;"
        ],
        "rule_sql": []
    },
    "636": {
        "question": "How many negative comments did Neil McGuigan get in his posts?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T3.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T1.DisplayName = 'Neil McGuigan' AND T3.Score < 60",
        "amends": [],
        "rules": [
            "Negative comment refers to score < 60; DisplayName = 'Neil McGuigan';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NegativeCommentCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'Neil McGuigan' AND c.Score < 60;"
        ],
        "rule_sql": []
    },
    "188": {
        "question": "Among the accounts who have loan validity more than 24 months, list out the accounts that have the lowest approved amount and have account opening date before 1997.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.duration > 24 AND STRFTIME('%Y', T2.date) < '1997' ORDER BY T1.amount ASC LIMIT 1",
        "amends": [
            "Do select only `account_id` instead of including `amount` and `account_opening_date`. Do use `INNER JOIN` with explicit alias `T2` instead of `JOIN` with alias `a`. Do filter by year extraction `STRFTIME('%Y', T2.date)` instead of direct date comparison `a.date < '1997-01-01'`. Do remove the subquery for minimum amount and instead use `ORDER BY T1.amount ASC LIMIT 1` to get the single smallest amount record instead of comparing against all minimum amounts. Do add explicit `ORDER BY` and `LIMIT` clauses instead of omitting them. The amended query now correctly returns the account with the smallest loan amount from 1996 or earlier with duration over 24 months, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for accounts with loan validity more than 24 months: filter rows where T1.duration > 24.\n2) When the question asks for accounts with opening date before 1997: filter rows where STRFTIME('%Y', T2.date) < '1997'.\n3) When the question asks for the lowest approved amount: order rows by T1.amount in ascending order and keep only the first row.\n4) When combining loan and account tables: link rows where T1.account_id = T2.account_id using inner match.\n5) When selecting output columns: include only account_id from the result.\n6) Output columns (ordered): T1.account_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.account_id, l.amount, a.date AS account_opening_date\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nWHERE l.duration > 24\nAND a.date < '1997-01-01'\nAND l.amount = (SELECT MIN(amount) FROM loan WHERE duration > 24);",
            "SELECT T1.account_id\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE T1.duration > 24\nAND STRFTIME('%Y', T2.date) < '1997'\nORDER BY T1.amount ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.account_id\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE T1.duration > 24\nAND STRFTIME('%Y', T2.date) < '1997'\nORDER BY T1.amount ASC\nLIMIT 1"
        ]
    },
    "739": {
        "question": "What are the names of the superheroes with the power of death touch?",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'",
        "amends": [],
        "rules": [
            "name of superheroes refers to refers to superhero_name; the power of death touch refers to power_name = 'Death Touch'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Death Touch';"
        ],
        "rule_sql": []
    },
    "1328": {
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "amends": [],
        "rules": [
            "'Law and Constitutional Studies' is the major name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Law and Constitutional Studies';"
        ],
        "rule_sql": []
    },
    "39": {
        "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
        "db_id": "california_schools",
        "ground_truth": "SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T2.County = 'Fresno'",
        "amends": [],
        "rules": [
            "between 1/1/1980 and 12/31/1980 means the year = 1980"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(s.NumTstTakr) AS average_test_takers\nFROM schools sc\nJOIN satscores s ON sc.CDSCode = s.cds\nWHERE sc.County = 'Fresno'\nAND sc.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';"
        ],
        "rule_sql": []
    },
    "378": {
        "question": "What are the foiled cards that are incredibly powerful when paired with non foiled cards? List the IDs.",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "amends": [],
        "rules": [
            "Incredibly powerful refers to both cardKingdomFoilId and cardKingdomId IS NOT Null;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM cards WHERE hasFoil = 1 AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1276": {
        "question": "For the patients who have an abnormal level of anti-DNA, please list the diseases they are diagnosed with.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT(T1.Diagnosis) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA >= 8",
        "amends": [],
        "rules": [
            "abnormal level of anti-DNA refers to DNA > = 8; diseases refers to Diagnosis;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.DNA >= 8;"
        ],
        "rule_sql": []
    },
    "1085": {
        "question": "Which of these players performs the best in crossing actions, Alexis, Ariel Borysiuk or Arouna Kone?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.player_name, t2.crossing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY t2.crossing DESC LIMIT 1",
        "amends": [],
        "rules": [
            "player who perform best in crossing actions refers to MAX(crossing);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.crossing\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone')\nORDER BY pa.crossing DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "515": {
        "question": "When was the oldest mythic card released and what are its legal play formats?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate LIMIT 1",
        "amends": [
            "Do add `T1.originalReleaseDate IS NOT NULL` to the WHERE clause instead of omitting it to filter out null dates. Do change the join to `INNER JOIN` instead of `JOIN` for explicit clarity. Do use table aliases `T1` and `T2` instead of `c` and `l` for consistency. Do capitalize `Legal` instead of `legal` in the status filter to match case-sensitive values. Do remove `ASC` from the ORDER BY clause instead of keeping it since ascending is the default. The amended query now correctly excludes null release dates while maintaining the same join logic and filtering criteria."
        ],
        "rules": [
            "1) When the question asks for the oldest card by release date: find the minimum value of T1.originalReleaseDate among cards that have a non-null release date. 2) When filtering for mythic rarity cards: include only rows where T1.rarity equals exactly 'mythic'. 3) When checking legal play formats: include only rows where T2.status equals exactly 'Legal' (case-sensitive). 4) When combining card and legality information: link rows where T1.uuid equals T2.uuid and keep only matching pairs (inner match). 5) When excluding null release dates: filter out rows where T1.originalReleaseDate IS NOT NULL. 6) When ordering by date for oldest item: sort by T1.originalReleaseDate in ascending order (default). 7) When retrieving the single oldest item: take only the first row after sorting. Output columns (ordered): T1.originalReleaseDate, T2.format"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.originalReleaseDate, l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic' AND l.status = 'legal'\nORDER BY c.originalReleaseDate ASC\nLIMIT 1;",
            "SELECT T1.originalReleaseDate, T2.format\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'mythic' \nAND T2.status = 'Legal'\nAND T1.originalReleaseDate IS NOT NULL\nORDER BY T1.originalReleaseDate\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.originalReleaseDate, T2.format\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'mythic'\nAND T1.originalReleaseDate IS NOT NULL\nAND T2.status = 'Legal'\nORDER BY T1.originalReleaseDate ASC\nLIMIT 1"
        ]
    },
    "1525": {
        "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
        "amends": [
            "Do use a single query with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of separate CTEs with a cross join. Do calculate the percentage directly using `SUM(IIF(T2.Currency = 'EUR', 1, 0)) * 100 / COUNT(T1.CustomerID)` instead of separate counts and division. Do filter with `WHERE T1.Date = '2012-08-25'` instead of duplicating the date condition in both CTEs. Do remove the `DISTINCT` from customer counting and instead count all joined rows to properly calculate the percentage. Do add explicit `CAST` to `FLOAT` for accurate division instead of relying on implicit conversion. Do eliminate the `CASE` statement for zero division protection since the join ensures at least one row when filtering by date. The amended query now correctly calculates the percentage of EUR customers on the specified date by joining and counting in a single pass."
        ],
        "rules": [
            "1) When the question asks for percentage of customers who used a specific currency on a specific date: join T1 (transactions_1k) and T2 (customers) where T1.CustomerID = T2.CustomerID to combine transaction and customer data.\n2) When filtering for a specific date '2012-08-25': apply WHERE T1.Date = '2012-08-25' to restrict to transactions on that date.\n3) When calculating percentage of customers using EUR: compute (SUM(IIF(T2.Currency = 'EUR', 1, 0)) * 100 / COUNT(T1.CustomerID)) to get the percentage directly.\n4) When handling division: cast to FLOAT for accurate decimal results instead of relying on implicit conversion.\n5) When counting customers: count all joined rows using T1.CustomerID without DISTINCT to properly calculate the percentage.\n6) When joining tables: use INNER JOIN on T1.CustomerID = T2.CustomerID to ensure proper matching of transaction and customer records.\nOutput columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH total_customers AS (\n    SELECT COUNT(DISTINCT CustomerID) AS total\n    FROM transactions_1k\n    WHERE Date = '2012-08-25'\n),\neur_customers AS (\n    SELECT COUNT(DISTINCT t.CustomerID) AS eur_count\n    FROM transactions_1k t\n    JOIN customers c ON t.CustomerID = c.CustomerID\n    WHERE t.Date = '2012-08-25' AND c.Currency = 'EUR'\n)\nSELECT \n    CASE \n        WHEN total > 0 THEN (eur_count * 100.0 / total)\n        ELSE 0\n    END AS percentage\nFROM total_customers, eur_customers;",
            "SELECT \n    CAST(SUM(IIF(c.Currency = 'EUR', 1, 0)) AS FLOAT) * 100.0 / COUNT(t.CustomerID) AS Percentage\nFROM transactions_1k t\nINNER JOIN customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-25';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(c.Currency = 'EUR', 1, 0)) * 100.0 / COUNT(t.CustomerID)) AS percentage\nFROM \n    transactions_1k t\nINNER JOIN \n    customers c ON t.CustomerID = c.CustomerID\nWHERE \n    t.Date = '2012-08-25';"
        ]
    },
    "298": {
        "question": "Calculate the percentage of molecules containing carcinogenic compounds that element is hydrogen.",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "amends": [
            "Do use `INNER JOIN` between `atom` and `molecule` instead of `LEFT JOIN` to ensure only molecules with atoms are considered. Do calculate the percentage using `CAST` to `REAL` instead of implicit floating-point conversion with `100.0`. Do count `CASE` expressions directly instead of using `COUNT(DISTINCT)` to avoid unnecessary deduplication. Do reference tables with aliases `T1` for `atom` and `T2` for `molecule` instead of single-letter aliases. Do place the condition `element = 'h'` before `label = '+'` in the `CASE` expression instead of the reverse order. Do use `ELSE NULL` explicitly in the `CASE` expression instead of relying on implicit NULL behavior. Do remove the multiplication by `100.0` from inside the numerator calculation and instead place it in the division operation. The amended query now correctly calculates the percentage of hydrogen atoms with positive labels among all molecules that have atoms.",
            "Do remove `DISTINCT` from both the numerator and denominator counts instead of keeping them, as the molecule_id values are already unique within their respective contexts. Do use integer division with `/` instead of floating-point division with `* 100.0 /` to maintain proper arithmetic behavior. Do omit the column alias `percentage` instead of including it, as the right query returns an unnamed scalar result. Do use the same join condition `T1.molecule_id = T2.molecule_id` instead of changing it, maintaining the correct relationship between atom and molecule tables. The amended query now correctly calculates the percentage without unnecessary distinct operations and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When joining atom and molecule tables: use inner join between T1 (atom) and T2 (molecule) on T1.molecule_id = T2.molecule_id to ensure only molecules with atoms are considered.\n2) When calculating percentages: use CAST to REAL for floating-point conversion instead of implicit conversion with 100.0.\n3) When counting case expressions: count the case expressions directly instead of using COUNT(DISTINCT) to avoid unnecessary deduplication.\n4) When ordering conditions in case expressions: place element = 'h' before label = '+' in the case expression.\n5) When writing case expressions: use ELSE NULL explicitly instead of relying on implicit NULL behavior.\n6) When structuring percentage calculations: remove multiplication by 100.0 from inside the numerator and place it in the division operation.\n7) Output columns (ordered): percentage",
            "1) When calculating percentages with molecule counts: use integer division with / instead of floating-point division with * 100.0 / to maintain proper arithmetic behavior.\n2) When counting molecule_id values that are already unique within their contexts: do not use DISTINCT in count operations.\n3) When joining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id to maintain the correct relationship between tables.\n4) When the query returns a single scalar result: omit column aliases like percentage.\n5) When filtering for hydrogen elements: use the exact literal 'h' for element comparison.\n6) When filtering for carcinogenic compounds: use the exact literal '+' for label comparison.\n7) When counting molecules containing carcinogenic hydrogen compounds: count T2.molecule_id values where T1.element = 'h' AND T2.label = '+'.\n8) When calculating the base denominator: count all T2.molecule_id values from the joined tables.\nOutput columns (ordered): (unnamed scalar result)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(DISTINCT CASE WHEN m.label = '+' AND a.element = 'h' THEN m.molecule_id END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM molecule m\nLEFT JOIN atom a ON m.molecule_id = a.molecule_id;",
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100.0) / \n    COUNT(DISTINCT T2.molecule_id) AS percentage\nFROM \n    atom T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id;",
            "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(*) \nFROM atom T1 \nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) / COUNT(T2.molecule_id) * 100\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id;"
        ]
    },
    "182": {
        "question": "How many male customers who were born between 1974 and 1976 have made a payment on their home in excess of $4000?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T2.account_id = T4.account_id INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976' AND T3.gender = 'M' AND T1.amount > 4000 AND T1.k_symbol = 'SIPO'",
        "amends": [
            "Do count `account_id` instead of `DISTINCT client_id` for the aggregate function. Do use `INNER JOIN` consistently instead of mixing `JOIN` without explicit type. Do correct the join order by connecting `trans` to `account` first instead of starting from `client`. Do fix the join condition between `disp` and `account` to use `T2.account_id = T4.account_id` instead of potentially incorrect column references. Do maintain the same filter conditions for `gender`, `birth_date`, `amount`, and `k_symbol` but ensure proper table aliasing. The amended query now correctly counts accounts rather than distinct clients and maintains proper join relationships to match the RIGHT_SQL's behavior.",
            "Do count `T1.account_id` without `DISTINCT` instead of counting distinct `T4.account_id`. Do use table aliases `T2` for account and `T3` for client instead of `T4` for account and `T2` for client. Do filter by `STRFTIME('%Y', T3.birth_date)` between '1974' and '1976' instead of `T2.birth_date` between date literals. Do filter by `T1.k_symbol = 'SIPO'` instead of `'HOME PAYMENT'`. The amended query now correctly counts transactions with the specified criteria."
        ],
        "rules": [
            "1) When counting entities in the context of payments: count using the exact token \"account_id\" instead of client identifiers. 2) When combining tables for this question: use inner joins consistently throughout all table connections. 3) When establishing table relationships: connect the \"trans\" table to \"account\" first as the primary relationship foundation. 4) When joining the \"disp\" and \"account\" tables: use the exact equality condition T2.account_id = T4.account_id. 5) When filtering for male customers: use the exact condition T1.gender = 'M' with the literal 'M'. 6) When filtering for birth years between 1974 and 1976: use the exact range '1974' to '1976' inclusive with year extraction from birth_date. 7) When filtering for payment amounts: use the exact condition T3.amount > 4000. 8) When filtering for payment type: use the exact condition T3.k_symbol = 'SIPO' with the literal 'SIPO'. Output columns (ordered): count of account_id",
            "1) When counting transactions that meet specific criteria: count occurrences of T1.account_id without requiring distinct values. 2) When filtering by gender: use T3.gender = 'M' to identify male customers. 3) When filtering by birth year range: use STRFTIME('%Y', T3.birth_date) between '1974' and '1976' to identify customers born between 1974 and 1976. 4) When filtering by transaction type: use T1.k_symbol = 'SIPO' instead of 'HOME PAYMENT' to identify home payment transactions. 5) When filtering by transaction amount: use T1.amount > 4000 to identify payments exceeding $4000. 6) When combining tables for customer transaction analysis: link rows where T1.account_id = T2.account_id and T2.client_id = T3.client_id to connect transactions to accounts to clients. 7) Output columns (ordered): COUNT(T1.account_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS male_customers_count\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN trans t ON a.account_id = t.account_id\nWHERE c.gender = 'M'\n  AND strftime('%Y', c.birth_date) BETWEEN '1974' AND '1976'\n  AND t.k_symbol = 'SIPO'\n  AND t.amount > 4000;",
            "SELECT COUNT(DISTINCT T4.account_id)\nFROM trans T1\nINNER JOIN account T4 ON T1.account_id = T4.account_id\nINNER JOIN disp T3 ON T4.account_id = T3.account_id\nINNER JOIN client T2 ON T3.client_id = T2.client_id\nWHERE T2.gender = 'M'\nAND T2.birth_date BETWEEN '1974-01-01' AND '1976-12-31'\nAND T1.amount > 4000\nAND T1.k_symbol = 'HOME PAYMENT'",
            "SELECT COUNT(T1.account_id)\nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T4 ON T2.account_id = T4.account_id\nINNER JOIN client T3 ON T4.client_id = T3.client_id\nWHERE T3.gender = 'M'\nAND STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976'\nAND T1.amount > 4000\nAND T1.k_symbol = 'SIPO'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id)\nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T4 ON T2.account_id = T4.account_id\nINNER JOIN client T3 ON T4.client_id = T3.client_id\nWHERE T3.gender = 'M'\nAND STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976'\nAND T1.amount > 4000\nAND T1.k_symbol = 'SIPO'"
        ]
    },
    "201": {
        "question": "What is the percentage of carbon in double-bond molecules?",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
        "amends": [
            "Do use `CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id)` instead of `SUM(CASE WHEN a.element = 'c' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)` for proper percentage calculation with distinct atom counting. Do join only `atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id` instead of joining both molecule and bond tables with unnecessary intermediate table. Do remove the redundant `molecule` table join instead of including it. Do use `WHERE T2.bond_type = '='` instead of the same filter but with unnecessary table joins. The amended query now correctly calculates the percentage of carbon atoms in molecules with double bonds by using distinct counts and proper casting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating percentage of carbon atoms in double-bond molecules: compute (number of distinct carbon atoms in double-bond molecules) divided by (total distinct atoms in double-bond molecules) multiplied by 100, using CAST to REAL for proper division.\n2) When joining atom and bond tables for double-bond molecules: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match).\n3) When filtering for double bonds: include only rows where T2.bond_type = '=' exactly.\n4) When counting carbon atoms: count distinct T1.atom_id where T1.element = 'c' exactly.\n5) When counting total atoms: count distinct T1.atom_id regardless of element.\n6) When the question involves percentage calculation: ensure proper casting to REAL type to avoid integer division.\n7) When the schema includes unnecessary intermediate tables: do not include the molecule table as it provides redundant information already available through direct atom-bond linkage.\nOutput columns (ordered): percentage_carbon"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN a.element = 'c' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS percentage_carbon\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = '=';",
            "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) AS percentage\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT \n    CAST(COUNT(DISTINCT CASE WHEN a.element = 'c' THEN a.atom_id END) AS REAL) / \n    CAST(COUNT(DISTINCT a.atom_id) AS REAL) * 100 AS percentage_carbon\nFROM \n    atom a\nINNER JOIN \n    bond b ON a.molecule_id = b.molecule_id\nWHERE \n    b.bond_type = '='"
        ]
    },
    "1434": {
        "question": "What are the zip codes that have post office boxes in the country of the country of San Juan Municipio whose state is Puerto Rico?",
        "db_id": "student_club",
        "ground_truth": "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico'",
        "amends": [],
        "rules": [
            "zip codes that have post office boxes refers to type = 'PO Box'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico';"
        ],
        "rule_sql": []
    },
    "126": {
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "db_id": "financial",
        "ground_truth": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "amends": [],
        "rules": [
            "A2 contains the information about district."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH decin_accounts AS (\n    SELECT COUNT(*) AS decin_count\n    FROM account\n    JOIN district ON account.district_id = district.district_id\n    WHERE district.A2 = 'Decin'\n    AND strftime('%Y', account.date) = '1993'\n),\ntotal_1993_accounts AS (\n    SELECT COUNT(*) AS total_count\n    FROM account\n    WHERE strftime('%Y', account.date) = '1993'\n)\nSELECT (decin_count * 100.0 / total_count) AS percentage\nFROM decin_accounts, total_1993_accounts;"
        ],
        "rule_sql": []
    },
    "336": {
        "question": "in molecules with triple bonds, how many of them are not carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND T1.label = '-'",
        "amends": [],
        "rules": [
            "triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT b.molecule_id) \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.bond_type = '#' AND m.label = '-';"
        ],
        "rule_sql": []
    },
    "1123": {
        "question": "What is the name of players with the highest potential?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.potential DESC LIMIT 1",
        "amends": [],
        "rules": [
            "highest potential refers to MAX(potential)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes);"
        ],
        "rule_sql": []
    },
    "1001": {
        "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `full_name`. Do use table aliases `T1`, `T2`, and `T3` instead of single letters. Do remove the explicit `JOIN` with `circuits` table and instead use a subquery `circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')` in the `WHERE` clause instead of direct table join. Do change the `ORDER BY` to use a complex time conversion formula `CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000` instead of simple `q3 ASC` to properly handle time format conversion. Do remove the `q.position = 1` filter instead of keeping it. The amended query now correctly handles time-based ordering and subquery filtering to match the intended behavior.",
            "Do use `T2.forename` and `T2.surname` from the drivers table instead of `T1.forename` and `T1.surname` from the drivers table. Do join `qualifying AS T1` first instead of starting with `drivers T1`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do join `drivers AS T2` on `T1.driverId = T2.driverId` instead of joining `qualifying T2` on `T1.driverId = T2.driverId`. Do join `races T3` on `T1.raceid = T3.raceid` instead of on `T2.raceId = T3.raceId`. Do add `q3 IS NOT NULL` filter instead of omitting it. Do remove `T3.round = 3` condition instead of keeping it. Do reference `q3` directly instead of `T2.q3` in the ORDER BY expression. The amended query now correctly identifies the fastest qualifying driver at Marina Bay Street Circuit in 2008 by properly handling table joins and ensuring valid qualifying times are considered.",
            "Do remove the redundant `T3.round = 3` filter instead of keeping it, as the circuit condition already uniquely identifies the specific race. Do reference `q3` directly without table alias instead of using `T1.q3` since there's no ambiguity. Do maintain the same `SELECT` list, `FROM` sources with `INNER JOIN` conditions, `WHERE` filters for `year` and circuit subquery, `ORDER BY` time conversion logic, and `LIMIT 1` to find the fastest qualifying driver at Marina Bay in 2008."
        ],
        "rules": [
            "1) When the question asks for a racer's full name: output individual columns T1.forename and T1.surname separately instead of concatenating them.\n2) When filtering for races at Marina Bay Street Circuit: use a subquery condition T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit') instead of joining the circuits table directly.\n3) When filtering for the year 2008: include the condition T3.year = 2008.\n4) When handling qualifying time ordering for q3 column: convert the time format using CAST(SUBSTR(T2.q3, 1, INSTR(T2.q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.q3, INSTR(T2.q3, ':') + 1, INSTR(T2.q3, '.') - INSTR(T2.q3, ':') - 1) AS REAL) + CAST(SUBSTR(T2.q3, INSTR(T2.q3, '.') + 1) AS REAL) / 1000 for proper time-based ordering.\n5) When ranking by qualifying time: order by the converted time value in ascending order to find the fastest time.\n6) When seeking the top ranked racer: take only the first row after ordering by the converted qualifying time.\n7) When combining tables for driver qualifying results: link T1 (drivers) and T2 (qualifying) where T1.driverId = T2.driverId, and link T2 and T3 (races) where T2.raceId = T3.raceId, keeping only matching pairs.\n8) Output columns (ordered): T1.forename, T1.surname",
            "1) When the question asks for the full name of a racer: use T2.forename and T2.surname from the drivers table.\n2) When joining qualifying and drivers tables: use INNER JOIN with qualifying AS T1 and drivers AS T2, linking rows where T1.driverId = T2.driverId.\n3) When joining qualifying and races tables: use INNER JOIN with races T3, linking rows where T1.raceid = T3.raceid.\n4) When filtering for races at Marina Bay Street Circuit in 2008: include conditions T3.year = 2008 and T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit').\n5) When handling qualifying times: ensure q3 IS NOT NULL to filter out invalid qualifying times.\n6) When ranking drivers by qualifying performance: order rows by converting q3 time format to numerical seconds value (minutes*60 + seconds + milliseconds/1000) in ascending order.\n7) When the question asks for the 1st ranked racer: take the first row after ordering by qualifying time.\n8) When the question mentions qualifying race position: do not use T3.round = 3 condition as it is not applicable.\nOutput columns (ordered): T2.forename, T2.surname",
            "1) When the question asks for a racer's full name from qualifying results: select T2.forename and T2.surname from the drivers table.\n2) When combining qualifying and drivers tables: link rows where T1.driverId = T2.driverId using an inner match.\n3) When combining qualifying and races tables: link rows where T1.raceId = T3.raceId using an inner match.\n4) When filtering for a specific year: include only rows where T3.year = 2008.\n5) When filtering for Marina Bay Street Circuit: use a subquery to find circuitId from circuits where name = 'Marina Bay Street Circuit' and filter T3.circuitId to match this value.\n6) When ranking qualifying times in q3 column: convert the time format from mm:ss.sss to total seconds by extracting minutes, seconds, and milliseconds components, then order by ascending time to find the fastest qualifier.\n7) When finding the top-ranked qualifier: use LIMIT 1 to return only the single fastest driver.\n8) When the question specifies \"3rd qualifying race\" but the circuit condition uniquely identifies the race: do not apply additional round filtering to avoid redundancy.\n9) Output columns (ordered): T2.forename, T2.surname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nJOIN races r ON q.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Marina Bay Street Circuit'\n  AND r.year = 2008\n  AND q.position = 1\n  AND q.q3 IS NOT NULL\nORDER BY q.q3 ASC\nLIMIT 1;",
            "SELECT T1.forename, T1.surname\nFROM drivers T1\nJOIN qualifying T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nWHERE T3.year = 2008\nAND T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')\nAND T3.round = 3\nORDER BY CAST(SUBSTR(T2.q3, 1, INSTR(T2.q3, ':') - 1) AS INTEGER) * 60 + \n         CAST(SUBSTR(T2.q3, INSTR(T2.q3, ':') + 1, INSTR(T2.q3, '.') - INSTR(T2.q3, ':') - 1) AS REAL) + \n         CAST(SUBSTR(T2.q3, INSTR(T2.q3, '.') + 1) AS REAL) / 1000 ASC\nLIMIT 1;",
            "SELECT T2.forename, T2.surname\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T1.raceId = T3.raceId\nWHERE T3.year = 2008\nAND T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')\nAND T3.round = 3\nAND T1.q3 IS NOT NULL\nORDER BY CAST(SUBSTR(T1.q3, 1, INSTR(T1.q3, ':') - 1) AS INTEGER) * 60 + \n         CAST(SUBSTR(T1.q3, INSTR(T1.q3, ':') + 1, INSTR(T1.q3, '.') - INSTR(T1.q3, ':') - 1) AS REAL) + \n         CAST(SUBSTR(T1.q3, INSTR(T1.q3, '.') + 1) AS REAL) / 1000 ASC\nLIMIT 1;",
            "SELECT T2.forename, T2.surname\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races T3 ON T1.raceId = T3.raceId\nWHERE T3.year = 2008\nAND T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')\nAND T1.q3 IS NOT NULL\nORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.forename, T2.surname\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T1.raceId = T3.raceId\nWHERE T3.year = 2008\nAND T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')\nAND T1.q3 IS NOT NULL\nORDER BY (CAST(SUBSTR(T1.q3, 1, INSTR(T1.q3, ':') - 1) AS INTEGER) * 60 + \n          CAST(SUBSTR(T1.q3, INSTR(T1.q3, ':') + 1, INSTR(T1.q3, '.') - INSTR(T1.q3, ':') - 1) AS REAL) + \n          CAST(SUBSTR(T1.q3, INSTR(T1.q3, '.') + 1) AS REAL) / 1000) ASC\nLIMIT 1;"
        ]
    },
    "825": {
        "question": "Identify the gender of the superhero who has the ability of Phoenix Force.",
        "db_id": "superhero",
        "ground_truth": "SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Phoenix Force'",
        "amends": [],
        "rules": [
            "ability of Phoenix Force refers to power_name = 'Phoenix Force';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT g.gender\nFROM gender g\nJOIN superhero s ON g.id = s.gender_id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Phoenix Force';"
        ],
        "rule_sql": []
    },
    "340": {
        "error": "something went wrong, tool did not call.",
        "question": "Which are the cards that have incredibly powerful foils.",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
        "amends": [
            "Do select only the `id` column instead of selecting all columns with `*`. Do keep the same `WHERE` clause with both `cardKingdomFoilId IS NOT NULL` and `cardKingdomId IS NOT NULL` conditions instead of changing them. The amended query now correctly returns only the id values from matching rows instead of all columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cards with incredibly powerful foils: select only the id column from the cards table. 2) When filtering for cards that have both foil and non-foil identifiers: include rows where both cardKingdomFoilId and cardKingdomId are not null. 3) Output columns (ordered): id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
            "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;"
        ]
    },
    "1418": {
        "question": "Mention the category of events which were held at MU 215.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "amends": [
            "Do select `T2.category` instead of `type` and remove `DISTINCT` instead of keeping it. Do add `INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event` instead of omitting the join to the budget table. Do keep the `WHERE T1.location = 'MU 215'` filter but apply it to the joined table structure instead of the original single table. The amended query now correctly retrieves category information from the budget table through proper table joining instead of attempting to get type directly from the event table."
        ],
        "rules": [
            "1) When the question asks for category information about events: retrieve the exact column T2.category instead of T1.type from the event table.\n2) When joining the event table (T1) with the budget table (T2): link rows where T1.event_id equals T2.link_to_event and keep only matching pairs (inner match).\n3) When filtering for events at location 'MU 215': apply the condition T1.location = 'MU 215' to the joined table structure.\n4) When retrieving category values: do not use DISTINCT to remove duplicate values.\nOutput columns (ordered): T2.category"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT type FROM event WHERE location = 'MU 215';",
            "SELECT T2.category \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.location = 'MU 215'"
        ],
        "rule_sql": [
            "SELECT T2.category \nFROM event T1 \nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event \nWHERE T1.location = 'MU 215'"
        ]
    },
    "268": {
        "question": "What are the elements for bond id TR001_10_11?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
        "amends": [
            "Do select only `T2.element` instead of `a1.element` and `a2.element`. Do use `INNER JOIN` with `atom AS T2` on `T1.atom_id = T2.atom_id` instead of joining two atom tables on `c.atom_id = a1.atom_id` and `c.atom_id2 = a2.atom_id`. Do remove the second join to `atom a2` instead of keeping it. Do use table aliases `T1` for connected and `T2` for atom instead of `c`, `a1`, and `a2`. The amended query now correctly retrieves only the element from the first atom in the connection instead of both connected atoms, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for elements for a specific bond id: filter rows where T1.bond_id equals the exact literal 'TR001_10_11'. 2) When combining the connected table (T1) with the atom table (T2): link rows where T1.atom_id equals T2.atom_id and keep only matching pairs. 3) When selecting output columns: include only T2.element from the joined atom table. 4) When using table aliases: refer to the connected table as T1 and the atom table as T2. 5) Output columns (ordered): T2.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_10_11';",
            "SELECT T2.element \nFROM connected AS T1 \nINNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id \nWHERE T1.bond_id = 'TR001_10_11'"
        ],
        "rule_sql": [
            "SELECT T2.element FROM connected T1 JOIN atom T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'"
        ]
    },
    "460": {
        "question": "Which artist designed the card whose promotional name is \"Battra, Dark Destroyer\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer'",
        "amends": [],
        "rules": [
            "promotional name is \"Battra, Dark Destroyer\" refers to flavorName = 'Battra, Dark Destroyer'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer';"
        ],
        "rule_sql": []
    },
    "559": {
        "question": "Indicate the creation date of the maximum number of votes.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CreationDate FROM votes GROUP BY CreationDate ORDER BY COUNT(Id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the creation date of the maximum number of votes refers to CreationDate where Max(Count(Id))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT CreationDate\nFROM votes\nGROUP BY CreationDate\nORDER BY COUNT(Id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1442": {
        "question": "What is the percentage of the events that went over budget?",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(budget_id) FROM budget",
        "amends": [],
        "rules": [
            "went over budget refers to remaining < 0; percentage = DIVIDE(SUM(remaining < 0), COUNT(event_id)) * 100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN b.spent > b.amount THEN 1 END) * 100.0 / COUNT(*)) AS percentage_over_budget\nFROM \n    event e\nJOIN \n    budget b ON e.event_id = b.link_to_event;"
        ],
        "rule_sql": []
    },
    "9": {
        "question": "Among the schools with the average score in Math over 560 in the SAT test, how many schools are directly charter-funded?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(T2.`School Code`) FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath > 560 AND T2.`Charter Funding Type` = 'Directly funded'",
        "amends": [
            "Do join `frpm` as `T2` instead of `schools`, and use `INNER JOIN` instead of `JOIN` with the join condition `T1.cds = T2.CDSCode` instead of `satscores.cds = schools.CDSCode`. Do filter on `T2.`Charter Funding Type` = 'Directly funded'` instead of `schools.FundingType = 'Charter'`. Do count `T2.`School Code`` instead of `COUNT(*)` and remove the alias `NumberOfCharterFundedSchools` instead of keeping it. The amended query now correctly identifies directly funded charter schools through the appropriate table and filtering criteria."
        ],
        "rules": [
            "1) When the question asks for schools with average Math SAT score over 560: filter rows where T1.AvgScrMath > 560.\n2) When combining SAT scores with funding information: link T1 and T2 where T1.cds = T2.CDSCode using an inner match.\n3) When identifying directly charter-funded schools: filter rows where T2.\"Charter Funding Type\" = 'Directly funded'.\n4) When counting schools: count the number of unique T2.\"School Code\" values.\nOutput columns (ordered): count of T2.\"School Code\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NumberOfCharterFundedSchools\nFROM satscores\nJOIN schools ON satscores.cds = schools.CDSCode\nWHERE satscores.AvgScrMath > 560\nAND schools.FundingType = 'Charter';",
            "SELECT COUNT(T2.\"School Code\") \nFROM satscores AS T1\nINNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath > 560 \nAND T2.\"Charter Funding Type\" = 'Directly funded'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.\"School Code\") \nFROM satscores T1\nINNER JOIN frpm T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath > 560 \nAND T2.\"Charter Funding Type\" = 'Directly funded'"
        ]
    },
    "583": {
        "question": "What is the total score of the posts edited by Yevgeny and include the user's website URL.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT SUM(T1.Score), T2.WebsiteUrl FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Yevgeny' GROUP BY T2.WebsiteUrl",
        "amends": [],
        "rules": [
            "\"Yevgeny\" is the DisplayName; edited refers to LastEditorUserId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(p.Score) AS TotalScore, u.WebsiteUrl\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE u.DisplayName = 'Yevgeny';\n"
        ],
        "rule_sql": []
    },
    "1272": {
        "question": "Which patient is the first patient with an abnormal anti-SSA to come to the hospital? Please give his or her ID.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` IS NOT NULL AND T2.SSA NOT IN ('negative', '0') ORDER BY T1.`First Date` ASC LIMIT 1",
        "amends": [],
        "rules": [
            "first patient refers to ID with MIN(`First Date`); abnormal anti-SSA refers to SSA NOT IN('negative', '0');"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.SSA NOT IN ('negative', '0')\nORDER BY p.`First Date` ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1468": {
        "question": "Where is the hometown of Garrett Gerke?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.city FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'",
        "amends": [],
        "rules": [
            "hometown refers to city"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT z.city AS hometown\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Garrett' AND m.last_name = 'Gerke';"
        ],
        "rule_sql": []
    },
    "778": {
        "question": "Provide superheroes' names who have the adaptation power.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Adaptation'",
        "amends": [],
        "rules": [
            "adaptation power refers to power_name = 'Adaptation';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Adaptation';"
        ],
        "rule_sql": []
    },
    "852": {
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "amends": [
            "Do count `T3.raceId` instead of `COUNT(*)` to avoid counting nulls. Do use `INNER JOIN` with explicit table aliases `circuits AS T1` and `races AS T3` instead of simple `JOIN` without aliases. Do specify the join condition as `T3.circuitID = T1.circuitId` instead of `races.circuitId = circuits.circuitId` for clarity. Do move the `circuits.country` filter to reference `T1.country` instead and change the exclusion list from continents to specific countries, replacing `NOT IN ('Asia', 'Europe')` with `NOT IN ('Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK')` to exclude specific Asian and European countries rather than entire continents. Do keep the `races.year = 2010` filter but reference it as `T3.year = 2010` instead. The amended query now correctly counts races from 2010 that occurred in circuits outside specific Asian and European countries rather than excluding entire continents, matching the intended behavior."
        ],
        "rules": [
            "1) When counting races: count using the canonical key T3.raceId instead of all rows to avoid counting nulls.\n2) When combining circuits and races tables: link rows where T3.circuitID = T1.circuitId using inner match and keep only matching pairs.\n3) When filtering by year 2010: include only rows where T3.year = 2010.\n4) When excluding circuits in Asia and Europe: exclude circuits where T1.country is in the specific list ('Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK').\n5) Output columns (ordered): race_count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS race_count\nFROM races\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE races.year = 2010\nAND circuits.country NOT IN ('Asia', 'Europe');",
            "SELECT COUNT(T3.raceId) \nFROM circuits AS T1 \nINNER JOIN races AS T3 ON T3.circuitId = T1.circuitId \nWHERE T3.year = 2010 \nAND T1.country NOT IN ('Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK')"
        ],
        "rule_sql": [
            "SELECT COUNT(T3.raceId) AS race_count\nFROM circuits T1\nINNER JOIN races T3 ON T3.circuitId = T1.circuitId\nWHERE T3.year = 2010\nAND T1.country NOT IN ('Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK')"
        ]
    },
    "1150": {
        "question": "What is the percentage of female patient were born after 1930?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'",
        "amends": [
            "Do use `SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN year(Birthday) > 1930 AND SEX = 'F' THEN 1 END)` for counting eligible records. Do move the `SEX = 'F'` filter to the `WHERE` clause instead of including it in both CASE expressions. Do use `CAST(... AS REAL)` for the percentage calculation instead of implicit casting with `100.0`. Do use `COUNT(*)` in the denominator instead of `COUNT(CASE WHEN SEX = 'F' THEN 1 END)` since the WHERE clause already filters for female patients. Do use SQLite's `STRFTIME('%Y', Birthday)` function instead of `year(Birthday)` for year extraction. The amended query now correctly calculates the percentage of female patients born after 1930 among all female patients.",
            "Do place the multiplication by 100 before the division instead of after it, changing `* 100 / COUNT(*)` instead of `/ COUNT(*) * 100`, to correctly calculate the percentage by first scaling the sum before dividing by the total count. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a percentage of female patients born after 1930: filter the Patient table to include only rows where SEX equals 'F' exactly. 2) When counting patients born after 1930: extract the year from Birthday using STRFTIME('%Y', Birthday) and compare if greater than '1930'. 3) When computing a percentage ratio: calculate (number of patients satisfying the condition) divided by (total number of patients in the filtered set) and multiply by 100, casting the result to REAL type. 4) When counting eligible records: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT with CASE expressions. 5) Output columns (ordered): percentage",
            "1) When calculating a percentage: multiply the numerator by 100 before dividing by the denominator to correctly scale the result. 2) When the question asks for percentage of female patients born after 1930: compute (number of female patients born after 1930) multiplied by 100 divided by (total number of female patients). 3) When handling date comparisons for birth year: compare the year portion of the Birthday field against the literal value '1930' using greater than comparison. 4) When filtering for female patients: use the exact literal 'F' for the SEX field. 5) Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN year(Birthday) > 1930 AND SEX = 'F' THEN 1 END) * 100.0 / \n    COUNT(CASE WHEN SEX = 'F' THEN 1 END)) AS percentage\nFROM \n    Patient;",
            "SELECT \n    CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100 AS percentage\nFROM Patient\nWHERE SEX = 'F';",
            "SELECT \n    CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(*) \nFROM Patient \nWHERE SEX = 'F';"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS REAL) AS percentage\nFROM \n    Patient\nWHERE \n    SEX = 'F';"
        ]
    },
    "1262": {
        "question": "How many patients with a normal level of complement 3 have a P pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C3 > 35 AND T1.`ANA Pattern` = 'P'",
        "amends": [],
        "rules": [
            "normal level of complement 3 refers to C3 > 35; have a P pattern observed in the sheet of ANA examination refers to ANA Pattern = 'P'; Should compute the number of distinct ones"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.ID) AS PatientCount\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE e.\"ANA Pattern\" = 'P' AND l.C3 IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1384": {
        "question": "How many income generated by Grant Gilmour?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'",
        "amends": [],
        "rules": [
            "income generated refers to income.amount"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) AS total_income FROM income WHERE link_to_member = (SELECT member_id FROM member WHERE first_name = 'Grant' AND last_name = 'Gilmour');"
        ],
        "rule_sql": []
    },
    "80": {
        "question": "What is the school type of the school with the highest latitude? Indicate the name of the school as well as the latitude coordinates.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.`School Type`, T1.`School Name`, T2.Latitude FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.Latitude DESC LIMIT 1",
        "amends": [
            "Do select `T1.School Type`, `T1.School Name`, and `T2.Latitude` instead of `s.School`, `s.Latitude`, and `f.School Type`. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do reference `T1.CDSCode = T2.CDSCode` instead of `s.CDSCode = f.CDSCode`. Do order by `T2.Latitude DESC` instead of `s.Latitude DESC`. The amended query now correctly retrieves the school with the highest latitude while maintaining proper table aliases and join conditions to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the school with the highest latitude: rank rows by T2.Latitude in descending order and keep the first 1 row.\n2) When combining T1 and T2 for shared entities: link rows where T1.CDSCode = T2.CDSCode exactly; keep only matching pairs (inner match).\n3) When the question asks for school type and school name: include T1.\"School Type\" and T1.\"School Name\" in the output.\n4) When the question asks for latitude coordinates: include T2.Latitude in the output.\n5) Output columns (ordered): T1.\"School Type\", T1.\"School Name\", T2.Latitude"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.School, s.Latitude, f.`School Type`\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nORDER BY s.Latitude DESC\nLIMIT 1;",
            "SELECT T1.\"School Type\", T1.\"School Name\", T2.Latitude\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.Latitude DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.\"School Type\", T1.\"School Name\", T2.Latitude\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.Latitude DESC\nLIMIT 1;"
        ]
    },
    "699": {
        "question": "When did the user known as 'IrishStat' create his or her account?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat'",
        "amends": [],
        "rules": [
            "DisplayName = 'IrishStat'; when create his or her account refers to CreationDate;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat';"
        ],
        "rule_sql": []
    },
    "489": {
        "question": "List the keyrune code for the set whose code is 'PKHC'.",
        "db_id": "card_games",
        "ground_truth": "SELECT keyruneCode FROM sets WHERE code = 'PKHC'",
        "amends": [],
        "rules": [
            "keyrune code refers to keyruneCode"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT keyruneCode FROM sets WHERE code = 'PKHC';"
        ],
        "rule_sql": []
    },
    "1059": {
        "question": "Please list player names which are higher than 180.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_name FROM Player WHERE height > 180",
        "amends": [],
        "rules": [
            "height>180;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name FROM Player WHERE height > 180;"
        ],
        "rule_sql": []
    },
    "1268": {
        "question": "For the patients with an abnormal anti-SM, please list the IDs of the three youngest ones.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM NOT IN ('negative','0') ORDER BY T1.Birthday DESC LIMIT 3",
        "amends": [],
        "rules": [
            "abnormal anti-SM refers to SM NOT IN ('negative', '0'); youngest refers to MAX(Birthday);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.SM NOT IN ('negative', '0')\nORDER BY p.Birthday DESC\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "507": {
        "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
        "amends": [
            "Do use `sets` table instead of `set_translations` and `cards` tables, and do change the FROM clause to reference only `sets` instead of joining multiple tables. Do calculate percentage from `COUNT(id)` instead of `COUNT(*)` to count specific identifiers. Do add explicit `CAST` to `REAL` instead of implicit decimal conversion for accurate division. Do move the language filter to a subquery with `WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)')` instead of joining directly on set_translations. Do reference `isOnlineOnly` directly from the sets table instead of through a joined cards table. The amended query now correctly calculates the percentage of online-only sets for Brazilian Portuguese translations by querying the appropriate source table and using proper counting and casting semantics."
        ],
        "rules": [
            "1) When the question asks for cards with Brazil Portuguese translation: filter sets where the set code is in the set codes from set_translations where language equals 'Portuguese (Brazil)' exactly.\n2) When counting sets: use the canonical key sets.id for counting instead of counting all rows.\n3) When calculating percentage of online-only sets: compute (number of sets where isOnlineOnly equals 1) divided by (total number of sets) multiplied by 100.0, using exact casting to REAL for accurate division.\n4) When referencing online-only status: use the exact column sets.isOnlineOnly directly from the sets table.\n5) Output columns (ordered): percentage_online_only"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN c.isOnlineOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_online_only\nFROM \n    set_translations st\nJOIN \n    cards c ON st.setCode = c.setCode\nWHERE \n    st.language = 'Portuguese (Brazil)';",
            "SELECT \n    (CAST(COUNT(CASE WHEN isOnlineOnly = 1 THEN id END) AS REAL) / CAST(COUNT(id) AS REAL)) * 100 AS percentage_online_only\nFROM \n    sets\nWHERE \n    code IN (SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)');"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN s.isOnlineOnly = 1 THEN s.id END) * 100.0 / COUNT(s.id)) AS percentage_online_only\nFROM \n    sets s\nWHERE \n    s.code IN (\n        SELECT DISTINCT st.setCode \n        FROM set_translations st \n        WHERE st.language = 'Portuguese (Brazil)'\n    )"
        ]
    },
    "824": {
        "question": "Identify superheroes who can control wind and list their names in alphabetical order.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Wind Control' ORDER BY T1.superhero_name",
        "amends": [],
        "rules": [
            "superheroes refers to superhero_name; can control wind refers to power_name = 'Wind Control';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Wind Control'\nORDER BY s.superhero_name ASC;"
        ],
        "rule_sql": []
    },
    "498": {
        "question": "What's the French name of the set of cards with \"Tendo Ice Bridge\" is in?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Tendo Ice Bridge' AND T2.language = 'French' AND T2.translation IS NOT NULL",
        "amends": [],
        "rules": [
            "French refers to language = 'French'; \"Tendo Ice Bridge\" is a translated name of a card; translated name refers to translation"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT st.translation AS french_set_name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode\nWHERE c.name = 'Tendo Ice Bridge' AND st.language = 'French';"
        ],
        "rule_sql": []
    },
    "953": {
        "question": "How many French constructors have a lap number of over 50?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "amends": [],
        "rules": [
            "lap numbers of over 50 refers to laps > 50;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.constructorId) \nFROM constructors c\nJOIN results r ON c.constructorId = r.constructorId\nWHERE c.nationality = 'French' AND r.laps > 50;"
        ],
        "rule_sql": []
    },
    "481": {
        "question": "Please list all the foreign languages in which the card \"Ancestor's Chosen\" has a flavor text.",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.flavorText IS NOT NULL",
        "amends": [],
        "rules": [
            "\"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'; has a flavor text refers to flavorText is not null"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT fd.language\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.name = 'Ancestor''s Chosen' AND fd.flavorText IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1437": {
        "question": "Which members who were approved from 1/10/2019 to 11/19/2019? Please identify the member who attended the event and the link to their event.",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T1.link_to_member, T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true'",
        "amends": [
            "Do select only `T1.link_to_member` and `T3.link_to_event` instead of multiple columns including `m.member_id`, `m.first_name`, `m.last_name`, `e.event_id`, `e.event_name`, and `e.event_date`. Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do reference tables with aliases `T1`, `T2`, and `T3` instead of `ex`, `m`, `a`, and `e`. Do use `INNER JOIN` consistently instead of mixing `JOIN` syntax. Do join `attendance` directly to `member` via `T2.member_id = T3.link_to_member` instead of through the expense table. Do remove the explicit `event` table join and its columns since they're not needed in the result set. Do apply `date(SUBSTR(T1.expense_date, 1, 10))` to handle date formatting instead of using `expense_date` directly. Do keep the `approved = 'true'` filter but move it after the date condition instead of before it. Do remove the unnecessary table references and columns that were not required for the query logic. The amended query now correctly returns distinct member-event pairs for approved expenses within the specified date range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for members approved within a date range: filter rows where T1.approved equals 'true' and date(SUBSTR(T1.expense_date, 1, 10)) falls between '2019-01-10' and '2019-11-19' inclusive.\n2) When combining expense, member, and attendance tables: link T1 to T2 where T1.link_to_member equals T2.member_id, then link T2 to T3 where T2.member_id equals T3.link_to_member, keeping only matching pairs (inner match).\n3) When the question asks for distinct member-event pairs: use DISTINCT to eliminate duplicate combinations of T1.link_to_member and T3.link_to_event.\n4) When selecting output columns: include only T1.link_to_member and T3.link_to_event instead of additional member or event details.\n5) When handling date comparisons: apply date formatting using date(SUBSTR(T1.expense_date, 1, 10)) instead of using the raw expense_date column directly.\nOutput columns (ordered): T1.link_to_member, T3.link_to_event"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.member_id, m.first_name, m.last_name, e.event_id, e.event_name, e.event_date\nFROM expense ex\nJOIN member m ON ex.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE ex.approved = 'true'\nAND ex.expense_date BETWEEN '2019-01-10' AND '2019-11-19'",
            "SELECT DISTINCT T1.link_to_member, T3.link_to_event\nFROM expense T1\nINNER JOIN attendance T3 ON T1.link_to_member = T3.link_to_member\nWHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19'\nAND T1.approved = 'true'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.link_to_member, T3.link_to_event\nFROM expense T1\nINNER JOIN member T2 ON T1.link_to_member = T2.member_id\nINNER JOIN attendance T3 ON T2.member_id = T3.link_to_member\nWHERE T1.approved = 'true'\nAND date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19';"
        ]
    },
    "700": {
        "question": "Identify the number of posts that offer a bounty amount over 30.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM votes WHERE BountyAmount >= 30",
        "amends": [],
        "rules": [
            "bounty amount over 30 refers to BountyAmount > = 30;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NumberOfPostsWithBountyOver30 FROM votes WHERE BountyAmount >= 30;"
        ],
        "rule_sql": []
    },
    "615": {
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "amends": [],
        "rules": [
            "\"Organizer\" is the Name of badge; teenager refers to Age BETWEEN 13 AND 18; percentage = Divide (Count(UserId where Age BETWEEN 13 AND 18), Count(UserId)) *100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.Age BETWEEN 13 AND 19 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_teenagers\nFROM \n    badges b\nJOIN \n    users u ON b.UserId = u.Id\nWHERE \n    b.Name = 'Organizer';"
        ],
        "rule_sql": []
    },
    "395": {
        "question": "How many cards designed by UDON and available in mtgo print type has a starting maximum hand size of -1?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE hAND = '-1' AND artist = 'UDON' AND Availability = 'mtgo' ",
        "amends": [],
        "rules": [
            "UDON refer to artist; availabe in mtgo refers to availability = 'mtgo'; starting maximum hand size of -1 refers to hand = -1"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'UDON' \nAND availability LIKE '%mtgo%' \nAND hand = '-1';"
        ],
        "rule_sql": []
    },
    "766": {
        "question": "What is the hero's full name with the highest attribute in strength?",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of full table names throughout the query. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do capitalize the string literal `'Strength'` instead of using lowercase `'strength'` to match the exact case in the data. Do maintain the same column selection `full_name`, join conditions `T1.id = T2.hero_id` and `T2.attribute_id = T3.id`, filter on `attribute_name`, ordering by `attribute_value DESC`, and `LIMIT 1` as these elements remain functionally identical. The amended query now correctly matches the case-sensitive attribute name while preserving the original logic to find the superhero with the highest strength value."
        ],
        "rules": [
            "1) When the question asks for a hero's full name with the highest attribute in strength: use T1.full_name as the output column.\n2) When combining tables superhero, hero_attribute, and attribute: link rows where T1.id = T2.hero_id and T2.attribute_id = T3.id using inner matches only.\n3) When filtering for strength attribute: use the exact literal 'Strength' (capitalized) for T3.attribute_name comparison.\n4) When ranking heroes by strength: order rows by T2.attribute_value in descending direction.\n5) When selecting the highest attribute value: keep only the first row after ordering.\n6) Output columns (ordered): T1.full_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'strength'\nORDER BY ha.attribute_value DESC\nLIMIT 1;",
            "SELECT T1.full_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Strength'\nORDER BY T2.attribute_value DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.full_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Strength'\nORDER BY T2.attribute_value DESC\nLIMIT 1;"
        ]
    },
    "813": {
        "question": "Calculate the average attribute value of all neutral superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT AVG(T1.attribute_value) FROM hero_attribute AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id INNER JOIN alignment AS T3 ON T2.alignment_id = T3.id WHERE T3.alignment = 'Neutral'",
        "amends": [],
        "rules": [
            "average = AVG(attribute_value); neutral superheroes refers to alignment_id = 3;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(ha.attribute_value) AS average_attribute_value\nFROM superhero sh\nJOIN hero_attribute ha ON sh.id = ha.hero_id\nWHERE sh.alignment_id = 3;"
        ],
        "rule_sql": []
    },
    "802": {
        "question": "Who is the tallest superhero?",
        "db_id": "superhero",
        "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "amends": [
            "Do use `ORDER BY height_cm DESC LIMIT 1` instead of a subquery with `MAX(height_cm)` to find the tallest superhero. Do remove the subquery structure entirely instead of using a correlated approach. Do eliminate the `WHERE` clause filter that compared height to a maximum value instead of keeping it. The amended query now correctly returns the superhero with the maximum height by sorting and limiting rather than using a potentially problematic subquery approach."
        ],
        "rules": [
            "1) When the question asks for the tallest superhero: rank rows by height_cm in descending order and keep the first 1 row. 2) When the question asks for superhero information: include the superhero_name column in the output. 3) Output columns (ordered): superhero_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero_name FROM superhero WHERE height_cm = (SELECT MAX(height_cm) FROM superhero);",
            "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;"
        ]
    },
    "301": {
        "question": "What is the bond type of TR007_4_19?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.bond_type FROM bond AS T WHERE T.bond_id = 'TR007_4_19'",
        "amends": [],
        "rules": [
            "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM bond WHERE bond_id = 'TR007_4_19';"
        ],
        "rule_sql": []
    },
    "1286": {
        "question": "For the patient with an abnormal alkaliphophatase level, how many of them are admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP >= 300 AND T1.Admission = '+'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID) AS AdmittedPatientsWithHighALP` to remove the unnecessary DISTINCT and column alias. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do remove the space before the `+` in `T1.Admission = '+'` instead of keeping it. The amended query now correctly counts patients with high ALP who were admitted without unnecessary DISTINCT operations.",
            "Do use `T2.ALP >= 300` instead of `T2.ALP > (SELECT AVG(ALP) FROM Laboratory)` to filter for specific ALP threshold values instead of comparing against a dynamic average. Do remove the subquery entirely instead of keeping it, eliminating the unnecessary correlated calculation. The amended query now correctly counts patients with laboratory results meeting the fixed ALP threshold of 300 or higher rather than those exceeding the average ALP value, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients with abnormal alkaline phosphatase levels who were admitted: use COUNT(T1.ID) without DISTINCT or column aliases. 2) When combining Patient and Laboratory tables: use INNER JOIN with T1 and T2 aliases where T1.ID = T2.ID. 3) When filtering for abnormal alkaline phosphatase levels: include rows where T2.ALP >= 300. 4) When filtering for admitted patients: include rows where T1.Admission = '+' without any space before the plus sign. 5) Output columns (ordered): COUNT(T1.ID)",
            "1) When the question asks about patients with abnormal alkaline phosphatase levels: filter laboratory results where T2.ALP is greater than or equal to 300. 2) When counting patients admitted to the hospital: include only patients where T1.Admission equals '+'. 3) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match). 4) When counting distinct patients: use T1.ID as the counting key to avoid duplicate counts. 5) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS AdmittedPatientsWithHighALP\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.ALP >= 300 AND P.Admission = '+';",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP > (SELECT AVG(ALP) FROM Laboratory) \nAND T1.Admission = '+';",
            "SELECT COUNT(T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.ALP >= 300 \nAND T1.Admission = '+';"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.ALP >= 300 AND T1.Admission = '+'"
        ]
    },
    "592": {
        "question": "How many users are awarded with more than 5 badges?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(UserId) FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "amends": [],
        "rules": [
            "more than 5 badges refers to Count (Name) > 5; user refers to UserId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS UserCount\nFROM (\n    SELECT UserId\n    FROM badges\n    GROUP BY UserId\n    HAVING COUNT(*) > 5\n) AS UsersWithMoreThan5Badges;"
        ],
        "rule_sql": []
    },
    "1206": {
        "question": "When is the laboratory examination of patient '48473' where his/her AST glutamic oxaloacetic transaminase (GOT) index is above the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT Date FROM Laboratory WHERE ID = 48473 AND GOT >= 60",
        "amends": [],
        "rules": [
            "AST glutamic oxaloacetic transaminase (GOT) index is above the normal range refers to GOT > = 60; when refers to DATE"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Date FROM Laboratory WHERE ID = 48473 AND GOT >= 60;"
        ],
        "rule_sql": []
    },
    "569": {
        "question": "Give the number of votes for the post about data visualization.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data visualization%'",
        "amends": [],
        "rules": [
            "About data visualization is the Title that contains 'data visualization';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS total_votes\nFROM votes v\nJOIN posts p ON v.PostId = p.Id\nWHERE p.Title LIKE '%data visualization%';"
        ],
        "rule_sql": []
    },
    "1238": {
        "question": "Among the patients who were diagnosed with SLE, who is the oldest with normal hemoglobin level. Provide the ID and sex.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.HGB > 10 AND T2.HGB < 17 ORDER BY T1.Birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "diagnosed with SLE refers to Diagnosis = 'SLE'; The larger the birthday value, the younger the person is, and vice versa; normal hemoglobin level refers to 10 < HGB < 17;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Diagnosis = 'SLE'\n  AND l.HGB BETWEEN 12 AND 17.5\nORDER BY p.Birthday ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "767": {
        "question": "What is the average of superheroes with no skin colour?",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id",
        "amends": [],
        "rules": [
            "average = DIVIDE(COUNT(superhero.id), SUM(skin_colour_id = 1)); no skin colour refers to skin_colour_id WHERE colour.id = 1;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) * 1.0 / SUM(CASE WHEN skin_colour_id = 1 THEN 1 ELSE 0 END) AS average_no_skin_colour\nFROM superhero;"
        ],
        "rule_sql": []
    },
    "1149": {
        "question": "Are there more in-patient or outpatient who were male? What is the deviation in percentage?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE SEX = 'M'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for counts. Do calculate the percentage directly using `SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)` instead of computing separate counts and then performing arithmetic. Do remove the CASE statement for comparison text and ABS function for deviation calculation instead of including them. Do eliminate the CTE structure and cross join between counts instead of using multiple common table expressions. Do cast the numerator to REAL for proper division instead of relying on integer arithmetic. Do filter for `SEX = 'M'` in the WHERE clause instead of handling it within CTEs. The amended query now correctly calculates the percentage of in-patient males relative to outpatient males without the unnecessary comparison logic and count separation."
        ],
        "rules": [
            "1) When counting patients by admission type for males: use conditional aggregation with SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) for in-patient counts and SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) for outpatient counts instead of separate queries.\n2) When calculating percentage deviation between admission types: compute (in-patient count * 100 / outpatient count) with the numerator cast to REAL for proper division instead of using separate count variables and arithmetic operations.\n3) When filtering for male patients: apply SEX = 'M' in the WHERE clause instead of handling gender filtering within separate subqueries.\n4) When the question asks for deviation in percentage: calculate the direct percentage ratio without absolute value or comparison text output instead of using ABS function and CASE statements for comparison labels.\n5) Output columns (ordered): percentage_deviation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH male_in_patients AS (\n    SELECT COUNT(*) AS count_in_patient\n    FROM Patient\n    WHERE SEX = 'M' AND Admission = '+'\n),\nmale_out_patients AS (\n    SELECT COUNT(*) AS count_out_patient\n    FROM Patient\n    WHERE SEX = 'M' AND Admission = '-'\n)\nSELECT \n    CASE \n        WHEN count_in_patient > count_out_patient THEN 'More in-patient males'\n        WHEN count_in_patient < count_out_patient THEN 'More outpatient males'\n        ELSE 'Equal number of in-patient and outpatient males'\n    END AS comparison,\n    ABS(count_in_patient - count_out_patient) * 100.0 / count_out_patient AS percentage_deviation\nFROM male_in_patients, male_out_patients;",
            "SELECT \n    (SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100.0 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)) AS percentage_deviation\nFROM Patient\nWHERE SEX = 'M';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100.0 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)) AS percentage_deviation\nFROM Patient\nWHERE SEX = 'M';"
        ]
    },
    "776": {
        "question": "Provide the hero name and race of Charles Chandler.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.full_name = 'Charles Chandler'",
        "amends": [],
        "rules": [
            "hero name refers to superhero_name; Charles Chandler is the full name of superhero;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name, r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.full_name = 'Charles Chandler';"
        ],
        "rule_sql": []
    },
    "387": {
        "question": "What are the cards for set OGW? State the colour for these cards.",
        "db_id": "card_games",
        "ground_truth": "SELECT id, colors FROM cards WHERE id IN ( SELECT id FROM set_translations WHERE setCode = 'OGW' )",
        "amends": [
            "Do select `id` and `colors` instead of `name` and `colors`. Do use a subquery with `id IN (SELECT id FROM set_translations WHERE setCode = 'OGW')` instead of directly filtering `WHERE setCode = 'OGW'` on the cards table. Do remove the direct reference to the cards table's setCode column and instead correlate through the set_translations table to properly filter by set code. The amended query now correctly matches the intended behavior by using the set_translations table to identify cards belonging to the OGW set."
        ],
        "rules": [
            "1) When filtering cards by set code 'OGW': use the set_translations table to identify matching card IDs through a subquery condition `id IN (SELECT id FROM set_translations WHERE setCode = 'OGW')` instead of directly filtering on the cards table.\n2) When selecting card information for set OGW: output the exact columns `id` and `colors` from the cards table.\n3) When handling the set code literal: preserve the exact value 'OGW' with the specified case and formatting.\n4) When combining card data with set information: use the card `id` as the linking key between the cards table and set_translations table.\n5) Output columns (ordered): id, colors"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, colors FROM cards WHERE setCode = 'OGW';",
            "SELECT id, colors FROM cards WHERE id IN (SELECT id FROM set_translations WHERE setCode = 'OGW')"
        ],
        "rule_sql": [
            "SELECT id, colors FROM cards WHERE id IN (SELECT id FROM set_translations WHERE setCode = 'OGW')"
        ]
    },
    "1372": {
        "question": "When did the member, Casey Mason, received the income?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "amends": [],
        "rules": [
            "when the income was received refers to date_received"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.date_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.first_name = 'Casey' AND m.last_name = 'Mason';"
        ],
        "rule_sql": []
    },
    "892": {
        "question": "State the driver with the most points scored. Find his full name with that points.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `full_name`, and do select actual `points` instead of aggregating with `MAX(points)`. Do join `races` table with `driverStandings` on `raceId` instead of omitting the races table entirely, and do use `INNER JOIN` on `T2.raceId = T1.raceId` instead of joining only drivers without race context. Do remove the `GROUP BY ds.driverId` clause instead of grouping by driver when individual race results are needed. Do order by actual `T2.points` instead of the aggregated `max_points`, maintaining the descending order. The amended query now correctly retrieves the highest points from individual race standings rather than maximum points per driver across all races, matching the RIGHT_SQL's behavior of showing the single highest race result."
        ],
        "rules": [
            "1) When the question asks for the driver with the most points scored: select individual columns T1.forename and T1.surname instead of concatenating them as a single full_name column.\n2) When retrieving points from race results: select actual T2.points instead of aggregating with MAX(points).\n3) When combining driver standings with race context: join the races table (T3) with driverStandings table (T2) on T2.raceId = T3.raceId using an inner match.\n4) When individual race results are needed: do not group by driverId and instead work with individual race entries.\n5) When ordering by points to find the highest score: order by actual T2.points in descending direction instead of aggregated points.\n6) When the question asks for the single highest race result: take only the first row after ordering by points descending.\n7) Output columns (ordered): T1.forename, T1.surname, T2.points"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name, MAX(ds.points) AS max_points\nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nGROUP BY ds.driverId\nORDER BY max_points DESC\nLIMIT 1;",
            "SELECT d.forename, d.surname, ds.points \nFROM driverStandings ds\nINNER JOIN drivers d ON ds.driverId = d.driverId\nINNER JOIN races r ON ds.raceId = r.raceId\nORDER BY ds.points DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT d.forename, d.surname, ds.points \nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nJOIN races r ON ds.raceId = r.raceId\nORDER BY ds.points DESC\nLIMIT 1;"
        ]
    },
    "522": {
        "question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
        "amends": [],
        "rules": [
            "ranked 1st on EDHRec refers to edhrecRank = 1; banned refers to status = 'Banned'; play format refers to format; cards name refers to name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name AS card_name, l.format AS banned_format\nFROM cards c\nLEFT JOIN legalities l ON c.uuid = l.uuid\nWHERE c.edhrecRank = 1 AND l.status = 'Banned';\n"
        ],
        "rule_sql": []
    },
    "743": {
        "question": "What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.",
        "db_id": "superhero",
        "ground_truth": "SELECT (CAST(COUNT(*) AS REAL) * 100 / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE T3.alignment = 'Bad'",
        "amends": [],
        "rules": [
            "published by Marvel Comics refers to publisher_name = 'Marvel Comics'; superheroes who act in their own self-interest or make decisions based on their own moral code refers to alignment = 'Bad'; calculation = MULTIPLY(DIVIDE(SUM(alignment = 'Bad); count(id)), 100)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH total_superheroes AS (\n    SELECT COUNT(*) AS total_count FROM superhero\n),\nbad_superheroes AS (\n    SELECT COUNT(*) AS bad_count FROM superhero\n    JOIN alignment ON superhero.alignment_id = alignment.id\n    WHERE alignment.alignment = 'Bad'\n),\nmarvel_bad_superheroes AS (\n    SELECT COUNT(*) AS marvel_bad_count FROM superhero\n    JOIN alignment ON superhero.alignment_id = alignment.id\n    JOIN publisher ON superhero.publisher_id = publisher.id\n    WHERE alignment.alignment = 'Bad' AND publisher.publisher_name = 'Marvel Comics'\n)\nSELECT \n    (bad_superheroes.bad_count * 100.0 / total_superheroes.total_count) AS percentage_bad,\n    marvel_bad_superheroes.marvel_bad_count AS marvel_bad_count\nFROM \n    total_superheroes, \n    bad_superheroes, \n    marvel_bad_superheroes;"
        ],
        "rule_sql": []
    },
    "310": {
        "question": "How many molecules have a double bond type and among these molecule, how many are labeled as carcinogenic compound?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id), SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '='",
        "amends": [
            "Do use `COUNT(DISTINCT T2.molecule_id)` instead of `COUNT(*)` to avoid counting duplicate molecules with multiple double bonds. Do move the `bond_type = '='` filter from the CTE to the main `WHERE` clause instead of keeping it in a separate CTE. Do remove the unnecessary CTE structure and perform a direct `INNER JOIN` between `bond` and `molecule` tables instead of using a CTE intermediate. Do use table aliases `T1` and `T2` instead of `dbm` and `m` for clarity. Do change the bond type comparison from `' = '` (with spaces) to `'='` (without spaces) to match the actual data format. The amended query now correctly handles molecules with multiple double bonds by using DISTINCT counting and matches the RIGHT_SQL's behavior.",
            "Do use `COUNT(DISTINCT T2.molecule_id)` instead of `COUNT(DISTINCT T1.molecule_id)` for the first aggregate. Do replace `COUNT(DISTINCT CASE WHEN T2.label = 'carcinogenic compound' THEN T1.molecule_id END)` with `SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END)` instead of counting distinct molecule IDs with a different condition. Do remove the column aliases `total_molecules_with_double_bonds` and `carcinogenic_molecules` instead of keeping them. Do use `T2.label = '+'` instead of `T2.label = 'carcinogenic compound'` in the CASE condition. The amended query now correctly counts distinct molecules from the molecule table and sums cases where the label equals '+' rather than using carcinogenic compound filtering with distinct counts."
        ],
        "rules": [
            "1) When counting molecules with a specific bond type: use COUNT(DISTINCT T2.molecule_id) instead of COUNT(*) to avoid counting duplicate molecules with multiple bonds of that type.\n2) When filtering for bond type '=': use the exact literal '=' without spaces to match the actual data format.\n3) When combining bond and molecule tables: perform a direct INNER JOIN between T1 (bond) and T2 (molecule) using T1.molecule_id = T2.molecule_id instead of using CTE intermediates.\n4) When identifying carcinogenic compounds: check for T2.label = '+' using the exact literal '+'.\n5) When the question asks for molecules with a specific bond type: apply the bond_type filter directly in the WHERE clause rather than in a separate CTE.\nOutput columns (ordered): total_molecules_with_double_bond, carcinogenic_molecules_with_double_bond",
            "1) When counting molecules with double bonds: count distinct values of T2.molecule_id instead of T1.molecule_id. 2) When filtering for carcinogenic compounds: use T2.label = '+' instead of T2.label = 'carcinogenic compound'. 3) When counting carcinogenic molecules among those with double bonds: use SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) instead of counting distinct molecule IDs. 4) When producing output: remove column aliases total_molecules_with_double_bonds and carcinogenic_molecules. 5) Output columns (ordered): COUNT(DISTINCT T2.molecule_id), SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH double_bond_molecules AS (\n  SELECT DISTINCT molecule_id\n  FROM bond\n  WHERE bond_type = ' = '\n)\nSELECT \n  COUNT(*) AS total_molecules_with_double_bond,\n  SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) AS carcinogenic_molecules_with_double_bond\nFROM double_bond_molecules dbm\nJOIN molecule m ON dbm.molecule_id = m.molecule_id;",
            "SELECT \n    COUNT(DISTINCT T1.molecule_id) AS total_molecules_with_double_bonds,\n    COUNT(DISTINCT CASE WHEN T2.label = 'carcinogenic compound' THEN T1.molecule_id END) AS carcinogenic_molecules\nFROM \n    bond T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T1.bond_type = '='",
            "SELECT \n    COUNT(DISTINCT T2.molecule_id) AS total_molecules_with_double_bonds,\n    SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS carcinogenic_molecules\nFROM \n    bond T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T1.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.molecule_id), SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) FROM bond T1 INNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '='"
        ]
    },
    "1139": {
        "question": "What was the final score for the match on September 24, 2008, in the Belgian Jupiler League between the home team and the away team?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.home_team_goal, t2.away_team_goal FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND t2.`date` LIKE '2008-09-24%'",
        "amends": [],
        "rules": [
            "September 24, 2008 refers to date like '2008-09-24%'; in the Belgian Jupiler League refers to League.name = 'Belgium Jupiler League'; final score for home team refers to home_team_goal; final score for away team refers to away_team_goal"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT home_team_goal, away_team_goal \nFROM Match \nWHERE date LIKE '2008-09-24%' \nAND league_id = (SELECT id FROM League WHERE name = 'Belgium Jupiler League');"
        ],
        "rule_sql": []
    },
    "1405": {
        "question": "Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.category, SUM(T2.amount) FROM event AS T1 JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'April Speaker' GROUP BY T2.category ORDER BY SUM(T2.amount) ASC",
        "amends": [],
        "rules": [
            "'April Speaker' is an event name; amount budgeted refers to SUM(amount); budget categories refers to category"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.category, b.amount\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'April Speaker'\nORDER BY b.amount ASC;"
        ],
        "rule_sql": []
    },
    "897": {
        "question": "Name the driver with the most winning. Mention his nationality and what is his maximum point scores.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE T2.wins >= 1 GROUP BY T1.forename, T1.surname, T1.nationality ORDER BY COUNT(T2.wins) DESC LIMIT 1",
        "amends": [
            "Do use `T1.forename`, `T1.surname`, and `T1.nationality` as separate columns instead of concatenating them into `full_name`. Do change the join to `INNER JOIN` instead of `JOIN` and reverse the join condition to `T2.driverId = T1.driverId` instead of `d.driverId = ds.driverId`. Do modify the WHERE filter to `T2.wins >= 1` instead of `ds.wins = (SELECT MAX(wins) FROM driverStandings)`. Do remove `d.driverId` from the GROUP BY clause instead of including it. Do add `ORDER BY COUNT(T2.wins) DESC` instead of omitting ordering. The amended query now correctly identifies drivers with at least one win and orders by win count rather than finding drivers with maximum wins."
        ],
        "rules": [
            "1) When the question asks for a driver's name, nationality, and maximum points: output T1.forename, T1.surname, and T1.nationality as separate columns instead of concatenating them.\n2) When combining driver information with standings data: link rows where T2.driverId = T1.driverId using an inner match.\n3) When filtering for drivers with winning records: include only rows where T2.wins >= 1.\n4) When grouping driver information: group by T1.forename, T1.surname, and T1.nationality without including T1.driverId.\n5) When ranking drivers by number of wins: order results by COUNT(T2.wins) in descending order to find the driver with the most wins.\n6) When computing maximum points: calculate MAX(T2.points) for each driver.\nOutput columns (ordered): T1.forename, T1.surname, T1.nationality, MAX(T2.points)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name, d.nationality, MAX(ds.points) AS max_points\nFROM drivers d\nJOIN driverStandings ds ON d.driverId = ds.driverId\nWHERE ds.wins = (SELECT MAX(wins) FROM driverStandings)\nGROUP BY d.driverId, d.forename, d.surname, d.nationality\nLIMIT 1;",
            "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) AS max_points\nFROM drivers T1\nINNER JOIN driverStandings T2 ON T2.driverId = T1.driverId\nWHERE T2.wins >= 1\nGROUP BY T1.forename, T1.surname, T1.nationality\nORDER BY COUNT(T2.wins) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT d.forename, d.surname, d.nationality, MAX(ds.points) AS max_points\nFROM drivers d\nINNER JOIN driverStandings ds ON d.driverId = ds.driverId\nWHERE ds.wins >= 1\nGROUP BY d.forename, d.surname, d.nationality\nORDER BY COUNT(ds.wins) DESC\nLIMIT 1;"
        ]
    },
    "1304": {
        "question": "Among the patients with a normal blood glucose, how many of them don't have thrombosis?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.GLU < 180 AND T3.Thrombosis = 0",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT p.ID)` to count all matching rows rather than distinct patient IDs. Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `l`, and `e` for consistent naming. Do specify `INNER JOIN` explicitly instead of implicit `JOIN` for clarity. Do reference `T2.GLU` and `T3.Thrombosis` instead of `l.GLU` and `e.Thrombosis` to match the alias changes. The amended query now correctly counts all patient records meeting the laboratory and examination criteria without unnecessary DISTINCT filtering.",
            "Do change the WHERE filter to `T2.GLU < 180` instead of `T2.GLU IS NOT NULL` to properly filter for glucose values below the threshold rather than just checking for non-null values. The amended query now correctly counts patients with glucose levels under 180 who do not have thrombosis, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs. 2) When using table aliases: use T1 for Patient table, T2 for Laboratory table, and T3 for Examination table for consistent naming. 3) When joining tables: use INNER JOIN explicitly instead of implicit JOIN for clarity. 4) When referencing laboratory glucose values: use T2.GLU to match the alias changes. 5) When referencing examination thrombosis status: use T3.Thrombosis to match the alias changes. 6) When filtering for normal blood glucose: use T2.GLU < 180 as the condition. 7) When filtering for absence of thrombosis: use T3.Thrombosis = 0 as the condition. 8) When combining patient, laboratory, and examination data: link rows where T1.ID = T2.ID and T1.ID = T3.ID using inner matches. 9) Output columns (ordered): COUNT(T1.ID)",
            "1) When the question asks for patients with normal blood glucose: filter rows where T2.GLU < 180 to identify patients with glucose levels below the threshold.\n2) When the question asks about patients without thrombosis: filter rows where T3.Thrombosis = 0 to exclude patients with thrombosis.\n3) When combining Patient, Laboratory, and Examination tables: link rows where T1.ID = T2.ID and T1.ID = T3.ID to match patient records across all three tables.\n4) When counting patients: compute the number of rows using T1.ID as the counting key.\n5) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.GLU < 180 AND e.Thrombosis = 0;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.GLU IS NOT NULL \nAND T3.Thrombosis = 0",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.GLU < 180 \nAND T3.Thrombosis = 0;"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.GLU < 180 AND T3.Thrombosis = 0"
        ]
    },
    "716": {
        "question": "Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10",
        "amends": [
            "Do use `SUM(IIF(T1.UpVotes = 0, 1, 0))` with explicit `CAST` to `REAL` instead of `COUNT(DISTINCT CASE WHEN u.UpVotes = 0 THEN c.UserId END)` for the numerator calculation. Do count `T1.Id` instead of `c.UserId` for the denominator to ensure accurate user counting. Do use `INNER JOIN` with `T1.Id = T2.UserId` instead of `JOIN` with `c.UserId = u.Id` for proper table aliasing and join condition clarity. Do place the `Score BETWEEN 5 AND 10` filter on the comments table instead of maintaining the same condition. Do remove the `DISTINCT` qualifiers from both counts instead of keeping them to avoid unnecessary deduplication. Do use explicit table aliases `T1` and `T2` instead of `u` and `c` for better readability. The amended query now correctly calculates the percentage of users with zero upvotes who made comments with scores between 5-10, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating the percentage of users with 0 up votes among comments with scores 5 to 10: use SUM(IIF(T1.UpVotes = 0, 1, 0)) with explicit CAST to REAL for the numerator instead of counting distinct users. 2) When counting users for the denominator: count T1.Id instead of comment user IDs to ensure accurate user counting. 3) When combining users and comments tables: use INNER JOIN with T1.Id = T2.UserId for proper table aliasing and join condition clarity. 4) When filtering comments by score: apply Score BETWEEN 5 AND 10 filter on the comments table (T2). 5) When performing aggregate calculations: remove DISTINCT qualifiers from both counts to avoid unnecessary deduplication. 6) When referencing tables: use explicit table aliases T1 for users and T2 for comments for better readability. Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN u.UpVotes = 0 THEN c.UserId END) * 100.0 / COUNT(DISTINCT c.UserId)) AS percentage\nFROM \n    comments c\nJOIN \n    users u ON c.UserId = u.Id\nWHERE \n    c.Score BETWEEN 5 AND 10;",
            "SELECT \n    (CAST(SUM(IIF(T2.UpVotes = 0, 1, 0)) AS REAL) / COUNT(T1.Id)) * 100.0 AS percentage\nFROM \n    comments T1\nINNER JOIN \n    users T2 ON T1.UserId = T2.Id\nWHERE \n    T1.Score BETWEEN 5 AND 10"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) / COUNT(T1.Id)) * 100 AS percentage\nFROM \n    users T1\nINNER JOIN \n    comments T2 ON T1.Id = T2.UserId\nWHERE \n    T2.Score BETWEEN 5 AND 10"
        ]
    },
    "1125": {
        "question": "Among the players with finishing rate of 1, pick the eldest player and state the player's name.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.finishing = 1 ORDER BY t1.birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "eldest player refers to MAX(SUBTRACT(datetime(CURRENT_TIMESTAMP,'localtime'),datetime(birthday))); finishing rate of 1 refers to finishing = 1"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.finishing = 1\nORDER BY p.birthday ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1479": {
        "question": "Which year recorded the most consumption of gas paid in CZK?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do reference the yearmonth table as `T2` instead of `ym` and customers table as `T1` instead of `c` in the SELECT clause. Do use `INNER JOIN` explicitly instead of just `JOIN` while keeping the same join condition `T1.CustomerID = T2.CustomerID`. Do remove the alias `Year` from the SELECT expression and instead reference `SUBSTR(T2.Date, 1, 4)` directly in both SELECT and GROUP BY clauses. Do remove the alias `TotalConsumption` from the aggregated column and instead reference `SUM(T2.Consumption)` directly in the ORDER BY clause. The amended query now correctly groups by the year expression and orders by the sum of consumption without unnecessary aliases, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for consumption by year: extract the year from T2.Date using SUBSTR(T2.Date, 1, 4). 2) When the question specifies gas paid in CZK: filter T1.Currency to exactly match 'CZK'. 3) When combining T1 and T2 for customer data: link rows where T1.CustomerID = T2.CustomerID using an inner match. 4) When calculating total consumption: compute SUM(T2.Consumption) per year. 5) When finding the year with most consumption: order results by SUM(T2.Consumption) in descending order and take the first result. 6) When grouping by year: organize results by SUBSTR(T2.Date, 1, 4) without using aliases. 7) Output columns (ordered): SUBSTR(T2.Date, 1, 4), SUM(T2.Consumption)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUBSTR(ym.Date, 1, 4) AS Year, SUM(ym.Consumption) AS TotalConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Currency = 'CZK'\nGROUP BY Year\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "SELECT SUBSTR(T2.Date, 1, 4) \nFROM yearmonth T2\nINNER JOIN customers T1 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK'\nGROUP BY SUBSTR(T2.Date, 1, 4)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT SUBSTR(T2.Date, 1, 4), SUM(T2.Consumption) \nFROM customers T1 \nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Currency = 'CZK' \nGROUP BY SUBSTR(T2.Date, 1, 4) \nORDER BY SUM(T2.Consumption) DESC \nLIMIT 1"
        ]
    },
    "896": {
        "question": "Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.",
        "db_id": "formula_1",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.surname = 'Hamilton' AND T1.year >= 2010",
        "amends": [
            "Do use `driverStandings` table instead of `results` table for position data. Do join `races` with `driverStandings` on `raceId` instead of joining `results` with `races`. Do filter on `T3.surname = 'Hamilton'` and `T1.year >= 2010` in WHERE clause instead of using CTEs. Do calculate percentage using `COUNT(CASE WHEN T2.position <> 1 THEN T2.position END)` for non-first positions instead of separate CTE counts. Do use `CAST(... AS REAL)` for precise division instead of implicit casting. Do remove CTE structure and perform single query instead of multiple common table expressions. Do reference `driverStandingsId` for total count instead of counting all rows. The amended query now correctly calculates the percentage of races where Hamilton didn't finish first using the appropriate standings data."
        ],
        "rules": [
            "1) When calculating percentages for driver positions: use the driverStandings table for position data instead of the results table.\n2) When joining races with driver standings: link rows where T1.raceId = T2.raceId to combine race and position information.\n3) When filtering for a specific driver: use T3.surname = 'Hamilton' to identify the driver's records.\n4) When filtering by time period: use T1.year >= 2010 to include races from 2010 onward.\n5) When counting non-first positions: use COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) to count races where position was not first.\n6) When calculating total races: count using driverStandingsId as the canonical key instead of counting all rows.\n7) When performing division for percentages: use CAST(... AS REAL) for precise division instead of implicit casting.\n8) When computing percentage calculations: perform the calculation as (non-first count * 100.0 / total count) to get the percentage value.\n9) Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH hamilton_races AS (\n    SELECT COUNT(*) AS total_races\n    FROM results r\n    JOIN drivers d ON r.driverId = d.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE d.surname = 'Hamilton' AND rc.year >= 2010\n),\nhamilton_not_first AS (\n    SELECT COUNT(*) AS not_first_races\n    FROM results r\n    JOIN drivers d ON r.driverId = d.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE d.surname = 'Hamilton' AND rc.year >= 2010 AND r.position > 1\n)\nSELECT (not_first_races * 100.0 / total_races) AS percentage\nFROM hamilton_races, hamilton_not_first;",
            "SELECT \n    (CAST(COUNT(CASE WHEN ds.position <> 1 THEN ds.driverStandingsId END) AS REAL) / \n     CAST(COUNT(ds.driverStandingsId) AS REAL)) * 100 AS percentage_not_first\nFROM \n    driverStandings ds\nJOIN \n    races r ON ds.raceId = r.raceId\nJOIN \n    drivers d ON ds.driverId = d.driverId\nWHERE \n    d.surname = 'Hamilton' \n    AND r.year >= 2010;"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN ds.position <> 1 THEN ds.driverStandingsId END) * 100.0 / COUNT(ds.driverStandingsId)) AS percentage\nFROM \n    driverStandings ds\nJOIN \n    races r ON ds.raceId = r.raceId\nJOIN \n    drivers d ON ds.driverId = d.driverId\nWHERE \n    d.surname = 'Hamilton'\n    AND r.year >= 2010"
        ]
    },
    "1421": {
        "question": "Calculate the percentage of members who are major Business in the list?",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member'",
        "amends": [
            "Do use `INNER JOIN` on `T2.major_id = T1.link_to_major` instead of `LEFT JOIN` on `member.link_to_major = m.major_id` to exclude members without majors. Do add `WHERE T1.position = 'Member'` instead of omitting it to filter only members with that position. Do change the calculation to `CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id)` instead of `(COUNT(CASE WHEN m.major_name = 'Business' THEN 1 END) * 100.0 / COUNT(*))` to properly handle the percentage calculation with explicit casting and member-specific counting. Do use table aliases `T1` and `T2` instead of no aliases for clarity. The amended query now correctly calculates the percentage of Business majors among members with a valid position, matching the intended behavior."
        ],
        "rules": [
            "1) When combining member and major tables: link rows where T2.major_id = T1.link_to_major and keep only matching pairs (inner match). 2) When filtering members by position: include only rows where T1.position = 'Member'. 3) When calculating percentage of Business majors: compute (number of rows where T2.major_name = 'Business') divided by (total number of members using T1.member_id as counting key), then multiply by 100 with explicit casting to REAL. 4) When counting members: use T1.member_id as the canonical counting key. 5) When handling text literals: preserve exact case and spacing for 'Business' and 'Member'. 6) Output columns (ordered): percentage_business_majors"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN m.major_name = 'Business' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_business_majors\nFROM member\nLEFT JOIN major m ON member.link_to_major = m.major_id;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id) AS percentage\nFROM \n    member T1\nINNER JOIN \n    major T2 ON T2.major_id = T1.link_to_major\nWHERE \n    T1.position = 'Member';"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(CASE WHEN T2.major_name = 'Business' THEN T1.member_id END) AS REAL) / COUNT(T1.member_id)) * 100 AS percentage_business_majors\nFROM \n    member T1\nINNER JOIN \n    major T2 ON T2.major_id = T1.link_to_major\nWHERE \n    T1.position = 'Member';"
        ]
    },
    "1293": {
        "question": "What is the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T2.ANA FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 ORDER BY T2.ANA DESC LIMIT 1",
        "amends": [],
        "rules": [
            "highest anti-nucleus antibody concentration level refers to MAX(ANA); normal creatinine level refers to CRE < 1.5;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(e.ANA) AS Highest_ANA\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE l.CRE < 1.5;"
        ],
        "rule_sql": []
    },
    "848": {
        "question": "Please list the year during which the race is held on circuits in Shanghai.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.location = 'Shanghai'",
        "amends": [],
        "rules": [
            "Shanghai is a name of location;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.location = 'Shanghai';"
        ],
        "rule_sql": []
    },
    "1043": {
        "question": "What is the short name of the football team Queens Park Rangers?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers'",
        "amends": [],
        "rules": [
            "short name of the football team refers to team_short_name; Queens Park Rangers refers to team_long_name = 'Queens Park Rangers';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers';"
        ],
        "rule_sql": []
    },
    "768": {
        "question": "How many superheroes were published by Dark Horse Comics?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Dark Horse Comics'",
        "amends": [],
        "rules": [
            "published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Dark Horse Comics');"
        ],
        "rule_sql": []
    },
    "197": {
        "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
        "db_id": "toxicology",
        "ground_truth": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
        "amends": [
            "Do join `atom` and `bond` directly instead of joining both to `molecule` unnecessarily. Do use `COUNT(T1.element)` instead of `COUNT(a.atom_id)` since we're counting oxygen atoms. Do remove the redundant `molecule` table from the FROM clause instead of including it when the join between atom and bond already provides the necessary molecule context. Do reference `T1.molecule_id` in GROUP BY instead of `m.molecule_id` since the molecule table is no longer present. The amended query now correctly calculates average oxygen count for molecules with single bonds by directly joining atom and bond tables on molecule_id with appropriate filters.",
            "Do use `bond_type = '-'` instead of `bond_type = 'single'` in the WHERE filter. Do use `element = 'o'` instead of `element = 'O'` for case sensitivity. Do remove the alias `AS avg_oxygen_atoms` from the outer SELECT instead of keeping it. Do add the alias `AS oxygen_counts` to the subquery instead of omitting it. The amended query now correctly filters for single bonds using the '-' representation and handles element case consistently, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for average number of oxygen atoms in single-bonded molecules: join atom table (T1) and bond table (T2) directly using T1.molecule_id = T2.molecule_id with an inner match. 2) When filtering for single bonds: include only rows where T2.bond_type = '-'. 3) When filtering for oxygen atoms: include only rows where T1.element = 'o'. 4) When counting oxygen atoms per molecule: group by T1.molecule_id and count T1.element. 5) When calculating the average: compute the average of the oxygen counts across all molecules. Output columns (ordered): average_oxygen_count",
            "1) When the question asks for average number of oxygen atoms in single-bonded molecules: use bond_type = '-' instead of 'single' to represent single bonds. 2) When filtering for oxygen atoms: use element = 'o' (lowercase) instead of 'O' for case-sensitive matching. 3) When calculating average oxygen atoms: do not use an alias like AS avg_oxygen_atoms in the outer SELECT. 4) When using a subquery to count oxygen atoms per molecule: add the alias AS oxygen_counts to the subquery. 5) When counting oxygen atoms per molecule: group by T1.molecule_id and count T1.element where element = 'o'. 6) When joining atom and bond tables: link rows where T1.molecule_id = T2.molecule_id to find atoms in bonded molecules. 7) Output columns (ordered): AVG(oxygen_count)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(oxygen_count) AS average_oxygen_count\nFROM (\n    SELECT m.molecule_id, COUNT(a.atom_id) AS oxygen_count\n    FROM molecule m\n    JOIN bond b ON m.molecule_id = b.molecule_id\n    JOIN atom a ON m.molecule_id = a.molecule_id\n    WHERE b.bond_type = '-'\n    AND a.element = 'o'\n    GROUP BY m.molecule_id\n) AS oxygen_counts;",
            "SELECT AVG(oxygen_count) AS avg_oxygen_atoms\nFROM (\n    SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count\n    FROM atom T1\n    JOIN bond T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T2.bond_type = 'single'\n    AND T1.element = 'O'\n    GROUP BY T1.molecule_id\n)",
            "SELECT AVG(oxygen_count) FROM (\n    SELECT COUNT(T1.element) AS oxygen_count\n    FROM atom T1\n    JOIN bond T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T2.bond_type = '-'\n    AND T1.element = 'o'\n    GROUP BY T1.molecule_id\n) AS oxygen_counts"
        ],
        "rule_sql": [
            "SELECT AVG(oxygen_count) \nFROM (\n    SELECT COUNT(T1.element) AS oxygen_count\n    FROM atom T1\n    INNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T2.bond_type = '-' AND T1.element = 'o'\n    GROUP BY T1.molecule_id\n) AS oxygen_counts"
        ]
    },
    "113": {
        "question": "For the client who applied 98832 USD loan in 1996/1/3, when was his/her birthday?",
        "db_id": "financial",
        "ground_truth": "SELECT T4.birth_date FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T1.date = '1996-01-03' AND T1.amount = 98832",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.amount = 98832 AND l.date = '1996-01-03';"
        ],
        "rule_sql": []
    },
    "375": {
        "question": "List down all the card IDs with converted mana cost of 0.",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE convertedManaCost = 0",
        "amends": [],
        "rules": [
            "converted mana cost of 0 refers to covertedManaCost = 0;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM cards WHERE convertedManaCost = 0;"
        ],
        "rule_sql": []
    },
    "821": {
        "question": "List down Ajax's superpowers.",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Ajax'",
        "amends": [],
        "rules": [
            "Ajax refers to superhero_name = 'Ajax'; superpowers refers to power_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Ajax';"
        ],
        "rule_sql": []
    },
    "436": {
        "question": "How many cards have frame effect as extendedart? List out the id of those cards.",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id",
        "amends": [
            "Do select individual `id` values instead of aggregating with `COUNT(*)` and `GROUP_CONCAT(id)`. Do add `GROUP BY id` instead of omitting grouping. Do remove the `AS count` and `AS card_ids` aliases instead of keeping them. The amended query now correctly returns individual card IDs rather than aggregated counts and concatenated ID lists, matching the RIGHT_SQL's behavior of selecting distinct card records with extended art frame effects.",
            "Do use exact equality comparison `frameEffects = 'extendedart'` instead of the LIKE pattern match `frameEffects LIKE '%extendedart%'` to ensure precise matching of the exact string value rather than partial substring matching, which could incorrectly include records with additional frame effects. The amended query now correctly filters for cards that have exactly the 'extendedart' frame effect and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for individual card IDs rather than aggregated counts: select individual id values instead of using COUNT(*) or GROUP_CONCAT(id). 2) When selecting individual card IDs: add GROUP BY id to ensure distinct card records are returned. 3) When the question specifies frame effect as extendedart: filter rows where frameEffects equals exactly 'extendedart'. 4) When producing output: remove any column aliases like AS count or AS card_ids. 5) Output columns (ordered): id",
            "1) When the question asks for cards with frame effect as extendedart: filter rows where the frameEffects column equals exactly 'extendedart' (case-sensitive exact match).\n2) When the question asks for the id of those cards: output the id column values from the filtered rows.\n3) When handling text literals: preserve the exact string 'extendedart' with no changes to case, spacing, or punctuation.\n4) When filtering for exact string matches: use equality comparison instead of pattern matching to ensure precise value matching.\n5) Output columns (ordered): id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS count, GROUP_CONCAT(id) AS card_ids FROM cards WHERE frameEffects = 'extendedart';",
            "SELECT id FROM cards WHERE frameEffects LIKE '%extendedart%' GROUP BY id;",
            "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id"
        ]
    },
    "788": {
        "question": "How many percent of female heroes were published by Marvel Comics?",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T3.gender = 'Female'",
        "amends": [
            "Do use `CAST` to convert the count to `REAL` instead of implicit conversion with `100.0`. Do calculate percentage based on `COUNT(T1.id)` instead of `COUNT(*)`. Do move the publisher filter `T2.publisher_name = 'Marvel Comics'` into the `CASE` expression instead of keeping it in the `WHERE` clause. Do filter for `T3.gender = 'Female'` in the `WHERE` clause instead of checking gender in the `CASE` expression. Do use table aliases `T1`, `T2`, `T3` instead of full table names. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly calculates the percentage of female heroes specifically for Marvel Comics by moving the publisher condition into the CASE expression while filtering for female gender in WHERE, ensuring accurate percentage calculation."
        ],
        "rules": [
            "1) When calculating percentages with gender filtering: filter for T3.gender = 'Female' in the WHERE clause instead of using CASE expressions for gender conditions. 2) When calculating percentages for specific publishers: move publisher filter conditions like T2.publisher_name = 'Marvel Comics' into the CASE expression instead of keeping them in the WHERE clause. 3) When counting entities for percentage calculations: use COUNT(T1.id) as the denominator instead of COUNT(*) to ensure accurate entity counting. 4) When performing percentage calculations: use CAST to convert counts to REAL type instead of implicit conversion with 100.0. 5) When joining tables: use INNER JOIN explicitly instead of just JOIN to clarify join semantics. 6) When working with this schema: use table aliases T1, T2, T3 instead of full table names, where T1 represents the superhero table, T2 represents the publisher table, and T3 represents the gender table. 7) When combining tables for shared entities: link rows where T1.publisher_id = T2.id and T1.gender_id = T3.id using inner matches only. Output columns (ordered): percentage_female_heroes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female_heroes\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    gender g ON s.gender_id = g.id\nWHERE \n    p.publisher_name = 'Marvel Comics';",
            "SELECT \n    (CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN T1.id END) AS REAL) / COUNT(T1.id)) * 100 AS percentage\nFROM \n    superhero T1\n    INNER JOIN publisher T2 ON T1.publisher_id = T2.id\n    INNER JOIN gender T3 ON T1.gender_id = T3.id\nWHERE \n    T3.gender = 'Female'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN T1.id END) AS REAL) / CAST(COUNT(T1.id) AS REAL) * 100 AS percentage_female_heroes\nFROM \n    superhero T1\nINNER JOIN \n    publisher T2 ON T1.publisher_id = T2.id\nINNER JOIN \n    gender T3 ON T1.gender_id = T3.id\nWHERE \n    T3.gender = 'Female'"
        ]
    },
    "613": {
        "question": "List out the dates that users who are located in Rochester, NY obtained their badges?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Date FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'Rochester, NY'",
        "amends": [],
        "rules": [
            "\"Rochester, NY\" is the Location of user; user refers to UserId"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.Date\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Location = 'Rochester, NY';\n"
        ],
        "rule_sql": []
    },
    "428": {
        "question": "What is the name of set number 5 and its translation?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name, T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 5 GROUP BY T1.name, T2.translation",
        "amends": [
            "Do use `INNER JOIN` instead of `LEFT JOIN` to ensure only matching records are returned. Do reference `T2.id` in the WHERE clause instead of `s.id` to filter by the translation table's ID. Do add `GROUP BY T1.name, T2.translation` instead of omitting aggregation when selecting non-aggregated columns. Do use table aliases `T1` and `T2` instead of `s` and `st` for consistency. Do remove the column alias `set_name` instead of keeping it since the column is now simply named `name`. The amended query now correctly filters by translation ID and ensures proper grouping for the result set."
        ],
        "rules": [
            "1) When joining T1 (sets) and T2 (set_translations): link rows where T1.code equals T2.setCode exactly and keep only matching pairs (inner match). 2) When filtering by translation ID number 5: include only rows where T2.id equals 5. 3) When selecting non-aggregated columns T1.name and T2.translation: organize results by grouping on both T1.name and T2.translation. 4) When the question asks for \"set number 5 and its translation\": output the name from T1 and translation from T2 for the translation with ID 5. 5) Output columns (ordered): T1.name, T2.translation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name AS set_name, st.translation FROM sets s LEFT JOIN set_translations st ON s.code = st.setCode WHERE s.id = 5;",
            "SELECT T1.name, T2.translation\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.id = 5\nGROUP BY T1.name, T2.translation;"
        ],
        "rule_sql": [
            "SELECT s.name, st.translation\nFROM sets s\nINNER JOIN set_translations st ON s.code = st.setCode\nWHERE st.id = 5\nGROUP BY s.name, st.translation"
        ]
    },
    "220": {
        "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
        "amends": [
            "Do add `DISTINCT` to eliminate duplicate elements instead of returning all occurrences. Do add table alias `T` and qualify column references as `T.element` and `T.molecule_id` instead of using unqualified column names. Do remove the explicit `ASC` direction from the `ORDER BY` clause instead of specifying it, as ascending is the default. The amended query now correctly returns only unique elements from the atom table for molecule_id 'TR000' in alphabetical order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"top three\" elements: return exactly 3 rows after ordering. 2) When the question specifies \"alphabetical order\": order the results by the element column in ascending order. 3) When the question asks for \"elements of the toxicology\" for molecule TR000: filter rows where T.molecule_id equals 'TR000' exactly. 4) When eliminating duplicate elements: return only distinct values of T.element. 5) When qualifying column references: use table alias T with column names as T.element and T.molecule_id. 6) Output columns (ordered): T.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element ASC LIMIT 3;",
            "SELECT DISTINCT T.element FROM atom T WHERE T.molecule_id = 'TR000' ORDER BY T.element"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.element\nFROM atom T\nWHERE T.molecule_id = 'TR000'\nORDER BY T.element ASC\nLIMIT 3"
        ]
    },
    "668": {
        "question": "What is the display name of the user who acquired the highest amount of badges?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T1.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "highest amount of badges refers to MAX(COUNT(Name));"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN (\n    SELECT UserId, COUNT(*) AS badge_count\n    FROM badges\n    GROUP BY UserId\n) b ON u.Id = b.UserId\nORDER BY b.badge_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "354": {
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "amends": [
            "Do use `COUNT(type)` instead of `COUNT(DISTINCT types)` to count all occurrences of the type column rather than counting distinct values from a non-existent column. Do reference the correct column name `type` instead of the incorrect `types` that doesn't exist in the schema. The amended query now correctly counts all card types by the specified artist rather than attempting to count distinct values from a non-existent column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"types of cards\" illustrated by an artist: use the column \"types\" from table \"cards\" to identify card types. 2) When counting occurrences of card types for a specific artist: count all values in the \"type\" column rather than counting distinct values. 3) When filtering by artist name: use the exact literal 'Aaron Boyd' with the correct case and spacing. 4) When referencing columns: use the exact column name \"type\" instead of \"types\" for counting operations. 5) Output columns (ordered): count of card types for Aaron Boyd"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT types) FROM cards WHERE artist = 'Aaron Boyd';",
            "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd';"
        ],
        "rule_sql": [
            "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd';"
        ]
    },
    "123": {
        "question": "Provide the account ID, district and region for loan amount greater than USD300,000.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.amount > 300000",
        "amends": [],
        "rules": [
            "A2 contains district names and A3 contains region names."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.account_id, d.A2 AS district, d.A3 AS region\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.amount > 300000;"
        ],
        "rule_sql": []
    },
    "114": {
        "question": "For the first client who opened his/her account in Prague, what is his/her account ID?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'Prague' ORDER BY T1.date ASC LIMIT 1",
        "amends": [
            "Do join `account` directly with `district` on `district_id` instead of joining through `disp` and `client` tables. Do use `INNER JOIN` with predicate `T1.district_id = T2.district_id` instead of multiple joins with different join conditions. Do filter on `T2.A3 = 'Prague'` in the WHERE clause instead of the same condition but through an unnecessary table chain. Do remove the unnecessary `disp` and `client` table joins instead of including them. Do maintain the same `ORDER BY T1.date ASC` and `LIMIT 1` clauses as the original query. The amended query now correctly retrieves accounts from Prague district directly through the district relationship instead of through an indirect client-based path."
        ],
        "rules": [
            "1) When the question asks for accounts from a specific district: join account table (T1) directly with district table (T2) using the exact key equality T1.district_id = T2.district_id instead of joining through intermediate tables. 2) When filtering for accounts in Prague: use the exact literal 'Prague' with the condition T2.A3 = 'Prague'. 3) When finding the first account by opening date: order results by T1.date in ascending order and keep only the first result. 4) When the question asks for account ID: output the column T1.account_id. 5) Output columns (ordered): T1.account_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.account_id\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN district di ON c.district_id = di.district_id\nWHERE di.A3 = 'Prague'\nORDER BY a.date ASC\nLIMIT 1;",
            "SELECT account_id\nFROM account\nINNER JOIN district ON account.district_id = district.district_id\nWHERE district.A3 = 'Prague'\nORDER BY account.date ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT account.account_id\nFROM account\nJOIN district ON account.district_id = district.district_id\nWHERE district.A3 = 'Prague'\nORDER BY account.date ASC\nLIMIT 1"
        ]
    },
    "675": {
        "question": "How many users whose reputations are higher than 2000 and the number of views is higher than 1000?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Reputation > 2000 AND Views > 1000",
        "amends": [],
        "rules": [
            "reputations are higher than 2000 refer to Reputation > 2000; number of views is higher than 1000 refers to Views > 1000;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE Reputation > 2000 AND Views > 1000;"
        ],
        "rule_sql": []
    },
    "1275": {
        "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(DISTINCT P.ID) AS MalePatientsWithNormalLevels` to remove the unnecessary alias. Do reference `T1.ID` and `T2.ID` instead of `P.ID` and `L.ID` with table aliases. Do change the join condition to `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of `JOIN Laboratory L ON P.ID = L.ID` to use explicit INNER JOIN and proper aliasing. Do update the CENTROMEA filter to `T2.CENTROMEA IN ('negative', '0')` instead of `L.CENTROMEA IN ('-', '+-')` to use the correct categorical values. Do update the SSB filter to `T2.SSB IN ('negative', '0')` instead of `L.SSB IN ('-', '+-')` to match the proper value encoding. Do maintain the sex filter as `T1.SEX = 'M'` instead of `P.SEX = 'M'` with the updated alias. The amended query now correctly counts male patients with laboratory results categorized as negative or zero instead of using placeholder symbols, matching the intended logic."
        ],
        "rules": [
            "1) When counting patients with specific laboratory conditions: use COUNT(DISTINCT T1.ID) to count unique patient identifiers. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner match. 3) When filtering for male patients: include only rows where T1.SEX = 'M'. 4) When filtering for normal anti-centromere levels: include only rows where T2.CENTROMEA IN ('negative', '0'). 5) When filtering for normal anti-SSB levels: include only rows where T2.SSB IN ('negative', '0'). 6) Output columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS MalePatientsWithNormalLevels\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M'\nAND L.CENTROMEA IN ('-', '+-')\nAND L.SSB IN ('-', '+-');",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.CENTROMEA IN ('negative', '0')\nAND T2.SSB IN ('negative', '0')\nAND T1.SEX = 'M'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.CENTROMEA IN ('negative', '0')\nAND T2.SSB IN ('negative', '0')"
        ]
    },
    "59": {
        "question": "What is the website for the schools under the administrations of Mike Larson and Dante Alvarez?",
        "db_id": "california_schools",
        "ground_truth": "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez')",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName2 = 'Mike' AND AdmLName2 = 'Larson') OR (AdmFName3 = 'Mike' AND AdmLName3 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez') OR (AdmFName2 = 'Dante' AND AdmLName2 = 'Alvarez') OR (AdmFName3 = 'Dante' AND AdmLName3 = 'Alvarez');"
        ],
        "rule_sql": []
    },
    "1503": {
        "question": "Please list the product description of the products bought in transactions in euro.",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT DISTINCT T1.ProductID, T3.Description FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Currency = 'EUR'",
        "amends": [
            "Do select `DISTINCT T1.ProductID, T3.Description` instead of just `p.Description`. Do use table aliases `T1`, `T2`, and `T3` instead of full table names. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do filter on `T2.Currency = 'EUR'` instead of `c.Currency = 'Euro'` to match the correct currency code format. The amended query now correctly returns distinct product IDs with their descriptions for Euro currency transactions."
        ],
        "rules": [
            "1) When the question asks for product descriptions of products bought in transactions: select distinct T1.ProductID and T3.Description. 2) When combining tables for transaction analysis: link T1 (transactions_1k) with T2 (customers) where T1.CustomerID = T2.CustomerID and with T3 (products) where T1.ProductID = T3.ProductID using inner matches. 3) When filtering for Euro currency transactions: use the condition T2.Currency = 'EUR' exactly as specified. 4) When handling currency codes: use the exact literal 'EUR' instead of 'Euro' to match the correct format. 5) Output columns (ordered): T1.ProductID, T3.Description"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Description\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE c.Currency = 'Euro';",
            "SELECT DISTINCT T1.ProductID, T3.Description\nFROM transactions_1k T1\nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN products T3 ON T1.ProductID = T3.ProductID\nWHERE T2.Currency = 'EUR'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.ProductID, t3.Description \nFROM transactions_1k t1\nINNER JOIN customers t2 ON t1.CustomerID = t2.CustomerID\nINNER JOIN products t3 ON t1.ProductID = t3.ProductID\nWHERE t2.Currency = 'EUR'\nORDER BY t1.ProductID, t3.Description"
        ]
    },
    "1439": {
        "question": "Please list the phone numbers of the members who majored in business at the College of Agriculture and Applied Sciences.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T2.major_name = 'Business' AND T2.college = 'College of Agriculture and Applied Sciences'",
        "amends": [],
        "rules": [
            "'College of Agriculture and Applied Sciences' is the college; majored in business refers to major_name = 'Business'; phone numbers refers to phone"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.phone\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' AND maj.college = 'College of Agriculture and Applied Sciences';"
        ],
        "rule_sql": []
    },
    "1256": {
        "question": "How many patients with a abnormal C-reactive protein don't have their data recorded?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP = '+' ) AND T1.Description IS NULL",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do maintain the same join condition `ON T1.ID = T2.ID` instead of changing it. Do keep the filter `T2.CRP = '+'` unchanged. Do preserve the `T1.Description IS NULL` condition without modification. The amended query now correctly counts all patient records matching the criteria rather than distinct patient IDs, ensuring the result matches the intended behavior."
        ],
        "rules": [
            "1) When counting patients with abnormal C-reactive protein: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs.\n2) When joining Patient and Laboratory tables: use INNER JOIN with condition T1.ID = T2.ID to link matching records.\n3) When filtering for abnormal C-reactive protein: use T2.CRP = '+' to identify abnormal test results.\n4) When checking for missing patient data: use T1.Description IS NULL to find patients without recorded data.\n5) When using table aliases: use T1 for Patient table and T2 for Laboratory table consistently.\nOutput columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.CRP = '+' AND P.Description IS NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.CRP = '+' AND T1.Description IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.CRP = '+' AND T1.Description IS NULL"
        ]
    },
    "1399": {
        "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
        "db_id": "student_club",
        "ground_truth": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
        "amends": [
            "Do use an explicit `INNER JOIN` chain with table aliases `T1`, `T2`, `T3` instead of an `EXISTS` subquery with implicit joins. Do select `T3.event_name` directly in the `CASE` expression instead of checking existence through a subquery. Do place the `event_name` filter in the `CASE` condition instead of the `WHERE` clause of a subquery. Do move the member name filters `T1.first_name = 'Maya'` and `T1.last_name = 'Mclean'` to the main query's `WHERE` clause instead of the subquery. Do return 'YES' as `result` instead of 'Yes' as `did_attend` when the condition is met, and implicitly return NULL instead of 'No' for non-matching cases. The amended query now correctly returns a row with the event-specific result instead of a single yes/no existence check, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about attendance at a specific event: use a CASE expression to check if T3.event_name equals the exact literal 'Women''s Soccer' and return 'YES' when true, otherwise return NULL.\n2) When filtering for a person by name: use T1.first_name = 'Maya' and T1.last_name = 'Mclean' in the WHERE clause.\n3) When joining tables for attendance records: use INNER JOIN with T1 (member) linked to T2 (attendance) via T1.member_id = T2.link_to_member, and T2 linked to T3 (event) via T2.link_to_event = T3.event_id.\n4) When handling text literals with apostrophes: preserve the exact literal 'Women''s Soccer' with double apostrophes as shown in the schema.\n5) When returning results: use the column alias 'result' for the output instead of 'did_attend'.\nOutput columns (ordered): result"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT CASE WHEN EXISTS (\n    SELECT 1\n    FROM attendance a\n    JOIN member m ON a.link_to_member = m.member_id\n    JOIN event e ON a.link_to_event = e.event_id\n    WHERE m.first_name = 'Maya' AND m.last_name = 'Mclean'\n    AND e.event_name = 'Women''s Soccer'\n) THEN 'Yes' ELSE 'No' END AS did_attend;",
            "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result\nFROM member T1\nINNER JOIN attendance T2 ON T1.member_id = T2.link_to_member\nINNER JOIN event T3 ON T2.link_to_event = T3.event_id\nWHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean';"
        ],
        "rule_sql": [
            "SELECT \n    CASE \n        WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' \n        ELSE NULL \n    END AS result\nFROM \n    member T1\nINNER JOIN \n    attendance T2 ON T1.member_id = T2.link_to_member\nINNER JOIN \n    event T3 ON T2.link_to_event = T3.event_id\nWHERE \n    T1.first_name = 'Maya' \n    AND T1.last_name = 'Mclean';"
        ]
    },
    "1053": {
        "question": "List the football teams that has a chance creation passing class of Risky. Inidcate its short name only.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Risky'",
        "amends": [],
        "rules": [
            "chance creation passing class refers to chanceCreationPassingClass; chanceCreationPassingClass = 'Risky'; short name refers to team_short_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_short_name\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE ta.chanceCreationPassingClass = 'Risky';"
        ],
        "rule_sql": []
    },
    "925": {
        "question": "Please give the link of the website that shows more information about the circuits the Spanish Grand Prix used in 2009.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "amends": [],
        "rules": [
            "link of the website refers to url"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.url \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE r.name = 'Spanish Grand Prix' AND r.year = 2009;"
        ],
        "rule_sql": []
    },
    "646": {
        "question": "Describe the post title which got positive comments and display names of the users who posted those comments.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Title, T2.UserDisplayName FROM posts AS T1 INNER JOIN comments AS T2 ON T2.PostId = T2.Id WHERE T1.Score > 60",
        "amends": [
            "Do select only `Title` and `UserDisplayName` instead of including `PostTitle`, `CommentText`, and `UserDisplayName`. Do join `posts` with `comments` instead of joining `comments` with `posts` and `users`. Do use `INNER JOIN` on `T2.PostId = T2.Id` instead of joining on `c.PostId = p.Id` and `c.UserId = u.Id`. Do filter on `T1.Score > 60` instead of filtering on `c.Score > 60`. Do remove the `users` table join and the `comments` table alias instead of keeping them. The amended query now correctly filters posts by score and joins with comments using the proper join condition.",
            "Do use table aliases `T1` and `T2` instead of `p` and `c` for consistency. Do correct the JOIN condition to `T2.PostId = T1.Id` instead of the incorrect `T2.PostId = T2.Id` which would create a self-join condition. Do move the filter to `T1.Score > 60` instead of `T2.Score > 60` to filter on the posts table score rather than comments score. The amended query now correctly joins posts and comments tables with proper join conditions and applies the score filter to the appropriate table.",
            "Do use the join condition `T2.PostId = T2.Id` instead of `T2.PostId = T1.Id` in the INNER JOIN predicate. The amended query now correctly matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for post titles and user display names: select only T1.Title and T2.DisplayName as output columns. 2) When combining posts and comments tables: link rows where T1.Id equals T2.PostId using an inner match. 3) When filtering for positive comments: include only rows where T2.Score is greater than 60. 4) Output columns (ordered): T1.Title, T2.DisplayName",
            "1) When joining posts table (T1) and comments table (T2): link rows where T2.PostId equals T1.Id exactly and keep only matching pairs (inner match).\n2) When filtering for posts with positive comments: include only rows where T1.Score is greater than 60.\n3) When the question asks for post titles and user display names: output T1.Title and T2.UserDisplayName.\n4) Output columns (ordered): T1.Title, T2.UserDisplayName",
            "1) When joining posts and comments tables: link rows where T2.PostId equals T2.Id exactly as shown in the amends (T2.PostId = T2.Id); keep only matching pairs (inner match).\n2) When the question asks for \"post title which got positive comments\": filter posts where T1.Score is greater than 60.\n3) When selecting output columns: include T1.Title and T2.UserDisplayName in the results.\n4) Output columns (ordered): T1.Title, T2.UserDisplayName"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.Title AS PostTitle, c.Text AS CommentText, u.DisplayName AS UserDisplayName\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nJOIN users u ON c.UserId = u.Id\nWHERE c.Score > 60;",
            "SELECT p.Title, c.UserDisplayName \nFROM posts p\nINNER JOIN comments c ON p.Id = c.PostId\nWHERE c.Score > 60",
            "SELECT T1.Title, T2.UserDisplayName \nFROM posts T1 \nINNER JOIN comments T2 ON T2.PostId = T1.Id \nWHERE T1.Score > 60",
            "SELECT T1.Title, T2.UserDisplayName \nFROM posts T1 \nINNER JOIN comments T2 ON T2.PostId = T2.Id \nWHERE T1.Score > 60"
        ],
        "rule_sql": [
            "SELECT T1.Title, T2.UserDisplayName \nFROM posts T1 \nINNER JOIN comments T2 ON T2.PostId = T1.Id \nWHERE T2.Score > 60"
        ]
    },
    "1379": {
        "question": "How many meeting events were held in 2020?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(event_id) FROM event WHERE type = 'Meeting' AND SUBSTR(event_date, 1, 4) = '2020'",
        "amends": [],
        "rules": [
            "meeting events refers to type = 'Meeting'; held in 2020 refers to YEAR(event_date) = 2020"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM event WHERE type = 'Meeting' AND event_date LIKE '%2020%';"
        ],
        "rule_sql": []
    },
    "523": {
        "error": "something went wrong, tool did not call.",
        "question": "What is the annual average number of sets that were released between 1/1/2012 to 12/31/2015? Indicate the common langugage of the card.",
        "db_id": "card_games",
        "ground_truth": "SELECT (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4, T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.id = T2.id WHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY T1.releaseDate ORDER BY COUNT(T2.language) DESC LIMIT 1",
        "amends": [
            "Do use `SUM(T1.id)/COUNT(T1.id)/4` instead of `AVG(set_count)` for the annual average calculation. Do join `sets AS T1` with `set_translations AS T2` on `T1.id = T2.id` instead of using separate CTEs for yearly counts and language analysis. Do filter on `T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'` in the WHERE clause instead of in a CTE. Do group by `T1.releaseDate` instead of grouping by year in a separate CTE. Do order by `COUNT(T2.language) DESC` and add `LIMIT 1` instead of using a separate CTE with ORDER BY and LIMIT for language analysis. Do remove the CTE structure entirely instead of maintaining separate common table expressions. The amended query now correctly calculates the average set value and identifies the most common language within the specified date range, matching the RIGHT_SQL's behavior.",
            "Do cast the `SUM(T1.id)` as `REAL` instead of performing integer division, and do remove the `annual_average` alias instead of keeping it. Do use `INNER JOIN` explicitly instead of just `JOIN`, and do remove the `AS` keyword from column aliases instead of including it. Do keep all other elements including the `SELECT` list expressions, `FROM` sources with join condition, `WHERE` filters, `GROUP BY` clause, `ORDER BY` expression, and `LIMIT` unchanged as they match between both queries. The amended query now correctly handles numeric division with proper casting and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating the annual average number of sets: use SUM(T1.id)/COUNT(T1.id)/4 instead of averaging set counts. 2) When combining set information with language data: join sets AS T1 with set_translations AS T2 on T1.id = T2.id using exact key equality. 3) When filtering for sets released between 1/1/2012 to 12/31/2015: apply T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31' in the WHERE clause. 4) When grouping for analysis: group by T1.releaseDate instead of by year. 5) When identifying the most common language: order by COUNT(T2.language) DESC and keep only the top result with LIMIT 1. 6) When handling the query structure: avoid using separate common table expressions and perform all operations in a single query. Output columns (ordered): annual average sets calculation result, common language from T2.language",
            "1) When computing an annual average over multiple years: calculate the sum divided by the count divided by the number of years (4 years in this case).\n2) When handling numeric division that requires decimal precision: cast the sum to REAL before division instead of performing integer division.\n3) When selecting columns without aliases: remove the AS keyword from column aliases.\n4) When joining tables: use INNER JOIN explicitly instead of just JOIN.\n5) When filtering by date range: use the exact date literals '2012-01-01' AND '2015-12-31' with the BETWEEN operator.\n6) When grouping by release date: group by T1.releaseDate to organize results by individual dates.\n7) When ordering by language frequency: order by COUNT(T2.language) in descending order to find the most common language.\n8) When limiting to the top result: use LIMIT 1 to return only the single most common language result.\n9) Output columns (ordered): SUM(T1.id)/COUNT(T1.id)/4, T2.language"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH yearly_set_counts AS (\n    SELECT \n        strftime('%Y', releaseDate) AS year,\n        COUNT(*) AS set_count\n    FROM \n        sets\n    WHERE \n        releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\n    GROUP BY \n        year\n),\ncommon_language AS (\n    SELECT \n        language,\n        COUNT(*) AS language_count\n    FROM \n        foreign_data\n    GROUP BY \n        language\n    ORDER BY \n        language_count DESC\n    LIMIT 1\n)\nSELECT \n    AVG(set_count) AS annual_average_sets,\n    (SELECT language FROM common_language) AS common_language\nFROM \n    yearly_set_counts;",
            "SELECT \n    SUM(T1.id)/COUNT(T1.id)/4 AS annual_average,\n    T2.language AS common_language\nFROM \n    sets AS T1\nJOIN \n    set_translations AS T2 ON T1.id = T2.id\nWHERE \n    T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\nGROUP BY \n    T1.releaseDate\nORDER BY \n    COUNT(T2.language) DESC\nLIMIT 1;",
            "SELECT \n    CAST(SUM(T1.id) AS REAL) / COUNT(T1.id) / 4, \n    T2.language\nFROM \n    sets AS T1\nINNER JOIN \n    set_translations AS T2 ON T1.id = T2.id\nWHERE \n    T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\nGROUP BY \n    T1.releaseDate\nORDER BY \n    COUNT(T2.language) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(T1.id) AS REAL)/COUNT(T1.id)/4, T2.language\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T1.id = T2.id\nWHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\nGROUP BY T1.releaseDate\nORDER BY COUNT(T2.language) DESC\nLIMIT 1"
        ]
    },
    "1463": {
        "question": "List the event names which were budgeted for the food.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Food'",
        "amends": [],
        "rules": [
            "budgeted for food refers to category = 'Food'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.category = 'Food';"
        ],
        "rule_sql": []
    },
    "185": {
        "question": "What proportion of customers who have accounts at the Prague branch are female?",
        "db_id": "financial",
        "ground_truth": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id) * 100 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'Prague'",
        "amends": [
            "Do use a direct `INNER JOIN` between `district` and `client` tables on `district_id` instead of the complex CTE approach with multiple joins through `account` and `disp` tables. Do filter with `T1.A3 = 'Prague'` instead of using `LIKE '%Prague%'` for exact matching. Do calculate the percentage using `CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id) * 100` instead of `(COUNT(CASE WHEN gender = 'F' THEN 1 END) * 100.0 / COUNT(*))` for more efficient boolean aggregation. Do remove the unnecessary gender column selection and CTE structure instead of maintaining the complex nested query approach. The amended query now correctly calculates the percentage of female clients in Prague districts with direct table relationships and proper aggregation."
        ],
        "rules": [
            "1) When the question asks for customers at a specific branch location: filter the district table using exact literal matching with T1.A3 = 'Prague' instead of pattern matching. 2) When combining district and client tables: perform an inner join using the exact key equality T1.district_id = T2.district_id to link related records. 3) When calculating the proportion of female customers: use boolean aggregation with CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id) * 100 for efficient computation. 4) When handling gender values: use the exact literal 'F' for female identification as specified in the data. 5) When counting clients: use the canonical key T2.client_id for accurate counting of distinct client entities. Output columns (ordered): (single percentage value result)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH prague_accounts AS (\n    SELECT account_id\n    FROM account\n    WHERE district_id IN (SELECT district_id FROM district WHERE A3 LIKE '%Prague%')\n),\nprague_clients AS (\n    SELECT c.client_id, c.gender\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN prague_accounts pa ON d.account_id = pa.account_id\n)\nSELECT \n    (COUNT(CASE WHEN gender = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS female_percentage\nFROM prague_clients;",
            "SELECT \n    CAST(SUM(CASE WHEN c.gender = 'F' THEN 1 ELSE 0 END) AS REAL) / COUNT(c.client_id) * 100 AS female_percentage\nFROM \n    client c\nINNER JOIN \n    district d ON c.district_id = d.district_id\nWHERE \n    d.A3 = 'Prague';"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN c.gender = 'F' THEN 1 ELSE 0 END) AS REAL) / COUNT(c.client_id) * 100 AS female_proportion\nFROM district d\nINNER JOIN client c ON d.district_id = c.district_id\nWHERE d.A3 = 'Prague';"
        ]
    },
    "565": {
        "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'",
        "amends": [
            "Do use `IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished')` as `resylt` instead of `p.ClosedDate IS NULL AS is_well_finished` to provide descriptive string values rather than a boolean result. Do alias the posts table as `T2` instead of `p` and comments as `T1` instead of `c` for consistent naming. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T1.UserId` and `T1.CreationDate` in the WHERE clause instead of `c.UserId` and `c.CreationDate` to match the table aliasing. The amended query now correctly returns descriptive status strings and matches the RIGHT_SQL's behavior.",
            "Do use the alias `resylt` instead of `result` for the IIF expression output. Do include the full timestamp precision `'2013-07-12 09:08:18.0'` instead of `'2013-07-12 09:08:18'` in the WHERE filter. The amended query now correctly handles the timestamp precision and maintains the same logical behavior with the updated alias."
        ],
        "rules": [
            "1) When the question asks about a post being well-finished based on a comment: use IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') as result instead of boolean values to provide descriptive string output.\n2) When combining comments and posts tables: use INNER JOIN with T1.PostId = T2.Id to link rows where the comment's PostId matches the post's Id, keeping only matching pairs.\n3) When filtering by user ID and creation date: use T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0' with exact numeric and timestamp literals.\n4) When assigning table aliases: use T1 for comments table and T2 for posts table consistently throughout the query.\n5) Output columns (ordered): IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') as result",
            "1) When the question asks about a post being well-finished based on a ClosedDate column: use an IIF expression that returns 'well-finished' when T2.ClosedDate is not null and 'NOT well-finished' when T2.ClosedDate is null, and name the output column as 'resylt'.\n2) When filtering for a specific user comment at an exact timestamp: use T1.UserId = 23853 and T1.CreationDate = '2013-07-12 09:08:18.0' with full timestamp precision including the decimal zero.\n3) When joining comments to posts: link rows where T1.PostId equals T2.Id using an inner join to keep only matching comment-post pairs.\nOutput columns (ordered): resylt"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ClosedDate IS NULL AS is_well_finished\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE c.UserId = 23853 AND c.CreationDate = '2013-07-12 09:08:18.0';",
            "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS result\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.UserId = 23853 \nAND T1.CreationDate = '2013-07-12 09:08:18'",
            "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.UserId = 23853\nAND T1.CreationDate = '2013-07-12 09:08:18.0';"
        ],
        "rule_sql": [
            "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') as resylt\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'"
        ]
    },
    "687": {
        "question": "How many comments were added to the post with the highest score?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T2.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId GROUP BY T1.Id ORDER BY SUM(T1.Score) DESC LIMIT 1",
        "amends": [
            "Do use an `INNER JOIN` between `posts` and `comments` on `T1.Id = T2.PostId` instead of a subquery approach with `WHERE PostId = (SELECT...)`. Do add `GROUP BY T1.Id` to group comments by each post instead of counting all comments without grouping. Do add `ORDER BY SUM(T1.Score) DESC` to order by the sum of post scores instead of finding only the single highest score post. Do add `LIMIT 1` to return only the top result instead of counting comments for all posts. Do remove the CTE `highest_score_post` and its subquery structure instead of maintaining that complex nested approach. Do count `T2.Id` specifically instead of using `COUNT(*)` for more precise counting of comment records. The amended query now correctly identifies the post with the highest total engagement (sum of scores) and counts its comments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining posts and comments tables: link rows where T1.Id equals T2.PostId and keep only matching pairs (inner match). 2) When the question asks for \"highest score\": rank posts by SUM(T1.Score) in descending order and keep the first 1 row. 3) When counting comments: compute the number of rows using T2.Id as the counting key. 4) When grouping comments by post: organize results by T1.Id and compute the comment count per group. 5) Output columns (ordered): comment_count"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH highest_score_post AS (\n    SELECT Id\n    FROM posts\n    WHERE Score = (SELECT MAX(Score) FROM posts)\n)\nSELECT COUNT(*) AS comment_count\nFROM comments\nWHERE PostId = (SELECT Id FROM highest_score_post);",
            "SELECT COUNT(T2.Id) AS comment_count\nFROM posts T1\nINNER JOIN comments T2 ON T1.Id = T2.PostId\nGROUP BY T1.Id\nORDER BY SUM(T1.Score) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(c.Id) AS comment_count\nFROM posts p\nINNER JOIN comments c ON p.Id = c.PostId\nWHERE p.Id = (\n    SELECT Id \n    FROM posts \n    ORDER BY Score DESC \n    LIMIT 1\n)"
        ]
    },
    "946": {
        "question": "Please list the location coordinates of the US circuits.",
        "db_id": "formula_1",
        "ground_truth": "SELECT lat, lng FROM circuits WHERE country = 'USA'",
        "amends": [
            "Do remove the `name` column from the SELECT list instead of including it, while keeping the `lat` and `lng` columns and maintaining the same WHERE filter condition `country = 'USA'`. The amended query now correctly returns only the latitude and longitude coordinates for USA circuits, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for location coordinates: include only the latitude and longitude columns from the circuits table.\n2) When filtering for US circuits: apply the condition country = 'USA' exactly as specified.\n3) When the question does not request circuit names: exclude the name column from the output.\n4) Output columns (ordered): lat, lng"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, lat, lng FROM circuits WHERE country = 'USA';",
            "SELECT lat, lng FROM circuits WHERE country = 'USA';"
        ],
        "rule_sql": [
            "SELECT lat, lng FROM circuits WHERE country = 'USA';"
        ]
    },
    "984": {
        "question": "What is the website of the constructor who tallied the most total wins.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1",
        "amends": [
            "Do select `T1.url` instead of `c.url` and use table aliases `T1` and `T2` instead of `c` and subquery aliases. Do use a direct `INNER JOIN` on `constructorStandings AS T2` instead of joining with a subquery that calculates `SUM(wins)`. Do join on `T1.constructorId = T2.constructorId` instead of joining with a subquery result. Do remove the unnecessary aggregation `SUM(wins)` and grouping `GROUP BY constructorId` instead of keeping them. Do order by `T2.wins DESC` directly instead of ordering by the calculated `total_wins DESC`. Do keep the `LIMIT 1` but apply it after the join instead of within a subquery. The amended query now correctly retrieves the constructor URL by joining directly with constructor standings and ordering by wins to find the top constructor, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the website of a constructor: select T1.url as the output column. 2) When combining constructor and constructor standings data: link rows where T1.constructorId equals T2.constructorId and keep only matching pairs (inner match). 3) When the question asks for the constructor with the most total wins: order all rows by T2.wins in descending order. 4) When seeking the single top result: keep only the first row after ordering. 5) Output columns (ordered): T1.url"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.url\nFROM constructors c\nJOIN (\n    SELECT constructorId, SUM(wins) AS total_wins\n    FROM constructorStandings\n    GROUP BY constructorId\n    ORDER BY total_wins DESC\n    LIMIT 1\n) AS max_wins ON c.constructorId = max_wins.constructorId;",
            "SELECT T1.url \nFROM constructors AS T1\nINNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId\nORDER BY T2.wins DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT c.url\nFROM constructors c\nINNER JOIN constructorStandings cs ON c.constructorId = cs.constructorId\nORDER BY cs.wins DESC\nLIMIT 1;"
        ]
    },
    "1263": {
        "question": "Among the patients whose level of Hematoclit isn't normal, which patient has the highest anti-Cardiolipin antibody concentration? Please list his or her ID.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 on T1.ID = T3.ID WHERE (T3.HCT >= 52 OR T3.HCT <= 29) ORDER BY T2.`aCL IgA` DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Hematoclit is normal refers to 29 < N < 52; highest anti-Cardiolipin antibody concentration refers to MAX(`aCL IgA`);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT E.ID\nFROM Examination E\nJOIN Laboratory L ON E.ID = L.ID\nWHERE L.HCT <= 29 OR L.HCT >= 52\nORDER BY E.`aCL IgA` DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1441": {
        "question": "How many members have education major in the College of Education & Human Services?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member' AND T2.major_name LIKE '%Education%' AND T2.college = 'College of Education & Human Services'",
        "amends": [
            "Do use `COUNT(T1.member_id)` instead of `COUNT(*)` to count specific non-null values. Do add `INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major` instead of using a subquery for the join. Do add `T1.position = 'Member'` filter instead of omitting it. Do change the major condition to `T2.major_name LIKE '%Education%'` instead of exact match `major_name = 'education'` to include variations. Do keep `T2.college = 'College of Education & Human Services'` condition. Do remove the subquery approach and instead use an explicit join with proper table aliases. The amended query now correctly filters for members with position 'Member' and uses pattern matching for education-related majors while maintaining the college filter through a proper join."
        ],
        "rules": [
            "1) When counting members: use COUNT(T1.member_id) instead of COUNT(*) to count specific non-null values. 2) When joining member and major tables: use INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major to link rows where the canonical keys are equal. 3) When filtering for member position: include T1.position = 'Member' condition to only include members with this exact position. 4) When matching education majors: use T2.major_name LIKE '%Education%' instead of exact match to include variations of education-related majors. 5) When filtering by college: keep T2.college = 'College of Education & Human Services' condition with exact literal value. Output columns (ordered): education_major_members"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS education_major_members\nFROM member\nWHERE link_to_major IN (SELECT major_id FROM major WHERE major_name = 'education' AND college = 'College of Education & Human Services');",
            "SELECT COUNT(T1.member_id) \nFROM member AS T1\nINNER JOIN major AS T2 ON T2.major_id = T1.link_to_major\nWHERE T1.position = 'Member'\nAND T2.major_name LIKE '%Education%'\nAND T2.college = 'College of Education & Human Services'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.member_id) AS education_major_members\nFROM member AS T1\nINNER JOIN major AS T2 ON T2.major_id = T1.link_to_major\nWHERE T1.position = 'Member'\nAND T2.major_name LIKE '%Education%'\nAND T2.college = 'College of Education & Human Services'"
        ]
    },
    "1239": {
        "question": "Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )",
        "amends": [],
        "rules": [
            "age = SUBTRACT(year(current_timestamp), year(Birthday)); patient with two or more laboratory examinations refers to COUNT(ID) > 2; hematoclit level exceeded the normal range refers to HCT > = 52;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age\nFROM Patient P\nWHERE P.ID IN (\n    SELECT L.ID\n    FROM Laboratory L\n    WHERE L.HCT >= 52\n    GROUP BY L.ID\n    HAVING COUNT(L.ID) >= 2\n);"
        ],
        "rule_sql": []
    },
    "958": {
        "question": "Which driver has the fastest lap time? Please give their forenames and surnames.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.forename, T2.surname, T1.fastestLapTime FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T1.fastestLapTime IS NOT NULL ORDER BY T1.fastestLapTime ASC LIMIT 1",
        "amends": [
            "Do select `T2.forename`, `T2.surname`, and `T1.fastestLapTime` instead of only `d.forename` and `d.surname`. Do use `INNER JOIN` with aliases `T1` for `results` and `T2` for `drivers` instead of `JOIN` with aliases `r` and `d`. Do filter on `T1.fastestLapTime IS NOT NULL` instead of `r.milliseconds IS NOT NULL`. Do order by `T1.fastestLapTime ASC` instead of `r.milliseconds ASC`. The amended query now correctly identifies the fastest lap time rather than milliseconds and includes the fastest lap time in the output."
        ],
        "rules": [
            "1) When the question asks for the fastest lap time: include T1.fastestLapTime in the output columns. 2) When joining results and drivers tables: use INNER JOIN with T1 for results and T2 for drivers, linking rows where T1.driverId = T2.driverId. 3) When filtering for valid lap times: include only rows where T1.fastestLapTime IS NOT NULL. 4) When ordering to find the fastest time: sort rows by T1.fastestLapTime in ascending order. 5) When limiting to the top result: keep only the first row after ordering. 6) Output columns (ordered): T2.forename, T2.surname, T1.fastestLapTime"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.milliseconds IS NOT NULL\nORDER BY r.milliseconds ASC\nLIMIT 1;",
            "SELECT T2.forename, T2.surname, T1.fastestLapTime\nFROM results T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T1.fastestLapTime IS NOT NULL\nORDER BY T1.fastestLapTime ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.forename, T2.surname, T1.fastestLapTime \nFROM results T1 \nINNER JOIN drivers T2 ON T1.driverId = T2.driverId \nWHERE T1.fastestLapTime IS NOT NULL \nORDER BY T1.fastestLapTime ASC \nLIMIT 1;"
        ]
    },
    "1193": {
        "question": "Excluding all P only ANA Pattern patients, how many of the remainder are women born between 1980 and 1989?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.`ANA Pattern` != 'P' AND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989' AND T1.SEX = 'F'",
        "amends": [
            "Do use `T1.ID` and `T2.ID` as table aliases instead of `P.ID` and `E.ID`. Do change the join condition to `T1.ID = T2.ID` instead of `P.ID = E.ID`. Do move the `ANA Pattern` filter from an OR condition with NULL check to a direct `T2.ANA Pattern != 'P'` instead of `(E.ANA Pattern IS NULL OR E.ANA Pattern != 'P')`. Do use `STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989'` for year extraction instead of `P.Birthday BETWEEN '1980-01-01' AND '1989-12-31'`. Do maintain `T1.SEX = 'F'` instead of `P.SEX = 'F'`. The amended query now correctly filters by year range using date functions and simplifies the ANA Pattern condition while maintaining the same join logic and distinct patient count."
        ],
        "rules": [
            "1) When excluding patients with ANA Pattern 'P': filter out rows where T2.\"ANA Pattern\" equals 'P' exactly. 2) When counting distinct patients: count unique values of T1.ID. 3) When filtering for female patients: include only rows where T1.SEX equals 'F' exactly. 4) When filtering for birth years between 1980 and 1989: extract the year from T1.Birthday and include only rows where the year is between '1980' and '1989' inclusive. 5) When combining Patient and Examination tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match). 6) Output columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'F' \nAND P.Birthday BETWEEN '1980-01-01' AND '1989-12-31'\nAND (E.`ANA Pattern` IS NULL OR E.`ANA Pattern` != 'P');",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nJOIN Examination T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F' \nAND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989'\nAND T2.\"ANA Pattern\" != 'P'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.\"ANA Pattern\" != 'P'\nAND T1.SEX = 'F'\nAND strftime('%Y', T1.Birthday) BETWEEN '1980' AND '1989'"
        ]
    },
    "575": {
        "question": "What is the badge name that user 'SilentGhost' obtained?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'SilentGhost'",
        "amends": [],
        "rules": [
            "\"SilentGhost\" is the DisplayName of user;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'SilentGhost';"
        ],
        "rule_sql": []
    },
    "1390": {
        "question": "Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) AS REAL) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "amends": [],
        "rules": [
            "percentage = DIVIDE(SUM(cost where event_name = 'Yearly Kickoff'), SUM(cost)) * 100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN e.event_name = 'Yearly Kickoff' THEN ex.cost ELSE 0 END) / SUM(ex.cost)) * 100 AS percentage_cost\nFROM \n    event e\nJOIN \n    budget b ON e.event_id = b.link_to_event\nJOIN \n    expense ex ON b.budget_id = ex.link_to_budget;"
        ],
        "rule_sql": []
    },
    "279": {
        "question": "What is the label for bond ID TR001_10_11?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_10_11'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.label\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_id = 'TR001_10_11';"
        ],
        "rule_sql": []
    },
    "94": {
        "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id , ( SELECT MAX(A11) - MIN(A11) FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "amends": [
            "Do use a single query with joins instead of CTEs, and do `INNER JOIN` tables directly on proper foreign keys like `T1.district_id = T2.district_id` instead of joining through multiple CTEs. Do move the oldest female client filter to a subquery in the `WHERE` clause instead of using a separate CTE. Do calculate the salary gap directly in the `SELECT` list with `(SELECT MAX(A11) - MIN(A11) FROM district)` instead of using a separate CTE. Do add proper table aliases like `account AS T1` instead of using full table names. Do change the join condition from `c.client_id = d.client_id` to proper account-based joins like `T1.account_id = T3.account_id`. Do remove the `avg_salary` column reference and instead filter by `district_id` in the WHERE clause. Do add `ORDER BY T2.A11 DESC LIMIT 1` instead of ordering by birth date in a CTE. The amended query now correctly identifies accounts from the district of the oldest female client and returns the salary gap with proper join relationships.",
            "Do join `account` directly with `district` on `district_id` instead of joining through `disp` and `client` tables to reach district. Do remove the `gender = 'F'` filter from the WHERE clause instead of keeping it as a direct condition. Do move the district selection logic to the JOIN condition with `district` instead of using it in WHERE filters. Do remove the subquery checking `A11 = MIN(A11)` for specific districts instead of keeping that redundant filtering. Do add `ORDER BY T2.A11 DESC LIMIT 1` instead of grouping by account_id and omitting ordering. Do remove the GROUP BY clause entirely instead of grouping by account_id. Do simplify the salary gap calculation to use the global district table instead of filtering by specific districts. The amended query now correctly identifies accounts in the target district and selects the one with highest A11 value, matching RIGHT_SQL's behavior.",
            "Do use the `salary_gap` alias instead of omitting it for the subquery result. Do change the WHERE filter to use `T2.district_id = (subquery)` instead of `T4.gender = 'F' AND T4.birth_date = (subquery)`. Do modify the subquery to select `district_id` instead of `MIN(birth_date)` and add `ORDER BY birth_date ASC` instead of just finding the minimum birth date. Do change the ORDER BY direction to `DESC` instead of `ASC` for `T2.A11`. The amended query now correctly identifies the district_id of the oldest female client first, then filters accounts by that district instead of incorrectly trying to match both gender and exact birth date simultaneously, which could return no results if no client has the exact minimum birth date."
        ],
        "rules": [
            "1) When the question asks for female clients: filter rows where gender equals 'F' exactly.\n2) When identifying the oldest client: order rows by birth_date in ascending order and take the first row.\n3) When calculating salary gap: compute the difference between maximum and minimum values of A11 from the district table.\n4) When joining account and district tables: link rows where T1.district_id equals T2.district_id using exact key equality.\n5) When joining client and account tables: link rows using account-based joins like T1.account_id = T3.account_id.\n6) When filtering for specific district: use the district_id from the oldest female client in WHERE clause conditions.\n7) When ordering for salary analysis: order by T2.A11 in descending order to identify highest values.\n8) When outputting results: include account numbers and the computed salary gap.\n9) Output columns (ordered): account_id, (SELECT MAX(A11) - MIN(A11) FROM district)",
            "1) When the question asks for female clients: filter clients using the exact literal 'F' for the gender column.\n2) When the question asks for oldest clients: order clients by birth_date in ascending order and take the first row.\n3) When the question asks for lowest average salary: find the minimum value of the A11 column from the district table.\n4) When combining account and district tables: link rows where account.district_id equals district.district_id using an inner match.\n5) When calculating salary gap: compute the difference between the maximum A11 value and minimum A11 value from the district table.\n6) When selecting specific accounts: use the district_id from the oldest female client to filter accounts.\n7) Output columns (ordered): T1.account_id, (MAX(T2.A11) - MIN(T2.A11)) AS salary_gap",
            "1) When the question asks for female clients: filter clients where gender equals exactly 'F' using the exact token T4.gender.\n2) When identifying the oldest clients: find the minimum birth date among female clients and use this to identify the corresponding district_id.\n3) When combining account and district tables: link rows where T1.district_id equals T2.district_id exactly as shown in the amends.\n4) When combining account and disp tables: link rows where T1.account_id equals T3.account_id exactly as shown in the amends.\n5) When combining disp and client tables: link rows where T3.client_id equals T4.client_id exactly as shown in the amends.\n6) When ordering by average salary: sort T2.A11 in descending order (DESC) to find the lowest average salary.\n7) When calculating salary gap: compute the difference between maximum and minimum A11 values from the district table using the exact expression MAX(A11) - MIN(A11).\n8) When limiting results: keep only the first row (LIMIT 1) after ordering.\n9) When using subqueries for district filtering: select district_id from client table ordered by birth_date ASC to find the district of the oldest female client.\n10) Output columns (ordered): T1.account_id, salary_gap"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH OldestFemaleClients AS (\n    SELECT c.client_id, c.birth_date, d.account_id, dt.A11 AS avg_salary\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN account a ON d.account_id = a.account_id\n    JOIN district dt ON c.district_id = dt.district_id\n    WHERE c.gender = 'F'\n    ORDER BY c.birth_date ASC\n    LIMIT 1\n),\nSalaryGap AS (\n    SELECT MAX(A11) AS max_salary, MIN(A11) AS min_salary, MAX(A11) - MIN(A11) AS gap\n    FROM district\n)\nSELECT o.account_id, s.gap\nFROM OldestFemaleClients o, SalaryGap s\nWHERE o.avg_salary = s.min_salary;",
            "SELECT \n    T1.account_id,\n    (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM \n    account AS T1\n    INNER JOIN disp AS T2 ON T1.account_id = T2.account_id\n    INNER JOIN client AS T3 ON T2.client_id = T3.client_id\n    INNER JOIN district AS T4 ON T3.district_id = T4.district_id\nWHERE \n    T3.gender = 'F' \n    AND T3.district_id = (\n        SELECT district_id \n        FROM client \n        WHERE gender = 'F' \n        ORDER BY birth_date ASC \n        LIMIT 1\n    )\n    AND T4.A11 = (\n        SELECT MIN(A11) \n        FROM district \n        WHERE district_id IN (\n            SELECT district_id \n            FROM client \n            WHERE gender = 'F' \n            ORDER BY birth_date ASC \n            LIMIT 1\n        )\n    )\nGROUP BY T1.account_id",
            "SELECT \n    T1.account_id,\n    (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM \n    account AS T1\nINNER JOIN \n    district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN \n    disp AS T3 ON T1.account_id = T3.account_id\nINNER JOIN \n    client AS T4 ON T3.client_id = T4.client_id\nWHERE \n    T4.gender = 'F' AND\n    T4.birth_date = (SELECT MIN(birth_date) FROM client WHERE gender = 'F')\nORDER BY \n    T2.A11 ASC\nLIMIT 1;",
            "SELECT \n    T1.account_id,\n    (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM \n    account AS T1\nINNER JOIN \n    district AS T2 ON T1.district_id = T2.district_id\nWHERE \n    T2.district_id = (\n        SELECT district_id \n        FROM client \n        WHERE gender = 'F' \n        ORDER BY birth_date ASC \n        LIMIT 1\n    )\nORDER BY \n    T2.A11 DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT \n    T1.account_id, \n    (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM account T1\nJOIN district T2 ON T1.district_id = T2.district_id\nJOIN disp T3 ON T1.account_id = T3.account_id\nJOIN client T4 ON T3.client_id = T4.client_id\nWHERE T4.gender = 'F'\nAND T4.district_id = (\n    SELECT district_id \n    FROM client \n    WHERE gender = 'F' \n    ORDER BY birth_date ASC \n    LIMIT 1\n)\nORDER BY T2.A11 ASC\nLIMIT 1;"
        ]
    }
}