{
    "174": {
        "sql": [
            "SELECT strftime('%Y', birth_date) AS birth_year FROM client WHERE client_id = 130;",
            "SELECT STRFTIME('%Y', T1.birth_date) FROM client AS T1 INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T2 ON T3.account_id = T2.account_id WHERE T2.account_id = 130"
        ],
        "question": "What year was account owner number 130 born?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', T1.birth_date) FROM client AS T1 INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T2 ON T3.account_id = T2.account_id WHERE T2.account_id = 130",
        "amends": [
            "Do add `INNER JOIN disp AS T3 ON T1.client_id = T3.client_id` and `INNER JOIN account AS T2 ON T3.account_id = T2.account_id` instead of querying only the `client` table. Do change the filter to `T2.account_id = 130` instead of `client_id = 130` to reference the account table instead of the client table. Do remove the alias `AS birth_year` from the `STRFTIME` expression instead of keeping it. Do use table aliases `T1.birth_date` instead of just `birth_date` to specify the table source. The amended query now correctly joins the client, disp, and account tables to find clients associated with a specific account ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "1363": {
        "sql": [
            "SELECT DISTINCT department FROM major WHERE college = 'Humanities and Social Sciences';",
            "SELECT major.department FROM major WHERE major.college = 'College of Humanities and Social Sciences';"
        ],
        "question": "List all of the College of Humanities and Social Sciences' departments.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it, and do use the exact college name `'College of Humanities and Social Sciences'` instead of the incomplete `'Humanities and Social Sciences'` to ensure accurate filtering of departments from the major table."
        ],
        "rules": []
    },
    "552": {
        "sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'csgillespie';"
        ],
        "question": "Please list the names of the badges obtained by csgillespie.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user"
        ]
    },
    "1432": {
        "sql": [
            "SELECT (COUNT(CASE WHEN i.amount = 50 AND i.source = 'Student_Club' THEN 1 END) * 100.0 / COUNT(m.member_id)) AS percentage\nFROM member m\nLEFT JOIN income i ON m.member_id = i.link_to_member\nWHERE m.t_shirt_size = 'Medium';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) AS REAL) / COUNT(T2.income_id) * 100 AS percentage\nFROM \n    member T1\nINNER JOIN \n    income T2 ON T1.member_id = T2.link_to_member\nWHERE \n    T1.t_shirt_size = 'medium' \n    AND T1.position = 'Member'",
            "SELECT SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) * 100 / COUNT(T2.income_id) \nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nWHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium';"
        ],
        "question": "Among the members with t-shirt size of medium, what is the percentage of the amount 50 received by the Student_Club?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) AS REAL) * 100 / COUNT(T2.income_id) FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END)` instead of `COUNT(CASE WHEN i.amount = 50 AND i.source = 'Student_Club' THEN 1 END)` for accurate percentage calculation. Do change from `LEFT JOIN` to `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of `m.member_id = i.link_to_member` to exclude members without income records. Do add filter `T1.position = 'Member'` instead of omitting it to restrict to members only. Do remove the `source = 'Student_Club'` condition instead of keeping it to count all income records meeting the amount criteria. Do use `COUNT(T2.income_id)` instead of `COUNT(m.member_id)` to properly count income records rather than members. Do add explicit `CAST` to `REAL` instead of implicit conversion for precise floating-point division. The amended query now correctly calculates the percentage of income records with amount 50 among all income records for medium-sized members.",
            "Do move the division operation to after the multiplication instead of before it, changing the calculation order from `SUM(...) / COUNT(...) * 100` to `SUM(...) * 100 / COUNT(...)` to ensure correct percentage calculation. Do change the case sensitivity in the WHERE clause from `'medium'` to `'Medium'` to match the actual data values. Do remove the alias `AS percentage` from the SELECT clause instead of keeping it, as it's not needed in the result. Do reorder the WHERE conditions from `t_shirt_size` first to `position` first, though this is purely cosmetic. The amended query now correctly calculates the percentage of income records with amount equal to 50 among all income records for medium-sized member positions, with proper case matching and mathematical operation order."
        ],
        "rules": [
            "t_shirt_size = 'Medium' where position = 'Member'; percentage = DIVIDE(COUNT(amount = 50), COUNT(member_id)) * 100"
        ]
    },
    "1002": {
        "sql": [
            "WITH youngest_driver AS (\n    SELECT driverId, forename || ' ' || surname AS full_name, nationality, dob\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 1\n),\nfirst_race AS (\n    SELECT r.raceId, r.name AS race_name, ra.date\n    FROM results r\n    JOIN races ra ON r.raceId = ra.raceId\n    JOIN youngest_driver yd ON r.driverId = yd.driverId\n    ORDER BY ra.date ASC\n    LIMIT 1\n)\nSELECT yd.full_name, yd.nationality, fr.race_name\nFROM youngest_driver yd, first_race fr;",
            "SELECT T1.forename, T1.surname, T1.nationality, T3.name\nFROM drivers AS T1\nINNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T2.raceId = T3.raceId\nORDER BY JULIANDAY(T1.dob) DESC\nLIMIT 1;"
        ],
        "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
        "amends": [
            "Do use `SELECT T1.forename, T1.surname, T1.nationality, T3.name` instead of `SELECT yd.full_name, yd.nationality, fr.race_name` to return individual name components and race name separately. Do use `FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId` instead of the CTE approach with `youngest_driver` and `first_race` to directly join through driver standings. Do add `ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1` instead of the complex CTE structure to find the youngest driver based on date of birth. Do remove the concatenated `full_name` and instead return `forename` and `surname` as separate columns. The amended query now correctly identifies the youngest driver through driver standings data and returns the appropriate race information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "full name refers to forename+surname; Youngest racer = MAX(dob)"
        ]
    },
    "1342": {
        "sql": [
            "SELECT SUM(e.cost) AS total_cost\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Posters' AND ev.event_date = '2019-09-04';",
            "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04';"
        ],
        "question": "What was the cost for the \"Posters\" on 2019/9/4?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04'",
        "amends": [
            "Do select only `cost` instead of `SUM(e.cost) AS total_cost` with aggregation. Do use `FROM expense` alone instead of joining with `budget` and `event` tables. Do filter directly on `expense_description = 'Posters'` and `expense_date = '2019-09-04'` instead of filtering through joined tables on `event_name` and `event_date`. Do remove the unnecessary joins and aggregation to query the expense table directly with the appropriate filters, matching the correct query behavior."
        ],
        "rules": [
            "'Poster' is an event description; on 2019/9/14 refers to event_date = '2019-09-04'"
        ]
    },
    "1231": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' \nAND strftime('%Y', P.Birthday) BETWEEN '1936' AND '1956'\nAND L.CPK >= 250;"
        ],
        "question": "For patient born between 1936-1956, how many male patients have creatinine phosphokinase beyond the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' AND T1.SEX = 'M' AND T2.CPK >= 250",
        "amends": [],
        "rules": [
            "born between 1936-1956 refers to year(Birthday) BETWEEN '1936' AND '1956'; male patients refers to sex = 'M'; creatinine phosphokinase beyond the normal range refers to CPK > = 250; Should consider DISTINCT in the final result;"
        ]
    },
    "252": {
        "sql": [
            "SELECT a2.atom_id, a2.element\nFROM atom a1\nJOIN connected c ON a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2\nJOIN atom a2 ON (a2.atom_id = c.atom_id OR a2.atom_id = c.atom_id2) AND a2.atom_id != a1.atom_id\nWHERE a1.element = 'pb';",
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'pb'\nUNION\nSELECT T2.atom_id, T2.atom_id2\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id2\nWHERE T1.element = 'pb'",
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'pb'"
        ],
        "question": "What are the atoms that can bond with the atom that has the element lead?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'pb'",
        "amends": [
            "Do select `T2.atom_id` and `T2.atom_id2` instead of `a2.atom_id` and `a2.element`. Do use `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of complex `JOIN` conditions with `OR` clauses and self-join logic. Do remove the additional `atom a2` table join and the `a2.atom_id != a1.atom_id` filter instead of keeping them. Do simplify the `WHERE` clause to only filter `T1.element = 'pb'` instead of maintaining the original condition. The amended query now correctly identifies connected atoms through a direct join without redundant self-join logic and matches the RIGHT_SQL's behavior.",
            "Do remove the second `UNION` query block entirely instead of keeping it, as the right query only needs to find connections where lead atoms are the starting point. Do maintain the `SELECT T2.atom_id, T2.atom_id2` projection and `INNER JOIN connected T2 ON T1.atom_id = T2.atom_id` join condition instead of duplicating it with a reversed join, since the right logic correctly identifies connections originating from lead atoms without needing to also check connections ending at lead atoms. The amended query now matches RIGHT_SQL's behavior by focusing solely on connections where the lead atom is the source rather than both source and destination."
        ],
        "rules": [
            "atom that has the element lead refers to atom_id where element = 'pb'"
        ]
    },
    "240": {
        "sql": [
            "SELECT element FROM atom WHERE molecule_id = 'TR004';"
        ],
        "question": "List all the elements of the toxicology of the molecule \"TR004\".",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
        "amends": [],
        "rules": [
            "TR004 is the molecule id;"
        ]
    },
    "694": {
        "sql": [
            "SELECT c.Text, u.DisplayName\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE c.PostId = (SELECT Id FROM posts WHERE Title = 'Analysing wind data with R')\nORDER BY c.CreationDate DESC\nLIMIT 10;",
            "SELECT T3.Text, T1.DisplayName\nFROM users T1\nJOIN posts T2 ON T1.Id = T2.OwnerUserId\nJOIN comments T3 ON T2.Id = T3.PostId\nWHERE T2.Title = 'Analysing wind data with R'\nORDER BY T1.CreationDate DESC\nLIMIT 10"
        ],
        "question": "Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Text, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T2.Title = 'Analysing wind data with R' ORDER BY T1.CreationDate DESC LIMIT 10",
        "amends": [
            "Do join `users` with `posts` on `T1.Id = T2.OwnerUserId` instead of directly joining `comments` with `users`, and then join `comments` with `posts` on `T2.Id = T3.PostId` instead of using a subquery. Do filter on `T2.Title` directly in the WHERE clause instead of using a subquery to find the PostId. Do order by `T1.CreationDate` instead of `c.CreationDate` to sort by user creation date rather than comment creation date. Do use table aliases `T1`, `T2`, and `T3` consistently instead of mixed aliasing. The amended query now correctly retrieves comments for the specific post by joining through the proper relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "the latest comment refers to MAX(CreationDate);"
        ]
    },
    "380": {
        "sql": [
            "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';"
        ],
        "question": "List the edhrecRank for cards with frame version 2015.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "amends": [],
        "rules": []
    },
    "1383": {
        "sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE z.city = 'Georgetown' AND z.state = 'South Carolina';"
        ],
        "question": "State the name of students from Georgetown, South Carolina.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Georgetown' AND T2.state = 'South Carolina'",
        "amends": [],
        "rules": [
            "name of students means the full name; full name refers to first_name, last_name; Georgetown is a city; South Carolina is a state"
        ]
    },
    "921": {
        "sql": [
            "SELECT r.raceId, r.year, r.round, r.name AS race_name, r.date, r.time, c.name AS circuit_name, c.location, c.country\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit';",
            "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Silverstone Circuit'"
        ],
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "amends": [
            "Do select `T1.url` instead of `r.raceId, r.year, r.round, r.name AS race_name, r.date, r.time, c.name AS circuit_name, c.location, c.country`. Do use `DISTINCT` instead of omitting it. Do join `circuits AS T1` and `races AS T2` with `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of joining `races r` and `circuits c` with `JOIN` on `r.circuitId = c.circuitId`. Do filter on `T1.name = 'Silverstone Circuit'` instead of `c.name = 'Silverstone Circuit'`. Do remove the table aliases `r` and `c` instead of keeping them. The amended query now correctly returns distinct URLs for the Silverstone Circuit instead of race details."
        ],
        "rules": [
            "more information refers to url"
        ]
    },
    "192": {
        "sql": [
            "SELECT AVG(l.amount) AS average_loan_amount\nFROM loan l\nJOIN trans t ON l.account_id = t.account_id\nWHERE l.status IN ('C', 'D') AND t.k_symbol = 'POPLATEK PO OBRATU';",
            "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'"
        ],
        "question": "What is the average amount of loan which are still on running contract with statement issuance after each transaction?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'",
        "amends": [
            "Do join `account AS T1` instead of omitting it, and do use `INNER JOIN loan AS T2` instead of joining with `trans t`. Do filter on `T2.status IN ('C', 'D')` instead of filtering on the wrong table's status, and do filter on `T1.frequency = 'POPLATEK PO OBRATU'` instead of filtering on `trans.k_symbol`. Do remove the alias `AS average_loan_amount` instead of keeping it. The amended query now correctly calculates average loan amounts for accounts with the specified frequency and loan status, matching the intended behavior."
        ],
        "rules": [
            "status = 'C' stands for running contract, OK so far; status = 'D' stands for running contract, client in debt. 'POPLATEK PO OBRATU' stands for issuance after transaction"
        ]
    },
    "798": {
        "sql": [
            "SELECT s.superhero_name, p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');",
            "SELECT T2.publisher_name\nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nWHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')"
        ],
        "question": "What is the publisher for Hawkman, Karate Kid and Speedy?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')",
        "amends": [
            "Do select only `publisher_name` instead of including `superhero_name` in the SELECT list. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference the publisher table as `T2` instead of `p` and superhero table as `T1` instead of `s` for consistent table aliasing. The amended query now correctly returns only publisher names for the specified superheroes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "publisher refers to publisher_name; Hawkman refers to superhero_name = 'Hawkman'; Karate Kid refers to superhero_name = 'Karate Kid'; Speedy refers to superhero_name = 'Speedy';"
        ]
    },
    "1273": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Examination E ON P.ID = E.ID \nWHERE E.Diagnosis = 'SLE' \nAND (E.SSB IN('-', '+-'));",
            "SELECT COUNT(*) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.SSB = 'negative' OR '0'\nAND T1.Diagnosis = 'SLE'"
        ],
        "question": "How many patients have a normal anti-SSB and are diagnosed with SLE in the examination?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Diagnosis = 'SLE'",
        "amends": [
            "Do join `Laboratory AS T2` instead of `Examination E` and use `INNER JOIN` instead of `JOIN`. Do change the join condition to `T1.ID = T2.ID` instead of `P.ID = E.ID`. Do move the diagnosis filter to `T1.Diagnosis = 'SLE'` instead of `E.Diagnosis = 'SLE'` and change the SSB condition to `T2.SSB = 'negative' OR '0'` instead of `E.SSB IN('-', '+-')`. Do remove the DISTINCT modifier from the count instead of keeping it. The amended query now correctly counts patients with SLE diagnosis and negative SSB laboratory results.",
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patients instead of all matching rows. Do add explicit `AS` aliases for both tables instead of omitting them. Do simplify the `WHERE` condition to `T2.SSB = 'negative' OR '0'` instead of the more complex `(T2.SSB = 'negative' OR T2.SSB = '0')` while maintaining the same logic. The amended query now correctly counts distinct patients with SLE diagnosis who have either negative or 0 SSB values, matching the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `T2.SSB` condition instead of keeping them, and do change the `OR` condition to `OR '0'` instead of `OR T2.SSB = '0'` in the WHERE clause. The amended query now correctly filters for patients with SLE diagnosis and either SSB value of 'negative' or any row where '0' evaluates to true, matching the RIGHT_SQL's behavior.",
            "Do move the `T2.SSB` filter condition to be part of the main WHERE clause instead of using parentheses, and do change the predicate from `T2.SSB = 'negative' OR T2.SSB = '0'` to `T2.SSB = 'negative' OR '0'` instead of the explicit column comparison for the second value. The amended query now correctly matches the RIGHT_SQL's behavior with the simplified filter logic.",
            "Do remove the parentheses around the `T2.SSB` condition instead of keeping them, and do change the logical operator precedence by placing the `OR` condition directly between `T2.SSB = 'negative'` and `'0'` instead of using separate equality checks. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and all filter conditions including `T1.Diagnosis = 'SLE'` instead of altering them. The amended query now correctly handles the OR logic without parentheses and matches the RIGHT_SQL's behavior.",
            "Do move the `T2.SSB` filter condition to be part of the main WHERE clause instead of wrapping it in parentheses, and do change the predicate from `T2.SSB = 'negative' OR T2.SSB = '0'` to `T2.SSB = 'negative' OR '0'` instead of the explicit column comparison for the second value. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Diagnosis = 'SLE'` filter without changes. The amended query now correctly handles the SSB filter logic and matches the RIGHT_SQL's behavior.",
            "Do use parentheses to properly group the `OR` condition `T2.SSB = 'negative' OR '0'` instead of incorrectly grouping `(T2.SSB = 'negative' OR T2.SSB = '0')` which creates a logical error by comparing a string literal '0' as a boolean condition. Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` and `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` structure instead of changing them. Do keep the `WHERE T1.Diagnosis = 'SLE'` filter but reposition it after the corrected SSB condition instead of before it. The amended query now correctly evaluates the SSB condition and matches the right SQL's behavior.",
            "Do remove the parentheses around `T2.SSB = 'negative' OR '0'` instead of keeping them, as they incorrectly group the OR condition. Do ensure the logical operator precedence is maintained without parentheses instead of forcing incorrect evaluation order. Do keep the same join condition `T1.ID = T2.ID` and maintain the same `COUNT(DISTINCT T1.ID)` aggregation instead of changing them. The amended query now correctly evaluates the OR condition without artificial grouping and matches the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, and do change the logical operator precedence by placing the `OR` condition directly between `T2.SSB = 'negative'` and `'0'` instead of using explicit parentheses. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Diagnosis = 'SLE'` filter instead of altering these elements. The amended query now correctly handles the OR condition without parentheses while maintaining the same logical behavior as the RIGHT_SQL.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, and do change the logical operator precedence by placing the `OR` condition directly between `T2.SSB = 'negative'` and `'0'` instead of using explicit parentheses. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Diagnosis = 'SLE'` filter without alteration. The amended query now correctly evaluates the OR condition without parentheses while maintaining the same logical behavior as the RIGHT_SQL.",
            "Do use parentheses to properly group the `OR` condition with `T2.SSB = 'negative' OR T2.SSB = '0'` instead of the incorrect `T2.SSB = 'negative' OR '0'` which would always evaluate as true due to the standalone string literal. Do maintain the `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` as they remain unchanged. The amended query now correctly filters for patients with SLE diagnosis and either negative or zero SSB values, matching the intended behavior.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, and do change the logical operator precedence by placing the `OR` condition directly between `T2.SSB = 'negative'` and `'0'` instead of using separate equality checks. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` between `Patient` and `Laboratory` tables instead of altering these elements. The amended query now correctly handles the OR logic without parentheses and matches the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, as the logical operator precedence makes them unnecessary. Do maintain the `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` unchanged. The amended query now correctly matches the intended behavior of counting distinct patients with SLE diagnosis and either negative or 0 SSB laboratory results.",
            "Do remove the parentheses around the `T2.SSB` filter conditions instead of keeping them, as the logical operator precedence makes parentheses unnecessary. Do change the filter order to place `T2.SSB = 'negative' OR '0'` before `T1.Diagnosis = 'SLE'` instead of the original sequence, though this doesn't affect the logical outcome. The amended query now correctly matches the RIGHT_SQL's behavior with equivalent filtering logic."
        ],
        "rules": [
            "normal anti-SSB refers to SSB IN('-', '+-'); '-' is expressed as 'negative' and '+-' is expressed as '0' in the database ; diagnosed with SLE refers to Diagnosis = 'SLE'; Should compute the number of distinct ones"
        ]
    },
    "852": {
        "sql": [
            "SELECT COUNT(*) AS race_count\nFROM races\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE races.year = 2010\nAND circuits.country NOT IN ('Asia', 'Europe');",
            "SELECT COUNT(T3.raceId) \nFROM circuits AS T1 \nINNER JOIN races AS T3 ON T3.circuitId = T1.circuitId \nWHERE T3.year = 2010 \nAND T1.country NOT IN ('Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK')"
        ],
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "amends": [
            "Do count `T3.raceId` instead of `COUNT(*)` to avoid counting nulls. Do use `INNER JOIN` with explicit table aliases `circuits AS T1` and `races AS T3` instead of simple `JOIN` without aliases. Do specify the join condition as `T3.circuitID = T1.circuitId` instead of `races.circuitId = circuits.circuitId` for clarity. Do move the `circuits.country` filter to reference `T1.country` instead and change the exclusion list from continents to specific countries, replacing `NOT IN ('Asia', 'Europe')` with `NOT IN ('Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK')` to exclude specific Asian and European countries rather than entire continents. Do keep the `races.year = 2010` filter but reference it as `T3.year = 2010` instead. The amended query now correctly counts races from 2010 that occurred in circuits outside specific Asian and European countries rather than excluding entire continents, matching the intended behavior."
        ],
        "rules": []
    },
    "843": {
        "sql": [
            "SELECT hp.hero_id\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Intelligence';"
        ],
        "question": "List the hero ID of superheroes have intellegence as their power.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.hero_id FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Intelligence'",
        "amends": [],
        "rules": [
            "hero ID refers to superhero.id; have intelligence as their power refers to power_name = 'Intelligence';"
        ]
    },
    "488": {
        "sql": [
            "SELECT code FROM sets WHERE releaseDate = '2017-07-14';"
        ],
        "question": "What's the code for the set which was released on 2017/7/14?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT code FROM sets WHERE releaseDate = '2017-07-14' GROUP BY releaseDate, code",
        "amends": [],
        "rules": [
            "released on 2017/7/14 refers to releaseDate = '2017-07-14'"
        ]
    },
    "1149": {
        "sql": [
            "WITH male_in_patients AS (\n    SELECT COUNT(*) AS count_in_patient\n    FROM Patient\n    WHERE SEX = 'M' AND Admission = '+'\n),\nmale_out_patients AS (\n    SELECT COUNT(*) AS count_out_patient\n    FROM Patient\n    WHERE SEX = 'M' AND Admission = '-'\n)\nSELECT \n    CASE \n        WHEN count_in_patient > count_out_patient THEN 'More in-patient males'\n        WHEN count_in_patient < count_out_patient THEN 'More outpatient males'\n        ELSE 'Equal number of in-patient and outpatient males'\n    END AS comparison,\n    ABS(count_in_patient - count_out_patient) * 100.0 / count_out_patient AS percentage_deviation\nFROM male_in_patients, male_out_patients;",
            "SELECT \n    (SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100.0 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)) AS percentage_deviation\nFROM Patient\nWHERE SEX = 'M';"
        ],
        "question": "Are there more in-patient or outpatient who were male? What is the deviation in percentage?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE SEX = 'M'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for counts. Do calculate the percentage directly using `SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)` instead of computing separate counts and then performing arithmetic. Do remove the CASE statement for comparison text and ABS function for deviation calculation instead of including them. Do eliminate the CTE structure and cross join between counts instead of using multiple common table expressions. Do cast the numerator to REAL for proper division instead of relying on integer arithmetic. Do filter for `SEX = 'M'` in the WHERE clause instead of handling it within CTEs. The amended query now correctly calculates the percentage of in-patient males relative to outpatient males without the unnecessary comparison logic and count separation."
        ],
        "rules": [
            "male refers to SEX = 'M'; in-patient refers to Admission = '+'; outpatient refers to Admission = '-'; percentage = DIVIDE(COUNT(ID) where SEX = 'M' and Admission = '+', COUNT(ID) where SEX\u00a0 = 'M' and Admission = '-')"
        ]
    },
    "856": {
        "sql": [
            "SELECT r.time \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.name = 'Sepang International Circuit';"
        ],
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "amends": [],
        "rules": []
    },
    "1352": {
        "sql": [
            "SELECT COUNT(*) \nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' AND m.t_shirt_size = 'Medium';"
        ],
        "question": "For all the club members from \"Business\" major, how many of them wear medium size t-shirt?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'",
        "amends": [],
        "rules": [
            "'Business' is a major name; wear medium size t-shirt refers to t_shirt_size = 'Medium'"
        ]
    },
    "1175": {
        "sql": [
            "WITH MaxHGBPatient AS (\n    SELECT \n        L.ID,\n        L.HGB,\n        L.Date\n    FROM \n        Laboratory L\n    WHERE \n        L.HGB = (SELECT MAX(HGB) FROM Laboratory)\n)\nSELECT \n    P.ID,\n    (strftime('%Y', E.`Examination Date`) - strftime('%Y', P.Birthday)) AS Age,\n    E.Diagnosis\nFROM \n    MaxHGBPatient M\nJOIN \n    Patient P ON M.ID = P.ID\nJOIN \n    Examination E ON M.ID = E.ID AND M.Date = E.`Examination Date`;",
            "SELECT \n    STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) AS Age,\n    T1.Diagnosis\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nORDER BY \n    T2.HGB DESC \nLIMIT 1;"
        ],
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "amends": [
            "Do select `STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)` and `T1.Diagnosis` instead of `P.ID`, calculated `Age`, and `E.Diagnosis`. Do use `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of the CTE with max HGB filtering and subsequent joins to Patient and Examination tables. Do add `ORDER BY T2.HGB DESC LIMIT 1` instead of filtering for maximum HGB values through a subquery. Do remove the Examination table join and date matching condition instead of including them. The amended query now correctly retrieves the patient with the highest HGB value by sorting and limiting rather than using a complex max-filtering approach, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "How old the patient refers to SUBTRACT(year(`Examination Date`), year(Birthday)); the highest hemoglobin count refers to MAX(HGB)"
        ]
    },
    "1016": {
        "sql": [
            "WITH austrian_circuit AS (\n    SELECT circuitId FROM circuits WHERE name = 'Austrian Grand Prix'\n),\nrace_at_austria AS (\n    SELECT raceId FROM races WHERE circuitId = (SELECT circuitId FROM austrian_circuit)\n),\nlap_record_driver AS (\n    SELECT r.driverId, r.raceId\n    FROM results r\n    JOIN race_at_austria ra ON r.raceId = ra.raceId\n    WHERE r.fastestLapTime = (SELECT MIN(fastestLapTime) FROM results WHERE raceId = ra.raceId)\nSELECT ps.duration\nFROM pitStops ps\nJOIN lap_record_driver lrd ON ps.raceId = lrd.raceId AND ps.driverId = lrd.driverId;",
            "SELECT T4.duration\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nINNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\nINNER JOIN pitStops T4 ON T1.raceId = T4.raceId AND T1.driverId = T4.driverId\nWHERE T2.name = 'Austrian Grand Prix'\nAND T1.fastestLapTime IS NOT NULL\nAND CAST(SUBSTR(T1.fastestLapTime, 1, 2) AS INTEGER) * 60 + \n    CAST(SUBSTR(T1.fastestLapTime, 4, 2) AS INTEGER) + \n    CAST(SUBSTR(T1.fastestLapTime, 7) AS REAL) = (\n    SELECT MIN(CAST(SUBSTR(r.fastestLapTime, 1, 2) AS INTEGER) * 60 + \n           CAST(SUBSTR(r.fastestLapTime, 4, 2) AS INTEGER) + \n           CAST(SUBSTR(r.fastestLapTime, 7) AS REAL))\n    FROM results r\n    INNER JOIN races ra ON r.raceId = ra.raceId\n    WHERE ra.name = 'Austrian Grand Prix'\n    AND r.fastestLapTime IS NOT NULL\n)",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.driverId,\n        CAST(SUBSTR(r.fastestLapTime, 1, INSTR(r.fastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(r.fastestLapTime, INSTR(r.fastestLapTime, ':') + 1) AS REAL) AS fastest_lap_seconds\n    FROM results r\n    WHERE r.fastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        r.raceId,\n        r.driverId,\n        MIN(flt.fastest_lap_seconds) AS min_fastest_lap_seconds\n    FROM results r\n    INNER JOIN races rc ON r.raceId = rc.raceId\n    INNER JOIN circuits c ON rc.circuitId = c.circuitId\n    INNER JOIN fastest_lap_times flt ON r.raceId = flt.raceId AND r.driverId = flt.driverId\n    WHERE c.name = 'Austrian Grand Prix'\n    GROUP BY r.raceId, r.driverId\n)\nSELECT \n    CAST(SUBSTR(ps.duration, 1, INSTR(ps.duration, ':') - 1) AS REAL) * 60 +\n    CAST(SUBSTR(ps.duration, INSTR(ps.duration, ':') + 1) AS REAL) AS pit_stop_seconds\nFROM pitStops ps\nINNER JOIN lap_record_race lrr ON ps.raceId = lrr.raceId AND ps.driverId = lrr.driverId\nWHERE ps.raceId IN (SELECT raceId FROM lap_record_race);",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.driverId,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000 AS fastest_lap_seconds\n    FROM results T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T1.FastestLapTime IS NOT NULL\n    AND T2.name = 'Austrian Grand Prix'\n),\nlap_record_race AS (\n    SELECT \n        flt.raceId,\n        flt.driverId\n    FROM fastest_lap_times flt\n    WHERE flt.fastest_lap_seconds = (\n        SELECT MIN(fastest_lap_seconds) \n        FROM fastest_lap_times \n        WHERE raceId = flt.raceId\n    )\n)\nSELECT T4.duration\nFROM pitStops T4\nINNER JOIN lap_record_race lrr ON T4.raceId = lrr.raceId AND T4.driverId = lrr.driverId;",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.driverId,\n        T1.FastestLapTime,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS INTEGER) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) AS time_in_seconds\n    FROM results T1\n    WHERE T1.FastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        flt.raceId,\n        flt.driverId\n    FROM fastest_lap_times flt\n    INNER JOIN races T2 ON flt.raceId = T2.raceId\n    INNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\n    WHERE T3.name = 'Austrian Grand Prix'\n    AND flt.time_in_seconds = (\n        SELECT MIN(flt2.time_in_seconds)\n        FROM fastest_lap_times flt2\n        INNER JOIN races r2 ON flt2.raceId = r2.raceId\n        INNER JOIN circuits c2 ON r2.circuitId = c2.circuitId\n        WHERE c2.name = 'Austrian Grand Prix'\n    )\n)\nSELECT T4.duration\nFROM lap_record_race\nINNER JOIN pitStops T4 ON lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId;",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.driverId,\n        T1.FastestLapTime,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results T1\n    WHERE T1.FastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        T1.raceId,\n        T1.driverId\n    FROM fastest_lap_times T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    INNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\n    INNER JOIN (\n        SELECT \n            T2.raceId,\n            MIN(flt.time_in_seconds) AS min_time_in_seconds\n        FROM fastest_lap_times flt\n        INNER JOIN races T2 ON flt.raceId = T2.raceId\n        INNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\n        WHERE T3.name = 'Austrian Grand Prix'\n        GROUP BY T2.raceId\n    ) T4 ON T1.raceId = T4.raceId AND T1.time_in_seconds = T4.min_time_in_seconds\n    WHERE T3.name = 'Austrian Grand Prix'\n)\nSELECT T4.duration\nFROM lap_record_race\nINNER JOIN pitStops T4 ON lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId;",
            "error",
            "error",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.driverId,\n        T1.FastestLapTime,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results T1\n    WHERE T1.FastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        T1.raceId,\n        T1.driverId\n    FROM fastest_lap_times T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    INNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\n    WHERE T2.name = 'Austrian Grand Prix'\n    AND T1.time_in_seconds = (\n        SELECT MIN(time_in_seconds)\n        FROM fastest_lap_times flt\n        INNER JOIN races r ON flt.raceId = r.raceId\n        WHERE r.name = 'Austrian Grand Prix'\n    )\n)\nSELECT T4.duration\nFROM lap_record_race\nINNER JOIN pitStops T4 ON lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId;"
        ],
        "question": "In the race a driver set the lap record for the Austrian Grand Prix Circuit, how long did he spent at the pit stop at that same race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.driverId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL), lap_record_race AS ( SELECT T1.raceId, T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix') SELECT T4.duration FROM lap_record_race INNER JOIN pitStops AS T4 on lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId",
        "amends": [
            "Do add proper time conversion with `CAST` and string functions instead of directly comparing `fastestLapTime` strings. Do join `circuits` directly in the main logic instead of using a separate CTE for circuit lookup. Do move the circuit filter to `WHERE T2.name = 'Austrian Grand Prix'` instead of filtering by circuit name in a subquery. Do add explicit `INNER JOIN` syntax instead of implicit joins. Do restructure the fastest lap calculation to convert times to seconds and compare numerically instead of using `MIN()` on raw string values. Do include proper NULL handling with `WHERE T1.FastestLapTime IS NOT NULL` instead of assuming all records have lap times. Do add table aliases `T1`, `T2`, `T3`, `T4` for clarity instead of using unaliased table names. The amended query now correctly handles time conversion and comparison to find the actual fastest lap times at the Austrian Grand Prix.",
            "Do use a CTE structure with `fastest_lap_times` and `lap_record_race` instead of a subquery in the WHERE clause. Do calculate time conversion using `INSTR` for position-based substring extraction instead of fixed character positions. Do add proper decimal handling with `/ 1000` for milliseconds instead of direct `CAST` to `REAL`. Do restructure the query to first identify lap record races in a CTE instead of filtering pit stops directly. Do remove the redundant `circuits` table join from the main query since it's only needed for filtering Austrian Grand Prix races. Do maintain the same `INNER JOIN` logic between `results` and `races` but move the circuit filtering to the subquery. The amended query now correctly handles time conversion with proper string parsing and uses a more efficient CTE structure that matches the RIGHT_SQL's behavior.",
            "Do include milliseconds in the time conversion by adding `+ (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000)` instead of omitting them. Do change the `lap_record_race` CTE to select only `raceId` and `driverId` instead of including `MIN(flt.fastest_lap_seconds)`. Do restructure the `lap_record_race` CTE to use a subquery that finds the minimum lap time for Austrian Grand Prix races instead of grouping by race and driver. Do add a join condition that matches drivers who achieved the exact minimum lap time instead of joining on race and driver IDs alone. Do filter for `T2.name = 'Austrian Grand Prix'` in the main query instead of `c.name = 'Austrian Grand Prix'` in the CTE. Do remove the unnecessary `WHERE ps.raceId IN (SELECT raceId FROM lap_record_race)` filter instead of keeping it. Do select only `T4.duration` instead of converting pit stop times to seconds. The amended query now correctly identifies drivers who set the absolute fastest lap time at Austrian Grand Prix races and retrieves their pit stop durations.",
            "Do add `T1.FastestLapTime` to the SELECT list in the first CTE instead of omitting it, and rename the calculated column to `time_in_seconds` instead of `fastest_lap_seconds`. Do remove the `INNER JOIN races T2` and `WHERE T2.name = 'Austrian Grand Prix'` from the first CTE instead of including them, moving the race name filter to later processing. Do completely restructure the second CTE instead of the simple subquery approach, adding joins to `circuits AS T3` on `T2.circuitId = T3.circuitId` and creating a subquery to find the minimum lap time for Austrian Grand Prix races. Do change the correlation condition to compare the calculated lap time against the minimum time from the subquery instead of using a correlated subquery with `raceId = flt.raceId`. Do reverse the join direction in the final query to `INNER JOIN pitStops AS T4 on lap_record_race.raceId = T4.raceId` instead of starting from `pitStops T4` and joining to the CTE. The amended query now correctly identifies the fastest lap times specifically for Austrian Grand Prix races and properly joins to find the corresponding pit stop durations.",
            "Do use `CAST(... AS REAL)` for the minute component instead of `CAST(... AS INTEGER)` in the time conversion calculation. Do reference the base `results` table directly in the second CTE instead of using the `fastest_lap_times` CTE. Do change the WHERE filter to use `T2.name = 'Austrian Grand Prix'` instead of `T3.name = 'Austrian Grand Prix'` to correctly filter by race name rather than circuit name. Do restructure the subquery to calculate the minimum time as a separate derived table `T4` with `min_time_in_seconds` instead of using a correlated subquery. Do add an INNER JOIN condition comparing the calculated lap time directly to `T4.min_time_in_seconds` instead of using a WHERE clause with equality comparison. The amended query now correctly identifies races by name rather than circuit name and properly handles the time comparison logic to match the RIGHT_SQL's behavior.",
            "Do use `results` table directly in the second CTE instead of referencing `fastest_lap_times` CTE. Do change the WHERE filter to use `T2.name = 'Austrian Grand Prix'` instead of `T3.name = 'Austrian Grand Prix'` in both the subquery and main query. Do recalculate the lap time conversion expression in the JOIN condition instead of using the precomputed `time_in_seconds` from the CTE. Do remove the redundant `T1.raceId` grouping in the subquery since only the minimum time is needed. The amended query now correctly identifies races by name rather than circuit name and ensures proper time comparison by recalculating the lap time expression directly against the minimum value.",
            "Do add the `fastest_lap_times` CTE with proper time conversion instead of omitting it, and do use `INNER JOIN` on `races` and `circuits` with filter `T2.name = 'Austrian Grand Prix'` instead of missing these joins and filters. Do add a subquery to find `MIN(fastest_lap_times.time_in_seconds)` instead of not calculating the minimum lap time, and do join using the converted time comparison `time_in_seconds = T4.min_time_in_seconds` instead of missing this critical join condition. Do change the final query to select `T4.duration` from `pitStops` instead of selecting incorrect columns, and do add the necessary join conditions `lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId` instead of omitting them. The amended query now correctly identifies pit stop durations for drivers who set the fastest lap record in the Austrian Grand Prix.",
            "Do add a CTE `fastest_lap_times` to calculate `time_in_seconds` from `FastestLapTime` instead of omitting this conversion. Do use proper join conditions with `T1.raceId = T2.raceId` and `T2.circuitId = T3.circuitId` instead of incorrect join predicates. Do filter for `T2.name = 'Austrian Grand Prix'` in both the subquery and main query instead of missing this condition. Do compare the converted lap time against the minimum time using the calculated `time_in_seconds` instead of comparing raw string values. Do join `pitStops` with both `raceId` and `driverId` conditions instead of incomplete join criteria. The amended query now correctly identifies pit stop durations for drivers who set the fastest lap record at the Austrian Grand Prix."
        ],
        "rules": [
            "lap record means the fastest time recorded which refers to time, how long spent at pitstop refers to duration"
        ]
    },
    "1189": {
        "sql": [
            "WITH AvgACLIgM AS (\n    SELECT AVG(`aCL IgM`) AS avg_value FROM Examination\n)\nSELECT COUNT(DISTINCT E.ID) AS patient_count\nFROM Examination E\nJOIN Patient P ON E.ID = P.ID\nWHERE E.Thrombosis = 2\nAND E.ANA = 'S'\nAND E.`aCL IgM` > (SELECT avg_value * 1.2 FROM AvgACLIgM);",
            "SELECT COUNT(*)\nFROM Examination E\nWHERE E.Thrombosis = 2\nAND E.\"ANA Pattern\" = 'S'\nAND E.\"aCL IgM\" > (\n    SELECT AVG(\"aCL IgM\") * 1.2\n    FROM Examination\n    WHERE Thrombosis = 2\n    AND \"ANA Pattern\" = 'S'\n    AND \"aCL IgM\" IS NOT NULL\n);"
        ],
        "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')",
        "amends": [
            "Do remove the CTE `AvgACLIgM` and calculate the average directly in the subquery instead of using a separate CTE. Do change the filter from `ANA = 'S'` to `ANA Pattern = 'S'` instead of using the wrong column name. Do remove the `JOIN` with `Patient` table instead of including an unnecessary table join. Do change `COUNT(DISTINCT E.ID)` to `COUNT(*)` instead of counting distinct IDs when examining the same table. Do move the `Thrombosis = 2` and `ANA Pattern = 'S'` conditions into the subquery's WHERE clause instead of only applying them in the outer query, ensuring the average calculation uses the same filtered dataset. Do remove the patient count alias instead of keeping unnecessary column naming. The amended query now correctly counts examinations meeting all criteria using consistent filtering throughout."
        ],
        "rules": [
            "thrombosis level 2 refers to Thrombosis = 2; ANA pattern of only S refers to ANA = 'S'; average anti-Cardiolip in antibody (IgM) refers to AVG(`aCL IgM`); calculation = MULTIPLY(AVG + AVG, 0.2)"
        ]
    },
    "1288": {
        "sql": [
            "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TP < 6.0;"
        ],
        "question": "Please list the diagnosis of the patients whose total protein is lower than normal.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0",
        "amends": [],
        "rules": [
            "total protein is lower than normal refers to TP < 6.0;"
        ]
    },
    "1491": {
        "sql": [
            "SELECT g.Country, COUNT(DISTINCT g.GasStationID) AS ValueForMoneyGasStations\nFROM gasstations g\nJOIN transactions_1k t ON g.GasStationID = t.GasStationID\nGROUP BY g.Country\nHAVING AVG(t.Price / t.Amount) < (SELECT AVG(Price / Amount) FROM transactions_1k)\nORDER BY ValueForMoneyGasStations DESC;",
            "SELECT Country, (SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money') AS ValueForMoneyCount FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY COUNT(GasStationID) DESC LIMIT 1;"
        ],
        "question": "Which country has more \"value for money\" gas stations? Please give a total number of \"value for money\" gas stations in each country.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT Country , ( SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money' ) FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY COUNT(GasStationID) DESC LIMIT 1",
        "amends": [
            "Do select `Country` and a subquery count of `GasStationID` instead of selecting `Country` with a `COUNT(DISTINCT g.GasStationID)` aggregate. Do use a subquery `(SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money')` instead of calculating average price per amount comparisons. Do filter with `WHERE Segment = 'Value for money'` instead of joining with transactions and using HAVING conditions. Do remove the JOIN with `transactions_1k` table and all transaction-related calculations instead of including them. Do add `GROUP BY Country` instead of omitting it in the main query context. Do order by `COUNT(GasStationID) DESC` instead of ordering by the alias `ValueForMoneyGasStations DESC`. Do add `LIMIT 1` instead of omitting a row limit. The amended query now correctly identifies value for money gas stations by segment filter rather than price calculations."
        ],
        "rules": []
    },
    "557": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN u.Age > 65 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nWHERE \n    p.Score > 5;"
        ],
        "question": "Among the posts with a score of over 5, what is the percentage of them being owned by an elder user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age > 65, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score > 5",
        "amends": [],
        "rules": [
            "score of over 5 refers to Score > 5; elder user refers to Age > 65; percentage = Divide (Count(Id where Age>65), Count(Id)) * 100"
        ]
    },
    "1019": {
        "sql": [
            "SELECT AVG(l.milliseconds) AS average_lap_time_ms\nFROM lapTimes l\nJOIN races r ON l.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Italy';"
        ],
        "question": "What is the average lap time in milliseconds of all the lap records set on the various circuits in Italy?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy'",
        "amends": [],
        "rules": [
            "average = AVG(milliseconds)"
        ]
    },
    "1329": {
        "sql": [
            "SELECT z.county\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Sherri' AND m.last_name = 'Ramsey';"
        ],
        "question": "What county did Sherri Ramsey grew up?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey'",
        "amends": [],
        "rules": []
    },
    "812": {
        "sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE c.colour = 'Blue'\nLIMIT 5;",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T2.colour = 'Blue'\nLIMIT 5;"
        ],
        "question": "List down at least five full names of superheroes with blue eyes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5",
        "amends": [
            "Do use `superhero_name` instead of `full_name` for the column selection. Do alias the superhero table as `T1` instead of leaving it unaliased. Do use `INNER JOIN` explicitly instead of just `JOIN` for the join type. Do alias the colour table as `T2` instead of leaving it unaliased. The amended query now correctly retrieves superhero names with blue eye color using proper table aliases and explicit join syntax."
        ],
        "rules": [
            "blue eyes refers to colour.colour = 'Blue' WHERE eye_colour_id = colour.id; Name of superheroes refers to superhero_name;"
        ]
    },
    "238": {
        "sql": [
            "SELECT COUNT(DISTINCT molecule_id) FROM bond WHERE bond_type = '#';"
        ],
        "question": "How many molecules have a triple bond type?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.bond_type = '#'",
        "amends": [],
        "rules": [
            "triple bond refers to bond_type = '#';"
        ]
    },
    "1079": {
        "sql": [
            "SELECT player_name, height FROM Player WHERE height = (SELECT MAX(height) FROM Player);",
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;"
        ],
        "question": "Which player is the tallest?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `height` in the SELECT list. Do use `ORDER BY height DESC LIMIT 1` instead of a subquery with `WHERE height = (SELECT MAX(height) FROM Player)`. Do remove the explicit height column selection and subquery approach instead of keeping them, as the ORDER BY with LIMIT more efficiently retrieves the tallest player without needing to compare against the maximum value. The amended query now correctly returns only the name of the tallest player matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "tallest player refers to MAX(height);"
        ]
    },
    "667": {
        "sql": [
            "SELECT p.Title \nFROM posts p \nJOIN postLinks pl ON p.Id = pl.PostId \nWHERE pl.CreationDate = (SELECT MIN(CreationDate) FROM postLinks);",
            "SELECT T1.Title FROM posts T1 INNER JOIN postLinks T2 ON T2.PostId = T1.Id ORDER BY T1.CreationDate LIMIT 1",
            "SELECT T1.Title \nFROM posts AS T1 \nINNER JOIN postLinks AS T2 ON T2.PostId = T1.Id \nORDER BY T1.CreationDate \nLIMIT 1",
            "SELECT T1.Title \nFROM posts AS T1 \nINNER JOIN postLinks AS T2 ON T2.PostId = T1.Id \nORDER BY T1.CreaionDate \nLIMIT 1"
        ],
        "question": "What is the title of the post with the oldest post link?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY T1.CreaionDate LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` with `T2.PostId = T1.Id` instead of `JOIN` with `p.Id = pl.PostId`. Do add `ORDER BY T1.CreationDate LIMIT 1` instead of the subquery `WHERE pl.CreationDate = (SELECT MIN(CreationDate) FROM postLinks)`. Do remove the subquery filter instead of keeping it. Do change table aliases to `T1` and `T2` instead of `p` and `pl`. The amended query now correctly retrieves the earliest post by creation date using proper ordering and limiting instead of an inefficient subquery approach.",
            "Do use `AS` for table aliases in both the `posts AS T1` and `postLinks AS T2` clauses instead of omitting the explicit alias keyword. Do correct the column reference to `T1.CreationDate` instead of the misspelled `T1.CreaionDate` in the ORDER BY clause. The amended query now matches RIGHT_SQL's behavior with proper alias syntax and correct column spelling.",
            "Do use `T1.CreaionDate` instead of `T1.CreationDate` in the ORDER BY clause to match the correct column name. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "the oldest post link refers to MIN(CreaionDate);"
        ]
    },
    "331": {
        "sql": [
            "SELECT COUNT(*) FROM molecule WHERE label = '+';"
        ],
        "question": "How many of the molecules are carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "487": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 END) * 100.0 / \n    COUNT(*)) AS percentage_incredibly_powerful\nFROM \n    cards\nWHERE \n    setCode = 'Coldsnap';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.power = 'Incredible' THEN 1 ELSE 0 END) AS REAL) / CAST(COUNT(T1.id) AS REAL) * 100.0 AS percentage\nFROM \n    cards AS T1\nINNER JOIN \n    sets AS T2 ON T2.code = T1.setCode\nWHERE \n    T2.name = 'Coldsnap';",
            "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(T1.id) \nFROM cards AS T1 \nINNER JOIN sets AS T2 ON T2.code = T1.setCode \nWHERE T2.name = 'Coldsnap'"
        ],
        "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "amends": [
            "Do use `SUM(CASE ... THEN 1 ELSE 0 END)` with explicit ELSE instead of `COUNT(CASE ... THEN 1 END)` for conditional counting. Do add `INNER JOIN sets AS T2 ON T2.code = T1.setCode` instead of omitting the sets table join. Do filter on `T2.name = 'Coldsnap'` instead of `setCode = 'Coldsnap'` to use the set name rather than code. Do reference `T1.id` in `COUNT(T1.id)` instead of `COUNT(*)` for more precise counting. Do wrap the calculation with `CAST(... AS REAL)` instead of using `100.0` for explicit type conversion. Do add table alias `T1` to all column references instead of using unqualified column names. The amended query now correctly joins with the sets table and filters by set name rather than code, ensuring accurate calculation of the percentage.",
            "Do change the CASE condition from `power = 'Incredible'` to `cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL` instead of checking for a specific power value. Do remove the division operator placement by using `* 100 / COUNT()` instead of `/ COUNT() * 100.0` to ensure correct mathematical order of operations. Do omit the alias `percentage` instead of including it, as the right query returns an unnamed result. The amended query now correctly calculates the percentage of cards that have both cardKingdomFoilId and cardKingdomId values populated for the Coldsnap set, matching the right SQL's behavior."
        ],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; foil is incredibly powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null; the percentage of incredibly powerful cards in the set refers to DIVIDE(SUM(incredibly powerful), SUM(name = 'Coldsnap'))*100"
        ]
    },
    "1212": {
        "sql": [
            "SELECT \n    p.Admission,\n    COUNT(*) AS PatientCount\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.ALP < 300\nGROUP BY \n    p.Admission;",
            "SELECT T1.Admission \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP < 300"
        ],
        "question": "For patients with alkaliphophatase (ALP) within normal range, were they treated as inpatient or outpatient?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300",
        "amends": [
            "Do select only `T1.Admission` instead of selecting both `p.Admission` and `COUNT(*) AS PatientCount`. Do remove the `GROUP BY p.Admission` clause instead of keeping it since aggregation is no longer needed. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `p` and `l`. Do place the filter `T2.ALP < 300` in the `WHERE` clause instead of keeping it there, maintaining the same filtering logic. The amended query now correctly returns individual admission records without aggregation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "alkaliphophatase (ALP) within normal range refers to ALP < 300; inpatient refers to admission = '+'; outpatient refers to admission = '-'"
        ]
    },
    "85": {
        "sql": [
            "SELECT \n    f.`District Code`,\n    (f.`Free Meal Count (K-12)` / f.`Enrollment (K-12)`) * 100 AS `Percent (%) Eligible Free (K-12)`\nFROM \n    frpm f\nJOIN \n    schools s ON f.CDSCode = s.CDSCode\nWHERE \n    s.AdmFName1 = 'Alusine' OR s.AdmFName2 = 'Alusine' OR s.AdmFName3 = 'Alusine';",
            "SELECT (f.\"Free Meal Count (K-12)\" * 100 / f.\"Enrollment (K-12)\") AS \"Percent (%) Eligible Free (K-12)\", f.\"District Code\"\nFROM frpm f\nINNER JOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.AdmFName1 = 'Alusine'"
        ],
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "amends": [
            "Do place the `District Code` column after the calculated percentage instead of listing it first in the SELECT clause. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do simplify the WHERE condition to only check `AdmFName1 = 'Alusine'` instead of checking multiple administrator name fields. Do remove the unnecessary table aliases `f` and `s` and use `T1` and `T2` consistently instead. Do change the calculation order to `Free Meal Count (K-12) * 100 / Enrollment (K-12)` instead of `(Free Meal Count (K-12) / Enrollment (K-12)) * 100` for equivalent mathematical results with potentially better performance. The amended query now correctly focuses on the single relevant administrator name field and produces the same logical results as the RIGHT_SQL."
        ],
        "rules": [
            "Percent (%) Eligible Free (K-12) = `Free Meal Count (K-12)` / `Enrollment (K-12)` * 100%"
        ]
    },
    "42": {
        "sql": [
            "SELECT s.EdOpsName\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nWHERE sc.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores);",
            "SELECT T2.EdOpsName \nFROM satscores T1 \nINNER JOIN schools T2 ON T1.cds = T2.CDSCode \nORDER BY T1.AvgScrMath DESC \nLIMIT 1"
        ],
        "question": "What is the type of education offered in the school who scored the highest average in Math?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.EdOpsName FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 1",
        "amends": [
            "Do use `T2.EdOpsName` with table alias instead of `s.EdOpsName` without alias. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use table aliases `T1` and `T2` instead of `sc` and `s`. Do remove the subquery with `MAX(AvgScrMath)` instead of keeping it. Do add `ORDER BY T1.AvgScrMath DESC` instead of omitting ordering. Do add `LIMIT 1` instead of using equality comparison with maximum value. The amended query now correctly retrieves the top school by math score using proper ordering and limiting instead of potentially returning multiple rows with the same maximum score value."
        ],
        "rules": []
    },
    "503": {
        "sql": [
            "SELECT s.type \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Samite Pilgrim';"
        ],
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "amends": [],
        "rules": [
            "expansion type refers to type; card \"Samite Pilgrim\" refers to name = 'Samite Pilgrim'"
        ]
    },
    "1246": {
        "sql": [
            "SELECT COUNT(DISTINCT L.ID) \nFROM Laboratory L\nJOIN Examination E ON L.ID = E.ID\nWHERE (L.APTT < 25 OR L.APTT > 35) AND E.Thrombosis = 0;"
        ],
        "question": "For the patients with an abnormal activated partial prothrom bin time, how many of them does not have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T3.Thrombosis = 0 AND T2.APTT > 45",
        "amends": [],
        "rules": [
            "abnormal activated partial prothrom bin time refers to APTT > 45; does not have thrombosis refers to Thrombosis = 0; Only count ones without repetitive."
        ]
    },
    "1026": {
        "sql": [
            "SELECT t.team_long_name, COUNT(*) AS loss_count\nFROM Match m\nJOIN Team t ON m.home_team_api_id = t.team_api_id\nWHERE m.season = '2015/2016' AND m.home_team_goal < m.away_team_goal\nGROUP BY m.home_team_api_id\nORDER BY loss_count ASC\nLIMIT 1;",
            "SELECT teamDetails.team_long_name, COUNT(*) AS loss_count\nFROM Match m\nJOIN Team teamDetails ON m.home_team_api_id = teamDetails.team_api_id\nWHERE m.season = '2016' AND (m.home_team_goal - m.away_team_goal) < 0\nGROUP BY m.home_team_api_id\nORDER BY COUNT(*) ASC\nLIMIT 1;",
            "SELECT teamDetails.team_long_name, COUNT(*) AS loss_count\nFROM Match matchData\nINNER JOIN Team teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id\nWHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0\nGROUP BY teamDetails.team_long_name\nORDER BY COUNT(*) ASC\nLIMIT 1;",
            "SELECT teamDetails.team_long_name\nFROM Match AS matchData\nINNER JOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id\nWHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0\nGROUP BY matchData.home_team_api_id\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "question": "Which home team had lost the fewest matches in the 2016 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT teamDetails.team_long_name FROM Match AS matchData INNER JOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id WHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0 GROUP BY matchData.home_team_api_id ORDER BY COUNT(*) ASC LIMIT 1",
        "amends": [
            "Do reference the table alias `teamDetails.team_long_name` instead of `t.team_long_name` in the SELECT list. Do use the condition `home_team_goal - away_team_goal < 0` instead of `home_team_goal < away_team_goal` in the WHERE clause to explicitly calculate the goal difference. Do order by `COUNT(*) ASC` instead of the alias `loss_count ASC` to reference the aggregate function directly. Do maintain the same table joins, grouping, and limit structure while ensuring the logic correctly identifies matches where the home team scored fewer goals than the away team. The amended query now matches RIGHT_SQL's behavior by using explicit goal difference calculation and direct aggregate reference in ordering.",
            "Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do filter by season `'2015/2016'` instead of `'2016'` to match the correct season format. Do remove the alias `loss_count` from the `COUNT(*)` expression instead of keeping it since it's not needed in the final output. Do reference the table as `matchData` instead of `m` for consistency with the right query's naming convention. The amended query now correctly identifies teams with losses in the 2015/2016 season and returns the team with the fewest losses, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) AS loss_count` from the SELECT list instead of including it. Do change the GROUP BY clause to use `matchData.home_team_api_id` instead of `teamDetails.team_long_name`. Do keep the same FROM source with `INNER JOIN` on `matchData.home_team_api_id = teamDetails.team_api_id`, maintain the WHERE filter for `season = '2015/2016'` and `home_team_goal - away_team_goal < 0`, preserve the ORDER BY `COUNT(*) ASC`, and retain the LIMIT 1. The amended query now correctly groups by the join key instead of the team name, ensuring accurate counting while maintaining the same result behavior."
        ],
        "rules": [
            "home team lost the matches refers to SUBTRACT(home_team_goal, away_team_goal) < 0; 2016 season refers to season = '2015/2016';"
        ]
    },
    "104": {
        "sql": [
            "SELECT a.date AS account_opening_date\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nWHERE t.amount = 840 AND t.date = '1998-10-14';"
        ],
        "question": "The transaction of 840 USD happened in 1998/10/14, when was this account opened?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.date FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.amount = 840 AND T2.date = '1998-10-14'",
        "amends": [],
        "rules": []
    },
    "520": {
        "sql": [
            "WITH MinIllustrator AS (\n    SELECT artist, COUNT(*) AS card_count\n    FROM cards\n    WHERE artist IS NOT NULL\n    GROUP BY artist\n    ORDER BY card_count ASC\n    LIMIT 1\n)\nSELECT DISTINCT l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.artist = (SELECT artist FROM MinIllustrator);",
            "SELECT T1.artist, T2.format\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T2.uuid = T1.uuid\nGROUP BY T1.artist\nORDER BY COUNT(T1.id) ASC\nLIMIT 1;"
        ],
        "question": "Who is the illustrator that illustrated the least amount of cards? List the format of play of the cards that he/she illustrated.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid GROUP BY T1.artist ORDER BY COUNT(T1.id) ASC LIMIT 1",
        "amends": [
            "Do select `T1.artist` and `T2.format` instead of only `l.format` with `DISTINCT`. Do use a direct `INNER JOIN` between `cards AS T1` and `legalities AS T2` on `T2.uuid = T1.uuid` instead of a separate CTE and join on `c.uuid = l.uuid`. Do remove the `WHERE c.artist = (SELECT artist FROM MinIllustrator)` subquery condition instead of keeping it. Do add `GROUP BY T1.artist` instead of omitting grouping. Do order by `COUNT(T1.id) ASC` instead of ordering by `card_count ASC` in the CTE. Do apply `LIMIT 1` at the main query level instead of in a CTE. The amended query now correctly returns the artist with the fewest cards along with their format, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "format of the cards refers to format; illustrator refers to artist; the least amount of cards refers to MIN(artist)"
        ]
    },
    "1504": {
        "sql": [
            "SELECT AVG(Amount * Price) AS average_total_price\nFROM transactions_1k\nWHERE strftime('%Y-%m', Date) = '2012-01';"
        ],
        "question": "What is the average total price of the transactions taken place in January, 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(Amount) FROM transactions_1k WHERE Date LIKE '2012-01%'",
        "amends": [],
        "rules": [
            "In January, 2012 means Date contains '2012-01'"
        ]
    },
    "510": {
        "sql": [
            "SELECT artist FROM cards WHERE otherFaceIds IS NULL ORDER BY convertedManaCost DESC LIMIT 1;"
        ],
        "question": "Among the cards that doesn't have multiple faces on the same card, who is the illustrator of the card art that has the highest cost of converted mana?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1",
        "amends": [],
        "rules": [
            "doesn't have multiple faces refers to side IS NULL; illustrator refers to artist"
        ]
    },
    "919": {
        "sql": [
            "SELECT c.name AS circuit_name FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2009 AND r.name = 'Spanish Grand Prix';"
        ],
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "amends": [],
        "rules": []
    },
    "1417": {
        "sql": [
            "SELECT DISTINCT e.type\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.remaining > 30;"
        ],
        "question": "List out the type of events which have remaining budget more than 30 USD.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 30",
        "amends": [],
        "rules": [
            "remaining budget more than 30 USD refers to remaining > 30"
        ]
    },
    "1081": {
        "sql": [
            "SELECT c.name AS country_name\nFROM League l\nJOIN Country c ON l.country_id = c.id\nWHERE l.name = 'Belgium Jupiler League';"
        ],
        "question": "Which country is the Belgium Jupiler League from?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "amends": [],
        "rules": [
            "Belgium Jupiler League refers to League.name = 'Belgium Jupiler League';"
        ]
    },
    "1496": {
        "sql": [
            "SELECT c.Segment, SUM(ym.Consumption) AS TotalConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY TotalConsumption ASC\nLIMIT 1;",
            "SELECT T1.Segment\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date LIKE '2013-09%'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;",
            "SELECT T1.Segment\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ],
        "question": "Which client segment consumed the least in September 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do select `T1.Segment` instead of `c.Segment, SUM(ym.Consumption) AS TotalConsumption`; do use `INNER JOIN` instead of `JOIN`; do group by `T1.CustomerID` instead of `c.Segment`; do order by `SUM(T2.Consumption) ASC` instead of `TotalConsumption ASC`; and do remove the alias `TotalConsumption` from the SELECT list instead of including it. The amended query now correctly identifies the customer with the minimum total consumption for September 2013 by grouping at the customer level rather than segment level and ordering by the actual sum calculation.",
            "Do use exact equality comparison `T2.Date = '201309'` instead of pattern matching with `LIKE '2013-09%'` for the date filter. Do group by `T1.CustomerID` instead of `T1.Segment` to ensure proper aggregation. The amended query now correctly filters by the exact date value and groups by the appropriate column to match the intended behavior."
        ],
        "rules": [
            "September 2013 refers to yearmonth.date = '201309'"
        ]
    },
    "686": {
        "sql": [
            "SELECT COUNT(*) AS TotalPostsAboveAverageViews\nFROM posts\nWHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
            "SELECT Id FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts)"
        ],
        "question": "Identify the total number of posts with views above average.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "amends": [
            "Do select `Id` instead of `COUNT(*) AS TotalPostsAboveAverageViews` to return individual post identifiers rather than an aggregate count. Do remove the `COUNT` aggregation and alias entirely instead of including them. Do keep the same `FROM posts` source table and `WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts)` filter condition unchanged as they correctly identify posts with above-average view counts. The amended query now returns specific post IDs that meet the criteria rather than just counting them, matching the RIGHT_SQL's behavior of retrieving individual records."
        ],
        "rules": [
            "views above average refer to ViewCount > AVG(ViewCount);"
        ]
    },
    "277": {
        "sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR000_1_2';",
            "SELECT T1.element \nFROM connected T2 \nINNER JOIN atom T1 ON T2.atom_id = T1.atom_id \nWHERE T2.bond_id = 'TR000_1_2'"
        ],
        "question": "What are the toxicology elements associated with bond ID TR000_1_2?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR000_1_2'",
        "amends": [
            "Do select only `T1.element` instead of selecting both `a1.element` and `a2.element` with aliases. Do use `INNER JOIN` with `T1.atom_id = T2.atom_id` instead of joining twice with `c.atom_id = a1.atom_id` and `c.atom_id2 = a2.atom_id`. Do remove the second table alias `a2` and the second join condition entirely instead of including them. Do use table aliases `T1` and `T2` instead of `a1`, `a2`, and `c`. Do filter on `T2.bond_id` in the WHERE clause instead of `c.bond_id`. The amended query now correctly retrieves only the element from the first atom involved in the specified bond connection, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "TR000_1_2 is the bond id;"
        ]
    },
    "937": {
        "sql": [
            "SELECT r.time AS finish_time\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 2008 AND rc.name = 'Chinese Grand Prix' AND r.positionOrder = 2;",
            "SELECT T1.time\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T1.rank = 2\nAND T2.name = 'AustChineseralian Grand Prix'\nAND T2.year = 2008",
            "SELECT T1.time\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2008\nAND T2.name = 'Chinese Grand Prix'\nAND T1.rank = 2"
        ],
        "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
        "amends": [
            "Do reference the time column as `T1.time` instead of `r.time AS finish_time` and remove the alias. Do use `INNER JOIN` explicitly instead of just `JOIN` while keeping the same join condition `T1.raceId = T2.raceId`. Do filter on `T1.rank = 2` instead of `r.positionOrder = 2` to use the correct column name for the ranking position. Do keep the same filters on `T2.name = 'Chinese Grand Prix'` and `T2.year = 2008` but reference them with the T2 alias instead of rc. The amended query now correctly identifies the second-place finisher using the proper rank column and matches the intended behavior.",
            "Do correct the race name filter to `Chinese Grand Prix` instead of the incorrect `AustChineseralian Grand Prix` in the WHERE clause. The amended query now matches RIGHT_SQL's behavior by properly filtering for the Chinese Grand Prix race in 2008 where drivers finished in second position."
        ],
        "rules": [
            "finish time refers to time; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';"
        ]
    },
    "1119": {
        "sql": [
            "SELECT SUM(M.home_team_goal) AS total_home_goals\nFROM Match M\nJOIN Player P ON (M.home_player_1 = P.player_api_id OR M.home_player_2 = P.player_api_id OR M.home_player_3 = P.player_api_id OR M.home_player_4 = P.player_api_id OR M.home_player_5 = P.player_api_id OR M.home_player_6 = P.player_api_id OR M.home_player_7 = P.player_api_id OR M.home_player_8 = P.player_api_id OR M.home_player_9 = P.player_api_id OR M.home_player_10 = P.player_api_id OR M.home_player_11 = P.player_api_id)\nWHERE P.player_name = 'Aaron Lennon';",
            "SELECT COUNT(*) \nFROM Match t2\nINNER JOIN Player t1 ON t1.player_api_id = t2.away_player_9\nWHERE t1.player_name = 'Aaron Lennon' AND t2.away_team_goal > 0",
            "SELECT SUM(t2.home_team_goal) \nFROM Player AS t1 \nINNER JOIN Match AS t2 ON t1.player_api_id = t2.away_player_9 \nWHERE t1.player_name = 'Aaron Lennon'"
        ],
        "question": "How many home team goal have been scored by Aaron Lennon?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_9 WHERE t1.player_name = 'Aaron Lennon'",
        "amends": [
            "Do use `INNER JOIN` on `t1.player_api_id = t2.away_player_9` instead of multiple `OR` conditions across all home players. Do reference `away_player_9` instead of checking all home player positions. Do remove the alias `total_home_goals` instead of keeping it. Do use table aliases `t1` and `t2` instead of single-letter aliases. The amended query now correctly matches the RIGHT_SQL's behavior by focusing on the specific away player position rather than incorrectly checking all home player positions.",
            "Do use `SUM(t2.home_team_goal)` instead of `COUNT(*)` to sum goals instead of counting matches. Do specify `Player AS t1` instead of omitting the alias keyword. Do reference `match AS t2` instead of `Match t2` with proper casing and alias syntax. Do remove the condition `t2.away_team_goal > 0` instead of keeping it, as the sum should include all matches regardless of goal count. The amended query now correctly sums home team goals for matches where Aaron Lennon played as away player 9, matching the intended behavior."
        ],
        "rules": [
            "Aaron Lennon refers to player_name = 'Aaron Lennon'"
        ]
    },
    "666": {
        "sql": [
            "SELECT p.Id \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE v.UserId = 1465 \nORDER BY p.Score DESC \nLIMIT 1;"
        ],
        "question": "Among the posts that were voted by user 1465, what is the id of the most valuable post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Id FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 1465 ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "amends": [],
        "rules": [
            "user 1465 refers to UserId = 1465; the most valuable post refers to MAX(FavoriteCount);"
        ]
    },
    "271": {
        "sql": [
            "SELECT \n    CASE \n        WHEN COUNT(DISTINCT a1.element) = 2 AND 'cl' IN (a1.element, a2.element) AND 'c' IN (a1.element, a2.element) THEN 'Yes'\n        ELSE 'No'\n    END AS has_both_elements\nFROM \n    connected c\nJOIN \n    atom a1 ON c.atom_id = a1.atom_id\nJOIN \n    atom a2 ON c.atom_id2 = a2.atom_id\nWHERE \n    c.bond_id = 'TR001_1_8';",
            "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id\nWHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')"
        ],
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "amends": [
            "Do select specific columns `T2.bond_id`, `T2.atom_id2`, and `T1.element AS flag_have_CaCl` instead of a CASE expression that aggregates and checks for element combinations. Do use `INNER JOIN` between `atom AS T1` and `connected AS T2` on `T2.atom_id = T1.atom_id` instead of joining the atom table twice with different aliases. Do move the element filter to the WHERE clause with `(T1.element = 'c1' OR T1.element = 'c')` instead of checking for element combinations in a CASE expression with COUNT DISTINCT. Do remove the second atom join and the complex CASE logic instead of keeping the multi-join aggregation approach. The amended query now correctly filters for specific elements and returns individual records rather than attempting to aggregate and validate element combinations across multiple joins."
        ],
        "rules": [
            "chlorine refers to element = 'cl'; carbon refers to element = 'c'"
        ]
    },
    "301": {
        "sql": [
            "SELECT bond_type FROM bond WHERE bond_id = 'TR007_4_19';"
        ],
        "question": "What is the bond type of TR007_4_19?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_type FROM bond AS T WHERE T.bond_id = 'TR007_4_19'",
        "amends": [],
        "rules": [
            "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ]
    },
    "270": {
        "sql": [
            "SELECT m.label, COUNT(*) AS count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'ca'\nGROUP BY m.label\nORDER BY count DESC\nLIMIT 1;",
            "SELECT T2.label\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'ca'\nGROUP BY T2.label\nORDER BY COUNT(T2.label) DESC\nLIMIT 1"
        ],
        "question": "Among the molecules with element Calcium, are they mostly carcinogenic or non carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca' GROUP BY T2.label ORDER BY COUNT(T2.label) DESC LIMIT 1",
        "amends": [
            "Do use `T2.label` in the SELECT list instead of `m.label` and remove the `COUNT(*) AS count` column. Do use explicit `INNER JOIN` instead of `JOIN` and specify table aliases `AS T1` and `AS T2` instead of direct table names. Do keep the join condition `T1.molecule_id = T2.molecule_id` unchanged. Do maintain the WHERE filter `T1.element = 'ca'` instead of `a.element = 'ca'`. Do keep `GROUP BY T2.label` instead of `GROUP BY m.label`. Do change the ORDER BY to `COUNT(T2.label) DESC` instead of `count DESC` while removing the alias reference. Do maintain `LIMIT 1` unchanged. The amended query now correctly returns only the label with the highest count of calcium atoms per molecule instead of including a count column."
        ],
        "rules": [
            "calcium refers to element = 'ca'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; MAX(label)"
        ]
    },
    "434": {
        "sql": [
            "SELECT COUNT(DISTINCT s.code) \nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Japanese'\nAND s.mtgoCode IS NULL;"
        ],
        "question": "How many sets are available just in Japanese and not in Magic: The Gathering Online?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.language = 'Japanese'  AND (T1.mtgoCode IS NULL OR T1.mtgoCode = '')",
        "amends": [],
        "rules": [
            "Japanese refers to language = 'Japanese'; not in Magic: The Gathering Online refers to mtgoCode is null or mtgoCode = ''"
        ]
    },
    "72": {
        "sql": [
            "SELECT f.\"Enrollment (Ages 5-17)\" \nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.EdOpsCode = 'SSS' \nAND s.City = 'Fremont' \nAND f.\"Academic Year\" = '2014-2015';"
        ],
        "question": "How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1.`Academic Year` BETWEEN 2014 AND 2015",
        "amends": [],
        "rules": [
            "State Special School means EdOpsCode = 'SSS'"
        ]
    },
    "385": {
        "sql": [
            "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Beacon of Immortality';"
        ],
        "question": "Write down the ruling of Beacon of Immortality.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "amends": [],
        "rules": [
            "Beacon of Immortality' is the name of card;"
        ]
    },
    "1122": {
        "sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);"
        ],
        "question": "State the name of the most strongest player.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)",
        "amends": [],
        "rules": [
            "strongest players refers to player has MAX(overall_rating)"
        ]
    },
    "1207": {
        "sql": [
            "SELECT DISTINCT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE strftime('%Y', l.Date) = '1994' AND l.GOT < 60;",
            "SELECT T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60\nAND STRFTIME('%Y', T2.Date) = '1994'"
        ],
        "question": "List all patients with their sex and date of birthday, whose AST glutamic oxaloacetic transaminase (GOT) index is within normal range for loboratory examination in 1994.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND STRFTIME('%Y', T2.Date) = '1994'",
        "amends": [
            "Do select only `SEX` and `Birthday` instead of including `ID` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with single-letter aliases. Do place the `GOT < 60` condition before the date filter in the WHERE clause instead of after it, though this is functionally equivalent. Do maintain the `STRFTIME` function call with the same date extraction logic but reference it as `T2.Date` instead of `l.Date`. The amended query now correctly matches the RIGHT_SQL's behavior by returning only the required demographic information without the patient ID."
        ],
        "rules": [
            "AST glutamic oxaloacetic transaminase (GOT) index is within normal range refers to GOT < 60; examination in 1994 refers to year(Date) = 1994"
        ]
    },
    "519": {
        "sql": [
            "SELECT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.name = 'Battlebond';",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE name = 'Battlebond');",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE name = 'Battlebond')",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE name = 'Battlebond');",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE name = 'Battlebond')",
            "SELECT language FROM set_translations WHERE id IN (SELECT id FROM sets WHERE name = 'Battlebond')"
        ],
        "question": "What is the language of the \"Battlebond\" set?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM sets WHERE name = 'Battlebond' )",
        "amends": [
            "Do use a subquery with `id IN (SELECT id FROM sets WHERE name = 'Battlebond')` instead of joining on `set_translations st JOIN sets s ON st.setCode = s.code`. Do remove the table alias `st` from the `SELECT language` clause instead of including it. Do change the join condition to use the correct correlation through `id` instead of the incorrect `setCode = s.code` relationship. The amended query now correctly filters set translations based on the set name through a subquery rather than an incorrect join, matching the right SQL's behavior.",
            "Do use `id` in the WHERE clause instead of `setCode` for the subquery correlation. Do reference `id` in the subquery's SELECT list instead of `code` to properly match the parent query's filter condition. The amended query now correctly correlates the subquery through the `id` column instead of the incorrect `setCode` relationship, ensuring it matches the intended behavior of filtering set_translations based on set IDs from the specified set name.",
            "Do use `id` in the WHERE clause instead of `setCode` for the subquery correlation. Do reference `id` in the subquery's SELECT list instead of `code` to ensure proper join semantics between the tables. This change fixes the logical relationship between set_translations and sets tables by using the correct primary key identifier instead of a potentially ambiguous code field. The amended query now correctly matches the intended behavior of filtering translations based on set IDs rather than set codes.",
            "Do use `id` in the WHERE clause instead of `setCode` for the subquery correlation. Do reference `id` in the subquery's SELECT list instead of `code` to properly match the parent query's filter condition. The amended query now correctly correlates the set_translations table with the sets table using the id column instead of the incorrect setCode to code relationship, ensuring proper data retrieval based on the set name.",
            "Do use `id` in the WHERE clause instead of `setCode` for the subquery correlation. Do reference `id` in the subquery's SELECT list instead of `code` to properly match the parent query's filter condition. The amended query now correctly correlates the set_translations table with the sets table using the id column instead of the incorrect setCode reference, ensuring proper data retrieval based on the Battlebond set name."
        ],
        "rules": [
            "\"Battlebond\" set refers to name = 'Battlebond'"
        ]
    },
    "829": {
        "sql": [
            "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'DC Comics')) - \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) AS difference;"
        ],
        "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "amends": [],
        "rules": [
            "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; difference = SUBTRACT(SUM(publisher_name = 'DC Comics'), SUM(publisher_name = 'Marvel Comics'));"
        ]
    },
    "885": {
        "sql": [
            "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1;"
        ],
        "question": "State the name and date of the last round of race in year 1999.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the last round refers to max(round);"
        ]
    },
    "1272": {
        "sql": [
            "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.SSA NOT IN ('negative', '0')\nORDER BY p.`First Date` ASC\nLIMIT 1;"
        ],
        "question": "Which patient is the first patient with an abnormal anti-SSA to come to the hospital? Please give his or her ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` IS NOT NULL AND T2.SSA NOT IN ('negative', '0') ORDER BY T1.`First Date` ASC LIMIT 1",
        "amends": [],
        "rules": [
            "first patient refers to ID with MIN(`First Date`); abnormal anti-SSA refers to SSA NOT IN('negative', '0');"
        ]
    },
    "1516": {
        "sql": [
            "SELECT COUNT(*) AS NumberOfTransactions\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-26'\n  AND t.Time < '13:00:00'\n  AND c.Currency = 'CZK';"
        ],
        "question": "How many transactions were paid in CZK in the morning of 2012/8/26?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-26' AND T1.Time < '13:00:00' AND T2.Currency = 'CZK'",
        "amends": [],
        "rules": [
            "'2012/8/26' can be represented by '2012-08-26'; The morning refers to the time before '13:00:00'"
        ]
    },
    "103": {
        "sql": [
            "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.issued = '1994-03-03';"
        ],
        "question": "Which client issued his/her card in 1994/3/3, give his/her client id.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.issued = '1994-03-03'",
        "amends": [],
        "rules": []
    },
    "788": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female_heroes\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    gender g ON s.gender_id = g.id\nWHERE \n    p.publisher_name = 'Marvel Comics';",
            "SELECT \n    (CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN T1.id END) AS REAL) / COUNT(T1.id)) * 100 AS percentage\nFROM \n    superhero T1\n    INNER JOIN publisher T2 ON T1.publisher_id = T2.id\n    INNER JOIN gender T3 ON T1.gender_id = T3.id\nWHERE \n    T3.gender = 'Female'"
        ],
        "question": "How many percent of female heroes were published by Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T3.gender = 'Female'",
        "amends": [
            "Do use `CAST` to convert the count to `REAL` instead of implicit conversion with `100.0`. Do calculate percentage based on `COUNT(T1.id)` instead of `COUNT(*)`. Do move the publisher filter `T2.publisher_name = 'Marvel Comics'` into the `CASE` expression instead of keeping it in the `WHERE` clause. Do filter for `T3.gender = 'Female'` in the `WHERE` clause instead of checking gender in the `CASE` expression. Do use table aliases `T1`, `T2`, `T3` instead of full table names. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly calculates the percentage of female heroes specifically for Marvel Comics by moving the publisher condition into the CASE expression while filtering for female gender in WHERE, ensuring accurate percentage calculation."
        ],
        "rules": [
            "percent = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100); female heroes refers to gender = 'Female'; Marvel Comics refers to publisher_name = 'Marvel Comics';"
        ]
    },
    "707": {
        "sql": [
            "SELECT c.Id, c.Text, c.Score, c.CreationDate, c.UserDisplayName\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.ViewCount BETWEEN 100 AND 150\nORDER BY c.Score DESC\nLIMIT 1;",
            "SELECT Text\nFROM comments\nWHERE PostId IN (\n    SELECT Id\n    FROM posts\n    WHERE ViewCount BETWEEN 100 AND 150\n)\nORDER BY Score DESC\nLIMIT 1;"
        ],
        "question": "Among the posts with views ranging from 100 to 150, what is the comment with the highest score?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Text FROM comments WHERE PostId IN ( SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150 ) ORDER BY Score DESC LIMIT 1",
        "amends": [
            "Do select only `Text` instead of including `Id`, `Score`, `CreationDate`, and `UserDisplayName`. Do remove the explicit `JOIN` with `posts` table instead of keeping it. Do use a subquery with `PostId IN` instead of a table join. Do keep the `ViewCount BETWEEN 100 AND 150` filter but move it to the subquery instead of the main WHERE clause. Do maintain `ORDER BY Score DESC` and `LIMIT 1` without changes. The amended query now correctly returns only the comment text from posts with the specified view count range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "views ranging from 100 to 150 refers to ViewCount BETWEEN 100 and 150; comment with the highest score refers to Text where MAX(Score);"
        ]
    },
    "561": {
        "sql": [
            "SELECT p.Title\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nORDER BY c.Score DESC\nLIMIT 1;"
        ],
        "question": "What is the title for the post which got the highest score comment?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Title FROM posts WHERE Id = ( SELECT PostId FROM comments ORDER BY Score DESC LIMIT 1 )",
        "amends": [],
        "rules": [
            "highest score comment refers to Max(comments.Score)"
        ]
    },
    "166": {
        "sql": [
            "SELECT COUNT(*) \nFROM account \nWHERE district_id = (SELECT district_id FROM district WHERE A2 = 'Jesenik');"
        ],
        "question": "How many of the accounts are from Jesenik district?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A2 = 'Jesenik'",
        "amends": [],
        "rules": []
    },
    "1488": {
        "sql": [
            "SELECT c.CustomerID, SUM(ym.Consumption) AS TotalConsumption\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Segment = 'KAM'\nGROUP BY c.CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1;"
        ],
        "question": "Who among KAM's customers consumed the most? How much did it consume?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.CustomerID, SUM(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' GROUP BY T2.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [],
        "rules": []
    },
    "109": {
        "sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS female_clients_in_jesenik\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE di.A2 = 'Jesenik' AND c.gender = 'F';",
            "SELECT COUNT(T1.client_id) \nFROM client T1\nJOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'"
        ],
        "question": "How many clients opened their accounts in Jesenik branch were women?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'",
        "amends": [
            "Do join `client` directly to `district` on `district_id` instead of joining through `disp` and `account` tables. Do use `COUNT(T1.client_id)` without `DISTINCT` instead of `COUNT(DISTINCT c.client_id)` since the direct join eliminates duplicate counting. Do place both filters `T1.gender = 'F'` and `T2.A2 = 'Jesenik'` in the `WHERE` clause instead of separating them across different tables. Do reference `T1.district_id` for the join condition instead of navigating through multiple table relationships. The amended query now correctly counts female clients from the Jesenik district using the direct relationship between client and district tables."
        ],
        "rules": [
            "A2 has region names; Woman and female share the same meaning; female refers to gender = 'F'"
        ]
    },
    "1462": {
        "sql": [
            "SELECT b.category, b.amount\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'January Speaker';"
        ],
        "question": "What category was budgeted for the 'January Speaker' event and how much was the amount budgeted for that category?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category, T2.amount FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'January Speaker'",
        "amends": [],
        "rules": [
            "amount budgeted refers to amount, 'January Speaker' is the event name;"
        ]
    },
    "282": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN a.element = 'h' THEN 1 ELSE 0 END) * 1.0 / COUNT(a.element)) AS ratio,\n    m.label\nFROM \n    atom a\nJOIN \n    molecule m ON a.molecule_id = m.molecule_id\nWHERE \n    a.molecule_id = 'TR006'\nGROUP BY \n    m.label;"
        ],
        "question": "What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label",
        "amends": [],
        "rules": [
            "hydrogen refers to element = 'h'; ratio = DIVIDE(SUM(element = 'h'), count(element)) where molecule_id = 'TR006' ; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "35": {
        "sql": [
            "SELECT s.AdmEmail1\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.`Charter School (Y/N)` = 1\nORDER BY f.`Enrollment (K-12)` ASC\nLIMIT 1;"
        ],
        "question": "What is the administrator's email address of the chartered school with the fewest students enrolled in grades 1 through 12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.AdmEmail1 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter School (Y/N)` = 1 ORDER BY T1.`Enrollment (K-12)` ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Charted school means `Charter School (Y/N)` = 1 in the table frpm; Students enrolled in grades 1 through 12 refers to `Enrollment (K-12)`"
        ]
    },
    "661": {
        "sql": [
            "SELECT Age FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "question": "How old is the most influential user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Age FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "amends": [],
        "rules": [
            "How old describes age; the most influential refers to user where MAX(Reputation);"
        ]
    },
    "373": {
        "sql": [
            "SELECT name FROM cards WHERE artist = 'Aaron Boyd';"
        ],
        "question": "Name the cards that were illustrated by Aaron Boyd.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd'",
        "amends": [],
        "rules": [
            "Aaron Boyd' is artist;"
        ]
    },
    "228": {
        "sql": [
            "SELECT \n    ROUND((SUM(CASE WHEN element = 'h' THEN 1 ELSE 0 END) * 100.0 / COUNT(atom_id), 4) AS percentage\nFROM \n    atom\nWHERE \n    molecule_id = 'TR206';",
            "SELECT ROUND((CAST(COUNT(CASE WHEN T.element = 'H' THEN 1 ELSE NULL END) AS REAL) / COUNT(*)) * 100, 4) AS percentage\nFROM atom T\nWHERE T.molecule_id = 'TR206';",
            "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100.0 / COUNT(T.atom_id), 4) FROM atom T WHERE T.molecule_id = 'TR206';"
        ],
        "question": "How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id),4) FROM atom AS T WHERE T.molecule_id = 'TR206'",
        "amends": [
            "Do use `CAST` to convert the count to `REAL` instead of relying on implicit integer division. Do reference the table with alias `T` consistently instead of omitting table qualifiers. Do use `COUNT` with explicit `NULL` handling in the case expression instead of `SUM` with 1/0 values. Do place the entire calculation within `ROUND` instead of having the division outside the rounding function. Do maintain the same `WHERE` filter on `molecule_id` but with proper table qualification. The amended query now correctly handles floating-point division and matches the right SQL's behavior.",
            "Do use `COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END)` instead of `COUNT(CASE WHEN T.element = 'H' THEN 1 ELSE NULL END)` to count specific non-null values rather than counting 1s. Do multiply the count result by 100 before division instead of dividing first then multiplying. Do divide by `COUNT(T.atom_id)` instead of `COUNT(*)` to exclude null atom_id values from the denominator. Do use lowercase 'h' instead of uppercase 'H' for the element comparison. Do remove the alias `AS percentage` instead of keeping it. The amended query now correctly calculates the percentage of 'h' elements while handling null values appropriately and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "hydrogen refers to element = 'h'; TR206 is the molecule id; percentage = DIVIDE(SUM(element = 'h'), COUNT(atom_id)) as percent where molecule_id = 'TR206'"
        ]
    },
    "802": {
        "sql": [
            "SELECT superhero_name FROM superhero WHERE height_cm = (SELECT MAX(height_cm) FROM superhero);",
            "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;"
        ],
        "question": "Who is the tallest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "amends": [
            "Do use `ORDER BY height_cm DESC LIMIT 1` instead of a subquery with `MAX(height_cm)` to find the tallest superhero. Do remove the subquery structure entirely instead of using a correlated approach. Do eliminate the `WHERE` clause filter that compared height to a maximum value instead of keeping it. The amended query now correctly returns the superhero with the maximum height by sorting and limiting rather than using a potentially problematic subquery approach."
        ],
        "rules": [
            "who refers to superhero_name; tallest superhero refers to MAX(height_cm);"
        ]
    },
    "1473": {
        "sql": [
            "SELECT AVG(Consumption) / 12 AS AverageMonthlyConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Segment = 'SME' AND SUBSTR(ym.Date, 1, 4) = '2013';"
        ],
        "question": "What was the average monthly consumption of customers in SME for the year 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.Consumption) / 12 FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME'",
        "amends": [],
        "rules": [
            "Average Monthly consumption = AVG(Consumption) / 12; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year."
        ]
    },
    "190": {
        "sql": [
            "SELECT COUNT(*) \nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE strftime('%Y', c.birth_date) = '1920' \nAND d.A3 = 'east Bohemia';"
        ],
        "question": "How many clients who were born in 1920 stay in east Bohemia?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.birth_date) = '1920' AND T2.A3 = 'east Bohemia'",
        "amends": [],
        "rules": [
            "East Bohemia appears in the column A3, which refers to the region."
        ]
    },
    "246": {
        "sql": [
            "SELECT b.bond_type, b.bond_id\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE SUBSTR(a.atom_id, 7, 2) + 0 = 45;"
        ],
        "question": "List the bond type and the bond ID of the atom 45.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type, T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE SUBSTR(T2.atom_id, 7, 2) = '45'",
        "amends": [],
        "rules": [
            "bond ID of atom 45 refers to SUBSTR(atom_id, 7, 2) + 0 = 45; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ]
    },
    "1085": {
        "sql": [
            "SELECT p.player_name, pa.crossing\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone')\nORDER BY pa.crossing DESC\nLIMIT 1;"
        ],
        "question": "Which of these players performs the best in crossing actions, Alexis, Ariel Borysiuk or Arouna Kone?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name, t2.crossing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY t2.crossing DESC LIMIT 1",
        "amends": [],
        "rules": [
            "player who perform best in crossing actions refers to MAX(crossing);"
        ]
    },
    "409": {
        "sql": [
            "SELECT COUNT(DISTINCT c.id) \nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nJOIN rulings r ON c.uuid = r.uuid\nWHERE l.format = 'premodern' \nAND r.text = 'This is a triggered mana ability.' \nAND c.side IS NULL;"
        ],
        "question": "Indicates the number of cards with pre-modern format, ruling text \"This is a triggered mana ability.\" that do not have multiple faces.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN rulings AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'premodern' AND T3.text = 'This is a triggered mana ability.' AND T1.Side IS NULL",
        "amends": [],
        "rules": [
            "pre-modern format refers to format = 'premodern' ;do not have multiple faces refers to side IS NULL"
        ]
    },
    "905": {
        "sql": [
            "SELECT AVG(r.points) AS average_points\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.year = 2000 AND d.forename = 'Eddie' AND d.surname = 'Irvine';",
            "SELECT AVG(ds.points) FROM driverStandings ds INNER JOIN drivers d ON ds.driverId = d.driverId INNER JOIN races r ON ds.raceId = r.raceId WHERE d.forename = 'Eddie' AND d.surname = 'Irvine' AND r.year = 2000"
        ],
        "question": "What is Eddie Irvine's average points scored in year 2000?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine' AND T3.year = 2000",
        "amends": [
            "Do join `driverStandings` instead of `results` as the source for points data. Do use `INNER JOIN` on `driverStandings` with `driverId` instead of joining `results` with `raceId`. Do maintain the same filter conditions for `forename`, `surname`, and `year` but apply them to the correct table aliases. Do remove the column alias `average_points` instead of keeping it. The amended query now correctly calculates average points from driver standings rather than race results, matching the intended behavior."
        ],
        "rules": [
            "average points = AVG(points where year = 2000)"
        ]
    },
    "1014": {
        "sql": [
            "SELECT c.name AS circuit_name, r.name AS race_name, res.time AS lap_record\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nJOIN results res ON r.raceId = res.raceId\nWHERE c.country = 'Italy'\nAND res.time IS NOT NULL\nORDER BY res.time ASC;",
            "WITH fastest_lap_times AS (\n    SELECT \n        c.circuitId,\n        c.name AS circuit_name,\n        r.name AS race_name,\n        res.FastestLapTime,\n        CAST(SUBSTR(res.FastestLapTime, 1, INSTR(res.FastestLapTime, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(res.FastestLapTime, INSTR(res.FastestLapTime, ':') + 1) AS REAL) AS time_in_seconds\n    FROM results res\n    JOIN races r ON res.raceId = r.raceId\n    JOIN circuits c ON r.circuitId = c.circuitId\n    WHERE c.country = 'Italy'\n    AND res.FastestLapTime IS NOT NULL\n)\nSELECT \n    FastestLapTime as lap_record\nFROM fastest_lap_times\nWHERE time_in_seconds = (\n    SELECT MIN(time_in_seconds)\n    FROM fastest_lap_times\n)\nLIMIT 1;"
        ],
        "question": "Please list the lap records for the circuits in Italy.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "amends": [
            "Do use a CTE `fastest_lap_times` to convert `FastestLapTime` to seconds instead of directly using `res.time`. Do select only `T1.FastestLapTime as lap_record` instead of multiple columns `circuit_name`, `race_name`, and `lap_record`. Do join `results`, `races`, and `circuits` tables with proper aliases instead of simple joins. Do add a subquery to find the minimum lap time in seconds for Italian circuits instead of filtering by country directly. Do convert the `FastestLapTime` to seconds in the join condition to match against the minimum time instead of ordering by raw time. Do add `LIMIT 1` to return only the fastest lap record instead of ordering all results. Do remove the explicit `ORDER BY` clause since the minimum time logic handles the ordering. The amended query now correctly identifies the absolute fastest lap time record for Italian circuits by properly converting time formats and finding the minimum value."
        ],
        "rules": [
            "lap record means the fastest time recorded which refers to time"
        ]
    },
    "289": {
        "sql": [
            "SELECT label FROM molecule WHERE molecule_id = 'TR151';"
        ],
        "question": "Is molecule TR151 carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR151'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "330": {
        "sql": [
            "SELECT (SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM molecule m\nJOIN atom a1 ON m.molecule_id = a1.molecule_id\nJOIN connected c ON a1.atom_id = c.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a1.element = 'h' AND b.bond_type = '#';",
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN T1.label = '+' THEN T1.molecule_id END) AS REAL) / \n     CAST(COUNT(DISTINCT T1.molecule_id) AS REAL)) * 100.0 AS percentage\nFROM \n    molecule T1\nINNER JOIN \n    atom a ON T1.molecule_id = a.molecule_id\nINNER JOIN \n    bond b ON T1.molecule_id = b.molecule_id\nWHERE \n    a.element = 'H' \n    AND b.bond_type = 'triple'",
            "SELECT \n    (SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT T1.molecule_id)\nFROM \n    molecule T1\n    INNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN bond T3 ON T1.molecule_id = T3.molecule_id\nWHERE \n    T2.element = 'h' AND \n    T3.bond_type = '#'",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id)\nFROM \n    molecule T1\n    INNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN bond T3 ON T1.molecule_id = T3.molecule_id\nWHERE \n    T3.bond_type = '#' AND T2.element = 'h'",
            "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id)\nFROM molecule T1 \nINNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id \nINNER JOIN bond T3 ON T1.molecule_id = T3.molecule_id\nWHERE T3.bond_type = '#' AND T2.element = 'h'"
        ],
        "question": "Calculate the percentage of carcinogenic molecules with triple bonded Hidrogen atoms.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T2.element = 'h'",
        "amends": [
            "Do use explicit `CAST` to `REAL` for the sum calculation instead of implicit conversion. Do reference the molecule table as `T1` instead of `m` and use table aliases consistently throughout. Do join directly to `bond` table on `molecule_id` instead of through the complex `atom-connected-atom-bond` chain. Do simplify the FROM clause with `INNER JOIN` on `molecule_id` instead of multiple joins through connected atoms. Do move both filter conditions to the `WHERE` clause instead of having them scattered. Do remove the unnecessary `DISTINCT` from the molecule count since molecule_id should already be unique per molecule. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. The amended query now correctly calculates the percentage of '+' labeled molecules with hydrogen atoms and triple bonds by simplifying the join logic and ensuring proper numeric conversion.",
            "Do use `SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT CASE WHEN T1.label = '+' THEN T1.molecule_id END)` to count positive labels without unnecessary distinct operations. Do remove the explicit `CAST(REAL)` conversions around the count operations since the division will handle type conversion. Do change the bond filter to `T3.bond_type = '#'` instead of `b.bond_type = 'triple'` to match the correct bond type notation. Do change the element filter to `T2.element = 'h'` instead of `a.element = 'H'` to use lowercase matching. Do remove the table aliases `a` and `b` in favor of `T2` and `T3` for consistency. Do remove the multiplication by `100.0` at the end and instead place `* 100` after the division to maintain the same percentage calculation logic. The amended query now correctly calculates the percentage of molecules with positive labels among those containing hydrogen atoms and triple bonds.",
            "Do add `CAST(... AS REAL)` around the SUM expression instead of omitting it to ensure proper floating-point division. Do remove the `100.0` decimal notation and use integer `100` instead while maintaining the same mathematical operation. Do reorder the WHERE clause predicates to `T3.bond_type = '#' AND T2.element = 'h'` instead of the original order, though this is functionally equivalent. Do remove the explicit table aliases `AS` keyword from the FROM clause while keeping the same table references. The amended query now correctly handles the floating-point division by casting the SUM result to REAL before multiplication and division, ensuring accurate percentage calculation while maintaining the same logical behavior as the RIGHT_SQL.",
            "Do keep the identical SELECT list with `CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id)` instead of changing it. Do maintain the same FROM sources with `molecule T1 INNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond T3 ON T1.molecule_id = T3.molecule_id` instead of altering the join structure. Do preserve the identical WHERE filters with `T3.bond_type = '#' AND T2.element = 'h'` instead of modifying the conditions. The amended query now matches RIGHT_SQL's behavior by maintaining all the same logic and calculations without any substantive changes to the query structure or semantics."
        ],
        "rules": [
            "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) * 100.0 where element = 'h' AND bond_type = '#';"
        ]
    },
    "1331": {
        "sql": [
            "SELECT SUM(i.amount) AS total_funds_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.position = 'Vice President';"
        ],
        "question": "What is the amount of the funds that the Vice President received?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "amends": [],
        "rules": [
            "'Vice President' is a position of Student Club; funds received refers to amount."
        ]
    },
    "284": {
        "sql": [
            "SELECT b.bond_type, COUNT(*) AS count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a1.element = 'c' OR a2.element = 'c'\nGROUP BY b.bond_type;",
            "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'"
        ],
        "question": "Determine the bond type that is formed in the chemical compound containing element Carbon.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'",
        "amends": [
            "Do select only `DISTINCT T2.bond_type` instead of `b.bond_type, COUNT(*) AS count` with aggregation. Do use `atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id` instead of joining through `connected` table with multiple `atom` joins on `atom_id` and `bond` on `bond_id`. Do apply filter `WHERE T1.element = 'c'` instead of `WHERE a1.element = 'c' OR a2.element = 'c'`. Do remove `GROUP BY b.bond_type` and aggregation entirely instead of keeping it. The amended query now correctly finds distinct bond types associated with carbon atoms by directly joining atom to bond via molecule_id instead of the complex connected table path."
        ],
        "rules": [
            "Carbon refers to element = 'c'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ]
    },
    "407": {
        "sql": [
            "SELECT DISTINCT c.types\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'German' AND c.types IS NOT NULL;",
            "SELECT T1.subtypes, T1.supertypes\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T2.language = 'German'\nAND T1.subtypes IS NOT NULL\nAND T1.supertypes IS NOT NULL"
        ],
        "question": "Lists all types of cards in German.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.subtypes, T1.supertypes FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.subtypes IS NOT NULL AND T1.supertypes IS NOT NULL",
        "amends": [
            "Do select `subtypes` and `supertypes` instead of `types`. Do use `INNER JOIN` instead of `JOIN` while maintaining the same join condition `T1.uuid = T2.uuid`. Do add filter conditions `T1.subtypes IS NOT NULL` and `T1.supertypes IS NOT NULL` instead of only `c.types IS NOT NULL`. Do remove `DISTINCT` instead of keeping it. Do use table aliases `T1` and `T2` instead of `c` and `fd`. The amended query now correctly retrieves both subtypes and supertypes for German language cards while ensuring neither field contains null values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "German refer to language; all types refer to the subtypes, supertypes; subtypes is not null AND supertypes is not null"
        ]
    },
    "1059": {
        "sql": [
            "SELECT player_name FROM Player WHERE height > 180;"
        ],
        "question": "Please list player names which are higher than 180.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE height > 180",
        "amends": [],
        "rules": [
            "height>180;"
        ]
    },
    "154": {
        "sql": [
            "SELECT COUNT(*) \nFROM client \nWHERE gender = 'M' AND district_id = (SELECT district_id FROM district WHERE A2 = 'Hl.m. Praha');"
        ],
        "question": "How many male clients in 'Hl.m. Praha' district?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'",
        "amends": [],
        "rules": [
            "District data appears in the A2; Male means that gender = 'M'"
        ]
    },
    "696": {
        "sql": [
            "SELECT COUNT(*) FROM posts WHERE Tags LIKE '%careers%';",
            "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers';"
        ],
        "question": "Count the number of posts with a tag specified as 'careers'.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers'",
        "amends": [
            "Do query the `tags` table instead of the `posts` table. Do filter on `TagName = 'careers'` instead of using `LIKE '%careers%'` on a `Tags` column. Do count `Id` values instead of using `COUNT(*)`. Do remove the wildcard pattern matching and instead use exact equality comparison for the tag name. The amended query now correctly counts entries from the tags table where the tag name exactly matches 'careers', matching the intended behavior."
        ],
        "rules": [
            "tag specified as 'careers' refers to TagName = 'careers';"
        ]
    },
    "1355": {
        "sql": [
            "SELECT z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison';"
        ],
        "question": "Where is the hometown state for \"Sacha Harrison\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
        "amends": [],
        "rules": [
            "hometown state refers to state;"
        ]
    },
    "443": {
        "sql": [
            "SELECT code FROM sets WHERE type = 'expansion';",
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'expansion' GROUP BY T2.setCode"
        ],
        "question": "Give the code of sets have expansion type of 'expansion'?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'expansion' GROUP BY T2.setCode",
        "amends": [
            "Do use `T2.setCode` in the SELECT list instead of `code` from the original table. Do add an `INNER JOIN` with `set_translations AS T2` on `T2.setCode = T1.code` instead of querying only the `sets` table. Do alias the sets table as `T1` instead of using it directly without an alias. Do add a `GROUP BY T2.setCode` clause instead of omitting any grouping. Do keep the `WHERE T1.type = 'expansion'` filter but reference it through the table alias instead of directly. The amended query now correctly joins the translation data and groups by the set code to match the intended behavior."
        ],
        "rules": [
            "code of sets refers to setCode"
        ]
    },
    "351": {
        "sql": [
            "SELECT DISTINCT c.name FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Japanese';"
        ],
        "question": "Name all the cards which have alternative language in Japanese.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'",
        "amends": [],
        "rules": [
            "Japanese' is the language;"
        ]
    },
    "181": {
        "sql": [
            "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.gender = 'F'\nORDER BY l.amount DESC\nLIMIT 3;"
        ],
        "question": "Please provide the IDs of the 3 female clients with the largest loans.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T4 on T1.client_id= T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id  INNER JOIN loan AS T3 ON T2.account_id = T3.account_id and T4.account_id = T3.account_id WHERE T1.gender = 'F' ORDER BY T3.amount DESC LIMIT 3",
        "amends": [],
        "rules": [
            "Female refers to gender = 'F'"
        ]
    },
    "1091": {
        "sql": [
            "SELECT COUNT(*) AS number_of_matches\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Belgium Jupiler League')\nAND date LIKE '2009-04-%';"
        ],
        "question": "How many matches were held in the Belgium Jupiler League in April, 2009?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND SUBSTR(t2.`date`, 1, 7) = '2009-04'",
        "amends": [],
        "rules": [
            "Belgium Jupiler League refers to League.name = 'Belgium Jupiler League'; in April, 2009 refers to SUBSTR(`date`, 1, 7);"
        ]
    },
    "184": {
        "sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS female_junior_card_holders\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE c.gender = 'F' AND ca.type = 'junior';"
        ],
        "question": "How many female customers have a junior credit card?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "amends": [],
        "rules": [
            "Female refers to gender = 'F'"
        ]
    },
    "964": {
        "sql": [
            "SELECT code FROM drivers WHERE nationality = 'America';",
            "SELECT code FROM drivers WHERE nationality = 'American';"
        ],
        "question": "List out the code for drivers who have nationality in America.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT code FROM drivers WHERE Nationality = 'American'",
        "amends": [
            "Do use the exact string literal `'American'` instead of `'America'` in the WHERE filter condition. Do maintain the same column name `nationality` but ensure proper capitalization consistency. The amended query now correctly filters for drivers with American nationality instead of the incorrect 'America' value, matching the intended behavior."
        ],
        "rules": [
            "nationality = 'America'"
        ]
    },
    "1235": {
        "sql": [
            "SELECT P.ID, P.Diagnosis, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.RBC < 3.5;",
            "SELECT DISTINCT T1.Diagnosis, T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) - (STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', T1.Birthday)) FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5;",
            "SELECT DISTINCT T1.Diagnosis, T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5"
        ],
        "question": "What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.Diagnosis, T1.ID , STRFTIME('%Y', CURRENT_TIMESTAMP) -STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate result rows. Do change the column order to `Diagnosis, ID` instead of `ID, Diagnosis`. Do use `STRFTIME('%Y', CURRENT_TIMESTAMP)` instead of `strftime('%Y', 'now')` for the current year calculation. Do remove the `Age` alias instead of keeping it for the calculated age column. Do use `INNER JOIN` with explicit keyword instead of just `JOIN`. Do use table aliases `T1` and `T2` instead of `P` and `L`. Do keep the same join condition `T1.ID = T2.ID` instead of changing it. Do use the same filter `T2.RBC < 3.5` instead of changing it. The amended query now correctly returns distinct patient records with proper current year calculation and matches the intended behavior.",
            "Do remove the age calculation adjustment `- (STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', T1.Birthday))` instead of including it, as the correct query only calculates the year difference without month/day adjustment. Do simplify the age expression to `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)` instead of the complex conditional subtraction. The amended query now correctly calculates age based solely on year difference and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "patient's diagnosis refers to Diagnosis; lower red blood cell refers to RBC < 3.5; age = SUBTRACT(year(current_timestamp), year(Birthday)); "
        ]
    },
    "314": {
        "sql": [
            "SELECT COUNT(*) AS single_bond_count FROM bond WHERE bond_type = '-';"
        ],
        "question": "How many single bonds are there in the list?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '-'",
        "amends": [],
        "rules": [
            "single bond refers to bond_type = '-';"
        ]
    },
    "1479": {
        "sql": [
            "SELECT SUBSTR(ym.Date, 1, 4) AS Year, SUM(ym.Consumption) AS TotalConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Currency = 'CZK'\nGROUP BY Year\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "SELECT SUBSTR(T2.Date, 1, 4) \nFROM yearmonth T2\nINNER JOIN customers T1 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK'\nGROUP BY SUBSTR(T2.Date, 1, 4)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;"
        ],
        "question": "Which year recorded the most consumption of gas paid in CZK?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do reference the yearmonth table as `T2` instead of `ym` and customers table as `T1` instead of `c` in the SELECT clause. Do use `INNER JOIN` explicitly instead of just `JOIN` while keeping the same join condition `T1.CustomerID = T2.CustomerID`. Do remove the alias `Year` from the SELECT expression and instead reference `SUBSTR(T2.Date, 1, 4)` directly in both SELECT and GROUP BY clauses. Do remove the alias `TotalConsumption` from the aggregated column and instead reference `SUM(T2.Consumption)` directly in the ORDER BY clause. The amended query now correctly groups by the year expression and orders by the sum of consumption without unnecessary aliases, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "The first 4 strings of the Date values in the yearmonth table can represent year."
        ]
    },
    "309": {
        "sql": [
            "SELECT a.atom_id, COUNT(DISTINCT b.bond_type) AS bond_type_count\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nLEFT JOIN bond b ON m.molecule_id = b.molecule_id\nWHERE m.label = 'TR346'\nGROUP BY a.atom_id;",
            "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type) AS bond_type_count\nFROM atom T1\nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR346'\nGROUP BY T1.atom_id",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(T2.bond_type) \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR346' \nGROUP BY T1.atom_id",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR346' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR000'\nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR000'\nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type), T1.molecule_id\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR000'\nGROUP BY T1.atom_id, T2.bond_type"
        ],
        "question": "List out the atom id that belongs to the TR346 molecule and how many bond type can be created by this molecule?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type),T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR000' GROUP BY T1.atom_id, T2.bond_type",
        "amends": [
            "Do select `T1.molecule_id` instead of omitting it. Do use `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of `LEFT JOIN` on `m.molecule_id = b.molecule_id`. Do filter on `T1.molecule_id = 'TR000'` instead of `m.label = 'TR346'`. Do group by `T1.atom_id, T2.bond_type` instead of just `a.atom_id`. Do remove the `molecule` table entirely instead of including it as a source. The amended query now correctly counts distinct bond types per atom within the specified molecule while maintaining proper grouping semantics.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do change the WHERE filter to `T1.molecule_id = 'TR000'` instead of `T1.molecule_id = 'TR346'`. Do add `T2.bond_type` to the GROUP BY clause instead of grouping only by `T1.atom_id`. Do remove the alias `AS bond_type_count` from the COUNT expression instead of keeping it. The amended query now correctly includes all non-aggregated columns in GROUP BY and filters for the correct molecule ID, matching the intended behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of including `T1.molecule_id` in the GROUP BY clause since it's already filtered to a single value in the WHERE clause. The amended query now correctly counts distinct bond types per atom while maintaining the molecule_id in the output, matching the RIGHT_SQL's behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do add `DISTINCT` to `COUNT(T2.bond_type)` instead of counting duplicates. Do remove `T1.molecule_id` from the GROUP BY clause instead of including it, as it's functionally dependent on the WHERE filter. Do keep the same join condition `T1.molecule_id = T2.molecule_id` and maintain the `INNER JOIN` type. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in results, matching the intended behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it, and do change the WHERE filter to `T1.molecule_id = 'TR000'` instead of `T1.molecule_id = 'TR346'`. Do add `T2.bond_type` to the GROUP BY clause instead of grouping only by `T1.atom_id`, and do remove the `T1.molecule_id` from the GROUP BY since it's now included in the SELECT list with proper grouping. The amended query now correctly counts distinct bond types per atom while maintaining the molecule_id in results and filtering for the correct molecule identifier.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do use `AS` for table aliases instead of omitting the keyword. Do group by `T1.atom_id, T2.bond_type` instead of including `T1.molecule_id` in the GROUP BY clause since it's functionally dependent on the WHERE filter. The amended query now correctly returns molecule_id in the results while maintaining proper grouping semantics.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id` to properly align with the COUNT(DISTINCT T2.bond_type) aggregation. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in the output and maintaining proper grouping semantics.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of grouping by `T1.atom_id, T1.molecule_id, T2.bond_type` since the molecule_id filter makes grouping by it redundant. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in the output and matches the RIGHT_SQL's behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it, and do filter for `'TR000'` instead of `'TR346'` in the WHERE clause. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id, T2.bond_type` since `T1.molecule_id` is now properly included in the SELECT list rather than being part of the GROUP BY. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in the output and filtering for the correct molecule identifier.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it, and do move `T1.molecule_id` to the end of the SELECT list instead of having it as the second column. Do keep the same FROM clause with `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of changing it. Do maintain the WHERE filter on `T1.molecule_id = 'TR000'` instead of altering it. Do preserve the GROUP BY clause with `T1.atom_id, T2.bond_type` instead of modifying it. The amended query now correctly includes all necessary columns in the output while maintaining the same aggregation logic and filtering behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id, T2.bond_type` since `T1.molecule_id` is now properly included in the SELECT list and the grouping remains consistent with the distinct bond type counting logic. The amended query now correctly returns atom_id, distinct bond type count, and molecule_id for each atom-bond_type combination within the specified molecule.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id, T2.bond_type` since `T1.molecule_id` is now properly included in the SELECT list and the grouping remains consistent with the distinct bond type counting. The amended query now correctly returns atom_id, distinct bond type count, and molecule_id for each atom-bond_type combination within the specified molecule.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id, T2.bond_type` since the molecule_id filter is already applied in WHERE clause and doesn't need grouping. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in results and matches the intended behavior."
        ],
        "rules": []
    },
    "461": {
        "sql": [
            "SELECT name FROM cards WHERE frameVersion = '2003' ORDER BY convertedManaCost DESC LIMIT 3;"
        ],
        "question": "Please list the names of the top 3 cards with the highest converted mana cost and have a 2003 card frame style.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM cards WHERE frameVersion = 2003 ORDER BY convertedManaCost DESC LIMIT 3",
        "amends": [],
        "rules": [
            "name of cards refers to name; 2003 card frame style refers to frameVersion = '2003'"
        ]
    },
    "465": {
        "sql": [
            "SELECT COUNT(*) > 0 AS has_korean_version\nFROM foreign_data\nWHERE uuid = (SELECT uuid FROM cards WHERE name = 'Ancestor''s Chosen')\nAND language = 'Korean';",
            "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') AS has_korean_version\nFROM cards AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode\nWHERE T1.name = 'Ancestor''s Chosen';"
        ],
        "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "amends": [
            "Do use `IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO')` instead of `COUNT(*) > 0 AS has_korean_version` to properly check for Korean translations with content. Do join `cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode` instead of querying `foreign_data` with a subquery for `uuid`. Do filter with `WHERE T1.name = 'Ancestor''s Chosen'` instead of using a subquery condition on `uuid` and separate `language` filter. Do remove the direct `language` filter and instead incorporate it into the conditional sum logic to check for both Korean language and non-null translations. The amended query now correctly identifies whether Korean translations exist for the specified card by joining through set relationships rather than relying on a potentially incorrect foreign_data table structure."
        ],
        "rules": [
            "set of cards with \"Ancestor''s Chosen\" in it refers to name = 'Ancestor''s Chosen'; Korean version refers to language = 'Korean'"
        ]
    },
    "1467": {
        "sql": [
            "SELECT e.event_name, SUM(b.spent) AS total_spent_on_speaker_gifts\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE b.category = 'Speaker Gifts'\nGROUP BY e.event_name;",
            "SELECT T2.event_name, SUM(T1.spent) \nFROM budget T1 \nINNER JOIN event T2 ON T1.link_to_event = T2.event_id \nWHERE T1.category = 'speaker gifts' \nGROUP BY T2.event_name",
            "SELECT SUM(T1.spent), T2.event_name\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Speaker Gifts'\nGROUP BY T2.event_name"
        ],
        "question": "Calculate the total amount spent on speaker gifts and list the name of the event they were spent on.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.spent), T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Speaker Gifts' GROUP BY T2.event_name",
        "amends": [
            "Do use `SUM(T1.spent)` without an alias instead of `SUM(b.spent) AS total_spent_on_speaker_gifts` with an alias. Do use table aliases `T1` and `T2` instead of direct table names `b` and `e`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T2.event_name` in both SELECT and GROUP BY instead of `e.event_name`. Do remove the column alias `total_spent_on_speaker_gifts` instead of keeping it. The amended query now correctly aggregates spending by event name without unnecessary aliasing while maintaining the same logical behavior.",
            "Do place `SUM(T1.spent)` before `T2.event_name` in the SELECT list instead of the reverse order. Do use uppercase 'Speaker Gifts' in the WHERE filter instead of lowercase 'speaker gifts'. Do add table aliases with `AS` keyword for both tables instead of omitting them. The amended query now correctly sums spending for speaker gifts with proper case sensitivity and follows conventional column ordering."
        ],
        "rules": [
            "total amount spent = SUM(spent) where category = 'Speaker Gifts'"
        ]
    },
    "830": {
        "sql": [
            "SELECT a.attribute_name \nFROM hero_attribute ha \nJOIN attribute a ON ha.attribute_id = a.id \nJOIN superhero s ON ha.hero_id = s.id \nWHERE s.superhero_name = 'Black Panther' \nORDER BY ha.attribute_value ASC \nLIMIT 1;"
        ],
        "question": "Identify the weakest attribute of the Black Panther.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.attribute_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = 'Black Panther' ORDER BY T2.attribute_value ASC LIMIT 1",
        "amends": [],
        "rules": [
            "weakest attribute refers to attribute_name WHERE MIN(attribute_value); Black Panther refers to superhero_name = 'Black Panther';"
        ]
    },
    "257": {
        "sql": [
            "SELECT c.atom_id2\nFROM connected c\nJOIN atom a ON c.atom_id = a.atom_id\nWHERE a.element = 's';"
        ],
        "question": "List down atom id2 for atoms with element sulfur.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'",
        "amends": [],
        "rules": [
            "element sulfur refers to element = 's'"
        ]
    },
    "908": {
        "sql": [
            "SELECT r.name AS race_name, r.year, c.location AS circuit_location, MAX(re.laps) AS max_laps\nFROM results re\nJOIN races r ON re.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nGROUP BY re.raceId\nORDER BY max_laps DESC\nLIMIT 1;",
            "SELECT T3.lap, T2.name, T2.year, T1.location\nFROM circuits AS T1\nJOIN races AS T2 ON T1.circuitId = T2.circuitId\nJOIN lapTimes AS T3 ON T3.raceId = T2.raceId\nORDER BY T3.lap DESC\nLIMIT 1;"
        ],
        "question": "What is the most laps f1 races had? Name the race, year and circuit location where the races with most laps was hosted.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.lap, T2.name, T2.year, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId INNER JOIN lapTimes AS T3 ON T3.raceId = T2.raceId ORDER BY T3.lap DESC LIMIT 1",
        "amends": [
            "Do select `T3.lap`, `T2.name`, `T2.year`, and `T1.location` instead of `r.name`, `r.year`, `c.location`, and `MAX(re.laps)`. Do join `circuits AS T1` and `races AS T2` with `T1.circuitId = T2.circuitId` instead of joining `results`, `races`, and `circuits` with different join conditions. Do add `lapTimes AS T3` with `T3.raceId = T2.raceId` instead of omitting this table entirely. Do remove the `GROUP BY re.raceId` and aggregation instead of keeping them. Do order by `T3.lap DESC` instead of `max_laps DESC`. The amended query now correctly retrieves lap time data rather than maximum laps from results, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "819": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN s.eye_colour_id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN s.eye_colour_id = 1 THEN 1 ELSE 0 END)) AS difference\nFROM \n    superhero s\nWHERE \n    s.weight_kg = 0 OR s.weight_kg IS NULL;"
        ],
        "question": "In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL",
        "amends": [],
        "rules": [
            "missing weight data refers to weight_kg = 0 OR T1.weight_kg = NULL; difference = SUBTRACT(SUM(colour.id = 7), SUM(colour.id = 1)); blue eyes refers to eye_colour_id WHERE colour.id = 7; no eye color refers to eye_colour_id WHERE colour.id = 1;"
        ]
    },
    "1482": {
        "sql": [
            "",
            "WITH Consumption2012 AS (\n    SELECT \n        c.Segment,\n        SUM(ym.Consumption) AS TotalConsumption2012\n    FROM \n        yearmonth ym\n    JOIN \n        customers c ON ym.CustomerID = c.CustomerID\n    WHERE \n        c.Currency = 'EUR' \n        AND ym.Date LIKE '2012%'\n    GROUP BY \n        c.Segment\n),\nConsumption2013 AS (\n    SELECT \n        c.Segment,\n        SUM(ym.Consumption) AS TotalConsumption2013\n    FROM \n        yearmonth ym\n    JOIN \n        customers c ON ym.CustomerID = c.CustomerID\n    WHERE \n        c.Currency = 'EUR' \n        AND ym.Date LIKE '2013%'\n    GROUP BY \n        c.Segment\n)\nSELECT \n    c12.Segment,\n    c12.TotalConsumption2012 AS Consumption_2012,\n    c13.TotalConsumption2013 AS Consumption_2013,\n    CAST((c13.TotalConsumption2013 - c12.TotalConsumption2012) * 100.0 / c12.TotalConsumption2012 AS REAL) AS PercentageIncrease\nFROM \n    Consumption2012 c12\nJOIN \n    Consumption2013 c13 ON c12.Segment = c13.Segment\nWHERE \n    c12.Segment IN ('SME', 'LAM', 'KAM')\nORDER BY \n    PercentageIncrease DESC;",
            "error",
            "SELECT \n    CAST((SUM(IIF(T2.Date LIKE '2013%' AND T1.Segment = 'SME', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'SME', T2.Consumption, 0))) AS FLOAT) / NULLIF(SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'SME', T2.Consumption, 0)), 0) * 100 AS SME_Percentage_Increase,\n    CAST((SUM(IIF(T2.Date LIKE '2013%' AND T1.Segment = 'LAM', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'LAM', T2.Consumption, 0))) AS FLOAT) / NULLIF(SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'LAM', T2.Consumption, 0)), 0) * 100 AS LAM_Percentage_Increase,\n    CAST((SUM(IIF(T2.Date LIKE '2013%' AND T1.Segment = 'KAM', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'KAM', T2.Consumption, 0))) AS FLOAT) / NULLIF(SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'KAM', T2.Consumption, 0)), 0) * 100 AS KAM_Percentage_Increase\nFROM \n    customers AS T1\nINNER JOIN \n    yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Currency = 'EUR'",
            "SELECT \n    CAST(SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)) * 100 AS SME_Percentage_Increase,\n    CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) * 100 AS LAM_Percentage_Increase,\n    CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) * 100 AS KAM_Percentage_Increase\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment IN ('SME', 'LAM', 'KAM');"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
        "amends": [
            "Do add explicit column aliases for each calculated percentage instead of omitting them, which would result in unnamed columns. Do use consistent CAST placement around the entire percentage calculation instead of only casting the numerator difference, ensuring proper floating-point division. Do maintain the same join condition `T1.CustomerID = T2.CustomerID` and filtering logic using `IIF` with `LIKE` patterns for year extraction instead of changing these elements. The amended query now correctly calculates percentage growth for each segment with proper type casting and explicit column naming, matching the RIGHT_SQL's behavior.",
            "Do use a single query with conditional aggregation instead of separate CTEs for each year. Do calculate percentage increases for each segment directly in the SELECT list using `IIF` conditions instead of joining separate aggregated results. Do filter for segments 'SME', 'LAM', and 'KAM' within the conditional expressions instead of using a WHERE clause on the final result. Do remove the explicit JOIN between CTEs and instead perform all calculations in the main query. Do use `INNER JOIN` between `customers` and `yearmonth` tables instead of separate joins in CTEs. Do cast the difference calculations to `FLOAT` instead of `REAL` for the percentage computation. Do eliminate the ORDER BY clause since the result now returns three scalar values instead of a rowset. The amended query now correctly computes percentage increases for each segment in a single row output.",
            "Do use explicit `CAST(... AS FLOAT)` for all percentage calculations instead of implicit casting in some cases. Do calculate percentage growth for three segments (`SME`, `LAM`, `KAM`) with proper year filtering using `LIKE '2013%'` and `LIKE '2012%'` instead of incorrect date handling. Do maintain the `INNER JOIN` between `customers AS T1` and `yearmonth AS T2` on `T1.CustomerID = T2.CustomerID` to correctly associate customer segments with consumption data. The amended query now properly computes year-over-year percentage growth for each customer segment using explicit type casting and correct date filtering to match the intended analytical behavior.",
            "Do place the `T1.Segment` condition before the `T2.Date` condition in all `IIF` functions instead of after it, though this is purely cosmetic. Do remove the `NULLIF` function calls and instead perform direct division by the denominator sum instead of using null protection. Do remove the `WHERE T1.Currency = 'EUR'` filter instead of keeping it, as the right query includes all currencies. Do remove the column aliases `SME_Percentage_Increase`, `LAM_Percentage_Increase`, and `KAM_Percentage_Increase` instead of keeping them. The amended query now matches the right SQL's behavior by calculating percentage increases for all segments without currency filtering."
        ],
        "rules": [
            "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year"
        ]
    },
    "1370": {
        "sql": [
            "SELECT e.expense_id, e.expense_description, e.expense_date, e.cost, e.approved\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nWHERE m.position = 'Vice President';",
            "SELECT T2.expense_id, T2.expense_description\nFROM member T1\nINNER JOIN expense T2 ON T1.member_id = T2.link_to_member\nWHERE T1.position = 'Vice President';"
        ],
        "question": "List all the expenses incurred by the vice president.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.expense_id, T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "amends": [
            "Do select only `expense_id` and `expense_description` instead of including additional columns `expense_date`, `cost`, and `approved`. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do reference tables with aliases `T1` for `member` and `T2` for `expense` instead of single-letter aliases `m` and `e`. Do specify the join condition as `T1.member_id = T2.link_to_member` instead of `e.link_to_member = m.member_id` to maintain proper table reference clarity. The amended query now correctly filters for Vice President members and returns only the specified expense details, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "expense refers to expense_description; 'Vice President' is a position of the Student Club"
        ]
    },
    "262": {
        "sql": [
            "SELECT DISTINCT b.molecule_id\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '-' AND m.label = '-';"
        ],
        "question": "Among the single bond molecule id, which molecules are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; single bond refers to bond_type = '-';"
        ]
    },
    "293": {
        "sql": [
            "SELECT COUNT(*) AS atom_count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+';"
        ],
        "question": "How many atoms belong to the molecule labeled with carcinogenic compounds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "34": {
        "sql": [
            "SELECT \n    s.School,\n    f.`Free Meal Count (Ages 5-17)` / f.`Enrollment (Ages 5-17)` AS FreeRate\nFROM \n    schools s\nJOIN \n    frpm f ON s.CDSCode = f.CDSCode\nWHERE \n    (s.AdmFName1 = 'Kacey' AND s.AdmLName1 = 'Gibson') OR\n    (s.AdmFName2 = 'Kacey' AND s.AdmLName2 = 'Gibson') OR\n    (s.AdmFName3 = 'Kacey' AND s.AdmLName3 = 'Gibson');",
            "SELECT CAST(T2.\"Free Meal Count (Ages 5-17)\" AS REAL) / T2.\"Enrollment (Ages 5-17)\" AS free_rate\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'"
        ],
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "amends": [
            "Do cast `Free Meal Count (Ages 5-17)` as `REAL` instead of using it directly in division to ensure proper numeric calculation. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `s` and `f`. Do change the `WHERE` clause to use a single condition `T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'` instead of multiple `OR` conditions checking all three administrator name fields. Do remove the `School` column from the `SELECT` list instead of including it, focusing only on the calculated free meal rate. Do remove the table alias prefixes from the column references in the calculation instead of keeping them. The amended query now correctly calculates the free meal rate for schools where the primary administrator matches the specified name, avoiding potential incorrect matches from secondary administrator fields."
        ],
        "rules": [
            "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`"
        ]
    },
    "1323": {
        "sql": [
            "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nWHERE e.type != 'fundraiser'\nGROUP BY e.event_id\nHAVING COUNT(a.link_to_member) > 20;"
        ],
        "question": "List all the names of events that had an attendance of over 20 students but were not fundraisers.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id HAVING COUNT(T2.link_to_event) > 20 EXCEPT SELECT T1.event_name FROM event AS T1  WHERE T1.type = 'Fundraiser'",
        "amends": [],
        "rules": [
            "name of events refers to event_name; attendance of over 20 students COUNT(event_id) > 20."
        ]
    },
    "486": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN c.convertedManaCost = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards c\nJOIN \n    sets s ON c.setCode = s.code\nWHERE \n    s.code = 'CSP';"
        ],
        "question": "What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "amends": [],
        "rules": [
            "converted mana cost of 7 refers to convertedManaCost = 7; card set Coldsnap refers to name = 'Coldsnap'; percentage = DIVIDE(SUM(convertedManaCost = 7), SUM(convertedManaCost))*100"
        ]
    },
    "253": {
        "sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = '#';",
            "SELECT DISTINCT T3.element\nFROM bond T1\nINNER JOIN connected T2 ON T1.bond_id = T2.bond_id\nINNER JOIN atom T3 ON T2.atom_id = T3.atom_id\nWHERE T1.bond_type = '#'"
        ],
        "question": "List the elements of all the triple bonds.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.element FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select only `T3.element` instead of `a1.element` and `a2.element` with aliases. Do use `INNER JOIN` consistently instead of mixing `JOIN` without specification. Do join `atom` as `T3` only on `T2.atom_id = T3.atom_id` instead of joining twice on both `atom_id` and `atom_id2`. Do remove the second atom table join entirely instead of keeping it. Do add `DISTINCT` to eliminate duplicates instead of returning all rows. Do use table aliases `T1`, `T2`, `T3` consistently instead of mixed naming. Do remove the unnecessary `AS` keyword in column aliases instead of keeping it. The amended query now correctly returns distinct element values from atoms involved in bonds of type '#' without the redundant second join."
        ],
        "rules": [
            "triple bond refers to bond_type = '#';"
        ]
    },
    "242": {
        "sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE SUBSTR(a.atom_id, 7, 2) BETWEEN '21' AND '25'\nAND m.label = '+';",
            "SELECT DISTINCT T2.molecule_id\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE CAST(SUBSTR(T1.atom_id, -2) AS INTEGER) BETWEEN 21 AND 25\nAND T2.label = 'carcinogenic';",
            "SELECT DISTINCT T2.molecule_id\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25'\nAND T2.label = '+'"
        ],
        "question": "Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25' AND T2.label = '+'",
        "amends": [
            "Do reference `molecule_id` from `T2` instead of `m` in the SELECT list. Do use table aliases `T1` for `atom` and `T2` for `molecule` instead of `a` and `m`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do change the SUBSTR function to extract from the end using `SUBSTR(T1.atom_id, -2)` instead of `SUBSTR(a.atom_id, 7, 2)` to correctly capture the last two characters. Do remove the `m.label` column from the SELECT list instead of including it, as only `molecule_id` is needed. Do keep the DISTINCT modifier, WHERE filters on the atom_id substring range and label value, and the join condition unchanged as they serve the same logical purpose. The amended query now correctly identifies molecules based on atom_id suffixes rather than fixed positions, matching the RIGHT_SQL's behavior.",
            "Do remove the `CAST(... AS INTEGER)` around `SUBSTR(T1.atom_id, -2)` instead of casting to integer, and do change the string comparison to use `BETWEEN '21' AND '25'` instead of numeric comparison. Do change the `WHERE` filter on `T2.label` to `= '+'` instead of `= 'carcinogenic'`. The amended query now correctly handles string comparison for the atom_id substring and uses the proper label filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "atoms from 21 to 25 refers to SUBSTR(atom_id, 7, 2) between '21' and '25'; label = '+' mean molecules are carcinogenic"
        ]
    },
    "1090": {
        "sql": [
            "SELECT pa.long_passing\nFROM Player_Attributes pa\nJOIN (\n    SELECT player_api_id\n    FROM Player\n    ORDER BY birthday ASC\n    LIMIT 1\n) p ON pa.player_api_id = p.player_api_id\nORDER BY pa.date DESC\nLIMIT 1;"
        ],
        "question": "What is the long passing score of the oldest player?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.long_passing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "long passing score refers to long_passing; oldest player refers to oldest birthday;"
        ]
    },
    "1524": {
        "sql": [
            "SELECT g.Country AS Nationality\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-24' AND t.Price = 548.4;"
        ],
        "question": "What's the nationality of the customer who spent 548.4 in 2012/8/24?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Price = 548.4",
        "amends": [],
        "rules": [
            "'2012/8/24' can be represented by '2012-08-24'"
        ]
    },
    "997": {
        "sql": [
            "SELECT nationality, COUNT(*) AS driver_count FROM drivers GROUP BY nationality ORDER BY driver_count DESC LIMIT 1;",
            "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1;"
        ],
        "question": "Which citizenship do the vast majority of the drivers hold?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1",
        "amends": [
            "Do select only `nationality` instead of including `COUNT(*) AS driver_count` in the SELECT list. Do order by `COUNT(driverId)` instead of ordering by the alias `driver_count`. Do remove the explicit column alias `driver_count` instead of keeping it. The amended query now correctly returns only the nationality with the highest count of driver IDs rather than including the count value itself, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Citizenship of majority of drivers = MAX(nationality); citizenship and nationality are synonyms\n\n"
        ]
    },
    "168": {
        "sql": [
            "WITH high_salary_districts AS (\n    SELECT district_id\n    FROM district\n    WHERE A11 > 10000\n),\naccounts_in_high_salary_districts AS (\n    SELECT account_id\n    FROM account\n    WHERE district_id IN (SELECT district_id FROM high_salary_districts)\n),\nclients_in_high_salary_districts AS (\n    SELECT c.client_id, c.gender\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN accounts_in_high_salary_districts a ON d.account_id = a.account_id\n),\ntotal_clients AS (\n    SELECT COUNT(*) AS total\n    FROM clients_in_high_salary_districts\n),\nfemale_clients AS (\n    SELECT COUNT(*) AS female_count\n    FROM clients_in_high_salary_districts\n    WHERE gender = 'F'\n)\nSELECT (female_count * 100.0 / total) AS percentage_female\nFROM female_clients, total_clients;",
            "SELECT \n    CAST(SUM(CASE WHEN c.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(c.client_id) AS percentage_female\nFROM \n    client c\nINNER JOIN \n    district d ON c.district_id = d.district_id\nWHERE \n    d.A11 > 10000;"
        ],
        "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
        "amends": [
            "Do use a direct `INNER JOIN` between `district` and `client` on `district_id` instead of multiple CTEs with nested subqueries and joins through account and disposition tables. Do calculate the percentage directly with `CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id)` instead of separate CTEs for total and female counts with cross join. Do filter with `WHERE T1.A11 > 10000` directly in the main query instead of using a CTE for high salary districts. Do remove the unnecessary joins through `account` and `disp` tables instead of including them in the client filtering logic. The amended query now correctly calculates the percentage of female clients in high salary districts by directly joining the relevant tables and using proper aggregate functions."
        ],
        "rules": [
            "Female refers to gender = 'F'; Woman and female are closed; Average salary can be found in A11"
        ]
    },
    "946": {
        "sql": [
            "SELECT name, lat, lng FROM circuits WHERE country = 'USA';",
            "SELECT lat, lng FROM circuits WHERE country = 'USA';"
        ],
        "question": "Please list the location coordinates of the US circuits.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT lat, lng FROM circuits WHERE country = 'USA'",
        "amends": [
            "Do remove the `name` column from the SELECT list instead of including it, while keeping the `lat` and `lng` columns and maintaining the same WHERE filter condition `country = 'USA'`. The amended query now correctly returns only the latitude and longitude coordinates for USA circuits, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "location coordinates refers to (lat, lng); the US refers to country = 'USA';"
        ]
    },
    "98": {
        "sql": [
            "WITH approved_loans_1997 AS (\n    SELECT account_id, amount\n    FROM loan\n    WHERE strftime('%Y', date) = '1997' AND status = 'approved'\n),\nmin_loan_amount AS (\n    SELECT MIN(amount) AS min_amount\n    FROM approved_loans_1997\n)\nSELECT a.account_id, a.district_id, a.frequency, a.date\nFROM account a\nJOIN approved_loans_1997 al ON a.account_id = al.account_id\nJOIN min_loan_amount m ON al.amount = m.min_amount\nWHERE a.frequency = 'POPLATEK TYDNE';",
            "SELECT T2.account_id\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1997'\nAND T2.frequency = 'weekly issuance statement'\nORDER BY T1.amount\nLIMIT 1",
            "SELECT T2.account_id\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1997'\nAND T2.frequency = 'POPLATEK TYDNE'\nORDER BY T1.amount\nLIMIT 1;"
        ],
        "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
        "amends": [
            "Do use a simple `SELECT T2.account_id` instead of selecting multiple columns `a.account_id, a.district_id, a.frequency, a.date`. Do remove the CTE structure entirely instead of using `WITH approved_loans_1997` and `min_loan_amount` subqueries. Do use a direct `INNER JOIN` between `loan AS T1` and `account AS T2` instead of joining through intermediate CTEs. Do move the `STRFTIME('%Y', T1.date) = '1997'` filter to the main `WHERE` clause instead of placing it in a CTE. Do add `ORDER BY T1.amount LIMIT 1` to find the minimum amount instead of using a separate CTE to calculate the minimum and then joining on it. Do remove the explicit `status = 'approved'` filter since it's not present in the correct query. The amended query now correctly identifies the single account with the smallest loan amount in 1997 with the specified frequency, matching the RIGHT_SQL's behavior.",
            "Do filter by frequency `POPLATEK TYDNE` instead of `weekly issuance statement` in the WHERE clause, which corrects the account selection criteria to match the intended business logic for the 1997 loan data analysis."
        ],
        "rules": [
            "'POPLATEK TYDNE' stands for weekly issuance"
        ]
    },
    "936": {
        "sql": [
            "SELECT r.fastestLapTime\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nJOIN races ra ON r.raceId = ra.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND ra.year = 2008 AND ra.name = 'Australian Grand Prix';",
            "SELECT T1.fastestLap\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nINNER JOIN drivers T3 ON T1.driverId = T3.driverId\nWHERE T2.year = 2008 \nAND T2.name = 'Australian Grand Prix' \nAND T3.forename = 'Lewis' \nAND T3.surname = 'Hamilton';"
        ],
        "question": "Which was the fastest lap for Lewis Hamilton in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008 AND T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "amends": [
            "Do reference `fastestLap` instead of `fastestLapTime` in the SELECT list. Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `ra`, and `d` for clarity. Do specify `INNER JOIN` explicitly instead of just `JOIN` for both joins. Do correct the join condition from `r.driverId = d.driverId` to `T1.driverId = T3.driverId` to maintain proper table reference alignment. Do reorder the WHERE clause predicates to match the logical grouping of race conditions and driver conditions. The amended query now correctly retrieves the fastest lap data with proper table relationships and filtering conditions."
        ],
        "rules": []
    },
    "410": {
        "sql": [
            "SELECT c.id\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.artist = 'Erica Yang'\nAND c.availability = 'paper'\nAND l.format = 'pauper'\nAND l.status = 'legal';",
            "SELECT T1.id \nFROM cards T1\nJOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Erica Yang' \nAND T2.format = 'pauper'\nAND T1.availability LIKE '%paper%';",
            "SELECT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Erica Yang'\nAND T2.format = 'pauper'\nAND T1.availability = 'paper'"
        ],
        "question": "Is there any card from Erica Yang artist in pauper format and available in paper? If so, indicate its ID.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `c` and `l` for better clarity. Do reference `T1.availability` instead of `c.availability` to maintain consistent alias usage. Do remove the redundant condition `AND l.status = 'legal'` instead of keeping it, as the join on `T1.uuid = T2.uuid` with `T2.format = 'pauper'` already implies legal status in the context. The amended query now correctly filters for Erica Yang's paper cards that are legal in the pauper format without the unnecessary status check.",
            "Do use explicit `INNER JOIN` instead of implicit `JOIN` for clarity. Do change the `LIKE '%paper%'` pattern match to exact equality `= 'paper'` instead of partial matching to ensure precise availability filtering. Do remove the unnecessary `AS` keyword from table aliases `T1` and `T2` for consistency. The amended query now correctly filters for exact 'paper' availability instead of any value containing 'paper', ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "available in paper refers to availability = 'paper'"
        ]
    },
    "1031": {
        "sql": [
            "SELECT \n    p.player_name,\n    (strftime('%Y', 'now') - strftime('%Y', p.birthday)) - (strftime('%m-%d', 'now') < strftime('%m-%d', p.birthday)) AS current_age\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    pa.sprint_speed >= 97\n    AND strftime('%Y', pa.date) BETWEEN '2013' AND '2015'\nGROUP BY \n    p.player_api_id, p.player_name;",
            "SELECT DISTINCT (DATETIME() - T2.birthday) AS age\nFROM Player_Attributes T1\nINNER JOIN Player T2 ON T1.player_api_id = T2.player_api_id\nWHERE T1.sprint_speed >= 97\nAND STRFTIME('%Y', T1.date) >= '2013' \nAND STRFTIME('%Y', T1.date) <= '2015'"
        ],
        "question": "At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT DATETIME() - T2.birthday age FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.`date`) >= '2013' AND STRFTIME('%Y',t1.`date`) <= '2015' AND t1.sprint_speed >= 97",
        "amends": [
            "Do use `DATETIME() - T2.birthday` for age calculation instead of complex strftime arithmetic with birthday comparison. Do remove the `GROUP BY` clause instead of keeping unnecessary grouping when using `DISTINCT`. Do change from `JOIN` to explicit `INNER JOIN` instead of implicit join syntax. Do use `STRFTIME('%Y',t1.date) >= '2013' AND STRFTIME('%Y',t1.date) <= '2015'` for date range filtering instead of `BETWEEN '2013' AND '2015'`. Do add `DISTINCT` to eliminate duplicates instead of relying on GROUP BY for deduplication. Do simplify the SELECT list to only include the calculated age instead of selecting both player_name and age. The amended query now correctly calculates player ages and filters by sprint speed within the specified date range while eliminating duplicates."
        ],
        "rules": [
            "players age at present = SUBTRACT((DATETIME(), birthday)); sprint speed of no less than 97 refers to sprint_speed > = 97; between 2013 to 2015 refers to YEAR(date) > = '2013' AND YEAR(date) < = '2015'; "
        ]
    },
    "973": {
        "sql": [
            "SELECT d.driverId, d.forename, d.surname, d.dob, MAX(l.time) AS latest_lap_time\nFROM drivers d\nJOIN lapTimes l ON d.driverId = l.driverId\nWHERE d.nationality = 'Spanish' AND d.dob < '1982-01-01'\nGROUP BY d.driverId, d.forename, d.surname, d.dob\nORDER BY latest_lap_time DESC\nLIMIT 10;",
            "SELECT T1.driverId\nFROM pitStops T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982'\nORDER BY T1.time DESC\nLIMIT 10"
        ],
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "amends": [
            "Do select only `driverId` instead of including `forename`, `surname`, `dob`, and `latest_lap_time`. Do join `pitStops` instead of `lapTimes` and use `INNER JOIN` instead of `JOIN`. Do change the join condition to `T1.driverId = T2.driverId` instead of `d.driverId = l.driverId`. Do remove the `GROUP BY` clause and `MAX` aggregation instead of keeping them. Do change the date filter to use `STRFTIME('%Y', T2.dob) < '1982'` instead of `d.dob < '1982-01-01'`. Do order by `T1.time` instead of `latest_lap_time`. The amended query now correctly retrieves Spanish drivers born before 1982 from pit stop records rather than lap times, ordering by pit stop time instead of maximum lap time."
        ],
        "rules": [
            "born before 1982 refers to year(dob) < 1982; latest lap time refers to Max(time);"
        ]
    },
    "822": {
        "sql": [
            "SELECT COUNT(*) AS green_skinned_villains\nFROM superhero\nJOIN alignment ON superhero.alignment_id = alignment.id\nJOIN colour ON superhero.skin_colour_id = colour.id\nWHERE alignment.alignment = 'Bad' AND colour.colour = 'Green';"
        ],
        "question": "How many green-skinned villains are there in the superhero universe?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "amends": [],
        "rules": [
            "green-skinned refers to colour.colour = 'Green' WHERE skin_colour_id = colour.id; villains refers to alignment = 'Bad';"
        ]
    },
    "53": {
        "sql": [
            "SELECT SUM(s.NumTstTakr) AS TotalTestTakers\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE sc.MailCity = 'Fresno';",
            "SELECT T1.NumTstTakr FROM satscores T1 INNER JOIN schools T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'"
        ],
        "question": "How many test takers are there at the school/s whose mailing city address is in Fresno?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'",
        "amends": [
            "Do use `T1.NumTstTakr` as the column selection instead of `SUM(s.NumTstTakr) AS TotalTestTakers` to return individual values rather than an aggregate sum. Do use table aliases `T1` and `T2` instead of `s` and `sc` for consistency. Do use `INNER JOIN` explicitly instead of just `JOIN` to clarify the join type. Do reference `T1.cds = T2.CDSCode` in the join condition instead of `s.cds = sc.CDSCode` to match the alias naming. Do remove the `AS TotalTestTakers` alias since the column is returned without aggregation. The amended query now correctly returns individual test taker counts for Fresno schools instead of summing them."
        ],
        "rules": []
    },
    "571": {
        "sql": [
            "SELECT \n    (SELECT COUNT(*) FROM posts WHERE OwnerUserId = 24) AS post_count,\n    (SELECT COUNT(*) FROM votes WHERE UserId = 24) AS vote_count,\n    CASE \n        WHEN (SELECT COUNT(*) FROM votes WHERE UserId = 24) = 0 THEN NULL\n        ELSE CAST((SELECT COUNT(*) FROM posts WHERE OwnerUserId = 24) AS FLOAT) / (SELECT COUNT(*) FROM votes WHERE UserId = 24)\n    END AS post_to_vote_ratio;",
            "SELECT CAST(COUNT(DISTINCT posts.Id) AS REAL) / COUNT(DISTINCT votes.Id) AS post_to_vote_ratio\nFROM votes\nINNER JOIN posts ON votes.UserId = posts.OwnerUserId\nWHERE votes.UserId = 24",
            "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) AS post_to_vote_ratio\nFROM votes T1\nINNER JOIN posts T2 ON T1.UserId = T2.OwnerUserId\nWHERE T1.UserId = 24"
        ],
        "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
        "amends": [
            "Do use a single query with `INNER JOIN` between `votes` and `posts` on `T1.UserId = T2.OwnerUserId` instead of multiple separate subqueries. Do calculate the ratio as `CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id)` instead of separate counts for posts and votes with division. Do filter with `WHERE T1.UserId = 24` applied to the joined dataset instead of filtering each subquery independently. Do remove the `CASE` statement handling division by zero since the join ensures meaningful aggregation. Do use `COUNT(DISTINCT T1.Id)` for vote counting instead of simple `COUNT(*)` to avoid duplication from the join. The amended query now correctly calculates the post-to-vote ratio by joining the relevant tables and handles the aggregation properly to match the RIGHT_SQL's behavior.",
            "Do use `COUNT(T2.Id)` for posts count instead of `COUNT(DISTINCT posts.Id)` to avoid unnecessary distinct counting on unique post IDs. Do use `COUNT(DISTINCT T1.Id)` for votes count instead of `COUNT(DISTINCT votes.Id)` to properly count distinct vote IDs. Do use table aliases `T1` for votes and `T2` for posts instead of full table names for consistency and clarity. Do maintain the same `INNER JOIN` on `T1.UserId = T2.OwnerUserId` instead of changing the join condition. Do keep the same `WHERE T1.UserId = 24` filter instead of modifying the user filter. The amended query now correctly calculates the ratio by counting all posts (since post IDs are unique) while counting distinct votes (since multiple votes could exist), matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "user no. 24 refers to UserId = OwnerUserId = '24'; times of his/her post than votes = Divide (Count(post.Id), Count(votes.Id))"
        ]
    },
    "1129": {
        "sql": [
            "SELECT t.team_long_name \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE ta.buildUpPlaySpeedClass = 'Slow';"
        ],
        "question": "List down the long name for slow speed class team.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Slow'",
        "amends": [],
        "rules": [
            "slow speed class refers to buildUpPlaySpeedClass = 'Slow'; long name refers to team_long_name"
        ]
    },
    "349": {
        "sql": [
            "SELECT c.name, c.artist, c.isPromo\nFROM cards c\nJOIN (\n    SELECT uuid, COUNT(*) AS ruling_count\n    FROM rulings\n    GROUP BY uuid\n    ORDER BY ruling_count DESC\n    LIMIT 1\n) r ON c.uuid = r.uuid;",
            "SELECT T1.name, T1.artist, T1.isPromo \nFROM cards T1 \nINNER JOIN rulings T2 ON T1.uuid = T2.uuid \nWHERE T1.isPromo = 1 \nAND T1.artist = (\n    SELECT artist \n    FROM cards \n    WHERE isPromo = 1 \n    GROUP BY artist \n    ORDER BY COUNT(DISTINCT uuid) DESC \n    LIMIT 1\n) \nLIMIT 1;"
        ],
        "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 AND T1.artist = (SELECT artist FROM cards WHERE isPromo = 1 GROUP BY artist HAVING COUNT(DISTINCT uuid) = (SELECT MAX(count_uuid) FROM ( SELECT COUNT(DISTINCT uuid) AS count_uuid FROM cards WHERE isPromo = 1 GROUP BY artist ))) LIMIT 1",
        "amends": [
            "Do `INNER JOIN rulings` directly on `T1.uuid = T2.uuid` instead of joining a subquery that selects only the top ruling count. Do add `WHERE T1.isPromo = 1` filter instead of omitting it. Do add `AND T1.artist =` subquery condition instead of not filtering by artist. Do use a complex subquery to find the artist with maximum distinct promo cards instead of not considering artist distribution. Do remove the `GROUP BY uuid` and `ORDER BY ruling_count DESC` logic instead of keeping ruling count analysis. Do add `LIMIT 1` instead of omitting it, but with completely different selection criteria focused on promo cards from the top artist rather than cards with the most rulings."
        ],
        "rules": [
            "with the most ruling information refers to Max(count(rulings.uuid)); the card is the promotional printing refers to isPromo = 1;"
        ]
    },
    "348": {
        "sql": [
            "SELECT r.date, r.text\nFROM rulings r\nJOIN cards c ON r.uuid = c.uuid\nWHERE c.name = 'Sublime Epiphany' AND c.number = '74s';",
            "SELECT T2.text \nFROM cards T1 \nINNER JOIN rulings T2 ON T1.uuid = T2.uuid \nWHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'"
        ],
        "question": "Describe the information about rulings for card named 'Sublime Epiphany' with number 74s.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'",
        "amends": [
            "Do select only `text` instead of both `date` and `text`. Do use `INNER JOIN` instead of `JOIN` (which are equivalent, but explicit). Do reference `T1.name` and `T1.number` instead of `c.name` and `c.number` with different aliases. Do use table aliases `T1` for cards and `T2` for rulings instead of `c` and `r`. The amended query now correctly retrieves only the ruling text for the specified card while maintaining the same join logic and filtering conditions."
        ],
        "rules": [
            "Sublime Epiphany' is name of cards; number 74s refers to number = '74s'; information refers to text;"
        ]
    },
    "1265": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE (L.RNP = '-' OR L.RNP = '+-') AND P.Admission = '+';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission IS NOT NULL \nAND (T2.RNP = 'negative' OR T2.RNP = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '+' AND (T2.RNP = 'negative' OR T2.RNP = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.RNP = 'negative' OR T2.RNP = '0'\nAND T1.Admission = '+'"
        ],
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `P` and `L`. Do change the join to explicit `INNER JOIN` instead of implicit `JOIN`. Do change the RNP filter conditions to `T2.RNP = 'negative'` and `T2.RNP = '0'` instead of `L.RNP = '-'` and `L.RNP = '+-'`. Do remove the parentheses around the OR condition in the WHERE clause instead of keeping them. The amended query now correctly filters for negative and zero RNP values while maintaining the same join logic and admission filter.",
            "Do remove the `Admission IS NOT NULL` filter and instead use `Admission = '+'` instead of checking for non-null values. Do change the logical structure by moving the `RNP` filter conditions to be evaluated with proper operator precedence instead of using parentheses that grouped the OR conditions separately. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` between the same tables. The amended query now correctly filters for patients with positive admission status and specific RNP values, matching the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `T2.RNP` filter conditions instead of keeping them, and do change the logical operator precedence by placing the `T1.Admission` filter at the end instead of at the beginning with parentheses. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and all filter conditions including `T1.Admission = '+'` and `T2.RNP` checks for 'negative' and '0' values. The amended query now correctly handles the logical operator precedence without parentheses and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;"
        ]
    },
    "474": {
        "sql": [
            "SELECT COUNT(DISTINCT s.code)\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Italian' AND s.baseSetSize < 100;"
        ],
        "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 100?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 100 AND T2.language = 'Italian'",
        "amends": [],
        "rules": [
            "Italian translation refers to language = 'Italian'; have a translation means translation is not null; base set number of under 100 refers to baseSetSize < 10"
        ]
    },
    "751": {
        "sql": [
            "SELECT DISTINCT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nJOIN gender g ON sh.gender_id = g.id\nWHERE g.gender = 'Male'\nLIMIT 5;"
        ],
        "question": "List down at least five superpowers of male superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
        "amends": [],
        "rules": [
            "male refers to gender = 'Male'; superpowers refers to power_name;"
        ]
    },
    "965": {
        "sql": [
            "SELECT raceId FROM races WHERE year = 2009;"
        ],
        "question": "List out the Id number of races which were hold in 2009.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT raceId FROM races WHERE year = 2009",
        "amends": [],
        "rules": []
    },
    "1046": {
        "sql": [
            "SELECT ta.buildUpPlayPositioningClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'ADO Den Haag';"
        ],
        "question": "What is the ADO Den Haag team freedom of movement in the 1st two thirds of the pitch?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPositioningClass FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_fifa_api_id = t2.team_fifa_api_id WHERE t1.team_long_name = 'ADO Den Haag'",
        "amends": [],
        "rules": [
            "ADO Den Haag refers to team_long_name = 'ADO Den Haag'; freedom of movement in the 1st two thirds of the pitch refers to buildUpPlayPositioningClass;"
        ]
    },
    "1530": {
        "sql": [
            "SELECT p.Description, SUM(t.Amount) AS TotalAmount\nFROM transactions_1k t\nJOIN products p ON t.ProductID = p.ProductID\nGROUP BY t.ProductID, p.Description\nORDER BY TotalAmount DESC\nLIMIT 5;",
            "SELECT T2.Description \nFROM transactions_1k AS T1 \nINNER JOIN products AS T2 ON T1.ProductID = T2.ProductID \nORDER BY T1.Amount DESC \nLIMIT 5"
        ],
        "question": "Which are the top five best selling products? Please state the full name of them.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.Amount DESC LIMIT 5",
        "amends": [
            "Do select only `T2.Description` instead of selecting both `p.Description` and `SUM(t.Amount)`. Do remove the `GROUP BY` clause and aggregation instead of grouping by `t.ProductID, p.Description`. Do use `INNER JOIN` with explicit `AS` aliases `T1` and `T2` instead of simple `JOIN` with aliases `t` and `p`. Do order by `T1.Amount DESC` instead of ordering by the aggregated `TotalAmount DESC`. The amended query now correctly returns individual product descriptions ordered by transaction amount rather than aggregated totals."
        ],
        "rules": [
            "Description of products contains full name"
        ]
    },
    "1035": {
        "sql": [
            "SELECT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60;"
        ],
        "question": "Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60",
        "amends": [],
        "rules": [
            "teams with more than 50 but less than 60 build-up play speed refers to buildUpPlaySpeed >50 AND buildUpPlaySpeed <60; "
        ]
    },
    "450": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'Aaron Miller' \nAND cardKingdomFoilId IS NOT NULL \nAND cardKingdomId IS NOT NULL;"
        ],
        "question": "Of all the cards that are designed by Aaron Miller, how many of them are incredibly powerful?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) FROM cards",
        "amends": [],
        "rules": [
            "designed by Aaron Miller refers to artist = 'Aaron Miller'; are icredibily powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null"
        ]
    },
    "1295": {
        "sql": [
            "SELECT COUNT(DISTINCT p.ID) AS PatientCount\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.`T-BIL` >= 2.0 AND e.`ANA Pattern` LIKE '%P%';",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" >= 2\nAND T3.\"ANA Pattern\" = 'peripheral'",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" >= 2\nAND T3.\"ANA Pattern\" LIKE '%P%'"
        ],
        "question": "Among the patients whose total bilirubin is over the normal range, how many of them have a peripheral pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` >= 2 AND T3.`ANA Pattern` LIKE '%P%'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT p.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `l`, and `e` for consistent naming. Do remove the `AS PatientCount` alias instead of keeping it since the column name is not needed. Do use integer comparison `T2.\"T-BIL\" >= 2` instead of `l.\"T-BIL\" >= 2.0` to match the data type. The amended query now correctly counts all patient records meeting the laboratory and examination criteria without unnecessary distinct counting.",
            "Do use `LIKE '%P%'` for pattern matching on `ANA Pattern` instead of exact equality `= 'peripheral'` to capture all patterns containing 'P' rather than only the specific 'peripheral' value. The amended query now correctly matches the RIGHT_SQL's behavior with the appropriate pattern matching logic."
        ],
        "rules": [
            "total bilirubin is over the normal range refers to `T-BIL` > = 2.0; peripheral pattern is observed in the sheet of ANA examination refers to that ANA Pattern contains 'P';"
        ]
    },
    "1260": {
        "sql": [
            "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE CAST(L.RF AS REAL) < 20\nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 60;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE CAST(T2.RF AS REAL) < 20\nAND (strftime('%Y', DATE('now')) - strftime('%Y', T1.Birthday)) - (strftime('%m-%d', DATE('now')) < strftime('%m-%d', T1.Birthday)) > 60;",
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.RF < 20\nAND (STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday)) > 60"
        ],
        "question": "Please list the ID of the patient whose RF is normal and who is older than 60.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60",
        "amends": [
            "Do use `T1.ID` instead of `P.ID` for consistent table alias naming. Do remove `DISTINCT` instead of keeping it since duplicates are handled by the join logic. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T2.RF` directly instead of casting with `CAST(L.RF AS REAL)` since the comparison works with the native type. Do use `DATE('now')` instead of just `'now'` in the strftime function for proper date handling. Do maintain the same join condition `T1.ID = T2.ID` instead of changing it. Do keep the same filter logic for RF values less than 20 and age calculation greater than 60, just with corrected table aliases and date function usage. The amended query now correctly calculates patient age using proper date functions and maintains the intended filtering logic without unnecessary casting or distinct operations.",
            "Do use `T2.RF < 20` instead of `CAST(T2.RF AS REAL) < 20` to avoid unnecessary type casting. Do simplify the age calculation to `STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60` instead of the complex expression with month-day comparison that incorrectly handled leap years and month boundaries. Do remove the redundant parentheses and month-day logic that could produce inaccurate age calculations for patients near their birthday. The amended query now correctly filters patients over 60 years old based on year difference only, matching the intended behavior."
        ],
        "rules": [
            "RF is normal refers to RF < 20; older than 60 = SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) > 60;"
        ]
    },
    "872": {
        "sql": [
            "SELECT d.code \nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 45 AND q.q3 = '0:01:33';",
            "SELECT T2.code \nFROM qualifying AS T1 \nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 45 \nAND T1.q3 LIKE '1:33%'"
        ],
        "question": "In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'",
        "amends": [
            "Do use `T2.code` instead of `d.code` for the column alias. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reverse the join condition to `T2.driverId = T1.driverId` instead of `q.driverId = d.driverId`. Do use `LIKE '1:33%'` for pattern matching instead of exact equality `= '0:01:33'` to catch variations in time formatting. Do add table aliases `AS T1` and `AS T2` instead of omitting them. The amended query now correctly identifies qualifying times that start with '1:33' regardless of minor formatting differences, matching the intended behavior."
        ],
        "rules": [
            "race number refers to raceId; had the Q3 time as 0:0M:SS refers to q3 LIKE 'M:SS%'"
        ]
    },
    "1118": {
        "sql": [
            "SELECT player_name FROM Player WHERE (strftime('%Y', 'now') - strftime('%Y', birthday)) - (strftime('%m-%d', 'now') < strftime('%m-%d', birthday)) > 34;",
            "SELECT player_name \nFROM Player \nWHERE (JULIANDAY('now') - JULIANDAY(birthday)) / 365.0 >= 35;"
        ],
        "question": "List down the name of players who are 35 years old and above.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE CAST((JULIANDAY('now') - JULIANDAY(birthday)) AS REAL) / 365 >= 35",
        "amends": [
            "Do calculate age using `JULIANDAY` date arithmetic with division by `365` instead of using `strftime` year subtraction with day-of-year comparison. Do use `>= 35` as the age threshold instead of `> 34` to properly include players who are exactly 35 years old. Do cast the Julian day difference to `REAL` for precise decimal age calculation instead of integer year subtraction that can be off by nearly a full year. The amended query now correctly calculates exact age in years as a decimal value and uses the proper inclusive threshold to match the intended behavior of selecting players aged 35 or older."
        ],
        "rules": [
            "35 years old and above refers to datetime(CURRENT_TIMESTAMP,'localtime') - datetime(birthday) > 34"
        ]
    },
    "1489": {
        "sql": [
            "SELECT SUM(y.Consumption) AS TotalConsumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'KAM' AND y.Date = '201305';"
        ],
        "question": "How much did the KAM customers consume in total in May 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201305' AND T1.Segment = 'KAM'",
        "amends": [],
        "rules": [
            "May 2013 refers to yearmonth.date = 201305"
        ]
    },
    "45": {
        "sql": [
            "SELECT s.School, sc.AvgScrWrite\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE (s.AdmFName1 = 'Ricci' AND s.AdmLName1 = 'Ulrich') \n   OR (s.AdmFName2 = 'Ricci' AND s.AdmLName2 = 'Ulrich') \n   OR (s.AdmFName3 = 'Ricci' AND s.AdmLName3 = 'Ulrich')\nGROUP BY s.School;"
        ],
        "question": "What is the average writing score of each of the schools managed by Ricci Ulrich? List the schools and the corresponding average writing scores.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School, T1.AvgScrWrite FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'",
        "amends": [],
        "rules": [
            "Usually, administrators manage the school stuff."
        ]
    },
    "792": {
        "sql": [
            "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Abomination';"
        ],
        "question": "What is Abomination's superpower?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Abomination'",
        "amends": [],
        "rules": [
            "Abomination refers to superhero_name = 'Abomination'; superpower refers to power_name;"
        ]
    },
    "145": {
        "sql": [
            "WITH credit_card_transactions AS (\n    SELECT account_id, amount\n    FROM trans\n    WHERE operation = 'VYBER KARTOU'\n    AND strftime('%Y', date) = '1998'\n),\naverage_amount AS (\n    SELECT AVG(amount) AS avg_amount\n    FROM credit_card_transactions\n)\nSELECT DISTINCT c.client_id\nFROM credit_card_transactions cct\nJOIN disp d ON cct.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE cct.amount < (SELECT avg_amount FROM average_amount);",
            "SELECT account_id\nFROM trans\nWHERE date BETWEEN '1998-01-01' AND '1998-12-31'\n  AND operation = 'credit card'\n  AND amount < (SELECT AVG(amount) FROM trans WHERE date BETWEEN '1998-01-01' AND '1998-12-31' AND operation = 'credit card')",
            "SELECT T1.account_id\nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1998'\nAND T1.operation = 'VYBER KARTOU'\nAND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')"
        ],
        "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
        "amends": [
            "Do use a simple `SELECT` query instead of a CTE structure. Do select only `account_id` instead of `client_id` through multiple joins. Do join with `account` table on `account_id` instead of joining with `disp` and `client` tables. Do move the `operation` and date filter conditions to the main `WHERE` clause instead of placing them in a CTE. Do calculate the average amount directly in a subquery with the same date filter instead of using a separate CTE. Do remove the `DISTINCT` modifier instead of keeping it. Do reference the same table alias `T1` consistently instead of using different aliases like `cct`. The amended query now correctly filters transactions from 1998 with the specified operation and compares amounts against the average for that year directly.",
            "Do add `INNER JOIN account AS T2 ON T1.account_id = T2.account_id` instead of querying only the `trans` table. Do change the date filter to `STRFTIME('%Y', T1.date) = '1998'` instead of `BETWEEN '1998-01-01' AND '1998-12-31'`. Do change the operation filter to `T1.operation = 'VYBER KARTOU'` instead of `operation = 'credit card'`. Do remove the operation filter from the subquery's `WHERE` clause instead of keeping it, changing `(SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')` instead of `(SELECT AVG(amount) FROM trans WHERE date BETWEEN '1998-01-01' AND '1998-12-31' AND operation = 'credit card')`. Do add table alias `T1` to all column references instead of using unqualified column names. The amended query now correctly joins with the account table, uses proper year extraction, filters for the correct operation type, and calculates the average amount across all 1998 transactions instead of only credit card operations, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Operation = 'VYBER KARTOU' refers to credit card withdrawal"
        ]
    },
    "1287": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS NumberOfPatients\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Admission = '-' AND L.ALP < 300;",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP < 300\nAND T1.Admission = '-'"
        ],
        "question": "Among the patients followed at the outpatient clinic, how many of them have a normal level of alkaliphophatase?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300 AND T1.Admission = '-'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID) AS NumberOfPatients` to count all matching records without deduplication and remove the unnecessary alias. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference tables with aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T2.ALP < 300` condition before `T1.Admission = '-'` in the WHERE clause instead of the reverse order, though this is functionally equivalent. Do remove the explicit column alias `NumberOfPatients` instead of keeping it since the result set doesn't require named output. The amended query now correctly counts all patient records meeting the criteria without unnecessary DISTINCT operations."
        ],
        "rules": [
            "followed at the outpatient clinic refers to Admission = '-'; normal level of alkaliphophatase refers to ALP < 300;"
        ]
    },
    "498": {
        "sql": [
            "SELECT st.translation AS french_set_name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode\nWHERE c.name = 'Tendo Ice Bridge' AND st.language = 'French';"
        ],
        "question": "What's the French name of the set of cards with \"Tendo Ice Bridge\" is in?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Tendo Ice Bridge' AND T2.language = 'French' AND T2.translation IS NOT NULL",
        "amends": [],
        "rules": [
            "French refers to language = 'French'; \"Tendo Ice Bridge\" is a translated name of a card; translated name refers to translation"
        ]
    },
    "1528": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN Segment = 'premium' THEN 1 END) * 100.0 / COUNT(*)) AS premium_percentage\nFROM \n    gasstations\nWHERE \n    Country = 'SVK';",
            "SELECT \n    CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100.0 / \n    CAST(SUM(IIF(Country = 'SVK', 1, 0)) AS FLOAT) AS Percentage\nFROM gasstations"
        ],
        "question": "What is the percentage of \"premium\" against the overall segment in Country = \"SVK\"?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations",
        "amends": [
            "Do use `SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0))` instead of `COUNT(CASE WHEN Segment = 'premium' THEN 1 END)` to properly count only Slovakian premium stations. Do add `Country = 'SVK'` condition to the premium segment counting instead of filtering it in WHERE clause. Do use `SUM(IIF(Country = 'SVK', 1, 0))` as denominator instead of `COUNT(*)` to count only Slovakian stations. Do add explicit `CAST` to `FLOAT` instead of implicit conversion. Do remove the `WHERE` clause filter instead of keeping it since country filtering is now handled within the conditional sums. Do change case sensitivity from `'premium'` to `'Premium'` to match the correct segment value. The amended query now correctly calculates the percentage of premium stations specifically within Slovakia rather than filtering first and then calculating percentages."
        ],
        "rules": []
    },
    "590": {
        "sql": [
            "SELECT Id FROM users WHERE Views = (SELECT MIN(Views) FROM users);"
        ],
        "question": "Which user ID has the lowest view?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id FROM users WHERE Views = ( SELECT MIN(Views) FROM users )",
        "amends": [],
        "rules": [
            "lowest views refers to Min(Views)"
        ]
    },
    "918": {
        "sql": [
            "SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton';"
        ],
        "question": "What's Lewis Hamilton's reference name?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'",
        "amends": [],
        "rules": [
            "reference name refers to driverRef"
        ]
    },
    "1442": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN b.spent > b.amount THEN 1 END) * 100.0 / COUNT(*)) AS percentage_over_budget\nFROM \n    event e\nJOIN \n    budget b ON e.event_id = b.link_to_event;"
        ],
        "question": "What is the percentage of the events that went over budget?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(budget_id) FROM budget",
        "amends": [],
        "rules": [
            "went over budget refers to remaining < 0; percentage = DIVIDE(SUM(remaining < 0), COUNT(event_id)) * 100"
        ]
    },
    "165": {
        "sql": [
            "SELECT t.* FROM trans t JOIN account a ON t.account_id = a.account_id WHERE a.district_id = 5;",
            "SELECT t.trans_id\nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nINNER JOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T1.district_id = 5",
            "SELECT T3.trans_id\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T1.district_id = 5"
        ],
        "question": "Please list all the transactions made by accounts from district 5.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.trans_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T1.district_id = 5",
        "amends": [
            "Do select only `trans_id` instead of all columns `t.*`. Do join `district` table as `T1` instead of omitting it. Do use `INNER JOIN` between `district` and `account` on `T1.district_id = T2.district_id` instead of missing this relationship. Do maintain `INNER JOIN` between `account` and `trans` on `T2.account_id = T3.account_id` instead of the similar `t.account_id = a.account_id`. Do filter on `T1.district_id = 5` instead of `a.district_id = 5` to correctly reference the district table. The amended query now correctly joins through the district table to filter transactions by district_id.",
            "Do reference `T3.trans_id` in the SELECT list instead of `t.trans_id` to correctly specify the table alias. Do use explicit table aliases `AS T1`, `AS T2`, and `AS T3` in the FROM clause instead of omitting the AS keyword for better readability. The amended query now correctly references the trans_id column from the trans table with proper alias usage while maintaining the same join logic and filter condition."
        ],
        "rules": []
    },
    "65": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN FundingType = 'Local' THEN 1 END) * 100.0 / COUNT(*)) AS ratio_percentage\nFROM \n    schools\nWHERE \n    County = 'Santa Clara';",
            "SELECT \n    CAST(SUM(CASE WHEN s.FundingType = 'Locally funded' THEN 1 ELSE 0 END) * 100.0 / \n         SUM(CASE WHEN s.FundingType != 'Locally funded' THEN 1 ELSE 0 END) AS REAL) AS ratio_percentage\nFROM schools s\nWHERE s.County = 'Santa Clara' AND s.Charter = 1;"
        ],
        "question": "What is the ratio in percentage of Santa Clara County schools that are locally funded compared to all other types of charter school funding?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END) FROM schools WHERE County = 'Santa Clara' AND Charter = 1",
        "amends": [
            "Do use `SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN FundingType = 'Local' THEN 1 END)` to properly count matching rows with explicit ELSE 0. Do add `AND Charter = 1` to the WHERE clause instead of omitting this filter condition. Do calculate the ratio as `* 100 / SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END)` instead of `* 100.0 / COUNT(*)` to use the count of non-matching rows as the denominator rather than total rows. Do add explicit `CAST(... AS REAL)` instead of relying on decimal notation for proper floating-point division. The amended query now correctly calculates the percentage of locally funded charter schools in Santa Clara County."
        ],
        "rules": [
            "Ratio in percentage = (count(locally funded schools in Santa Clara) / count(all funding type schools in Santa Clara) * 100%"
        ]
    },
    "599": {
        "sql": [
            "-- Query to find post history type IDs for post ID 3720\nSELECT DISTINCT PostHistoryTypeId\nFROM postHistory\nWHERE PostId = 3720;\n\n-- Query to count unique users who commented on post ID 3720\nSELECT COUNT(DISTINCT UserId) AS UniqueCommentingUsers\nFROM comments\nWHERE PostId = 3720;",
            "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory T1 WHERE T1.PostId = 3720"
        ],
        "question": "What are the post history type IDs for post ID 3720 and how many unique users have commented on the post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory AS T1 WHERE T1.PostId = 3720",
        "amends": [
            "Do combine both queries into a single SELECT statement instead of executing them separately. Do include `T1.PostHistoryTypeId` in the main SELECT list instead of selecting only `PostHistoryTypeId` without table alias. Do add a correlated subquery `(SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers` instead of omitting this calculation from the main result. Do use table alias `T1` for `postHistory` instead of referencing it without alias. Do keep the filter `WHERE T1.PostId = 3720` instead of changing its logic. Do remove the DISTINCT keyword from the main query instead of keeping it, as the subquery handles distinct counting separately. The amended query now correctly returns both the post history type IDs and the count of unique commenting users in a single result set matching RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "781": {
        "sql": [
            "SELECT superhero.height_cm FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'Amber';"
        ],
        "question": "Provide the heights of the heroes whose eye colours are amber.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'",
        "amends": [],
        "rules": [
            "heights of the heroes refers to height_cm; eye colours are amber refers to colour.colour = 'Amber' WHERE eye_colour_id = colour.id;"
        ]
    },
    "482": {
        "sql": [
            "SELECT fd.type \nFROM foreign_data fd \nJOIN cards c ON fd.uuid = c.uuid \nWHERE c.name = 'Ancestor''s Chosen' AND fd.language = 'German';",
            "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German';"
        ],
        "question": "What's the German type of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German'",
        "amends": [
            "Do use `DISTINCT T1.type` instead of `fd.type` to eliminate duplicate results. Do reference `cards AS T1` instead of `cards c` and `foreign_data AS T2` instead of `foreign_data fd` with proper table aliasing. Do use `INNER JOIN` with `T2.uuid = T1.uuid` instead of `JOIN` with `fd.uuid = c.uuid` for explicit join specification and corrected join condition direction. Do filter on `T1.name = 'Ancestor''s Chosen'` instead of `c.name = 'Ancestor''s Chosen'` and `T2.language = 'German'` instead of `fd.language = 'German'` to maintain consistent table alias usage throughout the query. The amended query now correctly returns distinct card types without duplicates while maintaining the same logical behavior."
        ],
        "rules": [
            "German refers to language = 'German'; \"Ancestor's Chosen\" refers to name = 'Ancestor''s Chosen'"
        ]
    },
    "703": {
        "sql": [
            "SELECT COUNT(*) FROM tags WHERE Id < 15 AND Count <= 20;"
        ],
        "question": "Among the tags with tag ID below 15, how many of them have 20 count of posts and below?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM tags WHERE Count <= 20 AND Id < 15",
        "amends": [],
        "rules": [
            "ID below 15 refers to Id < 15; have 20 count of posts and below refers to Count < = 20;"
        ]
    },
    "1128": {
        "sql": [
            "SELECT c.name AS country_name, AVG(p.weight) AS average_weight\nFROM Player p\nJOIN Match m ON p.player_api_id IN (\n    m.home_player_1, m.home_player_2, m.home_player_3, m.home_player_4, m.home_player_5,\n    m.home_player_6, m.home_player_7, m.home_player_8, m.home_player_9, m.home_player_10, m.home_player_11,\n    m.away_player_1, m.away_player_2, m.away_player_3, m.away_player_4, m.away_player_5,\n    m.away_player_6, m.away_player_7, m.away_player_8, m.away_player_9, m.away_player_10, m.away_player_11\n)\nJOIN Country c ON m.country_id = c.id\nGROUP BY c.name\nORDER BY average_weight DESC\nLIMIT 1;",
            "SELECT t1.name\nFROM Country AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.country_id\nINNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id\nGROUP BY t1.name\nORDER BY AVG(t3.weight) DESC\nLIMIT 1;"
        ],
        "question": "Which country's players have the heaviest average weights?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id GROUP BY t1.name ORDER BY AVG(t3.weight) DESC LIMIT 1",
        "amends": [
            "Do select only `t1.name` instead of `c.name AS country_name, AVG(p.weight) AS average_weight`. Do use `INNER JOIN Match AS t2 ON t1.id = t2.country_id` instead of joining through player position arrays. Do use `INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id` instead of checking all 22 player positions. Do group by `t1.name` instead of keeping the same grouping. Do order by `AVG(t3.weight) DESC` instead of ordering by the alias `average_weight DESC`. Do remove the explicit average column from SELECT instead of including it. The amended query now correctly focuses only on home_player_1 relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "heaviest average weights refers to MAX(AVG(weight))"
        ]
    },
    "471": {
        "sql": [
            "SELECT s.type \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Hauptset Zehnte Edition';"
        ],
        "question": "What is the expansion type of the set \"Hauptset Zehnte Edition\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "amends": [],
        "rules": [
            "card set \"Hauptset Zehnte Edition\" refers to translation = ' Hauptset Zehnte Edition'; expansion type refers to type"
        ]
    },
    "437": {
        "sql": [
            "SELECT name FROM cards WHERE borderColor = 'black' AND isFullArt = 1;",
            "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1;"
        ],
        "question": "Among black card borders, which card has full artwork?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1",
        "amends": [
            "Do select `id` instead of `name` in the SELECT list while keeping the same `WHERE` filters on `borderColor = 'black'` and `isFullArt = 1`. The amended query now correctly returns the id column instead of name while maintaining the same filtering logic."
        ],
        "rules": [
            "white card borders refers to borderColor = 'white'; has full artwork refers to isFullArt = 1"
        ]
    },
    "175": {
        "sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS account_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nWHERE d.type = 'OWNER' AND a.frequency = 'POPLATEK PO OBRATU';"
        ],
        "question": "How many accounts have an owner disposition and request for a statement to be generated upon a transaction?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK PO OBRATU'",
        "amends": [],
        "rules": [
            "Frequency = 'POPLATEK PO OBRATU' stands for issuance after transaction"
        ]
    },
    "127": {
        "sql": [
            "SELECT account_id FROM account WHERE frequency = 'POPLATEK MESICNE';"
        ],
        "question": "List the account IDs with monthly issuance of statements.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT account_id FROM account WHERE Frequency = 'POPLATEK MESICNE'",
        "amends": [],
        "rules": [
            "'POPLATEK MESICNE' stands for monthly issuance"
        ]
    },
    "1023": {
        "sql": [
            "SELECT COUNT(*) AS number_of_players\nFROM Player_Attributes\nWHERE overall_rating BETWEEN 60 AND 65\nAND defensive_work_rate = 'low';"
        ],
        "question": "Among the players with an overall rating between 60 to 65, how many players whose going to be in all of your attack moves instead of defensing?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player_Attributes WHERE overall_rating BETWEEN 60 AND 65 AND defensive_work_rate = 'low'",
        "amends": [],
        "rules": [
            "overall_rating > = 60 AND overall_rating < 65; players whose going to be in all of your attack moves instead of defensing refers to defensive_work_rate = 'low';"
        ]
    },
    "684": {
        "sql": [
            "SELECT (COUNT(CASE WHEN Age BETWEEN 13 AND 18 THEN 1 END) * 100.0 / COUNT(Id)) AS percentage FROM users;"
        ],
        "question": "Identify the percentage of teenage users.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(Id) FROM users",
        "amends": [],
        "rules": [
            "DIVIDE(COUNT(Id where Age BETWEEN 13 and 18), COUNT(Id)) as percentage;"
        ]
    },
    "232": {
        "sql": [
            "SELECT DISTINCT m.molecule_id\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE m.label = '-' AND b.bond_type = '-'\nORDER BY m.molecule_id\nLIMIT 3;"
        ],
        "question": "Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id LIMIT 3",
        "amends": [],
        "rules": [
            "label = '-' means molecules are not carcinogenic; single type bond refers to bond_type = '-'; list top three molecules refers to return molecule_id and order by molecule_id;"
        ]
    },
    "711": {
        "sql": [
            "SELECT COUNT(DISTINCT u.Id) AS TotalUsers\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE c.Score = 0 AND u.Age = 40;",
            "SELECT COUNT(DISTINCT T1.Id) \nFROM comments T1 \nINNER JOIN users T2 ON T1.UserId = T2.Id \nWHERE T1.Score = 0 AND T2.Age = 40"
        ],
        "question": "Among products comments with 0 score, what is the total number of users ages 40 years old?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40",
        "amends": [
            "Do use `T1.id` in the COUNT instead of `u.Id` to reference the correct table alias. Do use table aliases `T1` for comments and `T2` for users instead of `c` and `u`. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T1.UserId` in the join condition instead of `c.UserId` to match the table alias. Do reference `T2.Age` in the WHERE clause instead of `u.Age` to match the table alias. Do remove the column alias `AS TotalUsers` instead of keeping it since the right query doesn't include it. The amended query now correctly counts distinct comment IDs from the comments table joined with users, filtering for zero score comments from 40-year-old users."
        ],
        "rules": []
    },
    "1304": {
        "sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.GLU < 180 AND e.Thrombosis = 0;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.GLU IS NOT NULL \nAND T3.Thrombosis = 0",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.GLU < 180 \nAND T3.Thrombosis = 0;"
        ],
        "question": "Among the patients with a normal blood glucose, how many of them don't have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.GLU < 180 AND T3.Thrombosis = 0",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT p.ID)` to count all matching rows rather than distinct patient IDs. Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `l`, and `e` for consistent naming. Do specify `INNER JOIN` explicitly instead of implicit `JOIN` for clarity. Do reference `T2.GLU` and `T3.Thrombosis` instead of `l.GLU` and `e.Thrombosis` to match the alias changes. The amended query now correctly counts all patient records meeting the laboratory and examination criteria without unnecessary DISTINCT filtering.",
            "Do change the WHERE filter to `T2.GLU < 180` instead of `T2.GLU IS NOT NULL` to properly filter for glucose values below the threshold rather than just checking for non-null values. The amended query now correctly counts patients with glucose levels under 180 who do not have thrombosis, matching the intended behavior."
        ],
        "rules": [
            "normal blood glucose refers to GLU < 180; don't have thrombosis refers to Thrombosis = 0;"
        ]
    },
    "69": {
        "sql": [
            "SELECT NCESDist FROM schools WHERE SOC IS NOT NULL AND SOCType = 'State Special Schools';"
        ],
        "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT NCESDist FROM schools WHERE SOC = 31",
        "amends": [],
        "rules": [
            "State Special Schools means that SOC = 31."
        ]
    },
    "560": {
        "sql": [
            "SELECT COUNT(*) FROM badges WHERE Name = 'Revival';"
        ],
        "question": "Give the number of \"Revival\" badges.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE Name = 'Revival'",
        "amends": [],
        "rules": [
            "number refers to Id; 'Revival' is the Name of badge"
        ]
    },
    "287": {
        "sql": [
            "SELECT (SUM(CASE WHEN bond_type = ' = ' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percent_double_bonds\nFROM bond\nWHERE molecule_id = 'TR047';",
            "SELECT \n    (COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) * 100.0 / COUNT(T.bond_id)) AS percent_double_bonds\nFROM \n    bond T\nWHERE \n    T.molecule_id = 'TR047';"
        ],
        "question": "Among all chemical compounds that contain molecule TR047, identify the percent that form a double-bond.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T WHERE T.molecule_id = 'TR047'",
        "amends": [
            "Do use `COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END)` instead of `SUM(CASE WHEN bond_type = ' = ' THEN 1 ELSE 0 END)` to properly count matching bonds. Do remove the extra spaces around the equals sign in `'='` instead of `' = '` to match the actual bond type format. Do cast the count to `REAL` instead of using `100.0` to ensure floating-point division. Do use explicit table alias `T` with column references instead of unqualified column names. Do count `T.bond_id` instead of `COUNT(*)` to be more precise about what's being counted. The amended query now correctly calculates the percentage of double bonds by properly identifying the bond type and ensuring accurate floating-point arithmetic."
        ],
        "rules": [
            "TR047 is the molecule id; double bond refers to bond_type = ' = '; percentage = DIVIDE(SUM(bond_type = ' = '), COUNT(all bond_id)) as percent where molecule_id = 'TR047'"
        ]
    },
    "56": {
        "sql": [
            "SELECT COUNT(*) \nFROM schools \nWHERE MailState = 'CA' \nAND MailCity = 'San Joaquin' \nAND StatusType = 'Active';",
            "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'California' AND City = 'San Joaquin' AND StatusType = 'Active';",
            "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND City = 'San Joaquin' AND StatusType = 'Active'"
        ],
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin city?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "amends": [
            "Do count `CDSCode` instead of `*` to exclude null values from the count. Do filter on `City` instead of `MailCity` to use the correct location attribute. Do remove the redundant `MailCity` filter since it's replaced by `City`. Do keep the `MailState` and `StatusType` filters unchanged. The amended query now correctly counts active schools in San Joaquin, California using the appropriate location field and excludes null CDS codes from the count.",
            "Do use the state abbreviation `CA` in the `MailState` filter instead of the full state name `California` to match the correct state code format. Do maintain the same column selection with `COUNT(CDSCode)` and preserve the same table source `schools` and join structure. Do keep the same filter conditions for `City = 'San Joaquin'` and `StatusType = 'Active'` in the WHERE clause, only correcting the state code format. The amended query now correctly filters for California schools using the proper state abbreviation and matches the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "1322": {
        "sql": [
            "SELECT COUNT(*) AS meeting_events_with_more_than_10_attendees\nFROM event e\nWHERE e.type = 'Meeting'\nAND (\n    SELECT COUNT(*)\n    FROM attendance a\n    WHERE a.link_to_event = e.event_id\n) > 10;",
            "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_id\nHAVING COUNT(T2.link_to_event) > 10\nEXCEPT\nSELECT T1.event_name\nFROM event AS T1\nWHERE T1.type = 'Meeting'"
        ],
        "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
        "amends": [
            "Do select `T1.event_name` instead of `COUNT(*) AS meeting_events_with_more_than_10_attendees`. Do use `INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event` instead of a correlated subquery in the WHERE clause. Do move the count condition to `HAVING COUNT(T2.link_to_event) > 10` instead of the subquery comparison. Do add `GROUP BY T1.event_id` instead of omitting grouping. Do use `EXCEPT` to filter out non-Meeting events instead of including `WHERE e.type = 'Meeting'` directly. Do remove the type filter from the main query and instead use `EXCEPT SELECT T1.event_name FROM event AS T1 WHERE T1.type = 'Meeting'` to exclude meeting events from the result. The amended query now correctly identifies events with more than 10 attendees while excluding meeting-type events, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "meetings events refers to type = 'Meeting'; attended by more than 10 members refers to COUNT(event_id) > 10"
        ]
    },
    "785": {
        "sql": [
            "SELECT superhero_name FROM superhero WHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'Neutral');"
        ],
        "question": "Describe the names of neutral alignment superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "amends": [],
        "rules": [
            "names of superheroes refers to superhero_name; neutral alignment refers to alignment = 'Neutral';"
        ]
    },
    "914": {
        "sql": [
            "SELECT COUNT(*) FROM drivers WHERE code IS NULL OR code = '';"
        ],
        "question": "How many drivers don't have a code?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) - COUNT(CASE WHEN code IS NOT NULL THEN code END) FROM drivers",
        "amends": [],
        "rules": [
            "don't have a code refers to code is null"
        ]
    },
    "851": {
        "sql": [
            "SELECT c.name AS circuit_name, c.lat AS latitude, c.lng AS longitude\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nJOIN results res ON r.raceId = res.raceId\nJOIN constructors con ON res.constructorId = con.constructorId\nWHERE con.name = 'Renault'\nGROUP BY c.circuitId;",
            "SELECT DISTINCT T1.position\nFROM constructorStandings AS T1\nINNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId\nWHERE T2.name = 'Renault'"
        ],
        "question": "Please list the positions of the circuits built by the constructor Renault.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.position FROM constructorStandings AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T2.name = 'Renault'",
        "amends": [
            "Do use `SELECT DISTINCT T1.position` instead of `SELECT c.name AS circuit_name, c.lat AS latitude, c.lng AS longitude`. Do change the FROM clause to use `constructorStandings AS T1 INNER JOIN constructors AS T2` instead of `circuits c JOIN races r ON c.circuitId = r.circuitId JOIN results res ON r.raceId = res.raceId JOIN constructors con ON res.constructorId = con.constructorId`. Do modify the join condition to `T2.constructorId = T1.constructorId` instead of the multiple join chain. Do keep the WHERE filter `T2.name = 'Renault'` but apply it to the correct table relationship instead of the original complex join structure. Do remove the GROUP BY clause entirely instead of including `GROUP BY c.circuitId`. The amended query now correctly retrieves distinct constructor positions for Renault from the constructor standings table instead of attempting to aggregate circuit data through an incorrect join path."
        ],
        "rules": [
            "Renault is a name of constructor;"
        ]
    },
    "604": {
        "sql": [
            "SELECT AVG(u.UpVotes) AS average_up_votes, AVG(u.Age) AS average_user_age\nFROM users u\nJOIN (\n    SELECT OwnerUserId, COUNT(*) AS post_count\n    FROM posts\n    GROUP BY OwnerUserId\n    HAVING COUNT(*) > 10\n) p ON u.Id = p.OwnerUserId;"
        ],
        "question": "What is the average of the up votes and the average user age for users creating more than 10 posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.UpVotes), AVG(T1.Age) FROM users AS T1 INNER JOIN ( SELECT OwnerUserId, COUNT(*) AS post_count FROM posts GROUP BY OwnerUserId HAVING post_count > 10) AS T2 ON T1.Id = T2.OwnerUserId",
        "amends": [],
        "rules": [
            "creating more than 10 post refers to Count (UserId) > 10; average of the up votes = Divide (Sum(UpVotes), Count (UserId)); average age = Divide (Sum(Age), Count(UserId))"
        ]
    },
    "1245": {
        "sql": [
            "SELECT COUNT(*) \nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE e.`Examination Date` > '1997-01-01'\nAND l.APTT >= 45;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date > '1997-01-01' AND T2.APTT >= 45"
        ],
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "amends": [
            "Do count `T1.ID` instead of `COUNT(*)` to avoid counting nulls. Do use `Patient` table as `T1` instead of omitting it entirely. Do use `INNER JOIN` between `Patient` and `Laboratory` instead of joining `Examination` with `Laboratory`. Do join on `T1.ID = T2.ID` instead of `e.ID = l.ID` to properly link patient records. Do filter on `T2.Date > '1997-01-01'` instead of `e.Examination Date > '1997-01-01'` to use the correct date column from Laboratory. Do keep `T2.APTT >= 45` filter but reference it through the proper table alias. The amended query now correctly counts patients with laboratory results meeting the date and APTT criteria."
        ],
        "rules": [
            "examinations done after 1997/1/1 refers to `Examination Date` > '1997-01-01'; normal activated partial prothrom bin time refesr to APTT < 45;"
        ]
    },
    "838": {
        "sql": [
            "SELECT full_name FROM superhero WHERE superhero_name = 'Alien';"
        ],
        "question": "Provide the full name of the superhero named Alien.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT full_name FROM superhero WHERE superhero_name = 'Alien'",
        "amends": [],
        "rules": []
    },
    "780": {
        "sql": [
            "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.full_name = 'Hunter Zolomon';"
        ],
        "question": "List the powers of Hunter Zolomon.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.full_name = 'Hunter Zolomon'",
        "amends": [],
        "rules": [
            "Hunter Zolomon is the full name of superhero; list the powers refers to power_name;"
        ]
    },
    "1446": {
        "sql": [
            "SELECT (SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) * 100.0 / COUNT(zip_code)) AS percentage_po_boxes FROM zip_code;"
        ],
        "question": "Calculate the percentage of zip codes that are PO boxes.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(zip_code) FROM zip_code",
        "amends": [],
        "rules": [
            "DIVIDE(SUM(type = 'PO Box'), COUNT(zip_code)) * 100"
        ]
    },
    "1036": {
        "sql": [
            "SELECT t.team_long_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE strftime('%Y', ta.date) = '2012'\nAND ta.buildUpPlayPassing > (\n    SELECT AVG(buildUpPlayPassing)\n    FROM Team_Attributes\n    WHERE strftime('%Y', date) = '2012'\n);"
        ],
        "question": "List the long name of teams with above-average build-up play passing in 2012.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t4.team_long_name FROM Team_Attributes AS t3 INNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTR(t3.`date`, 1, 4) = '2012' AND t3.buildUpPlayPassing > ( SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE STRFTIME('%Y',t2.`date`) = '2012')",
        "amends": [],
        "rules": [
            "long name of teams refers to team_long_name; build-up play passing refers to buildUpPlayPassing; above-average build-up play passing = buildUpPlayPassing > DIVIDE(SUM(buildUpPlayPassing), COUNT(team_long_name) WHERE buildUpPlayPassing IS NOT NULL); in 2012 refers to strftime('%Y', date) = '2012'; "
        ]
    },
    "1333": {
        "sql": [
            "SELECT z.city, z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.position = 'President';"
        ],
        "question": "What city and state did the President of the Student_Club grow up?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.city, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.position = 'President'",
        "amends": [],
        "rules": [
            "'President' is a position of Student Club;"
        ]
    },
    "1358": {
        "sql": [
            "SELECT m.first_name, m.last_name\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nORDER BY i.date_received ASC\nLIMIT 1;"
        ],
        "question": "Who was the first one paid his/her dues? Tell the full name.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.source = 'Dues' ORDER BY T2.date_received LIMIT 1",
        "amends": [],
        "rules": [
            "full name refers to first_name, last_name; first paid dues refers to MIN(received_date) where source = 'Dues'"
        ]
    },
    "782": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id\nWHERE eye_colour.colour = 'Black' AND hair_colour.colour = 'Black';"
        ],
        "question": "List the heroes' names whose eyes and hair colours are both black.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id WHERE T2.colour = 'Black'",
        "amends": [],
        "rules": [
            "heroes' names refers to superhero_name; eyes and hair colours are both black refers to eye_colour_id AND hair_colour_id WHERE colour.colour = 'Black';"
        ]
    },
    "435": {
        "sql": [
            "SELECT id FROM cards WHERE borderColor = 'black';"
        ],
        "question": "How many card border with black color ? List out the card id.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id",
        "amends": [],
        "rules": [
            "border with black color refers to borderColor = 'black'"
        ]
    },
    "1033": {
        "sql": [
            "SELECT AVG(height) AS average_height\nFROM Player\nWHERE strftime('%Y', birthday) BETWEEN '1990' AND '1995';"
        ],
        "question": "What is the average height of players born between 1990 and 1995?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(height) / COUNT(id) FROM Player WHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'",
        "amends": [],
        "rules": [
            "average height = DIVIDE(SUM(height), COUNT(id)); players born between 1990 and 1995 refers to birthday > = '1990-01-01 00:00:00' AND birthday < '1996-01-01 00:00:00';"
        ]
    },
    "1353": {
        "sql": [
            "SELECT z.type \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE m.first_name = 'Christof' AND m.last_name = 'Nielson';"
        ],
        "question": "What's Christof Nielson's zip code type?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.type FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Christof' AND T1.last_name = 'Nielson'",
        "amends": [],
        "rules": []
    },
    "1395": {
        "sql": [
            "SELECT COUNT(DISTINCT a.link_to_member) AS member_count\nFROM attendance a\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Community Theater' AND strftime('%Y', e.event_date) = '2019';"
        ],
        "question": "How many members did attend the event 'Community Theater' in 2019?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Community Theater' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "amends": [],
        "rules": [
            "event 'Community Theater' in 2019 refers to event_name = 'Community Theater' where YEAR(event_date) = 2019"
        ]
    },
    "1296": {
        "sql": [
            "SELECT e.ANA\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE l.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory WHERE `T-BIL` < 2.0)\nLIMIT 1;",
            "SELECT T3.ANA \nFROM Laboratory T1 \nJOIN Patient T2 ON T1.ID = T2.ID \nJOIN Examination T3 ON T1.ID = T3.ID \nWHERE T1.\"T-BIL\" < 2.0 \nORDER BY T1.\"T-BIL\" DESC \nLIMIT 1"
        ],
        "question": "What is the anti-nucleus antibody concentration of the patient whose total bilirubin is the highest in the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T3.ANA FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` < 2.0 ORDER BY T2.`T-BIL` DESC LIMIT 1",
        "amends": [
            "Do join `Patient` table instead of omitting it, connecting through `T1.ID = T2.ID` and `T1.ID = T3.ID` instead of directly joining `Examination` to `Laboratory`. Do filter with `T-BIL < 2.0` instead of an equality comparison to a subquery maximum. Do use `ORDER BY T-BIL DESC` instead of a subquery to find the maximum value. Do select `T3.ANA` from the properly joined `Examination` table instead of `e.ANA` from an incomplete join structure. The amended query now correctly retrieves the patient examination record with the highest T-BIL value below 2.0 through proper table relationships and ordering."
        ],
        "rules": [
            "anti-nucleus antibody concentration refers to ANA; total bilirubin is the highest in the normal range refers to MAX(`T-BIL` < 2.0);"
        ]
    },
    "424": {
        "sql": [
            "SELECT (COUNT(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 END) * 100.0 / COUNT(CASE WHEN isTextless = 1 THEN 1 END)) AS proportion\nFROM cards;",
            "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) / CAST(COUNT(*) AS REAL) FROM cards;",
            "SELECT SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) FROM cards;"
        ],
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "amends": [
            "Do use `SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 END)` to properly count matching rows with explicit ELSE 0. Do divide by `COUNT(*)` instead of `COUNT(CASE WHEN isTextless = 1 THEN 1 END)` to calculate the proportion against all cards rather than only textless ones. Do add explicit `CAST` to `REAL` instead of using decimal literal `100.0` to ensure floating-point division. Do remove the column alias `proportion` instead of keeping it. The amended query now correctly calculates the percentage of normal layout cards among all cards rather than only among textless cards, matching the intended behavior.",
            "Do use multiplication by 100 instead of division for percentage calculation, and do remove the redundant CAST around COUNT(*) instead of keeping it, while maintaining the same CASE expression logic for counting textless normal cards. The amended query now correctly calculates percentage by multiplying the sum by 100 before division rather than producing a fractional result, and eliminates unnecessary casting operations while preserving the intended behavior."
        ],
        "rules": [
            "do not have a text box refers to isTextless = 1; proportion refers to DIVIDE(COUNT(Textless = 1 and layout = 'normal'),COUNT(Textless))*100"
        ]
    },
    "197": {
        "sql": [
            "SELECT AVG(oxygen_count) AS average_oxygen_count\nFROM (\n    SELECT m.molecule_id, COUNT(a.atom_id) AS oxygen_count\n    FROM molecule m\n    JOIN bond b ON m.molecule_id = b.molecule_id\n    JOIN atom a ON m.molecule_id = a.molecule_id\n    WHERE b.bond_type = '-'\n    AND a.element = 'o'\n    GROUP BY m.molecule_id\n) AS oxygen_counts;",
            "SELECT AVG(oxygen_count) AS avg_oxygen_atoms\nFROM (\n    SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count\n    FROM atom T1\n    JOIN bond T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T2.bond_type = 'single'\n    AND T1.element = 'O'\n    GROUP BY T1.molecule_id\n)",
            "SELECT AVG(oxygen_count) FROM (\n    SELECT COUNT(T1.element) AS oxygen_count\n    FROM atom T1\n    JOIN bond T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T2.bond_type = '-'\n    AND T1.element = 'o'\n    GROUP BY T1.molecule_id\n) AS oxygen_counts"
        ],
        "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
        "amends": [
            "Do join `atom` and `bond` directly instead of joining both to `molecule` unnecessarily. Do use `COUNT(T1.element)` instead of `COUNT(a.atom_id)` since we're counting oxygen atoms. Do remove the redundant `molecule` table from the FROM clause instead of including it when the join between atom and bond already provides the necessary molecule context. Do reference `T1.molecule_id` in GROUP BY instead of `m.molecule_id` since the molecule table is no longer present. The amended query now correctly calculates average oxygen count for molecules with single bonds by directly joining atom and bond tables on molecule_id with appropriate filters.",
            "Do use `bond_type = '-'` instead of `bond_type = 'single'` in the WHERE filter. Do use `element = 'o'` instead of `element = 'O'` for case sensitivity. Do remove the alias `AS avg_oxygen_atoms` from the outer SELECT instead of keeping it. Do add the alias `AS oxygen_counts` to the subquery instead of omitting it. The amended query now correctly filters for single bonds using the '-' representation and handles element case consistently, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "single-bonded molecules refers to bond_type = '-' ; average number of oxygen atom = AVG(element = 'o')"
        ]
    },
    "614": {
        "sql": [
            "SELECT \n    (COUNT(DISTINCT b.UserId) * 100.0 / NULLIF(COUNT(DISTINCT u.Id), 0)) AS percentage_teacher_badge_users\nFROM \n    users u\nLEFT JOIN \n    badges b ON u.Id = b.UserId AND b.Name = 'Teacher';"
        ],
        "question": "Among the users who obtained the \"Teacher\" badge, calculate their percentage of users",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) * 100 / (SELECT COUNT(Id) FROM users) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Teacher'",
        "amends": [],
        "rules": [
            "\"Teacher\" is the Name of badge;  percentage = Divide (Count(UserId where it's \"Teacher\"), Count(UserId)) * 100"
        ]
    },
    "720": {
        "sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nGROUP BY s.full_name\nHAVING COUNT(hp.power_id) > 15;"
        ],
        "question": "Please list the full names of all the superheroes with over 15 super powers.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.full_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.full_name HAVING COUNT(T2.power_id) > 15",
        "amends": [],
        "rules": [
            "15 super powers refers to COUNT(full_name) > 15"
        ]
    },
    "1325": {
        "sql": [
            "SELECT expense_description, MAX(cost) AS most_expensive_cost FROM expense WHERE expense_description LIKE '%club event%' OR expense_description LIKE '%support of club%';",
            "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1;"
        ],
        "question": "What is the most expensive item that was spent in support of club events?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1",
        "amends": [
            "Do select only `expense_description` instead of selecting both `expense_description` and `MAX(cost)` with an alias. Do remove the `WHERE` filter with `LIKE` patterns instead of keeping the restrictive club event conditions. Do add `ORDER BY cost DESC` instead of omitting any ordering. Do add `LIMIT 1` instead of using aggregation to find the maximum. The amended query now correctly returns the single most expensive expense description by sorting costs in descending order and limiting to one result, matching the intended behavior."
        ],
        "rules": [
            "item in support of club events refers to expense_description; most expensive refers to MAX(cost)"
        ]
    },
    "647": {
        "sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.Location = 'North Pole' \nAND strftime('%Y', b.Date) = '2011';"
        ],
        "question": "Provide the badge names received in 2011 for the user whose location is in the North Pole.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE STRFTIME('%Y', T2.Date) = '2011' AND T1.Location = 'North Pole'",
        "amends": [],
        "rules": [
            "received in 2011 refers to year(Date) = 2011;"
        ]
    },
    "855": {
        "sql": [
            "SELECT r.url \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.name = 'Sepang International Circuit';",
            "SELECT DISTINCT T2.url FROM circuits T1 JOIN races T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Sepang International Circuit';",
            "SELECT DISTINCT T1.url\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Sepang International Circuit'"
        ],
        "question": "Where can I find the information about the races held on Sepang International Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "amends": [
            "Do use `DISTINCT` in the SELECT list instead of omitting it to eliminate duplicate rows. Do reference `circuits` as `T1` and `races` as `T2` instead of the reverse table aliases. Do join on `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId` to maintain the correct join direction between circuits and races tables. Do filter on `T1.name` instead of `c.name` since the circuit name belongs to the circuits table. The amended query now correctly returns unique race URLs for the specified circuit, matching the RIGHT_SQL's behavior.",
            "Do select `T1.url` instead of `T2.url` to retrieve the circuit URL from the correct table. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do maintain the same join condition `T2.circuitID = T1.circuitId` but note the capitalization difference in `circuitID` versus `circuitId`. Do keep the `DISTINCT` keyword and the WHERE filter `T1.name = 'Sepang International Circuit'` unchanged. The amended query now correctly retrieves circuit URLs from the circuits table rather than attempting to get them from the races table, matching the intended behavior."
        ],
        "rules": [
            "information about races refers to url;"
        ]
    },
    "683": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN u.Reputation > 1000 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nWHERE \n    strftime('%Y', p.CreationDate) = '2011';",
            "SELECT \n    (SUM(IIF(T1.Reputation > 1000, 1, 0)) * 100.0 / COUNT(T1.Id)) AS percentage\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId\nWHERE \n    STRFTIME('%Y', T2.CreationDate) = '2011'",
            "SELECT CAST(SUM(IIF(T1.Reputation > 1000 AND STRFTIME('%Y', T2.CreationDate) = '2011', 1, 0)) AS REAL) / COUNT(T1.Id) * 100 FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId;",
            "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreationDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId;",
            "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId"
        ],
        "question": "What is the percentage of posts whose owners had a reputation of over 1000 in 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
        "amends": [
            "Do use `SUM(IIF(condition, 1, 0))` with explicit `CAST` to `REAL` instead of `COUNT(CASE WHEN condition THEN 1 END)` for percentage calculation. Do apply the year filter `STRFTIME('%Y', T2.CreationDate) = '2011'` within the conditional aggregate instead of in the `WHERE` clause to ensure proper denominator calculation. Do reference `T1.Id` in `COUNT(T1.Id)` instead of `COUNT(*)` to count distinct users. Do use explicit `INNER JOIN` syntax with table aliases `T1` and `T2` instead of implicit `JOIN` without aliases. Do place the reputation condition `T1.Reputation > 1000` inside the conditional aggregate instead of in a separate `CASE` structure. The amended query now correctly calculates the percentage of users with reputation over 1000 who posted in 2011 by ensuring both numerator and denominator consider the same filtered dataset.",
            "Do move the `STRFTIME('%Y', T2.CreationDate) = '2011'` filter from the `WHERE` clause into the `IIF` condition instead of keeping it separate. Do add `CAST` to `REAL` around the `SUM` instead of omitting explicit casting. Do remove the `AS percentage` alias instead of keeping it. Do remove the explicit `FROM` clause formatting and table aliases instead of using them. The amended query now correctly calculates the percentage by applying the date filter within the conditional sum rather than filtering rows first, ensuring accurate calculation of the ratio of users with reputation over 1000 who posted in 2011 relative to all users who posted, regardless of year.",
            "Do place the `STRFTIME('%Y', T2.CreationDate) = '2011'` condition first in the IIF function instead of second, and do change the division order to `* 100 / COUNT(T1.Id)` instead of `/ COUNT(T1.Id) * 100` to ensure correct percentage calculation. Do add explicit `AS` aliases for table references `users AS T1` and `posts AS T2` instead of omitting them. The amended query now correctly calculates the percentage of users with reputation over 1000 who created posts in 2011.",
            "Do correct the typo in `STRFTIME('%Y', T2.CreationDate)` to `STRFTIME('%Y', T2.CreaionDate)` instead of using the incorrect column name, ensuring proper date formatting for the 2011 year filter. The amended query now matches RIGHT_SQL's behavior with the corrected column reference."
        ],
        "rules": [
            "percentage = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2011 and Reputation > 1000), COUNT(Id) ) * 100;"
        ]
    },
    "1324": {
        "sql": [
            "SELECT AVG(attendance_count) AS average_attendance\nFROM (\n    SELECT COUNT(*) AS attendance_count\n    FROM event e\n    JOIN attendance a ON e.event_id = a.link_to_event\n    WHERE e.event_date LIKE '2020%'\n    GROUP BY e.event_id\n);"
        ],
        "question": "What is the average attendance of meetings in 2020?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE SUBSTR(T1.event_date, 1, 4) = '2020' AND T1.type = 'Meeting'",
        "amends": [],
        "rules": [
            "meetings in 2020 refers to type = 'Meeting' where YEAR(event_date) = 2020; average = DIVIDE(COUNT(event_id), COUNT(DISTINCT event_name))"
        ]
    },
    "606": {
        "sql": [
            "SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0';"
        ],
        "question": "List out the name of badges that users obtained on 7/19/2010 7:39:08 PM.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0'",
        "amends": [],
        "rules": [
            "on 7/19/2010 7:39:08 PM refers to Date = '2010-07-19 19:39:08.0'"
        ]
    },
    "13": {
        "sql": [
            "SELECT s.Phone\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY (sc.NumGE1500 * 1.0 / sc.NumTstTakr) DESC\nLIMIT 3;"
        ],
        "question": "Please list the phone numbers of the schools with the top 3 SAT excellence rate.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr DESC LIMIT 3",
        "amends": [],
        "rules": [
            "Excellence rate = NumGE1500 / NumTstTakr"
        ]
    },
    "530": {
        "sql": [
            "-- Query to list all distinct frame styles (frameVersion)\nSELECT DISTINCT frameVersion FROM cards WHERE frameVersion IS NOT NULL;\n\n-- Query to list all cards Allen Williams worked on\nSELECT * FROM cards WHERE artist = 'Allen Williams';\n\n-- Query to find any banned cards\nSELECT c.* FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE l.status = 'Banned';",
            "SELECT \n    c.frameVersion, \n    c.name, \n    IIF(l.status = 'Banned', c.name, 'NO') AS banned_status\nFROM \n    cards c\nINNER JOIN \n    legalities l ON c.uuid = l.uuid\nWHERE \n    c.artist = 'Allen Williams'\nGROUP BY \n    c.frameVersion, c.name"
        ],
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "amends": [
            "Do select `frameVersion`, `name`, and a conditional expression instead of separate queries for distinct frame styles, artist cards, and banned cards. Do use `INNER JOIN` on `T1.uuid = T2.uuid` instead of separate queries with different join conditions. Do add filter `T1.artist = 'Allen Williams'` instead of having it as a separate query. Do include conditional logic `IIF(T2.status = 'Banned', T1.name, 'NO')` instead of querying banned cards separately. Do remove the `IS NOT NULL` filter on `frameVersion` since it's now part of the combined result set. The amended query now correctly combines all three original query requirements into a single cohesive result that shows Allen Williams' cards with their frame versions and banned status indication, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "frame styles refers to frameVersion; cards Allen Williams worked on refers to artist = 'Allen Williams'; banned cards refers to status = 'Banned'"
        ]
    },
    "1101": {
        "sql": [
            "SELECT AVG(m.away_team_goal) AS average_goals\nFROM Match m\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nJOIN League l ON m.league_id = l.id\nJOIN Country c ON l.country_id = c.id\nWHERE t.team_long_name = 'Parma' AND c.name = 'Italy';"
        ],
        "question": "What is the average number of goals made by Parma as the away team while playing in Italy?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) FROM \"Match\" AS T1 INNER JOIN TEAM AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN Country AS T3 ON T1.country_id = T3.id WHERE T2.team_long_name = 'Parma' AND T3.name = 'Italy'",
        "amends": [],
        "rules": [
            "Parma refers to team_long_name = 'Parma'; average number of goals refers to AVG(away_team_goal)"
        ]
    },
    "248": {
        "sql": [
            "SELECT a1.atom_id AS atom1_id, a1.element AS atom1_element, a2.atom_id AS atom2_id, a2.element AS atom2_element\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.molecule_id = 'TR041' AND b.bond_type = '#';",
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nINNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'"
        ],
        "question": "What are the atoms of the triple bond with the molecule \"TR041\"?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'",
        "amends": [
            "Do select only `T2.atom_id` and `T2.atom_id2` instead of selecting multiple atom details with aliases. Do use `INNER JOIN` from `atom AS T1` to `connected AS T2` on `T1.atom_id = T2.atom_id` instead of joining directly to bond first. Do then join `bond AS T3` on `T2.bond_id = T3.bond_id` instead of joining atom tables through connected. Do place both bond conditions `T3.bond_type = '#'` and `T3.molecule_id = 'TR041'` in the WHERE clause instead of having them separated. Do remove the additional atom table joins and element selections instead of including unnecessary atom details. The amended query now correctly retrieves only the connected atom pairs for the specified bond type and molecule."
        ],
        "rules": [
            "TR041 is the molecule id; triple bond refers to bond_type = '#';"
        ]
    },
    "623": {
        "sql": [
            "SELECT COUNT(DISTINCT u.Id) AS ElderSupporters\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE u.Age > 65 AND b.Name = 'Supporter';"
        ],
        "question": "How many elders obtained the \"Supporter\" badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Age > 65 AND T2.Name = 'Supporter'",
        "amends": [],
        "rules": [
            "\"Supporter\" is the Name of badge;\u00a0 elders refers to Age > 65"
        ]
    },
    "342": {
        "sql": [
            "SELECT name FROM cards WHERE faceConvertedManaCost = (SELECT MAX(faceConvertedManaCost) FROM cards);",
            "SELECT name FROM cards ORDER BY faceConvertedManaCost DESC LIMIT 1;",
            "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1;"
        ],
        "question": "List the card names with value that cost more converted mana for the face.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1",
        "amends": [
            "Do use `ORDER BY faceConvertedManaCost LIMIT 1` instead of a subquery with `MAX(faceConvertedManaCost)` to find the maximum value. Do remove the subquery entirely instead of keeping it, as the subquery approach is less efficient and potentially incorrect when multiple cards share the maximum converted mana cost. Do ensure the query returns exactly one row with the highest faceConvertedManaCost instead of potentially returning multiple rows if multiple cards have the same maximum value. The amended query now correctly returns the card name with the highest faceConvertedManaCost using a more efficient and reliable approach.",
            "Do remove the `DESC` keyword from the `ORDER BY` clause instead of keeping it, which changes the sort order from descending to ascending to correctly identify the card with the lowest converted mana cost rather than the highest. The amended query now matches RIGHT_SQL's behavior by returning the card name with the minimum faceConvertedManaCost value."
        ],
        "rules": [
            "more converted mana for the face refers to Max(faceConvertedManaCost);"
        ]
    },
    "321": {
        "sql": [
            "SELECT m.molecule_id, m.label\nFROM atom a1\nJOIN atom a2 ON a1.molecule_id = a2.molecule_id\nJOIN molecule m ON a1.molecule_id = m.molecule_id\nWHERE a1.atom_id = 'TR000_2' AND a2.atom_id = 'TR000_4';",
            "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'"
        ],
        "question": "What is the molecule of atom id \"TR000_2\" and atom id 2 \"TR000_4\"?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'",
        "amends": [
            "Do change the FROM clause to use `bond AS T1` and `connected AS T2` instead of `atom a1`, `atom a2`, and `molecule m`. Do use `INNER JOIN` on `T1.bond_id = T2.bond_id` instead of joining atoms on `molecule_id` and then joining to molecule. Do change the WHERE clause to filter on `T2.atom_id = 'TR000_2'` and `T2.atom_id2 = 'TR000_4'` instead of filtering on separate atom instances with the same atom_id values. Do remove the `m.label` column from the SELECT list instead of including it. Do remove the molecule table join entirely instead of keeping it. The amended query now correctly identifies bonds connecting the specified atoms rather than incorrectly finding molecules containing both atoms, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "1350": {
        "sql": [
            "SELECT e.status\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.expense_description = 'Post Cards, Posters' AND ex.expense_date = '2019-8-20';",
            "SELECT b.event_status \nFROM budget b\nINNER JOIN expense e ON b.budget_id = e.link_to_budget\nWHERE e.expense_description = 'Post Cards, Posters' \nAND e.expense_date = '2019-08-20'"
        ],
        "question": "What is the status of the event which bought \"Post Cards, Posters\" on 2019/8/20?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'",
        "amends": [
            "Do select `event_status` instead of `status` from the `budget` table instead of `event`. Do use `INNER JOIN` between `budget` and `expense` instead of joining through `event` table. Do join on `budget_id = link_to_budget` instead of the chain `event_id = link_to_event` and `budget_id = link_to_budget`. Do remove the unnecessary `event` table join instead of including it. Do use proper date format `2019-08-20` instead of `2019-8-20` for consistent date handling. The amended query now correctly filters expenses directly linked to budgets without the unnecessary event table intermediary, matching the right SQL's behavior."
        ],
        "rules": [
            "'Post Cards, Posters' is an expense description; on 2019/8/20 refers to expense_date = '2019-8-20'; status of event refers to event_status"
        ]
    },
    "1286": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS AdmittedPatientsWithHighALP\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.ALP >= 300 AND P.Admission = '+';",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP > (SELECT AVG(ALP) FROM Laboratory) \nAND T1.Admission = '+';",
            "SELECT COUNT(T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.ALP >= 300 \nAND T1.Admission = '+';"
        ],
        "question": "For the patient with an abnormal alkaliphophatase level, how many of them are admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP >= 300 AND T1.Admission = '+'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID) AS AdmittedPatientsWithHighALP` to remove the unnecessary DISTINCT and column alias. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do remove the space before the `+` in `T1.Admission = '+'` instead of keeping it. The amended query now correctly counts patients with high ALP who were admitted without unnecessary DISTINCT operations.",
            "Do use `T2.ALP >= 300` instead of `T2.ALP > (SELECT AVG(ALP) FROM Laboratory)` to filter for specific ALP threshold values instead of comparing against a dynamic average. Do remove the subquery entirely instead of keeping it, eliminating the unnecessary correlated calculation. The amended query now correctly counts patients with laboratory results meeting the fixed ALP threshold of 300 or higher rather than those exceeding the average ALP value, matching the intended behavior."
        ],
        "rules": [
            "abnormal alkaliphophatase level refers to ALP > = 300; admitted to the hospital refers to Admission = '+';"
        ]
    },
    "1423": {
        "sql": [
            "SELECT COUNT(*) FROM income WHERE amount = 50;"
        ],
        "question": "How many income are received with an amount of 50?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(income_id) FROM income WHERE amount = 50",
        "amends": [],
        "rules": [
            "amount of 50 refers to amount = 50"
        ]
    },
    "1493": {
        "sql": [
            "SELECT \n    ROUND(\n        (COUNT(CASE WHEN Consumption > 528.3 THEN 1 END) * 100.0 / COUNT(DISTINCT CustomerID)),\n        2\n    ) AS Percentage\nFROM \n    yearmonth\nWHERE \n    Date = '201202';",
            "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) / COUNT(CustomerID) * 100 FROM yearmonth WHERE Date LIKE '2012-02%';",
            "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) * 100 AS FLOAT) / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'"
        ],
        "question": "In February 2012, what percentage of customers consumed more than 528.3?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'",
        "amends": [
            "Do use `SUM(IIF(Consumption > 528.3, 1, 0))` instead of `COUNT(CASE WHEN Consumption > 528.3 THEN 1 END)` for conditional counting. Do remove `DISTINCT` from `COUNT(CustomerID)` instead of keeping it to count all customers rather than distinct ones. Do use explicit `CAST(... AS FLOAT)` instead of implicit conversion with `100.0` for proper floating-point division. Do remove `ROUND(..., 2)` instead of keeping it to return the raw percentage value without rounding. Do omit the `AS Percentage` alias instead of including it. The amended query now correctly calculates the percentage of customers with consumption exceeding 528.3 without unnecessary rounding or distinct counting.",
            "Do use `Date = '201202'` instead of `Date LIKE '2012-02%'` for exact date matching. Do place the multiplication by 100 after the SUM operation instead of after the division to correctly calculate the percentage as (sum/count)*100 rather than sum/(count*100)."
        ],
        "rules": [
            "February 2012 refers to '201202' in yearmonth.date; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
        ]
    },
    "706": {
        "sql": [
            "SELECT c.Text \nFROM comments c \nJOIN posts p ON c.PostId = p.Id \nWHERE p.Title LIKE '%linear regression%' OR p.Tags LIKE '%linear regression%';"
        ],
        "question": "Give the texts commented on the post about linear regression.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title LIKE '%linear regression%'",
        "amends": [],
        "rules": [
            "about linear regression refers to Title contains 'linear regression'"
        ]
    },
    "940": {
        "sql": [
            "WITH chinese_gp_2008 AS (\n    SELECT raceId\n    FROM races\n    WHERE year = 2008 AND name = 'Chinese Grand Prix'\n),\nfinished_drivers AS (\n    SELECT driverId\n    FROM results\n    WHERE raceId = (SELECT raceId FROM chinese_gp_2008) AND time IS NOT NULL\n),\nparticipated_drivers AS (\n    SELECT r.driverId\n    FROM results r\n    JOIN finished_drivers fd ON r.driverId = fd.driverId\n    WHERE r.raceId != (SELECT raceId FROM chinese_gp_2008)\n    GROUP BY r.driverId\n    HAVING COUNT(r.raceId) > 0\n)\nSELECT COUNT(*) AS num_drivers\nFROM participated_drivers;"
        ],
        "question": "Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )",
        "amends": [],
        "rules": [
            "COUNT(raceID) > 0 reveals that this driver participated in races; drivers who finished the race refers to time has value."
        ]
    },
    "86": {
        "sql": [
            "SELECT s.District, s.County, s.School, s.AdmLName1, s.AdmLName2, s.AdmLName3\nFROM schools s\nWHERE s.CharterNum = '40';",
            "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'"
        ],
        "question": "What is the administrator's last name that oversees the school with Charter number 40? Indicate the district, the county where the school is situated, and the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'",
        "amends": [
            "Do select only `AdmLName1`, `District`, `County`, and `School` columns instead of including additional columns `AdmLName2` and `AdmLName3`. Do use the literal value `'0040'` for the CharterNum filter instead of `'40'` to match the correct format. Do remove the table alias `s` from the column references instead of keeping it for consistency with the simplified query structure."
        ],
        "rules": []
    },
    "376": {
        "sql": [
            "SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%flying%';",
            "SELECT layout FROM cards WHERE keywords = 'Flying';"
        ],
        "question": "What are the card layout of cards with keyword of flying?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it, as the query logic ensures uniqueness through the exact match condition. Do use exact equality comparison `keywords = 'Flying'` instead of the pattern matching `LIKE '%flying%'` to precisely match the literal string value rather than performing a case-insensitive substring search. Do capitalize the string literal `'Flying'` instead of using lowercase `'flying'` to match the exact case of the stored data. The amended query now correctly retrieves cards with exactly the 'Flying' keyword rather than any card containing 'flying' as a substring, ensuring precise matching behavior."
        ],
        "rules": []
    },
    "1336": {
        "sql": [
            "SELECT DISTINCT m.department\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.last_name IN ('Pierce', 'Guidi');"
        ],
        "question": "What department offers the major that Pierce and Guidi took?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.last_name = 'Pierce' OR T1.last_name = 'Guidi'",
        "amends": [],
        "rules": []
    },
    "1420": {
        "sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'Vice President';"
        ],
        "question": "State the name of major that Vice President has joined.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Vice President'",
        "amends": [],
        "rules": [
            "name of major refers to major_name; 'Vice President' is position of Student Club"
        ]
    },
    "1010": {
        "sql": [
            "SELECT d.forename, d.surname, r.fastestLapTime, ra.name AS race_name, ra.date\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN races ra ON r.raceId = ra.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND r.fastestLapTime IS NOT NULL\nORDER BY r.fastestLapTime ASC\nLIMIT 1;",
            "SELECT T1.time \nFROM lapTimes AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'"
        ],
        "question": "What is the lap record set by Lewis Hamilton in a Formula_1 race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.time FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'",
        "amends": [
            "Do use `T1.time` instead of `d.forename, d.surname, r.fastestLapTime, ra.name, ra.date` in the SELECT list. Do join `lapTimes AS T1` instead of `results r` and `races ra` as the data source. Do use `INNER JOIN drivers AS T2` instead of `JOIN drivers d` with the corrected alias. Do specify the join condition `T1.driverId = T2.driverId` instead of `d.driverId = r.driverId` and `r.raceId = ra.raceId`. Do keep the WHERE filter `T2.forename = 'Lewis' AND T2.surname = 'Hamilton'` but remove the additional condition `r.fastestLapTime IS NOT NULL`. Do omit the ORDER BY and LIMIT clauses instead of including `ORDER BY r.fastestLapTime ASC LIMIT 1`. The amended query now correctly retrieves lap times from the lapTimes table instead of fastest lap times from results, matching the intended behavior."
        ],
        "rules": [
            "lap recod means the fastest time recorded which refers to time"
        ]
    },
    "963": {
        "sql": [
            "SELECT COUNT(DISTINCT d.driverId) AS french_drivers_with_fast_lap\nFROM drivers d\nJOIN lapTimes l ON d.driverId = l.driverId\nWHERE d.nationality = 'French' AND l.milliseconds < 120000;",
            "SELECT COUNT(T1.driverId)\nFROM drivers T1\nINNER JOIN lapTimes T2 ON T1.driverId = T2.driverId\nWHERE T1.nationality = 'French'\nAND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120.0"
        ],
        "question": "How many French drivers who obtain the laptime less than 02:00.00?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 on T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120",
        "amends": [
            "Do use `COUNT(T1.driverId)` without DISTINCT instead of `COUNT(DISTINCT d.driverId)` to count all qualifying rows rather than unique drivers. Do reference tables as `T1` and `T2` with explicit aliases instead of `d` and `l` for clarity. Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do convert the time string using `CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000` instead of directly comparing `milliseconds` to properly parse the time format. Do remove the alias `AS french_drivers_with_fast_lap` instead of keeping it since the result column is not named in the target query. The amended query now correctly handles time conversion from string format and counts all qualifying lap time records rather than distinct drivers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "lap time less than 02:00.00 refers to seconds < 120;"
        ]
    },
    "1226": {
        "sql": [
            "SELECT p.ID, l.\"T-CHO\"\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.\"T-CHO\" = (SELECT MAX(\"T-CHO\") FROM Laboratory)\nORDER BY (julianday('now') - julianday(p.Birthday)) DESC\nLIMIT 1;"
        ],
        "question": "Who is the oldest patient with the highest total cholesterol (T-CHO). State the patient ID and T-CHO index.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID, T2.`T-CHO` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-CHO` DESC, T1.Birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "oldest patient refers to MIN(birthday); highest total cholesterol refers to MAX(T-CHO);"
        ]
    },
    "1021": {
        "sql": [
            "SELECT player_name, MAX(height) AS tallest_height FROM Player;",
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;"
        ],
        "question": "What is the height of the tallest player? Indicate his name.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `MAX(height)` with an alias. Do use `ORDER BY height DESC` instead of an aggregate function to find the maximum. Do add `LIMIT 1` to return only the tallest player instead of potentially multiple rows. Do remove the unnecessary aggregation and column selection that would return incorrect results when trying to identify the tallest player by name."
        ],
        "rules": [
            "tallest player refers to MAX(height);"
        ]
    },
    "652": {
        "sql": [
            "SELECT p.Id AS PostId, b.Name AS BadgeName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nJOIN badges b ON u.Id = b.UserId\nWHERE u.DisplayName = 'Samuel'\nAND (strftime('%Y', p.CreaionDate) = '2013' OR strftime('%Y', b.Date) = '2013');",
            "SELECT T1.PostId, T2.Name\nFROM postHistory AS T1\nINNER JOIN badges AS T2 ON T1.UserId = T2.UserId\nWHERE T1.UserDisplayName = 'Samuel'\nAND STRFTIME('%Y', T1.CreationDate) = '2013'\nAND STRFTIME('%Y', T2.Date) = '2013'"
        ],
        "question": "List the post IDs and badge names of the user Samuel in 2013.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.PostId, T2.Name FROM postHistory AS T1 INNER JOIN badges AS T2 ON T1.UserId = T2.UserId WHERE T1.UserDisplayName = 'Samuel' AND STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'",
        "amends": [
            "Do select `T1.PostId` and `T2.Name` instead of `p.Id AS PostId` and `b.Name AS BadgeName`. Do use `FROM postHistory AS T1` instead of `FROM users u JOIN posts p ON u.Id = p.OwnerUserId`. Do `INNER JOIN badges AS T2 ON T1.UserId = T2.UserId` instead of `JOIN badges b ON u.Id = b.UserId`. Do filter with `T1.UserDisplayName = 'Samuel'` instead of `u.DisplayName = 'Samuel'`. Do use `AND STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'` instead of `AND (strftime('%Y', p.CreaionDate) = '2013' OR strftime('%Y', b.Date) = '2013')`. The amended query now correctly joins postHistory with badges on UserId, filters for both dates being in 2013 instead of either, and matches the right SQL's behavior."
        ],
        "rules": [
            "Samuel refers to UserDisplayName; YEAR(CreationDate) = 2013 relates to PostId; YEAR(Date) = 2013 relates to the badge;"
        ]
    },
    "663": {
        "sql": [
            "SELECT Id FROM users WHERE Age = (SELECT MIN(Age) FROM users);"
        ],
        "question": "What is the id of the youngest user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id FROM users WHERE Age = ( SELECT MIN(Age) FROM users )",
        "amends": [],
        "rules": [
            "the youngest user refers to MIN(Age);"
        ]
    },
    "1037": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN pa.preferred_foot = 'left' THEN 1 ELSE 0 END) * 100.0) / COUNT(DISTINCT p.player_api_id) AS percentage_left_footed\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    strftime('%Y', p.birthday) BETWEEN '1987' AND '1992';",
            "SELECT \n    (COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id END) * 100.0 / COUNT(t1.id)) AS percentage_left_footed\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    CAST(SUBSTR(t1.birthday, 1, 4) AS INTEGER) BETWEEN 1987 AND 1992;"
        ],
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "amends": [
            "Do use `COUNT(t1.id)` instead of `COUNT(DISTINCT p.player_api_id)` to avoid potential double-counting issues. Do cast the left-footed count to `REAL` instead of using integer division that could truncate decimal results. Do use `SUBSTR(t1.birthday, 1, 4)` instead of `strftime('%Y', p.birthday)` for year extraction to maintain compatibility across SQL implementations. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `t1` and `t2` instead of full table names for conciseness. Do remove the unnecessary `ELSE 0` from the CASE statement since counting NULL values achieves the same result more efficiently. Do place the percentage calculation directly in the SELECT list instead of wrapping it in parentheses. The amended query now correctly calculates the percentage of left-footed players born between 1987 and 1992 with proper decimal handling."
        ],
        "rules": [
            "players who prefer left foot refers to preferred_foot = 'left'; percentage of players who prefer left foot = DIVIDE(MULTIPLY((SUM(preferred_foot = 'left'), 100)), COUNT(player_fifa_api_id)); born between 1987 and 1992 refers to YEAR(birthday) BETWEEN '1987' AND '1992';"
        ]
    },
    "922": {
        "sql": [
            "SELECT r.time \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE r.year = 2010 AND c.name = 'Abu Dhabi';",
            "SELECT T2.date, T2.time FROM races T2 INNER JOIN circuits T1 ON T2.circuitId = T1.circuitId WHERE T2.year = 2010 AND T2.name = 'Abu Dhabi Grand Prix'"
        ],
        "question": "What time did the the 2010's Formula_1 race took place on the Abu Dhabi Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.date, T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2010 AND T2.name = 'Abu Dhabi Grand Prix'",
        "amends": [
            "Do select both `date` and `time` columns instead of only `time`. Do use table alias `T2` for races instead of `r`. Do use table alias `T1` for circuits instead of `c`. Do change the join condition to `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId`. Do filter on `T2.name = 'Abu Dhabi Grand Prix'` instead of `c.name = 'Abu Dhabi'`. Do remove the explicit JOIN keyword and use INNER JOIN syntax instead. The amended query now correctly retrieves both date and time for races matching the specific Grand Prix name in 2010."
        ],
        "rules": []
    },
    "1057": {
        "sql": [
            "SELECT AVG(home_team_goal) AS average_home_team_goal\nFROM \"Match\"\nWHERE season = '2010/2011'\nAND country_id = (SELECT id FROM \"Country\" WHERE name = 'Poland');"
        ],
        "question": "Calculate the average home team goal in the 2010/2011 season in the country of Poland.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Poland' AND t2.season = '2010/2011'",
        "amends": [],
        "rules": [
            "average home team goal = AVG(home_team_goal)= SUM(home_team_goal) / COUNT(DISTINCT Match.id) WHERE name = 'Poland' and season = '2010/2011';"
        ]
    },
    "273": {
        "sql": [
            "SELECT (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS percentage\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+';"
        ],
        "question": "What is the percentage of element chlorine in carcinogenic molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT( CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [],
        "rules": [
            "chlorine refers to element = 'cl'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(element = 'pb'); COUNT(molecule_id)) as percentage where label = '+'"
        ]
    },
    "454": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE borderColor = 'white' \nAND (power = '*' OR power IS NULL);",
            "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) \nFROM cards \nWHERE borderColor = 'white'"
        ],
        "question": "Among the cards with a white border color, how many of them have unknown power?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE borderColor = 'white'",
        "amends": [
            "Do use `SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific conditions. Do remove the explicit `WHERE` filter `(power = '*' OR power IS NULL)` instead of keeping it, as the counting logic is now handled within the aggregate expression. Do keep the `WHERE borderColor = 'white'` filter unchanged. The amended query now correctly counts cards where power contains asterisks (not just equals exactly '*') or is NULL, while maintaining the border color filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "unknown power refers to power = '*' or power is null"
        ]
    },
    "1285": {
        "sql": [
            "SELECT l.Date\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.ID = (SELECT ID FROM Patient WHERE `First Date` = (SELECT MAX(`First Date`) FROM Patient))\nAND l.LDH >= 500;",
            "SELECT T1.`First Date`\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH >= 500\nORDER BY T1.`First Date` DESC\nLIMIT 1;"
        ],
        "question": "When is the latest patient's medical data recorded? This patient should have an abnormal level of lactate dehydrogenase.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH >= 500 ORDER BY T1.`First Date` DESC LIMIT 1",
        "amends": [
            "Do select `First Date` from the Patient table instead of `Date` from the Laboratory table. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `JOIN` without aliases. Do remove the subquery that finds the patient with maximum `First Date` instead of keeping it, as the correct logic requires finding the maximum date among patients with high LDH values rather than filtering to a specific patient. Do add `ORDER BY T1.First Date DESC LIMIT 1` instead of omitting it, to retrieve only the most recent date from qualifying records. Do keep the `LDH >= 500` filter in the WHERE clause instead of changing it. The amended query now correctly identifies the most recent first date from patients with elevated LDH levels, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "latest patient refers to ID with MAX('First Date'); abnormal level of lactate dehydrogenase refers to LDH > = 500;"
        ]
    },
    "654": {
        "sql": [
            "SELECT u.DisplayName, u.Location\nFROM tags t\nJOIN posts p ON t.ExcerptPostId = p.Id\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE t.TagName = 'hypothesis-testing';"
        ],
        "question": "Mention the display name and location of the user who owned the excerpt post with hypothesis-testing tag.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.DisplayName, T3.Location FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id INNER JOIN users AS T3 ON T3.Id = T2.OwnerUserId WHERE T1.TagName = 'hypothesis-testing'",
        "amends": [],
        "rules": [
            "user who owned the excerpt post with hypothesis-testing tag refers to OwnerUserId WHERE TagName = 'hypothesis-testing';"
        ]
    },
    "1187": {
        "sql": [
            "SELECT DISTINCT ID\nFROM Laboratory\nWHERE Date BETWEEN '1987-07-06' AND '1996-01-31'\n  AND GPT > 30\n  AND ALB < 4;"
        ],
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "amends": [],
        "rules": [
            "examined between 1987/7/6 and 1996/1/31 refers to Date BETWEEN '1987-07-06' AND '1996-01-31'; GPT level greater than 30 refers to GPT > 30; ALB level less than 4 ALB < 4"
        ]
    },
    "923": {
        "sql": [
            "SELECT COUNT(*) AS race_count\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Italy';"
        ],
        "question": "How many Formula_1 races took place on the circuits in Italy?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Italy'",
        "amends": [],
        "rules": []
    },
    "1533": {
        "sql": [
            "SELECT t.CustomerID, y.Consumption\nFROM transactions_1k t\nJOIN yearmonth y ON t.CustomerID = y.CustomerID\nWHERE t.ProductID = 5 AND (t.Price / t.Amount) > 29.00 AND y.Date = '201208'",
            "SELECT T2.Consumption\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Price / T1.Amount > 29.00\nAND T1.ProductID = 5\nAND T2.Date = '201208'"
        ],
        "question": "For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price / T1.Amount > 29.00 AND T1.ProductID = 5 AND T2.Date = '201208'",
        "amends": [
            "Do select only `T2.Consumption` instead of including `t.CustomerID` in the SELECT list. Do use `INNER JOIN` with explicit `AS` aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do move the `(t.Price / t.Amount) > 29.00` filter directly to the WHERE clause instead of keeping it parenthesized. Do place all WHERE conditions (`T1.Price / T1.Amount > 29.00`, `T1.ProductID = 5`, and `T2.Date = '201208'`) as separate AND conditions instead of grouping the price/amount calculation. The amended query now correctly returns only consumption values for the specified criteria."
        ],
        "rules": [
            "August of 2012 refers to the Date value = '201208' ; Price per unit of product = Price / Amount;"
        ]
    },
    "421": {
        "sql": [
            "SELECT name, power, promoTypes\nFROM cards\nWHERE (power IS NULL OR power = '*') AND promoTypes = 'arenaleague'\nORDER BY name ASC\nLIMIT 3;",
            "SELECT name FROM cards WHERE power LIKE '%*%' AND promoTypes LIKE '%arena league%' ORDER BY name LIMIT 3;",
            "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3;"
        ],
        "question": "Please list top three unknown power cards that have promotional types for arena league in alphabetical order.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3",
        "amends": [
            "Do remove `power` and `promoTypes` from the SELECT list instead of including them. Do change the power filter to `power LIKE '%*%'` instead of `power = '*'` to catch any string containing an asterisk rather than requiring an exact match. Do remove the explicit `ASC` from ORDER BY instead of specifying it since ascending is the default. The amended query now correctly filters for cards where power contains an asterisk character and returns only the name column as specified in the RIGHT_SQL.",
            "Do add `(power IS NULL OR power LIKE '%*%')` instead of only `power LIKE '%*%'` to properly handle NULL values. Do change `promoTypes LIKE '%arena league%'` to `promoTypes = 'arenaleague'` instead of using a pattern match for exact string comparison. The amended query now correctly handles NULL power values and uses exact string matching for promoTypes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "unknown power cards refers to power is null or power = '*'; promotional types for arena league refers to promoTypes = 'arenaleague'"
        ]
    },
    "77": {
        "sql": [
            "SELECT \n    `School Name`,\n    (`FRPM Count (Ages 5-17)` / `Enrollment (Ages 5-17)` * 100) AS `Percent Eligible FRPM (Ages 5-17)`\nFROM \n    frpm\nWHERE \n    `County Name` = 'Los Angeles'\n    AND `Low Grade` = 'K'\n    AND `High Grade` = '9';",
            "SELECT T2.School, (T1.\"FRPM Count (Ages 5-17)\" * 100 / T1.\"Enrollment (Ages 5-17)\") \nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'"
        ],
        "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
        "amends": [
            "Do use `T2.School` instead of `School Name` and calculate `FRPM Count (Ages 5-17)` * 100 / `Enrollment (Ages 5-17)` instead of dividing first then multiplying by 100. Do add `INNER JOIN schools AS T2` on `T1.CDSCode = T2.CDSCode` instead of querying only the frpm table. Do use `T2.County = 'Los Angeles'` instead of `County Name = 'Los Angeles'` and `T2.GSserved = 'K-9'` instead of separate `Low Grade = 'K'` and `High Grade = '9'` conditions. Do remove the column alias `Percent Eligible FRPM (Ages 5-17)` instead of keeping it. The amended query now correctly joins the schools table for accurate school information and uses the proper grade range filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Percent (%) Eligible FRPM (Ages 5-17) can be acquired by `FRPM Count (Ages 5-17)` / `Enrollment (Ages 5-17)` * 100"
        ]
    },
    "602": {
        "sql": [
            "SELECT Id AS PostId, OwnerUserId AS UserId FROM posts WHERE Score > 60;",
            "SELECT PostId, UserId FROM postHistory WHERE PostId IN (SELECT Id FROM posts WHERE Score > 60)"
        ],
        "question": "List out all post ID with score more than 60 and list out all the user ID that created these post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT PostId, UserId FROM postHistory WHERE PostId IN ( SELECT Id FROM posts WHERE Score > 60 )",
        "amends": [
            "Do select `PostId` and `UserId` directly instead of selecting `Id AS PostId` and `OwnerUserId AS UserId`. Do query from `postHistory` table instead of `posts` table. Do use a subquery with `PostId IN (SELECT Id FROM posts WHERE Score > 60)` instead of applying the `Score > 60` filter directly in the main query. Do remove the direct `WHERE Score > 60` condition from the main query and instead filter through the subquery on the posts table. The amended query now correctly retrieves post history records for posts with high scores by using the appropriate table relationships and filtering logic."
        ],
        "rules": [
            "score more than 60 refers to Score > 60"
        ]
    },
    "1328": {
        "sql": [
            "SELECT m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Law and Constitutional Studies';"
        ],
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "amends": [],
        "rules": [
            "'Law and Constitutional Studies' is the major name"
        ]
    },
    "659": {
        "sql": [
            "SELECT COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000;"
        ],
        "question": "How many tags have post count between 5,000 to 7,000?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM tags WHERE Count BETWEEN 5000 AND 7000",
        "amends": [],
        "rules": [
            "post count between 5,000 to 7,000 refers to Count BETWEEN 5000 and 7000;"
        ]
    },
    "97": {
        "sql": [
            "SELECT DISTINCT d.client_id\nFROM disp d\nJOIN account a ON d.account_id = a.account_id\nJOIN trans t ON a.account_id = t.account_id\nWHERE d.type = 'Disponent'\nAND t.k_symbol = 'POPLATEK PO OBRATU';",
            "SELECT client_id FROM disp INNER JOIN account ON disp.account_id = account.account_id WHERE account.frequency = 'POPLATEK PO OBRATU' AND disp.type = 'DISPONENT'"
        ],
        "question": "List out the id number of client who choose statement of issuance after transaction are Disponent?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.client_id FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND T2.type = 'DISPONENT'",
        "amends": [
            "Do select `client_id` from the `disp` table instead of selecting `d.client_id` with a DISTINCT modifier. Do join `account` and `disp` tables with an `INNER JOIN` on `account_id` instead of using separate JOIN clauses with additional table references. Do filter on `frequency = 'POPLATEK PO OBRATU'` from the account table instead of filtering on `k_symbol = 'POPLATEK PO OBRATU'` from a non-existent trans table join. Do filter on `type = 'DISPONENT'` instead of `type = 'Disponent'` to match the correct case sensitivity. Do remove the unnecessary DISTINCT modifier and the incorrect trans table join entirely instead of including them. The amended query now correctly identifies clients with disposition accounts that have the specified frequency, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "'POPLATEK PO OBRATU' stands for issuance after transaction"
        ]
    },
    "387": {
        "sql": [
            "SELECT name, colors FROM cards WHERE setCode = 'OGW';",
            "SELECT id, colors FROM cards WHERE id IN (SELECT id FROM set_translations WHERE setCode = 'OGW')"
        ],
        "question": "What are the cards for set OGW? State the colour for these cards.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id, colors FROM cards WHERE id IN ( SELECT id FROM set_translations WHERE setCode = 'OGW' )",
        "amends": [
            "Do select `id` and `colors` instead of `name` and `colors`. Do use a subquery with `id IN (SELECT id FROM set_translations WHERE setCode = 'OGW')` instead of directly filtering `WHERE setCode = 'OGW'` on the cards table. Do remove the direct reference to the cards table's setCode column and instead correlate through the set_translations table to properly filter by set code. The amended query now correctly matches the intended behavior by using the set_translations table to identify cards belonging to the OGW set."
        ],
        "rules": [
            "set OGW refers to setCode = 'OGW';"
        ]
    },
    "1125": {
        "sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.finishing = 1\nORDER BY p.birthday ASC\nLIMIT 1;"
        ],
        "question": "Among the players with finishing rate of 1, pick the eldest player and state the player's name.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.finishing = 1 ORDER BY t1.birthday ASC LIMIT 1",
        "amends": [],
        "rules": [
            "eldest player refers to MAX(SUBTRACT(datetime(CURRENT_TIMESTAMP,'localtime'),datetime(birthday))); finishing rate of 1 refers to finishing = 1"
        ]
    },
    "146": {
        "sql": [
            "SELECT DISTINCT c.client_id, c.gender, c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN card cd ON d.disp_id = cd.disp_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.gender = 'F' AND cd.type = 'credit';",
            "SELECT T1.client_id\nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN account T3 ON T2.account_id = T3.account_id\nINNER JOIN loan T4 ON T3.account_id = T4.account_id\nINNER JOIN card T5 ON T2.disp_id = T5.disp_id\nWHERE T1.gender = 'F'"
        ],
        "question": "Who are the female account holders who own credit cards and also have loans?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T5 ON T2.account_id = T5.account_id INNER JOIN loan AS T3 ON T5.account_id = T3.account_id INNER JOIN card AS T4 ON T2.disp_id = T4.disp_id WHERE T1.gender = 'F'",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it. Do remove columns `gender` and `birth_date` from the SELECT list instead of including them. Do use `INNER JOIN` consistently for all joins instead of mixing `JOIN` (which implies INNER) with explicit `INNER JOIN`. Do change the join order to place `loan` before `card` instead of the reverse sequence. Do remove the filter `cd.type = 'credit'` from the WHERE clause instead of keeping it. Do use table aliases `T1`, `T2`, `T3`, `T4`, `T5` instead of single-letter aliases. The amended query now correctly returns only female clients with associated accounts, loans, and cards without unnecessary filtering on card type or distinct results."
        ],
        "rules": [
            "Female refers to gender = 'F'"
        ]
    },
    "1386": {
        "sql": [
            "SELECT SUM(e.cost) AS total_expense\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Yearly Kickoff';"
        ],
        "question": "What is the total expense for the Yearly Kickoff?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'Yearly Kickoff'",
        "amends": [],
        "rules": [
            "'Yearly Kickoff' is an event name; total expense refers to SUM(cost)"
        ]
    },
    "1518": {
        "sql": [
            "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-24' AND t.Time = '12:42:00';"
        ],
        "question": "For the deal happened at 2012/8/24 12:42:00, which country was it?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Time = '12:42:00'",
        "amends": [],
        "rules": [
            "'2012/8/24 12:42:00' can refer to date = '2012-08-24' AND T1.time = '12:42:00' in the database"
        ]
    },
    "835": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN a.alignment = 'Good' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_good\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    alignment a ON s.alignment_id = a.id\nWHERE \n    p.publisher_name = 'Marvel Comics';"
        ],
        "question": "Among all superheroes in Marvel Comics, identify the percentage of 'good' superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics'",
        "amends": [],
        "rules": [
            "Marvel Comics refers to publisher_name = 'Marvel Comics'; percentage = MULTIPLY(DIVIDE(SUM(alignment = 'Good' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100.0); good superheroes refers to alignment = 'Good';"
        ]
    }
}