{
    "468": {
        "question": "What is the Simplified Chinese translation of the name of the set \"Eighth Edition\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Eighth Edition' AND T2.language = 'Chinese Simplified'",
        "amends": [],
        "rules": [
            "Eighth Edition is the name of card set which refers to name = 'Eighth Edition'; Simplified Chinese refers to language = 'Chinese Simplified'; translation of the name refers to translation"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT st.translation\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.name = 'Eighth Edition' AND st.language = 'Chinese Simplified';"
        ],
        "rule_sql": []
    },
    "969": {
        "question": "How many British drivers who were born in 1980?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) = '1980'",
        "amends": [],
        "rules": [
            "born in 1980 refers to year(dob) = 1980;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) = '1980';"
        ],
        "rule_sql": []
    },
    "1240": {
        "question": "From laboratory examinations in 1991, what is the average hematoclit level that is lower than the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT AVG(T2.HCT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HCT < 29 AND STRFTIME('%Y', T2.Date) = '1991'",
        "amends": [],
        "rules": [
            "laboratory examinations in 1991 refers to Date like '1991%'; average hematoclit level = AVG(HCT); hematoclit level that is lower than the normal range refers to HCT < 29;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(HCT) AS average_hematocrit_below_normal \nFROM Laboratory \nWHERE Date LIKE '1991%' AND HCT < 29;"
        ],
        "rule_sql": []
    },
    "422": {
        "question": "What is the language of the card with the multiverse number 149934?",
        "db_id": "card_games",
        "ground_truth": "SELECT language FROM foreign_data WHERE multiverseid = 149934",
        "amends": [],
        "rules": [
            "multiverse number 149934 refers to multiverseid = 149934;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM foreign_data WHERE multiverseid = 149934;"
        ],
        "rule_sql": []
    },
    "1388": {
        "question": "Which students manage to generate the highest income. State his/her full name along with the income source.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name, T2.source FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.first_name, T1.last_name, T2.source ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "amends": [
            "Do select individual columns `first_name`, `last_name`, and `source` instead of concatenating them into a single `full_name` column. Do add `GROUP BY` with `first_name`, `last_name`, and `source` instead of omitting grouping. Do add `ORDER BY SUM(amount) DESC` instead of using a subquery to find maximum amount. Do add `LIMIT 1` instead of returning all rows with maximum amount. Do remove the WHERE clause with subquery instead of keeping it. The amended query now correctly returns the member with the highest total income rather than all members who have any income matching the maximum single income amount, matching the RIGHT_SQL's behavior.",
            "Do remove `SUM(amount) as total_income` from the SELECT list instead of including it, and do use explicit table aliases `T1` and `T2` instead of omitting them. Do specify `INNER JOIN` instead of just `JOIN` for clarity. Do reference the aggregate function `SUM(T2.amount)` directly in the ORDER BY clause instead of using the alias `total_income`, and do ensure all GROUP BY columns use the explicit table aliases `T1.first_name`, `T1.last_name`, and `T2.source` instead of unqualified column names. The amended query now correctly orders by the sum of amounts while selecting only the member and source details without including the aggregate value in the output, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"highest income\": rank members by the sum of their income amounts in descending order and keep only the top 1 row.\n2) When combining member and income tables: link rows where member.member_id equals income.link_to_member and keep only matching pairs (inner match).\n3) When outputting personal information: select first_name, last_name, and source as separate columns instead of concatenating them.\n4) When computing total income per member: group results by first_name, last_name, and source to calculate sum(amount) for each combination.\n5) When breaking ties in ranking: use the natural grouping of first_name, last_name, and source to distinguish between members.\nOutput columns (ordered): first_name, last_name, source",
            "1) When the question asks for \"highest income\": rank rows by the sum of T2.amount in descending order and keep the first 1 row.\n2) When combining T1 and T2 for shared entities: link rows where T1.member_id = T2.link_to_member using an inner match; keep only matching pairs.\n3) When the question asks for \"per student\" grouping: organize results by T1.first_name, T1.last_name, and T2.source and compute the sum of T2.amount per group.\n4) When ordering by an aggregate value: reference the aggregate function SUM(T2.amount) directly in the ordering clause instead of using an alias.\n5) When selecting output columns: include only T1.first_name, T1.last_name, and T2.source in the output, excluding aggregate values.\n6) When using table aliases: use T1 for the member table and T2 for the income table consistently.\n7) Output columns (ordered): T1.first_name, T1.last_name, T2.source"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, i.source\nFROM member m\nJOIN income i ON m.member_id = i.link_to_member\nWHERE i.amount = (SELECT MAX(amount) FROM income);",
            "SELECT first_name, last_name, source, SUM(amount) as total_income\nFROM member\nJOIN income ON member.member_id = income.link_to_member\nGROUP BY first_name, last_name, source\nORDER BY total_income DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.last_name, T2.source\nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nGROUP BY T1.first_name, T1.last_name, T2.source\nORDER BY SUM(T2.amount) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T2.source\nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nGROUP BY T1.first_name, T1.last_name, T2.source\nORDER BY SUM(T2.amount) DESC\nLIMIT 1;"
        ]
    },
    "1035": {
        "question": "Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60",
        "amends": [],
        "rules": [
            "teams with more than 50 but less than 60 build-up play speed refers to buildUpPlaySpeed >50 AND buildUpPlaySpeed <60; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60;"
        ],
        "rule_sql": []
    },
    "412": {
        "question": "What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?",
        "db_id": "card_games",
        "ground_truth": "SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'",
        "amends": [
            "Do select only `name` instead of `fd.name AS foreign_name`. Do use a subquery with `uuid IN (SELECT uuid FROM cards)` instead of a `JOIN` between tables. Do reference `types` instead of `type` in the subquery filter. Do remove the table alias `fd` from the column reference. Do place all card filters within the subquery instead of mixing them between join conditions and WHERE clause. Do maintain the `language = 'French'` filter on the outer query instead of applying it to the joined table. The amended query now correctly filters cards by their types attribute and uses a more efficient subquery approach instead of an unnecessary join.",
            "Do use `types = 'Creature'` instead of `types LIKE '%Creature%'` for exact matching. Do move the `language = 'French'` filter to the end of the WHERE clause instead of placing it at the beginning. Do maintain the same logical structure with the subquery checking for `uuid` values from the cards table with the specified artist, layout, borderColor, and creature type conditions. The amended query now correctly uses exact string comparison for the creature type and maintains the same result set as the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for the foreign name of a card in a specific language: select only the \"name\" column from the foreign_data table without aliasing it as foreign_name.\n2) When filtering for cards with specific attributes (type, layout, border color, artist): use a subquery that selects uuid from the cards table where \"types\" = 'Creature', \"layout\" = 'normal', \"borderColor\" = 'black', and \"artist\" = 'Matthew D. Wilson'.\n3) When retrieving foreign language data: filter the foreign_data table where \"language\" = 'French' and where uuid is in the result of the cards subquery.\n4) When combining card data with foreign language data: use a subquery approach with uuid IN (SELECT uuid FROM cards WHERE conditions) instead of a JOIN operation.\n5) When referencing the types attribute of cards: use the exact column name \"types\" (not \"type\") in the subquery filter.\n6) When handling the language filter: apply the \"language\" = 'French' condition to the outer query on the foreign_data table, not within a join condition.\n7) Output columns (ordered): name",
            "1) When the question asks for a card of type Creature: use exact string comparison with types = 'Creature' instead of pattern matching. 2) When filtering for French language in foreign_data: place the language = 'French' condition at the end of the WHERE clause. 3) When combining cards and foreign_data tables: use the uuid column as the linking key between the tables. 4) When filtering cards by artist: use exact string comparison with artist = 'Matthew D. Wilson'. 5) When filtering cards by layout: use exact string comparison with layout = 'normal'. 6) When filtering cards by border color: use exact string comparison with borderColor = 'black'. 7) Output columns (ordered): foreign_data.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT fd.name AS foreign_name\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.type = 'Creature'\n  AND c.layout = 'normal'\n  AND c.borderColor = 'black'\n  AND c.artist = 'Matthew D. Wilson'\n  AND fd.language = 'French';",
            "SELECT name FROM foreign_data WHERE language = 'French' AND uuid IN (SELECT uuid FROM cards WHERE artist = 'Matthew D. Wilson' AND layout = 'normal' AND borderColor = 'black' AND types LIKE '%Creature%')",
            "SELECT name FROM foreign_data WHERE uuid IN (SELECT uuid FROM cards WHERE artist = 'Matthew D. Wilson' AND layout = 'normal' AND borderColor = 'black' AND types = 'Creature') AND language = 'French'"
        ],
        "rule_sql": [
            "SELECT name FROM foreign_data WHERE language = 'French' AND uuid IN (SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson')"
        ]
    },
    "265": {
        "question": "List down the molecule id for non carcinogenic molecules.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.molecule_id FROM molecule AS T WHERE T.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM molecule WHERE label = '-';"
        ],
        "rule_sql": []
    },
    "176": {
        "question": "What is the amount of debt that client number 992 has, and how is this client doing with payments?",
        "db_id": "financial",
        "ground_truth": "SELECT T4.amount, T4.status FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 on T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 992",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.amount AS debt_amount, l.status AS payment_status\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.client_id = 992;"
        ],
        "rule_sql": []
    },
    "1310": {
        "question": "For the male patients that have a normal prothrombin time, what is their average prothrombin time?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT AVG(T2.PT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PT < 14 AND T1.SEX = 'M'",
        "amends": [],
        "rules": [
            "male refers to Sex = 'M'; normal prothrombin time refer to PT < 14; average prothrombin time = AVG(PT);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(L.PT) AS AverageProthrombinTime\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.PT < 14;"
        ],
        "rule_sql": []
    },
    "240": {
        "question": "List all the elements of the toxicology of the molecule \"TR004\".",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
        "amends": [],
        "rules": [
            "TR004 is the molecule id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT element FROM atom WHERE molecule_id = 'TR004';"
        ],
        "rule_sql": []
    },
    "597": {
        "question": "How many users from India have the teacher badges?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Location = 'India' AND T1.Name = 'Teacher'",
        "amends": [],
        "rules": [
            "\"India\" is the Location; \"Teacher\" is the Name of badge"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT u.Id) \nFROM users u \nJOIN badges b ON u.Id = b.UserId \nWHERE u.Location = 'India' AND b.Name = 'Teacher';"
        ],
        "rule_sql": []
    },
    "1436": {
        "question": "Please provide links to events for members who have paid more than 50 dollar.",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T1.cost > 50",
        "amends": [],
        "rules": [
            "have paid more than 50 dollar refers to cost > 50"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.link_to_event\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nWHERE e.cost > 50;"
        ],
        "rule_sql": []
    },
    "88": {
        "question": "What is the administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500?Provide the name of the school.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.AdmEmail1, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.AdmEmail1, sc.sname\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);"
        ],
        "rule_sql": []
    },
    "1357": {
        "question": "State the date Connor Hilton paid his/her dues.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Connor' AND T1.last_name = 'Hilton' AND T2.source = 'Dues'",
        "amends": [],
        "rules": [
            "Connor Hilton is the full name; full name refers to first_name, last_name; date the dues was paid refers to date_received where source = 'Dues';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT i.date_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.first_name = 'Connor' AND m.last_name = 'Hilton';"
        ],
        "rule_sql": []
    },
    "346": {
        "question": "List all the card id and artist with unknown power which are legal for commander play format.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Legal' AND T2.format = 'commander' AND (T1.power IS NULL OR T1.power = '*')",
        "amends": [],
        "rules": [
            "unknown power refers to power = '*' or POWER IS NULL; commander play format refers to format = 'commander'; legal for commander play format refers to format = 'commander' where status = 'Legal'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.id, c.artist\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE (c.power = '*' OR c.power IS NULL)\nAND l.format = 'commander'\nAND l.status = 'Legal';"
        ],
        "rule_sql": []
    },
    "1266": {
        "question": "Which is the youngest patient with an abnormal anti-ribonuclear protein level? Please list his or her date of birth.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP != '-' OR '+-' ORDER BY T1.Birthday DESC LIMIT 1",
        "amends": [],
        "rules": [
            "youngest patient refers to MAX(Birthday); abnormal anti-ribonuclear protein level refers to RNP NOT IN('-', '+-'); date of birth refers to Birthday;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.RNP IS NOT NULL AND l.RNP != ''\nORDER BY p.Birthday DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "722": {
        "question": "What is the colour of Apocalypse's skin?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id WHERE T1.superhero_name = 'Apocalypse'",
        "amends": [],
        "rules": [
            "Apocalypse refers to superhero_name = 'Apocalypse'; colour of skin refers to colour where skin_colour_id = colour.id"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE s.superhero_name = 'Apocalypse';"
        ],
        "rule_sql": []
    },
    "1517": {
        "question": "For the earliest customer, what segment did he/she have?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID ORDER BY Date ASC LIMIT 1",
        "amends": [
            "Do join `transactions_1k AS T1` with `customers AS T2` on `T1.CustomerID = T2.CustomerID` instead of querying `customers` alone with a subquery for `MIN(CustomerID)`. Do select `T2.Segment` with table qualification instead of just `Segment`. Do remove the `WHERE` filter with subquery entirely instead of using it to find the minimum CustomerID. Do add `ORDER BY Date ASC` and `LIMIT 1` to get the earliest transaction's customer segment instead of relying on minimum CustomerID value. The amended query now correctly retrieves the customer segment from the earliest transaction rather than the customer with the lowest ID value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about the earliest customer: join transactions_1k as T1 with customers as T2 on T1.CustomerID = T2.CustomerID to link transaction dates with customer information. 2) When determining the earliest transaction: order results by T1.Date in ascending order and take only the first row. 3) When selecting customer segment information: output T2.Segment from the joined result. 4) When combining transaction and customer data: use inner matching where T1.CustomerID equals T2.CustomerID to ensure only valid customer-transaction pairs are considered. 5) Output columns (ordered): T2.Segment"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Segment FROM customers WHERE CustomerID = (SELECT MIN(CustomerID) FROM customers);",
            "SELECT T2.Segment \nFROM transactions_1k AS T1 \nJOIN customers AS T2 ON T1.CustomerID = T2.CustomerID \nORDER BY T1.Date ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Segment \nFROM transactions_1k T1\nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID\nORDER BY T1.Date ASC\nLIMIT 1"
        ]
    },
    "86": {
        "question": "What is the administrator's last name that oversees the school with Charter number 40? Indicate the district, the county where the school is situated, and the name of the school.",
        "db_id": "california_schools",
        "ground_truth": "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'",
        "amends": [
            "Do select only `AdmLName1`, `District`, `County`, and `School` columns instead of including additional columns `AdmLName2` and `AdmLName3`. Do use the literal value `'0040'` for the CharterNum filter instead of `'40'` to match the correct format. Do remove the table alias `s` from the column references instead of keeping it for consistency with the simplified query structure."
        ],
        "rules": [
            "1) When the question asks for an administrator's last name, district, county, and school name: select only columns AdmLName1, District, County, and School from the schools table.\n2) When filtering by Charter number: use the exact literal value '0040' instead of '40' to match the correct format.\n3) When referencing columns in a single-table query: do not use table aliases for column references.\n4) When the question asks for specific information about a school: do not include additional administrator name columns (AdmLName2, AdmLName3) beyond what is explicitly requested.\nOutput columns (ordered): AdmLName1, District, County, School"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.District, s.County, s.School, s.AdmLName1, s.AdmLName2, s.AdmLName3\nFROM schools s\nWHERE s.CharterNum = '40';",
            "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'"
        ],
        "rule_sql": [
            "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'"
        ]
    },
    "679": {
        "question": "Which post has the highest score? Please give its id and title's name.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1",
        "amends": [
            "Do select `T1.Id` and `T2.Title` from joined tables instead of `Id` and `Title` from a single table. Do use `INNER JOIN` between `users AS T1` and `posts AS T2` on `T1.Id = T2.OwnerUserId` instead of querying only the `posts` table. Do remove the subquery with `MAX(Score)` condition and instead add `ORDER BY T2.Score DESC LIMIT 1` to get the highest-scoring post instead of all posts with the maximum score. Do add table aliases `T1` and `T2` for clarity instead of using unqualified column names. The amended query now correctly retrieves the user ID and title of the highest-scoring post by joining users with posts and limiting to the top result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the highest score: rank rows by T2.Score in descending order and keep the first 1 row.\n2) When combining users and posts tables: link rows where T1.Id = T2.OwnerUserId and keep only matching pairs (inner match).\n3) When the question asks for post id and title: select T1.Id and T2.Title as output columns.\n4) When handling table references: use table aliases T1 for users and T2 for posts as established in the amends.\nOutput columns (ordered): T1.Id, T2.Title"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Id, Title FROM posts WHERE Score = (SELECT MAX(Score) FROM posts);",
            "SELECT T1.Id, T2.Title \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nORDER BY T2.Score DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Id, T2.Title FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1;"
        ]
    },
    "517": {
        "question": "How many rare enchantment Abundance cards are there whose play format status are all legal?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.rarity = 'rare' AND T1.types = 'Enchantment' AND T1.name = 'Abundance' AND T2.status = 'Legal'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(DISTINCT c.uuid)` to count individual card IDs rather than distinct UUIDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use `T2.status = 'Legal'` as a direct filter instead of the complex `HAVING SUM(CASE WHEN l.status != 'Legal' THEN 1 ELSE 0 END) = 0` logic. Do use exact equality `T1.types = 'Enchantment'` instead of `LIKE '%Enchantment%'` for precise type matching. Do remove the unnecessary `GROUP BY c.uuid` clause since we're doing a simple count aggregation. Do add table aliases `T1` and `T2` consistently throughout the query instead of mixing `c` and `l` with unaliased references. The amended query now correctly counts cards with rare rarity, exact Enchantment type, specific name, and legal status, matching the intended behavior.",
            "Do use `T2.uuid = T1.uuid` for the join condition instead of `T1.uuid = T2.uuid` to maintain proper join semantics. Do change the `rarity` filter to lowercase `'rare'` instead of `'Rare'` to match the correct case sensitivity in the data. The amended query now correctly counts cards with the specified criteria while maintaining proper join relationships and case-sensitive filtering."
        ],
        "rules": [
            "1) When counting cards: use T1.id as the counting key instead of T1.uuid to count individual card IDs.\n2) When joining tables cards and legalities: use INNER JOIN to link rows where T1.uuid = T2.uuid and keep only matching pairs.\n3) When filtering for card name: use exact equality T1.name = 'Abundance'.\n4) When filtering for rarity: use exact equality T1.rarity = 'rare'.\n5) When filtering for card types: use exact equality T1.types = 'Enchantment' instead of pattern matching.\n6) When filtering for legal status: use direct filter T2.status = 'Legal' instead of complex HAVING logic.\n7) When performing aggregation: do not include unnecessary GROUP BY clauses for simple counts.\n8) When using table aliases: consistently use T1 for cards table and T2 for legalities table throughout the query.\nOutput columns (ordered): COUNT(T1.id)",
            "1) When joining cards T1 and legalities T2: link rows where T2.uuid = T1.uuid exactly as shown and keep only matching pairs (inner match). 2) When filtering for rarity: use the exact literal 'rare' (lowercase) instead of 'Rare' to match case sensitivity in the data. 3) When counting cards: compute the number of rows using T1.id as the counting key. 4) When the question asks for cards with specific characteristics: filter for T1.rarity = 'rare', T1.types = 'Enchantment', T1.name = 'Abundance', and T2.status = 'Legal'. 5) Output columns (ordered): COUNT(T1.id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.uuid)\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.name = 'Abundance'\n  AND c.rarity = 'rare'\n  AND c.types LIKE '%Enchantment%'\nGROUP BY c.uuid\nHAVING SUM(CASE WHEN l.status != 'Legal' THEN 1 ELSE 0 END) = 0;",
            "SELECT COUNT(T1.id) \nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'Rare' \nAND T1.types = 'Enchantment' \nAND T1.name = 'Abundance' \nAND T2.status = 'Legal'",
            "SELECT COUNT(T1.id) \nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nWHERE T1.rarity = 'rare' \nAND T1.types = 'Enchantment' \nAND T1.name = 'Abundance' \nAND T2.status = 'Legal'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM cards T1 \nINNER JOIN legalities T2 ON T2.uuid = T1.uuid \nWHERE T1.name = 'Abundance' \nAND T1.rarity = 'rare' \nAND T1.types = 'Enchantment' \nAND T2.status = 'Legal'"
        ]
    },
    "1504": {
        "question": "What is the average total price of the transactions taken place in January, 2012?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT AVG(Amount) FROM transactions_1k WHERE Date LIKE '2012-01%'",
        "amends": [],
        "rules": [
            "In January, 2012 means Date contains '2012-01'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(Amount * Price) AS average_total_price\nFROM transactions_1k\nWHERE strftime('%Y-%m', Date) = '2012-01';"
        ],
        "rule_sql": []
    },
    "1146": {
        "question": "Please provide the full name of the away team that scored the most goals.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.team_long_name FROM Match AS t1 INNER JOIN Team AS t2 ON t1.away_team_api_id = t2.team_api_id ORDER BY t1.away_team_goal DESC LIMIT 1",
        "amends": [
            "Do use `t2.team_long_name` with alias `t2` instead of `t.team_long_name` with alias `t`. Do remove the `GROUP BY m.away_team_api_id` clause instead of keeping it. Do order by `t1.away_team_goal DESC` directly instead of using `SUM(m.away_team_goal) DESC` with aggregation. Do use explicit `INNER JOIN` with table aliases `t1` and `t2` instead of simple `JOIN` with aliases `m` and `t`. The amended query now correctly retrieves the single team with the highest away team goal in a match rather than attempting to aggregate goals across multiple matches per team."
        ],
        "rules": [
            "1) When the question asks for the team that scored the most goals: rank rows by the exact goal column token (t1.away_team_goal) in descending order and keep the first 1 row.\n2) When combining Match and Team tables for shared entities: link rows where the exact key equality t1.away_team_api_id = t2.team_api_id is satisfied; keep only matching pairs (inner match).\n3) When the question asks for the full name of a team: output the exact column token t2.team_long_name.\n4) When handling table aliases: use t1 for the Match table and t2 for the Team table as specified in the amends.\n5) When ordering by goal count: use the direct column value t1.away_team_goal instead of aggregating with SUM.\n6) When the question implies a single top result: do not use GROUP BY clauses.\nOutput columns (ordered): t2.team_long_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_long_name\nFROM Match m\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nGROUP BY m.away_team_api_id\nORDER BY SUM(m.away_team_goal) DESC\nLIMIT 1;",
            "SELECT t2.team_long_name \nFROM Match AS t1 \nINNER JOIN Team AS t2 ON t1.away_team_api_id = t2.team_api_id \nORDER BY t1.away_team_goal DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.team_long_name\nFROM Match t1\nINNER JOIN Team t2 ON t1.away_team_api_id = t2.team_api_id\nORDER BY t1.away_team_goal DESC\nLIMIT 1"
        ]
    },
    "1212": {
        "question": "For patients with alkaliphophatase (ALP) within normal range, were they treated as inpatient or outpatient?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300",
        "amends": [
            "Do select only `T1.Admission` instead of selecting both `p.Admission` and `COUNT(*) AS PatientCount`. Do remove the `GROUP BY p.Admission` clause instead of keeping it since aggregation is no longer needed. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `p` and `l`. Do place the filter `T2.ALP < 300` in the `WHERE` clause instead of keeping it there, maintaining the same filtering logic. The amended query now correctly returns individual admission records without aggregation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about admission status for patients with ALP within normal range: select only T1.Admission without aggregation or grouping.\n2) When combining Patient and Laboratory tables: use INNER JOIN where T1.ID = T2.ID to link patient records with their lab results.\n3) When filtering for ALP within normal range: apply the condition T2.ALP < 300 in the WHERE clause.\n4) When using table aliases: refer to Patient table as T1 and Laboratory table as T2 consistently.\n5) Output columns (ordered): T1.Admission"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    p.Admission,\n    COUNT(*) AS PatientCount\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.ALP < 300\nGROUP BY \n    p.Admission;",
            "SELECT T1.Admission \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP < 300"
        ],
        "rule_sql": [
            "SELECT T1.Admission \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP < 300"
        ]
    },
    "1098": {
        "question": "What is Ajax's highest chance creation passing score and what is it classified as?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Ajax' ORDER BY t2.chanceCreationPassing DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Ajax's refers to team_long_name = 'Ajax'; chance creation passing score refers to MAX(chanceCreationPassing); classified refer to chanceCreationPassingClass"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(ta.chanceCreationPassing) AS highest_chance_creation_passing, ta.chanceCreationPassingClass\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE t.team_long_name = 'Ajax';"
        ],
        "rule_sql": []
    },
    "204": {
        "question": "Of the first 100 molecules in number order, how many are carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'",
        "amends": [],
        "rules": [
            "first 100 molecules in number order refers to molecule_id between 'TR000' and 'TR099'; label = '+' means molecules are carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecule WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND label = '+';"
        ],
        "rule_sql": []
    },
    "1172": {
        "question": "How many male patients have elevated total bilirubin count?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "amends": [],
        "rules": [
            "male refers to SEX = 'M'; elevated means above the normal range; total bilirubin above the normal range refers to `T-BIL` >= '2.0'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.`T-BIL` >= 2.0;"
        ],
        "rule_sql": []
    },
    "841": {
        "question": "Provide the weight and race of the superhero with superhero ID 40.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.weight_kg, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.id = 40",
        "amends": [],
        "rules": [
            "weight refers to weight_kg; superhero ID 40 refers to superhero.id = 40;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.weight_kg, r.race FROM superhero s JOIN race r ON s.race_id = r.id WHERE s.id = 40;"
        ],
        "rule_sql": []
    },
    "353": {
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "amends": [
            "Do select `name` and `totalSetSize` instead of including `code` in the SELECT list. Do use `INNER JOIN` with alias `T2` instead of `JOIN` with alias `st`. Do reference `T1.code = T2.setCode` instead of `s.code = st.setCode` in the join condition. Do filter on `T2.language` instead of `st.language`. The amended query now correctly retrieves only the set name and total size for Italian translations without exposing the code field."
        ],
        "rules": [
            "1) When the question asks for sets available in Italian translation: filter rows where T2.language equals 'Italian' exactly. 2) When combining tables sets and set_translations: link rows where T1.code equals T2.setCode exactly and keep only matching pairs (inner match). 3) When listing sets with their total number of cards: include T1.name and T1.totalSetSize in the output. 4) When the question asks for the total number of cards per set: use T1.totalSetSize as the count value. 5) Output columns (ordered): T1.name, T1.totalSetSize"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.code, s.name, s.totalSetSize\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Italian';",
            "SELECT T1.name, T1.totalSetSize\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Italian';"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.totalSetSize\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Italian'\nORDER BY T1.name;"
        ]
    },
    "1178": {
        "question": "What was the gender of the first AORTITIS diagnosed patient?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
        "amends": [
            "Do add `AND First Date IS NOT NULL` to the WHERE filter instead of omitting it, which ensures only records with non-null date values are considered for ordering. This prevents potential issues with NULL values being included in the ORDER BY clause and ensures the query returns a meaningful result when sorting by date. The amended query now matches RIGHT_SQL's behavior by properly handling NULL date values."
        ],
        "rules": [
            "1) When the question asks for the first patient diagnosed with a specific condition: filter records where Diagnosis equals 'AORTITIS' exactly and ensure First Date is not null. 2) When ordering by date to find the first occurrence: sort records by First Date in ascending order. 3) When limiting to the first result: take only the top 1 row after ordering. 4) When selecting gender information: output the SEX column value. Output columns (ordered): SEX"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' ORDER BY `First Date` ASC LIMIT 1;",
            "SELECT p.SEX\nFROM Patient p\nWHERE p.Diagnosis = 'AORTITIS' \nAND p.\"First Date\" IS NOT NULL\nORDER BY p.\"First Date\" ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND \"First Date\" IS NOT NULL ORDER BY \"First Date\" ASC LIMIT 1"
        ]
    },
    "863": {
        "question": "Show me the season page of year when the race No. 901 took place.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "amends": [],
        "rules": [
            "race number refers to raceId;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.url \nFROM seasons s \nJOIN races r ON s.year = r.year \nWHERE r.raceId = 901;"
        ],
        "rule_sql": []
    },
    "487": {
        "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "amends": [
            "Do use `SUM(CASE ... THEN 1 ELSE 0 END)` with explicit ELSE instead of `COUNT(CASE ... THEN 1 END)` for conditional counting. Do add `INNER JOIN sets AS T2 ON T2.code = T1.setCode` instead of omitting the sets table join. Do filter on `T2.name = 'Coldsnap'` instead of `setCode = 'Coldsnap'` to use the set name rather than code. Do reference `T1.id` in `COUNT(T1.id)` instead of `COUNT(*)` for more precise counting. Do wrap the calculation with `CAST(... AS REAL)` instead of using `100.0` for explicit type conversion. Do add table alias `T1` to all column references instead of using unqualified column names. The amended query now correctly joins with the sets table and filters by set name rather than code, ensuring accurate calculation of the percentage.",
            "Do change the CASE condition from `power = 'Incredible'` to `cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL` instead of checking for a specific power value. Do remove the division operator placement by using `* 100 / COUNT()` instead of `/ COUNT() * 100.0` to ensure correct mathematical order of operations. Do omit the alias `percentage` instead of including it, as the right query returns an unnamed result. The amended query now correctly calculates the percentage of cards that have both cardKingdomFoilId and cardKingdomId values populated for the Coldsnap set, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a percentage calculation: use SUM(CASE WHEN <CONDITION> THEN 1 ELSE 0 END) divided by COUNT(T1.id) multiplied by 100 with explicit CAST to REAL type conversion. 2) When filtering by set name 'Coldsnap': use T2.name = 'Coldsnap' instead of setCode filtering. 3) When joining tables for set information: perform an INNER JOIN between T1 (cards) and T2 (sets) where T2.code = T1.setCode. 4) When counting rows for percentage denominator: use COUNT(T1.id) instead of COUNT(*) for precise counting. 5) When referencing columns from multiple tables: use table aliases T1 for cards table and T2 for sets table on all column references. 6) When identifying incredibly powerful cards: use the condition T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL. Output columns (ordered): percentage_incredibly_powerful",
            "1) When the question asks for percentage of cards with specific properties in a set: compute (number of cards satisfying both conditions) divided by (total number of cards in the set) multiplied by 100. 2) When identifying cards from the Coldsnap set: filter to only include cards where T2.name equals 'Coldsnap' exactly. 3) When checking for incredibly powerful cards: verify that both T1.cardKingdomFoilId and T1.cardKingdomId are not null instead of checking power values. 4) When performing division and percentage calculation: multiply the count of matching cards by 100 before dividing by the total count to ensure correct mathematical order. 5) When outputting results: do not include column aliases in the final output. 6) Output columns (ordered): the calculated percentage value without any column name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 END) * 100.0 / \n    COUNT(*)) AS percentage_incredibly_powerful\nFROM \n    cards\nWHERE \n    setCode = 'Coldsnap';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.power = 'Incredible' THEN 1 ELSE 0 END) AS REAL) / CAST(COUNT(T1.id) AS REAL) * 100.0 AS percentage\nFROM \n    cards AS T1\nINNER JOIN \n    sets AS T2 ON T2.code = T1.setCode\nWHERE \n    T2.name = 'Coldsnap';",
            "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(T1.id) \nFROM cards AS T1 \nINNER JOIN sets AS T2 ON T2.code = T1.setCode \nWHERE T2.name = 'Coldsnap'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(T1.id) \nFROM \n    cards T1\nINNER JOIN \n    sets T2 ON T2.code = T1.setCode\nWHERE \n    T2.name = 'Coldsnap';"
        ]
    },
    "1288": {
        "question": "Please list the diagnosis of the patients whose total protein is lower than normal.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0",
        "amends": [],
        "rules": [
            "total protein is lower than normal refers to TP < 6.0;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TP < 6.0;"
        ],
        "rule_sql": []
    },
    "1166": {
        "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T2.Symptoms, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Symptoms IS NOT NULL ORDER BY T1.Birthday DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T2.Symptoms` and `T1.Diagnosis` instead of `e.Symptoms` and `e.Diagnosis`. Do use `INNER JOIN` instead of `JOIN` for clarity. Do remove the subquery filter on `p.Birthday` and instead add `ORDER BY T1.Birthday DESC LIMIT 1` to get the most recent patient record instead of filtering by maximum birthday. Do keep the `T2.Symptoms IS NOT NULL` filter but move it to the WHERE clause instead of having it as a separate condition. Do add explicit ordering and limiting instead of relying on subquery comparison for date filtering."
        ],
        "rules": [
            "1) When the question asks about the youngest patient: order rows by T1.Birthday in descending direction and keep only the first 1 row.\n2) When the question asks for symptoms and diagnosis: output T2.Symptoms and T1.Diagnosis as the result columns.\n3) When combining Patient and Examination tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match).\n4) When symptoms must be present: include only rows where T2.Symptoms is not null.\nOutput columns (ordered): T2.Symptoms, T1.Diagnosis"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.Symptoms, e.Diagnosis\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Birthday = (SELECT MAX(Birthday) FROM Patient)\nAND e.Symptoms IS NOT NULL;",
            "SELECT T2.Symptoms, T1.Diagnosis \nFROM Patient T1 \nINNER JOIN Examination T2 ON T1.ID = T2.ID \nWHERE T2.Symptoms IS NOT NULL \nORDER BY T1.Birthday DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Symptoms, T1.Diagnosis\nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.Symptoms IS NOT NULL\nORDER BY T1.Birthday DESC\nLIMIT 1"
        ]
    },
    "1155": {
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "amends": [],
        "rules": [
            "LDH beyond normal range refers to LDH > '500';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.LDH > 500;"
        ],
        "rule_sql": []
    },
    "1320": {
        "question": "Please list the event names of all the events attended by Maya Mclean.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nWHERE m.first_name = 'Maya' AND m.last_name = 'Mclean';"
        ],
        "rule_sql": []
    },
    "966": {
        "question": "How many driver participated in race ID number 18?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18",
        "amends": [
            "Do query the `driverStandings` table instead of the `results` table. Do remove the `DISTINCT` modifier from the `COUNT` function instead of keeping it. Do use `COUNT(driverId)` instead of `COUNT(DISTINCT driverId)` to count all driver entries rather than unique drivers. The amended query now correctly counts all driver entries in the driver standings for race 18, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about driver participation in a specific race ID: query the \"driverStandings\" table instead of the \"results\" table. 2) When counting driver entries for a race: use COUNT(driverId) without the DISTINCT modifier to count all driver entries rather than unique drivers. 3) When filtering for a specific race ID number: include the condition raceId = 18 using the exact literal value. 4) Output columns (ordered): COUNT(driverId)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT driverId) FROM results WHERE raceId = 18;",
            "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18;"
        ],
        "rule_sql": [
            "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18"
        ]
    },
    "500": {
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "amends": [
            "Do reference `set_translations` directly as `T2` instead of joining through an intermediate `sets` table. Do use `INNER JOIN` between `cards` and `set_translations` on `T2.setCode = T1.setCode` instead of chaining through `sets` with `c.setCode = s.code` and `s.code = st.setCode`. Do add `AND T2.translation IS NOT NULL` to filter out null translations instead of omitting this null check. Do remove the alias `japanese_set_name` for the translation column instead of keeping it. The amended query now correctly retrieves Japanese set translations for the specified card while ensuring non-null results, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the Japanese name of a set containing a specific card: use the exact card name \"Fellwar Stone\" as a filter condition. 2) When joining cards and set_translations tables: link rows where T1.setCode = T2.setCode using an inner match. 3) When retrieving Japanese translations: filter for T2.language = 'Japanese' exactly. 4) When handling translations: ensure T2.translation IS NOT NULL to exclude null values. 5) Output columns (ordered): T2.translation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT st.translation AS japanese_set_name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode\nWHERE c.name = 'Fellwar Stone' AND st.language = 'Japanese';",
            "SELECT T2.translation\nFROM cards T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.setCode\nWHERE T1.name = 'Fellwar Stone'\nAND T2.language = 'Japanese'\nAND T2.translation IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT T2.translation \nFROM cards T1 \nJOIN set_translations T2 ON T1.setCode = T2.setCode \nWHERE T1.name = 'Fellwar Stone' \nAND T2.language = 'Japanese' \nAND T2.translation IS NOT NULL"
        ]
    },
    "426": {
        "question": "Please provide top three sets that don't appear in Magic: The Gathering Online, along with their names in in alphabetical order.",
        "db_id": "card_games",
        "ground_truth": "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3",
        "amends": [],
        "rules": [
            "don't appear in Magic: The Gathering Online refers to mtgoCode is NULL or mtgoCode = ''"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM sets WHERE mtgoCode IS NULL OR mtgoCode = '' ORDER BY name ASC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "637": {
        "error": "something went wrong, tool did not call.",
        "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
        "amends": [
            "Do use `INNER JOIN` with `users` and `postHistory` on `T1.Id = T2.UserId` instead of a CTE with a subquery for user lookup. Do add `INNER JOIN` with `posts` on `T3.Id = T2.PostId` instead of querying `posts` directly. Do select `T3.Tags` directly instead of complex JSON parsing with `REPLACE` and `json_each`. Do remove the `DISTINCT` clause and JSON manipulation instead of keeping them. Do move the `CommentCount = 0` filter to the `WHERE` clause instead of the CTE. Do remove the empty value filter instead of keeping it. The amended query now correctly retrieves tags from posts through the proper join relationships instead of attempting to parse malformed tag strings.",
            "Do remove `DISTINCT` instead of keeping it, and do remove the filters `T3.Tags IS NOT NULL` and `T3.Tags != ''` instead of including them, while keeping the same `SELECT T3.Tags` column, `FROM` sources with `INNER JOIN` on `T1.Id = T2.UserId` and `T3.Id = T2.PostId`, and `WHERE` filters for `T1.DisplayName = 'Mark Meckes'` and `T3.CommentCount = 0`. The amended query now matches RIGHT_SQL's behavior by eliminating unnecessary distinct processing and redundant null/empty string checks on the Tags column."
        ],
        "rules": [
            "1) When looking for posts by a specific user with DisplayName 'Mark Meckes': use INNER JOIN between users table (T1) and postHistory table (T2) where T1.Id = T2.UserId. 2) When retrieving post information: use INNER JOIN between postHistory (T2) and posts table (T3) where T3.Id = T2.PostId. 3) When filtering for posts without comments: apply CommentCount = 0 condition in the WHERE clause. 4) When extracting tags from posts: select T3.Tags directly without JSON parsing or REPLACE operations. 5) When handling tag values: do not filter out empty values. 6) When ensuring unique results: do not use DISTINCT clause. Output columns (ordered): T3.Tags",
            "1) When the question asks for tags used by a specific user: filter rows where T1.DisplayName equals 'Mark Meckes' exactly.\n2) When the question specifies posts without comments: filter rows where T3.CommentCount equals 0.\n3) When combining user and post data: link rows where T1.Id equals T2.UserId and T3.Id equals T2.PostId, keeping only matching pairs.\n4) When selecting tags from posts: output the T3.Tags column without removing duplicates or filtering for null/empty values.\n5) When the question asks for \"all the tags used\": do not apply DISTINCT to remove duplicate tag values.\n6) When handling tag values: do not filter out null or empty string values from T3.Tags.\nOutput columns (ordered): T3.Tags"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH MarkMeckesPosts AS (\n    SELECT Id, Tags\n    FROM posts\n    WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Mark Meckes')\n    AND CommentCount = 0\n)\nSELECT DISTINCT REPLACE(REPLACE(REPLACE(t.value, '<', ''), '>', ''), ' ', '') AS Tag\nFROM MarkMeckesPosts,\n     json_each('[\"' || REPLACE(REPLACE(Tags, '<', '\",\"'), '>', '\",\"') || '\"]') AS t\nWHERE t.value <> '';",
            "SELECT DISTINCT T3.Tags\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T3.Id = T2.PostId\nWHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0 AND T3.Tags IS NOT NULL AND T3.Tags != '';",
            "SELECT T3.Tags\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T3.Id = T2.PostId\nWHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0"
        ],
        "rule_sql": [
            "SELECT T3.Tags \nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T3.Id = T2.PostId\nWHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0"
        ]
    },
    "441": {
        "question": "State the set code of the set with release date of 07/13/2007?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'",
        "amends": [
            "Do select `T2.setCode` from the joined table instead of `code` from the base table. Do add `INNER JOIN set_translations AS T2` with predicate `ON T2.setCode = T1.code` instead of querying only the `sets` table. Do reference the table as `T1` in the `WHERE` clause with `T1.releaseDate` instead of directly using `releaseDate`. The amended query now correctly joins the translation table to retrieve the appropriate set codes while maintaining the same date filter condition, matching the RIGHT_SQL's behavior.",
            "Do use the ISO date format `'2007-07-13'` in the WHERE clause instead of the ambiguous `'07/13/2007'` format to ensure proper date comparison and avoid potential parsing errors across different database systems. The amended query now correctly filters by the specified release date using a standardized date format that matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"set code\" and the schema involves translation tables: select T2.setCode from the joined translation table instead of code from the base table. 2) When joining sets and set_translations tables: use INNER JOIN with predicate T2.setCode = T1.code to link the tables. 3) When filtering by release date in a joined query: reference the base table as T1 and use T1.releaseDate in the WHERE clause. 4) When filtering for a specific date value: use the exact literal '2007-07-13' with the correct date format. 5) Output columns (ordered): T2.setCode",
            "1) When filtering by release date '07/13/2007': use the ISO date format '2007-07-13' instead of '07/13/2007' to ensure proper date comparison and avoid parsing errors across different database systems.\n2) When the question asks for set code of a set with specific release date: filter sets table using the exact ISO date format '2007-07-13' for the releaseDate column.\n3) Output columns (ordered): T2.setCode"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM sets WHERE releaseDate = '2007-07-13';",
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '07/13/2007'",
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'"
        ],
        "rule_sql": [
            "SELECT T2.setCode \nFROM sets T1 \nINNER JOIN set_translations T2 ON T2.setCode = T1.code \nWHERE T1.releaseDate = '2007-07-13'"
        ]
    },
    "363": {
        "question": "How many cards of legalities whose status is restricted are found in a starter deck?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isStarter = 1",
        "amends": [
            "Do use `COUNT(DISTINCT T1.id)` instead of `COUNT(*)` to count distinct card IDs rather than all rows. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of full table names for better readability. Do reference `T2.status = 'Restricted'` instead of `legalities.status = 'restricted'` to match the exact case-sensitive value. Do maintain the same join condition `T1.uuid = T2.uuid` and filter `T1.isStarter = 1` as in the original query. The amended query now correctly counts distinct restricted starter cards with proper case handling and explicit syntax."
        ],
        "rules": [
            "1) When counting cards: use COUNT(DISTINCT T1.id) to count distinct card IDs rather than all rows.\n2) When joining tables: use INNER JOIN explicitly for clarity and specify T1.uuid = T2.uuid as the join condition.\n3) When filtering by legal status: use T2.status = 'Restricted' (exact case-sensitive value) instead of 'restricted'.\n4) When filtering starter cards: use T1.isStarter = 1 to identify cards that are part of starter decks.\n5) When combining cards and legalities tables: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match).\n6) Output columns (ordered): COUNT(DISTINCT T1.id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nJOIN legalities ON cards.uuid = legalities.uuid \nWHERE legalities.status = 'restricted' AND cards.isStarter = 1;",
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1 \nINNER JOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Restricted' \nAND T1.isStarter = 1"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1 \nINNER JOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Restricted' \nAND T1.isStarter = 1"
        ]
    },
    "1518": {
        "question": "For the deal happened at 2012/8/24 12:42:00, which country was it?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Time = '12:42:00'",
        "amends": [],
        "rules": [
            "'2012/8/24 12:42:00' can refer to date = '2012-08-24' AND T1.time = '12:42:00' in the database"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-24' AND t.Time = '12:42:00';"
        ],
        "rule_sql": []
    },
    "1465": {
        "question": "Which budget category does the expense 'Posters' fall to?",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Posters'",
        "amends": [],
        "rules": [
            "'Posters' refers to expense description"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.category\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nWHERE e.expense_description = 'Posters';"
        ],
        "rule_sql": []
    },
    "773": {
        "question": "Which superhero has the same eyes, hair and skin colour? Indicate the publisher of the superhero.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name, T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id",
        "amends": [],
        "rules": [
            "which superhero refers to superhero_name; the same eyes, hair and skin colour refers to hair_colour_id = skin_colour_id AND hair_colour_id = eye_colour_id; publisher refers to publisher_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name, p.publisher_name\nFROM superhero s\nJOIN colour eye ON s.eye_colour_id = eye.id\nJOIN colour hair ON s.hair_colour_id = hair.id\nJOIN colour skin ON s.skin_colour_id = skin.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE eye.id = hair.id AND hair.id = skin.id\nGROUP BY s.superhero_name, p.publisher_name;"
        ],
        "rule_sql": []
    },
    "1077": {
        "question": "What's the long name for the team GEN?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT team_long_name FROM Team WHERE team_short_name = 'GEN'",
        "amends": [],
        "rules": [
            "long name for the team refers to team_long_name; team_short_name = 'GEN';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_long_name FROM Team WHERE team_short_name = 'GEN';"
        ],
        "rule_sql": []
    },
    "505": {
        "question": "Show the Simplified Chinese translation of the name of the set \"Mirrodin\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT code FROM sets WHERE name = 'Mirrodin' ) AND language = 'Chinese Simplified'",
        "amends": [],
        "rules": [
            "Simplified Chinese translation refers to language = 'Chinese Simplified'; name of the set \"Mirrodin\" refers to name = 'Mirrodin'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT st.translation FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE st.language = 'Chinese Simplified' AND s.name = 'Mirrodin';"
        ],
        "rule_sql": []
    },
    "283": {
        "question": "Identify whether the chemical compound that contains Calcium is carcinogenic.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'",
        "amends": [
            "Do use `T2.label AS flag_carcinogenic` instead of `m.molecule_id, m.label` in the SELECT list. Do remove `DISTINCT` instead of keeping it. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do use table aliases `T1` for atom and `T2` for molecule instead of `a` and `m`. Do use `T1.element = 'ca'` instead of `a.element = 'ca'` in the WHERE clause. The amended query now correctly returns only the carcinogenic flag labels without molecule IDs and without unnecessary DISTINCT, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about chemical compounds containing Calcium: filter rows where T1.element equals 'ca' exactly. 2) When combining atom and molecule tables: link rows where T1.molecule_id equals T2.molecule_id and keep only matching pairs (inner match). 3) When the output should indicate carcinogenicity: return only T2.label as flag_carcinogenic without molecule IDs. 4) When the question asks for a simple yes/no flag: do not use DISTINCT since we want to see the carcinogenic status for each matching compound. 5) Output columns (ordered): T2.label AS flag_carcinogenic"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'ca';",
            "SELECT T2.label AS flag_carcinogenic\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'ca'"
        ],
        "rule_sql": [
            "SELECT T2.label AS flag_carcinogenic FROM atom T1 INNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'"
        ]
    },
    "939": {
        "question": "How many drivers from the UN participated in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(*) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T1.nationality = 'British' AND T3.year = 2008",
        "amends": [],
        "rules": [
            "from the UN refers to nationality = 'British'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT d.driverId) AS numberOfBritishDrivers\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE r.year = 2008 AND r.name = 'Australian Grand Prix' AND d.nationality = 'British';"
        ],
        "rule_sql": []
    },
    "952": {
        "question": "Which constructors have been ranked 1?",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.name FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.rank = 1",
        "amends": [
            "Do join `results` instead of `constructorStandings` as the source table. Do use `T1.constructorId = T2.constructorId` instead of `c.constructorId = cs.constructorId` for the join condition. Do filter on `T1.rank = 1` instead of `cs.position = 1` for the winning condition. Do reference `T2.name` instead of `c.name` in the SELECT list while maintaining the DISTINCT modifier. The amended query now correctly identifies constructors with winning race results rather than constructor championship standings."
        ],
        "rules": [
            "1) When the question asks about constructors ranked 1: use the results table (T1) instead of constructorStandings for determining race rankings. 2) When joining constructors and results tables: link rows where T1.constructorId = T2.constructorId to match race results to constructor information. 3) When filtering for winning race results: apply the condition T1.rank = 1 to identify first-place finishes. 4) When selecting constructor names: use T2.name from the constructors table to get the constructor names. 5) When the question asks for distinct constructor names: ensure only unique constructor names are returned in the output. 6) Output columns (ordered): T2.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.name \nFROM constructors c \nJOIN constructorStandings cs ON c.constructorId = cs.constructorId \nWHERE cs.position = 1;",
            "SELECT DISTINCT T2.name \nFROM results T1 \nJOIN constructors T2 ON T1.constructorId = T2.constructorId \nWHERE T1.rank = 1"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.name\nFROM results r\nJOIN constructors c ON r.constructorId = c.constructorId\nWHERE r.rank = 1\nORDER BY c.name;"
        ]
    },
    "1522": {
        "question": "There's one customer spent 214582.17 in the June of 2013, which currency did he/she use?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Currency FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '201306' AND T1.Consumption = 214582.17",
        "amends": [],
        "rules": [
            "June of 2013 means Date contains '201306' in the yearmonth.date of the database"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Currency\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201306' AND ym.Consumption = 214582.17;"
        ],
        "rule_sql": []
    },
    "626": {
        "question": "How many votes were made in 2010?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM votes WHERE STRFTIME('%Y', CreationDate) = '2010'",
        "amends": [],
        "rules": [
            "YEAR(CreationDate) = 2010;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS vote_count FROM votes WHERE strftime('%Y', CreationDate) = '2010';"
        ],
        "rule_sql": []
    },
    "1258": {
        "question": "How many patients with a normal Rhuematoid Factor has a positive measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T3.KCT = '+'",
        "amends": [],
        "rules": [
            "normal Rhuematoid Factor refers TO RA IN('-', '+-'); positive measure of degree of coagulation refers to KCT = '+'; Should compute the number of distinct ones"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nJOIN Laboratory L ON P.ID = L.ID\nWHERE E.KCT = '+' AND L.RA IN ('-', '+-');"
        ],
        "rule_sql": []
    },
    "1027": {
        "question": "Indicate the full names of the top 10 players with the highest number of penalties.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.player_name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.id = t2.id ORDER BY t1.penalties DESC LIMIT 10",
        "amends": [
            "Do join `Player_Attributes AS t1` instead of `Player_Attributes pa` and use `INNER JOIN` instead of `JOIN`. Do reference `t1.id = t2.id` instead of `p.player_api_id = pa.player_api_id` for the join condition. Do select only `t2.player_name` instead of both `p.player_name` and `pa.penalties`. Do order by `t1.penalties` instead of `pa.penalties` while maintaining the `DESC` ordering and `LIMIT 10`. The amended query now correctly retrieves only player names ordered by penalties from the properly joined tables."
        ],
        "rules": [
            "1) When the question asks for \"top 10 players with the highest number of penalties\": rank rows by t1.penalties in descending order and keep the first 10 rows.\n2) When combining Player_Attributes as t1 and Player as t2: link rows where t1.id = t2.id exactly as shown; keep only matching pairs (inner match).\n3) When selecting output columns: include only t2.player_name from the result set.\n4) When ordering results: sort by t1.penalties in descending direction.\n5) Output columns (ordered): t2.player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.penalties\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY pa.penalties DESC\nLIMIT 10;",
            "SELECT t2.player_name\nFROM Player_Attributes AS t1\nINNER JOIN Player AS t2 ON t1.id = t2.id\nORDER BY t1.penalties DESC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT t2.player_name\nFROM Player_Attributes t1\nINNER JOIN Player t2 ON t1.id = t2.id\nORDER BY t1.penalties DESC\nLIMIT 10"
        ]
    },
    "1295": {
        "question": "Among the patients whose total bilirubin is over the normal range, how many of them have a peripheral pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` >= 2 AND T3.`ANA Pattern` LIKE '%P%'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT p.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `l`, and `e` for consistent naming. Do remove the `AS PatientCount` alias instead of keeping it since the column name is not needed. Do use integer comparison `T2.\"T-BIL\" >= 2` instead of `l.\"T-BIL\" >= 2.0` to match the data type. The amended query now correctly counts all patient records meeting the laboratory and examination criteria without unnecessary distinct counting.",
            "Do use `LIKE '%P%'` for pattern matching on `ANA Pattern` instead of exact equality `= 'peripheral'` to capture all patterns containing 'P' rather than only the specific 'peripheral' value. The amended query now correctly matches the RIGHT_SQL's behavior with the appropriate pattern matching logic."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs.\n2) When joining tables: use INNER JOIN explicitly for clarity between T1, T2, and T3.\n3) When referring to tables: use aliases T1 for Patient, T2 for Laboratory, and T3 for Examination instead of p, l, and e.\n4) When outputting results: do not include column aliases like AS PatientCount since the column name is not needed.\n5) When comparing total bilirubin values: use integer comparison T2.\"T-BIL\" >= 2 instead of floating-point comparison to match the data type.\n6) When filtering for peripheral pattern: use exact string matching for T3.\"ANA Pattern\" containing 'P' pattern.\n7) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using inner match.\n8) When combining Patient and Examination tables: link rows where T1.ID = T3.ID using inner match.\n9) Output columns (ordered): COUNT(T1.ID)",
            "1) When the question asks about patients with total bilirubin over normal range: filter rows where T2.\"T-BIL\" >= 2.\n2) When the question asks about peripheral pattern in ANA examination: filter rows where T3.\"ANA Pattern\" LIKE '%P%' to capture patterns containing 'P'.\n3) When counting patients: count using the canonical key T1.ID.\n4) When combining Patient, Laboratory, and Examination tables: link rows where T1.ID = T2.ID and T1.ID = T3.ID; keep only matching pairs (inner match).\n5) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.ID) AS PatientCount\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.`T-BIL` >= 2.0 AND e.`ANA Pattern` LIKE '%P%';",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" >= 2\nAND T3.\"ANA Pattern\" = 'peripheral'",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" >= 2\nAND T3.\"ANA Pattern\" LIKE '%P%'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" >= 2\nAND T3.\"ANA Pattern\" LIKE '%P%'"
        ]
    },
    "534": {
        "question": "What is the display name of the user who has the most number of views?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "amends": [],
        "rules": [
            "user who has the most number of view refers to Max(Views)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DisplayName FROM users ORDER BY Views DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "590": {
        "question": "Which user ID has the lowest view?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Id FROM users WHERE Views = ( SELECT MIN(Views) FROM users )",
        "amends": [],
        "rules": [
            "lowest views refers to Min(Views)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Id FROM users WHERE Views = (SELECT MIN(Views) FROM users);"
        ],
        "rule_sql": []
    },
    "364": {
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "amends": [],
        "rules": [
            "Cloudchaser Eagle is the name of card;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.status FROM legalities l JOIN cards c ON l.uuid = c.uuid WHERE c.name = 'Cloudchaser Eagle';"
        ],
        "rule_sql": []
    },
    "609": {
        "question": "How many posts have a score of 10 on the list?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score = 10",
        "amends": [],
        "rules": [
            "score of 10 refers to Score = 10; post refers to Id"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE Score = 10;"
        ],
        "rule_sql": []
    },
    "853": {
        "question": "Please give the names of the races held on the circuits in Spain.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "amends": [],
        "rules": [
            "Spain is a name of country;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.country = 'Spain';"
        ],
        "rule_sql": []
    },
    "930": {
        "question": "In which Formula_1 race did Lewis Hamilton rank the highest?",
        "db_id": "formula_1",
        "ground_truth": "SELECT name FROM races WHERE raceId IN ( SELECT raceId FROM results WHERE rank = 1 AND driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) )",
        "amends": [
            "Do select only `name` instead of multiple columns including `race_name`, `rank`, `positionText`, and `points`. Do use a subquery in the `WHERE` clause with `raceId IN` instead of joining directly to `races` and `drivers`. Do filter for `rank = 1` in the subquery instead of ordering by `rank ASC` with `LIMIT 1`. Do use a nested subquery to get the `driverId` from `drivers` with the name conditions instead of joining to the `drivers` table. Do remove the explicit `ORDER BY` and `LIMIT` clauses instead of keeping them, as the `rank = 1` filter achieves the same result. The amended query now correctly identifies races where Lewis Hamilton achieved first place by using proper subquery filtering instead of join-based ranking."
        ],
        "rules": [
            "1) When the question asks for races where a specific driver achieved their highest rank: use a subquery to filter for races where the driver's rank equals 1 instead of ordering and limiting results.\n2) When identifying a driver by first and last name: use nested subqueries to get the driverId from the drivers table with conditions forename = 'Lewis' AND surname = 'Hamilton'.\n3) When filtering races by driver performance: use raceId IN with a subquery that finds races where the driver achieved rank = 1.\n4) When selecting output for race identification: include only the race name column from the races table.\n5) When combining driver and race information: do not perform direct joins but use subquery filtering with raceId IN instead of table joins.\n6) When the question implies finding the highest rank achievement: filter for rank = 1 rather than using ordering and limit operations.\nOutput columns (ordered): r.name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT r.name AS race_name, rs.rank, rs.positionText, rs.points\nFROM results rs\nJOIN races r ON rs.raceId = r.raceId\nJOIN drivers d ON rs.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nORDER BY rs.rank ASC\nLIMIT 1;",
            "SELECT name FROM races WHERE raceId IN (SELECT raceId FROM results WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') AND rank = 1);"
        ],
        "rule_sql": [
            "SELECT r.name\nFROM races r\nWHERE r.raceId IN (\n    SELECT raceId\n    FROM results\n    WHERE driverId = (\n        SELECT driverId\n        FROM drivers\n        WHERE forename = 'Lewis' AND surname = 'Hamilton'\n    )\n    AND position = 1\n);"
        ]
    },
    "1493": {
        "question": "In February 2012, what percentage of customers consumed more than 528.3?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'",
        "amends": [
            "Do use `SUM(IIF(Consumption > 528.3, 1, 0))` instead of `COUNT(CASE WHEN Consumption > 528.3 THEN 1 END)` for conditional counting. Do remove `DISTINCT` from `COUNT(CustomerID)` instead of keeping it to count all customers rather than distinct ones. Do use explicit `CAST(... AS FLOAT)` instead of implicit conversion with `100.0` for proper floating-point division. Do remove `ROUND(..., 2)` instead of keeping it to return the raw percentage value without rounding. Do omit the `AS Percentage` alias instead of including it. The amended query now correctly calculates the percentage of customers with consumption exceeding 528.3 without unnecessary rounding or distinct counting.",
            "Do use `Date = '201202'` instead of `Date LIKE '2012-02%'` for exact date matching. Do place the multiplication by 100 after the SUM operation instead of after the division to correctly calculate the percentage as (sum/count)*100 rather than sum/(count*100)."
        ],
        "rules": [
            "1) When counting customers who meet a consumption condition: use SUM(IIF(Consumption > 528.3, 1, 0)) instead of COUNT(CASE WHEN Consumption > 528.3 THEN 1 END) for conditional counting.\n2) When counting total customers: use COUNT(CustomerID) without DISTINCT to count all customers rather than distinct ones.\n3) When performing percentage calculations: use explicit CAST(... AS FLOAT) instead of implicit conversion with 100.0 for proper floating-point division.\n4) When the question asks for a percentage without rounding specification: return the raw percentage value without ROUND() function.\n5) When the output is a single calculated value: omit the AS alias specification.\n6) When filtering by date with format 'YYYYMM': use Date = '201202' for February 2012.\nOutput columns (ordered): the calculated percentage value",
            "1) When the question asks for a specific month and year like \"February 2012\": use the exact date format '201202' for matching. 2) When calculating a percentage of customers meeting a condition: compute (number of customers meeting the condition divided by total customers) multiplied by 100. 3) When filtering for customers who consumed more than a specific value like 528.3: use the exact comparison Consumption > 528.3. 4) When counting customers: use CustomerID as the counting key. 5) Output columns (ordered): the calculated percentage value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    ROUND(\n        (COUNT(CASE WHEN Consumption > 528.3 THEN 1 END) * 100.0 / COUNT(DISTINCT CustomerID)),\n        2\n    ) AS Percentage\nFROM \n    yearmonth\nWHERE \n    Date = '201202';",
            "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) / COUNT(CustomerID) * 100 FROM yearmonth WHERE Date LIKE '2012-02%';",
            "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) * 100 AS FLOAT) / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) / COUNT(CustomerID) * 100 FROM yearmonth WHERE Date = '201202'"
        ]
    },
    "644": {
        "question": "Provide the last edit date and last edit user ID for the post \"Detecting a given face in a database of facial images\".",
        "db_id": "codebase_community",
        "ground_truth": "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images'",
        "amends": [],
        "rules": [
            "Title = 'Detecting a given face in a database of facial images';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images';"
        ],
        "rule_sql": []
    },
    "474": {
        "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 100?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 100 AND T2.language = 'Italian'",
        "amends": [],
        "rules": [
            "Italian translation refers to language = 'Italian'; have a translation means translation is not null; base set number of under 100 refers to baseSetSize < 10"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT s.code)\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Italian' AND s.baseSetSize < 100;"
        ],
        "rule_sql": []
    },
    "1267": {
        "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
        "amends": [
            "Do join `Laboratory AS T2` instead of `Patient P` and use `INNER JOIN` instead of `JOIN`. Do reference `T2.SM` instead of `E.SM` and check for values `('negative','0')` instead of `('-', '+-')`. Do remove `DISTINCT` from the count instead of keeping it and count `T1.ID` instead of `E.ID`. Do reference `T1.Thrombosis` instead of `E.Thrombosis` while keeping the same filter condition. The amended query now correctly counts examinations with specific laboratory results instead of patient joins."
        ],
        "rules": [
            "1) When the question asks about patients with normal anti-SM: filter Laboratory T2.SM to values ('negative','0') exactly as specified. 2) When counting patients without thrombosis: count T1.ID (not distinct) where T1.Thrombosis equals 0. 3) When combining Examination and Laboratory tables: use inner join where T1.ID equals T2.ID to match examination records with laboratory results. 4) When handling text literals: preserve exact case and punctuation for 'negative' and '0' values. 5) Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT E.ID) \nFROM Examination E\nJOIN Patient P ON E.ID = P.ID\nWHERE (E.SM IN('-', '+-')) AND E.Thrombosis = 0;",
            "SELECT COUNT(T1.ID)\nFROM Examination T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.SM IN ('negative', '0')\nAND T1.Thrombosis = 0;"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Examination T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.SM IN ('negative', '0') \nAND T1.Thrombosis = 0"
        ]
    },
    "1070": {
        "question": "Which country is the league Italy Serie A from?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Italy Serie A'",
        "amends": [],
        "rules": [
            "Italy Serie A from refers to League.name = 'Italy Serie A';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name AS country_name\nFROM League l\nJOIN Country c ON l.country_id = c.id\nWHERE l.name = 'Italy Serie A';"
        ],
        "rule_sql": []
    },
    "433": {
        "question": "What is the percentage of the set of cards that have Chinese Simplified as the language and are only available for online games?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode",
        "amends": [
            "Do use `sets` and `set_translations` tables instead of `cards` and `foreign_data` tables. Do join with `INNER JOIN` on `T1.code = T2.setCode` instead of multiple CTEs with `LEFT JOIN` on `uuid`. Do calculate percentage using `SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END)` divided by `COUNT(*)` instead of counting distinct UUIDs from separate CTEs. Do remove the `DISTINCT` operations and CTE structure instead of maintaining complex subqueries. Do cast the result as `REAL` instead of using `* 100.0` with division. The amended query now correctly calculates the percentage of Chinese Simplified online-only sets by directly joining the relevant tables with proper filtering conditions."
        ],
        "rules": [
            "1) When the question asks for percentage of sets with specific language and availability: use tables \"sets\" as T1 and \"set_translations\" as T2 instead of \"cards\" and \"foreign_data\".\n2) When combining T1 and T2 for shared entities: link rows where T1.code = T2.setCode using inner join and keep only matching pairs.\n3) When filtering for Chinese Simplified language: use exact literal 'Chinese Simplified' with T2.language.\n4) When filtering for online-only availability: use T1.isOnlineOnly = 1.\n5) When calculating percentage: compute (SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) divided by COUNT(*)) and cast as REAL.\n6) When handling division: guard against division by zero by ensuring denominator is not zero.\n7) Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH chinese_cards AS (\n    SELECT DISTINCT c.uuid\n    FROM cards c\n    JOIN foreign_data fd ON c.uuid = fd.uuid\n    WHERE fd.language = 'Chinese Simplified'\n),\nonline_chinese_cards AS (\n    SELECT uuid\n    FROM cards\n    WHERE uuid IN (SELECT uuid FROM chinese_cards) AND isOnlineOnly = 1\n)\nSELECT \n    (COUNT(DISTINCT online_chinese_cards.uuid) * 100.0 / \n    NULLIF(COUNT(DISTINCT chinese_cards.uuid), 0) AS percentage\nFROM chinese_cards\nLEFT JOIN online_chinese_cards ON chinese_cards.uuid = online_chinese_cards.uuid;",
            "SELECT \n    CAST(SUM(CASE WHEN st.language = 'Chinese Simplified' AND s.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100.0 AS percentage\nFROM \n    sets s\nINNER JOIN \n    set_translations st ON s.code = st.setCode;"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100 AS percentage\nFROM \n    sets AS T1\nINNER JOIN \n    set_translations AS T2 ON T1.code = T2.setCode\nWHERE \n    COUNT(*) > 0"
        ]
    },
    "1382": {
        "question": "Among the students majored in interior design, who have attended the Community Theater event?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id WHERE T4.event_name = 'Community Theater' AND T1.major_name = 'Interior Design'",
        "amends": [],
        "rules": [
            "majored in music refers to major_name = 'Interior Design'; 'Community Theater' is the event name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE maj.major_name = 'Interior Design' AND e.event_name = 'Community Theater';"
        ],
        "rule_sql": []
    },
    "1016": {
        "question": "In the race a driver set the lap record for the Austrian Grand Prix Circuit, how long did he spent at the pit stop at that same race?",
        "db_id": "formula_1",
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.driverId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL), lap_record_race AS ( SELECT T1.raceId, T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix') SELECT T4.duration FROM lap_record_race INNER JOIN pitStops AS T4 on lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId",
        "amends": [
            "Do add proper time conversion with `CAST` and string functions instead of directly comparing `fastestLapTime` strings. Do join `circuits` directly in the main logic instead of using a separate CTE for circuit lookup. Do move the circuit filter to `WHERE T2.name = 'Austrian Grand Prix'` instead of filtering by circuit name in a subquery. Do add explicit `INNER JOIN` syntax instead of implicit joins. Do restructure the fastest lap calculation to convert times to seconds and compare numerically instead of using `MIN()` on raw string values. Do include proper NULL handling with `WHERE T1.FastestLapTime IS NOT NULL` instead of assuming all records have lap times. Do add table aliases `T1`, `T2`, `T3`, `T4` for clarity instead of using unaliased table names. The amended query now correctly handles time conversion and comparison to find the actual fastest lap times at the Austrian Grand Prix.",
            "Do use a CTE structure with `fastest_lap_times` and `lap_record_race` instead of a subquery in the WHERE clause. Do calculate time conversion using `INSTR` for position-based substring extraction instead of fixed character positions. Do add proper decimal handling with `/ 1000` for milliseconds instead of direct `CAST` to `REAL`. Do restructure the query to first identify lap record races in a CTE instead of filtering pit stops directly. Do remove the redundant `circuits` table join from the main query since it's only needed for filtering Austrian Grand Prix races. Do maintain the same `INNER JOIN` logic between `results` and `races` but move the circuit filtering to the subquery. The amended query now correctly handles time conversion with proper string parsing and uses a more efficient CTE structure that matches the RIGHT_SQL's behavior.",
            "Do include milliseconds in the time conversion by adding `+ (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000)` instead of omitting them. Do change the `lap_record_race` CTE to select only `raceId` and `driverId` instead of including `MIN(flt.fastest_lap_seconds)`. Do restructure the `lap_record_race` CTE to use a subquery that finds the minimum lap time for Austrian Grand Prix races instead of grouping by race and driver. Do add a join condition that matches drivers who achieved the exact minimum lap time instead of joining on race and driver IDs alone. Do filter for `T2.name = 'Austrian Grand Prix'` in the main query instead of `c.name = 'Austrian Grand Prix'` in the CTE. Do remove the unnecessary `WHERE ps.raceId IN (SELECT raceId FROM lap_record_race)` filter instead of keeping it. Do select only `T4.duration` instead of converting pit stop times to seconds. The amended query now correctly identifies drivers who set the absolute fastest lap time at Austrian Grand Prix races and retrieves their pit stop durations.",
            "Do add `T1.FastestLapTime` to the SELECT list in the first CTE instead of omitting it, and rename the calculated column to `time_in_seconds` instead of `fastest_lap_seconds`. Do remove the `INNER JOIN races T2` and `WHERE T2.name = 'Austrian Grand Prix'` from the first CTE instead of including them, moving the race name filter to later processing. Do completely restructure the second CTE instead of the simple subquery approach, adding joins to `circuits AS T3` on `T2.circuitId = T3.circuitId` and creating a subquery to find the minimum lap time for Austrian Grand Prix races. Do change the correlation condition to compare the calculated lap time against the minimum time from the subquery instead of using a correlated subquery with `raceId = flt.raceId`. Do reverse the join direction in the final query to `INNER JOIN pitStops AS T4 on lap_record_race.raceId = T4.raceId` instead of starting from `pitStops T4` and joining to the CTE. The amended query now correctly identifies the fastest lap times specifically for Austrian Grand Prix races and properly joins to find the corresponding pit stop durations.",
            "Do use `CAST(... AS REAL)` for the minute component instead of `CAST(... AS INTEGER)` in the time conversion calculation. Do reference the base `results` table directly in the second CTE instead of using the `fastest_lap_times` CTE. Do change the WHERE filter to use `T2.name = 'Austrian Grand Prix'` instead of `T3.name = 'Austrian Grand Prix'` to correctly filter by race name rather than circuit name. Do restructure the subquery to calculate the minimum time as a separate derived table `T4` with `min_time_in_seconds` instead of using a correlated subquery. Do add an INNER JOIN condition comparing the calculated lap time directly to `T4.min_time_in_seconds` instead of using a WHERE clause with equality comparison. The amended query now correctly identifies races by name rather than circuit name and properly handles the time comparison logic to match the RIGHT_SQL's behavior.",
            "Do use `results` table directly in the second CTE instead of referencing `fastest_lap_times` CTE. Do change the WHERE filter to use `T2.name = 'Austrian Grand Prix'` instead of `T3.name = 'Austrian Grand Prix'` in both the subquery and main query. Do recalculate the lap time conversion expression in the JOIN condition instead of using the precomputed `time_in_seconds` from the CTE. Do remove the redundant `T1.raceId` grouping in the subquery since only the minimum time is needed. The amended query now correctly identifies races by name rather than circuit name and ensures proper time comparison by recalculating the lap time expression directly against the minimum value.",
            "Do add the `fastest_lap_times` CTE with proper time conversion instead of omitting it, and do use `INNER JOIN` on `races` and `circuits` with filter `T2.name = 'Austrian Grand Prix'` instead of missing these joins and filters. Do add a subquery to find `MIN(fastest_lap_times.time_in_seconds)` instead of not calculating the minimum lap time, and do join using the converted time comparison `time_in_seconds = T4.min_time_in_seconds` instead of missing this critical join condition. Do change the final query to select `T4.duration` from `pitStops` instead of selecting incorrect columns, and do add the necessary join conditions `lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId` instead of omitting them. The amended query now correctly identifies pit stop durations for drivers who set the fastest lap record in the Austrian Grand Prix.",
            "Do add a CTE `fastest_lap_times` to calculate `time_in_seconds` from `FastestLapTime` instead of omitting this conversion. Do use proper join conditions with `T1.raceId = T2.raceId` and `T2.circuitId = T3.circuitId` instead of incorrect join predicates. Do filter for `T2.name = 'Austrian Grand Prix'` in both the subquery and main query instead of missing this condition. Do compare the converted lap time against the minimum time using the calculated `time_in_seconds` instead of comparing raw string values. Do join `pitStops` with both `raceId` and `driverId` conditions instead of incomplete join criteria. The amended query now correctly identifies pit stop durations for drivers who set the fastest lap record at the Austrian Grand Prix."
        ],
        "rules": [
            "1) When the question mentions \"Austrian Grand Prix Circuit\": filter circuits where T2.name = 'Austrian Grand Prix' exactly as written.\n2) When finding the fastest lap record: convert T1.FastestLapTime to seconds for numerical comparison instead of string comparison, and exclude null values with T1.FastestLapTime IS NOT NULL.\n3) When combining tables for race information: link T1 (results) and T2 (circuits) through T3 (races) using T1.raceId = T3.raceId and T3.circuitId = T2.circuitId with inner joins.\n4) When identifying the driver who set the lap record: find the minimum converted lap time value for the specific race at the Austrian Grand Prix circuit.\n5) When retrieving pit stop duration: join T4 (pitStops) with the lap record driver using T4.raceId = T1.raceId and T4.driverId = T1.driverId to get matching records.\n6) When handling time-based comparisons: use proper time conversion functions instead of direct string operations on time values.\n7) Output columns (ordered): T4.duration",
            "1) When identifying lap records for a specific Grand Prix circuit: first find all races with the exact name 'Austrian Grand Prix' and calculate the fastest lap time for each race using proper time conversion with milliseconds handling (/1000). 2) When determining the lap record holder: identify the driver with the minimum converted lap time among all results for Austrian Grand Prix races. 3) When retrieving pit stop information for a specific driver and race: join pitStops table using both raceId and driverId to match the exact race and driver combination. 4) When handling time conversion from string format: use position-based substring extraction with INSTR instead of fixed character positions to properly parse lap time strings. 5) When structuring complex queries with multiple filtering conditions: use CTE structures to first identify relevant races and lap records before joining with additional tables like pitStops. 6) When filtering for specific circuit races: remove redundant table joins and filter directly on the race name 'Austrian Grand Prix' in the relevant subquery. 7) Output columns (ordered): T4.duration",
            "1) When the question asks about the Austrian Grand Prix Circuit: filter for T2.name = 'Austrian Grand Prix' exactly as written. 2) When converting time formats with milliseconds: include milliseconds by adding + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) to the time conversion. 3) When finding the absolute fastest lap time: use a subquery to find the minimum lap time for the specified circuit instead of grouping by race and driver. 4) When identifying drivers who set the lap record: match drivers who achieved the exact minimum lap time value instead of just joining on race and driver IDs. 5) When retrieving pit stop information: select only T4.duration without converting to seconds. 6) When combining tables for race information: link T1 and T2 where T1.raceId = T2.raceId and keep only matching pairs. 7) When combining tables for circuit information: link T2 and T3 where T2.circuitId = T3.circuitId and keep only matching pairs. 8) When combining tables for pit stop information: link T1 and T4 where T1.raceId = T4.raceId and T1.driverId = T4.driverId and keep only matching pairs. 9) Output columns (ordered): T4.duration",
            "1) When the question asks about the Austrian Grand Prix Circuit: filter races to those with name exactly \"Austrian Grand Prix\" using T2.name = 'Austrian Grand Prix'.\n2) When calculating fastest lap times from T1.FastestLapTime: convert the time format to seconds by extracting minutes, seconds, and milliseconds components and combining them into a numerical value.\n3) When finding the lap record for a specific circuit: identify the minimum lap time value among all races at that circuit rather than per individual race.\n4) When joining tables for circuit information: link races T2 to circuits T3 using T2.circuitId = T3.circuitId to access circuit details.\n5) When retrieving pit stop information for a specific driver and race: join pitStops T4 to the results using both T4.raceId and T4.driverId matching the identified race and driver.\n6) When the question asks for pit stop duration: output the T4.duration column from the pitStops table.\n7) Output columns (ordered): T4.duration",
            "1) When converting time strings with colon and decimal separators: convert the minute component using CAST(... AS REAL) instead of CAST(... AS INTEGER) for proper time calculation.\n2) When filtering for races at a specific circuit: use T2.name = 'Austrian Grand Prix' to filter by race name rather than circuit name.\n3) When calculating minimum lap times for a circuit: create a separate derived table T4 with min_time_in_seconds instead of using a correlated subquery.\n4) When comparing lap times to find the record: use INNER JOIN condition comparing the calculated lap time directly to T4.min_time_in_seconds instead of WHERE clause equality comparison.\n5) When working with the base results table: reference it directly in CTEs instead of using intermediate CTE references.\n6) When combining tables for race and circuit information: use the exact join conditions shown in the schema (T1.raceId = T2.raceId and T2.circuitId = T3.circuitId).\n7) When handling time duration data: preserve the exact format and precision as stored in the pitStops.duration column.\nOutput columns (ordered): T4.duration",
            "1) When the question asks about a driver setting the lap record for a specific race: identify the race using the exact literal 'Austrian Grand Prix' from the races table name column (T2.name = 'Austrian Grand Prix').\n2) When finding the fastest lap time: convert the FastestLapTime from results table using the exact conversion expression that extracts minutes, seconds, and milliseconds components.\n3) When determining the minimum lap time for a race: compute the minimum converted lap time value across all drivers for races named 'Austrian Grand Prix'.\n4) When matching the lap record driver: find the driver whose converted lap time equals the minimum lap time for that race.\n5) When retrieving pit stop duration: join the pitStops table using both raceId and driverId from the identified lap record driver to get the exact pit stop duration.\n6) When combining tables for race identification: use races table (T2) directly with name filter instead of circuits table for identifying 'Austrian Grand Prix' races.\n7) When performing time comparisons: recalculate the lap time conversion expression directly in join conditions rather than using precomputed values.\nOutput columns (ordered): T4.duration",
            "1) When the question mentions a specific circuit name \"Austrian Grand Prix\": filter T2.name to exactly match \"Austrian Grand Prix\" with exact case and spacing.\n2) When finding the lap record for a circuit: calculate the minimum time_in_seconds from fastest_lap_times for that circuit.\n3) When joining tables for race and circuit information: use INNER JOIN between races and circuits tables with proper join conditions.\n4) When identifying the driver who set the fastest lap record: join using the converted time comparison time_in_seconds = T4.min_time_in_seconds.\n5) When retrieving pit stop information for the record-setting driver: join pitStops using both raceId and driverId conditions (lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId).\n6) When selecting the final output: choose T4.duration from the pitStops table.\n7) When handling time conversion: properly convert lap times to seconds in the fastest_lap_times CTE.\nOutput columns (ordered): T4.duration",
            "1) When the question mentions a specific race circuit like \"Austrian Grand Prix\": filter for T2.name = 'Austrian Grand Prix' in both subqueries and main queries.\n2) When calculating lap times from string values like \"FastestLapTime\": convert the time string to numeric seconds using proper time conversion instead of comparing raw string values.\n3) When combining tables for race information: link rows using T1.raceId = T2.raceId and T2.circuitId = T3.circuitId with exact equality conditions.\n4) When joining pit stop data with race results: use both raceId and driverId conditions (T1.raceId = T4.raceId and T1.driverId = T4.driverId) for complete join criteria.\n5) When identifying fastest lap records: compare converted lap times against the minimum time using the calculated time_in_seconds value.\n6) When the question asks for pit stop duration at a specific race: extract the pit stop duration information from the pitStops table for the identified driver and race.\nOutput columns (ordered): T4.duration"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH austrian_circuit AS (\n    SELECT circuitId FROM circuits WHERE name = 'Austrian Grand Prix'\n),\nrace_at_austria AS (\n    SELECT raceId FROM races WHERE circuitId = (SELECT circuitId FROM austrian_circuit)\n),\nlap_record_driver AS (\n    SELECT r.driverId, r.raceId\n    FROM results r\n    JOIN race_at_austria ra ON r.raceId = ra.raceId\n    WHERE r.fastestLapTime = (SELECT MIN(fastestLapTime) FROM results WHERE raceId = ra.raceId)\nSELECT ps.duration\nFROM pitStops ps\nJOIN lap_record_driver lrd ON ps.raceId = lrd.raceId AND ps.driverId = lrd.driverId;",
            "SELECT T4.duration\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nINNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\nINNER JOIN pitStops T4 ON T1.raceId = T4.raceId AND T1.driverId = T4.driverId\nWHERE T2.name = 'Austrian Grand Prix'\nAND T1.fastestLapTime IS NOT NULL\nAND CAST(SUBSTR(T1.fastestLapTime, 1, 2) AS INTEGER) * 60 + \n    CAST(SUBSTR(T1.fastestLapTime, 4, 2) AS INTEGER) + \n    CAST(SUBSTR(T1.fastestLapTime, 7) AS REAL) = (\n    SELECT MIN(CAST(SUBSTR(r.fastestLapTime, 1, 2) AS INTEGER) * 60 + \n           CAST(SUBSTR(r.fastestLapTime, 4, 2) AS INTEGER) + \n           CAST(SUBSTR(r.fastestLapTime, 7) AS REAL))\n    FROM results r\n    INNER JOIN races ra ON r.raceId = ra.raceId\n    WHERE ra.name = 'Austrian Grand Prix'\n    AND r.fastestLapTime IS NOT NULL\n)",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.driverId,\n        CAST(SUBSTR(r.fastestLapTime, 1, INSTR(r.fastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(r.fastestLapTime, INSTR(r.fastestLapTime, ':') + 1) AS REAL) AS fastest_lap_seconds\n    FROM results r\n    WHERE r.fastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        r.raceId,\n        r.driverId,\n        MIN(flt.fastest_lap_seconds) AS min_fastest_lap_seconds\n    FROM results r\n    INNER JOIN races rc ON r.raceId = rc.raceId\n    INNER JOIN circuits c ON rc.circuitId = c.circuitId\n    INNER JOIN fastest_lap_times flt ON r.raceId = flt.raceId AND r.driverId = flt.driverId\n    WHERE c.name = 'Austrian Grand Prix'\n    GROUP BY r.raceId, r.driverId\n)\nSELECT \n    CAST(SUBSTR(ps.duration, 1, INSTR(ps.duration, ':') - 1) AS REAL) * 60 +\n    CAST(SUBSTR(ps.duration, INSTR(ps.duration, ':') + 1) AS REAL) AS pit_stop_seconds\nFROM pitStops ps\nINNER JOIN lap_record_race lrr ON ps.raceId = lrr.raceId AND ps.driverId = lrr.driverId\nWHERE ps.raceId IN (SELECT raceId FROM lap_record_race);",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.driverId,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000 AS fastest_lap_seconds\n    FROM results T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T1.FastestLapTime IS NOT NULL\n    AND T2.name = 'Austrian Grand Prix'\n),\nlap_record_race AS (\n    SELECT \n        flt.raceId,\n        flt.driverId\n    FROM fastest_lap_times flt\n    WHERE flt.fastest_lap_seconds = (\n        SELECT MIN(fastest_lap_seconds) \n        FROM fastest_lap_times \n        WHERE raceId = flt.raceId\n    )\n)\nSELECT T4.duration\nFROM pitStops T4\nINNER JOIN lap_record_race lrr ON T4.raceId = lrr.raceId AND T4.driverId = lrr.driverId;",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.driverId,\n        T1.FastestLapTime,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS INTEGER) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) AS time_in_seconds\n    FROM results T1\n    WHERE T1.FastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        flt.raceId,\n        flt.driverId\n    FROM fastest_lap_times flt\n    INNER JOIN races T2 ON flt.raceId = T2.raceId\n    INNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\n    WHERE T3.name = 'Austrian Grand Prix'\n    AND flt.time_in_seconds = (\n        SELECT MIN(flt2.time_in_seconds)\n        FROM fastest_lap_times flt2\n        INNER JOIN races r2 ON flt2.raceId = r2.raceId\n        INNER JOIN circuits c2 ON r2.circuitId = c2.circuitId\n        WHERE c2.name = 'Austrian Grand Prix'\n    )\n)\nSELECT T4.duration\nFROM lap_record_race\nINNER JOIN pitStops T4 ON lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId;",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.driverId,\n        T1.FastestLapTime,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results T1\n    WHERE T1.FastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        T1.raceId,\n        T1.driverId\n    FROM fastest_lap_times T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    INNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\n    INNER JOIN (\n        SELECT \n            T2.raceId,\n            MIN(flt.time_in_seconds) AS min_time_in_seconds\n        FROM fastest_lap_times flt\n        INNER JOIN races T2 ON flt.raceId = T2.raceId\n        INNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\n        WHERE T3.name = 'Austrian Grand Prix'\n        GROUP BY T2.raceId\n    ) T4 ON T1.raceId = T4.raceId AND T1.time_in_seconds = T4.min_time_in_seconds\n    WHERE T3.name = 'Austrian Grand Prix'\n)\nSELECT T4.duration\nFROM lap_record_race\nINNER JOIN pitStops T4 ON lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId;",
            "error",
            "error",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.driverId,\n        T1.FastestLapTime,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results T1\n    WHERE T1.FastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        T1.raceId,\n        T1.driverId\n    FROM fastest_lap_times T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    INNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\n    WHERE T2.name = 'Austrian Grand Prix'\n    AND T1.time_in_seconds = (\n        SELECT MIN(time_in_seconds)\n        FROM fastest_lap_times flt\n        INNER JOIN races r ON flt.raceId = r.raceId\n        WHERE r.name = 'Austrian Grand Prix'\n    )\n)\nSELECT T4.duration\nFROM lap_record_race\nINNER JOIN pitStops T4 ON lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId;"
        ],
        "rule_sql": [
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.driverId,\n        CAST(SUBSTR(res.fastestLapTime, 1, INSTR(res.fastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, ':') + 1, INSTR(res.fastestLapTime, '.') - INSTR(res.fastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results res\n    JOIN races r ON res.raceId = r.raceId\n    WHERE r.name = 'Austrian Grand Prix'\n    AND res.fastestLapTime IS NOT NULL\n),\nmin_lap_time AS (\n    SELECT MIN(time_in_seconds) AS min_time_in_seconds\n    FROM fastest_lap_times\n)\nSELECT ps.duration\nFROM fastest_lap_times flt\nJOIN min_lap_time mlt ON flt.time_in_seconds = mlt.min_time_in_seconds\nJOIN pitStops ps ON flt.raceId = ps.raceId AND flt.driverId = ps.driverId;"
        ]
    },
    "315": {
        "question": "Among the molecules which contain \"cl\" element, which of them are carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'cl' AND T2.label = '+'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `a` and `m`. Do select only `T1.molecule_id` instead of both `m.molecule_id` and `m.label`. Do use `INNER JOIN` instead of `JOIN` (though they are equivalent). Do reference `T1.element` directly instead of applying `LOWER()` function to `a.element`. Do remove the `DISTINCT` keyword instead of keeping it. Do reference `T2.label` instead of `m.label`. The amended query now correctly filters for chlorine atoms without case conversion and returns only molecule IDs from matching molecules with the '+' label."
        ],
        "rules": [
            "1) When the question asks for molecules containing \"cl\" element: filter rows where T1.element equals 'cl' exactly (case-sensitive). 2) When the question asks for carcinogenic molecules: filter rows where T2.label equals '+' exactly. 3) When combining T1 and T2 for shared molecules: link rows where T1.molecule_id equals T2.molecule_id exactly; keep only matching pairs (inner match). 4) When selecting output columns: return only T1.molecule_id. 5) When handling text literals: do not change case, spacing, or punctuation of 'cl' or '+'. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 7) When referring to table roles: do not rename or swap the aliases T1 and T2 once set for this schema. Output columns (ordered): T1.molecule_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE LOWER(a.element) = 'cl' AND m.label = '+';",
            "SELECT T1.molecule_id\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'cl' AND T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT T1.molecule_id\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'cl' AND T2.label = '+'"
        ]
    },
    "130": {
        "question": "How many of the account holders in South Bohemia still do not own credit cards?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T3.account_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.client_id = T3.client_id WHERE T1.A3 = 'south Bohemia' AND T3.type != 'OWNER'",
        "amends": [
            "Do count `T3.account_id` instead of `COUNT(DISTINCT c.client_id)` as `account_holders_without_credit_cards`. Do join `district AS T1` with `client AS T2` on `T1.district_id = T2.district_id` instead of joining district with account first. Do join `client AS T2` with `disp AS T3` on `T2.client_id = T3.client_id` instead of joining account with disp. Do remove the `LEFT JOIN card` table and `cd.card_id IS NULL` condition entirely instead of including them. Do filter with `T3.type != 'OWNER'` instead of `dp.type = 'OWNER'`. Do omit the `account` table and aliases like `AS account_holders_without_credit_cards` instead of including them. The amended query now correctly counts accounts for non-owner dispositions in South Bohemia district without involving credit card logic.",
            "Do remove `DISTINCT` from the count instead of keeping it, as the query should count all matching records rather than unique account IDs. Do change the case sensitivity in the filter from `'South Bohemia'` to `'south Bohemia'` instead of preserving the original capitalization to ensure proper string matching. Do omit the alias `account_holders_without_credit_cards` instead of including it, as the result column name is not required. The amended query now correctly counts all account IDs from non-OWNER disposition types in the specified region without unnecessary distinct counting or aliasing.",
            "Do filter on `T1.A3` instead of `T1.A2` in the WHERE clause to correctly reference the district name column. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for clarity, though this is functionally equivalent. The amended query now correctly counts accounts in the 'south Bohemia' district for non-OWNER disposition types, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for account holders in a specific region: filter T1.A3 to the exact literal 'South Bohemia'. 2) When determining account holder status: filter T3.type to not equal the exact literal 'OWNER'. 3) When counting account holders: count the number of distinct T3.account_id values. 4) When combining district and client tables: link rows where T1.district_id equals T2.district_id. 5) When combining client and disposition tables: link rows where T2.client_id equals T3.client_id. 6) When the question involves credit card ownership: do not include card table or credit card logic. 7) When the question involves account holders: do not include account table. 8) Output columns (ordered): account_holders_without_credit_cards",
            "1) When counting account holders: count all matching records rather than unique account IDs. 2) When filtering for the region \"South Bohemia\": use the exact literal 'south Bohemia' with lowercase 's' to ensure proper string matching. 3) When the question does not require a specific output column name: omit any alias for the result column. 4) When filtering disposition types: exclude records where the type is exactly 'OWNER'. Output columns (ordered): COUNT(T3.account_id)",
            "1) When the question mentions a region name \"South Bohemia\": filter rows where T1.A3 equals exactly 'south Bohemia' (case-sensitive).\n2) When the question asks about account holders who do not own credit cards: filter rows where T3.type does not equal 'OWNER'.\n3) When combining district (T1), client (T2), and disp (T3) tables: link rows where T1.district_id equals T2.district_id and T2.client_id equals T3.client_id, keeping only matching pairs (inner match).\n4) When counting account holders: compute the number of rows using T3.account_id as the counting key.\nOutput columns (ordered): COUNT(T3.account_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS account_holders_without_credit_cards\nFROM district d\nJOIN account a ON d.district_id = a.district_id\nJOIN disp dp ON a.account_id = dp.account_id\nJOIN client c ON dp.client_id = c.client_id\nLEFT JOIN card cd ON dp.disp_id = cd.disp_id\nWHERE d.A3 = 'South Bohemia' AND dp.type = 'OWNER' AND cd.card_id IS NULL;",
            "SELECT COUNT(DISTINCT T3.account_id) AS account_holders_without_credit_cards\nFROM district AS T1\nJOIN client AS T2 ON T1.district_id = T2.district_id\nJOIN disp AS T3 ON T2.client_id = T3.client_id\nWHERE T1.A3 = 'South Bohemia' AND T3.type != 'OWNER'",
            "SELECT COUNT(T3.account_id) \nFROM district AS T1 \nJOIN client AS T2 ON T1.district_id = T2.district_id \nJOIN disp AS T3 ON T2.client_id = T3.client_id \nWHERE T1.A2 = 'south Bohemia' AND T3.type != 'OWNER'",
            "SELECT COUNT(T3.account_id)\nFROM district AS T1\nINNER JOIN client AS T2 ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3 ON T2.client_id = T3.client_id\nWHERE T1.A3 = 'south Bohemia' AND T3.type != 'OWNER'"
        ],
        "rule_sql": [
            "SELECT COUNT(T3.account_id) \nFROM district T1\nJOIN client T2 ON T1.district_id = T2.district_id\nJOIN disp T3 ON T2.client_id = T3.client_id\nWHERE T1.A3 = 'south Bohemia' \nAND T3.type != 'OWNER'"
        ]
    },
    "1497": {
        "question": "Which SME customer consumed the least in June 2012?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do select only `CustomerID` instead of including `Segment` and `Consumption` columns. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `c` and `y`. Do move the `Segment` filter to the `WHERE` clause instead of keeping it in the original position. Do add `GROUP BY T1.CustomerID` instead of omitting aggregation grouping. Do order by `SUM(T2.Consumption)` instead of ordering by raw `Consumption` values. Do remove the explicit `ASC` keyword while maintaining ascending order instead of keeping it. The amended query now correctly aggregates consumption by customer and returns the customer with the lowest total consumption for the specified segment and date period, matching the RIGHT_SQL's behavior.",
            "Do use exact equality `T2.Date = '201206'` instead of pattern matching `T2.Date LIKE '2012-06%'` for the date filter. Do add explicit `ASC` direction in the `ORDER BY` clause instead of omitting it. The amended query now correctly filters by exact date value and specifies ascending sort order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the customer with the least consumption: select only the CustomerID column instead of including additional columns like Segment and Consumption. 2) When joining the customers and yearmonth tables: use an INNER JOIN with explicit table aliases T1 for customers and T2 for yearmonth, linking them where T1.CustomerID = T2.CustomerID. 3) When filtering for SME segment: apply the condition T1.Segment = 'SME' in the WHERE clause. 4) When filtering for June 2012: apply the condition T2.Date = '201206' in the WHERE clause. 5) When aggregating consumption by customer: use GROUP BY T1.CustomerID to organize results by individual customers. 6) When calculating total consumption: compute SUM(T2.Consumption) for each customer group. 7) When ordering to find the minimum consumption: order by SUM(T2.Consumption) in ascending order (lowest first). 8) When selecting the single customer with the minimum consumption: take only the first row from the ordered results. Output columns (ordered): T1.CustomerID",
            "1) When the question mentions \"least\" consumption: rank rows by consumption in ascending order and keep the first 1 row.\n2) When filtering by date 'June 2012': use exact equality T2.Date = '201206' instead of pattern matching.\n3) When ordering by consumption: explicitly specify ascending direction in the sort order.\n4) When filtering for SME customers: use exact equality T1.Segment = 'SME'.\n5) When combining customers and yearmonth tables: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match).\n6) When computing consumption: sum the T2.Consumption values for each customer.\nOutput columns (ordered): T1.CustomerID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.CustomerID, c.Segment, y.Consumption\nFROM customers c\nJOIN yearmonth y ON c.CustomerID = y.CustomerID\nWHERE c.Segment = 'SME' AND y.Date = '201206'\nORDER BY y.Consumption ASC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND T2.Date LIKE '2012-06%'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption)\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND T2.Date = '201206'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND T2.Date = '201206'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ]
    },
    "243": {
        "question": "What are the bonds that have phosphorus and nitrogen as their atom elements?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id IN ( SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p' ) AND T1.element = 'n'",
        "amends": [
            "Do remove `DISTINCT` and the `b.molecule_id` and `b.bond_type` columns instead of including them. Do change the FROM clause to use a single `atom` table aliased as `T1` instead of multiple `atom` and `bond` tables. Do use an `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of complex multi-table joins. Do move the phosphorus element filter to a subquery instead of using OR conditions in the main WHERE clause. Do add a subquery with `T3` and `T4` aliases to find bonds connected to phosphorus atoms instead of checking both atom elements in the main query. Do change the WHERE clause to use `T1.element = 'n'` and an IN condition with the subquery instead of the OR-based element pairing. Do remove the second atom join and the bond table join entirely instead of keeping unnecessary table relationships. The amended query now correctly identifies bonds connecting nitrogen and phosphorus atoms using a more efficient subquery approach that matches the RIGHT_SQL's behavior.",
            "Do change the FROM clause to use `atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id` instead of starting with `bond b` alone. Do add a WHERE filter `T1.element = 'n'` instead of omitting it. Do replace the complex subquery checking for both P-N and N-P pairs with a simpler subquery `SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p'` instead of the original dual-condition OR logic. Do remove the second join to atom table `a2` in the subquery instead of keeping it. The amended query now correctly finds bonds connected to both nitrogen and phosphorus atoms through separate conditions rather than attempting to find P-N bonds in a single operation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for bonds with specific atom elements: use a subquery approach to find bonds connected to one element, then check for the other element in the main query instead of using OR conditions.\n2) When filtering for phosphorus atoms: use the exact literal 'p' in the subquery condition T3.element = 'p'.\n3) When filtering for nitrogen atoms: use the exact literal 'n' in the main query condition T1.element = 'n'.\n4) When joining tables for atom connectivity: use inner join on T1.atom_id = T2.atom_id to match connected atoms.\n5) When finding bonds connected to specific elements: use a subquery with aliases T3 and T4 to identify bonds connected to phosphorus atoms instead of complex multi-table joins.\n6) When checking if bonds contain both elements: use an IN condition with the subquery results instead of OR-based element pairing logic.\n7) When selecting output columns: include only bond_id instead of additional columns like molecule_id and bond_type.\n8) When removing duplicate results: do not use DISTINCT if the query structure naturally produces unique results.\nOutput columns (ordered): T2.bond_id",
            "1) When the question asks for bonds with specific atom elements: start by joining the atom table as T1 with the connected table as T2 using T1.atom_id = T2.atom_id instead of starting from bond table alone.\n2) When filtering for nitrogen atoms: add a condition T1.element = 'n' exactly as specified.\n3) When checking for phosphorus atoms in bonds: use a subquery that selects T3.bond_id from connected as T3 joined with atom as T4 on T3.atom_id = T4.atom_id where T4.element = 'p'.\n4) When combining conditions for multiple elements: use separate subqueries for each element instead of OR logic checking both element combinations in a single operation.\n5) When joining tables: use inner joins exactly as specified in the amends (T1 INNER JOIN T2, T3 INNER JOIN T4) and do not add additional joins to atom tables.\n6) Output columns (ordered): T2.bond_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT b.bond_id, b.molecule_id, b.bond_type\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE (a1.element = 'p' AND a2.element = 'n') OR (a1.element = 'n' AND a2.element = 'p');",
            "SELECT b.bond_id\nFROM bond b\nWHERE b.bond_id IN (\n    SELECT c.bond_id\n    FROM connected c\n    JOIN atom a1 ON c.atom_id = a1.atom_id\n    JOIN atom a2 ON c.atom_id2 = a2.atom_id\n    WHERE (a1.element = 'P' AND a2.element = 'N') OR (a1.element = 'N' AND a2.element = 'P')\n)",
            "SELECT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'n'\nAND T2.bond_id IN (\n    SELECT T3.bond_id\n    FROM connected AS T3\n    INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id\n    WHERE T4.element = 'p'\n)"
        ],
        "rule_sql": [
            "SELECT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'n'\nAND T2.bond_id IN (\n    SELECT T3.bond_id\n    FROM connected AS T3\n    INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id\n    WHERE T4.element = 'p'\n)"
        ]
    },
    "991": {
        "question": "What is the full name and date of birth of Austrian drivers born between 1981 and 1991?",
        "db_id": "formula_1",
        "ground_truth": "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `full_name`. Do keep the same `dob` column selection instead of changing it. Do maintain the same `WHERE` filter on `nationality = 'Austrian'` instead of altering it. Do preserve the same date range filter using `STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'` instead of modifying it. The amended query now correctly returns separate forename and surname columns instead of a concatenated full name while maintaining the same filtering logic for Austrian drivers born between 1981 and 1991."
        ],
        "rules": [
            "1) When the question asks for \"full name\" but the schema has separate forename and surname columns: output the individual columns \"forename\" and \"surname\" instead of concatenating them.\n2) When filtering for drivers with nationality \"Austrian\": use the exact literal value 'Austrian' for the nationality filter.\n3) When filtering for birth years between 1981 and 1991: use the year extraction function on the \"dob\" column and check for values between '1981' and '1991' inclusive.\n4) When selecting date of birth: output the \"dob\" column as is without transformation.\nOutput columns (ordered): forename, surname, dob"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT forename || ' ' || surname AS full_name, dob FROM drivers WHERE nationality = 'Austrian' AND strftime('%Y', dob) BETWEEN '1981' AND '1991';",
            "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'"
        ],
        "rule_sql": [
            "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND strftime('%Y', dob) BETWEEN '1981' AND '1991'"
        ]
    },
    "561": {
        "question": "What is the title for the post which got the highest score comment?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Title FROM posts WHERE Id = ( SELECT PostId FROM comments ORDER BY Score DESC LIMIT 1 )",
        "amends": [],
        "rules": [
            "highest score comment refers to Max(comments.Score)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Title\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nORDER BY c.Score DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "309": {
        "question": "List out the atom id that belongs to the TR346 molecule and how many bond type can be created by this molecule?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type),T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR000' GROUP BY T1.atom_id, T2.bond_type",
        "amends": [
            "Do select `T1.molecule_id` instead of omitting it. Do use `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of `LEFT JOIN` on `m.molecule_id = b.molecule_id`. Do filter on `T1.molecule_id = 'TR000'` instead of `m.label = 'TR346'`. Do group by `T1.atom_id, T2.bond_type` instead of just `a.atom_id`. Do remove the `molecule` table entirely instead of including it as a source. The amended query now correctly counts distinct bond types per atom within the specified molecule while maintaining proper grouping semantics.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do change the WHERE filter to `T1.molecule_id = 'TR000'` instead of `T1.molecule_id = 'TR346'`. Do add `T2.bond_type` to the GROUP BY clause instead of grouping only by `T1.atom_id`. Do remove the alias `AS bond_type_count` from the COUNT expression instead of keeping it. The amended query now correctly includes all non-aggregated columns in GROUP BY and filters for the correct molecule ID, matching the intended behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of including `T1.molecule_id` in the GROUP BY clause since it's already filtered to a single value in the WHERE clause. The amended query now correctly counts distinct bond types per atom while maintaining the molecule_id in the output, matching the RIGHT_SQL's behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do add `DISTINCT` to `COUNT(T2.bond_type)` instead of counting duplicates. Do remove `T1.molecule_id` from the GROUP BY clause instead of including it, as it's functionally dependent on the WHERE filter. Do keep the same join condition `T1.molecule_id = T2.molecule_id` and maintain the `INNER JOIN` type. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in results, matching the intended behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it, and do change the WHERE filter to `T1.molecule_id = 'TR000'` instead of `T1.molecule_id = 'TR346'`. Do add `T2.bond_type` to the GROUP BY clause instead of grouping only by `T1.atom_id`, and do remove the `T1.molecule_id` from the GROUP BY since it's now included in the SELECT list with proper grouping. The amended query now correctly counts distinct bond types per atom while maintaining the molecule_id in results and filtering for the correct molecule identifier.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do use `AS` for table aliases instead of omitting the keyword. Do group by `T1.atom_id, T2.bond_type` instead of including `T1.molecule_id` in the GROUP BY clause since it's functionally dependent on the WHERE filter. The amended query now correctly returns molecule_id in the results while maintaining proper grouping semantics.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id` to properly align with the COUNT(DISTINCT T2.bond_type) aggregation. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in the output and maintaining proper grouping semantics.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of grouping by `T1.atom_id, T1.molecule_id, T2.bond_type` since the molecule_id filter makes grouping by it redundant. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in the output and matches the RIGHT_SQL's behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it, and do filter for `'TR000'` instead of `'TR346'` in the WHERE clause. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id, T2.bond_type` since `T1.molecule_id` is now properly included in the SELECT list rather than being part of the GROUP BY. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in the output and filtering for the correct molecule identifier.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it, and do move `T1.molecule_id` to the end of the SELECT list instead of having it as the second column. Do keep the same FROM clause with `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of changing it. Do maintain the WHERE filter on `T1.molecule_id = 'TR000'` instead of altering it. Do preserve the GROUP BY clause with `T1.atom_id, T2.bond_type` instead of modifying it. The amended query now correctly includes all necessary columns in the output while maintaining the same aggregation logic and filtering behavior.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id, T2.bond_type` since `T1.molecule_id` is now properly included in the SELECT list and the grouping remains consistent with the distinct bond type counting logic. The amended query now correctly returns atom_id, distinct bond type count, and molecule_id for each atom-bond_type combination within the specified molecule.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id, T2.bond_type` since `T1.molecule_id` is now properly included in the SELECT list and the grouping remains consistent with the distinct bond type counting. The amended query now correctly returns atom_id, distinct bond type count, and molecule_id for each atom-bond_type combination within the specified molecule.",
            "Do include `T1.molecule_id` in the SELECT list instead of omitting it. Do group by `T1.atom_id, T2.bond_type` instead of `T1.atom_id, T1.molecule_id, T2.bond_type` since the molecule_id filter is already applied in WHERE clause and doesn't need grouping. The amended query now correctly counts distinct bond types per atom while preserving the molecule_id in results and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for atoms belonging to a specific molecule: filter using T1.molecule_id = 'TR000' instead of label-based filtering. 2) When counting distinct bond types per atom: group by both T1.atom_id and T2.bond_type to ensure proper distinct counting. 3) When combining atom and bond information: use INNER JOIN on T1.molecule_id = T2.molecule_id to link related data. 4) When selecting output columns: include T1.molecule_id in addition to atom_id and bond type count. 5) When handling molecule identification: do not use the molecule table directly; use molecule_id from atom and bond tables instead. Output columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atoms belonging to a specific molecule with ID 'TR000': filter rows where T1.molecule_id equals 'TR000' exactly. 2) When counting distinct bond types created by a molecule: compute the number of unique values of T2.bond_type. 3) When grouping results by atom_id and bond_type: organize results by both T1.atom_id and T2.bond_type together. 4) When selecting output columns: include both T1.atom_id and the count of distinct bond types. 5) When combining atom and bond tables for shared molecules: link rows where T1.molecule_id equals T2.molecule_id exactly and keep only matching pairs. Output columns (ordered): T1.atom_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atoms belonging to a specific molecule with identifier 'TR346': filter rows where T1.molecule_id equals 'TR346' exactly. 2) When counting distinct bond types per atom: group results by T1.atom_id and T2.bond_type to compute distinct counts. 3) When including molecule_id in output while filtering to a single molecule value: include T1.molecule_id in the output columns even when grouping by atom_id only. 4) When combining atom and bond tables for shared molecules: link rows where T1.molecule_id equals T2.molecule_id exactly and keep only matching pairs. 5) Output columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atoms belonging to a specific molecule with identifier 'TR346': filter rows where T1.molecule_id equals 'TR346' exactly. 2) When counting bond types created by a molecule: count distinct values of T2.bond_type instead of counting duplicates. 3) When grouping by atom_id while molecule_id is fixed by filtering: do not include molecule_id in the grouping clause as it is functionally dependent. 4) When combining atom and bond tables for shared molecules: link rows where T1.molecule_id equals T2.molecule_id exactly and keep only matching pairs (inner match). 5) When the question asks to list atom_id and molecule_id together: include both T1.atom_id and T1.molecule_id in the output columns. Output columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atoms belonging to a specific molecule with identifier 'TR000': filter rows where T1.molecule_id equals 'TR000' exactly. 2) When counting distinct bond types per atom: group results by both T1.atom_id and T2.bond_type to ensure proper distinct counting. 3) When including molecule_id in output while grouping by atom_id: include T1.molecule_id in the select list without adding it to the group by clause since it's functionally dependent on atom_id for this molecule filter. 4) When joining atom and bond tables for molecule relationships: link rows where T1.molecule_id equals T2.molecule_id to find bonds associated with each atom. 5) Output columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atom id belonging to a specific molecule: include T1.atom_id in the output columns. 2) When the question asks for how many bond types can be created by a molecule: count distinct T2.bond_type values. 3) When filtering for a specific molecule with identifier 'TR346': apply the condition T1.molecule_id = 'TR346' exactly. 4) When joining atom and bond tables: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match). 5) When grouping results: group by T1.atom_id and T2.bond_type to maintain proper aggregation semantics. 6) When including molecule_id in output: ensure T1.molecule_id is included in the SELECT list. 7) Output columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atom id belonging to a specific molecule: filter rows where T1.molecule_id equals the exact literal 'TR346' (not 'TR000').\n2) When counting distinct bond types created by a molecule: count the number of unique values in T2.bond_type.\n3) When grouping for aggregation: group by T1.atom_id and T2.bond_type to align with the distinct count of bond types.\n4) When including molecule identifier in output: include T1.molecule_id in the result columns.\n5) When combining atom and bond tables: link rows where T1.molecule_id equals T2.molecule_id and keep only matching pairs (inner match).\nOutput columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atom id belonging to a specific molecule: filter T1.molecule_id to exactly 'TR346' (not 'TR000').\n2) When counting distinct bond types per atom: count unique values of T2.bond_type for each T1.atom_id.\n3) When grouping results: group by T1.atom_id only, not by T2.bond_type, since we want bond type count per atom.\n4) When including molecule_id in output: include T1.molecule_id in the result columns.\n5) When joining atom and bond tables: link rows where T1.molecule_id = T2.molecule_id to find bonds for each molecule.\nOutput columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atoms belonging to a specific molecule with identifier 'TR000': filter rows where T1.molecule_id equals 'TR000' exactly. 2) When counting distinct bond types per atom: group results by T1.atom_id and T2.bond_type to compute distinct counts. 3) When including molecule identifier in output: ensure T1.molecule_id is present in the result columns. 4) When joining atom and bond tables: link rows where T1.molecule_id equals T2.molecule_id to find matching molecule records. 5) Output columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atom IDs belonging to a specific molecule: filter rows where T1.molecule_id equals the exact literal 'TR000'.\n2) When counting distinct bond types for a molecule: compute the number of unique values of T2.bond_type.\n3) When grouping results by atom and bond type: organize results by T1.atom_id and T2.bond_type.\n4) When including molecule ID in output: place T1.molecule_id at the end of the output columns list.\n5) When combining atom and bond tables: link rows where T1.molecule_id equals T2.molecule_id and keep only matching pairs.\nOutput columns (ordered): T1.atom_id, COUNT(DISTINCT T2.bond_type), T1.molecule_id",
            "1) When the question asks for atoms belonging to a specific molecule with identifier 'TR346': filter rows where T1.molecule_id equals exactly 'TR346' (not 'TR000').\n2) When counting distinct bond types created by a molecule: count the number of unique values of T2.bond_type for each atom.\n3) When grouping results by atom and bond type: organize results by T1.atom_id and T2.bond_type to get distinct bond type counts per atom.\n4) When selecting output columns for atom information: include T1.atom_id to identify each atom and T1.molecule_id to confirm the molecule association.\n5) When combining atom and bond tables for molecule analysis: link rows where T1.molecule_id equals T2.molecule_id to associate atoms with their bonds.\nOutput columns (ordered): T1.atom_id, COUNT(DISTINCT T2.bond_type), T1.molecule_id",
            "1) When the question asks for atom id and molecule id: include both T1.atom_id and T1.molecule_id in the output columns. 2) When counting distinct bond types for a molecule: count the number of unique values of T2.bond_type. 3) When filtering for a specific molecule: use the exact literal 'TR346' for T1.molecule_id instead of 'TR000'. 4) When grouping for distinct bond type counting: group by T1.atom_id and T2.bond_type to get counts per atom-bond_type combination. 5) When joining atom and bond tables: link rows where T1.molecule_id equals T2.molecule_id to match atoms with their bonds. Output columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)",
            "1) When the question asks for atom id belonging to a specific molecule (TR346): filter rows where T1.molecule_id equals 'TR346' exactly. 2) When counting bond types created by a molecule: count distinct values of T2.bond_type. 3) When grouping results by atom: organize results by T1.atom_id only. 4) When including molecule_id in output: include T1.molecule_id in the result columns. 5) When combining atom and bond tables: link rows where T1.molecule_id equals T2.molecule_id exactly and keep only matching pairs (inner match). Output columns (ordered): T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.atom_id, COUNT(DISTINCT b.bond_type) AS bond_type_count\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nLEFT JOIN bond b ON m.molecule_id = b.molecule_id\nWHERE m.label = 'TR346'\nGROUP BY a.atom_id;",
            "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type) AS bond_type_count\nFROM atom T1\nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR346'\nGROUP BY T1.atom_id",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(T2.bond_type) \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR346' \nGROUP BY T1.atom_id",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR346' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR000'\nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR000'\nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id = 'TR000' \nGROUP BY T1.atom_id, T2.bond_type",
            "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type), T1.molecule_id\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR000'\nGROUP BY T1.atom_id, T2.bond_type"
        ],
        "rule_sql": [
            "SELECT T1.atom_id, T1.molecule_id, COUNT(DISTINCT T2.bond_type)\nFROM atom T1\nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id = 'TR346'\nGROUP BY T1.atom_id"
        ]
    },
    "1426": {
        "question": "List the last name of members with a major in environmental engineering and include its department and college name.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.last_name, T1.department, T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'",
        "amends": [],
        "rules": [
            "'Environmental Engineering' is the major_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.last_name, ma.department, ma.college\nFROM member m\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE ma.major_name = 'Environmental Engineering';"
        ],
        "rule_sql": []
    },
    "329": {
        "question": "Which carcinogenic molecule have the highest number of atoms consisted in it?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T2.molecule_id, COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T2.molecule_id ORDER BY COUNT(T1.atom_id) DESC LIMIT 1 ) t",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; molecule that have the highest number of atoms consisted in in refers to MAX(COUNT(atom.molecule_id))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.molecule_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+'\nGROUP BY a.molecule_id\nORDER BY COUNT(a.atom_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "288": {
        "question": "Identify whether the molecule that contains atom TR001_1 is carcinogenic.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_1'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.label \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE a.atom_id = 'TR001_1';"
        ],
        "rule_sql": []
    },
    "316": {
        "question": "Among the molecules which contain \"c\" element, which of them are not carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.molecule_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'c' AND m.label = '-';"
        ],
        "rule_sql": []
    },
    "708": {
        "question": "List the creation date and age of the user that commented with webiste.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.CreationDate, T2.Age FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.text LIKE '%http://%'",
        "amends": [],
        "rules": [
            "commented with webiste refers to the value contains 'http://'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.CreationDate, u.Age\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text LIKE '%http://%';"
        ],
        "rule_sql": []
    },
    "323": {
        "question": "Is molecule TR000 is carcinogenic or not?",
        "db_id": "toxicology",
        "ground_truth": "SELECT label FROM molecule AS T WHERE T.molecule_id = 'TR000'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "-- The schema does not provide any information about carcinogenicity, so the query cannot determine if molecule TR000 is carcinogenic.\n-- The following query retrieves the label of molecule TR000, but it does not confirm carcinogenicity.\nSELECT label FROM molecule WHERE molecule_id = 'TR000';"
        ],
        "rule_sql": []
    },
    "1396": {
        "question": "Provide the number of events attended by Luisa Guidi. What is her major?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T3.link_to_event), T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'",
        "amends": [],
        "rules": [
            "major refers to major_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH luisa_info AS (\n    SELECT member_id, link_to_major\n    FROM member\n    WHERE first_name = 'Luisa' AND last_name = 'Guidi'\n)\nSELECT \n    COUNT(a.link_to_event) AS number_of_events_attended,\n    m.major_name\nFROM \n    luisa_info li\nLEFT JOIN \n    attendance a ON li.member_id = a.link_to_member\nLEFT JOIN \n    major m ON li.link_to_major = m.major_id\nGROUP BY \n    m.major_name;"
        ],
        "rule_sql": []
    },
    "1064": {
        "question": "List out of players whose preferred foot is left.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "amends": [
            "Do select `DISTINCT t1.id, t1.player_name` instead of just `p.player_name` to include the player ID and ensure uniqueness. Do use table aliases `t1` and `t2` instead of `p` and `pa` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use `t1.player_api_id = t2.player_api_id` as the join condition instead of `p.player_api_id = pa.player_api_id` with the aliased table names. The amended query now correctly returns distinct player IDs and names for left-footed players, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for players with a specific preferred foot: filter rows where t2.preferred_foot equals exactly 'left'.\n2) When combining Player and Player_Attributes tables: link rows where t1.player_api_id equals t2.player_api_id exactly and keep only matching pairs (inner match).\n3) When ensuring unique player results: return distinct combinations of t1.id and t1.player_name.\n4) When using table aliases: refer to Player table as t1 and Player_Attributes table as t2 consistently.\n5) Output columns (ordered): t1.id, t1.player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.preferred_foot = 'left';",
            "SELECT DISTINCT t1.id, t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.preferred_foot = 'left';"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.id, t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.preferred_foot = 'left'"
        ]
    },
    "1271": {
        "question": "How many patients with a normal anti-SSA came to the hospital before 2000?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '2000'",
        "amends": [
            "Do use `T1.ID` and `T2.ID` as table aliases instead of `P.ID` and `L.ID`. Do change the SSA filter to `IN ('negative', '0')` instead of `IN ('-', '+-')`. Do use `STRFTIME('%Y', T2.Date)` for year extraction instead of `YEAR(P.\"First Date\")`. Do reference `T2.Date` instead of `P.\"First Date\"` for the date comparison. The amended query now correctly filters laboratory results with specific SSA values and uses the laboratory date for year comparison, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for count of patients: compute the number of distinct values of T1.ID.\n2) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When filtering for normal anti-SSA results: include only rows where T2.SSA IN ('negative', '0').\n4) When filtering for dates before 2000: include only rows where STRFTIME('%Y', T2.Date) < '2000'.\n5) When handling text literals: preserve exact values 'negative' and '0' without changing case or punctuation.\n6) When choosing identifier delimiters: use T1.ID and T2.ID without quotes as shown in the amends.\n7) When extracting year from dates: use STRFTIME('%Y', T2.Date) for year extraction.\n8) Output columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.SSA IN ('-', '+-') \nAND YEAR(P.`First Date`) < 2000;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.SSA IN ('negative', '0')\nAND STRFTIME('%Y', T2.Date) < '2000';"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.SSA IN ('negative', '0')\nAND STRFTIME('%Y', T2.Date) < '2000'"
        ]
    },
    "1363": {
        "question": "List all of the College of Humanities and Social Sciences' departments.",
        "db_id": "student_club",
        "ground_truth": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it, and do use the exact college name `'College of Humanities and Social Sciences'` instead of the incomplete `'Humanities and Social Sciences'` to ensure accurate filtering of departments from the major table."
        ],
        "rules": [
            "1) When the question asks for departments from a specific college: filter the major table using the exact college name literal 'College of Humanities and Social Sciences' to match rows where college equals this value. 2) When listing departments without requiring uniqueness: do not apply distinct filtering on the department column. 3) Output columns (ordered): department"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT department FROM major WHERE college = 'Humanities and Social Sciences';",
            "SELECT major.department FROM major WHERE major.college = 'College of Humanities and Social Sciences';"
        ],
        "rule_sql": [
            "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'"
        ]
    },
    "998": {
        "question": "In terms of number of points acquired, how many victories did the driver who ranked 91st acquired?",
        "db_id": "formula_1",
        "ground_truth": "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) FROM driverStandings",
        "amends": [
            "Do use `SUM(CASE WHEN points = 91 THEN wins ELSE 0 END)` instead of selecting `wins` directly. Do remove the subquery `(SELECT driverId FROM driverStandings ORDER BY points DESC LIMIT 1 OFFSET 90)` instead of using it to filter by driverId. Do aggregate the wins for all rows where points equal 91 instead of retrieving wins for a single driver at a specific ranking position. The amended query now correctly calculates the total wins for drivers with exactly 91 points, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for victories (wins) for drivers with a specific points value (91): sum the wins column for all rows where points equals 91 exactly. 2) When handling exact point values: use the literal value 91 without quotes as it represents a numeric comparison. 3) When aggregating wins: use the exact column name wins from the driverStandings table. 4) Output columns (ordered): SUM(CASE WHEN points = 91 THEN wins ELSE 0 END)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT wins FROM driverStandings WHERE driverId = (SELECT driverId FROM driverStandings ORDER BY points DESC LIMIT 1 OFFSET 90);",
            "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) AS total_wins FROM driverStandings;"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) FROM driverStandings;"
        ]
    },
    "1189": {
        "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')",
        "amends": [
            "Do remove the CTE `AvgACLIgM` and calculate the average directly in the subquery instead of using a separate CTE. Do change the filter from `ANA = 'S'` to `ANA Pattern = 'S'` instead of using the wrong column name. Do remove the `JOIN` with `Patient` table instead of including an unnecessary table join. Do change `COUNT(DISTINCT E.ID)` to `COUNT(*)` instead of counting distinct IDs when examining the same table. Do move the `Thrombosis = 2` and `ANA Pattern = 'S'` conditions into the subquery's WHERE clause instead of only applying them in the outer query, ensuring the average calculation uses the same filtered dataset. Do remove the patient count alias instead of keeping unnecessary column naming. The amended query now correctly counts examinations meeting all criteria using consistent filtering throughout."
        ],
        "rules": [
            "1) When calculating an average value for comparison: compute the average directly in a subquery using the same filtering conditions as the main query instead of using a separate CTE.\n2) When filtering by ANA pattern: use the exact column name \"ANA Pattern\" with literal value 'S' instead of a similar column name.\n3) When the question only requires data from one table: do not join with unnecessary tables like Patient when all required data exists in the Examination table.\n4) When counting rows that meet specific criteria: use COUNT(*) instead of counting distinct IDs when examining the same table.\n5) When calculating an average based on filtered data: apply all filtering conditions (Thrombosis = 2 and ANA Pattern = 'S') in the subquery to ensure the average calculation uses the same filtered dataset.\n6) When comparing values to a calculated average: use the exact comparison E.\"aCL IgM\" > (subquery average * 1.2) to find values 20% higher than average.\n7) When the output is a simple count: do not use unnecessary column aliases for the count result.\nOutput columns (ordered): COUNT(*)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH AvgACLIgM AS (\n    SELECT AVG(`aCL IgM`) AS avg_value FROM Examination\n)\nSELECT COUNT(DISTINCT E.ID) AS patient_count\nFROM Examination E\nJOIN Patient P ON E.ID = P.ID\nWHERE E.Thrombosis = 2\nAND E.ANA = 'S'\nAND E.`aCL IgM` > (SELECT avg_value * 1.2 FROM AvgACLIgM);",
            "SELECT COUNT(*)\nFROM Examination E\nWHERE E.Thrombosis = 2\nAND E.\"ANA Pattern\" = 'S'\nAND E.\"aCL IgM\" > (\n    SELECT AVG(\"aCL IgM\") * 1.2\n    FROM Examination\n    WHERE Thrombosis = 2\n    AND \"ANA Pattern\" = 'S'\n    AND \"aCL IgM\" IS NOT NULL\n);"
        ],
        "rule_sql": [
            "SELECT COUNT(*)\nFROM Examination E\nWHERE E.Thrombosis = 2\nAND E.\"ANA Pattern\" = 'S'\nAND E.\"aCL IgM\" > (\n    SELECT AVG(\"aCL IgM\") * 1.2\n    FROM Examination\n    WHERE Thrombosis = 2\n    AND \"ANA Pattern\" = 'S'\n);"
        ]
    },
    "477": {
        "question": "Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (T2.name = 'Coldsnap' AND T1.artist = 'Chippy') OR (T2.name = 'Coldsnap' AND T1.artist = 'Aaron Miller') OR (T2.name = 'Coldsnap' AND T1.artist = 'Jeremy Jarvis') GROUP BY T1.artist",
        "amends": [],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; Jeremy Jarvis, Aaron Miller or Chippy are the name of artists which refers to artist IN ('Jeremy Jarvis', 'Aaron Miller','Chippy');"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.artist\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Coldsnap'\nAND c.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy');"
        ],
        "rule_sql": []
    },
    "738": {
        "question": "Which superheroes have a durability attribute value of less than 50?",
        "db_id": "superhero",
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "amends": [],
        "rules": [
            "durability of less than 50 refers to attribute_name = 'Durability' AND attribute_value < 50"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Durability' AND ha.attribute_value < 50;"
        ],
        "rule_sql": []
    },
    "554": {
        "question": "What is the display name of the user who has obtained the most number of badges?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id GROUP BY T2.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "who obtained the most number of badges refers to UserID with Max(Count(Id))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN (\n    SELECT UserId, COUNT(*) AS badge_count\n    FROM badges\n    GROUP BY UserId\n) b ON u.Id = b.UserId\nORDER BY b.badge_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "866": {
        "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
        "amends": [
            "Do select `T2.forename`, `T2.surname`, and `T2.url` instead of only `d.url`. Do add `DISTINCT` to eliminate duplicate rows instead of omitting it. Do use `INNER JOIN` with `drivers AS T2` and `lapTimes AS T1` instead of `JOIN drivers d` and `lapTimes l`. Do change the join condition to `T2.driverId = T1.driverId` instead of `d.driverId = l.driverId`. Do use `LIKE '1:27%'` for pattern matching instead of exact match `= '0:01:27'`. The amended query now correctly retrieves distinct driver names and URLs for lap times starting with '1:27' in race 161, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a player's introduction website along with their name: select T2.forename, T2.surname, and T2.url instead of only the website URL.\n2) When retrieving data that may have duplicates: use DISTINCT to eliminate duplicate rows.\n3) When combining lap time data with driver information: use INNER JOIN with drivers AS T2 and lapTimes AS T1, linking them where T2.driverId = T1.driverId.\n4) When matching lap time patterns that start with specific minutes and seconds: use LIKE '1:27%' for pattern matching instead of exact time matching.\n5) When filtering for a specific race: use T1.raceId = 161 to identify race No. 161.\nOutput columns (ordered): T2.forename, T2.surname, T2.url"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.url \nFROM drivers d \nJOIN lapTimes l ON d.driverId = l.driverId \nWHERE l.raceId = 161 AND l.time = '0:01:27';",
            "SELECT DISTINCT T2.forename, T2.surname, T2.url\nFROM lapTimes AS T1\nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 161 AND T1.time LIKE '1:27%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.forename, T2.surname, T2.url\nFROM lapTimes AS T1\nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 161\nAND T1.time LIKE '0:01:27%';"
        ]
    },
    "1270": {
        "question": "Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.SC170 = 'negative' OR T2.SC170 = '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL",
        "amends": [],
        "rules": [
            "normal anti-scl70 refers to SC170 IN('negative', '0'); female refers to Sex = 'F'; does not have any symptom refers to symptoms IS NULL; Should consider DISTINCT in the final result;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.SC170 IN('negative', '0') \nAND P.SEX = 'F' \nAND E.Symptoms IS NULL;"
        ],
        "rule_sql": []
    },
    "61": {
        "question": "How many chartered schools located in the city of Hickman are owned by the Elementary School District?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE DOC = 52 AND Charter = 1 AND City = 'Hickman'",
        "amends": [],
        "rules": [
            "Elementary School District refers to DOC = 52; Chartered schools refer to Charter = 1 in the table schools"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NumberOfCharteredSchools\nFROM schools\nWHERE City = 'Hickman' AND Charter = 1 AND DOC = '52';"
        ],
        "rule_sql": []
    },
    "845": {
        "question": "List the power of superheroes with height greater than 80% of the average height of all superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm * 100 > ( SELECT AVG(height_cm) FROM superhero ) * 80",
        "amends": [],
        "rules": [
            "power of superheroes refers to power_name; height greater than 80% of the average height of all superheroes = height_cm > MULTIPLY(AVG(height_cm), 0.8);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.height_cm > (SELECT 0.8 * AVG(height_cm) FROM superhero);"
        ],
        "rule_sql": []
    },
    "504": {
        "question": "How many cards are there in the set 'World Championship Decks 2004' with the converted mana cost as '3'.",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE setCode IN ( SELECT code FROM sets WHERE name = 'World Championship Decks 2004' ) AND convertedManaCost = 3",
        "amends": [],
        "rules": [
            "the set 'World Championship Decks 2004' refers to name = 'World Championship Decks 2004'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT code FROM sets WHERE name = 'World Championship Decks 2004') \nAND convertedManaCost = 3;"
        ],
        "rule_sql": []
    },
    "66": {
        "question": "Between 1/1/2000 to 12/31/2005, how many directly funded schools opened in the county of Stanislaus?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', OpenDate) BETWEEN '2000' AND '2005' AND County = 'Stanislaus' AND FundingType = 'Directly funded'",
        "amends": [
            "Do count `School` column instead of `COUNT(*)` to exclude NULL values. Do use `strftime('%Y', OpenDate)` for year extraction instead of `BETWEEN` with full date strings to properly handle year-only comparison. Do change `FundingType` filter to lowercase 'Directly funded' instead of 'Directly Funded' to match the actual case-sensitive data. Do remove the explicit `BETWEEN` date range condition and instead filter by year only through the strftime function. The amended query now correctly counts non-NULL School values within the specified year range while maintaining proper case sensitivity for the FundingType filter."
        ],
        "rules": [
            "1) When counting schools: count the \"School\" column instead of all rows to exclude NULL values.\n2) When filtering by year range 2000 to 2005: use year extraction from the OpenDate column instead of full date range comparison.\n3) When filtering for directly funded schools: use the exact literal 'Directly funded' (lowercase 'f') to match case-sensitive data.\n4) When the question asks about schools in Stanislaus county: filter using the County column with value 'Stanislaus'.\n5) Output columns (ordered): COUNT(\"School\") as NumberOfDirectlyFundedSchools"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NumberOfDirectlyFundedSchools\nFROM schools\nWHERE County = 'Stanislaus'\nAND FundingType = 'Directly Funded'\nAND OpenDate BETWEEN '2000-01-01' AND '2005-12-31';",
            "SELECT COUNT(School) \nFROM schools \nWHERE County = 'Stanislaus' \nAND LOWER(FundingType) = 'directly funded' \nAND strftime('%Y', OpenDate) BETWEEN '2000' AND '2005'"
        ],
        "rule_sql": [
            "SELECT COUNT(\"School\") as NumberOfDirectlyFundedSchools\nFROM schools\nWHERE strftime('%Y', OpenDate) BETWEEN '2000' AND '2005'\nAND County = 'Stanislaus'\nAND FundingType = 'Directly funded';"
        ]
    },
    "1294": {
        "question": "Please list the patient's ID whose creatinine level is normal and whose anti Cardiolipin antibody concentration level is the highest.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T2.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.CRE < 1.5 ORDER BY T2.`aCL IgA` DESC LIMIT 1",
        "amends": [
            "Do select `T2.ID` instead of `p.ID` and remove the subquery. Do join `Laboratory AS T1` with `Examination AS T2` using `T1.ID = T2.ID` instead of joining Patient with both Laboratory and Examination separately. Do keep the `T1.CRE < 1.5` filter but remove the complex subquery condition. Do add `ORDER BY T2.aCL IgA DESC LIMIT 1` instead of using a subquery to find the maximum value, which more efficiently retrieves the single record with the highest aCL IgA value. The amended query now correctly identifies the Examination record with the maximum aCL IgA value for patients with CRE < 1.5, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining Laboratory and Examination tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 2) When filtering for normal creatinine levels: include only rows where T1.CRE < 1.5. 3) When finding the highest anti Cardiolipin antibody concentration level: rank rows by T2.aCL IgA in descending order and keep the first 1 row. 4) When selecting patient ID: output T2.ID. 5) Output columns (ordered): T2.ID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.CRE < 1.5\nAND e.`aCL IgA` = (SELECT MAX(`aCL IgA`) FROM Examination WHERE `aCL IgA` IS NOT NULL);",
            "SELECT T2.ID\nFROM Laboratory AS T1\nJOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.CRE < 1.5\nORDER BY T2.\"aCL IgA\" DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.ID\nFROM Laboratory T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T1.CRE < 1.5\nORDER BY T2.\"aCL IgA\" DESC\nLIMIT 1"
        ]
    },
    "661": {
        "question": "How old is the most influential user?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Age FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "amends": [],
        "rules": [
            "How old describes age; the most influential refers to user where MAX(Reputation);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Age FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "rule_sql": []
    },
    "373": {
        "question": "Name the cards that were illustrated by Aaron Boyd.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd'",
        "amends": [],
        "rules": [
            "Aaron Boyd' is artist;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE artist = 'Aaron Boyd';"
        ],
        "rule_sql": []
    },
    "1322": {
        "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
        "amends": [
            "Do select `T1.event_name` instead of `COUNT(*) AS meeting_events_with_more_than_10_attendees`. Do use `INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event` instead of a correlated subquery in the WHERE clause. Do move the count condition to `HAVING COUNT(T2.link_to_event) > 10` instead of the subquery comparison. Do add `GROUP BY T1.event_id` instead of omitting grouping. Do use `EXCEPT` to filter out non-Meeting events instead of including `WHERE e.type = 'Meeting'` directly. Do remove the type filter from the main query and instead use `EXCEPT SELECT T1.event_name FROM event AS T1 WHERE T1.type = 'Meeting'` to exclude meeting events from the result. The amended query now correctly identifies events with more than 10 attendees while excluding meeting-type events, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting events attended by more than 10 members: group by T1.event_id and count T2.link_to_event, then keep only groups where the count exceeds 10.\n2) When filtering for non-meeting events: exclude events where T1.type equals 'Meeting' exactly.\n3) When combining event and attendance tables: link rows where T1.event_id equals T2.link_to_event using an inner match.\n4) When selecting output: return T1.event_name instead of a count.\n5) Output columns (ordered): T1.event_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS meeting_events_with_more_than_10_attendees\nFROM event e\nWHERE e.type = 'Meeting'\nAND (\n    SELECT COUNT(*)\n    FROM attendance a\n    WHERE a.link_to_event = e.event_id\n) > 10;",
            "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_id\nHAVING COUNT(T2.link_to_event) > 10\nEXCEPT\nSELECT T1.event_name\nFROM event AS T1\nWHERE T1.type = 'Meeting'"
        ],
        "rule_sql": [
            "SELECT T1.event_name\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_id\nHAVING COUNT(T2.link_to_event) > 10\nAND T1.type != 'Meeting';"
        ]
    },
    "1269": {
        "question": "Please list the IDs of the patients who had the examination done after 1997/1/1 and had a normal anti-scl70.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SC170 IN ('negative','0') AND T2.Date > 1997-01-01",
        "amends": [
            "Do select `T1.ID` instead of `e.ID` and remove `DISTINCT` instead of keeping it. Do use `INNER JOIN` on `Laboratory AS T2` with `T1.ID = T2.ID` instead of `JOIN` on `Patient p` with `e.ID = p.ID`. Do filter on `T2.SC170 IN ('negative','0')` and `T2.Date > 1997-01-01` instead of `e.SC170 IN ('negative','0')` and `e.Examination Date > '1997-01-01'`. The amended query now correctly joins Patient with Laboratory table and applies filters to the Laboratory table columns, matching the intended behavior.",
            "Do use unquoted date literal `1997-01-01` instead of quoted `'1997-01-01'` for proper date comparison. Do reorder the WHERE clause predicates to place `T2.SC170 IN ('negative','0')` before `T2.Date > 1997-01-01` instead of the reverse order, though this is functionally equivalent in most SQL engines. The amended query now correctly matches the RIGHT_SQL's behavior with proper date handling and predicate arrangement."
        ],
        "rules": [
            "1) When the question asks for patient IDs who had an examination: use T1.ID from the Patient table as the output column instead of any other table's ID.\n2) When joining Patient and Laboratory tables: use an inner join where T1.ID = T2.ID to link patients with their laboratory results.\n3) When filtering for examination dates after 1997/1/1: apply the condition T2.Date > 1997-01-01 to the Laboratory table's Date column.\n4) When filtering for normal anti-scl70 results: use T2.SC170 IN ('negative','0') to match the exact literal values 'negative' and '0'.\n5) When selecting patient IDs: do not use DISTINCT as the join and filter conditions naturally produce unique patient IDs.\nOutput columns (ordered): T1.ID",
            "1) When the question mentions \"examination done after 1997/1/1\": filter rows where T2.Date is greater than 1997-01-01. 2) When the question mentions \"normal anti-scl70\": filter rows where T2.SC170 is either 'negative' or '0'. 3) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match). 4) Output columns (ordered): T1.ID"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT e.ID\nFROM Examination e\nJOIN Patient p ON e.ID = p.ID\nWHERE e.`Examination Date` > '1997-01-01'\nAND e.SC170 IN ('negative', '0');",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date > '1997-01-01'\nAND T2.SC170 IN ('negative', '0')",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.SC170 IN ('negative','0')\nAND T2.Date > 1997-01-01"
        ],
        "rule_sql": [
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date > '1997-01-01'\nAND T2.SC170 IN ('negative', '0')"
        ]
    },
    "415": {
        "question": "What percentage of cards with format commander and legal status do not have a content warning?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END)` to properly count only true cases. Do add explicit `ELSE 0` instead of omitting it to ensure correct summation. Do cast the sum as `REAL` instead of using decimal notation for proper floating-point division. Do reference `T1.id` in `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do use table aliases `T1` and `T2` instead of single letters for clarity. Do capitalize `'Legal'` instead of using lowercase `'legal'` to match the actual data values. The amended query now correctly calculates the percentage by properly handling the case logic and ensuring accurate floating-point division."
        ],
        "rules": [
            "1) When the question asks for percentage of cards with specific format and legal status: compute (number of cards without content warning) divided by (total number of cards) multiplied by 100.0, using exact format 'commander' and status 'Legal'.\n2) When counting cards without content warnings: use SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) to properly count only true cases with explicit ELSE 0.\n3) When performing floating-point division: cast the sum as REAL instead of using decimal notation for proper division.\n4) When counting total cards: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values.\n5) When combining cards and legalities tables: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match).\n6) When filtering by format and status: use exact literals 'commander' for format and 'Legal' for status with correct capitalization.\nOutput columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'commander' AND l.status = 'legal';",
            "SELECT \n    (SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    cards T1\nJOIN \n    legalities T2 ON T1.uuid = T2.uuid\nWHERE \n    T2.format = 'commander' \n    AND T2.status = 'Legal';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    cards T1\nINNER JOIN \n    legalities T2 ON T1.uuid = T2.uuid\nWHERE \n    T2.format = 'commander' \n    AND T2.status = 'Legal'"
        ]
    },
    "163": {
        "question": "Which district has the most accounts with loan contracts finished with no problems?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.A2 FROM District AS T1 INNER JOIN Account AS T2 ON T1.District_id = T2.District_id INNER JOIN Loan AS T3 ON T2.Account_id = T3.Account_id WHERE T3.status = 'A' GROUP BY T1.District_id ORDER BY COUNT(T2.Account_id) DESC LIMIT 1",
        "amends": [
            "Do select `T1.A2` instead of `d.A2 AS district_name` and remove the alias. Do use `INNER JOIN` consistently instead of mixing `JOIN` syntax. Do join `Account AS T2` on `T1.District_id = T2.District_id` instead of `d.district_id = a.district_id`. Do join `Loan AS T3` on `T2.Account_id = T3.Account_id` instead of `l.account_id = a.account_id`. Do group by `T1.District_id` instead of `d.A2` to ensure proper aggregation. Do order by `COUNT(T2.Account_id)` instead of `account_count` to reference the actual aggregate function rather than the alias. The amended query now correctly groups by district ID rather than district name, ensuring accurate counting of accounts per district for loans with status 'A', and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"district\": use T1.A2 as the district name identifier. 2) When combining District (T1) and Account (T2) tables: link rows where T1.District_id = T2.District_id and keep only matching pairs (inner match). 3) When combining Account (T2) and Loan (T3) tables: link rows where T2.Account_id = T3.Account_id and keep only matching pairs (inner match). 4) When filtering for loan contracts finished with no problems: include only rows where T3.status = 'A'. 5) When counting accounts per district: compute the number of rows using T2.Account_id as the counting key. 6) When grouping by district: organize results by T1.District_id. 7) When finding the district with the most accounts: rank districts by count of T2.Account_id in descending order and keep the first 1 row. 8) Output columns (ordered): T1.A2, COUNT(T2.Account_id)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.A2 AS district_name, COUNT(a.account_id) AS account_count\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.status = 'A'\nGROUP BY d.A2\nORDER BY account_count DESC\nLIMIT 1;",
            "SELECT T1.A2\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T2.account_id = T3.account_id\nWHERE T3.status = 'A'\nGROUP BY T1.district_id\nORDER BY COUNT(T2.account_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.A2, COUNT(T2.account_id) \nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nINNER JOIN loan T3 ON T2.account_id = T3.account_id\nWHERE T3.status = 'A'\nGROUP BY T1.district_id\nORDER BY COUNT(T2.account_id) DESC\nLIMIT 1;"
        ]
    },
    "1386": {
        "question": "What is the total expense for the Yearly Kickoff?",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'Yearly Kickoff'",
        "amends": [],
        "rules": [
            "'Yearly Kickoff' is an event name; total expense refers to SUM(cost)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(e.cost) AS total_expense\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Yearly Kickoff';"
        ],
        "rule_sql": []
    },
    "610": {
        "question": "What are the name of badge that users who have the highest reputation obtained?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` instead of `b.Name` to reference the correct table alias. Do use `INNER JOIN` with `users AS T1` and `badges AS T2` instead of `JOIN users u` and `badges b` with proper table aliasing. Do specify the join condition as `T1.Id = T2.UserId` instead of `b.UserId = u.Id` to correctly reference the primary-foreign key relationship. Do remove the subquery filter `WHERE u.Reputation = (SELECT MAX(Reputation) FROM users)` instead of keeping it, as the subquery approach is inefficient for finding maximum reputation. Do add `ORDER BY T1.Reputation DESC LIMIT 1` instead of omitting it, which directly retrieves the badge from the user with highest reputation without requiring a subquery. The amended query now correctly returns the badge name from the user with the highest reputation using an efficient top-1 approach instead of the inefficient subquery comparison."
        ],
        "rules": [
            "1) When selecting badge names: use T2.name as the output column instead of b.Name to reference the correct table alias.\n2) When joining users and badges tables: use INNER JOIN with users AS T1 and badges AS T2 with the join condition T1.Id = T2.UserId to correctly reference the primary-foreign key relationship.\n3) When finding users with highest reputation: use ORDER BY T1.Reputation DESC LIMIT 1 instead of subquery comparison for efficient top-1 retrieval.\n4) When the question asks for badge names from users with highest reputation: remove subquery filters and use direct ordering with limit.\nOutput columns (ordered): T2.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Reputation = (SELECT MAX(Reputation) FROM users);",
            "SELECT T2.Name \nFROM users AS T1 \nINNER JOIN badges AS T2 ON T1.Id = T2.UserId \nORDER BY T1.Reputation DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1"
        ]
    },
    "485": {
        "question": "When was the ruling for the card 'Reminisce' created?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Reminisce'",
        "amends": [],
        "rules": [
            "Reminisce refers to name = 'Reminisce'; when created is the date"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.date FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Reminisce';"
        ],
        "rule_sql": []
    },
    "641": {
        "question": "How many users received commentator badges in 2014?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'",
        "amends": [],
        "rules": [
            "Commentator is the name of the badge; year(Date) = 2014;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT UserId) AS NumberOfUsers\nFROM badges\nWHERE Name = 'Commentator' AND strftime('%Y', Date) = '2014';"
        ],
        "rule_sql": []
    },
    "459": {
        "question": "Which card costs more converted mana, \"Serra Angel\" or \"Shrine Keeper\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1",
        "amends": [
            "Do remove `convertedManaCost` from the SELECT list instead of including it, and do add `LIMIT 1` to the ORDER BY clause instead of omitting it, which restricts the result to only the highest convertedManaCost record among the specified cards. The amended query now matches RIGHT_SQL's behavior by returning just the name of the card with the highest converted mana cost from the given list."
        ],
        "rules": [
            "1) When the question asks which card costs more between specific named cards: select only the card name with the highest converted mana cost value. 2) When comparing specific card names: use exact string literals 'Serra Angel' and 'Shrine Keeper' with the exact case and spacing shown. 3) When ordering by converted mana cost to find the highest value: sort in descending order and keep only the top result. 4) When selecting output: include only the name column, not the convertedManaCost column used for comparison. 5) Output columns (ordered): name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, convertedManaCost FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC;",
            "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1;"
        ]
    },
    "461": {
        "question": "Please list the names of the top 3 cards with the highest converted mana cost and have a 2003 card frame style.",
        "db_id": "card_games",
        "ground_truth": "SELECT name FROM cards WHERE frameVersion = 2003 ORDER BY convertedManaCost DESC LIMIT 3",
        "amends": [],
        "rules": [
            "name of cards refers to name; 2003 card frame style refers to frameVersion = '2003'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE frameVersion = '2003' ORDER BY convertedManaCost DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "555": {
        "question": "What is the average score of the posts owned by the user csgillespie?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT AVG(T1.Score) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; average score refers to AVG(Score)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(p.Score) AS AverageScore\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';"
        ],
        "rule_sql": []
    },
    "1342": {
        "question": "What was the cost for the \"Posters\" on 2019/9/4?",
        "db_id": "student_club",
        "ground_truth": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04'",
        "amends": [
            "Do select only `cost` instead of `SUM(e.cost) AS total_cost` with aggregation. Do use `FROM expense` alone instead of joining with `budget` and `event` tables. Do filter directly on `expense_description = 'Posters'` and `expense_date = '2019-09-04'` instead of filtering through joined tables on `event_name` and `event_date`. Do remove the unnecessary joins and aggregation to query the expense table directly with the appropriate filters, matching the correct query behavior."
        ],
        "rules": [
            "1) When the question asks for cost information about \"Posters\" on a specific date: query the expense table directly without joining to other tables. 2) When filtering for expense description: use exact literal matching with expense_description = 'Posters'. 3) When filtering for date: use exact literal matching with expense_date = '2019-09-04'. 4) When selecting cost values: return individual cost values without aggregation using the column cost. 5) Output columns (ordered): cost"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(e.cost) AS total_cost\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Posters' AND ev.event_date = '2019-09-04';",
            "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04';"
        ],
        "rule_sql": [
            "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04'"
        ]
    },
    "128": {
        "question": "List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "db_id": "financial",
        "ground_truth": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 9",
        "amends": [
            "Do join `client` directly to `district` on `district_id` instead of joining through `disp` and `account` tables. Do use `COUNT(T1.client_id)` instead of `COUNT(*)` to count only female clients. Do group by both `T2.district_id` and `T2.A2` instead of only `d.A2` to ensure proper aggregation. Do reference `T1.client_id` in the COUNT instead of using the asterisk to avoid counting duplicate records from unnecessary joins. Do remove the intermediate table joins that were incorrectly filtering the dataset, as the relationship between client and district is direct through district_id rather than through account relationships.",
            "Do use `T2.A2` and `COUNT(T1.client_id)` in the SELECT list instead of `d.district_id, d.A2` and `COUNT(c.client_id) AS female_account_holders`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do use table aliases `T1` and `T2` instead of `c` and `d`. Do reference `T2.district_id` and `T2.A2` in GROUP BY instead of `d.district_id, d.A2`. Do order by `COUNT(T1.client_id) DESC` instead of the alias `female_account_holders DESC`. The amended query now correctly matches the RIGHT_SQL's behavior.",
            "Do remove `T2.district_id` from the SELECT list instead of including it, while keeping `T2.A2` and the aggregate function. Do maintain the same `INNER JOIN` on `T1.district_id = T2.district_id` instead of changing the join condition. Do preserve the `WHERE T1.gender = 'F'` filter instead of altering it. Do keep the same `GROUP BY T2.district_id, T2.A2` clause instead of modifying the grouping. Do maintain the `ORDER BY COUNT(T1.client_id) DESC` and `LIMIT 9` instead of changing the sorting or limiting. The amended query now correctly focuses on district names rather than IDs while maintaining the same join logic, filtering, grouping, and result ordering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"top nine districts by descending order\": rank districts by the number of female account holders in descending order and keep the first 9 rows.\n2) When counting female account holders: compute the number of rows using T1.client_id as the counting key for female clients only.\n3) When grouping by district: organize results by both T2.district_id and T2.A2 to ensure proper aggregation.\n4) When combining client and district tables: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match).\n5) When filtering for female clients: include only rows where T1.gender = 'F' exactly as specified.\n6) Output columns (ordered): T2.A2 as district_name, COUNT(T1.client_id) as female_account_holders",
            "1) When the question asks for \"top nine districts\": rank rows by the count of female account holders in descending order and keep the first 9 rows.\n2) When counting female account holders: count the number of rows where T1.gender equals 'F' using T1.client_id as the counting key.\n3) When combining T1 and T2 for shared entities: link rows where T1.district_id equals T2.district_id exactly; keep only matching pairs (inner match).\n4) When grouping by district: organize results by T2.district_id and T2.A2 and compute the count per group.\n5) When ordering results: sort by the count of T1.client_id in descending order.\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.\n7) When handling text literals: do not change case, spacing, or punctuation for 'F'.\n8) When referring to table roles: do not rename or swap the aliases T1 and T2 once set for this schema.\n9) When combining tables specified as an inner match: do not perform outer matches or cartesian combinations.\nOutput columns (ordered): T2.A2, COUNT(T1.client_id)",
            "1) When the question asks for \"top nine districts\" by a count: rank rows by the count in descending order and keep the first 9 rows.\n2) When counting female account holders: count rows where T1.gender equals 'F' using T1.client_id as the counting key.\n3) When the question asks for districts by name: include T2.A2 in the output instead of T2.district_id.\n4) When grouping by district: organize results by T2.district_id and T2.A2 together.\n5) When combining client and district tables: link rows where T1.district_id equals T2.district_id and keep only matching pairs.\n6) Output columns (ordered): T2.A2, COUNT(T1.client_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.A2 AS district_name, COUNT(*) AS female_account_holders\nFROM client c\nJOIN disp dp ON c.client_id = dp.client_id\nJOIN account a ON dp.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE c.gender = 'F'\nGROUP BY d.A2\nORDER BY female_account_holders DESC\nLIMIT 9;",
            "SELECT d.district_id, d.A2, COUNT(c.client_id) AS female_account_holders\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.gender = 'F'\nGROUP BY d.district_id, d.A2\nORDER BY female_account_holders DESC\nLIMIT 9;",
            "SELECT T2.district_id, T2.A2, COUNT(T1.client_id) AS female_account_holders\nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\nGROUP BY T2.district_id, T2.A2\nORDER BY COUNT(T1.client_id) DESC\nLIMIT 9",
            "SELECT T2.A2, COUNT(T1.client_id) AS female_account_holders\nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\nGROUP BY T2.district_id, T2.A2\nORDER BY COUNT(T1.client_id) DESC\nLIMIT 9"
        ],
        "rule_sql": [
            "SELECT T2.A2, COUNT(T1.client_id) \nFROM client T1 \nINNER JOIN district T2 ON T1.district_id = T2.district_id \nWHERE T1.gender = 'F' \nGROUP BY T2.district_id, T2.A2 \nORDER BY COUNT(T1.client_id) DESC \nLIMIT 9"
        ]
    },
    "1254": {
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND  strftime('%Y',  T1.`First Date`) > '1990'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use `BETWEEN 80 AND 500` instead of separate `L.IGA > 80 AND L.IGA < 500` conditions for the IGA range filter. Do use `strftime('%Y', T1.First Date) > '1990'` instead of `YEAR(P.First Date) >= 1990` to extract the year and compare as string with proper SQLite date function. Do use table aliases `T1` and `T2` consistently instead of `P` and `L` for better readability. The amended query now correctly counts patients with IGA values in the 80-500 range who had their first date after 1990, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs.\n2) When joining tables: use INNER JOIN to explicitly specify inner matching between tables.\n3) When filtering for normal Ig A levels between 80 and 500: use BETWEEN 80 AND 500 for the IGA range filter.\n4) When filtering for dates after 1990/1/1: use strftime('%Y', T1.First Date) > '1990' to extract the year and compare as string.\n5) When using table aliases: use T1 for the Patient table and T2 for the Laboratory table consistently.\n6) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\nOutput columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.IGA > 80 AND L.IGA < 500 \nAND YEAR(P.`First Date`) >= 1990;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGA BETWEEN 80 AND 500\nAND strftime('%Y', T1.\"First Date\") > '1990'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGA BETWEEN 80 AND 500\nAND strftime('%Y', T1.First Date) > '1990'"
        ]
    },
    "1362": {
        "question": "How many cities are there in Orange County, Virginia?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia'",
        "amends": [],
        "rules": [
            "Orange County is the county name, Virginia is the state name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia';"
        ],
        "rule_sql": []
    },
    "15": {
        "question": "Which active district has the highest average score in Reading?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1",
        "amends": [
            "Do select only `District` instead of selecting both `District` and `AVG(sc.AvgScrRead)` with an alias. Do use `INNER JOIN` instead of just `JOIN` while keeping the same join condition `T1.CDSCode = T2.cds`. Do remove the filter `sc.rtype = 'D'` instead of keeping it. Do remove the `GROUP BY s.District` clause instead of including it. Do order by `T2.AvgScrRead` directly instead of ordering by the computed average alias. The amended query now correctly returns the district with the highest reading score from active schools without unnecessary aggregation and filtering."
        ],
        "rules": [
            "1) When the question asks for the highest average score in Reading: order rows by T2.AvgScrRead in descending direction and keep the first 1 row.\n2) When filtering for active schools: include only rows where T1.StatusType equals 'Active' exactly.\n3) When combining schools and satscores tables: link rows where T1.CDSCode equals T2.cds exactly and keep only matching pairs (inner match).\n4) When selecting output columns: return only T1.District as the result.\n5) Output columns (ordered): T1.District"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.District, AVG(sc.AvgScrRead) AS AvgReadingScore\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.StatusType = 'Active' AND sc.rtype = 'D'\nGROUP BY s.District\nORDER BY AvgReadingScore DESC\nLIMIT 1;",
            "SELECT s.District \nFROM schools s\nINNER JOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.StatusType = 'Active'\nORDER BY sc.AvgScrRead DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.District\nFROM schools T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nWHERE T1.StatusType = 'Active'\nORDER BY T2.AvgScrRead DESC\nLIMIT 1"
        ]
    },
    "1508": {
        "question": "How many transactions taken place in the gas station in the Czech Republic are with a price of over 1000?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND T1.Price > 1000",
        "amends": [],
        "rules": [
            "Gas station in the Czech Republic implies that Country = 'CZE'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE' AND t.Price > 1000;"
        ],
        "rule_sql": []
    },
    "1485": {
        "question": "How much more was customer 7 consuming in April 2013 than customer 5?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0)) FROM yearmonth WHERE Date = '201304'",
        "amends": [],
        "rules": [
            "April 2013 refers to 201304 in the yearmonth.date"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT Consumption FROM yearmonth WHERE CustomerID = 7 AND Date = '201304') - \n    (SELECT Consumption FROM yearmonth WHERE CustomerID = 5 AND Date = '201304') AS ConsumptionDifference;"
        ],
        "rule_sql": []
    },
    "604": {
        "question": "What is the average of the up votes and the average user age for users creating more than 10 posts?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT AVG(T1.UpVotes), AVG(T1.Age) FROM users AS T1 INNER JOIN ( SELECT OwnerUserId, COUNT(*) AS post_count FROM posts GROUP BY OwnerUserId HAVING post_count > 10) AS T2 ON T1.Id = T2.OwnerUserId",
        "amends": [],
        "rules": [
            "creating more than 10 post refers to Count (UserId) > 10; average of the up votes = Divide (Sum(UpVotes), Count (UserId)); average age = Divide (Sum(Age), Count(UserId))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(u.UpVotes) AS average_up_votes, AVG(u.Age) AS average_user_age\nFROM users u\nJOIN (\n    SELECT OwnerUserId, COUNT(*) AS post_count\n    FROM posts\n    GROUP BY OwnerUserId\n    HAVING COUNT(*) > 10\n) p ON u.Id = p.OwnerUserId;"
        ],
        "rule_sql": []
    },
    "331": {
        "question": "How many of the molecules are carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecule WHERE label = '+';"
        ],
        "rule_sql": []
    },
    "351": {
        "question": "Name all the cards which have alternative language in Japanese.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'",
        "amends": [],
        "rules": [
            "Japanese' is the language;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.name FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Japanese';"
        ],
        "rule_sql": []
    },
    "497": {
        "question": "List the expansion type of the set \"Huiti\u00e8me \u00e9dition\".",
        "db_id": "card_games",
        "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition' )",
        "amends": [],
        "rules": [
            "the set \"Huiti\u00e8me \u00e9dition\" refers to translation = 'Huiti\u00e8me \u00e9dition'; expansion type refers to type"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.type \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Huiti\u00e8me \u00e9dition';"
        ],
        "rule_sql": []
    },
    "161": {
        "question": "What type of credit card does the client with the id 13539 own?",
        "db_id": "financial",
        "ground_truth": "SELECT T3.type FROM disp AS T1 INNER JOIN client AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T1.disp_id = T3.disp_id WHERE T2.client_id = 13539",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.type \nFROM card c \nJOIN disp d ON c.disp_id = d.disp_id \nWHERE d.client_id = 13539;"
        ],
        "rule_sql": []
    },
    "214": {
        "question": "What type of label is not on molecules with atoms with tin?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "amends": [],
        "rules": [
            "tin refers to element ! = 'sn'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.label\nFROM molecule m\nWHERE m.molecule_id NOT IN (\n  SELECT a.molecule_id\n  FROM atom a\n  WHERE a.element = 'tin'\n);"
        ],
        "rule_sql": []
    },
    "148": {
        "question": "Please list the accounts whose district is Tabor that are eligible for loans.",
        "db_id": "financial",
        "ground_truth": "SELECT T2.account_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'OWNER' AND T1.A2 = 'Tabor'",
        "amends": [],
        "rules": [
            "District refers to column A2; when the account type = 'OWNER', it's eligible for loans"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.account_id\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nJOIN disp dp ON a.account_id = dp.account_id\nWHERE d.A2 = 'Tabor' AND dp.type = 'OWNER';"
        ],
        "rule_sql": []
    },
    "450": {
        "question": "Of all the cards that are designed by Aaron Miller, how many of them are incredibly powerful?",
        "db_id": "card_games",
        "ground_truth": "SELECT SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) FROM cards",
        "amends": [],
        "rules": [
            "designed by Aaron Miller refers to artist = 'Aaron Miller'; are icredibily powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'Aaron Miller' \nAND cardKingdomFoilId IS NOT NULL \nAND cardKingdomId IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "255": {
        "question": "What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.",
        "db_id": "toxicology",
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id),5) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'",
        "amends": [],
        "rules": [
            "single bond refers to bond_type = '-'; label = '+' mean molecules are carcinogenic; proportion = DIVIDE(SUM(label = '+') * 100, COUNT(bond_id)) where bond_type = '-'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    ROUND((SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100.0) / COUNT(b.bond_id), 5) AS proportion\nFROM \n    bond b\nJOIN \n    molecule m ON b.molecule_id = m.molecule_id\nWHERE \n    b.bond_type = '-';"
        ],
        "rule_sql": []
    },
    "747": {
        "question": "What is the total number of superheroes without full name?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL",
        "amends": [],
        "rules": [
            "superheroes without full name refers to full_name IS NULL"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superhero WHERE full_name IS NULL;"
        ],
        "rule_sql": []
    },
    "1433": {
        "question": "Which countries have zip codes with post office boxes?",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL",
        "amends": [
            "Do add `AND county IS NOT NULL` to the WHERE clause instead of omitting this null check, ensuring only non-null county values are returned while preserving the DISTINCT selection from the zip_code table where type equals 'PO Box'. The amended query now matches RIGHT_SQL's behavior by excluding null county entries from the result set."
        ],
        "rules": [
            "1) When the question asks for countries with zip codes of type 'PO Box': select from the zip_code table where type equals exactly 'PO Box'.\n2) When selecting distinct county values: ensure only unique county values are returned using DISTINCT.\n3) When handling null values in county column: exclude rows where county is NULL by adding county IS NOT NULL condition.\n4) Output columns (ordered): county"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box';",
            "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL ORDER BY county;"
        ]
    },
    "458": {
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards",
        "amends": [
            "Do use a conditional COUNT with `CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END` instead of COUNT(DISTINCT artist) with separate LIKE conditions. Do combine the availability check into a single pattern `'%arena,mtgo%'` instead of separate `LIKE '%arena%'` and `LIKE '%mtgo%'` conditions. Do remove the artist column reference and DISTINCT aggregation instead of counting distinct artists. Do eliminate the alias `artist_count` instead of keeping it. The amended query now correctly counts cards where availability contains both arena and mtgo together in a comma-separated format with black border color, matching the RIGHT_SQL's behavior.",
            "Do remove `DISTINCT` from the aggregate function instead of keeping it, as the COUNT function inherently handles uniqueness when counting non-null values. Do change the CASE expression to return `1` instead of `artist` when conditions are met, since we want to count occurrences rather than distinct artist values. Do keep the same `LIKE '%arena,mtgo%'` and `borderColor = 'black'` conditions in the WHERE clause logic instead of changing them. The amended query now correctly counts all matching rows rather than distinct artists, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a count of artists with specific card attributes: use a conditional count that evaluates to 1 when both conditions are met, otherwise null, instead of counting distinct artist values.\n2) When checking for availability containing both \"arena\" and \"mtgo\": use a single pattern match '%arena,mtgo%' instead of separate LIKE conditions for each value.\n3) When filtering for black border color: use the exact literal 'black' for the borderColor comparison.\n4) When producing output: do not include column aliases in the final result.\n5) Output columns (ordered): COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END)",
            "1) When counting rows that meet specific conditions: use COUNT with a CASE expression that returns 1 when conditions are met instead of returning the column value itself.\n2) When checking for multiple values in a text column: use LIKE '%value1,value2%' pattern matching to find rows containing both values in the specified order.\n3) When filtering for exact color matches: use exact equality comparison with the literal 'black' for borderColor.\n4) When the COUNT function is used: do not include DISTINCT within the aggregate function as COUNT inherently handles non-null values.\n5) Output columns (ordered): COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT artist) AS artist_count\nFROM cards\nWHERE borderColor = 'black'\nAND availability LIKE '%arena%'\nAND availability LIKE '%mtgo%';",
            "SELECT COUNT(DISTINCT CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN artist ELSE NULL END) FROM cards;",
            "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards;"
        ],
        "rule_sql": [
            "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards;"
        ]
    },
    "137": {
        "question": "How many accounts have running contracts in Branch location 1?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
        "amends": [],
        "rules": [
            "Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS number_of_accounts\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE a.district_id = 1 AND (l.status = 'C' OR l.status = 'D');"
        ],
        "rule_sql": []
    },
    "725": {
        "question": "How many superheroes are published by Marvel Comics?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "amends": [],
        "rules": [
            "published by Marvel Comics refers to publisher_name = 'Marvel Comics'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');"
        ],
        "rule_sql": []
    },
    "296": {
        "question": "Indicate the molecule id is belonging to the TR000_1_2 bond that has the first atom named TR000_1.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.molecule_id, T2.bond_id, T1.atom_id FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'",
        "amends": [
            "Do select `T2.molecule_id, T2.bond_id, T1.atom_id` instead of only `b.molecule_id`. Do use explicit table aliases `AS T1` and `AS T2` instead of implicit `c` and `b`. Do specify `INNER JOIN` instead of just `JOIN`. Do place the `WHERE` condition `T1.atom_id = 'TR000_1'` before `T2.bond_id = 'TR000_1_2'` instead of the reverse order. The amended query now correctly returns all three relevant columns with proper table references and maintains the same join logic and filtering conditions."
        ],
        "rules": [
            "1) When selecting columns from multiple joined tables: include all relevant column identifiers with their explicit table aliases as T2.molecule_id, T2.bond_id, T1.atom_id. 2) When joining tables connected and bond: use explicit table aliases AS T1 for connected and AS T2 for bond. 3) When performing table joins: specify INNER JOIN to indicate only matching rows should be included. 4) When filtering on multiple conditions with atom_id and bond_id: place the condition T1.atom_id = 'TR000_1' before T2.bond_id = 'TR000_1_2' in the WHERE clause. 5) When joining T1 and T2: link rows where T1.bond_id equals T2.bond_id exactly. 6) When handling text literals: preserve exact case and formatting as shown in 'TR000_1_2' and 'TR000_1'. Output columns (ordered): T2.molecule_id, T2.bond_id, T1.atom_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.molecule_id\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE c.bond_id = 'TR000_1_2' AND c.atom_id = 'TR000_1';",
            "SELECT T2.molecule_id, T2.bond_id, T1.atom_id\nFROM connected AS T1\nINNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.atom_id = 'TR000_1'\nAND T2.bond_id = 'TR000_1_2'"
        ],
        "rule_sql": [
            "SELECT T2.molecule_id, T2.bond_id, T1.atom_id\nFROM connected AS T1\nINNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'"
        ]
    },
    "1249": {
        "question": "Please list the disease names of the patients that have a proteinuria level higher than normal.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` >= 30",
        "amends": [],
        "rules": [
            "disease names refers to Diagnosis; proteinuria level higher than normal refers to `U-PRO` > = 30;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.\"U-PRO\" >= 30;"
        ],
        "rule_sql": []
    },
    "400": {
        "question": "Lists the set code of all cards translated into Spanish.",
        "db_id": "card_games",
        "ground_truth": "SELECT setCode FROM set_translations WHERE language = 'Spanish'",
        "amends": [],
        "rules": [
            "Spanish refer to language; set code refers to setCode"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT setCode \nFROM set_translations \nWHERE language = 'Spanish';"
        ],
        "rule_sql": []
    },
    "463": {
        "question": "How many translations are there for the set of cards with \"Angel of Mercy\" in it?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(DISTINCT translation) FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Angel of Mercy' ) AND translation IS NOT NULL",
        "amends": [
            "Do use `COUNT(DISTINCT translation)` instead of `COUNT(*)` to count unique translations rather than all rows. Do add `AND translation IS NOT NULL` instead of omitting it to exclude null translation values. Do keep the same subquery structure for the `IN` clause with `SELECT setCode FROM cards WHERE name = 'Angel of Mercy'` without changes. The amended query now correctly counts distinct non-null translations for the specified card set."
        ],
        "rules": [
            "1) When counting translations: count distinct values of the \"translation\" column rather than counting all rows. 2) When handling translation values: exclude rows where \"translation\" is null. 3) When filtering for cards with specific names: use the exact literal 'Angel of Mercy' to match card names. 4) When relating cards to set translations: use the setCode column to link cards with their translations. 5) Output columns (ordered): translation_count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS translation_count\nFROM set_translations\nWHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy');",
            "SELECT COUNT(DISTINCT translation) \nFROM set_translations \nWHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy') \nAND translation IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT st.translation) AS translation_count\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE c.name = 'Angel of Mercy'\nAND st.translation IS NOT NULL;"
        ]
    },
    "232": {
        "question": "Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id LIMIT 3",
        "amends": [],
        "rules": [
            "label = '-' means molecules are not carcinogenic; single type bond refers to bond_type = '-'; list top three molecules refers to return molecule_id and order by molecule_id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.molecule_id\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE m.label = '-' AND b.bond_type = '-'\nORDER BY m.molecule_id\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "796": {
        "question": "State all of 3-D Man's attributes along with their values.",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.attribute_name, T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = '3-D Man'",
        "amends": [],
        "rules": [
            "3-D Man is the superhero_name. attributes refers to attribute_name; values refers to attribute_value;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.attribute_name, ha.attribute_value\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE s.superhero_name = '3-D Man';"
        ],
        "rule_sql": []
    },
    "92": {
        "question": "List out the no. of districts that have female average salary is more than 6000 but less than 10000?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(DISTINCT T2.district_id)  FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A11 BETWEEN 6000 AND 10000",
        "amends": [],
        "rules": [
            "A11 refers to average salary; Female mapps to gender = 'F'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT d.district_id) AS number_of_districts\nFROM district d\nJOIN client c ON d.district_id = c.district_id\nWHERE c.gender = 'F' AND d.A11 > 6000 AND d.A11 < 10000;"
        ],
        "rule_sql": []
    },
    "729": {
        "question": "What is the average height of the superheroes from Marvel Comics?",
        "db_id": "superhero",
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "amends": [],
        "rules": [
            "superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; average height of the superheroes refers to AVG(height_cm)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height_cm) AS average_height\nFROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel Comics';"
        ],
        "rule_sql": []
    },
    "238": {
        "question": "How many molecules have a triple bond type?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.bond_type = '#'",
        "amends": [],
        "rules": [
            "triple bond refers to bond_type = '#';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT molecule_id) FROM bond WHERE bond_type = '#';"
        ],
        "rule_sql": []
    },
    "189": {
        "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
        "db_id": "financial",
        "ground_truth": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Female refers to 'F' in the gender; A11 contains information about average salary"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH oldest_female_clients AS (\n    SELECT c.client_id, c.birth_date, d.A11 AS average_salary\n    FROM client c\n    JOIN district d ON c.district_id = d.district_id\n    WHERE c.gender = 'F'\n    ORDER BY c.birth_date ASC, d.A11 ASC\n    LIMIT 1\n)\nSELECT a.account_id\nFROM oldest_female_clients ofc\nJOIN disp dp ON ofc.client_id = dp.client_id\nJOIN account a ON dp.account_id = a.account_id;"
        ],
        "rule_sql": []
    },
    "1219": {
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "amends": [
            "Do use a direct `INNER JOIN` between `Patient` and `Laboratory` instead of a CTE with window functions. Do place the sex-specific UA threshold conditions directly in the `WHERE` clause instead of filtering after window numbering. Do remove the `ROW_NUMBER()` window function and instead use a subquery to find the `MAX(Date)` for each patient in the `WHERE` condition instead of filtering by row number. Do reference `T2.UA` directly in the `AVG()` function instead of using a CTE-derived column. Do ensure the date filter uses equality with the maximum date subquery instead of relying on window function ordering. The amended query now correctly calculates the average UA value for patients' most recent lab results based on sex-specific thresholds.",
            "Do use table aliases `T1` and `T2` instead of full table names. Do change the WHERE clause to use explicit OR conditions with `T2.UA < 6.5 AND T1.SEX = 'F'` and `T2.UA < 8.0 AND T1.SEX = 'M'` instead of the CASE statement with BETWEEN ranges. Do remove the ELSE condition from the CASE statement instead of keeping it. Do simplify the subquery by removing the WHERE ID = P.ID correlation instead of maintaining it. The amended query now correctly filters UA values based on sex-specific thresholds and matches the RIGHT_SQL's behavior.",
            "Do remove the alias `average_ua` from the `AVG` aggregate instead of keeping it. Do move the `T2.Date` subquery filter to the end of the `WHERE` clause instead of placing it at the beginning. Do remove the correlation `WHERE ID = T1.ID` from the subquery instead of keeping it, making the subquery independent. Do adjust the parentheses grouping in the `WHERE` clause to properly associate the gender-specific UA thresholds with their respective conditions instead of the previous grouping that could cause logical ambiguity. The amended query now correctly calculates the average UA values without the unnecessary correlation in the subquery and with proper logical grouping of conditions.",
            "Do remove the correlated subquery condition `WHERE ID = T1.ID` from the `MAX(Date)` subquery instead of keeping it, making the subquery uncorrelated to find the global maximum date across all Laboratory records rather than per-patient maximum. Do ensure the WHERE clause properly groups the conditions with parentheses to maintain the intended logic of filtering by sex-specific UA thresholds and the global maximum date. The amended query now correctly calculates the average UA value for patients meeting sex-specific UA thresholds at the overall maximum laboratory date across all patients, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for patients with normal uric acid (UA): apply sex-specific UA threshold conditions where (T2.SEX = 'M' AND T1.UA < 8.0) OR (T2.SEX = 'F' AND T1.UA < 6.5).\n2) When finding the latest laboratory examination result: for each patient, use the maximum Date value from Laboratory table to identify the most recent result.\n3) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner join to ensure matching patient records.\n4) When calculating average UA index: compute the average of T1.UA values for the filtered results.\n5) When handling date-based filtering: use equality comparison with the maximum date subquery instead of window function ordering to identify latest results.\n6) Output columns (ordered): AVG(T1.UA) as AverageUAIndex",
            "1) When filtering for patients with normal uric acid levels: use sex-specific thresholds where T2.UA < 6.5 AND T1.SEX = 'F' for female patients and T2.UA < 8.0 AND T1.SEX = 'M' for male patients, connected with OR conditions.\n2) When joining Patient and Laboratory tables: link rows where T1.ID = T2.ID to match patient records with their laboratory results.\n3) When selecting the latest laboratory examination result: use the maximum Date value from the Laboratory table without correlating by patient ID.\n4) When computing average UA index: calculate the average of T2.UA values for patients meeting the normal uric acid criteria.\n5) Output columns (ordered): average_ua",
            "1) When the question asks for average UA index: compute the average of T2.UA values.\n2) When filtering for patients with normal uric acid: apply gender-specific thresholds where for female patients (T1.SEX = 'F'), UA must be less than 6.5, and for male patients (T1.SEX = 'M'), UA must be less than 8.0.\n3) When selecting the latest laboratory examination result: filter to include only rows where T2.Date equals the maximum Date from the Laboratory table.\n4) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match).\n5) When organizing the WHERE clause: place the date subquery filter at the end of the conditions instead of at the beginning.\n6) When using subqueries for maximum date: make the subquery independent without correlation to the outer query.\n7) When grouping conditions with parentheses: properly associate gender-specific UA thresholds with their respective gender conditions to avoid logical ambiguity.\n8) When producing output: do not include an alias for the average calculation.\nOutput columns (ordered): AVG(T2.UA)",
            "1) When the question asks for patients with normal uric acid (UA): filter patients using sex-specific UA thresholds where female patients have UA < 6.5 and male patients have UA < 8.0.\n2) When calculating average UA index based on latest laboratory examination result: use the global maximum date across all Laboratory records rather than per-patient maximum dates.\n3) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n4) When filtering by laboratory date: use the overall maximum date from the Laboratory table without correlation to individual patients.\n5) When grouping conditions with multiple criteria: use proper parentheses to maintain the intended logic of filtering by both sex-specific UA thresholds and the global maximum date.\nOutput columns (ordered): AVG(T2.UA)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH LatestLabResults AS (\n    SELECT \n        L.ID,\n        L.UA,\n        P.SEX,\n        ROW_NUMBER() OVER (PARTITION BY L.ID ORDER BY L.Date DESC) AS rn\n    FROM \n        Laboratory L\n    JOIN \n        Patient P ON L.ID = P.ID\n    WHERE \n        (P.SEX = 'M' AND L.UA < 8.0) OR (P.SEX = 'F' AND L.UA < 6.5)\n)\nSELECT AVG(UA) AS AverageUAIndex\nFROM LatestLabResults\nWHERE rn = 1;",
            "SELECT AVG(L.UA) AS average_ua\nFROM Patient P\nINNER JOIN Laboratory L ON P.ID = L.ID\nWHERE L.UA BETWEEN \n    CASE \n        WHEN P.SEX = 'M' THEN 3.7 AND 7.0\n        WHEN P.SEX = 'F' THEN 2.5 AND 5.7\n        ELSE L.UA\n    END\nAND L.Date = (\n    SELECT MAX(Date) \n    FROM Laboratory \n    WHERE ID = P.ID\n)",
            "SELECT AVG(T2.UA) AS average_ua\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date = (\n    SELECT MAX(Date)\n    FROM Laboratory\n    WHERE ID = T1.ID\n)\nAND (\n    (T2.UA < 6.5 AND T1.SEX = 'F') OR\n    (T2.UA < 8.0 AND T1.SEX = 'M')\n)",
            "SELECT AVG(T2.UA)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M')\nAND T2.Date = (SELECT MAX(Date) FROM Laboratory WHERE ID = T1.ID)",
            "SELECT AVG(T2.UA)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M')\nAND T2.Date = (SELECT MAX(Date) FROM Laboratory)"
        ],
        "rule_sql": [
            "SELECT AVG(T2.UA) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE ((T1.SEX = 'F' AND T2.UA < 6.5) OR (T1.SEX = 'M' AND T2.UA < 8.0))\nAND T2.Date = (SELECT MAX(Date) FROM Laboratory)"
        ]
    },
    "1002": {
        "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
        "amends": [
            "Do use `SELECT T1.forename, T1.surname, T1.nationality, T3.name` instead of `SELECT yd.full_name, yd.nationality, fr.race_name` to return individual name components and race name separately. Do use `FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId` instead of the CTE approach with `youngest_driver` and `first_race` to directly join through driver standings. Do add `ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1` instead of the complex CTE structure to find the youngest driver based on date of birth. Do remove the concatenated `full_name` and instead return `forename` and `surname` as separate columns. The amended query now correctly identifies the youngest driver through driver standings data and returns the appropriate race information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When finding the youngest racer: order drivers by date of birth in descending order using JULIANDAY(T1.dob) and take only the first row. 2) When joining driver information with race information: link drivers (T1) to driverStandings (T2) using T1.driverId = T2.driverId, then link driverStandings (T2) to races (T3) using T2.raceId = T3.raceId, keeping only matching pairs. 3) When returning name information: output forename and surname as separate columns instead of concatenating them. 4) When the question asks for nationality and race name: include T1.nationality and T3.name in the output. 5) Output columns (ordered): T1.forename, T1.surname, T1.nationality, T3.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH youngest_driver AS (\n    SELECT driverId, forename || ' ' || surname AS full_name, nationality, dob\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 1\n),\nfirst_race AS (\n    SELECT r.raceId, r.name AS race_name, ra.date\n    FROM results r\n    JOIN races ra ON r.raceId = ra.raceId\n    JOIN youngest_driver yd ON r.driverId = yd.driverId\n    ORDER BY ra.date ASC\n    LIMIT 1\n)\nSELECT yd.full_name, yd.nationality, fr.race_name\nFROM youngest_driver yd, first_race fr;",
            "SELECT T1.forename, T1.surname, T1.nationality, T3.name\nFROM drivers AS T1\nINNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T2.raceId = T3.raceId\nORDER BY JULIANDAY(T1.dob) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.forename, T1.surname, T1.nationality, T3.name\nFROM drivers T1\nJOIN driverStandings T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nORDER BY JULIANDAY(T1.dob) DESC\nLIMIT 1;"
        ]
    },
    "11": {
        "question": "Please list the codes of the schools with a total enrollment of over 500.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.CDSCode FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` + T2.`Enrollment (Ages 5-17)` > 500",
        "amends": [],
        "rules": [
            "Total enrollment can be represented by `Enrollment (K-12)` + `Enrollment (Ages 5-17)`"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT CDSCode FROM frpm WHERE (\"Enrollment (K-12)\" + \"Enrollment (Ages 5-17)\") > 500;"
        ],
        "rule_sql": []
    },
    "580": {
        "question": "Name 10 users with the badge name 'Necromancer.'",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Necromancer' LIMIT 10",
        "amends": [],
        "rules": [
            "\"Necromancer\" is the Name of badge; users refers to DisplayName"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Necromancer'\nLIMIT 10;"
        ],
        "rule_sql": []
    },
    "854": {
        "question": "What is the coordinates location of the circuits for Australian grand prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Australian Grand Prix'",
        "amends": [],
        "rules": [
            "coordinate position/location refers to lat, lng; circuits for Australian grand prix refers to races.name = 'Australian Grand Prix'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.lat, c.lng\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Australian Grand Prix';"
        ],
        "rule_sql": []
    },
    "233": {
        "question": "Please list top two bonds that happened with the molecule TR006 in alphabetical order.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.molecule_id = 'TR006' ORDER BY T2.bond_id LIMIT 2",
        "amends": [
            "Do select `T2.bond_id` instead of `bond_id, bond_type` and add `DISTINCT` instead of omitting it. Do join `atom AS T1` and `connected AS T2` with `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of querying only the `bond` table. Do filter on `T1.molecule_id = 'TR006'` instead of `molecule_id = 'TR006'` from the bond table. Do order by `T2.bond_id` instead of `bond_type ASC` while keeping the same `LIMIT 2`. The amended query now correctly retrieves distinct bond IDs from the connected table through atom relationships instead of directly from the bond table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"top two\" and requires alphabetical order: rank rows by T2.bond_id in ascending alphabetical order and keep the first 2 rows.\n2) When the question asks for bonds related to molecule TR006: filter rows where T1.molecule_id equals exactly 'TR006'.\n3) When combining atom and connected tables: link rows where T1.atom_id equals T2.atom_id exactly and keep only matching pairs (inner match).\n4) When selecting bond identifiers: use T2.bond_id and ensure distinct values are returned.\n5) Output columns (ordered): T2.bond_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_id, bond_type FROM bond WHERE molecule_id = 'TR006' ORDER BY bond_type ASC LIMIT 2;",
            "SELECT DISTINCT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.molecule_id = 'TR006'\nORDER BY T2.bond_id\nLIMIT 2"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.bond_id\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.molecule_id = 'TR006'\nORDER BY T2.bond_id ASC\nLIMIT 2"
        ]
    },
    "1332": {
        "question": "How much did the Student_Club members spend on food in September Meeting?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Food' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "amends": [],
        "rules": [
            "amount spent refers to spent; spend on food in September Meeting refers to category = 'Food' where event_name = 'September Meeting'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(b.spent) AS total_spent_on_food\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'September Meeting' AND b.category = 'Food';"
        ],
        "rule_sql": []
    },
    "748": {
        "question": "What is the eye colour of superhero with superhero ID 75?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.id = 75",
        "amends": [],
        "rules": [
            "eye colour refers to colour where eye_colour_id = colour.id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.id = 75;"
        ],
        "rule_sql": []
    },
    "371": {
        "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1",
        "amends": [
            "Do use `SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN fd.language = 'French' THEN 1 END)` to properly count French records. Do cast the sum to `REAL` instead of using `100.0` for floating-point division. Do use `INNER JOIN` instead of `LEFT JOIN` to exclude cards without foreign data. Do reference `T1.id` in `COUNT(T1.id)` instead of `COUNT(*)` to count only cards with foreign data. Do use table aliases `T1` and `T2` instead of `c` and `fd` for consistency. The amended query now correctly calculates the percentage of French cards among those with foreign data that are story spotlight cards."
        ],
        "rules": [
            "1) When calculating percentages using conditional counting: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for accurate counting. 2) When performing floating-point division for percentages: cast the numerator to REAL type instead of multiplying by 100.0. 3) When combining tables where only matching records are needed: use INNER JOIN instead of LEFT JOIN to exclude non-matching rows. 4) When counting entities in joined tables: use the canonical key from the primary table (T1.id) instead of COUNT(*) to count only valid entities. 5) When the question asks for percentage of cards with specific language among Story Spotlight cards: compute (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) cast as REAL) divided by COUNT(T1.id). 6) When combining T1 and T2 for shared entities: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match). 7) When filtering for Story Spotlight cards: include only rows where T1.isStorySpotlight = 1. Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN fd.language = 'French' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards c\nLEFT JOIN \n    foreign_data fd ON c.uuid = fd.uuid\nWHERE \n    c.isStorySpotlight = 1;",
            "SELECT \n    (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    cards T1\nINNER JOIN \n    foreign_data T2 ON T1.uuid = T2.uuid\nWHERE \n    T1.isStorySpotlight = 1;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN fd.language = 'French' THEN 1 ELSE 0 END) AS REAL) / COUNT(c.id)) * 100.0 AS percentage\nFROM \n    cards c\nINNER JOIN \n    foreign_data fd ON c.uuid = fd.uuid\nWHERE \n    c.isStorySpotlight = 1"
        ]
    },
    "1455": {
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "amends": [
            "Do select only `budget_id` instead of multiple columns including `category`, `amount`, `spent`, `remaining`, and `event_status`. Do use `INNER JOIN` with `expense AS T1` and `budget AS T2` instead of joining `budget b` with `expense e`. Do use the join condition `T1.link_to_budget = T2.budget_id` instead of `b.budget_id = e.link_to_budget`. Do keep the WHERE filter on `expense_description = 'Water, chips, cookies'` and ORDER BY `cost DESC` with LIMIT 1, but reference them through table alias `T1` instead of `e`. The amended query now correctly returns only the budget_id associated with the specified expense description, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting columns for output: return only T2.budget_id instead of multiple columns including category, amount, spent, remaining, and event_status.\n2) When combining expense and budget tables: use expense as T1 and budget as T2 with join condition T1.link_to_budget = T2.budget_id.\n3) When filtering for specific expense descriptions: keep only rows where T1.expense_description = 'Water, chips, cookies' exactly as written.\n4) When ordering results by cost: sort rows by T1.cost in descending order.\n5) When finding the budget with the most money for specified items: take only the top result after sorting by cost descending.\n6) Output columns (ordered): T2.budget_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.budget_id, b.category, b.amount, b.spent, b.remaining, b.event_status\nFROM budget b\nJOIN expense e ON b.budget_id = e.link_to_budget\nWHERE e.expense_description = 'Water, chips, cookies'\nORDER BY e.cost DESC\nLIMIT 1;",
            "SELECT T2.budget_id\nFROM expense AS T1\nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\nWHERE T1.expense_description = 'Water, chips, cookies'\nORDER BY T1.cost DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.budget_id\nFROM expense AS T1\nJOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\nWHERE T1.expense_description = 'Water, chips, cookies'\nORDER BY T1.cost DESC\nLIMIT 1;"
        ]
    },
    "860": {
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "amends": [
            "Do use `DISTINCT` on `nationality` instead of omitting it to eliminate duplicate nationalities. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `d` and `q` aliases. Do reference `T2.nationality` instead of `d.nationality` to clarify the source table. Do use `LIKE '1:40%'` for the q2 filter instead of exact match `= '0:01:40'` to capture variations in time formatting. Do maintain the same join condition `T2.driverId = T1.driverId` instead of `d.driverId = q.driverId` with corrected table reference order. The amended query now correctly identifies distinct nationalities of drivers who qualified with q2 times starting with '1:40' for race 355, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for nationality of a driver with specific qualifying time: use T2.nationality from the drivers table with DISTINCT to eliminate duplicate nationalities. 2) When filtering for qualifying time in q2 column: use LIKE '1:40%' pattern matching instead of exact equality to capture time formatting variations. 3) When combining drivers and qualifying tables: link rows where T2.driverId = T1.driverId using inner join. 4) When filtering for race number: use exact literal value 355 for raceId. 5) Output columns (ordered): T2.nationality"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.nationality\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nWHERE q.raceId = 355 AND q.q2 = '0:01:40';",
            "SELECT DISTINCT T2.nationality\nFROM qualifying T1\nINNER JOIN drivers T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.nationality\nFROM qualifying T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T1.raceId = 355\nAND T1.q2 LIKE '1:40%';"
        ]
    },
    "1236": {
        "question": "For all the female patient age 50 and above, who has abnormal red blood cell count. State if they were admitted to hospital.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND (T2.RBC <= 3.5 OR T2.RBC >= 6.0) AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50",
        "amends": [
            "Do select only `ID` and `Admission` columns instead of including `SEX`, `Birthday`, `Age`, and `RBC`. Do add `DISTINCT` to eliminate duplicate rows instead of returning all matches. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `P` and `L`. Do reference `T2.RBC` in the WHERE clause instead of `L.RBC`. Do use `CURRENT_TIMESTAMP` for the current year calculation instead of `'now'` string literal. Do remove the redundant `Age` column calculation from the SELECT list since it's only used in filtering. Do maintain the same join condition `T1.ID = T2.ID` and filter logic for female patients with abnormal RBC values aged 50 or older. The amended query now correctly returns distinct patient IDs and admission dates matching the intended result set.",
            "Do use `T1.SEX = 'F'` instead of `T1.SEX = 'female'` for gender filtering. Do replace the complex subquery condition with `T2.RBC <= 3.5 OR T2.RBC >= 6.0` instead of checking against an average value. Do remove the `T2.RBC IS NOT NULL` filter since the RBC range condition implicitly handles null exclusion. Do maintain the same `SELECT DISTINCT T1.ID, T1.Admission` column selection and `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` join structure. Do preserve the age calculation `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50` unchanged. The amended query now correctly identifies patients with abnormal RBC values rather than comparing to an average, matching the intended logic."
        ],
        "rules": [
            "1) When the question asks for patient admission status for female patients age 50+ with abnormal RBC: select only T1.ID and T1.Admission columns. 2) When eliminating duplicate patient records: use DISTINCT on the selected columns. 3) When joining Patient and Laboratory tables: use INNER JOIN with T1 as Patient and T2 as Laboratory, linking rows where T1.ID = T2.ID. 4) When filtering for female patients: include only rows where T1.SEX = 'F'. 5) When calculating age from birthday: use CURRENT_TIMESTAMP to compute age as (current year - birth year) and filter for age >= 50. 6) When identifying abnormal red blood cell count: include rows where T2.RBC <= 3.5 OR T2.RBC >= 6.0. 7) When the question only requires admission status: remove intermediate calculation columns like age and RBC values from the output. Output columns (ordered): T1.ID, T1.Admission",
            "1) When filtering by gender: use T1.SEX = 'F' instead of 'female' for exact gender matching.\n2) When identifying abnormal red blood cell count: use T2.RBC <= 3.5 OR T2.RBC >= 6.0 instead of comparing to average values.\n3) When checking for null values in RBC: do not explicitly filter for T2.RBC IS NOT NULL since the range condition implicitly excludes nulls.\n4) When calculating patient age: use STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 to identify patients 50 years and older.\n5) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID to find matching patient records.\n6) When selecting output: use DISTINCT T1.ID, T1.Admission to show unique patient identifiers and admission status.\nOutput columns (ordered): T1.ID, T1.Admission"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, P.SEX, P.Birthday, \n       (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age,\n       L.RBC, P.Admission\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'F'\n  AND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) >= 50\n  AND (L.RBC <= 3.5 OR L.RBC >= 6.0);",
            "SELECT DISTINCT T1.ID, T1.Admission\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'female'\n  AND (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday) >= 50\n  AND T2.RBC IS NOT NULL\n  AND T2.RBC < (SELECT AVG(RBC) FROM Laboratory WHERE RBC IS NOT NULL)",
            "SELECT DISTINCT T1.ID, T1.Admission\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'\nAND (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) >= 50\nAND (T2.RBC <= 3.5 OR T2.RBC >= 6.0)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.Admission\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'\nAND (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) >= 50\nAND (T2.RBC <= 3.5 OR T2.RBC >= 6.0)"
        ]
    },
    "1523": {
        "question": "Which country was the card owner of No.667467 in?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.CardID = '667467'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT g.Country \nFROM transactions_1k t \nJOIN gasstations g ON t.GasStationID = g.GasStationID \nWHERE t.CardID = 667467;"
        ],
        "rule_sql": []
    },
    "771": {
        "question": "List the name of superheroes with flight power.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Flight'",
        "amends": [],
        "rules": [
            "name of superheroes refers to superhero_name; flight power refers to power_name = 'Flight';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Flight';"
        ],
        "rule_sql": []
    },
    "1162": {
        "question": "How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(*) FROM Patient WHERE STRFTIME('%Y', Description) = '1997' AND SEX = 'F' AND Admission = '-'",
        "amends": [],
        "rules": [
            "female refers to sex = 'F'; came at the hospital in 1997 refers to year(Description) = '1997'; immediately followed at the outpatient clinic refers to Admission = '-'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM Patient \nWHERE SEX = 'F' \nAND strftime('%Y', Description) = '1997' \nAND Admission = '-';"
        ],
        "rule_sql": []
    },
    "219": {
        "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
        "amends": [
            "Do calculate the percentage of distinct `molecule_id` values where `label = '+'` instead of counting bond occurrences. Do join `atom` and `molecule` tables with `INNER JOIN` on `molecule_id` instead of only joining `molecule` and `bond`. Do add `atom` table to the FROM clause instead of omitting it. Do filter on `bond_type = '#'` in the WHERE clause instead of using it in a CASE expression. Do use `COUNT(DISTINCT molecule_id)` for both numerator and denominator instead of SUM and COUNT on bond_id. Do cast the numerator to REAL for precise division instead of using 100.0 multiplication. Do remove the bond counting logic and CASE expression instead of keeping them. The amended query now correctly calculates the percentage of distinct molecules with '+' label that have bonds of type '#', matching the RIGHT_SQL's behavior.",
            "Do calculate the percentage using `T2.molecule_id` from the molecule table instead of `m.molecule_id` from the original join structure. Do join `atom AS T1` to `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of the complex multi-table join chain involving bond, connected, and two atom tables. Do remove the unnecessary joins to `connected`, `atom a1`, and `atom a2` instead of including them. Do simplify the WHERE clause to filter only on `T3.bond_type = '#'` instead of the previous complex join conditions. Do maintain the same aggregate logic with `COUNT(DISTINCT CASE)` for percentage calculation but with corrected table references. The amended query now correctly calculates the percentage of molecules with '+' label among those containing '#' bond types by properly joining only the necessary tables."
        ],
        "rules": [
            "1) When the question asks for percentage of carcinogenic molecules: calculate the ratio of distinct molecules with label '+' that have bonds of type '#' to all distinct molecules with label '+', casting to REAL for precise division.\n2) When combining molecule and atom tables: link rows where molecule.molecule_id = atom.molecule_id using inner match.\n3) When filtering for carcinogenic molecules: include only molecules where label equals '+' exactly.\n4) When filtering for triple type bonds: include only bonds where bond_type equals '#' exactly.\n5) When counting distinct molecules: use molecule_id as the counting key for both numerator and denominator.\n6) Output columns (ordered): percentage",
            "1) When calculating percentages involving molecule carcinogenicity: use T2.molecule_id as the counting key for both numerator and denominator instead of other molecule_id references.\n2) When joining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id using an inner match.\n3) When filtering for triple type bonds: include only rows where T3.bond_type = '#' exactly as specified.\n4) When identifying carcinogenic molecules: use the exact literal '+' for T2.label in the conditional case statement.\n5) When computing percentage of carcinogenic molecules: calculate (count of distinct T2.molecule_id where T2.label = '+') divided by (count of distinct T2.molecule_id) multiplied by 100.0.\n6) When handling bond type filtering: do not include unnecessary joins to connected table or multiple atom tables.\nOutput columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN b.bond_type = '#' THEN 1 ELSE 0 END) * 100.0 / COUNT(b.bond_id)) AS percentage\nFROM \n    molecule m\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nWHERE \n    m.label = '+';",
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN m.label = '+' THEN m.molecule_id END) AS REAL) / \n     COUNT(DISTINCT m.molecule_id)) * 100.0 AS percentage\nFROM \n    molecule m\nINNER JOIN \n    bond b ON m.molecule_id = b.molecule_id\nINNER JOIN \n    connected c ON b.bond_id = c.bond_id\nINNER JOIN \n    atom a1 ON c.atom_id = a1.atom_id\nINNER JOIN \n    atom a2 ON c.atom_id2 = a2.atom_id\nWHERE \n    b.bond_type = '#'",
            "SELECT \n    (COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id END) * 100.0 / \n     COUNT(DISTINCT T2.molecule_id)) AS percentage\nFROM \n    molecule AS T2\nINNER JOIN \n    atom AS T1 ON T1.molecule_id = T2.molecule_id\nINNER JOIN \n    connected AS T4 ON T1.atom_id = T4.atom_id OR T1.atom_id = T4.atom_id2\nINNER JOIN \n    bond AS T3 ON T4.bond_id = T3.bond_id\nWHERE \n    T3.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id END) * 100.0 / \n     COUNT(DISTINCT T2.molecule_id)) AS percentage\nFROM \n    molecule T2\nINNER JOIN \n    bond T3 ON T2.molecule_id = T3.molecule_id\nWHERE \n    T3.bond_type = '#'"
        ]
    },
    "705": {
        "question": "Give the user's reputation and up vote number of the user that commented \"fine, you win :)\".",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Reputation, T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'fine, you win :)'",
        "amends": [],
        "rules": [
            "Text = 'fine, you win :)';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.Reputation, u.UpVotes\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text = 'fine, you win :)';"
        ],
        "rule_sql": []
    },
    "179": {
        "question": "How much, in total, did client number 617 pay for all of the transactions in 1998?",
        "db_id": "financial",
        "ground_truth": "SELECT SUM(T3.amount) FROM client AS T1 INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date)= '1998' AND T1.client_id = 617",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(t.amount) AS total_payment\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN trans t ON d.account_id = t.account_id\nWHERE c.client_id = 617\nAND strftime('%Y', t.date) = '1998';"
        ],
        "rule_sql": []
    },
    "156": {
        "question": "Who is the owner of the account with the largest loan amount?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.client_id FROM disp AS T1 INNER JOIN account AS T3 ON T1.account_id = T3.account_id INNER JOIN loan AS T2 ON T3.account_id = T2.account_id WHERE T1.type = 'OWNER' ORDER BY T2.amount DESC LIMIT 1",
        "amends": [
            "Do select only `client_id` instead of including `gender` and `birth_date` in the SELECT list. Do use table aliases `T1`, `T2`, and `T3` instead of `c`, `d`, `a`, and `l` for consistency. Do join `disp AS T1` directly to `account AS T3` on `T1.account_id = T3.account_id` instead of joining through `client` first. Do use `INNER JOIN` consistently instead of mixing `JOIN` without explicit type specification. Do reference `T1.type` in the WHERE clause instead of `d.type` to match the alias change. Do order by `T2.amount` instead of `l.amount` to align with the new table alias. The amended query now correctly focuses on retrieving only the client ID of the account owner with the highest loan amount, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the owner of an account: filter rows where T1.type equals exactly 'OWNER'.\n2) When combining tables for account and loan information: link rows where T1.account_id equals T3.account_id using an inner match.\n3) When combining tables for loan information: link rows where T3.account_id equals T2.account_id using an inner match.\n4) When finding the largest loan amount: order rows by T2.amount in descending order and keep only the first row.\n5) When the question asks for who owns an account: output only the client_id identifier.\nOutput columns (ordered): T1.client_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.client_id, c.gender, c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE d.type = 'OWNER'\nORDER BY l.amount DESC\nLIMIT 1;",
            "SELECT T1.client_id\nFROM disp AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nINNER JOIN account AS T3 ON T1.account_id = T3.account_id\nWHERE T1.type = 'OWNER'\nORDER BY T2.amount DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.client_id\nFROM disp AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nWHERE T1.type = 'OWNER'\nORDER BY T2.amount DESC\nLIMIT 1;"
        ]
    },
    "457": {
        "question": "Please list the websites where I can purchase the cards that have the promotional type of \"bundle\".",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
        "amends": [],
        "rules": [
            "promotional type of \"bundle\" refers to promoTypes = 'bundle'; websites refers to purchaseUrls"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT purchaseUrls FROM cards WHERE promoTypes LIKE '%bundle%';"
        ],
        "rule_sql": []
    },
    "122": {
        "question": "State the district and region for loan ID '4990'.",
        "db_id": "financial",
        "ground_truth": "SELECT T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.loan_id = 4990",
        "amends": [],
        "rules": [
            "A2, A3 contains the information about district and region respectively."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.A2 AS district, d.A3 AS region\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.loan_id = 4990;"
        ],
        "rule_sql": []
    },
    "1381": {
        "question": "List the name of students that have attended more than 7 events.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "amends": [],
        "rules": [
            "name of students means the full name; full name refers to first_name, last_name; attended more than 7 events refers to COUNT(link_to_event) > 7"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nGROUP BY m.member_id, m.first_name, m.last_name\nHAVING COUNT(a.link_to_event) > 7;"
        ],
        "rule_sql": []
    },
    "111": {
        "question": "How many accounts were opened in Litomerice in 1996?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1996' AND T1.A2 = 'Litomerice'",
        "amends": [],
        "rules": [
            "A2 refers to district name; Litomerice is one of district names."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM account \nJOIN district ON account.district_id = district.district_id \nWHERE district.A2 = 'Litomerice' \nAND strftime('%Y', account.date) = '1996';"
        ],
        "rule_sql": []
    },
    "1327": {
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "amends": [
            "Do select individual columns `first_name` and `last_name` instead of concatenating them with `|| ' ' ||` into a single `full_name` alias. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for both table joins. Do use table aliases `T1`, `T2`, and `T3` instead of single-letter aliases `m`, `a`, and `e`. The amended query now correctly returns separate first and last name columns while maintaining the same join logic and filtering condition."
        ],
        "rules": [
            "1) When selecting names from the member table: output separate first_name and last_name columns instead of concatenating them into a single full_name column.\n2) When joining tables for attendance and event information: use explicit INNER JOIN syntax with table aliases T1 for member, T2 for attendance, and T3 for event.\n3) When filtering for a specific event: use the exact literal 'Laugh Out Loud' for the event_name condition with T3.event_name.\n4) When linking member to attendance: use T1.member_id = T2.link_to_member as the join condition.\n5) When linking attendance to event: use T2.link_to_event = T3.event_id as the join condition.\n6) Output columns (ordered): T1.first_name, T1.last_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Laugh Out Loud';",
            "SELECT T1.first_name, T1.last_name\nFROM member T1\nINNER JOIN attendance T2 ON T1.member_id = T2.link_to_member\nINNER JOIN event T3 ON T2.link_to_event = T3.event_id\nWHERE T3.event_name = 'Laugh Out Loud';"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member\nINNER JOIN event AS T3 ON T2.link_to_event = T3.event_id\nWHERE T3.event_name = 'Laugh Out Loud';"
        ]
    },
    "808": {
        "question": "Find the race of the superhero who weighs 108kg and is 188cm tall.",
        "db_id": "superhero",
        "ground_truth": "SELECT DISTINCT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 108 AND T1.height_cm = 188",
        "amends": [],
        "rules": [
            "weighs 108kg refers to weight_kg = 108; 188cm tall refers to height_cm = 188;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.weight_kg = 108 AND s.height_cm = 188;"
        ],
        "rule_sql": []
    },
    "10": {
        "question": "For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1",
        "amends": [
            "Do select `FRPM Count (Ages 5-17)` from `frpm` instead of from `satscores`. Do use `INNER JOIN` with `T1.cds = T2.CDSCode` instead of `JOIN` with `f.CDSCode = s.cds`. Do remove the subquery filter `WHERE s.AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores)` instead of keeping it. Do add `ORDER BY T1.AvgScrRead DESC` instead of omitting it. Do add `LIMIT 1` instead of omitting it. The amended query now correctly retrieves the single highest-scoring record by sorting and limiting rather than using a subquery comparison."
        ],
        "rules": [
            "1) When the question asks for the school with the highest average score in Reading: rank rows by T1.AvgScrRead in descending order and keep the first 1 row.\n2) When combining T1 (satscores) and T2 (frpm) for shared entities: link rows where T1.cds = T2.CDSCode exactly as shown; keep only matching pairs (inner match).\n3) When the question asks for FRPM count for students aged 5-17: select the exact column T2.\"FRPM Count (Ages 5-17)\" from the frpm table.\n4) Output columns (ordered): T2.\"FRPM Count (Ages 5-17)\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.\"FRPM Count (Ages 5-17)\"\nFROM frpm f\nJOIN satscores s ON f.CDSCode = s.cds\nWHERE s.AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores);",
            "SELECT f.\"FRPM Count (Ages 5-17)\"\nFROM satscores s\nINNER JOIN frpm f ON s.cds = f.CDSCode\nORDER BY s.AvgScrRead DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.\"FRPM Count (Ages 5-17)\"\nFROM satscores T1\nINNER JOIN frpm T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrRead DESC\nLIMIT 1"
        ]
    },
    "605": {
        "question": "How many users obtained the \"Announcer\" badge?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE Name = 'Announcer'",
        "amends": [
            "Do count `id` instead of `DISTINCT UserId` to count all badge instances rather than unique users, since multiple users can have the same badge type. Do remove the `DISTINCT` modifier instead of keeping it to avoid unnecessary deduplication when counting total badge occurrences. The amended query now correctly counts all Announcer badges rather than unique users who have them, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for count of badge instances: count all rows using the exact token \"id\" as the counting key. 2) When the question specifies a badge name \"Announcer\": filter rows where the exact token \"Name\" equals the exact literal 'Announcer' (case-sensitive). 3) When counting badge instances: do not apply distinct modifiers to avoid unnecessary deduplication of badge occurrences. 4) Output columns (ordered): COUNT(id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Announcer';",
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Announcer';"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Announcer'"
        ]
    },
    "438": {
        "question": "Point out the language of set id \"174\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT language FROM set_translations WHERE id = 174",
        "amends": [
            "Do select only `language` instead of `st.language` with table alias. Do remove the `JOIN sets s ON st.setCode = s.code` clause instead of including an unnecessary join to the sets table. Do change the filter to `WHERE id = 174` instead of `WHERE s.id = 174` to directly filter on the set_translations table's primary key. The amended query now correctly retrieves languages directly from set_translations without the redundant join, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the language of a specific set id: filter the set_translations table using the exact literal value \"174\" for the id column. 2) When selecting output columns: use the exact column name \"language\" without table alias prefixes. 3) When the schema shows a direct lookup by primary key: access the table directly without unnecessary joins to other tables. 4) Output columns (ordered): language"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.id = 174;",
            "SELECT language FROM set_translations WHERE id = 174"
        ],
        "rule_sql": [
            "SELECT language FROM set_translations WHERE id = 174"
        ]
    },
    "1411": {
        "question": "State what kind of expenses that Sacha Harrison incurred?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
        "amends": [],
        "rules": [
            "kind of expenses refers to expense_description; Sacha Harrison is the full name; full name refers to first_name, last_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.expense_description\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison';"
        ],
        "rule_sql": []
    },
    "367": {
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "amends": [],
        "rules": [
            "Phyrexian' is the language; name of artists refers to artist;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.artist FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Phyrexian';"
        ],
        "rule_sql": []
    },
    "1086": {
        "question": "What's the heading accuracy of Ariel Borysiuk?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.heading_accuracy FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ariel Borysiuk'",
        "amends": [
            "Do reference `t2.heading_accuracy` instead of `p_a.heading_accuracy` in the SELECT list. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference `Player AS t1` and `Player_Attributes AS t2` instead of `Player p` and `Player_Attributes p_a` with different aliases. Do remove the `ORDER BY p_a.date DESC LIMIT 1` clause instead of keeping it, as the RIGHT_SQL retrieves all matching records without temporal ordering or row limitation. The amended query now matches RIGHT_SQL's behavior of returning all heading_accuracy values for the specified player without date-based filtering."
        ],
        "rules": [
            "1) When the question asks for heading accuracy of a specific player: select t2.heading_accuracy from Player_Attributes AS t2. 2) When joining Player and Player_Attributes tables: use INNER JOIN to combine rows where t1.player_api_id = t2.player_api_id. 3) When filtering for a specific player name: include condition t1.player_name = 'Ariel Borysiuk' exactly as specified. 4) When retrieving player attributes: do not apply temporal ordering or row limitation unless explicitly requested. 5) Output columns (ordered): t2.heading_accuracy"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p_a.heading_accuracy \nFROM Player_Attributes p_a\nJOIN Player p ON p_a.player_api_id = p.player_api_id\nWHERE p.player_name = 'Ariel Borysiuk'\nORDER BY p_a.date DESC\nLIMIT 1;",
            "SELECT t2.heading_accuracy \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Ariel Borysiuk'"
        ],
        "rule_sql": [
            "SELECT t2.heading_accuracy \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Ariel Borysiuk'"
        ]
    },
    "50": {
        "question": "What is the postal street address for the school with the 7th highest Math average? Indicate the school's name.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 6, 1",
        "amends": [
            "Do select `T2.MailStreet` and `T2.School` instead of `s.School` and `s.Street`. Do use `INNER JOIN` with alias `T2` for schools instead of `JOIN` with alias `s`. Do reference `T1.AvgScrMath` in ORDER BY instead of `sc.AvgScrMath`. Do use `LIMIT 6, 1` syntax instead of `LIMIT 1 OFFSET 6`. Do remove the `WHERE sc.AvgScrMath IS NOT NULL` filter instead of keeping it, as the ORDER BY DESC naturally handles NULL values by placing them last. The amended query now correctly retrieves the 7th highest math score school's mailing address and name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the postal street address and school name: select T2.MailStreet and T2.School as output columns. 2) When combining SAT scores and schools data: use an inner match where T1.CDSCode equals T2.CDSCode to link related records. 3) When ranking schools by Math average: order rows by T1.AvgScrMath in descending direction. 4) When the question specifies the 7th highest ranked school: take the single row at position 7 (after skipping the first 6 rows). 5) When handling NULL values in ordering: place NULL values last in the descending order without explicit filtering. Output columns (ordered): T2.School, T2.MailStreet"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.School, s.Street\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nWHERE sc.AvgScrMath IS NOT NULL\nORDER BY sc.AvgScrMath DESC\nLIMIT 1 OFFSET 6;",
            "SELECT T2.MailStreet, T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 6, 1"
        ],
        "rule_sql": [
            "SELECT T2.School, T2.MailStreet\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 1 OFFSET 6;",
            "SELECT T2.School, T2.MailStreet\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC NULLS LAST\nLIMIT 1 OFFSET 6;"
        ]
    },
    "941": {
        "question": "How many points did Lewis Hamilton get in total in all the Formula_1 races he participated?",
        "db_id": "formula_1",
        "ground_truth": "SELECT SUM(T2.points) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(points) AS total_points\nFROM results\nWHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton');"
        ],
        "rule_sql": []
    },
    "1524": {
        "question": "What's the nationality of the customer who spent 548.4 in 2012/8/24?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Price = 548.4",
        "amends": [],
        "rules": [
            "'2012/8/24' can be represented by '2012-08-24'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT g.Country AS Nationality\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-24' AND t.Price = 548.4;"
        ],
        "rule_sql": []
    },
    "1481": {
        "error": "something went wrong, tool did not call.",
        "question": "What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(Consumption) FROM yearmonth ) AND T2.Date BETWEEN 201301 AND 201312",
        "amends": [
            "Do use `SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) / COUNT(T1.CustomerID) - SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) / COUNT(T1.CustomerID)` instead of incorrect segment comparisons, and do add `CAST(... AS REAL)` around each division operation instead of omitting explicit casting to ensure proper numeric precision. Do include all three difference calculations between SME-LAM, LAM-KAM, and KAM-SME segments instead of incomplete logic. Do maintain the `FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID` structure with correct join condition. Do keep the `WHERE T1.Currency = 'CZK'` filter but do remove the incorrect `T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth)` subquery condition instead of including it, as it incorrectly filters to only the minimum consumption record rather than all relevant records. Do retain the `T2.Date BETWEEN 201301 AND 201312` date range filter. The amended query now correctly calculates average consumption differences between segments for all CZK currency customers within the specified date range.",
            "Do use `COUNT(T1.CustomerID)` instead of `COUNT(DISTINCT IIF(T1.Segment = 'SME', T1.CustomerID, NULL))` and similar conditional counts for all segment calculations to count all customers rather than segment-specific distinct counts. Do add `AND T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth)` to the WHERE clause instead of omitting this filter condition. Do use integer literals `201301` and `201312` instead of string literals `'201301'` and `'201312'` for the date range comparison. Do remove the column aliases `SME_LAM_Difference`, `LAM_KAM_Difference`, and `KAM_SME_Difference` instead of keeping them. The amended query now correctly calculates average consumption differences across segments while filtering for minimum consumption values and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for consumption differences between segments SME, LAM, and KAM: calculate the difference in average consumption between each segment pair using exact segment literals 'SME', 'LAM', and 'KAM'.\n2) When filtering by currency: include only rows where T1.Currency equals 'CZK' exactly.\n3) When filtering by date range: include only rows where T2.Date is between 201301 and 201312 inclusive.\n4) When combining customers and yearmonth tables: link rows where T1.CustomerID equals T2.CustomerID exactly and keep only matching pairs (inner match).\n5) When calculating average consumption per segment: compute SUM(IIF(T1.Segment = segment_literal, T2.Consumption, 0)) divided by COUNT(T1.CustomerID) for each segment, with explicit casting to ensure numeric precision.\n6) When the question mentions \"annual average consumption\": calculate the average over the entire year 2013 using the date range 201301 to 201312.\n7) When computing differences between segment pairs: calculate SME-LAM, LAM-KAM, and KAM-SME differences using the exact segment literals in that order.\n8) When handling numeric operations: use explicit casting to REAL for division operations to maintain precision.\n9) When counting customers: use T1.CustomerID as the counting key for average calculations.\n10) Output columns (ordered): SME-LAM difference, LAM-KAM difference, KAM-SME difference",
            "1) When the question asks for customers with the least amount of consumption: filter rows where T2.Consumption equals the minimum consumption value from the yearmonth table.\n2) When filtering for payments in CZK: include only rows where T1.Currency equals CZK exactly.\n3) When filtering for year 2013: include only rows where T2.Date is between 201301 and 201312 inclusive.\n4) When calculating average consumption per segment: for each segment (SME, LAM, KAM), compute the sum of T2.Consumption divided by the count of T1.CustomerID.\n5) When computing differences between segment averages: calculate SME average minus LAM average, LAM average minus KAM average, and KAM average minus SME average.\n6) When counting customers: use T1.CustomerID as the counting key for all segment calculations.\n7) When combining customers and yearmonth tables: link rows where T1.CustomerID equals T2.CustomerID and keep only matching pairs.\nOutput columns (ordered): (SME average - LAM average), (LAM average - KAM average), (KAM average - SME average)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "",
            "SELECT \n    CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'SME', T1.CustomerID, NULL)) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'LAM', T1.CustomerID, NULL)) AS SME_LAM_Difference,\n    CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'LAM', T1.CustomerID, NULL)) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'KAM', T1.CustomerID, NULL)) AS LAM_KAM_Difference,\n    CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'KAM', T1.CustomerID, NULL)) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(DISTINCT IIF(T1.Segment = 'SME', T1.CustomerID, NULL)) AS KAM_SME_Difference\nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK' \nAND T2.Date BETWEEN '201301' AND '201312';",
            "SELECT \n    CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) AS SME_LAM_Difference,\n    CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) AS LAM_KAM_Difference,\n    CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) AS KAM_SME_Difference\nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK' \n    AND T2.Date BETWEEN 201301 AND 201312\n    AND T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth)"
        ],
        "rule_sql": [
            "WITH MinConsumption AS (\n    SELECT MIN(Consumption) as MinConsumption\n    FROM yearmonth\n    WHERE Date BETWEEN '201301' AND '201312'\n),\nFilteredCustomers AS (\n    SELECT c.CustomerID, c.Segment, c.Currency\n    FROM customers c\n    JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\n    WHERE c.Currency = 'CZK'\n    AND ym.Date BETWEEN '201301' AND '201312'\n    AND ym.Consumption = (SELECT MinConsumption FROM MinConsumption)\n),\nSegmentAverages AS (\n    SELECT \n        CAST(SUM(IIF(fc.Segment = 'SME', ym.Consumption, 0)) AS REAL) / COUNT(DISTINCT fc.CustomerID) AS SME_Avg,\n        CAST(SUM(IIF(fc.Segment = 'LAM', ym.Consumption, 0)) AS REAL) / COUNT(DISTINCT fc.CustomerID) AS LAM_Avg,\n        CAST(SUM(IIF(fc.Segment = 'KAM', ym.Consumption, 0)) AS REAL) / COUNT(DISTINCT fc.CustomerID) AS KAM_Avg\n    FROM FilteredCustomers fc\n    JOIN yearmonth ym ON fc.CustomerID = ym.CustomerID\n    WHERE ym.Date BETWEEN '201301' AND '201312'\n)\nSELECT \n    (SME_Avg - LAM_Avg) AS SME_LAM_Diff,\n    (LAM_Avg - KAM_Avg) AS LAM_KAM_Diff,\n    (KAM_Avg - SME_Avg) AS KAM_SME_Diff\nFROM SegmentAverages;"
        ]
    },
    "352": {
        "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
        "amends": [
            "Do use `SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT CASE WHEN language = 'Chinese Simplified' THEN uuid END)` for counting Chinese Simplified records. Do add explicit table aliases `T1` and `T2` instead of omitting them. Do use `INNER JOIN cards AS T1 ON T1.uuid = T2.uuid` instead of querying only `foreign_data` table. Do calculate percentage using `CAST(... AS REAL) * 100 / COUNT(T1.id)` instead of `* 100.0 / COUNT(DISTINCT uuid)` to avoid double-counting issues with DISTINCT. Do reference `T1.id` for the total count instead of `uuid` from the joined table. The amended query now correctly calculates the percentage of Chinese Simplified records by properly joining tables and avoiding duplicate counting issues."
        ],
        "rules": [
            "1) When calculating the percentage of cards available in Chinese Simplified: use SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) for counting Chinese Simplified records instead of COUNT(DISTINCT CASE WHEN language = 'Chinese Simplified' THEN uuid END). 2) When joining tables for this calculation: use INNER JOIN cards AS T1 ON T1.uuid = T2.uuid instead of querying only the foreign_data table. 3) When calculating the total count for percentage: use COUNT(T1.id) instead of COUNT(DISTINCT uuid) to avoid double-counting issues. 4) When computing the percentage ratio: use CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) instead of * 100.0 / COUNT(DISTINCT uuid). 5) When referencing table columns: use explicit table aliases T1 and T2 instead of omitting them. 6) When handling the literal value for language: use exact string 'Chinese Simplified' with the specified case and spacing. 7) Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(DISTINCT CASE WHEN language = 'Chinese Simplified' THEN uuid END) * 100.0 / COUNT(DISTINCT uuid)) AS percentage\nFROM foreign_data;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage_chinese_simplified\nFROM \n    cards AS T1\nINNER JOIN \n    foreign_data AS T2 ON T1.uuid = T2.uuid;"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid"
        ]
    },
    "209": {
        "question": "Chlorine is in what type of bond?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T3.element = 'cl'",
        "amends": [],
        "rules": [
            "type of bond refers to bond_type; chlorine refers to element = 'cl'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'cl'\nGROUP BY b.bond_type;"
        ],
        "rule_sql": []
    },
    "1409": {
        "question": "Mention the total expense used on 8/20/2019.",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20'",
        "amends": [],
        "rules": [
            "total expense refers SUM(cost) where expense_date = '2019-08-20'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(cost) AS total_expense FROM expense WHERE expense_date = '2019-08-20';"
        ],
        "rule_sql": []
    },
    "248": {
        "question": "What are the atoms of the triple bond with the molecule \"TR041\"?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'",
        "amends": [
            "Do select only `T2.atom_id` and `T2.atom_id2` instead of selecting multiple atom details with aliases. Do use `INNER JOIN` from `atom AS T1` to `connected AS T2` on `T1.atom_id = T2.atom_id` instead of joining directly to bond first. Do then join `bond AS T3` on `T2.bond_id = T3.bond_id` instead of joining atom tables through connected. Do place both bond conditions `T3.bond_type = '#'` and `T3.molecule_id = 'TR041'` in the WHERE clause instead of having them separated. Do remove the additional atom table joins and element selections instead of including unnecessary atom details. The amended query now correctly retrieves only the connected atom pairs for the specified bond type and molecule."
        ],
        "rules": [
            "1) When the question asks for atoms of a triple bond with a specific molecule: use the exact molecule identifier \"TR041\" and bond type \"#\" as filter conditions. 2) When joining tables for bond and atom relationships: link atom table T1 to connected table T2 using T1.atom_id = T2.atom_id, then link connected table T2 to bond table T3 using T2.bond_id = T3.bond_id. 3) When filtering for specific bond conditions: apply both T3.bond_type = '#' and T3.molecule_id = 'TR041' in the filtering criteria. 4) When selecting output for connected atom pairs: return only the atom identifiers T2.atom_id and T2.atom_id2 instead of additional atom details. 5) Output columns (ordered): T2.atom_id, T2.atom_id2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a1.atom_id AS atom1_id, a1.element AS atom1_element, a2.atom_id AS atom2_id, a2.element AS atom2_element\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.molecule_id = 'TR041' AND b.bond_type = '#';",
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nINNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom T1\nJOIN connected T2 ON T1.atom_id = T2.atom_id\nJOIN bond T3 ON T2.bond_id = T3.bond_id\nWHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'"
        ]
    },
    "1265": {
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `P` and `L`. Do change the join to explicit `INNER JOIN` instead of implicit `JOIN`. Do change the RNP filter conditions to `T2.RNP = 'negative'` and `T2.RNP = '0'` instead of `L.RNP = '-'` and `L.RNP = '+-'`. Do remove the parentheses around the OR condition in the WHERE clause instead of keeping them. The amended query now correctly filters for negative and zero RNP values while maintaining the same join logic and admission filter.",
            "Do remove the `Admission IS NOT NULL` filter and instead use `Admission = '+'` instead of checking for non-null values. Do change the logical structure by moving the `RNP` filter conditions to be evaluated with proper operator precedence instead of using parentheses that grouped the OR conditions separately. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` between the same tables. The amended query now correctly filters for patients with positive admission status and specific RNP values, matching the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `T2.RNP` filter conditions instead of keeping them, and do change the logical operator precedence by placing the `T1.Admission` filter at the end instead of at the beginning with parentheses. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and all filter conditions including `T1.Admission = '+'` and `T2.RNP` checks for 'negative' and '0' values. The amended query now correctly handles the logical operator precedence without parentheses and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting patients: use T1.ID as the counting key to count distinct patients.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner match to keep only patients with laboratory records.\n3) When filtering for normal anti-ribonuclear protein levels: include rows where T2.RNP equals 'negative' or T2.RNP equals '0'.\n4) When filtering for hospital admission: include only rows where T1.Admission equals '+'.\n5) When handling text literals: preserve exact values 'negative', '0', and '+' without changing case or punctuation.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting patients with specific laboratory results and admission status: use COUNT(DISTINCT T1.ID) to count unique patient identifiers.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When filtering for hospital admission status: use Admission = '+' exactly as specified, not null checks.\n4) When filtering for anti-ribonuclear protein levels: use RNP = 'negative' OR RNP = '0' with proper operator precedence, without unnecessary parentheses.\n5) Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting patients: use COUNT(DISTINCT T1.ID) to count unique patient IDs.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When filtering for hospital admission status: include only rows where T1.Admission equals exactly '+'.\n4) When filtering for normal anti-ribonuclear protein levels: include only rows where T2.RNP equals exactly 'negative' or T2.RNP equals exactly '0'.\n5) When applying multiple filter conditions: apply the T2.RNP filter conditions first, then apply the T1.Admission filter without using parentheses around the RNP conditions.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE (L.RNP = '-' OR L.RNP = '+-') AND P.Admission = '+';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission IS NOT NULL \nAND (T2.RNP = 'negative' OR T2.RNP = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '+' AND (T2.RNP = 'negative' OR T2.RNP = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.RNP = 'negative' OR T2.RNP = '0'\nAND T1.Admission = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') \nAND T1.Admission = '+'"
        ]
    },
    "589": {
        "question": "Which user ID has the highest reputation?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Id FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "amends": [],
        "rules": [
            "highest reputation refers to Max(Reputation)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Id FROM users ORDER BY Reputation DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1491": {
        "question": "Which country has more \"value for money\" gas stations? Please give a total number of \"value for money\" gas stations in each country.",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT Country , ( SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money' ) FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY COUNT(GasStationID) DESC LIMIT 1",
        "amends": [
            "Do select `Country` and a subquery count of `GasStationID` instead of selecting `Country` with a `COUNT(DISTINCT g.GasStationID)` aggregate. Do use a subquery `(SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money')` instead of calculating average price per amount comparisons. Do filter with `WHERE Segment = 'Value for money'` instead of joining with transactions and using HAVING conditions. Do remove the JOIN with `transactions_1k` table and all transaction-related calculations instead of including them. Do add `GROUP BY Country` instead of omitting it in the main query context. Do order by `COUNT(GasStationID) DESC` instead of ordering by the alias `ValueForMoneyGasStations DESC`. Do add `LIMIT 1` instead of omitting a row limit. The amended query now correctly identifies value for money gas stations by segment filter rather than price calculations."
        ],
        "rules": [
            "1) When the question asks for \"value for money\" gas stations: filter gasstations table using exact literal \"Value for money\" for the Segment column. 2) When counting gas stations per country: group results by the exact token Country from the gasstations table. 3) When computing total counts per group: count the number of GasStationID values in each group. 4) When the question asks for the country with more value for money gas stations: order results by the count of GasStationID in descending order and keep only the top result. 5) Output columns (ordered): Country, COUNT(GasStationID)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT g.Country, COUNT(DISTINCT g.GasStationID) AS ValueForMoneyGasStations\nFROM gasstations g\nJOIN transactions_1k t ON g.GasStationID = t.GasStationID\nGROUP BY g.Country\nHAVING AVG(t.Price / t.Amount) < (SELECT AVG(Price / Amount) FROM transactions_1k)\nORDER BY ValueForMoneyGasStations DESC;",
            "SELECT Country, (SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money') AS ValueForMoneyCount FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY COUNT(GasStationID) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Country, COUNT(GasStationID) \nFROM gasstations \nWHERE Segment = 'Value for money' \nGROUP BY Country \nORDER BY COUNT(GasStationID) DESC \nLIMIT 1"
        ]
    },
    "1229": {
        "question": "For all patients with triglyceride (TG) level beyond the normal range, how many are age more than 50 years?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200 AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 50",
        "amends": [],
        "rules": [
            "triglyceride (TG) level beyond the normal range refers to TG > = 200; more than 50 years of age = SUBTRACT(year(current_timestamp), year(Birthday)) > 50; Should consider DISTINCT in the final result;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.TG >= 200 \nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 50;"
        ],
        "rule_sql": []
    },
    "1087": {
        "question": "Among the players whose height is over 180, how many of them have a volley score of over 70?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 AND t2.volleys > 70",
        "amends": [],
        "rules": [
            "height > 180; volley score refers to volleys; volleys > 70;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.player_api_id) \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE p.height > 180 AND pa.volleys > 70;"
        ],
        "rule_sql": []
    },
    "1283": {
        "question": "For the patients with the normal glutamic pylvic transaminase level, how many of them are male?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patients. Do reference `T2.GOT < 60` instead of `L.GPT < 60` to filter on the correct laboratory test value. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T1.SEX = 'M'` condition in the WHERE clause instead of changing its position. The amended query now correctly counts male patients with normal GOT values rather than GPT values."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) without DISTINCT to count all matching rows rather than unique patients.\n2) When filtering laboratory test values: reference T2.GOT < 60 instead of GPT to filter on the correct laboratory test value.\n3) When using table aliases: use T1 for Patient table and T2 for Laboratory table for consistency.\n4) When filtering by patient gender: place the T1.SEX = 'M' condition in the WHERE clause.\n5) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\nOutput columns (ordered): MalePatientsWithNormalGPT"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) AS MalePatientsWithNormalGPT\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.GPT < 60;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60 AND T1.SEX = 'M'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) AS MalePatientsWithNormalGPT\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60 AND T1.SEX = 'M'"
        ]
    },
    "962": {
        "error": "something went wrong, tool did not call.",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "db_id": "formula_1",
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "amends": [
            "Do use a single query with conditional aggregation instead of multiple CTEs and subqueries. Do calculate the percentage directly with `SUM(IIF(condition, 1, 0)) * 100 / COUNT(*)` instead of using separate CTEs and subquery division. Do add explicit `CAST` to `REAL` instead of implicit type conversion. Do use `INNER JOIN` on `T1.raceId = T2.raceId` and `T1.driverId = T3.driverId` instead of the previous join structure. Do move the `strftime('%Y', dob) < '1985'` and `laps > 50` conditions into the `IIF` function instead of filtering in a separate CTE. Do keep the `year BETWEEN 2000 AND 2005` filter in the `WHERE` clause instead of duplicating it across CTEs. Do remove the `DISTINCT` operations and multiple CTEs instead of maintaining complex subquery structure. The amended query now correctly calculates the percentage of drivers born before 1985 who completed over 50 laps in races between 2000-2005 using efficient conditional aggregation."
        ],
        "rules": [
            "1) When the question asks for a percentage of drivers meeting specific conditions: compute the ratio using conditional aggregation with SUM(IIF(condition, 1, 0)) * 100 / COUNT(*) instead of separate CTEs and subqueries.\n2) When combining tables for race results and driver information: link rows using T1.raceId = T2.raceId and T1.driverId = T3.driverId with inner matches only.\n3) When filtering for specific years 2000 to 2005: apply year BETWEEN 2000 AND 2005 in the WHERE clause to restrict the time period.\n4) When checking driver birth year before 1985: use strftime('%Y', dob) < '1985' as a condition within the IIF function instead of pre-filtering.\n5) When checking for lap numbers over 50: use laps > 50 as a condition within the IIF function instead of pre-filtering.\n6) When handling numeric type conversion: use explicit CAST to REAL instead of implicit type conversion for percentage calculations.\n7) When counting drivers: avoid DISTINCT operations and multiple CTEs, instead count all rows meeting the base criteria.\nOutput columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH drivers_2000_2005 AS (\n    SELECT DISTINCT d.driverId, d.dob\n    FROM drivers d\n    JOIN results r ON d.driverId = r.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE rc.year BETWEEN 2000 AND 2005\n),\ndrivers_before_1985_over_50_laps AS (\n    SELECT DISTINCT d.driverId\n    FROM drivers d\n    JOIN results r ON d.driverId = r.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE strftime('%Y', d.dob) < '1985'\n    AND r.laps > 50\n    AND rc.year BETWEEN 2000 AND 2005\n)\nSELECT \n    (COUNT(d.driverId) * 100.0 / (SELECT COUNT(*) FROM drivers_2000_2005)) AS percentage\nFROM drivers_before_1985_over_50_laps d;",
            "SELECT \n    CAST(SUM(IIF(strftime('%Y', d.dob) < '1985' AND r.laps > 50, 1, 0)) AS REAL) * 100.0 / COUNT(*) AS percentage\nFROM \n    results r\nINNER JOIN \n    races rc ON r.raceId = rc.raceId\nINNER JOIN \n    drivers d ON r.driverId = d.driverId\nWHERE \n    rc.year BETWEEN 2000 AND 2005;"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(IIF(strftime('%Y', d.dob) < '1985' AND r.laps > 50, 1, 0)) * 100.0 / COUNT(*) AS REAL) AS percentage\nFROM \n    results r\nINNER JOIN \n    races rc ON r.raceId = rc.raceId\nINNER JOIN \n    drivers d ON r.driverId = d.driverId\nWHERE \n    rc.year BETWEEN 2000 AND 2005;"
        ]
    },
    "236": {
        "question": "What are the bond type and the atoms of the bond ID of TR001_6_9?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_id = 'TR001_6_9'",
        "amends": [],
        "rules": [
            "atoms refer to atom_id or atom_id2"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_type, c.atom_id, c.atom_id2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.bond_id = 'TR001_6_9';"
        ],
        "rule_sql": []
    },
    "369": {
        "question": "How many cards that illusrtated in German have been reprinted?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.isReprint = 1",
        "amends": [],
        "rules": [
            "German' is the language; reprinted refers to isReprint = 1;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.uuid) \nFROM cards c \nJOIN foreign_data fd ON c.uuid = fd.uuid \nWHERE fd.language = 'German' AND c.isReprint = 1;"
        ],
        "rule_sql": []
    },
    "1513": {
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "amends": [],
        "rules": [
            "'2012/8/25' can be represented by '2012-08-25'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-25'\nORDER BY t.Time ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "383": {
        "question": "How many of the banned cards are white border?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Banned' AND T1.borderColor = 'white'",
        "amends": [],
        "rules": [
            "banned card refers to status = 'Banned'; white border refers to borderColor = 'white';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS banned_white_border_cards\nFROM legalities\nJOIN cards ON legalities.uuid = cards.uuid\nWHERE legalities.status = 'Banned' AND cards.borderColor = 'white';"
        ],
        "rule_sql": []
    },
    "239": {
        "question": "How many connections does the atom 19 have?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
        "amends": [],
        "rules": [
            "connections refers to bond_id; atom 19 refers to atom_id like 'TR%_19';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT bond_id) AS connection_count FROM connected WHERE atom_id LIKE 'TR%_19' OR atom_id2 LIKE 'TR%_19';"
        ],
        "rule_sql": []
    },
    "844": {
        "question": "Give the eye colour of Blackwulf.",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf'",
        "amends": [],
        "rules": [
            "eye colour refers to colour.colour where eye_colour_id = colour.id; Blackwulf refers to superhero_name = 'Blackwulf';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.superhero_name = 'Blackwulf';"
        ],
        "rule_sql": []
    },
    "273": {
        "question": "What is the percentage of element chlorine in carcinogenic molecules?",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT( CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [],
        "rules": [
            "chlorine refers to element = 'cl'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(element = 'pb'); COUNT(molecule_id)) as percentage where label = '+'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS percentage\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+';"
        ],
        "rule_sql": []
    },
    "1137": {
        "question": "What percentage of players have a strength and stamina score of more than 80?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) FROM Player_Attributes t",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs and cross join. Do calculate the percentage using `CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id)` instead of `(strong_count * 100.0 / total)` from cross-joined CTEs. Do reference `id` column instead of `player_api_id` for counting. Do remove the DISTINCT operations since we're counting individual records rather than distinct players. Do eliminate the CTE structure and cross join between total_players and strong_players in favor of direct aggregation. The amended query now correctly calculates the percentage of records meeting both strength and stamina conditions using proper conditional counting and avoids the unnecessary complexity of CTEs with cross join."
        ],
        "rules": [
            "1) When counting records in Player_Attributes table: use the \"id\" column for counting instead of \"player_api_id\". 2) When calculating percentages with conditional criteria: use CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) formula for accurate percentage calculation. 3) When performing conditional aggregation: avoid using DISTINCT operations and CTE structures with cross joins, instead use direct aggregation within a single query. 4) When filtering for strength and stamina scores above 80: apply the exact conditions strength > 80 AND stamina > 80 without modification to the threshold values. Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH total_players AS (\n    SELECT COUNT(DISTINCT player_api_id) AS total\n    FROM Player_Attributes\n),\nstrong_players AS (\n    SELECT COUNT(DISTINCT player_api_id) AS strong_count\n    FROM Player_Attributes\n    WHERE strength > 80 AND stamina > 80\n)\nSELECT (strong_count * 100.0 / total) AS percentage\nFROM total_players, strong_players;",
            "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) AS percentage\nFROM Player_Attributes;"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) AS percentage FROM Player_Attributes;"
        ]
    },
    "36": {
        "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [
            "Do select individual columns `AdmFName1`, `AdmLName1`, `AdmFName2`, `AdmLName2`, `AdmFName3`, and `AdmLName3` instead of concatenating them with CASE statements into `admin1`, `admin2`, and `admin3` aliases. Do use an `INNER JOIN` between `satscores AS T1` and `schools AS T2` on `T1.cds = T2.CDSCode` instead of a CTE subquery with `WHERE CDSCode = (SELECT cds FROM top_school)`. Do add `ORDER BY T1.NumGE1500 DESC LIMIT 1` at the query level instead of using a separate CTE to find the top school. Do remove the CASE expressions and CTE structure entirely instead of keeping them. The amended query now correctly joins the tables and retrieves the administrator names for the school with the highest NumGE1500 value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the school with the highest number of students scoring 1500 or more on the SAT: rank rows by T1.NumGE1500 in descending order and keep the first 1 row.\n2) When combining satscores and schools tables: link rows where T1.cds = T2.CDSCode exactly as shown and keep only matching pairs (inner match).\n3) When the question asks for administrator full names: select individual columns AdmFName1, AdmLName1, AdmFName2, AdmLName2, AdmFName3, and AdmLName3 instead of concatenating them.\n4) When handling text literals: do not change case, spacing, or punctuation of administrator names.\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names.\n6) When referring to table roles: do not rename or swap the aliases T1 for satscores and T2 for schools once set for this schema.\n7) Output columns (ordered): T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH top_school AS (\n    SELECT cds\n    FROM satscores\n    ORDER BY NumGE1500 DESC\n    LIMIT 1\n)\nSELECT \n    CASE \n        WHEN AdmFName1 IS NOT NULL AND AdmLName1 IS NOT NULL THEN AdmFName1 || ' ' || AdmLName1\n        ELSE NULL\n    END AS admin1,\n    CASE \n        WHEN AdmFName2 IS NOT NULL AND AdmLName2 IS NOT NULL THEN AdmFName2 || ' ' || AdmLName2\n        ELSE NULL\n    END AS admin2,\n    CASE \n        WHEN AdmFName3 IS NOT NULL AND AdmLName3 IS NOT NULL THEN AdmFName3 || ' ' || AdmLName3\n        ELSE NULL\n    END AS admin3\nFROM schools\nWHERE CDSCode = (SELECT cds FROM top_school);",
            "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1"
        ]
    },
    "986": {
        "question": "In which race did the fastest 1st lap time was recorded? Please indicate the time in milliseconds.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.milliseconds FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.lap = 1 ORDER BY T1.time LIMIT 1",
        "amends": [
            "Do select only `T1.milliseconds` instead of multiple columns including `r.raceId`, `r.name`, `r.year`, `r.circuitId`, and `lt.milliseconds`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of `JOIN` with aliases `lt` and `r`. Do join on `T1.raceId = T2.raceId` instead of `lt.raceId = r.raceId`. Do order by `T1.time` instead of `lt.milliseconds ASC`. Do remove the `AS race_name` alias instead of keeping it. The amended query now correctly returns only the fastest lap time from the first lap of races, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the fastest 1st lap time: select only T1.milliseconds as the output column. 2) When combining lap times and races tables: use an inner join where T1.raceId = T2.raceId. 3) When filtering for first lap data: include only rows where T1.lap = 1. 4) When ordering to find the fastest time: sort rows by T1.time in ascending order. 5) When retrieving the single fastest result: take only the first row after ordering. Output columns (ordered): T1.milliseconds"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.raceId, r.name AS race_name, r.year, r.circuitId, lt.milliseconds AS fastest_lap_time\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nWHERE lt.lap = 1\nORDER BY lt.milliseconds ASC\nLIMIT 1;",
            "SELECT T1.milliseconds\nFROM lapTimes T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T1.lap = 1\nORDER BY T1.time\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.milliseconds \nFROM lapTimes T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T1.lap = 1\nORDER BY T1.time ASC\nLIMIT 1;"
        ]
    },
    "1024": {
        "question": "Who are the top 5 players who perform better in crossing actions? Indicate their player id.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5",
        "amends": [
            "Do select only `id` instead of `p.player_api_id, p.player_name, pa.crossing` from the `Player_Attributes` table. Do remove the `JOIN` with `Player` table on `p.player_api_id = pa.player_api_id` instead of including it. Do keep `ORDER BY crossing DESC` and `LIMIT 5` as they remain unchanged. The amended query now correctly retrieves only the IDs from Player_Attributes ordered by crossing, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"top 5 players\" based on crossing performance: rank rows by the \"crossing\" column in descending order and keep the first 5 rows.\n2) When the question specifies \"player id\" as the output: select only the \"id\" column from the Player_Attributes table.\n3) When the question does not require player names or crossing values: do not include \"player_name\" or \"crossing\" columns in the output.\n4) When the question focuses on player attributes only: do not join with the Player table.\n5) Output columns (ordered): id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_api_id, p.player_name, pa.crossing\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY pa.crossing DESC\nLIMIT 5;",
            "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5"
        ]
    },
    "1176": {
        "question": "What was the anti-nucleus antibody concentration level for the patient id 3605340 on 1996/12/2?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT ANA FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02'",
        "amends": [],
        "rules": [
            "anti-nucleus antibody refers to ANA; 1996/12/2 refers to `Examination Date` = '1996-12-02'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT `ANA` FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02';"
        ],
        "rule_sql": []
    },
    "1280": {
        "question": "How many male patients have their glutamic oxaloacetic transaminase in the normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T2.GOT < 60` condition before `T1.SEX = 'M'` in the WHERE clause instead of the reverse order, though this is functionally equivalent. The amended query now correctly counts all patient records meeting the criteria rather than unique patients, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting patients that meet specific criteria: use COUNT(T1.ID) without DISTINCT to count all matching rows rather than unique patient IDs. 2) When joining Patient and Laboratory tables: use INNER JOIN with the exact condition T1.ID = T2.ID to keep only matching pairs. 3) When filtering for male patients: use the exact condition T1.SEX = 'M' with the literal 'M' exactly as specified. 4) When filtering for glutamic oxaloacetic transaminase in normal range: use the exact condition T2.GOT < 60 with the numeric value 60. 5) When ordering conditions in WHERE clause: place T2.GOT < 60 before T1.SEX = 'M' though this is functionally equivalent. 6) When using table aliases: use T1 for Patient table and T2 for Laboratory table consistently. Output columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.GOT < 60;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60 AND T1.SEX = 'M'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'"
        ]
    },
    "1454": {
        "question": "What is the percentage of the cost for the meeting events?",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "amends": [
            "Do calculate `SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost)` instead of `(SUM(e.cost) / COUNT(DISTINCT ev.event_id)) * 100` to properly compute the percentage of meeting costs relative to total costs. Do use `INNER JOIN` consistently instead of mixing `JOIN` and `INNER JOIN` syntax. Do reference tables with aliases `T1`, `T2`, and `T3` instead of `ev`, `b`, and `e` for clarity. Do move the `type = 'Meeting'` filter from the `WHERE` clause into a `CASE` expression instead of filtering rows before aggregation. Do remove the `DISTINCT` count and unnecessary division by event count instead of including it in the calculation. Do eliminate the column alias `percentage_cost` instead of keeping it since the result is a single value. The amended query now correctly calculates the percentage of meeting-related expenses relative to all expenses."
        ],
        "rules": [
            "1) When calculating percentage of costs for specific event types: compute SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) to get the percentage of meeting costs relative to total costs.\n2) When filtering for specific event types in aggregate calculations: move the type filter from WHERE clause into a CASE expression instead of filtering rows before aggregation.\n3) When combining tables T1, T2, and T3: use INNER JOIN consistently with the implied join conditions from the schema structure.\n4) When referencing tables: use aliases T1, T2, and T3 consistently instead of other naming conventions.\n5) When computing percentage calculations: avoid unnecessary DISTINCT counts and division by entity counts that don't relate to the percentage calculation.\n6) When the result is a single aggregate value: eliminate column aliases since the output is a single percentage value.\nOutput columns (ordered): (single percentage value)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (SUM(e.cost) / COUNT(DISTINCT ev.event_id)) * 100 AS percentage_cost\nFROM event ev\nJOIN budget b ON ev.event_id = b.link_to_event\nJOIN expense e ON b.budget_id = e.link_to_budget\nWHERE ev.type = 'Meeting';",
            "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) FROM event T1 INNER JOIN budget T2 ON T1.event_id = T2.link_to_event INNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget;"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100.0 / SUM(T3.cost) \nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget"
        ]
    },
    "35": {
        "question": "What is the administrator's email address of the chartered school with the fewest students enrolled in grades 1 through 12?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.AdmEmail1 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter School (Y/N)` = 1 ORDER BY T1.`Enrollment (K-12)` ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Charted school means `Charter School (Y/N)` = 1 in the table frpm; Students enrolled in grades 1 through 12 refers to `Enrollment (K-12)`"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.AdmEmail1\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.`Charter School (Y/N)` = 1\nORDER BY f.`Enrollment (K-12)` ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1047": {
        "question": "What is the football player Francois Affolter header's finishing rate on 18/09/2014?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.heading_accuracy FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Francois Affolter' AND SUBSTR(t2.`date`, 1, 10) = '2014-09-18'",
        "amends": [
            "Do select only `heading_accuracy` instead of both `player_name` and `heading_accuracy`. Do use `INNER JOIN` instead of `JOIN` (which are equivalent, but explicit). Do use table aliases `t1` and `t2` instead of full table names. Do change the date filter to use `SUBSTR(t2.date, 1, 10)` to extract just the date portion instead of comparing the full timestamp string. Do remove the explicit `00:00:00` time component from the date comparison. The amended query now correctly handles date filtering by extracting only the date part and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a specific player's finishing rate: filter rows where t1.player_name equals 'Francois Affolter' exactly. 2) When filtering by a specific date: extract only the date portion from t2.date using substring operations and compare it to '2014-09-18' exactly. 3) When joining Player and Player_Attributes tables: use an inner join where t1.player_api_id equals t2.player_api_id. 4) When selecting output columns: include only heading_accuracy from the Player_Attributes table. 5) Output columns (ordered): t2.heading_accuracy"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.heading_accuracy\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Francois Affolter'\nAND pa.date = '2014-09-18 00:00:00';",
            "SELECT t1.heading_accuracy\nFROM Player_Attributes t1\nINNER JOIN Player t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.player_name = 'Francois Affolter'\nAND SUBSTR(t1.date, 1, 10) = '2014-09-18'"
        ],
        "rule_sql": [
            "SELECT t2.heading_accuracy \nFROM Player t1 \nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Francois Affolter' \nAND substr(t2.date, 1, 10) = '2014-09-18'"
        ]
    },
    "1127": {
        "question": "Locate players with vision scores of 90 and above, state the country of these players.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t4.name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id INNER JOIN Match AS t3 ON t2.player_api_id = t3.home_player_8 INNER JOIN Country AS t4 ON t3.country_id = t4.id WHERE t1.vision > 89",
        "amends": [
            "Do remove `p.player_name` and change `c.name AS country_name` to `t4.name` in the SELECT list instead of including both columns. Do change the join condition from matching on any of 22 player position columns to specifically joining on `t2.player_api_id = t3.home_player_8` instead of the OR chain across all player positions. Do change the WHERE filter from `pa.vision >= 90` to `t1.vision > 89` instead of using the greater-than-or-equal operator. Do remove the unnecessary DISTINCT modifier instead of keeping it, as the specific join condition on a single player position eliminates duplicate rows. The amended query now correctly filters for players with vision greater than 89 who specifically played in the home_player_8 position, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for players with vision scores of 90 and above: filter rows where t1.vision > 89 instead of using >= 90. 2) When joining Player_Attributes (t1) and Player (t2): use the exact key equality t1.player_api_id = t2.player_api_id. 3) When joining Player (t2) and Match (t3): use the specific condition t2.player_api_id = t3.home_player_8 instead of matching any of the 22 player position columns. 4) When joining Match (t3) and Country (t4): use the exact key equality t3.country_id = t4.id. 5) When selecting output columns: include only t4.name instead of both player_name and country_name. 6) When eliminating duplicates: do not use DISTINCT as the specific join condition on a single player position naturally eliminates duplicate rows. Output columns (ordered): t4.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.player_name, c.name AS country_name\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nJOIN Match m ON (p.player_api_id = m.home_player_1 OR p.player_api_id = m.home_player_2 OR p.player_api_id = m.home_player_3 OR p.player_api_id = m.home_player_4 OR p.player_api_id = m.home_player_5 OR p.player_api_id = m.home_player_6 OR p.player_api_id = m.home_player_7 OR p.player_api_id = m.home_player_8 OR p.player_api_id = m.home_player_9 OR p.player_api_id = m.home_player_10 OR p.player_api_id = m.home_player_11 OR p.player_api_id = m.away_player_1 OR p.player_api_id = m.away_player_2 OR p.player_api_id = m.away_player_3 OR p.player_api_id = m.away_player_4 OR p.player_api_id = m.away_player_5 OR p.player_api_id = m.away_player_6 OR p.player_api_id = m.away_player_7 OR p.player_api_id = m.away_player_8 OR p.player_api_id = m.away_player_9 OR p.player_api_id = m.away_player_10 OR p.player_api_id = m.away_player_11)\nJOIN Country c ON m.country_id = c.id\nWHERE pa.vision >= 90;",
            "SELECT t4.name\nFROM Player_Attributes t1\nJOIN Player t2 ON t1.player_api_id = t2.player_api_id\nJOIN Match t3 ON t2.player_api_id = t3.home_player_8\nJOIN Country t4 ON t3.country_id = t4.id\nWHERE t1.vision > 89"
        ],
        "rule_sql": [
            "SELECT t4.name \nFROM Player_Attributes t1\nJOIN Player t2 ON t1.player_api_id = t2.player_api_id\nJOIN Match t3 ON t2.player_api_id = t3.home_player_8\nJOIN Country t4 ON t3.country_id = t4.id\nWHERE t1.vision > 89"
        ]
    },
    "81": {
        "question": "In which city can you find the school in the state of California with the lowest latitude coordinates and what is its lowest grade? Indicate the school name.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.City, T1.`Low Grade`, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.State = 'CA' ORDER BY T2.Latitude ASC LIMIT 1",
        "amends": [
            "Do select `T1.School Name` instead of `s.School`, and do select `T1.Low Grade` instead of `f.Low Grade` with proper table aliases. Do use `INNER JOIN` with explicit `AS` table aliases `T1` and `T2` instead of simple aliases `s` and `f`. Do join on `T1.CDSCode = T2.CDSCode` instead of `s.CDSCode = f.CDSCode` to maintain proper table reference consistency. Do filter on `T2.State = 'CA'` instead of `s.State = 'CA'` to correctly reference the joined table. Do order by `T2.Latitude ASC` instead of `s.Latitude ASC` with consistent table alias usage. The amended query now correctly selects the intended columns from the proper table sources and maintains consistent join logic throughout.",
            "Do reorder the SELECT list to `T2.City, T1.Low Grade, T1.School Name` instead of `T1.School Name, T1.Low Grade, T2.City`. Do use backticks for column names `Low Grade` and `School Name` instead of double quotes. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column order and identifier quoting."
        ],
        "rules": [
            "1) When the question asks for the school name: select T1.\"School Name\" instead of any other school identifier. 2) When the question asks for the lowest grade: select T1.\"Low Grade\" from the frpm table. 3) When joining tables schools and frpm: use INNER JOIN with T1 as frpm and T2 as schools, linking rows where T1.CDSCode = T2.CDSCode. 4) When filtering for California schools: use T2.State = 'CA' to reference the state column from the schools table. 5) When finding the school with lowest latitude coordinates: order by T2.Latitude ASC and take the first result. 6) When selecting output columns: include T2.City, T1.\"School Name\", and T1.\"Low Grade\". Output columns (ordered): T2.City, T1.\"School Name\", T1.\"Low Grade\"",
            "1) When the question asks for a school in California: filter rows where T2.State equals 'CA' exactly.\n2) When finding the school with the lowest latitude coordinates: order rows by T2.Latitude in ascending order and keep only the first row.\n3) When the question asks for city, lowest grade, and school name: output columns in the order T2.City, T1.`Low Grade`, T1.`School Name`.\n4) When combining tables frpm and schools: link rows where T1.CDSCode equals T2.CDSCode exactly and keep only matching pairs (inner match).\n5) When handling identifier quoting: use backticks for column names containing spaces like `Low Grade` and `School Name`.\nOutput columns (ordered): T2.City, T1.`Low Grade`, T1.`School Name`"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.City, s.School, f.\"Low Grade\"\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.State = 'CA'\nORDER BY s.Latitude ASC\nLIMIT 1;",
            "SELECT T1.\"School Name\", T1.\"Low Grade\", T2.City\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.State = 'CA'\nORDER BY T2.Latitude ASC\nLIMIT 1;",
            "SELECT T2.City, T1.`Low Grade`, T1.`School Name`\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.State = 'CA'\nORDER BY T2.Latitude ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.City, T1.`School Name`, T1.`Low Grade` \nFROM frpm T1 \nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.State = 'CA' \nORDER BY T2.Latitude ASC \nLIMIT 1"
        ]
    },
    "162": {
        "question": "What is the region of the client with the id 3541 from?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
        "amends": [],
        "rules": [
            "A3 refers to region"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.A3 AS region\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.client_id = 3541;"
        ],
        "rule_sql": []
    },
    "339": {
        "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; oxygen refers to element = 'o'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.atom_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+' AND a.element = 'o';"
        ],
        "rule_sql": []
    },
    "96": {
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK TYDNE'",
        "amends": [],
        "rules": [
            "'POPLATEK TYDNE' stands for weekly issuance"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS customer_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'OWNER';"
        ],
        "rule_sql": []
    },
    "257": {
        "question": "List down atom id2 for atoms with element sulfur.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'",
        "amends": [],
        "rules": [
            "element sulfur refers to element = 's'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.atom_id2\nFROM connected c\nJOIN atom a ON c.atom_id = a.atom_id\nWHERE a.element = 's';"
        ],
        "rule_sql": []
    },
    "203": {
        "question": "In how many atoms is there no bromine?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T.atom_id) FROM atom AS T WHERE T.element <> 'br'",
        "amends": [],
        "rules": [
            "atoms with no bromine refers to element ! = 'br'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM atom WHERE element != 'br';"
        ],
        "rule_sql": []
    },
    "556": {
        "question": "What is the average number of badges obtained by a user with over 200 views?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Views > 200",
        "amends": [],
        "rules": [
            "user with over 200 views refers to Views > 200; average number of badges = Divide (Count(Id), Count(DisplayName))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(badge_count) AS average_badges\nFROM (\n    SELECT u.Id, COUNT(b.Id) AS badge_count\n    FROM users u\n    LEFT JOIN badges b ON u.Id = b.UserId\n    WHERE u.Views > 200\n    GROUP BY u.Id\n) AS user_badges;"
        ],
        "rule_sql": []
    },
    "994": {
        "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
        "db_id": "formula_1",
        "ground_truth": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
        "amends": [
            "Do use `SUM(T1.points)` as the first column instead of `c.name` in the SELECT list. Do include only `T2.name` and `T2.nationality` instead of grouping by `c.constructorId, c.name, c.nationality`. Do use table aliases `T1`, `T2`, and `T3` instead of full table names. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do join `races AS T3` with `T3.raceid = T1.raceid` instead of `cr.raceId = r.raceId`. Do group by only `T2.name` instead of `c.constructorId, c.name, c.nationality`. Do order by `SUM(T1.points)` instead of the alias `total_points`. The amended query now correctly aggregates constructor points for Monaco Grand Prix races between 1980 and 2010 while properly grouping by constructor name only."
        ],
        "rules": [
            "1) When the question asks for the constructor with most points from Monaco Grand Prix between 1980 and 2010: compute the sum of T1.points for each constructor and find the highest scoring one.\n2) When combining tables T1, T2, and T3: link rows where T1.constructorid = T2.constructorid and T1.raceid = T3.raceid using inner matches only.\n3) When filtering for Monaco Grand Prix races between 1980 and 2010: include only rows where T3.name = 'Monaco Grand Prix' and T3.year is between 1980 and 2010 inclusive.\n4) When grouping by constructor: organize results by T2.name only, not by constructorId or nationality.\n5) When ordering results: sort by SUM(T1.points) in descending order to find the highest scoring constructor.\n6) When limiting to top result: keep only the first row after ordering by points.\n7) Output columns (ordered): SUM(T1.points), T2.name, T2.nationality"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, c.nationality, SUM(cr.points) AS total_points\nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nJOIN races r ON cr.raceId = r.raceId\nWHERE r.name = 'Monaco Grand Prix' AND r.year BETWEEN 1980 AND 2010\nGROUP BY c.constructorId, c.name, c.nationality\nORDER BY total_points DESC\nLIMIT 1;",
            "SELECT SUM(T1.points) AS total_points, T2.name, T2.nationality\nFROM constructorResults AS T1\nINNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId\nINNER JOIN races AS T3 ON T1.raceId = T3.raceId\nWHERE T3.name LIKE '%Monaco Grand Prix%' \nAND T3.year BETWEEN 1980 AND 2010\nGROUP BY T2.name\nORDER BY SUM(T1.points) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT SUM(cr.points) AS score, c.name, c.nationality\nFROM constructorResults cr\nJOIN constructors c ON cr.constructorId = c.constructorId\nJOIN races r ON cr.raceId = r.raceId\nWHERE r.name = 'Monaco Grand Prix' AND r.year BETWEEN 1980 AND 2010\nGROUP BY c.name\nORDER BY SUM(cr.points) DESC\nLIMIT 1;"
        ]
    },
    "551": {
        "question": "How many badges has the user csgillespie obtained?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS badge_count\nFROM badges\nWHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');"
        ],
        "rule_sql": []
    },
    "1131": {
        "question": "What is the average heights of Italy players?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) FROM Player AS T1 INNER JOIN Match AS T2 ON T1.id = T2.id INNER JOIN Country AS T3 ON T2.country_id = T3.ID WHERE T3.NAME = 'Italy'",
        "amends": [
            "Do use `CAST(SUM(T1.height) AS REAL) / COUNT(T1.id)` instead of `AVG(P.height)` for precise average calculation. Do join `Match AS T2` on `T1.id = T2.id` instead of checking if `P.player_api_id` is in multiple player columns. Do use `INNER JOIN` consistently instead of mixing `JOIN` and `INNER JOIN` syntax. Do reference tables with aliases `T1`, `T2`, `T3` instead of `P`, `M`, `C` for clarity. Do filter on `T3.NAME = 'Italy'` instead of `C.name = 'Italy'` to match the table alias. The amended query now correctly calculates the average height by joining directly on player IDs rather than checking against multiple position columns, ensuring accurate results.",
            "Do `INNER JOIN` on `T1.id = T2.id` instead of the complex `INNER JOIN` condition checking against multiple player columns. Do remove the alias `AS average_height` instead of keeping it. Do use `T3.ID` instead of `T3.id` in the join condition. Do use `T3.NAME` instead of `T3.name` in the WHERE filter. The amended query now correctly joins on the primary key relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating average height: use CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) instead of AVG(P.height) for precise calculation. 2) When joining Match table: use T1.id = T2.id instead of checking if player_api_id is in multiple player columns. 3) When using table aliases: reference tables with T1, T2, T3 instead of P, M, C for clarity. 4) When filtering for Italy players: use T3.NAME = 'Italy' instead of C.name = 'Italy' to match the table alias. 5) When combining tables: use INNER JOIN consistently instead of mixing JOIN and INNER JOIN syntax. Output columns (ordered): average_height",
            "1) When joining Player (T1) and Country (T3) tables: link rows where T1.id equals T3.ID exactly as shown in the schema relationship.\n2) When filtering for Italy players: use the exact literal 'Italy' with the exact column token T3.NAME in the condition.\n3) When computing average height: calculate the sum of T1.height divided by the count of T1.id without adding an alias to the result.\n4) When combining tables for this query: perform an inner match between Player and Country tables using the primary key relationship T1.id = T3.ID.\n5) Output columns (ordered): CAST(SUM(T1.height) AS REAL) / COUNT(T1.id)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(P.height) AS average_height\nFROM Player P\nJOIN Match M ON P.player_api_id IN (\n    M.home_player_1, M.home_player_2, M.home_player_3, M.home_player_4, M.home_player_5,\n    M.home_player_6, M.home_player_7, M.home_player_8, M.home_player_9, M.home_player_10, M.home_player_11,\n    M.away_player_1, M.away_player_2, M.away_player_3, M.away_player_4, M.away_player_5,\n    M.away_player_6, M.away_player_7, M.away_player_8, M.away_player_9, M.away_player_10, M.away_player_11\n)\nJOIN Country C ON M.country_id = C.id\nWHERE C.name = 'Italy';",
            "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) AS average_height\nFROM Player AS T1\nINNER JOIN Match AS T2 ON T1.player_api_id IN (\n    T2.home_player_1, T2.home_player_2, T2.home_player_3, T2.home_player_4, T2.home_player_5,\n    T2.home_player_6, T2.home_player_7, T2.home_player_8, T2.home_player_9, T2.home_player_10, T2.home_player_11,\n    T2.away_player_1, T2.away_player_2, T2.away_player_3, T2.away_player_4, T2.away_player_5,\n    T2.away_player_6, T2.away_player_7, T2.away_player_8, T2.away_player_9, T2.away_player_10, T2.away_player_11\n)\nINNER JOIN Country AS T3 ON T2.country_id = T3.id\nWHERE T3.name = 'Italy'",
            "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) \nFROM Player AS T1\nINNER JOIN Match AS T2 ON T1.id = T2.id\nINNER JOIN Country AS T3 ON T2.country_id = T3.ID\nWHERE T3.NAME = 'Italy'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) \nFROM Player T1\nINNER JOIN Country T3 ON T1.id = T3.ID\nWHERE T3.NAME = 'Italy'"
        ]
    },
    "506": {
        "question": "For all the set of cards that has Japanese translation, what is the percentage of them are only available in non-foil?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Japanese' )",
        "amends": [
            "Do use `CAST(SUM(...) AS REAL)` instead of omitting the explicit cast to ensure proper floating-point division. Do calculate percentage from `COUNT(id)` instead of `COUNT(*)` to count only cards with valid IDs. Do move the language filter to a subquery in the `WHERE` clause with `code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese')` instead of joining the set_translations table directly. Do remove the unnecessary joins to `set_translations` and `cards` tables instead of keeping them, as the calculation can be done directly from the sets table using the subquery result. Do omit the column alias `percentage_non_foil_only` instead of including it since the right query doesn't use an alias. The amended query now correctly calculates the percentage of non-foil only sets for Japanese translations using proper type casting and more efficient filtering."
        ],
        "rules": [
            "1) When the question asks for percentage of cards with Japanese translation that are non-foil only: calculate (number of cards with isNonFoilOnly = 1) divided by (total number of cards) multiplied by 100.0, using explicit casting to REAL for floating-point division.\n2) When filtering for sets with Japanese translation: use a subquery condition WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese') instead of direct table joins.\n3) When counting cards: use COUNT(id) instead of COUNT(*) to count only cards with valid IDs.\n4) When calculating aggregates: perform calculations directly from the sets table using the subquery result instead of unnecessary joins to set_translations and cards tables.\n5) When producing output: omit column aliases since the question doesn't require specific output naming.\nOutput columns (ordered): (SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(id))"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN c.isNonFoilOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_non_foil_only\nFROM \n    sets s\nJOIN \n    set_translations st ON s.code = st.setCode\nJOIN \n    cards c ON s.code = c.setCode\nWHERE \n    st.language = 'Japanese';",
            "SELECT \n    CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) / COUNT(id) * 100\nFROM \n    sets\nWHERE \n    code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese');"
        ],
        "rule_sql": [
            "SELECT (SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(id)) \nFROM sets \nWHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese')"
        ]
    },
    "1370": {
        "question": "List all the expenses incurred by the vice president.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.expense_id, T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "amends": [
            "Do select only `expense_id` and `expense_description` instead of including additional columns `expense_date`, `cost`, and `approved`. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do reference tables with aliases `T1` for `member` and `T2` for `expense` instead of single-letter aliases `m` and `e`. Do specify the join condition as `T1.member_id = T2.link_to_member` instead of `e.link_to_member = m.member_id` to maintain proper table reference clarity. The amended query now correctly filters for Vice President members and returns only the specified expense details, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for expenses incurred by the vice president: filter members where T1.position equals 'Vice President' exactly. 2) When combining member and expense tables: link rows where T1.member_id equals T2.link_to_member exactly and keep only matching pairs (inner match). 3) When selecting expense details: include only T2.expense_id and T2.expense_description columns. 4) When handling table references: use T1 as alias for member table and T2 as alias for expense table. 5) Output columns (ordered): T2.expense_id, T2.expense_description"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.expense_id, e.expense_description, e.expense_date, e.cost, e.approved\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nWHERE m.position = 'Vice President';",
            "SELECT T2.expense_id, T2.expense_description\nFROM member T1\nINNER JOIN expense T2 ON T1.member_id = T2.link_to_member\nWHERE T1.position = 'Vice President';"
        ],
        "rule_sql": [
            "SELECT T2.expense_id, T2.expense_description FROM member T1 INNER JOIN expense T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'"
        ]
    },
    "85": {
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "amends": [
            "Do place the `District Code` column after the calculated percentage instead of listing it first in the SELECT clause. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do simplify the WHERE condition to only check `AdmFName1 = 'Alusine'` instead of checking multiple administrator name fields. Do remove the unnecessary table aliases `f` and `s` and use `T1` and `T2` consistently instead. Do change the calculation order to `Free Meal Count (K-12) * 100 / Enrollment (K-12)` instead of `(Free Meal Count (K-12) / Enrollment (K-12)) * 100` for equivalent mathematical results with potentially better performance. The amended query now correctly focuses on the single relevant administrator name field and produces the same logical results as the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"Percent (%) Eligible Free (K-12)\": calculate Free Meal Count (K-12) * 100 / Enrollment (K-12) using exact column names from the frpm table.\n2) When the question mentions \"school administered by an administrator whose first name is Alusine\": filter schools where AdmFName1 equals exactly 'Alusine' (case-sensitive).\n3) When combining frpm and schools tables: link rows where T1.CDSCode = T2.CDSCode using inner join and keep only matching pairs.\n4) When the question asks for \"district code of the school\": include District Code from the frpm table in the output.\n5) When ordering output columns: place the calculated percentage first followed by District Code.\nOutput columns (ordered): (Free Meal Count (K-12) * 100 / Enrollment (K-12)) AS \"Percent (%) Eligible Free (K-12)\", \"District Code\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    f.`District Code`,\n    (f.`Free Meal Count (K-12)` / f.`Enrollment (K-12)`) * 100 AS `Percent (%) Eligible Free (K-12)`\nFROM \n    frpm f\nJOIN \n    schools s ON f.CDSCode = s.CDSCode\nWHERE \n    s.AdmFName1 = 'Alusine' OR s.AdmFName2 = 'Alusine' OR s.AdmFName3 = 'Alusine';",
            "SELECT (f.\"Free Meal Count (K-12)\" * 100 / f.\"Enrollment (K-12)\") AS \"Percent (%) Eligible Free (K-12)\", f.\"District Code\"\nFROM frpm f\nINNER JOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.AdmFName1 = 'Alusine'"
        ],
        "rule_sql": [
            "SELECT \n    (f.\"Free Meal Count (K-12)\" * 100.0 / f.\"Enrollment (K-12)\") AS \"Percent (%) Eligible Free (K-12)\",\n    f.\"District Code\"\nFROM \n    frpm f\nINNER JOIN \n    schools s ON f.CDSCode = s.CDSCode\nWHERE \n    s.AdmFName1 = 'Alusine'"
        ]
    },
    "300": {
        "question": "What atoms comprise TR186?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id = 'TR186'",
        "amends": [
            "Do reference the table with alias `T` instead of using the bare table name. Do remove the column `element` from the SELECT list instead of including it. Do qualify the column `atom_id` with the table alias as `T.atom_id` instead of using the unqualified column name. Do qualify the column `molecule_id` with the table alias as `T.molecule_id` instead of using the unqualified column name. The amended query now correctly selects only the atom_id column from the aliased table with proper column qualification."
        ],
        "rules": [
            "1) When the question asks for atoms comprising a specific molecule: filter rows where T.molecule_id equals the exact literal 'TR186'. 2) When selecting output columns for this question: include only T.atom_id and exclude the element column. 3) When referencing columns from the atom table: qualify all column references with the table alias T. 4) Output columns (ordered): T.atom_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_id, element FROM atom WHERE molecule_id = 'TR186';",
            "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id = 'TR186';"
        ],
        "rule_sql": [
            "SELECT T.atom_id FROM atom T WHERE T.molecule_id = 'TR186'"
        ]
    },
    "264": {
        "question": "What are the labels for TR000, TR001 and TR002?",
        "db_id": "toxicology",
        "ground_truth": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
        "amends": [],
        "rules": [
            "TR000, TR001 and TR002 are molecule id; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id, label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');"
        ],
        "rule_sql": []
    },
    "647": {
        "question": "Provide the badge names received in 2011 for the user whose location is in the North Pole.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE STRFTIME('%Y', T2.Date) = '2011' AND T1.Location = 'North Pole'",
        "amends": [],
        "rules": [
            "received in 2011 refers to year(Date) = 2011;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.Location = 'North Pole' \nAND strftime('%Y', b.Date) = '2011';"
        ],
        "rule_sql": []
    },
    "928": {
        "question": "Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T3.forename, T3.surname, T3.driverRef FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Canadian Grand Prix' AND T2.rank = 1 AND T1.year = 2007",
        "amends": [
            "Do select `forename`, `surname`, and `driverRef` instead of only `driverRef`. Do use table aliases `T1`, `T2`, and `T3` instead of full table names. Do join `races AS T1` instead of `races rc`. Do use `INNER JOIN` consistently instead of mixing `JOIN` syntax. Do filter on `T2.rank = 1` instead of `r.position = 1`. Do maintain the same join conditions between `raceId` and `driverId` columns. The amended query now correctly identifies the winner using the rank column instead of position and returns the complete driver name information."
        ],
        "rules": [
            "1) When the question asks for a driver's reference name and complete name information: select T3.forename, T3.surname, and T3.driverRef as output columns.\n2) When joining tables for race results: use T1 for races, T2 for results, and T3 for drivers with the exact aliases as specified.\n3) When combining race and result data: link rows where T1.raceId = T2.raceId using inner join.\n4) When combining result and driver data: link rows where T2.driverId = T3.driverId using inner join.\n5) When filtering for a specific Grand Prix event: include rows where T1.name = 'Canadian Grand Prix' exactly as specified.\n6) When filtering for a specific year: include rows where T1.year = 2007.\n7) When identifying the ranked first driver: include rows where T2.rank = 1 instead of position-based filtering.\n8) Output columns (ordered): T3.forename, T3.surname, T3.driverRef"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.driverRef\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.name = 'Canadian Grand Prix' AND rc.year = 2007 AND r.position = 1;",
            "SELECT T3.forename, T3.surname, T3.driverRef \nFROM races AS T1\nINNER JOIN results AS T2 ON T1.raceId = T2.raceId\nINNER JOIN drivers AS T3 ON T2.driverId = T3.driverId\nWHERE T1.name = 'Canadian Grand Prix' \nAND T1.year = 2007 \nAND T2.rank = 1;"
        ],
        "rule_sql": [
            "SELECT T3.forename, T3.surname, T3.driverRef\nFROM races T1\nINNER JOIN results T2 ON T1.raceId = T2.raceId\nINNER JOIN drivers T3 ON T2.driverId = T3.driverId\nWHERE T1.name = 'Canadian Grand Prix'\nAND T1.year = 2007\nAND T2.rank = 1;"
        ]
    },
    "496": {
        "question": "What is the number of cards are there in the set of \"Rinascita di Alara\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Rinascita di Alara'",
        "amends": [],
        "rules": [
            "number of cards refers to baseSetSize; set of \"Rinascita di Alara\" refers to translation = 'Rinascita di Alara'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.baseSetSize\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.translation = 'Rinascita di Alara';"
        ],
        "rule_sql": []
    },
    "1469": {
        "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
        "amends": [],
        "rules": [
            "full name refers to first_name, last_name, hometown of Lincolnton, North Carolina refers to city = 'Lincolnton' AND state = 'North Carolina'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name, m.position\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE z.city = 'Lincolnton' AND z.state = 'North Carolina' AND m.zip = 28092;"
        ],
        "rule_sql": []
    },
    "910": {
        "question": "What's the location coordinates of Silverstone Circuit?",
        "db_id": "formula_1",
        "ground_truth": "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit'",
        "amends": [],
        "rules": [
            "location coordinates refers to (lat, lng); Silverstone Circuit refers to circuits.name = 'Silverstone Circuit'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit';"
        ],
        "rule_sql": []
    },
    "830": {
        "question": "Identify the weakest attribute of the Black Panther.",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.attribute_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = 'Black Panther' ORDER BY T2.attribute_value ASC LIMIT 1",
        "amends": [],
        "rules": [
            "weakest attribute refers to attribute_name WHERE MIN(attribute_value); Black Panther refers to superhero_name = 'Black Panther';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.attribute_name \nFROM hero_attribute ha \nJOIN attribute a ON ha.attribute_id = a.id \nJOIN superhero s ON ha.hero_id = s.id \nWHERE s.superhero_name = 'Black Panther' \nORDER BY ha.attribute_value ASC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1244": {
        "question": "List all patients who first came to the hospital after year 1992 with prothrombin time (PT) level that are normal.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) > '1992' AND T2.PT < 14",
        "amends": [
            "Do select only `T1.ID` instead of multiple columns including `P.ID`, `P.SEX`, `P.Birthday`, `P.Description`, `P.First Date`, `P.Admission`, and `P.Diagnosis`. Do use `INNER JOIN` with explicit `AS T2` alias instead of `JOIN` with `L` alias. Do reference `T1.First Date` instead of `P.First Date` in the STRFTIME function. Do reference `T2.PT` instead of `L.PT` in the filter condition. Do remove `DISTINCT` instead of keeping it. The amended query now correctly returns only patient IDs meeting the date and laboratory criteria without unnecessary columns or distinct filtering.",
            "Do use backticks around `First Date` instead of First_Date to handle the column name with spaces. Do change the WHERE condition to `T2.PT < 14` instead of `T2.PT IS NOT NULL` to filter for specific values rather than just non-null values. The amended query now correctly filters laboratory results with PT values below 14 instead of merely checking for non-null PT values, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for patients who first came after year 1992: filter rows where the year part of T1.\"First Date\" is greater than 1992.\n2) When the question asks for patients with normal prothrombin time (PT) level: filter rows where T2.PT is less than 14.\n3) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match).\n4) When the question asks to list all patients: select only T1.ID instead of multiple columns including P.ID, P.SEX, P.Birthday, P.Description, P.\"First Date\", P.Admission, and P.Diagnosis.\n5) When selecting output columns: do not use DISTINCT filtering.\nOutput columns (ordered): T1.ID",
            "1) When the question asks for patients who first came after year 1992: filter rows where the year part of T1.\"First Date\" is greater than 1992.\n2) When the question specifies \"normal\" prothrombin time (PT) level: filter rows where T2.PT is less than 14.\n3) When combining Patient and Laboratory tables for shared patients: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n4) When choosing identifier delimiters: use double quotes around \"First Date\" to handle the column name with spaces, not backticks.\n5) When handling text literals: preserve the exact numeric value 14 for PT level comparison.\n6) Output columns (ordered): T1.ID"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT P.ID, P.SEX, P.Birthday, P.Description, P.`First Date`, P.Admission, P.Diagnosis\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE strftime('%Y', P.`First Date`) > '1992'\nAND L.PT < 14;",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.First_Date) > '1992'\nAND T2.PT IS NOT NULL",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.`First Date`) > '1992'\nAND T2.PT < 14"
        ],
        "rule_sql": [
            "SELECT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE CAST(strftime('%Y', T1.\"First Date\") AS INTEGER) > 1992\nAND T2.PT < 14"
        ]
    },
    "691": {
        "question": "Identify the number of adult users who have cast over 5000 upvotes.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000",
        "amends": [],
        "rules": [
            "adult users refer to Age BETWEEN 19 and 65; over 5000 upvotes refer to UpVotes > 5000;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NumberOfAdultUsersWithHighUpvotes\nFROM users\nWHERE Age >= 18 AND UpVotes > 5000;"
        ],
        "rule_sql": []
    },
    "765": {
        "question": "How many heroes have stealth power?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'",
        "amends": [
            "Do use `COUNT(T1.hero_id)` without DISTINCT instead of `COUNT(DISTINCT hero_id)` to count all hero occurrences rather than unique heroes. Do add `INNER JOIN superpower AS T2 ON T1.power_id = T2.id` instead of using a subquery for the power lookup. Do move the filter to `WHERE T2.power_name = 'Stealth'` instead of the subquery condition `power_id = (SELECT id FROM superpower WHERE power_name = 'stealth')`. Do use proper table aliases `T1` and `T2` instead of unaliased table references. The amended query now correctly joins the tables and filters on the power name directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting heroes: use COUNT(T1.hero_id) without DISTINCT to count all hero occurrences rather than unique heroes. 2) When joining hero_power and superpower tables: use INNER JOIN with T1.power_id = T2.id as the join condition. 3) When filtering for stealth power: use WHERE T2.power_name = 'Stealth' with exact case matching. 4) When using table aliases: use T1 for hero_power and T2 for superpower consistently. 5) Output columns (ordered): COUNT(T1.hero_id) AS hero_count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT hero_id) AS hero_count\nFROM hero_power\nWHERE power_id = (SELECT id FROM superpower WHERE power_name = 'stealth');",
            "SELECT COUNT(T1.hero_id) \nFROM hero_power AS T1 \nINNER JOIN superpower AS T2 ON T1.power_id = T2.id \nWHERE T2.power_name = 'Stealth'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.hero_id) AS hero_count\nFROM hero_power T1\nINNER JOIN superpower T2 ON T1.power_id = T2.id\nWHERE T2.power_name = 'Stealth'"
        ]
    },
    "674": {
        "question": "Who has the highest reputation? Please give the display name.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "amends": [],
        "rules": [
            "the highest reputation refers to MAX(Reputation);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DisplayName FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "rule_sql": []
    },
    "484": {
        "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
        "amends": [
            "Do use a single query with `INNER JOIN` between `foreign_data`, `cards`, and `sets` tables instead of using CTEs with separate `ColdsnapCards` and `MaxCMC` subqueries. Do filter directly with `T3.name = 'Coldsnap'` in the WHERE clause instead of creating a separate CTE for Coldsnap cards. Do add `ORDER BY T2.convertedManaCost DESC` to sort by converted mana cost in descending order instead of attempting to find maximum CMC through a separate CTE join. Do remove the unnecessary `MaxCMC` CTE and its join condition `cc.convertedManaCost = m.max_cmc` instead of trying to match maximum converted mana cost values. Do select `T2.name` (the card name from cards table) instead of selecting `fd.name` as italian_name from foreign_data. Do use table aliases `T1`, `T2`, and `T3` for clarity instead of the original table names. The amended query now correctly retrieves Italian card names from the Coldsnap set ordered by converted mana cost, matching the RIGHT_SQL's behavior.",
            "Do select `T2.name` instead of `T1.name AS italian_name` to retrieve the card name from the correct table. Do maintain the same `INNER JOIN` structure between `foreign_data T1` and `cards T2` but correct the join condition to `T2.uuid = T1.uuid` instead of `T1.uuid = T2.uuid` for proper table relationship. Do keep the `INNER JOIN` with `sets T3` on `T3.code = T2.setCode` instead of `T2.setCode = T3.code` for consistent join direction. Do preserve the `WHERE` filters for `T3.name = 'Coldsnap'` and `T1.language = 'Italian'` unchanged. Do maintain the `ORDER BY T2.convertedManaCost DESC` clause without modification. The amended query now correctly retrieves card names from the cards table rather than Italian names from foreign_data, while maintaining the same filtering and sorting logic to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for Italian names of cards: select T1.name from the foreign_data table where T1.language = 'Italian' exactly.\n2) When the question specifies cards from the Coldsnap set: filter using T3.name = 'Coldsnap' exactly in the WHERE clause.\n3) When combining tables for card information: link foreign_data (T1), cards (T2), and sets (T3) using T1.uuid = T2.uuid and T2.setCode = T3.code for inner matches.\n4) When ordering by highest converted mana cost: sort results by T2.convertedManaCost in descending order.\n5) When selecting output columns: use T1.name as the Italian card name.\n6) Output columns (ordered): T1.name",
            "1) When the question asks for Italian names of cards: select T2.name from the cards table instead of T1.name from foreign_data. 2) When joining foreign_data T1 and cards T2: link rows where T2.uuid = T1.uuid exactly. 3) When joining cards T2 and sets T3: link rows where T3.code = T2.setCode exactly. 4) When filtering for the Coldsnap set: include only rows where T3.name = 'Coldsnap' exactly. 5) When filtering for Italian language: include only rows where T1.language = 'Italian' exactly. 6) When ordering by converted mana cost: sort rows by T2.convertedManaCost in descending order. 7) When the question asks for highest converted mana cost: return all rows with the maximum T2.convertedManaCost value after sorting. Output columns (ordered): T2.name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH ColdsnapCards AS (\n    SELECT c.id, c.name, c.convertedManaCost, c.uuid\n    FROM cards c\n    JOIN sets s ON c.setCode = s.code\n    WHERE s.name = 'Coldsnap'\n),\nMaxCMC AS (\n    SELECT MAX(convertedManaCost) AS max_cmc\n    FROM ColdsnapCards\n)\nSELECT fd.name AS italian_name\nFROM foreign_data fd\nJOIN ColdsnapCards cc ON fd.uuid = cc.uuid\nJOIN MaxCMC m ON cc.convertedManaCost = m.max_cmc\nWHERE fd.language = 'Italian';",
            "SELECT T1.name AS italian_name\nFROM foreign_data T1\nINNER JOIN cards T2 ON T1.uuid = T2.uuid\nINNER JOIN sets T3 ON T2.setCode = T3.code\nWHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'\nORDER BY T2.convertedManaCost DESC;",
            "SELECT T2.name\nFROM foreign_data T1\nINNER JOIN cards T2 ON T2.uuid = T1.uuid\nINNER JOIN sets T3 ON T3.code = T2.setCode\nWHERE T3.name = 'Coldsnap'\nAND T1.language = 'Italian'\nORDER BY T2.convertedManaCost DESC;"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM foreign_data T1\nJOIN cards T2 ON T1.uuid = T2.uuid\nJOIN sets T3 ON T2.setCode = T3.code\nWHERE T1.language = 'Italian'\nAND T3.name = 'Coldsnap'\nAND T2.convertedManaCost = (\n    SELECT MAX(convertedManaCost) \n    FROM cards \n    JOIN sets ON cards.setCode = sets.code \n    WHERE sets.name = 'Coldsnap'\n)\nORDER BY T2.convertedManaCost DESC"
        ]
    },
    "99": {
        "question": "Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1",
        "amends": [
            "Do select only `account_id` instead of including `account_opening_date` and `approved_loan_amount`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit aliases `a` and `l`. Do place the `STRFTIME` filter on `T2.date` before the `duration` filter instead of after it. Do order by `T1.amount` instead of `l.amount`. The amended query now correctly returns only the account_id with the highest loan amount from 1993 accounts with loans longer than 12 months, matching the intended behavior.",
            "Do use `loan AS T1` as the primary table instead of `account T1` and join with `account AS T2` instead of `loan T2`, reversing the join direction. Do apply the duration filter on `T1.duration` instead of `T2.duration` to reference the correct table. Do maintain the same `STRFTIME` condition on `T2.date`, `ORDER BY T1.amount DESC`, and `LIMIT 1` as these remain functionally equivalent. The amended query now correctly filters duration from the loan table and maintains the proper table relationships to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for accounts with loan validity more than 12 months: filter rows where T1.duration > 12.\n2) When the question asks for accounts with opening date in 1993: filter rows where STRFTIME('%Y', T2.date) = '1993'.\n3) When the question asks for the highest approved amount: order rows by T1.amount in descending order and keep only the first row.\n4) When combining account and loan tables: link rows where T1.account_id = T2.account_id using an inner match.\n5) When the question asks to list accounts: output only the account_id column.\n6) Output columns (ordered): T2.account_id",
            "1) When the question asks for accounts with loan validity more than 12 months: filter rows where T1.duration > 12.\n2) When the question asks for accounts with account opening date in 1993: filter rows where STRFTIME('%Y', T2.date) = '1993'.\n3) When the question asks for accounts with the highest approved amount: order rows by T1.amount in descending order and keep only the top 1 row.\n4) When combining loan and account tables: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match).\n5) When choosing table aliases: use loan AS T1 as the primary table and account AS T2 as the joined table.\nOutput columns (ordered): T1.account_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.account_id, a.date AS account_opening_date, l.amount AS approved_loan_amount\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.duration > 12\nAND strftime('%Y', a.date) = '1993'\nORDER BY l.amount DESC\nLIMIT 1;",
            "SELECT T1.account_id\nFROM account T1\nINNER JOIN loan T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T2.date) = '1993'\nAND T2.duration > 12\nORDER BY T1.amount DESC\nLIMIT 1;",
            "SELECT T1.account_id\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T2.date) = '1993'\nAND T1.duration > 12\nORDER BY T1.amount DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.account_id\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.duration > 12\nAND STRFTIME('%Y', T2.date) = '1993'\nORDER BY T1.amount DESC\nLIMIT 1"
        ]
    },
    "961": {
        "question": "Which race has the shortest actual finishing time? Please give the name and year.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN results AS T2 on T1.raceId = T2.raceId WHERE T2.milliseconds IS NOT NULL ORDER BY T2.milliseconds LIMIT 1",
        "amends": [],
        "rules": [
            "shortest actual finishing time refers to Min(milliseconds) except milliseconds = null;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name AS race_name, r.year\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nWHERE res.milliseconds IS NOT NULL\nORDER BY res.milliseconds ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "327": {
        "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
        "amends": [
            "Do select only `molecule_id` instead of including `label` in the SELECT list. Do use table aliases `T1` and `T2` instead of `m` and `a`. Do wrap the query in a subquery with alias `T` instead of querying directly. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do group by only `molecule_id` instead of both `molecule_id` and `label`. Do reference `T2.atom_id` in the COUNT instead of `a.atom_id`. Do remove the redundant `m.label` from GROUP BY since it's filtered in WHERE. The amended query now correctly returns only molecule IDs meeting the criteria without redundant columns.",
            "Do use a subquery with `T1.molecule_id` and `COUNT(T2.atom_id)` in the SELECT list instead of only selecting `T1.molecule_id`. Do change the WHERE filter to `T1.label = '-'` instead of `T1.label != 'carcinogenic'`. Do alias the subquery as `t` instead of omitting the alias. Do remove the explicit table alias `T1` and `T2` from the outer query's SELECT clause instead of keeping them. The amended query now correctly filters for molecules with a dash label and counts atoms within a subquery structure, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for non-carcinogenic molecules: filter molecules where T1.label equals '-' exactly. 2) When counting atoms per molecule: count the number of T2.atom_id values for each T1.molecule_id. 3) When filtering for molecules with more than 5 atoms: keep only molecules where the atom count exceeds 5. 4) When combining molecule and atom tables: link rows where T1.molecule_id equals T2.molecule_id exactly and keep only matching pairs (inner match). 5) When grouping for aggregate calculations: organize results by T1.molecule_id only. 6) When selecting output columns: return only T1.molecule_id without including other columns. 7) When handling text literals: preserve the exact literal '-' with no changes to case or formatting. Output columns (ordered): T1.molecule_id",
            "1) When the question asks for non-carcinogenic molecules: filter for molecules where T1.label equals exactly '-' instead of using inequality comparisons. 2) When counting atoms per molecule: use T2.atom_id as the counting key within a subquery structure. 3) When the question specifies \"more than 5 atoms\": apply the condition COUNT(T2.atom_id) > 5 to filter molecules. 4) When using subqueries: alias the subquery as t for reference in the outer query. 5) When selecting from a subquery: reference only the column names without table aliases in the outer SELECT clause. 6) Output columns (ordered): molecule_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.molecule_id, m.label\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '-'\nGROUP BY m.molecule_id, m.label\nHAVING COUNT(a.atom_id) > 5;",
            "SELECT T1.molecule_id\nFROM molecule T1\nINNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.label != 'carcinogenic'\nGROUP BY T1.molecule_id\nHAVING COUNT(T2.atom_id) > 5",
            "SELECT molecule_id FROM (SELECT T1.molecule_id, COUNT(T2.atom_id) AS atom_count FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING atom_count > 5) AS t"
        ],
        "rule_sql": [
            "SELECT molecule_id FROM molecule T1 WHERE T1.label = '-' AND (SELECT COUNT(atom_id) FROM atom T2 WHERE T2.molecule_id = T1.molecule_id) > 5"
        ]
    },
    "762": {
        "question": "Which power do superheroes have the most of?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T1.hero_id) DESC LIMIT 1",
        "amends": [
            "Do use `T2.power_name` in the SELECT list instead of `sp.power_name` and remove the alias `power_count` instead of keeping it. Do use table aliases `T1` and `T2` instead of full table names and specify `INNER JOIN` explicitly instead of just `JOIN`. Do change the COUNT expression to `COUNT(T1.hero_id)` instead of `COUNT(hp.power_id)` to count heroes rather than power instances. Do move the ordering to use `ORDER BY COUNT(T1.hero_id) DESC` instead of ordering by the removed alias `power_count DESC`. The amended query now correctly identifies the most common power by counting distinct heroes who possess each power rather than counting power instances, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(T1.hero_id)` from the SELECT list instead of including it, as the query only needs to return the power name with the highest count rather than displaying the count value itself. Do keep the same `FROM` sources with `INNER JOIN` on `T1.power_id = T2.id` instead of changing the join logic. Do maintain the `GROUP BY T2.power_name` instead of altering the grouping. Do preserve the `ORDER BY COUNT(T1.hero_id) DESC` instead of modifying the ordering, as this correctly identifies the power with the maximum occurrence. Do retain `LIMIT 1` instead of removing the limit, ensuring only the top result is returned. The amended query now correctly returns only the power name with the highest frequency count while maintaining the same logical behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When counting superheroes per power: count distinct heroes using T1.hero_id instead of counting power instances. 2) When the question asks for \"the most\" of something: rank results by the count in descending order and keep only the top result. 3) When combining hero_power and superpower tables: link rows where T1.power_id = T2.id using an inner join. 4) When selecting output columns: include T2.power_name and the count of T1.hero_id without aliases. 5) When grouping results: organize by T2.power_name to show counts per power. 6) Output columns (ordered): T2.power_name, COUNT(T1.hero_id)",
            "1) When the question asks for \"the most\" of something: rank rows by the count of occurrences in descending order and keep only the top 1 row.\n2) When counting superheroes per power: organize results by T2.power_name and compute the count using T1.hero_id as the counting key.\n3) When combining hero_power and superpower tables: link rows where T1.power_id = T2.id and keep only matching pairs (inner match).\n4) When the output should show only the category with the highest count: remove the count value from the final output and display only the category name.\n5) Output columns (ordered): T2.power_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name, COUNT(hp.power_id) AS power_count\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nGROUP BY sp.power_name\nORDER BY power_count DESC\nLIMIT 1;",
            "SELECT T2.power_name, COUNT(T1.hero_id) \nFROM hero_power T1 \nINNER JOIN superpower T2 ON T1.power_id = T2.id \nGROUP BY T2.power_name \nORDER BY COUNT(T1.hero_id) DESC \nLIMIT 1;",
            "SELECT T2.power_name\nFROM hero_power T1\nINNER JOIN superpower T2 ON T1.power_id = T2.id\nGROUP BY T2.power_name\nORDER BY COUNT(T1.hero_id) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.power_name\nFROM hero_power T1\nINNER JOIN superpower T2 ON T1.power_id = T2.id\nGROUP BY T2.power_name\nORDER BY COUNT(T1.hero_id) DESC\nLIMIT 1;"
        ]
    },
    "169": {
        "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
        "db_id": "financial",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for each year. Do add `INNER JOIN` on `disp` with `type = 'OWNER'` filter instead of omitting the owner requirement. Do move the gender filter to the main `WHERE` clause instead of using a CTE. Do calculate the growth rate directly with `CASE` expressions for each year's sum instead of subtracting CTE results. Do cast the difference to `REAL` for proper division instead of implicit integer division. Do remove the unnecessary CTE structure and cross join instead of using a more efficient single-pass aggregation. The amended query now correctly filters for owner accounts only and handles the percentage calculation with proper type casting.",
            "Do remove the CASE wrapper and directly compute the growth calculation instead of conditionally handling zero denominators. Do cast the numerator difference to REAL for proper decimal division instead of implicit integer division. Do move the `type = 'OWNER'` filter from the JOIN condition to the WHERE clause instead of keeping it in the ON predicate. Do remove the explicit year filter `strftime('%Y', l.date) IN ('1996', '1997')` since the CASE expressions already handle specific years instead of redundant filtering. Do simplify table aliases to T1, T2, T3, T4 instead of single letters for consistency. The amended query now correctly performs the growth rate calculation with proper numeric handling and streamlined filtering.",
            "Do use `T1` as the loan table alias instead of `T4` and reference `T1.date` instead of `T4.date` in all date calculations. Do simplify the CASE expression by removing the conditional check for 1996 data presence and directly calculate the growth rate formula instead of wrapping it in a conditional. Do change the mathematical operation order to perform multiplication before division instead of division before multiplication. Do use table aliases `T2` for account, `T3` for disp, and `T4` for client instead of the original `T1`, `T2`, and `T3` assignments. Do reference `T3.type` in the WHERE clause instead of `T2.type` to match the corrected table alias assignments. Do remove the column alias `growth_rate` instead of keeping it for a cleaner single-value output. The amended query now correctly calculates the growth rate without unnecessary conditional logic and with proper table alias references.",
            "Do cast the difference calculation as `REAL` instead of performing direct arithmetic on integer values to ensure proper decimal division. Do use `T4.gender = 'M'` instead of `T4.gender = 'MALE'` to match the correct gender code format. Do adjust the join condition between `disp` and `account` tables to use `T3.account_id = T2.account_id` instead of `T2.account_id = T3.account_id` for proper relationship direction. Do remove the alias `growth_rate` from the calculation instead of keeping it to match the output format. The amended query now correctly calculates the percentage growth with proper type casting and accurate join relationships."
        ],
        "rules": [
            "1) When calculating growth rate between two years: use conditional aggregation with CASE expressions to compute sums for each year within a single query instead of separate CTEs. 2) When filtering for account ownership: join the disp table and include the condition disp.type = 'OWNER' to ensure only owner accounts are considered. 3) When filtering by client gender: apply the gender condition directly in the main WHERE clause as client.gender = 'M' instead of using CTEs. 4) When performing division for growth rate calculation: cast the difference to REAL type to ensure proper decimal division instead of integer division. 5) When computing percentage growth: calculate ((sum_1997 - sum_1996) / sum_1996) * 100 using the conditional sums from the same aggregation pass. 6) When combining tables for client-account relationships: use INNER JOIN between account, disp, and client tables with the appropriate key relationships. Output columns (ordered): growth_rate",
            "1) When computing growth rate between two years: calculate (sum for 1997 minus sum for 1996) divided by sum for 1996, multiplied by 100, and round to 2 decimal places, using REAL type for decimal division.\n2) When filtering for male clients: include only rows where gender equals 'M' exactly.\n3) When linking accounts to clients: ensure the relationship uses type = 'OWNER' in the WHERE clause condition.\n4) When handling year-specific amounts: use conditional summing for exact years '1996' and '1997' without additional year filtering.\n5) When combining tables: use T1 for loan, T2 for account, T3 for disp, T4 for client with exact key relationships (T1.account_id = T2.account_id, T2.account_id = T3.account_id, T3.client_id = T4.client_id).\n6) Output columns (ordered): growth_rate",
            "1) When calculating growth rate between two years: compute (sum for later year minus sum for earlier year) divided by sum for earlier year multiplied by 100, without conditional checks for data presence.\n2) When the question mentions \"male client\": filter rows where T4.gender equals 'M' exactly.\n3) When the question involves account ownership: filter rows where T3.type equals 'OWNER' exactly.\n4) When combining loan and account tables: link rows where T1.account_id equals T2.account_id exactly.\n5) When combining account and disp tables: link rows where T2.account_id equals T3.account_id exactly.\n6) When combining disp and client tables: link rows where T3.client_id equals T4.client_id exactly.\n7) When calculating amounts by year: use T1.date to extract year values and sum T1.amount for each year.\n8) When performing mathematical operations: execute multiplication before division in the growth rate formula.\n9) Output columns (ordered): the growth rate calculation result",
            "1) When calculating percentage growth between years: cast the difference calculation as REAL instead of performing direct arithmetic on integer values to ensure proper decimal division.\n2) When filtering by gender: use T4.gender = 'M' instead of 'MALE' to match the correct gender code format.\n3) When joining disp and account tables: use T3.account_id = T2.account_id instead of T2.account_id = T3.account_id for proper relationship direction.\n4) When outputting the result: remove any alias from the growth rate calculation to match the required output format.\n5) When combining loan, account, disp, and client tables: link rows where T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T3.client_id = T4.client_id; keep only matching pairs (inner match).\n6) When filtering for account ownership: use T3.type = 'OWNER' to identify primary account holders.\n7) When calculating growth rate between 1996 and 1997: compute (sum of amounts from 1997 minus sum of amounts from 1996) multiplied by 100.0 divided by sum of amounts from 1996, using exact year literals '1996' and '1997'.\nOutput columns (ordered): (SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100.0 / SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH male_accounts AS (\n    SELECT a.account_id\n    FROM account a\n    JOIN disp d ON a.account_id = d.account_id\n    JOIN client c ON d.client_id = c.client_id\n    WHERE c.gender = 'M'\n),\nloans_1996 AS (\n    SELECT SUM(amount) AS total_amount\n    FROM loan\n    WHERE account_id IN (SELECT account_id FROM male_accounts)\n    AND strftime('%Y', date) = '1996'\n),\nloans_1997 AS (\n    SELECT SUM(amount) AS total_amount\n    FROM loan\n    WHERE account_id IN (SELECT account_id FROM male_accounts)\n    AND strftime('%Y', date) = '1997'\n)\nSELECT \n    ((loans_1997.total_amount - loans_1996.total_amount) / loans_1996.total_amount) * 100 AS growth_rate\nFROM loans_1996, loans_1997;",
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END) > 0 \n        THEN ROUND((\n            (SUM(CASE WHEN strftime('%Y', l.date) = '1997' THEN l.amount ELSE 0 END) - \n             SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END)) * 100.0 / \n            SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END)\n        ), 2)\n        ELSE NULL \n    END AS growth_rate\nFROM loan l\nINNER JOIN account a ON l.account_id = a.account_id\nINNER JOIN disp d ON a.account_id = d.account_id AND d.type = 'OWNER'\nINNER JOIN client c ON d.client_id = c.client_id\nWHERE c.gender = 'M' \nAND (strftime('%Y', l.date) IN ('1996', '1997')",
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN strftime('%Y', T4.date) = '1996' THEN T4.amount ELSE 0 END) > 0 \n        THEN CAST(\n            (SUM(CASE WHEN strftime('%Y', T4.date) = '1997' THEN T4.amount ELSE 0 END) - \n             SUM(CASE WHEN strftime('%Y', T4.date) = '1996' THEN T4.amount ELSE 0 END)\n        ) AS REAL) / \n             SUM(CASE WHEN strftime('%Y', T4.date) = '1996' THEN T4.amount ELSE 0 END) * 100 \n        ELSE NULL \n    END AS growth_rate\nFROM \n    loan T4\nINNER JOIN \n    account T1 ON T4.account_id = T1.account_id\nINNER JOIN \n    disp T2 ON T1.account_id = T2.account_id\nINNER JOIN \n    client T3 ON T2.client_id = T3.client_id\nWHERE \n    T3.gender = 'M' \n    AND T2.type = 'OWNER'",
            "SELECT \n    (SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - \n     SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS growth_rate\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T3 ON T2.account_id = T3.account_id\nINNER JOIN client T4 ON T3.client_id = T4.client_id\nWHERE T3.type = 'OWNER' \n    AND T4.gender = 'MALE'",
            "SELECT \n    (SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - \n     SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS growth_rate\nFROM \n    loan T1\n    INNER JOIN account T2 ON T1.account_id = T2.account_id\n    INNER JOIN disp T3 ON T2.account_id = T3.account_id\n    INNER JOIN client T4 ON T3.client_id = T4.client_id\nWHERE \n    T3.type = 'OWNER' \n    AND T4.gender = 'M'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN strftime('%Y', loan.date) = '1997' THEN loan.amount ELSE 0 END) - \n     SUM(CASE WHEN strftime('%Y', loan.date) = '1996' THEN loan.amount ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN strftime('%Y', loan.date) = '1996' THEN loan.amount ELSE 0 END) AS growth_rate\nFROM \n    loan\nINNER JOIN \n    account ON loan.account_id = account.account_id\nINNER JOIN \n    disp ON account.account_id = disp.account_id\nINNER JOIN \n    client ON disp.client_id = client.client_id\nWHERE \n    client.gender = 'M' \n    AND disp.type = 'OWNER'"
        ]
    },
    "943": {
        "question": "What is the rate of drivers completing all the laps in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.resultId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008",
        "amends": [
            "Do use a single query with `INNER JOIN` between `results` and `races` on `raceId` instead of using CTEs with subqueries. Do calculate completion rate using `SUM(IIF(time IS NOT NULL, 1, 0))` for completed laps instead of separate CTEs for completed and total counts. Do multiply by `100` to get percentage instead of returning a decimal fraction. Do filter directly in the `WHERE` clause with `name = 'Australian Grand Prix' AND year = 2008` instead of using a CTE to first find the raceId. Do reference tables with aliases `T1` and `T2` instead of no aliases. Do count using `resultId` instead of generic `COUNT(*)` for more precise results. The amended query now correctly calculates the percentage completion rate for the specified race directly without unnecessary subqueries and CTEs."
        ],
        "rules": [
            "1) When the question asks for a rate of drivers completing all laps in a specific Grand Prix: combine information from the results and races tables using an inner match on raceId. 2) When filtering for the 2008 Australian Grand Prix: apply conditions year = 2008 AND name = 'Australian Grand Prix' exactly as specified. 3) When calculating completion rate: compute the percentage by taking (SUM(IIF(time IS NOT NULL, 1, 0)) / COUNT(resultId)) * 100. 4) When counting drivers: use resultId as the counting key instead of generic counting. 5) When handling text literals: preserve exact case and spacing for 'Australian Grand Prix'. 6) When combining tables: use T1 for results and T2 for races with inner join on T1.raceId = T2.raceId. 7) Output columns (ordered): completion_rate"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH race_info AS (\n    SELECT raceId\n    FROM races\n    WHERE year = 2008 AND name = 'Australian Grand Prix'\n),\ncompleted_laps AS (\n    SELECT COUNT(*) AS completed\n    FROM results\n    WHERE raceId = (SELECT raceId FROM race_info) AND time IS NOT NULL\n),\ntotal_drivers AS (\n    SELECT COUNT(*) AS total\n    FROM results\n    WHERE raceId = (SELECT raceId FROM race_info)\n)\nSELECT CAST(completed AS REAL) / CAST(total AS REAL) AS completion_rate\nFROM completed_laps, total_drivers;",
            "SELECT \n    (SUM(IIF(T1.time IS NOT NULL, 1, 0)) * 100.0 / COUNT(T1.resultId)) AS completion_rate\nFROM \n    results T1\nINNER JOIN \n    races T2 ON T1.raceId = T2.raceId\nWHERE \n    T2.name = 'Australian Grand Prix' AND T2.year = 2008;"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(T1.time IS NOT NULL, 1, 0)) * 100.0 / COUNT(T1.resultId)) AS completion_rate\nFROM \n    results T1\nINNER JOIN \n    races T2 ON T1.raceId = T2.raceId\nWHERE \n    T2.year = 2008 \n    AND T2.name = 'Australian Grand Prix'"
        ]
    },
    "1183": {
        "question": "For the patient who was diagnosed SLE on 1997/1/27, what was his/her original diagnose when he/she came to the hospital for the first time?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = ( SELECT ID FROM Examination WHERE `Examination Date` = '1997-01-27' AND Diagnosis = 'SLE' ) AND T2.`Examination Date` = T1.`First Date`",
        "amends": [],
        "rules": [
            "'SLE' AND original diagnose refers to diagnosis; 1997/1/27 refer to `Examination Date` = '1997-01-27'; first came to the hospital refers to patient.`First Date`"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Diagnosis\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE e.Diagnosis = 'SLE' AND e.`Examination Date` = '1997-01-27' AND p.`First Date` IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1136": {
        "question": "How many players had the highest potential score for crossing that preferred to use their left foots while attacking?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(t1.id) FROM Player_Attributes AS t1 WHERE t1.preferred_foot = 'left' AND t1.crossing = ( SELECT MAX(crossing) FROM Player_Attributes)",
        "amends": [],
        "rules": [
            "highest potential score for crossing refers to MAX(crossing); preferred to use their left foots while attacking refers to preferred_foot = 'left'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS number_of_players\nFROM Player_Attributes\nWHERE crossing = (SELECT MAX(crossing) FROM Player_Attributes)\nAND preferred_foot = 'left'\nAND attacking_work_rate IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "629": {
        "question": "Calculate the ratio of votes in 2010 and 2011.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
        "amends": [],
        "rules": [
            "DIVIDE(COUNT(Id where YEAR(CreationDate) = 2010), COUNT(Id where YEAR(CreationDate) = 2011)) FROM votes;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM votes WHERE strftime('%Y', CreationDate) = '2010') * 1.0 / \n    (SELECT COUNT(*) FROM votes WHERE strftime('%Y', CreationDate) = '2011') AS ratio_2010_to_2011;"
        ],
        "rule_sql": []
    },
    "249": {
        "question": "What are the elements of the atoms of TR144_8_19?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'",
        "amends": [
            "Do select only `T2.element` instead of both `a1.element` and `a2.element` with aliases. Do use `INNER JOIN` with `atom AS T2` on `T1.atom_id = T2.atom_id` instead of joining two atom tables on different columns. Do remove the second join to `atom a2` on `c.atom_id2 = a2.atom_id` instead of keeping it. Do use table alias `T1` for `connected` instead of `c`. Do remove the unnecessary column aliases `element1` and `element2` instead of including them. The amended query now correctly retrieves only the element from the single relevant atom table based on the atom_id relationship, matching the RIGHT_SQL's behavior.",
            "Do remove the `INNER JOIN molecule AS m ON T2.molecule_id = m.molecule_id` and its associated condition instead of including it. Do change the WHERE filter to use `T1.bond_id = 'TR144_8_19'` instead of `m.label = 'TR144_8_19'`. The amended query now correctly filters by bond_id from the connected table rather than incorrectly joining through molecule to check label, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for elements of atoms related to a specific bond ID: filter rows where T1.bond_id equals exactly 'TR144_8_19'. 2) When combining the connected table (T1) with the atom table (T2): link rows where T1.atom_id equals T2.atom_id and keep only matching pairs. 3) When selecting output columns: include only T2.element without any column aliases. 4) Output columns (ordered): T2.element",
            "1) When the question asks for elements of atoms related to a specific bond identifier: filter rows where T1.bond_id equals the exact literal 'TR144_8_19'. 2) When combining connected and atom tables: link rows where T1.atom_id equals T2.atom_id and keep only matching pairs (inner match). 3) When selecting output columns: include only T2.element from the results. 4) Output columns (ordered): T2.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR144_8_19';",
            "SELECT T2.element \nFROM connected AS T1 \nINNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id \nINNER JOIN molecule AS m ON T2.molecule_id = m.molecule_id \nWHERE m.label = 'TR144_8_19'",
            "SELECT T2.element\nFROM connected AS T1\nINNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.bond_id = 'TR144_8_19'"
        ],
        "rule_sql": [
            "SELECT T2.element FROM connected T1 JOIN atom T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'"
        ]
    },
    "1076": {
        "question": "What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye\n?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.id ELSE NULL END) - CAST(SUM(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.id ELSE NULL END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "amends": [],
        "rules": [
            "difference of the average ball control = SUBTRACT(AVG(ball_control WHERE player_name = 'Abdou Diallo'), AVG(ball_control WHERE player_name = 'Aaron Appindangoye')); AVG(ball_control WHERE player_name = 'XX XX') = SUM(CASE WHEN player_name = 'XX XX' THEN ball_control ELSE 0 END) / COUNT(CASE WHEN player_name = 'XX XX' THEN id ELSE NULL END)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH diallo_avg AS (\n    SELECT AVG(pa.ball_control) AS avg_ball_control\n    FROM Player_Attributes pa\n    JOIN Player p ON pa.player_api_id = p.player_api_id\n    WHERE p.player_name = 'Abdou Diallo'\n),\nappindangoye_avg AS (\n    SELECT AVG(pa.ball_control) AS avg_ball_control\n    FROM Player_Attributes pa\n    JOIN Player p ON pa.player_api_id = p.player_api_id\n    WHERE p.player_name = 'Aaron Appindangoye'\n)\nSELECT diallo_avg.avg_ball_control - appindangoye_avg.avg_ball_control AS difference_in_avg_ball_control\nFROM diallo_avg, appindangoye_avg;"
        ],
        "rule_sql": []
    },
    "662": {
        "question": "How many posts with votes that were created in 2011 have a bounty of 50?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.BountyAmount = 50 AND STRFTIME('%Y', T2.CreationDate) = '2011'",
        "amends": [],
        "rules": [
            "created in 2012 refers YEAR(CreationDate) = 2011; BountyAmount = 50;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.Id) \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE strftime('%Y', v.CreationDate) = '2011' \nAND v.BountyAmount = 50;"
        ],
        "rule_sql": []
    },
    "741": {
        "question": "What is the name of the superhero that has the most powers?",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "name of the superhero refers to superhero_name; superhero that has the most powers refers to MAX(COUNT(superhero_name))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nGROUP BY s.superhero_name\nORDER BY COUNT(hp.power_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "342": {
        "question": "List the card names with value that cost more converted mana for the face.",
        "db_id": "card_games",
        "ground_truth": "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1",
        "amends": [
            "Do use `ORDER BY faceConvertedManaCost LIMIT 1` instead of a subquery with `MAX(faceConvertedManaCost)` to find the maximum value. Do remove the subquery entirely instead of keeping it, as the subquery approach is less efficient and potentially incorrect when multiple cards share the maximum converted mana cost. Do ensure the query returns exactly one row with the highest faceConvertedManaCost instead of potentially returning multiple rows if multiple cards have the same maximum value. The amended query now correctly returns the card name with the highest faceConvertedManaCost using a more efficient and reliable approach.",
            "Do remove the `DESC` keyword from the `ORDER BY` clause instead of keeping it, which changes the sort order from descending to ascending to correctly identify the card with the lowest converted mana cost rather than the highest. The amended query now matches RIGHT_SQL's behavior by returning the card name with the minimum faceConvertedManaCost value."
        ],
        "rules": [
            "1) When the question asks for cards with the highest faceConvertedManaCost: rank rows by faceConvertedManaCost in descending order and keep the first 1 row. 2) When multiple cards share the maximum faceConvertedManaCost value: break ties using the canonical key if shown in the amends (e.g., name). 3) When ordering by faceConvertedManaCost: use descending order to get the highest values first. 4) Output columns (ordered): name",
            "1) When the question asks for cards that \"cost more converted mana for the face\": order rows by the exact token \"faceConvertedManaCost\" in ascending order to find the minimum value. 2) When the question asks to \"list the card names\": include the exact token \"name\" in the output. 3) When only one result is needed for the extreme value: keep only the first row after ordering. 4) Output columns (ordered): name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE faceConvertedManaCost = (SELECT MAX(faceConvertedManaCost) FROM cards);",
            "SELECT name FROM cards ORDER BY faceConvertedManaCost DESC LIMIT 1;",
            "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name FROM cards ORDER BY faceConvertedManaCost ASC LIMIT 1;"
        ]
    },
    "798": {
        "question": "What is the publisher for Hawkman, Karate Kid and Speedy?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')",
        "amends": [
            "Do select only `publisher_name` instead of including `superhero_name` in the SELECT list. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference the publisher table as `T2` instead of `p` and superhero table as `T1` instead of `s` for consistent table aliasing. The amended query now correctly returns only publisher names for the specified superheroes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for publisher information for specific superheroes: select only the publisher_name column from the publisher table (T2). 2) When joining the superhero table (T1) with the publisher table (T2): use an inner join where T1.publisher_id equals T2.id. 3) When filtering for specific superhero names: include only rows where T1.superhero_name exactly matches one of the literal values 'Hawkman', 'Karate Kid', or 'Speedy'. 4) When using table aliases: refer to the superhero table as T1 and the publisher table as T2. 5) Output columns (ordered): T2.publisher_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name, p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');",
            "SELECT T2.publisher_name\nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nWHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')"
        ],
        "rule_sql": [
            "SELECT T2.publisher_name FROM superhero T1 INNER JOIN publisher T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')"
        ]
    },
    "1023": {
        "question": "Among the players with an overall rating between 60 to 65, how many players whose going to be in all of your attack moves instead of defensing?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT COUNT(id) FROM Player_Attributes WHERE overall_rating BETWEEN 60 AND 65 AND defensive_work_rate = 'low'",
        "amends": [],
        "rules": [
            "overall_rating > = 60 AND overall_rating < 65; players whose going to be in all of your attack moves instead of defensing refers to defensive_work_rate = 'low';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS number_of_players\nFROM Player_Attributes\nWHERE overall_rating BETWEEN 60 AND 65\nAND defensive_work_rate = 'low';"
        ],
        "rule_sql": []
    },
    "483": {
        "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
        "amends": [
            "Do select only `T1.text` instead of `c.name` and `fd.text` with aliases. Do use `INNER JOIN` for both joins instead of `JOIN` (which is equivalent but explicit). Do join `cards` to `foreign_data` on `T2.uuid = T1.uuid` instead of `c.uuid = fd.uuid`, maintaining the same logic. Do join `sets` on `T3.code = T2.setCode` instead of `c.setCode = s.code`, preserving the relationship. Do add `DISTINCT` to eliminate duplicate rows instead of potentially returning multiple identical entries. Do remove the column aliases `card_name` and `italian_ruling_text` since only one column is selected. The amended query now correctly returns distinct Italian ruling texts for Coldsnap cards, matching the RIGHT_SQL's behavior.",
            "Do filter on `T3.name = 'Coldsnap'` instead of `T3.code = 'Coldsnap'` to correctly identify the set by name rather than code. Do maintain the `SELECT DISTINCT T1.text` clause and the join structure with `INNER JOIN cards T2 ON T2.uuid = T1.uuid` and `INNER JOIN sets T3 ON T3.code = T2.setCode` as they remain unchanged. Do keep the `T1.language = 'Italian'` filter in the WHERE clause. The amended query now correctly matches the RIGHT_SQL's behavior by filtering on the set name rather than code."
        ],
        "rules": [
            "1) When the question asks for Italian text ruling of cards: select only the exact column T1.text from the foreign_data table.\n2) When joining cards and foreign_data tables: link rows where T2.uuid = T1.uuid using an inner match.\n3) When joining sets table to cards: link rows where T3.code = T2.setCode using an inner match.\n4) When filtering for the Coldsnap set: include only rows where T3.name equals 'Coldsnap' exactly.\n5) When filtering for Italian language: include only rows where T1.language equals 'Italian' exactly.\n6) When eliminating duplicate entries: apply distinct processing to ensure unique results.\nOutput columns (ordered): T1.text",
            "1) When the question asks for Italian text rulings: filter for T1.language = 'Italian' exactly as written. 2) When identifying cards from the Coldsnap set: filter on T3.name = 'Coldsnap' exactly as written, not using the code field. 3) When combining foreign_data with cards: link rows where T2.uuid = T1.uuid exactly as shown. 4) When combining cards with sets: link rows where T3.code = T2.setCode exactly as shown. 5) When selecting text from foreign_data: use T1.text and ensure distinct values are returned. 6) When performing inner joins between tables: keep only matching pairs where the join conditions are satisfied exactly as specified. Output columns (ordered): T1.text"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name AS card_name, fd.text AS italian_ruling_text\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE s.name = 'Coldsnap' AND fd.language = 'Italian';",
            "SELECT DISTINCT T1.text\nFROM foreign_data T1\nINNER JOIN cards T2 ON T2.uuid = T1.uuid\nINNER JOIN sets T3 ON T3.code = T2.setCode\nWHERE T1.language = 'Italian' AND T3.code = 'Coldsnap'",
            "SELECT DISTINCT T1.text\nFROM foreign_data T1\nINNER JOIN cards T2 ON T2.uuid = T1.uuid\nINNER JOIN sets T3 ON T3.code = T2.setCode\nWHERE T1.language = 'Italian' AND T3.name = 'Coldsnap'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.text\nFROM foreign_data T1\nINNER JOIN cards T2 ON T2.uuid = T1.uuid\nINNER JOIN sets T3 ON T3.code = T2.setCode\nWHERE T1.language = 'Italian'\nAND T3.name = 'Coldsnap';"
        ]
    },
    "1255": {
        "question": "For the patients with an abnormal Ig M level, what is the most common disease they are diagnosed with?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGM NOT BETWEEN 40 AND 400 GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1",
        "amends": [
            "Do use `SELECT T1.Diagnosis` with explicit table alias instead of just `Diagnosis`. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of using a CTE with subquery. Do filter with `T2.IGM NOT BETWEEN 40 AND 400` instead of `IGM <= 40 OR IGM >= 400` in a separate CTE. Do remove the DISTINCT operation and CTE structure instead of keeping them. Do group by `T1.Diagnosis` instead of grouping in a separate CTE. Do order by `COUNT(T1.Diagnosis)` directly instead of ordering by a pre-computed count column. Do remove the explicit NULL check on Diagnosis since the join and grouping implicitly handle this. The amended query now correctly joins patient and laboratory data directly and matches the right SQL's behavior.",
            "Do remove `COUNT(T1.Diagnosis) AS count_diagnosis` from the SELECT list instead of including it, as the RIGHT_SQL only needs to return the Diagnosis column without the count aggregation. The amended query now correctly returns only the Diagnosis column while maintaining the same join logic, filtering condition, grouping, and ordering behavior as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks about patients with abnormal Ig M levels: filter Laboratory table rows where IGM is not between 40 and 400 using T2.IGM NOT BETWEEN 40 AND 400.\n2) When combining patient and laboratory data: link Patient as T1 and Laboratory as T2 where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When grouping by diagnosis: organize results by T1.Diagnosis and compute counts per diagnosis group.\n4) When counting diagnoses: compute the number of rows using T1.Diagnosis as the counting entity.\n5) When finding the most common diagnosis: rank rows by count of T1.Diagnosis in descending order and keep the first 1 row.\n6) When handling diagnosis values: do not explicitly check for NULL since the join and grouping implicitly handle missing values.\n7) When selecting output: use explicit table alias T1.Diagnosis instead of unqualified Diagnosis.\n8) Output columns (ordered): T1.Diagnosis",
            "1) When the question asks for the most common disease among patients with abnormal Ig M levels: identify patients with abnormal Ig M levels by checking where T2.IGM is not between 40 and 400.\n2) When combining Patient and Laboratory tables for shared patients: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When grouping by diagnosis to find the most common disease: organize results by T1.Diagnosis and count occurrences per diagnosis group.\n4) When ranking diagnoses by frequency to find the most common: order results by count of diagnoses in descending order.\n5) When selecting only the top result: keep the first row after ordering by frequency.\n6) Output columns (ordered): T1.Diagnosis"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH AbnormalIgMPatients AS (\n    SELECT DISTINCT ID\n    FROM Laboratory\n    WHERE IGM <= 40 OR IGM >= 400\n),\nDiagnosisCount AS (\n    SELECT Diagnosis, COUNT(*) AS Count\n    FROM Examination\n    WHERE ID IN (SELECT ID FROM AbnormalIgMPatients) AND Diagnosis IS NOT NULL\n    GROUP BY Diagnosis\n)\nSELECT Diagnosis\nFROM DiagnosisCount\nORDER BY Count DESC\nLIMIT 1;",
            "SELECT T1.Diagnosis, COUNT(T1.Diagnosis) AS count_diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.IGM NOT BETWEEN 40 AND 400\nGROUP BY T1.Diagnosis\nORDER BY COUNT(T1.Diagnosis) DESC\nLIMIT 1;",
            "SELECT T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.IGM NOT BETWEEN 40 AND 400\nGROUP BY T1.Diagnosis\nORDER BY COUNT(T1.Diagnosis) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Diagnosis\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGM NOT BETWEEN 40 AND 400\nGROUP BY T1.Diagnosis\nORDER BY COUNT(T1.Diagnosis) DESC\nLIMIT 1"
        ]
    },
    "429": {
        "question": "What is the language and expansion type of set number 206?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.language, T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 206",
        "amends": [
            "Do use `INNER JOIN` instead of `LEFT JOIN` to ensure only matching records are returned. Do reference `T2.id` in the WHERE clause instead of `s.id` to filter by the set_translations table's ID rather than the sets table's ID. Do swap the column order in the SELECT list, placing `T2.language` first instead of `s.type AS expansion_type` second. Do use table aliases `T1` and `T2` instead of `s` and `st` for better clarity. Do remove the alias `expansion_type` for the type column instead of keeping it. The amended query now correctly filters by the set_translations table ID and returns only matching records between the two tables."
        ],
        "rules": [
            "1) When joining tables T1 and T2: use an inner match where T1.code equals T2.setCode to ensure only matching records are returned. 2) When filtering by set number 206: apply the condition T2.id = 206 to filter by the set_translations table's ID. 3) When selecting output columns: place T2.language first and T1.type second in the result. 4) When naming columns: do not use aliases for T1.type, output it as T1.type. 5) Output columns (ordered): T2.language, T1.type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.type AS expansion_type, st.language FROM sets s LEFT JOIN set_translations st ON s.code = st.setCode WHERE s.id = 206;",
            "SELECT T2.language, s.type FROM sets s INNER JOIN set_translations T2 ON s.code = T2.setCode WHERE T2.id = 206"
        ],
        "rule_sql": [
            "SELECT T2.language, T1.type FROM sets T1 INNER JOIN set_translations T2 ON T1.code = T2.setCode WHERE T2.id = 206"
        ]
    },
    "886": {
        "question": "Which year has the most number of races?",
        "db_id": "formula_1",
        "ground_truth": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
        "amends": [
            "Do order by `COUNT(round)` instead of `race_count` alias. Do remove the `COUNT(*) AS race_count` column selection instead of including it. Do count `round` instead of `*` in the ORDER BY clause. The amended query now correctly identifies the year with the most rounds by counting actual race rounds rather than using an alias that references the count itself, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting races: count the \"round\" column instead of all columns. 2) When ordering by the count: use the actual count expression (COUNT(round)) instead of an alias reference. 3) When selecting output columns: include only the \"year\" column and exclude the count column from the final output. 4) When finding the year with the most races: order the results by the count of rounds in descending order and keep only the top result. 5) Output columns (ordered): year"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) AS race_count FROM races GROUP BY year ORDER BY race_count DESC LIMIT 1;",
            "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1;"
        ]
    },
    "649": {
        "question": "Describe the post history counts and last edit date of the post title \"What is the best introductory Bayesian statistics textbook?\"",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Id, T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'",
        "amends": [
            "Do select `T1.Id` and `T2.LastEditDate` instead of aggregating with `COUNT(ph.Id)` and `MAX(ph.CreationDate)`. Do use `INNER JOIN` with `T1.PostId = T2.Id` instead of `JOIN` with `p.Id = ph.PostId`. Do move the filter to `WHERE T2.Title` instead of `WHERE p.Title`. Do remove the `GROUP BY p.Id` clause instead of keeping it. Do reference tables as `postHistory AS T1` and `posts AS T2` instead of `posts p` and `postHistory ph`. The amended query now correctly retrieves individual post history records with their last edit dates instead of aggregating counts and maximum dates per post."
        ],
        "rules": [
            "1) When the question asks for post history counts and last edit date of a specific post title: retrieve individual post history records with their last edit dates instead of aggregating counts and maximum dates per post.\n2) When joining postHistory and posts tables: use INNER JOIN with T1.PostId = T2.Id to link post history records to their corresponding posts.\n3) When filtering by post title: apply the filter condition to T2.Title instead of the joined table.\n4) When selecting columns: choose T1.Id and T2.LastEditDate instead of aggregated counts and maximum dates.\n5) When handling individual records: remove GROUP BY clauses that would aggregate results by post ID.\n6) When assigning table aliases: use postHistory AS T1 and posts AS T2 as the canonical reference scheme.\n7) When matching exact text literals: preserve the exact title string 'What is the best introductory Bayesian statistics textbook?' with its original case, spacing, and punctuation.\nOutput columns (ordered): T1.Id, T2.LastEditDate"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    COUNT(ph.Id) AS post_history_count,\n    MAX(ph.CreationDate) AS last_edit_date\nFROM \n    posts p\nJOIN \n    postHistory ph ON p.Id = ph.PostId\nWHERE \n    p.Title = 'What is the best introductory Bayesian statistics textbook?'\nGROUP BY \n    p.Id;",
            "SELECT T1.Id, T2.LastEditDate \nFROM postHistory AS T1 \nINNER JOIN posts AS T2 ON T1.PostId = T2.Id \nWHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'"
        ],
        "rule_sql": [
            "SELECT T1.Id, T2.LastEditDate\nFROM postHistory AS T1\nINNER JOIN posts AS T2 ON T1.PostId = T2.Id\nWHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'"
        ]
    },
    "948": {
        "question": "What are the maximum points of British constructors?",
        "db_id": "formula_1",
        "ground_truth": "SELECT MAX(T1.points) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T2.nationality = 'British'",
        "amends": [],
        "rules": [
            "maximum points = MAX(points); British is a nationality"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(cs.points) AS max_points\nFROM constructors c\nJOIN constructorStandings cs ON c.constructorId = cs.constructorId\nWHERE c.nationality = 'British';"
        ],
        "rule_sql": []
    },
    "49": {
        "question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
        "db_id": "california_schools",
        "ground_truth": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Closed' AND school IS NOT NULL",
        "amends": [
            "Do use a subquery to find the county with the most closed schools instead of a CTE with JOIN. Do filter directly on `StatusType = 'Closed'` in the main query instead of using a CTE. Do add `DISTINCT` to eliminate duplicates instead of omitting it. Do add `school IS NOT NULL` filter instead of omitting it. Do remove the explicit ordering by `ClosedDate` instead of keeping it. Do use `COUNT(School)` in the subquery instead of `COUNT(*)` to count actual schools. The amended query now correctly identifies the county with the most closed schools and returns all closed schools from that county while ensuring no null school values."
        ],
        "rules": [
            "1) When the question asks for \"most number of closed schools\" by county: find the county with the maximum count of schools where StatusType equals 'Closed' and school is not null.\n2) When counting schools: use COUNT(School) to count actual schools instead of all rows.\n3) When filtering for closed schools: include only rows where StatusType equals 'Closed' exactly.\n4) When ensuring data quality: filter out null school values by including school IS NOT NULL.\n5) When eliminating duplicates: use DISTINCT to ensure unique results.\n6) When the question asks for school names and closure dates: include both School and ClosedDate columns in the output.\n7) When finding the county with maximum count: use a subquery to identify the county with the highest count of closed schools.\n8) When the question does not specify ordering: do not apply explicit ordering to the results.\nOutput columns (ordered): County, School, ClosedDate"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH ClosedSchools AS (\n    SELECT County, School, ClosedDate\n    FROM schools\n    WHERE StatusType = 'Closed'\n),\nCountyCount AS (\n    SELECT County, COUNT(*) AS SchoolCount\n    FROM ClosedSchools\n    GROUP BY County\n    ORDER BY SchoolCount DESC\n    LIMIT 1\n)\nSELECT cs.County, cs.School, cs.ClosedDate\nFROM ClosedSchools cs\nJOIN CountyCount cc ON cs.County = cc.County\nORDER BY cs.ClosedDate;",
            "SELECT s.County, s.School, s.ClosedDate \nFROM schools s \nWHERE s.StatusType = 'Closed' \nAND s.School IS NOT NULL \nAND s.County = (\n    SELECT s2.County \n    FROM schools s2 \n    WHERE s2.StatusType = 'Closed' \n    AND s2.School IS NOT NULL \n    GROUP BY s2.County \n    ORDER BY COUNT(s2.School) DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT s.County, s.School, s.ClosedDate\nFROM schools s\nWHERE s.StatusType = 'Closed' \nAND s.School IS NOT NULL\nAND s.County = (\n    SELECT s2.County\n    FROM schools s2\n    WHERE s2.StatusType = 'Closed'\n    AND s2.School IS NOT NULL\n    GROUP BY s2.County\n    ORDER BY COUNT(s2.School) DESC\n    LIMIT 1\n)"
        ]
    }
}