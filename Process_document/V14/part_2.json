{
    "6": {
        "question": "Among the schools with the SAT test takers of over 500, please list the schools that are magnet schools or offer a magnet program.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Magnet = 1 AND T1.NumTstTakr > 500",
        "amends": [
            "Do select only `T2.School` instead of multiple columns including `s.CDSCode`, `s.School`, `s.District`, `s.County`, `sc.NumTstTakr`, `sc.AvgScrRead`, `sc.AvgScrMath`, and `sc.AvgScrWrite`. Do use explicit `INNER JOIN` with table aliases `T1` and `T2` instead of implicit `JOIN` with aliases `s` and `sc`. Do join on `T1.cds = T2.CDSCode` instead of `s.CDSCode = sc.cds`. Do apply the `Magnet = 1` filter to `T2` instead of `s` and the `NumTstTakr > 500` filter to `T1` instead of `sc`. The amended query now correctly focuses on retrieving only school names from magnet schools with sufficient test takers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for schools with specific attributes: select only the school name column \"T2.School\" instead of multiple columns. 2) When joining tables \"satscores\" and \"schools\": use explicit INNER JOIN with table aliases T1 for \"satscores\" and T2 for \"schools\". 3) When combining T1 and T2 for shared entities: link rows where T1.cds = T2.CDSCode exactly. 4) When filtering for magnet schools: apply the condition T2.Magnet = 1 to the schools table. 5) When filtering for SAT test takers over 500: apply the condition T1.NumTstTakr > 500 to the satscores table. 6) Output columns (ordered): T2.School"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.CDSCode, s.School, s.District, s.County, sc.NumTstTakr, sc.AvgScrRead, sc.AvgScrMath, sc.AvgScrWrite\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.Magnet = 1 AND sc.NumTstTakr > 500;",
            "SELECT T2.School \nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.NumTstTakr > 500\nAND T2.Magnet = 1"
        ],
        "rule_sql": [
            "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.NumTstTakr > 500\nAND T2.Magnet = 1\nORDER BY T2.School;"
        ]
    },
    "1408": {
        "question": "Calculate the total cost spent for Parking in the list.",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Parking'",
        "amends": [],
        "rules": [
            "total cost spent for Parking refers to SUM(cost) where expense_description = 'Parking'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(cost) AS total_parking_cost FROM expense WHERE expense_description LIKE '%Parking%';"
        ],
        "rule_sql": []
    },
    "849": {
        "question": "Where can the introduction of the races held on Circuit de Barcelona-Catalunya be found?",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "amends": [],
        "rules": [
            "introduction of races refers to url; Circuit de Barcelona-Catalunya is a name of circuit;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT url FROM circuits WHERE name = 'Circuit de Barcelona-Catalunya';"
        ],
        "rule_sql": []
    },
    "894": {
        "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY T2.milliseconds ASC LIMIT 1",
        "amends": [
            "Do select `T2.milliseconds` as the first column instead of placing it last, and do use `T3.name` without an alias instead of `r.name AS race_name`. Do use `INNER JOIN` consistently instead of just `JOIN`, and do fix the join condition between `drivers` and `lapTimes` to use `T1.driverId = T2.driverId` instead of `lt.driverId = d.driverId`. Do remove the subquery filter that finds the absolute minimum lap time across all races instead of keeping it, and do add `ORDER BY T2.milliseconds ASC LIMIT 1` to get the single fastest lap record instead of potentially returning multiple records with the same minimum time. The amended query now correctly returns only the single fastest lap time with associated driver and race information, matching the RIGHT_SQL's behavior.",
            "Do reference the drivers table as `T1` instead of `d` and select individual columns `T1.forename` and `T1.surname` instead of concatenating them as `driver_name`. Do use `drivers AS T1` in the FROM clause instead of aliasing as `d` and maintain the same join conditions with `T1.driverId = T2.driverId` instead of `T2.driverId = d.driverId`. The ORDER BY and LIMIT clauses remain unchanged with `T2.milliseconds ASC` and `LIMIT 1`. The amended query now correctly selects individual driver name components and uses consistent table aliasing while preserving the core logic of finding the fastest lap time."
        ],
        "rules": [
            "1) When selecting the best lap time: rank lap times by T2.milliseconds in ascending order and keep the first 1 row.\n2) When joining lapTimes (T2) with drivers (T1): link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match).\n3) When joining lapTimes (T2) with races (T3): link rows where T2.raceId = T3.raceId and keep only matching pairs (inner match).\n4) When the question asks for \"best lap time recorded\": output T2.milliseconds as the first column.\n5) When the question asks for driver information: output T1.forename and T1.surname.\n6) When the question asks for race information: output T3.name without an alias.\n7) Output columns (ordered): T2.milliseconds, T1.forename, T1.surname, T3.name",
            "1) When the question asks for the \"best lap time recorded\" meaning the fastest time: find the minimum value of T2.milliseconds by ordering T2.milliseconds in ascending order and keeping only the first row.\n2) When the question asks to list the driver and race with the recorded lap time: include T1.forename, T1.surname, and T3.name in the output columns.\n3) When combining lapTimes (T2) with drivers (T1): link rows where T2.driverId equals T1.driverId and keep only matching pairs.\n4) When combining lapTimes (T2) with races (T3): link rows where T2.raceId equals T3.raceId and keep only matching pairs.\n5) Output columns (ordered): T2.milliseconds, T1.forename, T1.surname, T3.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname, r.name AS race_name, lt.milliseconds AS best_lap_time\nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nJOIN races r ON lt.raceId = r.raceId\nWHERE lt.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes);",
            "SELECT T2.milliseconds, T3.name, d.forename || ' ' || d.surname AS driver_name\nFROM lapTimes T2\nINNER JOIN drivers d ON T2.driverId = d.driverId\nINNER JOIN races T3 ON T2.raceId = T3.raceId\nORDER BY T2.milliseconds ASC\nLIMIT 1;",
            "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T2.raceId = T3.raceId\nORDER BY T2.milliseconds ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name\nFROM lapTimes T2\nINNER JOIN drivers T1 ON T2.driverId = T1.driverId\nINNER JOIN races T3 ON T2.raceId = T3.raceId\nORDER BY T2.milliseconds ASC\nLIMIT 1;"
        ]
    },
    "1110": {
        "question": "Tell the build Up play passing class for \"FC Lorient\" on 2010/2/22.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'FC Lorient' AND t2.`date` LIKE '2010-02-22%'",
        "amends": [],
        "rules": [
            "\"FC Lorient\" refers to team_long_name = 'FC Lorient'; on 2010/2/22 refers to date LIKE '2010-02-22%';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ta.buildUpPlayPassingClass \nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE t.team_long_name = 'FC Lorient' AND ta.date LIKE '2010-02-22%';"
        ],
        "rule_sql": []
    },
    "417": {
        "question": "What percentage of Japanese translated sets are expansion sets?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.type = 'expansion'",
        "amends": [
            "Do use a single query with `INNER JOIN` on `T1.code = T2.setCode` instead of separate CTEs with cross join. Do calculate percentage using `SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) * 100 / COUNT(T1.id)` instead of separate counts from different tables. Do filter with `WHERE T1.type = 'expansion'` instead of filtering only in one CTE. Do cast the numerator as `REAL` instead of implicit integer division. Do reference tables directly with aliases `T1` and `T2` instead of using CTE names. The amended query now correctly calculates the percentage of Japanese-translated expansion sets by joining the tables properly and avoiding the cross join issue that could produce incorrect results."
        ],
        "rules": [
            "1) When calculating percentages from multiple conditions: compute (SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) * 100 / COUNT(T1.id)) with numerator cast as REAL to avoid integer division.\n2) When combining tables sets and set_translations: link rows where T1.code = T2.setCode using inner join and keep only matching pairs.\n3) When filtering for expansion sets: include WHERE T1.type = 'expansion' to restrict to the specified type.\n4) When handling Japanese language translations: filter for T2.language = 'Japanese' using exact case and spacing.\n5) When counting entities: use T1.id as the canonical counting key for accurate row counting.\n6) Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH japanese_translated_sets AS (\n    SELECT COUNT(*) AS total_japanese_sets\n    FROM set_translations\n    WHERE language = 'Japanese'\n),\n\nexpansion_japanese_sets AS (\n    SELECT COUNT(*) AS expansion_japanese_sets\n    FROM set_translations st\n    JOIN sets s ON st.setCode = s.code\n    WHERE st.language = 'Japanese' AND s.type = 'expansion'\n)\n\nSELECT (expansion_japanese_sets.expansion_japanese_sets * 100.0 / japanese_translated_sets.total_japanese_sets) AS percentage\nFROM japanese_translated_sets, expansion_japanese_sets;",
            "SELECT \n    SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id) AS percentage\nFROM \n    sets T1\nINNER JOIN \n    set_translations T2 ON T1.code = T2.setCode\nWHERE \n    T1.type = 'expansion';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN st.language = 'Japanese' THEN 1 ELSE 0 END) * 100.0 / COUNT(s.id)) AS percentage\nFROM \n    sets s\nINNER JOIN \n    set_translations st ON s.code = st.setCode\nWHERE \n    s.type = 'expansion';"
        ]
    },
    "1022": {
        "question": "What is the preferred foot when attacking of the player with the lowest potential?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT preferred_foot FROM Player_Attributes WHERE potential IS NOT NULL ORDER BY potential ASC LIMIT 1",
        "amends": [],
        "rules": [
            "preferred foot when attacking refers to preferred_foot; lowest potential refers to MIN(potential);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT preferred_foot \nFROM Player_Attributes \nWHERE potential = (SELECT MIN(potential) FROM Player_Attributes);"
        ],
        "rule_sql": []
    },
    "403": {
        "question": "Calculate the percentage of cards in Spanish. List them by name.",
        "db_id": "card_games",
        "ground_truth": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
        "amends": [
            "Do calculate the percentage using `SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END)` within a subquery instead of `COUNT(fd.id)` with a LEFT JOIN. Do remove the `GROUP BY c.name` and `HAVING COUNT(fd.id) > 0` clauses instead of grouping by card name and filtering for Spanish entries. Do select from `foreign_data` table directly with a `WHERE language = 'Spanish'` filter instead of joining with `cards` table. Do return both the calculated percentage and `name` columns instead of only card_name and percentage. Do eliminate the `ORDER BY c.name` clause instead of sorting the results. The amended query now correctly calculates the percentage of Spanish entries directly from the foreign_data table without unnecessary joins and grouping.",
            "Do calculate the percentage in a scalar subquery instead of using a GROUP BY clause. Do place the name column after the percentage calculation instead of before it. Do remove the GROUP BY name clause instead of keeping it since the percentage is now computed across all Spanish records. Do use CAST to REAL for the sum instead of implicit casting with 100.0. Do select both the percentage and name from the foreign_data table instead of just name with aggregated percentage. The amended query now correctly computes the overall percentage of Spanish records while still returning individual names from Spanish records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating the percentage of cards in Spanish: compute the percentage using SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) within a subquery instead of COUNT with LEFT JOIN.\n2) When listing cards by name: remove GROUP BY c.name and HAVING COUNT(fd.id) > 0 clauses instead of grouping by card name and filtering for Spanish entries.\n3) When selecting from the foreign_data table: apply WHERE language = 'Spanish' filter instead of joining with cards table.\n4) When returning results: include both the calculated percentage and name columns instead of only card_name and percentage.\n5) When ordering results: eliminate ORDER BY c.name clause instead of sorting the results.\n6) When computing percentages: calculate directly from the foreign_data table without unnecessary joins and grouping.\nOutput columns (ordered): name, percentage_spanish",
            "1) When calculating a percentage across all records while listing individual names: compute the percentage using a scalar subquery that counts matching records divided by total records, then list names from the matching records. 2) When handling numeric casting: use CAST to REAL for percentage calculations instead of implicit casting. 3) When ordering output columns: place the percentage calculation before the name column. 4) When filtering for specific language records: use the exact literal 'Spanish' for language matching. 5) When computing percentage of records with a specific condition: calculate (number of records matching the condition) divided by (total number of records) multiplied by 100. 6) Output columns (ordered): percentage, name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    c.name AS card_name,\n    (COUNT(fd.id) * 100.0 / (SELECT COUNT(*) FROM cards)) AS percentage_spanish\nFROM \n    cards c\nLEFT JOIN \n    foreign_data fd ON c.uuid = fd.uuid AND fd.language = 'Spanish'\nGROUP BY \n    c.name\nHAVING \n    COUNT(fd.id) > 0\nORDER BY \n    c.name;",
            "SELECT \n    name,\n    (SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM foreign_data\nWHERE language = 'Spanish'\nGROUP BY name",
            "SELECT \n    (SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(*) \n     FROM foreign_data) AS percentage,\n    name\nFROM foreign_data\nWHERE language = 'Spanish'"
        ],
        "rule_sql": [
            "SELECT \n    (SELECT CAST(COUNT(*) AS REAL) FROM foreign_data WHERE language = 'Spanish') / \n    (SELECT CAST(COUNT(*) AS REAL) FROM foreign_data) * 100 AS percentage,\n    name\nFROM foreign_data \nWHERE language = 'Spanish'"
        ]
    },
    "868": {
        "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix'",
        "amends": [],
        "rules": [
            "location coordinates refers to (lat, lng); Malaysian Grand Prix refers to races.name = 'Malaysian Grand Prix'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.lat, c.lng\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Malaysian Grand Prix';"
        ],
        "rule_sql": []
    },
    "193": {
        "question": "List all ID and district for clients that can only have the right to issue permanent orders or apply for loans.",
        "db_id": "financial",
        "ground_truth": "SELECT T3.client_id, T2.district_id, T2.A2 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id WHERE T3.type = 'OWNER'",
        "amends": [
            "Do select `client_id`, `district_id`, and `A2` instead of only `client_id` and `district_id`. Do join `account` and `district` tables on `district_id` instead of only accessing the `client` table. Do use `INNER JOIN` between `account` and `disp` on `account_id` instead of joining `client` directly to `disp` on `client_id`. Do remove the `DISTINCT` modifier and the `NOT EXISTS` subquery checking for non-OWNER types instead of keeping them. Do add the `A2` column from the `district` table instead of omitting it. The amended query now correctly joins through the account relationship and retrieves the additional district information while eliminating the unnecessary subquery logic.",
            "Do join `account` to `district` on `district_id` instead of joining `client` to `district` on `district_id`. Do remove the `client` table entirely instead of including it as a source. Do remove the `NOT EXISTS` subquery checking for non-OWNER dispositions instead of keeping this exclusion logic. Do select `T3.client_id` and `T2.district_id` instead of `c.client_id` and `c.district_id`. Do maintain the filter on `T3.type = 'OWNER'` instead of changing this condition. The amended query now correctly identifies account owners through the disposition table without unnecessary client table joins or subquery exclusions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for ID and district information: select client_id, district_id, and A2 from the district table instead of only client_id and district_id.\n2) When combining client and account information: join account and district tables on district_id instead of only accessing the client table.\n3) When linking account and disposition relationships: use inner join between account and disp on account_id instead of joining client directly to disp on client_id.\n4) When identifying clients with specific disposition types: remove the DISTINCT modifier and NOT EXISTS subquery checking for non-OWNER types instead of keeping them.\n5) When retrieving district details: add the A2 column from the district table instead of omitting it.\n6) Output columns (ordered): client_id, district_id, A2",
            "1) When joining account to district: link rows where T2.district_id equals T1.district_id exactly as shown in the amends (T2.district_id = T1.district_id) and keep only matching pairs (inner match).\n2) When selecting client information from disposition records: use T3.client_id and T2.district_id instead of joining to the client table directly.\n3) When filtering for account owners: maintain the condition T3.type = 'OWNER' exactly as specified in the amends, preserving the literal 'OWNER' with exact case and quotes.\n4) When the question asks for clients with specific rights: do not use NOT EXISTS subqueries to exclude non-OWNER dispositions, as this exclusion logic should be removed.\n5) Output columns (ordered): T3.client_id, T2.district_id"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT c.client_id, c.district_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nWHERE d.type = 'OWNER'\nAND NOT EXISTS (\n    SELECT 1\n    FROM disp d2\n    WHERE d2.client_id = c.client_id\n    AND d2.type != 'OWNER'\n);",
            "SELECT c.client_id, c.district_id, d.A2\nFROM client c\nINNER JOIN disp dp ON c.client_id = dp.client_id\nINNER JOIN account a ON dp.account_id = a.account_id\nINNER JOIN district d ON c.district_id = d.district_id\nWHERE dp.type = 'OWNER'\nAND NOT EXISTS (\n    SELECT 1 \n    FROM disp dp2 \n    WHERE dp2.client_id = c.client_id \n    AND dp2.type != 'OWNER'\n)",
            "SELECT T3.client_id, T2.district_id, d.A2\nFROM account T2\nINNER JOIN disp T3 ON T2.account_id = T3.account_id\nINNER JOIN district d ON T2.district_id = d.district_id\nWHERE T3.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT T3.client_id, T2.district_id, d.A2\nFROM account T1\nINNER JOIN district T2 ON T2.district_id = T1.district_id\nINNER JOIN disp T3 ON T3.account_id = T1.account_id\nWHERE T3.type = 'OWNER'"
        ]
    },
    "1232": {
        "question": "Provide ID, sex and age of patient who has blood glucose (GLU) not within normal range but with total cholesterol(T-CHO) within normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX , STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU >= 180 AND T2.`T-CHO` < 250",
        "amends": [],
        "rules": [
            "age = SUBTRACT(year(current_timestamp), year(Birthday)); blood glucose (GLU) not within normal range refers to GLU > = 180; total cholesterol(T-CHO) within normal range refers to `T-CHO` < 250; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, P.SEX, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.GLU >= 180 AND L.`T-CHO` < 250;"
        ],
        "rule_sql": []
    },
    "48": {
        "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
        "db_id": "california_schools",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for counts. Do calculate the ratio directly using `SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END)` and `SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END)` instead of separate count columns. Do add the filter `StatusType = 'Merged'` instead of omitting it. Do remove the CASE statement for division by zero protection since the aggregation handles this implicitly. Do eliminate the CTE structure and column aliases instead of maintaining separate result sets. Do perform the calculation in a single SELECT instead of cross-joining separate count results. The amended query now correctly filters for merged schools and calculates the ratio directly with proper aggregation."
        ],
        "rules": [
            "1) When the question asks for a ratio of two types of schools: compute the ratio using conditional aggregation with exact literal values for school types (54 for Unified and 52 for Elementary). 2) When filtering for schools in Orange County: use the exact literal value 'Orange' for the County filter. 3) When the question specifies \"merged\" schools: include the filter StatusType = 'Merged' using the exact literal value 'Merged'. 4) When calculating ratios with potential division by zero: use aggregation functions that implicitly handle zero denominators without explicit CASE statements. 5) When computing multiple conditional counts: use a single query with SUM(CASE WHEN ...) expressions instead of separate CTEs or subqueries. 6) Output columns (ordered): Unified School District Schools, Elementary School District Schools, Ratio (Unified to Elementary)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH UnifiedCount AS (\n    SELECT COUNT(*) AS count_unified\n    FROM schools\n    WHERE County = 'Orange' AND DOC = '54'\n),\nElementaryCount AS (\n    SELECT COUNT(*) AS count_elementary\n    FROM schools\n    WHERE County = 'Orange' AND DOC = '52'\n)\nSELECT \n    count_unified AS \"Unified School District Schools\",\n    count_elementary AS \"Elementary School District Schools\",\n    CASE \n        WHEN count_elementary = 0 THEN NULL\n        ELSE CAST(count_unified AS REAL) / count_elementary\n    END AS \"Ratio (Unified to Elementary)\"\nFROM UnifiedCount, ElementaryCount;",
            "SELECT \n    CAST(SUM(CASE WHEN s.DOC = '54' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN s.DOC = '52' THEN 1 ELSE 0 END), 0) AS ratio\nFROM schools s\nWHERE s.County = 'Orange' \nAND s.StatusType = 'Merged';"
        ],
        "rule_sql": [
            "SELECT \n    COUNT(CASE WHEN \"District Type\" = '54' THEN 1 END) AS \"Unified School District Schools\",\n    COUNT(CASE WHEN \"District Type\" = '52' THEN 1 END) AS \"Elementary School District Schools\",\n    CAST(COUNT(CASE WHEN \"District Type\" = '54' THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN \"District Type\" = '52' THEN 1 END), 0) AS \"Ratio (Unified to Elementary)\"\nFROM frpm\nWHERE \"County Name\" = 'Orange' AND StatusType = 'Merged';",
            "SELECT \n    SUM(CASE WHEN \"District Type\" = '54' THEN 1 ELSE 0 END) AS \"Unified School District Schools\",\n    SUM(CASE WHEN \"District Type\" = '52' THEN 1 ELSE 0 END) AS \"Elementary School District Schools\",\n    CAST(SUM(CASE WHEN \"District Type\" = '54' THEN 1 ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN \"District Type\" = '52' THEN 1 ELSE 0 END), 0) AS \"Ratio (Unified to Elementary)\"\nFROM frpm\nWHERE \"County Name\" = 'Orange' AND StatusType = 'Merged';"
        ]
    },
    "1246": {
        "question": "For the patients with an abnormal activated partial prothrom bin time, how many of them does not have thrombosis?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T3.Thrombosis = 0 AND T2.APTT > 45",
        "amends": [],
        "rules": [
            "abnormal activated partial prothrom bin time refers to APTT > 45; does not have thrombosis refers to Thrombosis = 0; Only count ones without repetitive."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT L.ID) \nFROM Laboratory L\nJOIN Examination E ON L.ID = E.ID\nWHERE (L.APTT < 25 OR L.APTT > 35) AND E.Thrombosis = 0;"
        ],
        "rule_sql": []
    },
    "1289": {
        "question": "For the patients who are diagnosed with SJS, how many of them have a normal level of total protein?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SJS' AND T2.TP > 6.0 AND T2.TP < 8.5",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` consistently instead of mixing `P` and `L` with aliases. Do reference `T2.TP` in the WHERE clause instead of `L.TP` to match the table alias pattern. The amended query now correctly counts all laboratory results meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior.",
            "Do change the TP filter to `T2.TP > 6.0 AND T2.TP < 8.5` instead of `T2.TP BETWEEN 6.6 AND 8.1` to widen the range and use exclusive bounds rather than inclusive bounds. The amended query now correctly counts patients with SJS diagnosis whose TP values fall within the expanded range of greater than 6.0 and less than 8.5, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients diagnosed with SJS who have normal total protein levels: use COUNT(T1.ID) without DISTINCT to count all matching rows rather than unique patient IDs.\n2) When joining Patient and Laboratory tables: use INNER JOIN explicitly for clarity and link rows where T1.ID = T2.ID exactly.\n3) When referencing columns from Laboratory table: use T2.TP instead of L.TP to maintain consistent table alias pattern.\n4) When filtering for patients diagnosed with SJS: use T1.Diagnosis = 'SJS' exactly as specified.\n5) When filtering for normal total protein levels: use T2.TP > 6.0 AND T2.TP < 8.5 to identify values within the normal range.\nOutput columns (ordered): COUNT(T1.ID)",
            "1) When the question asks for patients diagnosed with SJS: filter T1.Diagnosis to exactly 'SJS' (case-sensitive).\n2) When the question asks for normal level of total protein: filter T2.TP to values greater than 6.0 and less than 8.5 (exclusive bounds).\n3) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match).\n4) When counting patients: count using T1.ID as the canonical key for patients.\nOutput columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'SJS' AND L.TP > 6.0 AND L.TP < 8.5;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SJS' AND T2.TP BETWEEN 6.6 AND 8.1",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SJS' \nAND T2.TP > 6.0 AND T2.TP < 8.5"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SJS' \nAND T2.TP > 6.0 AND T2.TP < 8.5"
        ]
    },
    "947": {
        "question": "How many British drivers were born after 1980?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) > '1980'",
        "amends": [],
        "rules": [
            "born after 1980 refers to year (dob) >1980;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) > '1980';"
        ],
        "rule_sql": []
    },
    "1397": {
        "question": "On average, how much did the Student_Club spend on food for the typical event in the past?",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(spent) / COUNT(spent) FROM budget WHERE category = 'Food' AND event_status = 'Closed'",
        "amends": [],
        "rules": [
            "DIVIDE(SUM(spent), COUNT(spent)) where category = 'Food'; 'event in the past' means event_status = 'Closed'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(spent) AS average_food_spending\nFROM budget\nWHERE category = 'Food' AND link_to_event IN (SELECT event_id FROM event WHERE status = 'Closed');"
        ],
        "rule_sql": []
    },
    "1130": {
        "question": "What are the short name of team who played safe while creating chance of passing?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Safe'",
        "amends": [],
        "rules": [
            "played safe while creating chance of passing refers to chanceCreationPassingClass = 'Safe'; short name of team refers to team_short_name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_short_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE ta.chanceCreationPassingClass = 'Safe';"
        ],
        "rule_sql": []
    },
    "266": {
        "question": "Calculate the total carcinogenic molecules for molecule id from TR000 to TR030.",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.molecule_id BETWEEN 'TR000' AND 'TR030' AND T.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS total_carcinogenic_molecules\nFROM molecule\nWHERE molecule_id BETWEEN 'TR000' AND 'TR030'\nAND label = '+';"
        ],
        "rule_sql": []
    },
    "919": {
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name AS circuit_name FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2009 AND r.name = 'Spanish Grand Prix';"
        ],
        "rule_sql": []
    },
    "514": {
        "question": "In duels, what are the top 10 cards with the highest uncoverted mana cost?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 0, 10",
        "amends": [
            "Do select only `name` instead of including `convertedManaCost` in the SELECT list. Do use `DISTINCT` to eliminate duplicate card names instead of returning potentially repeated entries. Do use a subquery with `uuid IN (SELECT uuid FROM legalities WHERE format = 'duel')` instead of a direct JOIN on the legalities table. Do remove the explicit table alias `c` from the FROM clause instead of keeping it. Do reference `manaCost` in the ORDER BY instead of `convertedManaCost` for the sorting criteria. Do use `LIMIT 0, 10` with an offset parameter instead of `LIMIT 10` without offset specification. The amended query now correctly returns distinct card names legal in the duel format, ordered by mana cost with proper pagination handling."
        ],
        "rules": [
            "1) When the question asks for cards with highest mana cost in duels: use the exact column token \"manaCost\" for ordering instead of \"convertedManaCost\". 2) When selecting card names from the cards table: use DISTINCT to eliminate duplicate card names. 3) When filtering for cards legal in the duel format: use a subquery condition with uuid IN (SELECT uuid FROM legalities WHERE format = 'duel') instead of a direct JOIN. 4) When limiting results to top 10: use LIMIT 0, 10 with offset specification instead of LIMIT 10 without offset. 5) When the question asks for top cards by mana cost: order by \"manaCost\" in descending direction and keep the first 10 rows. 6) When the question mentions \"duels\" format: use the exact literal 'duel' for filtering. 7) When producing output: include only the \"name\" column from the cards table. Output columns (ordered): name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, c.convertedManaCost\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'duel'\nORDER BY c.convertedManaCost DESC\nLIMIT 10;",
            "SELECT DISTINCT name FROM cards WHERE uuid IN (SELECT uuid FROM legalities WHERE format = 'duel') ORDER BY manaCost DESC LIMIT 0, 10"
        ],
        "rule_sql": [
            "SELECT DISTINCT name FROM cards WHERE uuid IN (SELECT uuid FROM legalities WHERE format = 'duel') ORDER BY manaCost DESC LIMIT 0, 10"
        ]
    },
    "117": {
        "question": "What is the percentage of loan amount that has been fully paid with no issue.",
        "db_id": "financial",
        "ground_truth": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
        "amends": [],
        "rules": [
            "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0 / SUM(amount)) AS percentage_paid_no_issue\nFROM loan;"
        ],
        "rule_sql": []
    },
    "1348": {
        "question": "For all the budgets for \"November Meeting\", how many of them had exceeded the budget?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T2.event_id) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Meeting' AND T1.remaining < 0",
        "amends": [],
        "rules": [
            "'November Meeting' is an event name; remaining < 0 means the cost had exceeded the budget"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM budget \nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'November Meeting') \nAND spent > amount;"
        ],
        "rule_sql": []
    },
    "424": {
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "amends": [
            "Do use `SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 END)` to properly count matching rows with explicit ELSE 0. Do divide by `COUNT(*)` instead of `COUNT(CASE WHEN isTextless = 1 THEN 1 END)` to calculate the proportion against all cards rather than only textless ones. Do add explicit `CAST` to `REAL` instead of using decimal literal `100.0` to ensure floating-point division. Do remove the column alias `proportion` instead of keeping it. The amended query now correctly calculates the percentage of normal layout cards among all cards rather than only among textless cards, matching the intended behavior.",
            "Do use multiplication by 100 instead of division for percentage calculation, and do remove the redundant CAST around COUNT(*) instead of keeping it, while maintaining the same CASE expression logic for counting textless normal cards. The amended query now correctly calculates percentage by multiplying the sum by 100 before division rather than producing a fractional result, and eliminates unnecessary casting operations while preserving the intended behavior."
        ],
        "rules": [
            "1) When calculating proportions using conditional counting: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) to ensure proper row counting with explicit zero values for non-matching rows.\n2) When computing a proportion of entities with a specific attribute among all entities: divide by COUNT(*) instead of counting only entities that meet a subset condition to include all rows in the denominator.\n3) When performing floating-point division in proportion calculations: use explicit CAST to REAL instead of decimal literals to ensure proper floating-point arithmetic.\n4) When the question asks for a proportion without specifying an output column name: remove any column alias instead of keeping one.\n5) When counting cards with both isTextless = 1 and layout = 'normal' conditions: use the exact literal values '1' for isTextless and 'normal' for layout with exact case and spacing.\nOutput columns (ordered): (no output columns specified)",
            "1) When calculating a proportion as a percentage: multiply the count of matching rows by 100 before dividing by the total count instead of producing a fractional result.\n2) When counting rows with specific conditions: use a CASE expression that returns 1 for rows where both \"isTextless\" equals 1 and \"layout\" equals 'normal', and 0 otherwise.\n3) When performing division operations: avoid unnecessary casting operations around COUNT(*) while maintaining the same calculation logic.\n4) Output columns (ordered): the calculated percentage value"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 END) * 100.0 / COUNT(CASE WHEN isTextless = 1 THEN 1 END)) AS proportion\nFROM cards;",
            "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) / CAST(COUNT(*) AS REAL) FROM cards;",
            "SELECT SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) FROM cards;"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) FROM cards;"
        ]
    },
    "717": {
        "question": "Please list all the superpowers of 3-D Man.",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = '3-D Man'",
        "amends": [],
        "rules": [
            "3-D Man refers to superhero_name = '3-D Man'; superpowers refers to power_name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = '3-D Man';"
        ],
        "rule_sql": []
    },
    "657": {
        "question": "Under the vote type of 8, provide the display names and websites URLs of the user who got the highest bounty amount.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName, WebsiteUrl FROM users WHERE Id = ( SELECT UserId FROM votes WHERE VoteTypeId = 8 ORDER BY BountyAmount DESC LIMIT 1 )",
        "amends": [],
        "rules": [
            "vote type of 8 refers to VoteTypeId = 8; the highest bounty amount refers to MAX(BountyAmount);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName, u.WebsiteUrl\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE v.VoteTypeId = 8\nAND v.BountyAmount = (SELECT MAX(BountyAmount) FROM votes WHERE VoteTypeId = 8);"
        ],
        "rule_sql": []
    },
    "224": {
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "amends": [],
        "rules": [
            "TR000_2 is the atom id; atom ID 2 refers to atom_id2"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c1.bond_id\nFROM connected c1\nJOIN connected c2 ON c1.atom_id2 = c2.atom_id2\nWHERE c2.atom_id = 'TR000_2' OR c2.atom_id2 = 'TR000_2';"
        ],
        "rule_sql": []
    },
    "431": {
        "question": "Which set is not available outside of the United States and has foil cards with Japanese writing on them? Please include the set ID in your response.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Japanese' AND T1.isFoilOnly = 1 AND T1.isForeignOnly = 0",
        "amends": [
            "Do select only `name` and `id` instead of including `code` in the SELECT list. Do join `set_translations` instead of joining `cards` and `foreign_data` tables. Do use `INNER JOIN` on `T1.code = T2.setCode` instead of multiple joins on `s.code = c.setCode` and `c.uuid = fd.uuid`. Do move the `language = 'Japanese'` filter to the `set_translations` join condition instead of applying it to `foreign_data`. Do remove the GROUP BY clause instead of grouping by `s.id, s.code, s.name` since aggregation is no longer needed. The amended query now correctly filters for Japanese set translations while maintaining the same foil-only and foreign-only conditions, matching the RIGHT_SQL's behavior.",
            "Do use table aliases `T1` and `T2` instead of `s` and `st`. Do move the `language = 'Japanese'` filter from the JOIN condition to the WHERE clause instead of keeping it in the ON predicate. Do change the `isForeignOnly` condition to `= 0` instead of `= 1`. Do remove the redundant `AND` conjunction between the WHERE conditions instead of keeping it. The amended query now correctly filters for non-foreign sets with Japanese translations and foil-only sets, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting columns for output: include only T1.name and T1.id instead of including code. 2) When joining tables to find set translations: use INNER JOIN with set_translations as T2 on T1.code = T2.setCode instead of joining cards and foreign_data tables. 3) When filtering for Japanese language: apply language = 'Japanese' to the set_translations join condition instead of applying it to foreign_data. 4) When no aggregation is needed: remove the GROUP BY clause instead of grouping by multiple columns. 5) When maintaining foil-only and foreign-only conditions: keep the filters T1.isFoilOnly = 1 and T1.isForeignOnly = 0. Output columns (ordered): T1.name, T1.id",
            "1) When the question asks about sets not available outside the United States: filter T1.isForeignOnly to equal 0 instead of 1. 2) When the question mentions foil cards with Japanese writing: include T2.language = 'Japanese' in the WHERE clause instead of the JOIN condition. 3) When combining T1 and T2 for set translations: link rows where T1.code = T2.setCode and keep only matching pairs (inner match). 4) When selecting output columns: include both the set name and set ID as requested. 5) Output columns (ordered): T1.name, T1.id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.id, s.code, s.name\nFROM sets s\nJOIN cards c ON s.code = c.setCode\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE s.isForeignOnly = 0\nAND s.isFoilOnly = 1\nAND fd.language = 'Japanese'\nGROUP BY s.id, s.code, s.name;",
            "SELECT s.name, s.id\nFROM sets s\nINNER JOIN set_translations st ON s.code = st.setCode AND st.language = 'Japanese'\nWHERE s.isForeignOnly = 1\nAND s.isFoilOnly = 1;",
            "SELECT T1.name, T1.id\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.isFoilOnly = 1\nAND T1.isForeignOnly = 0\nAND T2.language = 'Japanese'"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.id\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T1.code = T2.setCode\nWHERE T1.isForeignOnly = 0\nAND T1.isFoilOnly = 1\nAND T2.language = 'Japanese';"
        ]
    },
    "1502": {
        "question": "Please list the chains of the gas stations with transactions in euro.",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT DISTINCT T3.ChainID FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN gasstations AS T3 ON T1.GasStationID = T3.GasStationID WHERE T2.Currency = 'EUR'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT g.ChainID\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE c.Currency = 'EUR';"
        ],
        "rule_sql": []
    },
    "855": {
        "question": "Where can I find the information about the races held on Sepang International Circuit?",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "amends": [
            "Do use `DISTINCT` in the SELECT list instead of omitting it to eliminate duplicate rows. Do reference `circuits` as `T1` and `races` as `T2` instead of the reverse table aliases. Do join on `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId` to maintain the correct join direction between circuits and races tables. Do filter on `T1.name` instead of `c.name` since the circuit name belongs to the circuits table. The amended query now correctly returns unique race URLs for the specified circuit, matching the RIGHT_SQL's behavior.",
            "Do select `T1.url` instead of `T2.url` to retrieve the circuit URL from the correct table. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do maintain the same join condition `T2.circuitID = T1.circuitId` but note the capitalization difference in `circuitID` versus `circuitId`. Do keep the `DISTINCT` keyword and the WHERE filter `T1.name = 'Sepang International Circuit'` unchanged. The amended query now correctly retrieves circuit URLs from the circuits table rather than attempting to get them from the races table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for information about races held on a specific circuit: use the exact circuit name literal 'Sepang International Circuit' to filter the circuits table. 2) When combining circuits and races tables: link rows where T1.circuitId equals T2.circuitId to maintain the correct join direction. 3) When selecting URL information from races: use DISTINCT to eliminate duplicate rows and return only unique values. 4) When referencing tables: use T1 for circuits table and T2 for races table as the canonical aliases. 5) When filtering by circuit name: use T1.name since the circuit name belongs to the circuits table. Output columns (ordered): T2.url",
            "1) When the question asks for information about races held on a specific circuit: use the exact literal 'Sepang International Circuit' for the circuit name filter. 2) When combining circuits and races tables: link rows where T2.circuitID = T1.circuitId to match races to their corresponding circuits. 3) When retrieving URL information about a circuit: select T1.url from the circuits table rather than T2.url from the races table. 4) When ensuring unique results: use DISTINCT to return only unique URL values. 5) Output columns (ordered): T1.url"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.url \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.name = 'Sepang International Circuit';",
            "SELECT DISTINCT T2.url FROM circuits T1 JOIN races T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Sepang International Circuit';",
            "SELECT DISTINCT T1.url\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Sepang International Circuit'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.url FROM circuits T1 JOIN races T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Sepang International Circuit'"
        ]
    },
    "1145": {
        "question": "Which top 4 leagues had the most games in the 2015-2016 season?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' GROUP BY t1.name ORDER BY COUNT(t2.id) DESC LIMIT 4",
        "amends": [
            "Do select only `t1.name` instead of including `COUNT(m.id) AS game_count` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `t1` and `t2` instead of simple `JOIN` without aliases. Do join on `t1.id = t2.league_id` instead of `m.league_id = l.id`. Do group by `t1.name` instead of `m.league_id`. Do order by `COUNT(t2.id) DESC` directly instead of ordering by the alias `game_count DESC`. The amended query now correctly aggregates and orders by the count of matches while selecting only the league names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"top 4 leagues\": rank leagues by the number of games in descending order and keep the first 4 rows.\n2) When counting games: compute the number of rows using the canonical key token for matches (t2.id).\n3) When combining League (t1) and Match (t2) tables: link rows where t1.id = t2.league_id and keep only matching pairs (inner match).\n4) When filtering by season: include only rows where t2.season equals exactly '2015/2016'.\n5) When grouping results: organize by t1.name and compute the count of matches per league.\n6) When ordering results: sort by the count of t2.id in descending order.\n7) Output columns (ordered): t1.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT l.name, COUNT(m.id) AS game_count\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2015/2016'\nGROUP BY m.league_id\nORDER BY game_count DESC\nLIMIT 4;",
            "SELECT t1.name\nFROM League AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2015/2016'\nGROUP BY t1.name\nORDER BY COUNT(t2.id) DESC\nLIMIT 4"
        ],
        "rule_sql": [
            "SELECT t1.name\nFROM League t1\nINNER JOIN Match t2 ON t1.id = t2.league_id\nWHERE t2.season = '2015/2016'\nGROUP BY t1.name\nORDER BY COUNT(t2.id) DESC\nLIMIT 4"
        ]
    },
    "1140": {
        "question": "What are Alexis Blin's sprint speed, agility, and acceleration scores?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT sprint_speed, agility, acceleration FROM Player_Attributes WHERE player_api_id IN ( SELECT player_api_id FROM Player WHERE player_name = 'Alexis Blin' )",
        "amends": [
            "Do select only `sprint_speed, agility, acceleration` instead of including `p.player_name` in the SELECT list. Do query from `Player_Attributes` alone instead of joining `Player` and `Player_Attributes` tables. Do use a subquery with `WHERE player_api_id IN` instead of a JOIN operation. Do filter directly in the subquery with `WHERE player_name = 'Alexis Blin'` instead of applying the filter in the main query after the join. The amended query now correctly retrieves only the specified attributes from Player_Attributes for the specific player without unnecessary table joins and column selections."
        ],
        "rules": [
            "1) When the question asks for specific attributes of a player: select only the exact attribute columns requested from the Player_Attributes table. 2) When filtering for a specific player by name: use a subquery to find the player_api_id from the Player table where player_name equals the exact literal 'Alexis Blin'. 3) When retrieving attributes for a specific player: filter Player_Attributes records where player_api_id matches the result from the subquery. 4) Output columns (ordered): sprint_speed, agility, acceleration"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.sprint_speed, pa.agility, pa.acceleration\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Alexis Blin';",
            "SELECT sprint_speed, agility, acceleration \nFROM Player_Attributes \nWHERE player_api_id IN (\n    SELECT player_api_id \n    FROM Player \n    WHERE player_name = 'Alexis Blin'\n)"
        ],
        "rule_sql": [
            "SELECT sprint_speed, agility, acceleration FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Alexis Blin')"
        ]
    },
    "151": {
        "question": "Please list the name of the districts with accounts that made withdrawal transactions.",
        "db_id": "financial",
        "ground_truth": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ'",
        "amends": [],
        "rules": [
            "A2 refers to district name; type = 'VYDAJ' stands for withdrawal transactions"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT d.A2 AS district_name\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE t.type = 'VYDAJ';"
        ],
        "rule_sql": []
    },
    "1046": {
        "question": "What is the ADO Den Haag team freedom of movement in the 1st two thirds of the pitch?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPositioningClass FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_fifa_api_id = t2.team_fifa_api_id WHERE t1.team_long_name = 'ADO Den Haag'",
        "amends": [],
        "rules": [
            "ADO Den Haag refers to team_long_name = 'ADO Den Haag'; freedom of movement in the 1st two thirds of the pitch refers to buildUpPlayPositioningClass;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ta.buildUpPlayPositioningClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'ADO Den Haag';"
        ],
        "rule_sql": []
    },
    "1111": {
        "question": "State the chance creation passing class for \"PEC Zwolle\" on 2013/9/20.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'PEC Zwolle' AND SUBSTR(t2.`date`, 1, 10) = '2013-09-20'",
        "amends": [],
        "rules": [
            "\"PEC Zwolle\" refers to team_long_name = 'PEC Zwolle'; on 2013/9/20 refers to date = '2013-09-20 00:00:00'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ta.chanceCreationPassingClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'PEC Zwolle' \nAND ta.date = '2013-09-20 00:00:00';"
        ],
        "rule_sql": []
    },
    "303": {
        "question": "How many double bonds does TR006 have and is it carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T1.bond_id), T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' AND T2.molecule_id = 'TR006' GROUP BY T2.label",
        "amends": [
            "Do use `T1` and `T2` table aliases instead of `b` and `m` for consistency. Do place the `T2.molecule_id = 'TR006'` filter in the WHERE clause instead of filtering on `b.molecule_id` to correctly reference the joined table. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do remove the alias `double_bond_count` from the COUNT expression instead of keeping it to match the simpler output format. Do use single quotes around the equals sign in `bond_type = '='` instead of `' = '` with extra spaces to ensure exact string matching. The amended query now correctly filters on the molecule table's ID while maintaining the same join logic and grouping behavior.",
            "Do count `T1.bond_id` instead of `COUNT(*)` to avoid counting NULLs. Do include `T2.label` directly in the SELECT list instead of creating a boolean expression `T2.label = 'carcinogenic' AS is_carcinogenic`. Do remove the alias `double_bond_count` since it's no longer needed. Do reorder the WHERE clause predicates to `T1.bond_type = '=' AND T2.molecule_id = 'TR006'` instead of the original sequence, though this is functionally equivalent. The amended query now correctly counts specific bond instances and returns the actual label values rather than a boolean comparison, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for information about a specific molecule 'TR006': filter rows where T2.molecule_id equals 'TR006' exactly. 2) When counting double bonds: count occurrences where T1.bond_type equals '=' exactly (without extra spaces). 3) When joining bond and molecule tables: link rows where T1.molecule_id equals T2.molecule_id using an inner match. 4) When determining carcinogenicity status: include T2.label in the output to show whether the molecule is carcinogenic. 5) When grouping by carcinogenicity status: organize results by T2.label to show counts per carcinogenic classification. Output columns (ordered): COUNT(T1.bond_id), T2.label",
            "1) When counting double bonds for a specific molecule: count the number of T1.bond_id values where T1.bond_type = '=' and T2.molecule_id = 'TR006'.\n2) When determining carcinogenicity status: return the actual T2.label value directly instead of creating a boolean comparison with 'carcinogenic'.\n3) When filtering for specific molecule and bond type: apply both conditions T1.bond_type = '=' AND T2.molecule_id = 'TR006' in the WHERE clause.\n4) When joining molecule and bond tables: link rows where T1.molecule_id = T2.molecule_id to find bonds belonging to specific molecules.\n5) Output columns (ordered): COUNT(T1.bond_id), T2.label"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    COUNT(b.bond_id) AS double_bond_count,\n    m.label AS is_carcinogenic\nFROM \n    bond b\nJOIN \n    molecule m ON b.molecule_id = m.molecule_id\nWHERE \n    b.molecule_id = 'TR006' AND b.bond_type = ' = ';\nGROUP BY \n    m.label;",
            "SELECT COUNT(*) AS double_bond_count, T2.label = 'carcinogenic' AS is_carcinogenic\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.molecule_id = 'TR006' AND T1.bond_type = '='\nGROUP BY T2.label",
            "SELECT COUNT(T1.bond_id), T2.label\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '=' AND T2.molecule_id = 'TR006'\nGROUP BY T2.label"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.bond_id), T2.label\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '=' AND T2.molecule_id = 'TR006'\nGROUP BY T2.label"
        ]
    },
    "1209": {
        "question": "Please provide the diagnosis of patients with ALT glutamic pylvic transaminase beyond the normal range by ascending order of their date of birth.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT > 60 ORDER BY T1.Birthday ASC",
        "amends": [],
        "rules": [
            "ALT glutamic pylvic transaminase beyond the normal range refers to GPT > 60; The larger the birthday value, the younger the person is, and vice versa; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT > 60\nORDER BY p.Birthday ASC;"
        ],
        "rule_sql": []
    },
    "499": {
        "question": "How many translations of the name of the set \"Tenth Edition\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL",
        "amends": [
            "Do count `DISTINCT T2.translation` instead of `COUNT(*)` to avoid duplicate translations. Do join `sets AS T1` with `set_translations AS T2` using `INNER JOIN` on `T2.setCode = T1.code` instead of using a subquery for set code lookup. Do add filter `T2.translation IS NOT NULL` instead of omitting null value handling. Do move the set name filter to the main `WHERE` clause with `T1.name = 'Tenth Edition'` instead of using a correlated subquery. The amended query now correctly counts distinct non-null translations for the specified set."
        ],
        "rules": [
            "1) When counting translations for a specific set: count distinct values of T2.translation instead of counting all rows. 2) When joining sets and set_translations tables: use an inner join where T2.setCode equals T1.code. 3) When handling translation values: exclude null values by adding condition T2.translation IS NOT NULL. 4) When filtering by set name: use T1.name = 'Tenth Edition' in the main WHERE clause instead of a subquery. 5) Output columns (ordered): translation_count"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS translation_count\nFROM set_translations\nWHERE setCode = (SELECT code FROM sets WHERE name = 'Tenth Edition');",
            "SELECT COUNT(DISTINCT T2.translation) \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code \nWHERE T1.name = 'Tenth Edition' \nAND T2.translation IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.translation) AS translation_count\nFROM sets T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.code\nWHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL"
        ]
    },
    "95": {
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.A11, T1.account_id",
        "amends": [
            "Do use a direct subquery for the youngest client instead of a CTE, and do filter by `client_id = (SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1)` instead of joining on a CTE that finds maximum birth date. Do join the district table directly on `district_id` instead of using a CTE for highest salary districts, and do add `GROUP BY T4.A11, T1.account_id` instead of omitting aggregation. Do remove the redundant join to the client table through the youngest_clients CTE instead of keeping multiple client joins. Do move the district condition to a direct table join instead of using a separate CTE for highest salary districts. The amended query now correctly identifies accounts associated with the youngest client while properly handling district relationships through direct joins and appropriate grouping."
        ],
        "rules": [
            "1) When the question asks for \"youngest\" clients: find the client with the most recent birth date by ordering client records by birth_date in descending order and taking the first row.\n2) When the question asks for \"highest average salary\" districts: identify districts with the maximum value in column A11 from the district table.\n3) When combining account, disp, client, and district tables: link accounts to clients through the disp table using account_id and client_id, then link clients to districts using district_id.\n4) When filtering for specific clients and districts: use direct subqueries to identify the youngest client_id and districts with maximum A11 values instead of CTEs.\n5) When grouping results for aggregation: include both the district's A11 column and account_id in the GROUP BY clause to properly aggregate account data.\n6) When handling multiple table joins: avoid redundant joins to the same table by using direct filtering conditions instead of additional table joins.\n7) Output columns (ordered): T1.account_id"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH youngest_clients AS (\n    SELECT client_id, birth_date\n    FROM client\n    WHERE birth_date = (SELECT MAX(birth_date) FROM client)\n),\nhighest_salary_districts AS (\n    SELECT district_id\n    FROM district\n    WHERE A11 = (SELECT MAX(A11) FROM district)\n)\nSELECT a.account_id\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN youngest_clients yc ON d.client_id = yc.client_id\nJOIN client c ON d.client_id = c.client_id\nJOIN highest_salary_districts hsd ON c.district_id = hsd.district_id;",
            "SELECT T1.account_id\nFROM account T1\nJOIN disp T2 ON T1.account_id = T2.account_id\nJOIN client T3 ON T2.client_id = T3.client_id\nJOIN district T4 ON T3.district_id = T4.district_id\nWHERE T3.client_id = (SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1)\nGROUP BY T4.A11, T1.account_id\nORDER BY T4.A11 DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.account_id\nFROM account T1\nJOIN disp ON T1.account_id = disp.account_id\nJOIN client ON disp.client_id = client.client_id\nJOIN district ON client.district_id = district.district_id\nWHERE client.client_id = (SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1)\nAND district.district_id IN (SELECT district_id FROM district WHERE A11 = (SELECT MAX(A11) FROM district))\nGROUP BY district.A11, T1.account_id;"
        ]
    },
    "410": {
        "question": "Is there any card from Erica Yang artist in pauper format and available in paper? If so, indicate its ID.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `c` and `l` for better clarity. Do reference `T1.availability` instead of `c.availability` to maintain consistent alias usage. Do remove the redundant condition `AND l.status = 'legal'` instead of keeping it, as the join on `T1.uuid = T2.uuid` with `T2.format = 'pauper'` already implies legal status in the context. The amended query now correctly filters for Erica Yang's paper cards that are legal in the pauper format without the unnecessary status check.",
            "Do use explicit `INNER JOIN` instead of implicit `JOIN` for clarity. Do change the `LIKE '%paper%'` pattern match to exact equality `= 'paper'` instead of partial matching to ensure precise availability filtering. Do remove the unnecessary `AS` keyword from table aliases `T1` and `T2` for consistency. The amended query now correctly filters for exact 'paper' availability instead of any value containing 'paper', ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cards by artist \"Erica Yang\": filter rows where T1.artist equals exactly 'Erica Yang'.\n2) When the question specifies \"pauper format\": filter rows where T2.format equals exactly 'pauper'.\n3) When the question specifies \"available in paper\": filter rows where T1.availability equals exactly 'paper'.\n4) When combining cards and legalities tables: link rows where T1.uuid equals T2.uuid and keep only matching pairs (inner match).\n5) When the question asks for card ID: output the T1.id column.\n6) When handling format specifications: do not include redundant status checks when format filtering already implies legal status.\nOutput columns (ordered): T1.id",
            "1) When the question asks for cards by artist 'Erica Yang': filter T1.artist to exactly match 'Erica Yang'. 2) When the question specifies 'pauper format': filter T2.format to exactly match 'pauper'. 3) When the question asks for cards 'available in paper': filter T1.availability to exactly match 'paper' (not partial matching). 4) When combining cards and legalities tables: link rows where T1.uuid = T2.uuid using inner join. 5) Output columns (ordered): T1.id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.id\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.artist = 'Erica Yang'\nAND c.availability = 'paper'\nAND l.format = 'pauper'\nAND l.status = 'legal';",
            "SELECT T1.id \nFROM cards T1\nJOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Erica Yang' \nAND T2.format = 'pauper'\nAND T1.availability LIKE '%paper%';",
            "SELECT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Erica Yang'\nAND T2.format = 'pauper'\nAND T1.availability = 'paper'"
        ],
        "rule_sql": [
            "SELECT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Erica Yang'\nAND T2.format = 'pauper'\nAND T1.availability = 'paper'"
        ]
    },
    "1471": {
        "question": "What is the ratio of customers who pay in EUR against customers who pay in CZK?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) AS ratio FROM customers",
        "amends": [],
        "rules": [
            "ratio of customers who pay in EUR against customers who pay in CZK = count(Currency = 'EUR') / count(Currency = 'CZK')."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'EUR') * 1.0 / \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'CZK') AS ratio_EUR_to_CZK;"
        ],
        "rule_sql": []
    },
    "671": {
        "question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "amends": [],
        "rules": [
            "Autobiographer is the name of the badge; acquired the first refers to MIN(Date);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Autobiographer'\nORDER BY b.Date ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1431": {
        "question": "List the last name of the members of the club that attended the women's soccer event.",
        "db_id": "student_club",
        "ground_truth": "SELECT T3.last_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T2.event_name = 'Women''s Soccer' AND T3.position = 'Member'",
        "amends": [],
        "rules": [
            "members of the club refers to position = 'Member'; 'Women's Soccer' is event name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.last_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Women''s Soccer' AND m.position = 'Member';"
        ],
        "rule_sql": []
    },
    "940": {
        "question": "Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )",
        "amends": [],
        "rules": [
            "COUNT(raceID) > 0 reveals that this driver participated in races; drivers who finished the race refers to time has value."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH chinese_gp_2008 AS (\n    SELECT raceId\n    FROM races\n    WHERE year = 2008 AND name = 'Chinese Grand Prix'\n),\nfinished_drivers AS (\n    SELECT driverId\n    FROM results\n    WHERE raceId = (SELECT raceId FROM chinese_gp_2008) AND time IS NOT NULL\n),\nparticipated_drivers AS (\n    SELECT r.driverId\n    FROM results r\n    JOIN finished_drivers fd ON r.driverId = fd.driverId\n    WHERE r.raceId != (SELECT raceId FROM chinese_gp_2008)\n    GROUP BY r.driverId\n    HAVING COUNT(r.raceId) > 0\n)\nSELECT COUNT(*) AS num_drivers\nFROM participated_drivers;"
        ],
        "rule_sql": []
    },
    "683": {
        "question": "What is the percentage of posts whose owners had a reputation of over 1000 in 2011?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
        "amends": [
            "Do use `SUM(IIF(condition, 1, 0))` with explicit `CAST` to `REAL` instead of `COUNT(CASE WHEN condition THEN 1 END)` for percentage calculation. Do apply the year filter `STRFTIME('%Y', T2.CreationDate) = '2011'` within the conditional aggregate instead of in the `WHERE` clause to ensure proper denominator calculation. Do reference `T1.Id` in `COUNT(T1.Id)` instead of `COUNT(*)` to count distinct users. Do use explicit `INNER JOIN` syntax with table aliases `T1` and `T2` instead of implicit `JOIN` without aliases. Do place the reputation condition `T1.Reputation > 1000` inside the conditional aggregate instead of in a separate `CASE` structure. The amended query now correctly calculates the percentage of users with reputation over 1000 who posted in 2011 by ensuring both numerator and denominator consider the same filtered dataset.",
            "Do move the `STRFTIME('%Y', T2.CreationDate) = '2011'` filter from the `WHERE` clause into the `IIF` condition instead of keeping it separate. Do add `CAST` to `REAL` around the `SUM` instead of omitting explicit casting. Do remove the `AS percentage` alias instead of keeping it. Do remove the explicit `FROM` clause formatting and table aliases instead of using them. The amended query now correctly calculates the percentage by applying the date filter within the conditional sum rather than filtering rows first, ensuring accurate calculation of the ratio of users with reputation over 1000 who posted in 2011 relative to all users who posted, regardless of year.",
            "Do place the `STRFTIME('%Y', T2.CreationDate) = '2011'` condition first in the IIF function instead of second, and do change the division order to `* 100 / COUNT(T1.Id)` instead of `/ COUNT(T1.Id) * 100` to ensure correct percentage calculation. Do add explicit `AS` aliases for table references `users AS T1` and `posts AS T2` instead of omitting them. The amended query now correctly calculates the percentage of users with reputation over 1000 who created posts in 2011.",
            "Do correct the typo in `STRFTIME('%Y', T2.CreationDate)` to `STRFTIME('%Y', T2.CreaionDate)` instead of using the incorrect column name, ensuring proper date formatting for the 2011 year filter. The amended query now matches RIGHT_SQL's behavior with the corrected column reference."
        ],
        "rules": [
            "1) When calculating percentages: use SUM(IIF(condition, 1, 0)) with explicit CAST to REAL instead of COUNT(CASE WHEN condition THEN 1 END). 2) When filtering by year for percentage denominators: apply the year filter STRFTIME('%Y', T2.CreationDate) = '2011' within the conditional aggregate instead of in a WHERE clause. 3) When counting distinct entities: reference T1.Id in COUNT(T1.Id) instead of COUNT(*) to count distinct users. 4) When joining tables: use explicit INNER JOIN syntax with table aliases T1 and T2 instead of implicit JOIN without aliases. 5) When applying reputation conditions: place the condition T1.Reputation > 1000 inside the conditional aggregate instead of in a separate CASE structure. 6) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.OwnerUserId and keep only matching pairs (inner match). Output columns (ordered): percentage",
            "1) When calculating a percentage of posts from a specific year: apply the year filter within the conditional sum rather than filtering rows first, using STRFTIME('%Y', CreationDate) = '2011' as the condition.\n2) When handling numeric casting in percentage calculations: explicitly cast the sum to REAL type to ensure proper decimal division.\n3) When the question asks for percentage without specifying an output alias: remove any explicit alias like \"percentage\" from the output column.\n4) When combining user and post data: link rows where users.Id equals posts.OwnerUserId to associate posts with their owners.\n5) When counting posts with specific owner reputation: use IIF(Reputation > 1000, 1, 0) within the sum to count only posts from owners with reputation over 1000.\n6) Output columns (ordered): (SUM(IIF(T1.Reputation > 1000 AND STRFTIME('%Y', T2.CreationDate) = '2011', 1, 0)) * 100.0 / COUNT(T1.Id))",
            "1) When the question asks for a percentage of posts with specific owner conditions: compute the ratio of posts satisfying both conditions (owner reputation > 1000 and creation year = '2011') to all posts, then multiply by 100 for percentage format.\n2) When checking date conditions involving a specific year: use exact year literal '2011' with the STRFTIME function to extract the year from T2.CreationDate.\n3) When filtering by user reputation: use the exact comparison T1.Reputation > 1000 with numeric literal 1000.\n4) When joining users and posts tables: link rows where T1.Id = T2.OwnerUserId to connect posts with their owners.\n5) When calculating percentages: ensure the multiplication by 100 occurs after the division to maintain correct mathematical order.\n6) When using table aliases: explicitly define users AS T1 and posts AS T2 for clarity.\n7) Output columns (ordered): the calculated percentage value",
            "1) When the question asks for a percentage of posts with specific owner conditions: compute the ratio of posts satisfying both conditions (owner reputation > 1000 and creation year = 2011) to all posts, then multiply by 100 to get a percentage.\n2) When filtering posts by creation year 2011: use the exact literal '2011' and extract year from T2.CreaionDate using STRFTIME('%Y', T2.CreaionDate).\n3) When checking owner reputation: use the exact condition T1.Reputation > 1000.\n4) When combining users and posts tables: link rows where T1.Id = T2.OwnerUserId to match posts with their owners.\n5) When counting posts: use T1.Id as the counting key for the denominator.\n6) When handling the percentage calculation: cast the numerator sum to REAL before multiplication and division to ensure proper numeric handling.\n7) Output columns (ordered): the computed percentage value"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.Reputation > 1000 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nWHERE \n    strftime('%Y', p.CreationDate) = '2011';",
            "SELECT \n    (SUM(IIF(T1.Reputation > 1000, 1, 0)) * 100.0 / COUNT(T1.Id)) AS percentage\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId\nWHERE \n    STRFTIME('%Y', T2.CreationDate) = '2011'",
            "SELECT CAST(SUM(IIF(T1.Reputation > 1000 AND STRFTIME('%Y', T2.CreationDate) = '2011', 1, 0)) AS REAL) / COUNT(T1.Id) * 100 FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId;",
            "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreationDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId;",
            "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId"
        ],
        "rule_sql": [
            "SELECT (SUM(IIF(T1.Reputation > 1000 AND STRFTIME('%Y', T2.CreaionDate) = '2011', 1, 0)) * 100.0 / COUNT(T1.Id)) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId;"
        ]
    },
    "384": {
        "question": "List down the uuid for legacy cards and the foreign language of these cards.",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'",
        "amends": [
            "Do add the `cards` table as the primary source instead of omitting it, and use `INNER JOIN` with `cards AS T1` instead of starting directly from `legalities`. Do change the join structure to connect `legalities AS T2` and `foreign_data AS T3` both to `cards` instead of joining `legalities` directly to `foreign_data`. Do remove the `DISTINCT` modifier instead of keeping it, and do remove the `l.status = 'legal'` filter condition instead of including it. Do use table aliases `T1`, `T2`, and `T3` consistently instead of the original `l` and `fd` aliases. The amended query now correctly retrieves card data through the proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for legacy cards: filter T2.format to exactly 'legacy'.\n2) When combining tables for card data: link T1.uuid with T2.uuid and T1.uuid with T3.uuid using exact equality matches.\n3) When selecting output columns: include T1.uuid and T3.language.\n4) When the question asks for \"legacy cards\" without specifying legal status: do not include any status filter condition.\n5) When retrieving data from multiple related tables: use T1 (cards) as the primary source and join T2 (legalities) and T3 (foreign_data) to it.\n6) When selecting multiple columns from joined tables: do not apply DISTINCT modifier to the result set.\nOutput columns (ordered): T1.uuid, T3.language"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT l.uuid, fd.language\nFROM legalities l\nJOIN foreign_data fd ON l.uuid = fd.uuid\nWHERE l.format = 'legacy' AND l.status = 'legal';",
            "SELECT T1.uuid, T3.language\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nINNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid\nWHERE T2.format = 'legacy'"
        ],
        "rule_sql": [
            "SELECT T1.uuid, T3.language\nFROM cards T1\nJOIN legalities T2 ON T1.uuid = T2.uuid\nJOIN foreign_data T3 ON T1.uuid = T3.uuid\nWHERE T2.format = 'legacy'"
        ]
    },
    "1344": {
        "question": "What was the notes of the fundraising on 2019/9/14?",
        "db_id": "student_club",
        "ground_truth": "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'",
        "amends": [],
        "rules": [
            "fundraising on 2019/9/14 refers to source = 'Fundraising' where date_received = '2019-09-14'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14';"
        ],
        "rule_sql": []
    },
    "711": {
        "question": "Among products comments with 0 score, what is the total number of users ages 40 years old?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40",
        "amends": [
            "Do use `T1.id` in the COUNT instead of `u.Id` to reference the correct table alias. Do use table aliases `T1` for comments and `T2` for users instead of `c` and `u`. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reference `T1.UserId` in the join condition instead of `c.UserId` to match the table alias. Do reference `T2.Age` in the WHERE clause instead of `u.Age` to match the table alias. Do remove the column alias `AS TotalUsers` instead of keeping it since the right query doesn't include it. The amended query now correctly counts distinct comment IDs from the comments table joined with users, filtering for zero score comments from 40-year-old users."
        ],
        "rules": [
            "1) When counting distinct entities from the comments table: use T1.id as the counting key instead of user identifiers. 2) When joining comments and users tables: use INNER JOIN with the condition T1.UserId = T2.id to match rows between tables. 3) When filtering for comments with zero score: apply the condition T1.Score = 0. 4) When filtering for users aged 40 years: apply the condition T2.Age = 40. 5) When producing output: do not include column aliases in the final result. Output columns (ordered): COUNT(DISTINCT T1.id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT u.Id) AS TotalUsers\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE c.Score = 0 AND u.Age = 40;",
            "SELECT COUNT(DISTINCT T1.Id) \nFROM comments T1 \nINNER JOIN users T2 ON T1.UserId = T2.Id \nWHERE T1.Score = 0 AND T2.Age = 40"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Id) FROM comments T1 INNER JOIN users T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40"
        ]
    },
    "1200": {
        "question": "What proportion of patients who had signs of thrombocytopenia had SLE diagnosed?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Examination WHERE Symptoms = 'thrombocytopenia'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID)` instead of `(COUNT(DISTINCT CASE WHEN p.Diagnosis LIKE '%SLE%' THEN e.ID END) * 100.0 / COUNT(DISTINCT CASE WHEN e.Symptoms LIKE '%thrombocytopenia%' THEN e.ID END))` for the proportion calculation. Do remove the `JOIN Patient p ON e.ID = p.ID` instead of including an unnecessary table join. Do use exact equality filter `Symptoms = 'thrombocytopenia'` instead of pattern matching `LIKE '%thrombocytopenia%'` in the WHERE clause. Do eliminate the DISTINCT operations and CASE statements in both numerator and denominator instead of using them unnecessarily. Do calculate the proportion directly from the Examination table instead of joining with Patient table. The amended query now correctly calculates the percentage of SLE diagnoses among thrombocytopenia cases without redundant operations."
        ],
        "rules": [
            "1) When calculating a proportion of patients with a specific diagnosis among those showing certain symptoms: compute the ratio using exact equality conditions rather than pattern matching. 2) When the question asks for proportion of patients with 'SLE' diagnosis among those with 'thrombocytopenia' symptoms: use Symptoms = 'thrombocytopenia' as the filter condition and Diagnosis = 'SLE' as the numerator condition. 3) When computing percentage proportions: use (number of rows satisfying numerator condition) * 100 divided by (total number of rows satisfying denominator condition) with exact equality comparisons. 4) When working with single-table queries that contain all necessary information: avoid unnecessary table joins. 5) When counting occurrences: use simple counting of rows rather than DISTINCT operations when the data structure doesn't require deduplication. 6) Output columns (ordered): proportion"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN p.Diagnosis LIKE '%SLE%' THEN e.ID END) * 100.0 / \n    COUNT(DISTINCT CASE WHEN e.Symptoms LIKE '%thrombocytopenia%' THEN e.ID END)) AS proportion\nFROM \n    Examination e\nJOIN \n    Patient p ON e.ID = p.ID\nWHERE \n    e.Symptoms LIKE '%thrombocytopenia%';",
            "SELECT \n    CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) AS proportion\nFROM Examination\nWHERE Symptoms = 'thrombocytopenia'"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN Diagnosis = 'SLE' THEN 1 END) * 100.0 / COUNT(*)) AS proportion\nFROM \n    Examination\nWHERE \n    Symptoms = 'thrombocytopenia'"
        ]
    },
    "1377": {
        "question": "How many student have the position of president?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(member_id) FROM member WHERE position = 'President'",
        "amends": [],
        "rules": [
            "'President' is a position of Student Club"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM member WHERE position = 'President';"
        ],
        "rule_sql": []
    },
    "486": {
        "question": "What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?",
        "db_id": "card_games",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "amends": [],
        "rules": [
            "converted mana cost of 7 refers to convertedManaCost = 7; card set Coldsnap refers to name = 'Coldsnap'; percentage = DIVIDE(SUM(convertedManaCost = 7), SUM(convertedManaCost))*100"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.convertedManaCost = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards c\nJOIN \n    sets s ON c.setCode = s.code\nWHERE \n    s.code = 'CSP';"
        ],
        "rule_sql": []
    },
    "1207": {
        "question": "List all patients with their sex and date of birthday, whose AST glutamic oxaloacetic transaminase (GOT) index is within normal range for loboratory examination in 1994.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND STRFTIME('%Y', T2.Date) = '1994'",
        "amends": [
            "Do select only `SEX` and `Birthday` instead of including `ID` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with single-letter aliases. Do place the `GOT < 60` condition before the date filter in the WHERE clause instead of after it, though this is functionally equivalent. Do maintain the `STRFTIME` function call with the same date extraction logic but reference it as `T2.Date` instead of `l.Date`. The amended query now correctly matches the RIGHT_SQL's behavior by returning only the required demographic information without the patient ID."
        ],
        "rules": [
            "1) When selecting patient demographic information without ID: output only T1.SEX and T1.Birthday columns.\n2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner match.\n3) When filtering for laboratory examinations in 1994: extract year from T2.Date using strftime('%Y', T2.Date) = '1994'.\n4) When checking for normal AST GOT range: apply condition T2.GOT < 60 before other filters.\n5) Output columns (ordered): T1.SEX, T1.Birthday"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE strftime('%Y', l.Date) = '1994' AND l.GOT < 60;",
            "SELECT T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60\nAND STRFTIME('%Y', T2.Date) = '1994'"
        ],
        "rule_sql": [
            "SELECT T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60\nAND strftime('%Y', T2.Date) = '1994';"
        ]
    },
    "1161": {
        "question": "For in-patient age 50 and above, what is their average anti-cardiolipin antibody (IgG) concentration?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT AVG(T2.`aCL IgG`) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 AND T1.Admission = '+'",
        "amends": [],
        "rules": [
            "in-patient refers to Admission = '+'; age 50 and above refers to SUBTRACT(year(current_timestamp), year(Birthday)) >= '50'; average anti-cardiolipin antibody (IgG) concentration refers to AVG(aCL IgG)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(e.\"aCL IgG\") AS \"Average aCL IgG Concentration\"\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Admission = '+' AND (strftime('%Y', 'now') - strftime('%Y', p.Birthday)) >= 50;"
        ],
        "rule_sql": []
    },
    "1069": {
        "question": "Which football player has the shortest height?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_name FROM player ORDER BY height ASC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `MIN(height)` with an alias. Do remove the `MIN(height)` aggregate function instead of keeping it since we're finding the player with minimum height rather than aggregating. Do add `ORDER BY height ASC` to sort by height ascending instead of omitting ordering. Do add `LIMIT 1` to return only the top row instead of omitting row limiting. Do remove the `FROM Player` table reference capitalization instead of using uppercase table name. The amended query now correctly identifies the single player with the minimum height by sorting and limiting rather than using aggregation which would return all players with their individual heights."
        ],
        "rules": [
            "1) When the question asks for the player with the shortest height: select only player_name instead of including aggregate functions. 2) When finding minimum values: sort by height in ascending order instead of using aggregate functions. 3) When returning a single result from an ordered list: limit the output to only the first row. 4) When referencing table names: use the exact case as shown in the schema (Player instead of PLAYER). 5) Output columns (ordered): player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, MIN(height) AS shortest_height FROM Player;",
            "SELECT player_name FROM Player ORDER BY height ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player ORDER BY height ASC LIMIT 1;"
        ]
    },
    "452": {
        "question": "Please list the names of the cards that have a text box.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE isTextless = 0",
        "amends": [],
        "rules": [
            "have a text box refers to isTextless = 0"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE isTextless = 0;"
        ],
        "rule_sql": []
    },
    "1478": {
        "question": "Which segment had the least consumption?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Segment ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do reference `Segment` directly in the SELECT list instead of including `SUM(ym.Consumption)` as `TotalConsumption`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with `c` and `ym`. Do place the aggregation `SUM(T2.Consumption)` directly in the ORDER BY clause instead of referencing the alias `TotalConsumption` from the SELECT list. The amended query now correctly identifies the segment with the minimum total consumption by moving the aggregate calculation to the ORDER BY clause where it can properly determine the ordering without relying on a SELECT list alias that isn't available during the sorting phase."
        ],
        "rules": [
            "1) When the question asks for \"least consumption\" by segment: organize results by T1.Segment and compute the sum of T2.Consumption per segment, then order by the sum in ascending direction and keep the first 1 row.\n2) When combining T1 (gasstations) and T2 (yearmonth) for shared entities: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match).\n3) When ordering by an aggregate calculation: place the aggregation SUM(T2.Consumption) directly in the order clause instead of referencing an alias from the select list.\n4) When using table aliases: use T1 for the gasstations table and T2 for the yearmonth table as established by the join pattern.\n5) Output columns (ordered): T1.Segment"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.Segment, SUM(ym.Consumption) AS TotalConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nGROUP BY c.Segment\nORDER BY TotalConsumption ASC\nLIMIT 1;",
            "SELECT T1.Segment\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nGROUP BY T1.Segment\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Segment\nFROM gasstations T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nGROUP BY T1.Segment\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ]
    },
    "230": {
        "question": "What are the elements of the toxicology and label of molecule TR060?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'",
        "amends": [],
        "rules": [
            "TR060 is the molecule id; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.element, m.label FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR060';"
        ],
        "rule_sql": []
    },
    "420": {
        "question": "How many cards are oversized, reprinted, and printed for promotions?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1",
        "amends": [],
        "rules": [
            "are oversized refers to isOversized = 1; reprinted refers to isReprint = 1; printed for promotions refers to isPromo = 1"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1;"
        ],
        "rule_sql": []
    },
    "1510": {
        "question": "What is the average total price of the transactions taken place in gas stations in the Czech Republic?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE'",
        "amends": [
            "Do calculate `AVG(T1.Price)` instead of `AVG(Amount * Price)` to average only the price column rather than multiplying amount by price. Do use `INNER JOIN` with explicit keyword instead of just `JOIN` while maintaining the same join condition `T1.GasStationID = T2.GasStationID`. Do use table aliases `T1` and `T2` instead of `t` and `g` for consistency. Do keep the filter `T2.Country = 'CZE'` unchanged in the WHERE clause. The amended query now correctly calculates the average price for Czech gas stations instead of incorrectly computing the average of amount multiplied by price."
        ],
        "rules": [
            "1) When the question asks for average total price of transactions: calculate the average of T1.Price instead of multiplying amount by price.\n2) When combining transactions_1k and gasstations tables: link rows where T1.GasStationID = T2.GasStationID using an inner join.\n3) When filtering for gas stations in the Czech Republic: include only rows where T2.Country equals 'CZE' exactly.\n4) When using table aliases: refer to transactions_1k as T1 and gasstations as T2 consistently.\nOutput columns (ordered): AVG(T1.Price) as average_total_price"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(Amount * Price) AS average_total_price\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE';",
            "SELECT AVG(T1.Price) \nFROM transactions_1k AS T1 \nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID \nWHERE T2.Country = 'CZE'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.Price) as average_total_price\nFROM transactions_1k T1\nINNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nWHERE T2.Country = 'CZE';"
        ]
    },
    "1154": {
        "question": "State the sex and birthday of patient ID '163109'. When was the examination taken and what symptom does the patient had.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.SEX, T1.Birthday, T2.`Examination Date`, T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = 163109",
        "amends": [],
        "rules": [
            "When was the examination taken refers to `Examination Date`"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.SEX, p.Birthday, e.\"Examination Date\", e.Symptoms\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.ID = 163109;"
        ],
        "rule_sql": []
    },
    "1148": {
        "question": "What is the percentage of players that are under 180 cm who have an overall strength of more than 70?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height < 180",
        "amends": [
            "Do use `t1.id` for counting instead of `*` to avoid potential NULL issues. Do add explicit table aliases `t1` and `t2` instead of ambiguous table references. Do move the `height < 180` filter to the `WHERE` clause instead of including it in the CASE expression. Do change the condition to `overall_rating > 70` instead of `strength > 70` to use the correct column. Do add explicit `CAST` to `REAL` instead of using `100.0` for proper type handling. Do use `ELSE NULL` in the CASE expression instead of implicit NULL handling for clarity. Do specify `INNER JOIN` explicitly instead of just `JOIN` for join type clarity. The amended query now correctly calculates the percentage of players under 180cm height with overall rating above 70, matching the intended behavior.",
            "Do remove the `height < 180` condition from the CASE expression instead of including it there, and do add a WHERE clause filter for `t1.height < 180` instead of omitting it. Do simplify the percentage calculation by using direct multiplication and division instead of the complex nested CAST operations. Do change the alias from `percentage` to `percent` instead of keeping the longer form. The amended query now correctly filters players by height in the WHERE clause before applying the rating condition in the CASE expression, ensuring accurate percentage calculation of players under 180cm with ratings above 70."
        ],
        "rules": [
            "1) When counting players: use t1.id as the counting key instead of counting all rows to avoid potential NULL issues.\n2) When filtering by height under 180 cm: apply the condition t1.height < 180 in the WHERE clause instead of using it in a CASE expression.\n3) When checking for overall strength above 70: use the condition t2.overall_rating > 70 instead of t2.strength > 70 to reference the correct column.\n4) When calculating percentages: cast the numerator to REAL type for proper division handling instead of using 100.0 directly.\n5) When using CASE expressions: explicitly specify ELSE NULL for clarity instead of relying on implicit NULL handling.\n6) When joining Player and Player_Attributes tables: use INNER JOIN with the condition t1.player_api_id = t2.player_api_id to ensure only matching pairs are kept.\n7) Output columns (ordered): percentage",
            "1) When calculating percentages for players meeting specific height and rating criteria: filter rows first using the exact condition t1.height < 180 in the WHERE clause instead of including height conditions in CASE expressions.\n2) When computing conditional counts for percentage calculations: use CASE expressions only for the rating condition t2.overall_rating > 70 after applying height filters.\n3) When performing percentage calculations: use direct multiplication and division operations instead of complex nested CAST operations.\n4) When naming percentage result columns: use the exact alias \"percent\" instead of longer forms like \"percentage\".\n5) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match).\nOutput columns (ordered): percent"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN p.height < 180 AND pa.strength > 70 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id;",
            "SELECT \n    (CAST(COUNT(CASE WHEN t1.height < 180 AND t2.overall_rating > 70 THEN t1.id ELSE NULL END) AS REAL) / \n     CAST(COUNT(t1.id) AS REAL)) * 100.0 AS percentage\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id;",
            "SELECT \n    (COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) * 100.0 / COUNT(t1.id)) AS percent\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.height < 180"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(CASE WHEN t2.overall_rating > 70 THEN 1 ELSE NULL END) AS REAL) / COUNT(t1.id)) * 100 AS percent\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.height < 180"
        ]
    },
    "1367": {
        "question": "Which college do most of the members go to?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "college most members go refers to MAX(COUNT(major.college))"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.college\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nGROUP BY m.college\nORDER BY COUNT(mb.member_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1174": {
        "question": "What is the average age of patients as of year 1999 examined in the laboratory for the October of the year 1991?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT AVG('1999'  - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "amends": [
            "Do use `'1999'` as a string literal instead of `1999` as a numeric value in the age calculation. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table alias `T2` for the Patient table instead of `p` and `T1` for Laboratory instead of `l`. Do change the upper bound of the date range to `'1991-10-30'` instead of `'1991-10-31'` to properly capture only October 1991 dates. Do remove the column alias `average_age` instead of keeping it for a more concise output. The amended query now correctly calculates average age using proper string handling and precise date filtering to match the intended behavior."
        ],
        "rules": [
            "1) When calculating age as of year 1999: use the string literal '1999' instead of numeric 1999 in the age calculation. 2) When joining Laboratory and Patient tables: use INNER JOIN with T1 for Laboratory and T2 for Patient, linking where T1.ID = T2.ID. 3) When filtering for October 1991 laboratory examinations: use date range between '1991-10-01' and '1991-10-30' inclusive. 4) When computing average age: calculate AVG(1999 - strftime('%Y', T2.Birthday)) without an output column alias. 5) Output columns (ordered): AVG(1999 - strftime('%Y', T2.Birthday))"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(1999 - strftime('%Y', p.Birthday)) AS average_age\nFROM Laboratory l\nJOIN Patient p ON l.ID = p.ID\nWHERE l.Date BETWEEN '1991-10-01' AND '1991-10-31';",
            "SELECT AVG(1999 - strftime('%Y', T2.Birthday)) \nFROM Laboratory T1\nINNER JOIN Patient T2 ON T1.ID = T2.ID\nWHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'"
        ],
        "rule_sql": [
            "SELECT AVG(1999 - strftime('%Y', T2.Birthday)) FROM Laboratory T1 INNER JOIN Patient T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30';"
        ]
    },
    "1480": {
        "question": "What was the gas consumption peak month for SME customers in 2013?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT SUBSTR(T2.Date, 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME' GROUP BY SUBSTR(T2.Date, 5, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do reference the table aliases `T1` and `T2` instead of `c` and `ym` for consistency with the right query. Do use `INNER JOIN` explicitly instead of just `JOIN` to clarify the join type. Do place the `Segment = 'SME'` filter in the `WHERE` clause instead of keeping it there since it's already correct. Do reference `SUM(T2.Consumption)` directly in the `ORDER BY` clause instead of using the alias `TotalConsumption`. Do group by the expression `SUBSTR(T2.Date, 5, 2)` instead of the alias `Month` to ensure proper grouping. Do remove the column alias `Month` from the `SELECT` list and only keep the expression itself instead of including both. Do remove the alias `TotalConsumption` from the `SELECT` list since it's not needed in the final output. The amended query now correctly identifies the month with the highest total consumption for SME customers in 2013 by properly grouping on the month expression and ordering by the sum directly."
        ],
        "rules": [
            "1) When the question asks for the peak month for SME customers in 2013: filter T1.Segment to exactly 'SME' and T2.Date to start with '2013'. 2) When grouping by month from T2.Date: extract the month using SUBSTR(T2.Date, 5, 2) and group by this expression. 3) When computing total consumption: sum T2.Consumption values. 4) When finding the highest consumption month: order the results by the sum of T2.Consumption in descending order and take the first row. 5) When combining T1 and T2 for customer data: link rows where T1.CustomerID = T2.CustomerID using an inner match. 6) Output columns (ordered): SUBSTR(T2.Date, 5, 2)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    SUBSTR(ym.Date, 5, 2) AS Month,\n    SUM(ym.Consumption) AS TotalConsumption\nFROM \n    yearmonth ym\nJOIN \n    customers c ON ym.CustomerID = c.CustomerID\nWHERE \n    c.Segment = 'SME' AND \n    SUBSTR(ym.Date, 1, 4) = '2013'\nGROUP BY \n    Month\nORDER BY \n    TotalConsumption DESC\nLIMIT 1;",
            "SELECT SUBSTR(T2.Date, 5, 2) AS Month\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND T2.Date LIKE '2013%'\nGROUP BY SUBSTR(T2.Date, 5, 2)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT SUBSTR(T2.Date, 5, 2) AS Month\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND T2.Date LIKE '2013%'\nGROUP BY SUBSTR(T2.Date, 5, 2)\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;"
        ]
    },
    "905": {
        "question": "What is Eddie Irvine's average points scored in year 2000?",
        "db_id": "formula_1",
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine' AND T3.year = 2000",
        "amends": [
            "Do join `driverStandings` instead of `results` as the source for points data. Do use `INNER JOIN` on `driverStandings` with `driverId` instead of joining `results` with `raceId`. Do maintain the same filter conditions for `forename`, `surname`, and `year` but apply them to the correct table aliases. Do remove the column alias `average_points` instead of keeping it. The amended query now correctly calculates average points from driver standings rather than race results, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for average points scored by a specific driver in a specific year: use the driverStandings table as the source for points data instead of the results table.\n2) When joining driverStandings with drivers: link rows where driverStandings.driverId equals drivers.driverId using an inner match.\n3) When filtering for driver name \"Eddie Irvine\": apply conditions drivers.forename = 'Eddie' AND drivers.surname = 'Irvine' exactly as specified.\n4) When filtering for year 2000: apply condition races.year = 2000 exactly as specified.\n5) When calculating average points: compute the average of driverStandings.points for the matching rows.\n6) When producing output: do not include column aliases like average_points in the final result.\nOutput columns (ordered): AVG(driverStandings.points)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(r.points) AS average_points\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.year = 2000 AND d.forename = 'Eddie' AND d.surname = 'Irvine';",
            "SELECT AVG(ds.points) FROM driverStandings ds INNER JOIN drivers d ON ds.driverId = d.driverId INNER JOIN races r ON ds.raceId = r.raceId WHERE d.forename = 'Eddie' AND d.surname = 'Irvine' AND r.year = 2000"
        ],
        "rule_sql": [
            "SELECT AVG(driverStandings.points) \nFROM driverStandings \nINNER JOIN drivers ON driverStandings.driverId = drivers.driverId \nINNER JOIN races ON driverStandings.raceId = races.raceId \nWHERE drivers.forename = 'Eddie' AND drivers.surname = 'Irvine' AND races.year = 2000"
        ]
    },
    "393": {
        "question": "On how many cards designed by John Avon is its foil non-powerful?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do add parentheses around `cardKingdomId IS NULL OR cardKingdomFoilId IS NULL` instead of only checking `cardKingdomFoilId IS NULL` to include both conditions. Do move the artist filter `artist = 'John Avon'` to the end instead of having it first to maintain logical grouping with the NULL checks. The amended query now correctly counts cards where either cardKingdomId or cardKingdomFoilId is NULL for John Avon's artwork, matching the intended behavior."
        ],
        "rules": [
            "1) When counting cards: use the exact identifier \"id\" instead of counting all columns to avoid including NULL values. 2) When checking for non-powerful cards: include both conditions with parentheses as (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) instead of only checking cardKingdomFoilId IS NULL. 3) When filtering by artist John Avon: place the condition artist = 'John Avon' at the end to maintain logical grouping with the NULL checks. 4) When the question asks about cards designed by John Avon with non-powerful foil: count cards where either cardKingdomId or cardKingdomFoilId is NULL for the artist John Avon. Output columns (ordered): count of id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE artist = 'John Avon' AND cardKingdomFoilId IS NULL;",
            "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon';"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'"
        ]
    },
    "794": {
        "question": "Which hero was the fastest?",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do remove the `GROUP BY s.superhero_name` and `MAX(ha.attribute_value)` aggregation instead of grouping and using an aggregate function, since the query only needs to return a single row. Do use `T2.attribute_value` directly in the `ORDER BY` clause instead of applying `MAX()` to it, as there's no grouping requirement. Do change the table aliases to `T1`, `T2`, and `T3` instead of `s`, `ha`, and `a` for consistency with the target query structure. Do add explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. The amended query now correctly returns the superhero with the highest Speed attribute value without unnecessary aggregation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the fastest hero: use the exact token \"Speed\" as the literal value for attribute filtering. 2) When combining tables T1, T2, and T3: link rows where T1.id = T2.hero_id and T2.attribute_id = T3.id using inner matches only. 3) When ordering by attribute value to find the fastest: sort T2.attribute_value in descending order and take the first row. 4) When no grouping is required: do not use GROUP BY or aggregation functions like MAX(). 5) Output columns (ordered): T1.superhero_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nGROUP BY s.superhero_name\nORDER BY MAX(ha.attribute_value) DESC\nLIMIT 1;",
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Speed'\nORDER BY T2.attribute_value DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nINNER JOIN hero_attribute ha ON s.id = ha.hero_id\nINNER JOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nORDER BY ha.attribute_value DESC\nLIMIT 1"
        ]
    },
    "1511": {
        "question": "For the customers who paid in the euro, what is their average total price of the transactions?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Currency = 'EUR'",
        "amends": [
            "Do select `AVG(T1.Price)` instead of `AVG(Amount * Price)` to calculate the average price rather than the product of amount and price. Do join `gasstations AS T2` on `T1.GasStationID = T2.GasStationID` instead of omitting this table entirely. Do use `INNER JOIN` for both joins instead of just `JOIN` for clarity. Do reference tables as `T1`, `T2`, and `T3` with explicit aliases instead of `t` and `c` for better readability. Do filter on `T3.Currency = 'EUR'` instead of `c.Currency = 'EUR'` to maintain consistent table alias usage. The amended query now correctly calculates the average price from transactions joined with both gasstations and customers tables for EUR currency transactions."
        ],
        "rules": [
            "1) When the question asks for average total price of transactions: calculate the average of T1.Price instead of multiplying Amount and Price. 2) When combining transaction data with customer information: join T1 (transactions_1k) with T3 (customers) using T1.CustomerID = T3.CustomerID. 3) When combining transaction data with gas station information: join T1 (transactions_1k) with T2 (gasstations) using T1.GasStationID = T2.GasStationID. 4) When filtering for customers who paid in euro: include only rows where T3.Currency equals 'EUR'. 5) When joining multiple tables: use inner joins to ensure all relationships are satisfied. 6) Output columns (ordered): AVG(T1.Price) AS AverageTotalPrice"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(Amount * Price) AS AverageTotalPrice\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE c.Currency = 'EUR';",
            "SELECT AVG(T1.Price) AS AveragePrice\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Currency = 'EUR';"
        ],
        "rule_sql": [
            "SELECT AVG(T1.Price) AS AverageTotalPrice\nFROM transactions_1k T1\nINNER JOIN customers T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Currency = 'EUR';"
        ]
    },
    "837": {
        "question": "Give the hero ID of superhero with the lowest attribute value.",
        "db_id": "superhero",
        "ground_truth": "SELECT hero_id FROM hero_attribute WHERE attribute_value = ( SELECT MIN(attribute_value) FROM hero_attribute )",
        "amends": [],
        "rules": [
            "lowest attribute value refers to MIN(attribute_value);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hero_id FROM hero_attribute WHERE attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute);"
        ],
        "rule_sql": []
    },
    "512": {
        "question": "How many cards with unknown power that can't be found in foil is in duel deck A?",
        "db_id": "card_games",
        "ground_truth": "SELECT SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE hasFoil = 0 AND duelDeck = 'a'",
        "amends": [],
        "rules": [
            "unknown power refers to power IS NULL or power = '*'; can't be found in foil refers to hasFoil = 0; duel deck A refers to duelDeck = 'a'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE (power IS NULL OR power = '*') AND hasFoil = 0 AND duelDeck = 'a';"
        ],
        "rule_sql": []
    },
    "736": {
        "question": "Who is the dumbest superhero?",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' ORDER BY T2.attribute_value LIMIT 1",
        "amends": [],
        "rules": [
            "the dumbest superhero refers to MIN(attribute_value) where attribute_name = 'Intelligence'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Intelligence'\nORDER BY ha.attribute_value ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "591": {
        "question": "How many users are awarded with supporter badge during year 2011?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE STRFTIME('%Y', Date) = '2011' AND Name = 'Supporter'",
        "amends": [],
        "rules": [
            "\"Supporter\" is the Name of badge; in year 2011 refers to year(Date) = 2011"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT UserId) AS NumberOfUsers\nFROM badges\nWHERE Name = 'Supporter' AND strftime('%Y', Date) = '2011';"
        ],
        "rule_sql": []
    },
    "906": {
        "question": "Which was Lewis Hamilton first race? What was his points recorded for his first race event?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.name, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year ASC LIMIT 1",
        "amends": [
            "Do use `driverStandings` table instead of `results` table to get points data. Do join `races` directly with `driverStandings` on `raceId` instead of using a CTE with complex joins. Do remove the CTE structure entirely instead of keeping the nested query approach. Do reference tables with aliases `T1`, `T2`, and `T3` instead of full table names. Do filter directly in the main query's `WHERE` clause instead of using a CTE with separate filtering. Do add `ORDER BY T1.year ASC` instead of ordering by both `year` and `round`. Do select `T1.name` and `T2.points` instead of `race_name`, `date`, and `points`. Do remove the `date` column from the output instead of including it. The amended query now correctly retrieves Hamilton's points from the driver standings table for his first race year."
        ],
        "rules": [
            "1) When the question asks about a driver's first race: find the earliest race year for that driver using T1.year and order by T1.year ASC.\n2) When the question mentions \"Lewis Hamilton\": filter using exact literals T3.forename = 'Lewis' AND T3.surname = 'Hamilton'.\n3) When retrieving points data for a race: use the driverStandings table (T2) instead of the results table to get accurate points information.\n4) When combining race and driver standings data: link rows where T1.raceId = T2.raceId using exact key equality.\n5) When combining driver and driver standings data: link rows where T2.driverId = T3.driverId using exact key equality.\n6) When selecting output for a driver's first race: include T1.name for the race name and T2.points for the points recorded, but exclude date information.\n7) When determining the first race: use only year-based ordering (T1.year ASC) instead of ordering by both year and round.\nOutput columns (ordered): T1.name, T2.points"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH hamilton_first_race AS (\n    SELECT r.raceId, r.year, r.round, r.name AS race_name, r.date\n    FROM results res\n    JOIN drivers d ON res.driverId = d.driverId\n    JOIN races r ON res.raceId = r.raceId\n    WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\n    ORDER BY r.year, r.round\n    LIMIT 1\n)\nSELECT hfr.race_name AS first_race, hfr.date, res.points\nFROM hamilton_first_race hfr\nJOIN results res ON hfr.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
            "SELECT T1.name, T2.points \nFROM races T1 \nJOIN driverStandings T2 ON T1.raceId = T2.raceId \nJOIN drivers T3 ON T2.driverId = T3.driverId \nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' \nORDER BY T1.year ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.points\nFROM races T1\nJOIN driverStandings T2 ON T1.raceId = T2.raceId\nJOIN drivers T3 ON T2.driverId = T3.driverId\nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\nORDER BY T1.year ASC\nLIMIT 1"
        ]
    },
    "308": {
        "question": "How many bonds are created by bonding atoms with chlorine element?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T1.bond_id) FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T2.element = 'cl'",
        "amends": [],
        "rules": [
            "chlorine refers to element = 'cl'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.bond_id) AS bond_count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE a1.element = 'cl' OR a2.element = 'cl';"
        ],
        "rule_sql": []
    },
    "546": {
        "question": "Please list the display names of all the users who owns a post that is well-finished.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.ClosedDate IS NOT NULL",
        "amends": [],
        "rules": [
            "the post that is well-finished refers to ClosedDate IS NOT Null"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ClosedDate IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1383": {
        "question": "State the name of students from Georgetown, South Carolina.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Georgetown' AND T2.state = 'South Carolina'",
        "amends": [],
        "rules": [
            "name of students means the full name; full name refers to first_name, last_name; Georgetown is a city; South Carolina is a state"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE z.city = 'Georgetown' AND z.state = 'South Carolina';"
        ],
        "rule_sql": []
    },
    "1112": {
        "question": "What was the chance creation crossing class for \"Hull City\" on 2010/2/22?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.chanceCreationCrossingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hull City' AND SUBSTR(t2.`date`, 1, 10) = '2010-02-22'",
        "amends": [],
        "rules": [
            "\"Hull City\" refers to team_long_name = 'Hull City'; on 2010/2/22 refers to date = '2010-02-22 00:00:00'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ta.chanceCreationCrossingClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'Hull City' \nAND ta.date = '2010-02-22 00:00:00';"
        ],
        "rule_sql": []
    },
    "1461": {
        "question": "List the last names of students under the Elementary Education major and include their phone numbers.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.last_name, T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T2.major_name = 'Elementary Education'",
        "amends": [],
        "rules": [
            "'Elementary Education' is the major name; phone numbers refers to phone"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.last_name, m.phone\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Elementary Education';"
        ],
        "rule_sql": []
    },
    "1515": {
        "question": "What segment did the customer have at 2012/8/23 21:20:00?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.date = '2012-08-23' AND T1.time = '21:20:00'",
        "amends": [],
        "rules": [
            "'2012/8/23' can be represented by '2012-08-23'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.Segment\nFROM customers c\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE t.Date = '2012-08-23' AND t.Time = '21:20:00';"
        ],
        "rule_sql": []
    },
    "1083": {
        "question": "Which player has the strongest overall strength?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `overall_rating` in the SELECT list. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference the joined table as `t2` instead of `pa` for consistency. Do maintain the same join condition `t1.player_api_id = t2.player_api_id` instead of changing it. Do keep the same ORDER BY clause on `t2.overall_rating DESC` instead of altering it. Do preserve the same LIMIT 1 instead of modifying it. The amended query now correctly returns only the player name of the highest-rated player instead of including the redundant rating value in the output."
        ],
        "rules": [
            "1) When the question asks for the strongest overall strength: use the column \"overall_rating\" from table T2 to determine strength ranking.\n2) When selecting output columns: include only \"player_name\" from table T1 and exclude the rating value from the output.\n3) When combining Player and Player_Attributes tables: link rows where T1.player_api_id equals T2.player_api_id using an inner match.\n4) When ordering results by strength: sort rows in descending order based on T2.overall_rating.\n5) When finding the top result: keep only the first row after sorting.\n6) Output columns (ordered): T1.player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;",
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t2.overall_rating DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT p.player_name\nFROM Player p\nINNER JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;"
        ]
    },
    "542": {
        "question": "What is the total number of comments of all the posts owned by csgillespie?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT SUM(T1.CommentCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [],
        "rules": [
            "\"csgillespie\" is the DisplayName of user; total number of comments refers to Sum(CommentCount)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(p.CommentCount) AS TotalComments\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';"
        ],
        "rule_sql": []
    },
    "1466": {
        "question": "Write the full name of the club member with the position of 'Secretary' and list which college the club member belongs to.",
        "db_id": "student_club",
        "ground_truth": "SELECT T1.first_name, T1.last_name, college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Secretary'",
        "amends": [
            "Do use separate columns `first_name` and `last_name` instead of concatenating them as `full_name`. Do reference the major table as `T2` instead of `ma` and use `T2.college` instead of `ma.college`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do reverse the join condition to `T2.major_id = T1.link_to_major` instead of `m.link_to_major = ma.major_id` for clarity. Do use table alias `T1` consistently instead of mixing `m` and `T1`. The amended query now correctly selects individual name columns and maintains the same join logic with proper table aliasing."
        ],
        "rules": [
            "1) When the question asks for the full name of a club member: output the first_name and last_name columns separately instead of concatenating them as full_name.\n2) When joining the member table (T1) with the major table (T2): use an inner join where T2.major_id equals T1.link_to_major.\n3) When filtering for members with position of 'Secretary': include only rows where T1.position equals exactly 'Secretary' (case-sensitive).\n4) When selecting which college the member belongs to: use T2.college from the major table.\n5) Output columns (ordered): T1.first_name, T1.last_name, T2.college"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, ma.college\nFROM member m\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE m.position = 'Secretary';",
            "SELECT T1.first_name, T1.last_name, T2.college FROM member T1 INNER JOIN major T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Secretary'"
        ],
        "rule_sql": [
            "SELECT m.first_name, m.last_name, maj.college \nFROM member m \nINNER JOIN major maj ON maj.major_id = m.link_to_major \nWHERE m.position = 'Secretary'"
        ]
    },
    "408": {
        "question": "How many unknown power cards contain info about the triggered ability",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power = '*') AND T2.text LIKE '%triggered ability%'",
        "amends": [
            "Do select `T2.text` instead of `COUNT(*)` to return actual ruling text rather than just a count. Do add `INNER JOIN rulings AS T2` on `T1.uuid = T2.uuid` instead of querying only the `cards` table to properly join with rulings data. Do reference `T1.power` instead of just `power` to qualify the column with its table alias. Do reference `T2.text` instead of just `text` in the LIKE condition to filter on the ruling text rather than card text. The amended query now correctly joins cards with their rulings and returns the actual ruling text containing triggered ability references instead of just counting them.",
            "Do change the WHERE condition to `T1.power IS NULL OR T1.power = '*'` instead of `T1.power = 'unknown'` to properly handle both NULL values and the asterisk wildcard character that represents unknown power values. The amended query now correctly matches the RIGHT_SQL's behavior by addressing the NULL semantics and alternative representation of unknown power values."
        ],
        "rules": [
            "1) When the question asks for information about unknown power cards containing triggered ability info: select T2.text to return the actual ruling text content instead of just counting rows. 2) When combining card and ruling data: link rows where T1.uuid = T2.uuid using an inner match to properly associate cards with their corresponding rulings. 3) When filtering for unknown power cards: check T1.power IS NULL OR T1.power = '*' to identify cards with missing or unknown power values. 4) When filtering for triggered ability references: check T2.text LIKE '%triggered ability%' to find ruling text containing the exact phrase \"triggered ability\". 5) Output columns (ordered): T2.text",
            "1) When the question asks for cards with unknown power: check for both NULL values and the literal '*' character in T1.power using the condition (T1.power IS NULL OR T1.power = '*').\n2) When the question asks for text containing \"triggered ability\": filter T2.text to include only rows where the text contains the exact phrase \"triggered ability\".\n3) When combining cards and rulings tables: link rows where T1.uuid equals T2.uuid and keep only matching pairs (inner match).\n4) Output columns (ordered): T2.text"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE (power IS NULL OR power = '*') \nAND text LIKE '%triggered ability%';",
            "SELECT T2.text \nFROM cards AS T1 \nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid \nWHERE T1.power = 'unknown' \nAND T2.text LIKE '%triggered ability%';",
            "SELECT T2.text \nFROM cards AS T1 \nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid \nWHERE (T1.power IS NULL OR T1.power = '*') \nAND T2.text LIKE '%triggered ability%';"
        ],
        "rule_sql": [
            "SELECT T2.text\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE (T1.power IS NULL OR T1.power = '*')\nAND T2.text LIKE '%triggered ability%'"
        ]
    },
    "978": {
        "question": "How many times the circuits were held in Austria? Please give their location and coordinates.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
        "amends": [
            "Do remove the `JOIN races` clause and all race-related columns instead of including them, as the query only needs circuit location data. Do remove the `COUNT(r.raceId)` aggregate and `GROUP BY` clause instead of performing unnecessary grouping and counting. Do add `DISTINCT` to ensure unique location records instead of potentially returning duplicates. Do simplify the SELECT list to only `location, lat, lng` instead of including `name` and unnecessary circuit identifiers. Do keep the `WHERE country = 'Austria'` filter unchanged as it correctly restricts to Austrian circuits. The amended query now correctly returns only distinct location coordinates for Austrian circuits without the race count aggregation."
        ],
        "rules": [
            "1) When the question asks for location and coordinates of circuits in a specific country: filter rows where the country column equals the exact literal 'Austria'. 2) When the question requires distinct location records: ensure only unique combinations of location, latitude, and longitude values are returned. 3) When the question specifies output columns: include only the exact columns location, lat, and lng in the results. 4) When the question does not require race count information: do not join with the races table or perform any counting operations. 5) Output columns (ordered): location, lat, lng"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, c.location, c.lat, c.lng, COUNT(r.raceId) AS race_count\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nWHERE c.country = 'Austria'\nGROUP BY c.circuitId, c.name, c.location, c.lat, c.lng;",
            "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria';"
        ],
        "rule_sql": [
            "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria';"
        ]
    },
    "1435": {
        "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "db_id": "student_club",
        "ground_truth": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "amends": [],
        "rules": [
            "name of events refers event_name; game event that was closed refers to type = 'Game' where status = 'Closed'; event_date BETWEEN '2019-03-15' and '2020-03-20'; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name FROM event WHERE type = 'Game' AND status = 'Closed' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';"
        ],
        "rule_sql": []
    },
    "1460": {
        "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.first_name, T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
        "amends": [
            "Do select `first_name` and `last_name` as separate columns instead of concatenating them into `full_name`. Do use `INNER JOIN` with the explicit keyword instead of just `JOIN`. Do reverse the join condition to `T1.link_to_member = T2.member_id` instead of `m.member_id = e.link_to_member` to maintain proper table reference consistency. Do use table aliases `T1` and `T2` instead of single-letter aliases `m` and `e` for better readability. The amended query now correctly retrieves individual name components and maintains proper join semantics while matching the RIGHT_SQL's behavior.",
            "Do use a single equality comparison with `expense_description = 'Water, Veggie tray, supplies'` instead of the `IN` operator with separate values `('water', 'veggie tray', 'supplies')` to match the exact combined string value. Do maintain the same `INNER JOIN` on `T1.link_to_member = T2.member_id` without changes to the join condition. Do preserve the same column selection of `T2.first_name, T2.last_name, T1.cost` from the same tables. The amended query now correctly filters for the specific combined description string instead of multiple separate values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a member's full name: output first_name and last_name as separate columns instead of concatenating them into a single full_name column. 2) When joining T1 (expense table) and T2 (member table): use an INNER JOIN with the condition T1.link_to_member = T2.member_id to maintain proper table reference consistency. 3) When filtering for expenses with the exact description \"Water, Veggie tray, supplies\": use the literal value exactly as specified with the same case, spacing, and punctuation. 4) When selecting output columns: include both T2.first_name and T2.last_name as separate columns along with T1.cost. 5) Output columns (ordered): T2.first_name, T2.last_name, T1.cost",
            "1) When the question asks for the full name of a member who spent money on specific items: combine T2.first_name and T2.last_name to form the full name.\n2) When filtering for expenses with the exact description \"Water, Veggie tray, supplies\": use equality comparison with expense_description = 'Water, Veggie tray, supplies' (exact case and punctuation).\n3) When combining expense and member tables: link rows where T1.link_to_member = T2.member_id and keep only matching pairs (inner match).\n4) When the question includes the cost of the expense: include T1.cost in the output.\nOutput columns (ordered): T2.first_name, T2.last_name, T1.cost"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, e.cost\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.expense_description = 'Water, Veggie tray, supplies';",
            "SELECT T2.first_name, T2.last_name, T1.cost\nFROM expense T1\nINNER JOIN member T2 ON T1.link_to_member = T2.member_id\nWHERE T1.expense_description IN ('water', 'veggie tray', 'supplies');",
            "SELECT T2.first_name, T2.last_name, T1.cost\nFROM expense T1\nINNER JOIN member T2 ON T1.link_to_member = T2.member_id\nWHERE T1.expense_description = 'Water, Veggie tray, supplies'"
        ],
        "rule_sql": [
            "SELECT T2.first_name, T2.last_name, T1.cost \nFROM expense T1 \nINNER JOIN member T2 ON T1.link_to_member = T2.member_id \nWHERE T1.expense_description = 'Water, Veggie tray, supplies'"
        ]
    },
    "728": {
        "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
        "db_id": "superhero",
        "ground_truth": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
        "amends": [
            "Do add `RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank` instead of omitting the window function. Do use `INNER JOIN` explicitly instead of just `JOIN` for both joins. Do change the alias `eye_colour` to `EyeColor` instead of keeping the original casing. Do remove the `ORDER BY superhero_count DESC` clause instead of keeping it since the ranking function handles ordering. Do add the `Count` alias instead of `superhero_count` for the aggregate column. The amended query now correctly calculates popularity rankings for eye colors among Marvel Comics superheroes."
        ],
        "rules": [
            "1) When the question mentions \"rank\" and \"popularity\" for eye colors: use a ranking function that orders by the count of superheroes in descending order to determine popularity rank. 2) When joining the superhero table with publisher information: use an inner join between superhero and publisher where superhero.publisher_id equals publisher.id to filter for Marvel Comics superheroes. 3) When joining the superhero table with color information: use an inner join between superhero and colour where superhero.eye_colour_id equals colour.id to get eye color details. 4) When filtering for Marvel Comics superheroes: include only rows where publisher.publisher_name equals 'Marvel Comics' exactly. 5) When grouping results by eye color: organize the output by colour.colour to count superheroes per eye color. 6) When counting superheroes: use the canonical key superhero.id to count the number of superheroes per eye color group. 7) When outputting the eye color column: use the alias EyeColor instead of the original casing for the colour.colour field. 8) When outputting the count column: use the alias Count instead of superhero_count for the aggregate result. 9) When the ranking function handles ordering: do not include an additional ORDER BY clause in the final output. Output columns (ordered): EyeColor, Count, PopularityRank"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.colour AS eye_colour, COUNT(s.id) AS superhero_count\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'Marvel Comics'\nGROUP BY c.colour\nORDER BY superhero_count DESC;",
            "SELECT \n    c.colour AS EyeColor,\n    COUNT(s.id) AS Count,\n    RANK() OVER (ORDER BY COUNT(s.id) DESC) AS PopularityRank\nFROM \n    superhero s\nINNER JOIN \n    colour c ON s.eye_colour_id = c.id\nINNER JOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    p.publisher_name = 'Marvel Comics'\nGROUP BY \n    c.colour"
        ],
        "rule_sql": [
            "SELECT \n    c.colour AS EyeColor,\n    COUNT(s.id) AS Count,\n    RANK() OVER (ORDER BY COUNT(s.id) DESC) AS PopularityRank\nFROM \n    superhero s\nINNER JOIN \n    publisher p ON s.publisher_id = p.id\nINNER JOIN \n    colour c ON s.eye_colour_id = c.id\nWHERE \n    p.publisher_name = 'Marvel Comics'\nGROUP BY \n    c.colour\nORDER BY \n    PopularityRank;"
        ]
    },
    "221": {
        "question": "What are the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6?",
        "db_id": "toxicology",
        "ground_truth": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1 , T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'",
        "amends": [
            "Do use `SUBSTR(T.bond_id, 1, 7)` and `T.molecule_id || SUBSTR(T.bond_id, 8, 2)` in the SELECT list instead of joining to the `atom` table to get `a1.atom_id` and `a2.atom_id`. Do query from the `bond` table as `T` instead of joining `connected c` with `atom a1` and `atom a2`. Do remove the JOIN conditions `c.atom_id = a1.atom_id` and `c.atom_id2 = a2.atom_id` instead of keeping them. Do keep the filter `T.molecule_id = 'TR001'` and `T.bond_id = 'TR001_2_6'` in the WHERE clause instead of the previous complex join-based approach. The amended query now correctly extracts atom identifiers directly from the bond_id field structure rather than relying on potentially incorrect table joins, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for atoms bonded in a specific molecule with a specific bond ID: query from the bond table as T instead of joining multiple tables. 2) When extracting atom identifiers from bond_id field structure: use SUBSTR(T.bond_id, 1, 7) for the first atom and T.molecule_id || SUBSTR(T.bond_id, 8, 2) for the second atom instead of joining to atom tables. 3) When filtering for a specific molecule and bond: apply T.molecule_id = 'TR001' and T.bond_id = 'TR001_2_6' conditions exactly as specified. 4) When handling bond_id structure: preserve the exact substring positions (1,7 and 8,2) and concatenation pattern shown in the amends. 5) Output columns (ordered): SUBSTR(T.bond_id, 1, 7), T.molecule_id || SUBSTR(T.bond_id, 8, 2)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a1.atom_id AS atom1, a2.atom_id AS atom2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_2_6' AND a1.molecule_id = 'TR001' AND a2.molecule_id = 'TR001';",
            "SELECT \n  SUBSTR(T.bond_id, 1, 7) AS atom_id1,\n  T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2\nFROM \n  bond T\nWHERE \n  T.molecule_id = 'TR001' \n  AND T.bond_id = 'TR001_2_6'"
        ],
        "rule_sql": [
            "SELECT SUBSTR(T.bond_id, 1, 7), T.molecule_id || SUBSTR(T.bond_id, 8, 2) FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'"
        ]
    },
    "144": {
        "question": "How much is the average amount in credit card made by account holders in a month, in year 2021?",
        "db_id": "financial",
        "ground_truth": "SELECT AVG(T4.amount) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE STRFTIME('%Y', T4.date) = '1998' AND T4.operation = 'VYBER KARTOU'",
        "amends": [
            "Do use `AVG(T4.amount)` without month grouping instead of `strftime('%m', t.date) AS month` with `AVG(t.amount)` and grouping. Do join `card AS T1` and `disp AS T2` on `T1.disp_id = T2.disp_id` instead of omitting these tables entirely. Do join `account AS T3` on `T2.account_id = T3.account_id` instead of directly joining `account a` on `t.account_id = a.account_id`. Do join `trans AS T4` on `T3.account_id = T4.account_id` instead of the direct account-trans join. Do filter with `STRFTIME('%Y', T4.date) = '1998'` instead of `'2021'` while keeping `T4.operation = 'VYBER KARTOU'`. Do remove the `GROUP BY month` and `ORDER BY month` clauses instead of including them. The amended query now correctly calculates the average amount for card withdrawal operations in 1998 across the proper table relationships."
        ],
        "rules": [
            "1) When the question asks for average amount of credit card operations: compute the average of T4.amount without grouping by month. 2) When joining tables for account holder relationships: link card as T1 and disp as T2 where T1.disp_id = T2.disp_id. 3) When connecting to account information: join account as T3 where T2.account_id = T3.account_id. 4) When accessing transaction data: join trans as T4 where T3.account_id = T4.account_id. 5) When filtering for credit card withdrawal operations: include only rows where T4.operation = 'VYBER KARTOU'. 6) When filtering for a specific year: include only rows where STRFTIME('%Y', T4.date) = '1998'. 7) When the question does not specify monthly breakdown: do not group by month or order by month. Output columns (ordered): AVG(T4.amount)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    strftime('%m', t.date) AS month,\n    AVG(t.amount) AS average_amount\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nWHERE \n    t.operation = 'VYBER KARTOU'\n    AND strftime('%Y', t.date) = '2021'\nGROUP BY \n    month\nORDER BY \n    month;",
            "SELECT AVG(T4.amount) AS average_amount\nFROM card AS T1\nJOIN disp AS T2 ON T1.disp_id = T2.disp_id\nJOIN account AS T3 ON T2.account_id = T3.account_id\nJOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE STRFTIME('%Y', T4.date) = '1998'\nAND T4.operation = 'VYBER KARTOU'"
        ],
        "rule_sql": [
            "SELECT AVG(T4.amount) \nFROM card AS T1\nJOIN disp AS T2 ON T1.disp_id = T2.disp_id\nJOIN account AS T3 ON T2.account_id = T3.account_id\nJOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE T4.operation = 'VYBER KARTOU'\nAND STRFTIME('%Y', T4.date) = '2021'"
        ]
    },
    "469": {
        "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
        "db_id": "card_games",
        "ground_truth": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
        "amends": [
            "Do use `IIF` function with uppercase 'YES'/'NO' instead of `CASE WHEN` with 'Yes'/'No' for the conditional logic. Do remove `DISTINCT` instead of keeping it since the join condition ensures uniqueness. Do use table aliases `T1` and `T2` instead of full table names `c` and `s`. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do reverse the join condition to `T2.code = T1.setCode` instead of `c.setCode = s.code` while maintaining the same logical relationship. The amended query now correctly returns the MTGO appearance status without unnecessary DISTINCT and with consistent conditional formatting.",
            "Do check `T2.mtgoCode IS NOT NULL` directly in the `SELECT` expression instead of using `COUNT(*) > 0` to determine the result. Do remove the `WHERE` condition `T2.mtgoCode IS NOT NULL` since it's now handled in the `SELECT` clause instead of filtering rows. Do omit the `AS appears_on_mtgo` alias from the `SELECT` list instead of including it. The amended query now correctly evaluates the mtgoCode presence directly for each matching row rather than counting filtered results, ensuring accurate boolean determination for the specified card name."
        ],
        "rules": [
            "1) When the question asks about appearance on Magic: The Gathering Online: use the IIF function with uppercase 'YES' and 'NO' literals instead of CASE WHEN with 'Yes' and 'No'. 2) When checking if a card appears on MTGO: use T2.mtgoCode IS NOT NULL as the condition for determining appearance status. 3) When joining cards and sets tables: use INNER JOIN with the condition T2.code = T1.setCode to link the tables. 4) When filtering for a specific card name: use T1.name = 'Angel of Mercy' with exact literal matching. 5) When ensuring result uniqueness: do not use DISTINCT when the join condition already guarantees uniqueness. 6) When using table aliases: refer to cards table as T1 and sets table as T2 consistently. Output columns (ordered): IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') AS appeared_on_mtgo",
            "1) When the question asks about a card appearing on Magic: The Gathering Online: check if the mtgoCode is not null for the matching set. 2) When looking for a specific card name \"Angel of Mercy\": filter rows where T1.name equals exactly 'Angel of Mercy'. 3) When combining cards and sets tables: link rows where T2.code equals T1.setCode to find the corresponding set information. 4) When determining boolean appearance results: evaluate the condition directly in the output expression rather than counting filtered results. 5) When producing a simple yes/no answer: omit column aliases from the output. Output columns (ordered): IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO')"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT CASE WHEN s.mtgoCode IS NOT NULL THEN 'Yes' ELSE 'No' END AS appeared_on_mtgo\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE c.name = 'Angel of Mercy';",
            "SELECT IIF(COUNT(*) > 0, 'YES', 'NO') AS appears_on_mtgo\nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Angel of Mercy' AND T2.mtgoCode IS NOT NULL;",
            "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards T1 INNER JOIN sets T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'"
        ],
        "rule_sql": [
            "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') AS appeared_on_mtgo\nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Angel of Mercy'"
        ]
    },
    "634": {
        "question": "Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1",
        "amends": [
            "Do join `postHistory` and `posts` tables instead of directly joining `users` with `posts`. Do use `INNER JOIN` on `T1.Id = T2.UserId` and `T2.PostId = T3.Id` instead of `JOIN` on `u.Id = p.OwnerUserId`. Do change the WHERE condition to use `OR` logic with `T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder'` instead of `IN` clause. Do aggregate with `SUM(T3.ViewCount)` in the ORDER BY instead of calculating total_views in a CTE. Do remove the CTE structure and perform aggregation directly in the main query instead of using a separate WITH clause. Do reference `T3.ViewCount` for summation instead of `p.ViewCount`. The amended query now correctly calculates view counts through the postHistory relationship and matches the RIGHT_SQL's behavior.",
            "Do remove `SUM(T3.ViewCount) AS total_views` from the SELECT list instead of including it, and do move the `SUM(T3.ViewCount)` aggregate function to the ORDER BY clause instead of keeping it in SELECT. Do maintain the same FROM sources with `INNER JOIN` on `T1.Id = T2.UserId` and `INNER JOIN` on `T2.PostId = T3.Id`, and preserve the WHERE filter on `T1.DisplayName` with OR conditions. Do keep the GROUP BY on `T1.DisplayName` and LIMIT 1, but do order by `SUM(T3.ViewCount) DESC` instead of by the removed alias `total_views`. The amended query now correctly returns only the display name while ordering by the sum of view counts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining tables to find post view counts: use an inner match between postHistory (T1) and posts (T3) through users (T2) where T1.Id = T2.UserId and T2.PostId = T3.Id instead of directly joining users with posts.\n2) When filtering for specific users by display name: use OR logic with exact literal matches T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' instead of an IN clause.\n3) When calculating total view counts: aggregate using SUM(T3.ViewCount) instead of calculating in a separate CTE structure.\n4) When ordering results by popularity: sort by the total view count in descending order to determine which user has higher popularity.\n5) When comparing popularity between specific users: return only the top result to identify which one has higher popularity.\nOutput columns (ordered): T1.DisplayName, SUM(T3.ViewCount)",
            "1) When the question asks for which of two specific users has higher popularity based on post views: compute the sum of T3.ViewCount for each user and compare them to determine the highest.\n2) When filtering for specific users by display name: use exact string literals 'Harvey Motulsky' and 'Noah Snyder' with OR conditions on T1.DisplayName.\n3) When combining user, post history, and post information: link rows where T1.Id = T2.UserId and T2.PostId = T3.Id using inner matches only.\n4) When grouping by user: organize results by T1.DisplayName to compute aggregates per user.\n5) When determining the highest popularity: order results by SUM(T3.ViewCount) in descending direction and keep only the top result.\n6) When outputting results for comparison questions: return only the identifier being compared (T1.DisplayName) without the aggregate value used for ordering.\nOutput columns (ordered): T1.DisplayName"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH user_view_counts AS (\n    SELECT \n        u.DisplayName,\n        SUM(p.ViewCount) AS total_views\n    FROM \n        users u\n    JOIN \n        posts p ON u.Id = p.OwnerUserId\n    WHERE \n        u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')\n    GROUP BY \n        u.DisplayName\n)\nSELECT \n    DisplayName,\n    total_views\nFROM \n    user_view_counts\nORDER BY \n    total_views DESC\nLIMIT 1;",
            "SELECT \n    T1.DisplayName,\n    SUM(T3.ViewCount) AS total_views\nFROM \n    users T1\nINNER JOIN \n    postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN \n    posts T3 ON T2.PostId = T3.Id\nWHERE \n    T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder'\nGROUP BY \n    T1.DisplayName\nORDER BY \n    total_views DESC\nLIMIT 1",
            "SELECT T1.DisplayName\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nWHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder'\nGROUP BY T1.DisplayName\nORDER BY SUM(T3.ViewCount) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.DisplayName\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nWHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder'\nGROUP BY T1.DisplayName\nORDER BY SUM(T3.ViewCount) DESC\nLIMIT 1"
        ]
    },
    "1021": {
        "question": "What is the height of the tallest player? Indicate his name.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "amends": [
            "Do select only `player_name` instead of including `MAX(height)` with an alias. Do use `ORDER BY height DESC` instead of an aggregate function to find the maximum. Do add `LIMIT 1` to return only the tallest player instead of potentially multiple rows. Do remove the unnecessary aggregation and column selection that would return incorrect results when trying to identify the tallest player by name."
        ],
        "rules": [
            "1) When the question asks for the tallest player's height and name: use ORDER BY height DESC to rank players by height in descending order instead of using aggregate functions. 2) When identifying the single tallest player: add LIMIT 1 to return only the top-ranked player instead of potentially multiple rows. 3) When selecting output columns for tallest player information: include only player_name instead of including MAX(height) with an alias. 4) Output columns (ordered): player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, MAX(height) AS tallest_height FROM Player;",
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;"
        ]
    },
    "676": {
        "question": "Please list all display names of users who are adults.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65",
        "amends": [],
        "rules": [
            "adults refer to users where Age BETWEEN 19 and 65;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65;"
        ],
        "rule_sql": []
    },
    "954": {
        "question": "Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.",
        "db_id": "formula_1",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.raceId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009",
        "amends": [],
        "rules": [
            "from 2007 to 2009 refers to year between 2007 and 2009; race completion refers to time is not null; percentage = Divide(COUNT(DriverID where time is not null and year between 2007 and 2009),Count (DriverID where year between 2007 and 2009))*100; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN r.time IS NOT NULL THEN 1 END) * 100.0 / COUNT(*)) AS race_completion_percentage\nFROM \n    results r\nJOIN \n    drivers d ON r.driverId = d.driverId\nJOIN \n    races rc ON r.raceId = rc.raceId\nWHERE \n    d.nationality = 'Japanese'\n    AND rc.year BETWEEN 2007 AND 2009;"
        ],
        "rule_sql": []
    },
    "1170": {
        "question": "How many patients hadn't undergone a medical examination until at least a year following their initial hospital visit?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '+' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.`First Date`) >= 1",
        "amends": [
            "Do add `T1.Admission = '+'` filter in the WHERE clause instead of omitting it. Do use `INNER JOIN` with explicit `AS` aliases `T1` and `T2` instead of simple `JOIN` with aliases `p` and `e`. Do keep the same join condition `T1.ID = T2.ID` instead of changing it. Do maintain the same date difference calculation `STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.`First Date`) >= 1` instead of altering it. The amended query now correctly filters for patients with Admission status '+' while preserving the examination date difference logic, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for patients who hadn't undergone examination until at least a year after initial visit: filter for patients where the year difference between Examination Date and First Date is at least 1. 2) When filtering patient records: include only patients with Admission status exactly equal to '+'. 3) When combining Patient and Examination tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 4) When counting distinct patients: use T1.ID as the counting key. 5) Output columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE (strftime('%Y', e.`Examination Date`) - strftime('%Y', p.`First Date`)) >= 1;",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '+'\nAND STRFTIME('%Y', T2.\"Examination Date\") - STRFTIME('%Y', T1.\"First Date\") >= 1"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '+' \nAND julianday(T2.\"Examination Date\") - julianday(T1.\"First Date\") >= 365"
        ]
    },
    "374": {
        "question": "How many black border cards are only available on mtgo?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE availability = 'mtgo' AND borderColor = 'black'",
        "amends": [],
        "rules": [
            "black border card refers to borderColor = black; available on mtgo refers to availability = mtgo;\n\nadd quotes for string = 'black' and = 'mtgo'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo';"
        ],
        "rule_sql": []
    },
    "781": {
        "question": "Provide the heights of the heroes whose eye colours are amber.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'",
        "amends": [],
        "rules": [
            "heights of the heroes refers to height_cm; eye colours are amber refers to colour.colour = 'Amber' WHERE eye_colour_id = colour.id;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero.height_cm FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'Amber';"
        ],
        "rule_sql": []
    },
    "1157": {
        "question": "For patients with severe degree of thrombosis, list their ID, sex and disease the patient is diagnosed with.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 2",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `T1.ID`, `T1.SEX`, and `T1.Diagnosis` instead of `P.ID`, `P.SEX`, and `COALESCE(E.Diagnosis, P.Diagnosis) AS Disease`. Do use `INNER JOIN` instead of `LEFT JOIN` to only include patients with matching examination records. Do join on `T1.ID = T2.ID` instead of `P.ID = E.ID` with consistent table aliasing. Do filter on `T2.Thrombosis = 2` instead of `E.Thrombosis = 2` with proper table reference. Do remove the `COALESCE` function and directly use `T1.Diagnosis` instead of attempting to merge diagnosis sources. The amended query now correctly returns distinct patients with thrombosis examination results, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for patients with severe thrombosis: filter rows where T2.Thrombosis equals 2 exactly. 2) When combining Patient and Examination tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match). 3) When selecting patient information: include T1.ID, T1.SEX, and T1.Diagnosis as output columns. 4) When eliminating duplicate patient records: use distinct selection to return unique rows. 5) When handling diagnosis information: use T1.Diagnosis directly instead of attempting to merge from multiple sources. Output columns (ordered): T1.ID, T1.SEX, T1.Diagnosis"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, P.SEX, COALESCE(E.Diagnosis, P.Diagnosis) AS Disease\nFROM Patient P\nLEFT JOIN Examination E ON P.ID = E.ID\nWHERE E.Thrombosis = 2;",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis\nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.Thrombosis = 2"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis\nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.Thrombosis = 2"
        ]
    },
    "977": {
        "question": "From race no. 50 to 100, how many finishers have been disqualified?",
        "db_id": "formula_1",
        "ground_truth": "SELECT SUM(IIF(time IS NOT NULL, 1, 0)) FROM results WHERE statusId = 2 AND raceID < 100 AND raceId > 50",
        "amends": [],
        "rules": [
            "disqualified refers to statusID = 2, finisher refers to time! = null; race no. refers to raceId; raceId > 50 and raceId < 100;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS disqualified_finishers\nFROM results\nWHERE raceId > 50 AND raceId < 100\n  AND time IS NOT NULL\n  AND statusId = 2;"
        ],
        "rule_sql": []
    },
    "467": {
        "question": "How many cards are there in the base set of \"Hauptset Zehnte Edition\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "amends": [],
        "rules": [
            "\"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; number of cards refers to baseSetSize"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.baseSetSize \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Hauptset Zehnte Edition';"
        ],
        "rule_sql": []
    },
    "612": {
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'Pierre';"
        ],
        "rule_sql": []
    },
    "187": {
        "question": "How many clients who choose statement of weekly issuance are Owner?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'",
        "amends": [
            "Do count `T2.account_id` instead of `COUNT(DISTINCT c.client_id)` to track accounts rather than clients. Do use `INNER JOIN` between `account` and `disp` instead of joining through `client` table, removing the unnecessary `client` table entirely. Do reference `T1.frequency` from the `account` table instead of `a.frequency` with different alias. Do filter for `T2.type = 'OWNER'` instead of `d.type = 'Owner'` with uppercase consistency. Do remove the `AS client_count` alias instead of keeping it since the result is an unlabeled count. The amended query now correctly counts accounts with weekly frequency statements owned by their primary holders, matching the intended behavior.",
            "Do use the literal string `'POPLATEK TYDNE'` for the frequency filter instead of `'WEEKLY ISSUANCE'` to match the correct business requirement. The amended query now correctly counts account owners with the specified frequency, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for count of accounts with specific frequency and type: count the number of rows using the exact token T2.account_id. 2) When combining account and disp tables: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match). 3) When filtering for frequency: use the exact literal 'POPLATEK TYDNE' with the exact token T1.frequency. 4) When filtering for type: use the exact literal 'OWNER' with the exact token T2.type. 5) When the result is an unlabeled count: do not add an alias to the count result. Output columns (ordered): count",
            "1) When the question asks for clients who choose statement of weekly issuance: filter T1.frequency to exactly match the literal string 'POPLATEK TYDNE'. 2) When the question asks for clients who are Owner: filter T2.type to exactly match the literal string 'OWNER'. 3) When counting clients: count using T2.account_id as the counting key. 4) When combining account T1 and disp T2: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match). 5) Output columns (ordered): COUNT(T2.account_id)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS client_count\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'Owner';",
            "SELECT COUNT(T2.account_id)\nFROM account T1\nINNER JOIN disp T2 ON T1.account_id = T2.account_id\nWHERE T1.frequency = 'WEEKLY ISSUANCE'\nAND T2.type = 'OWNER'",
            "SELECT COUNT(T2.account_id) \nFROM account T1 \nINNER JOIN disp T2 ON T1.account_id = T2.account_id \nWHERE T1.frequency = 'POPLATEK TYDNE' \nAND T2.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.account_id) FROM account T1 INNER JOIN disp T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'"
        ]
    },
    "1103": {
        "question": "What was the overall rating for Aaron Mooy on 2016/2/4?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-02-04' AND t1.player_name = 'Aaron Mooy'",
        "amends": [],
        "rules": [
            "Aaron Mooy refers to player_name = 'Aaron Mooy'; on 2016/2/4 refers to date LIKE '2016-02-04%';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pa.overall_rating \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Aaron Mooy' \nAND pa.date LIKE '2016-02-04%';"
        ],
        "rule_sql": []
    },
    "1019": {
        "question": "What is the average lap time in milliseconds of all the lap records set on the various circuits in Italy?",
        "db_id": "formula_1",
        "ground_truth": "SELECT CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy'",
        "amends": [],
        "rules": [
            "average = AVG(milliseconds)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(l.milliseconds) AS average_lap_time_ms\nFROM lapTimes l\nJOIN races r ON l.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Italy';"
        ],
        "rule_sql": []
    },
    "1284": {
        "question": "For the patient with the highest lactate dehydrogenase in the normal range, when was his or her data first recorded?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH < 500 ORDER BY T2.LDH ASC LIMIT 1",
        "amends": [
            "Do use a direct `INNER JOIN` between `Patient` and `Laboratory` tables instead of a subquery with aggregation. Do filter `LDH < 500` in the `WHERE` clause instead of within a subquery. Do order by `LDH ASC` instead of ordering by `MaxLDH DESC` in a subquery. Do remove the `GROUP BY` and `MAX` aggregation instead of including them unnecessarily. Do reference the joined table directly as `T2.LDH` instead of creating an alias `max_ldh`. The amended query now correctly finds the patient with the lowest LDH value below 500 instead of the highest, matching the RIGHT_SQL's behavior.",
            "Do use `T1.`First Date`` as the selected column instead of `p.ID, MIN(l.Date)` to return only the first date instead of both ID and a minimum date. Do remove the aggregation `MIN()` and alias `first_recorded_date` instead of keeping them since no grouping is needed. Do change table alias `p` to `T1` and `l` to `T2` instead of keeping the original aliases for consistency. Do use backticks around `First Date` instead of unquoted identifiers to handle potential reserved words or spaces. Do move the date selection directly to the SELECT list instead of using an aggregate function with grouping semantics. Do keep the `INNER JOIN` on `T1.ID = T2.ID` instead of changing the join type or condition. Do maintain the `WHERE T2.LDH < 500` filter instead of altering the predicate. Do preserve the `ORDER BY T2.LDH ASC` and `LIMIT 1` instead of modifying the sorting or limiting logic. The amended query now correctly returns only the earliest date for patients with LDH under 500 instead of attempting to aggregate without proper grouping."
        ],
        "rules": [
            "1) When the question asks for the patient with the highest lactate dehydrogenase in the normal range: filter Laboratory records where LDH < 500 and order by LDH in descending order to find the highest value within the normal range.\n2) When combining Patient and Laboratory tables: link rows where Patient.ID equals Laboratory.ID using an inner join to ensure only matching patient-laboratory pairs are considered.\n3) When retrieving the first recorded date for a patient: select the First Date column from the Patient table for the identified patient.\n4) When ordering laboratory values: use LDH directly without aggregation since we need the individual measurement values rather than aggregated maximums.\n5) When filtering for normal range values: use the exact literal condition LDH < 500 as specified in the normal range definition.\nOutput columns (ordered): T1.\"First Date\"",
            "1) When the question asks for the first recorded date of a patient: use T1.\"First Date\" as the output column instead of aggregating with MIN() or including patient ID.\n2) When joining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When filtering for patients with lactate dehydrogenase in the normal range: include only rows where T2.LDH < 500.\n4) When finding the patient with the highest lactate dehydrogenase: order rows by T2.LDH in ascending direction and keep only the first row.\n5) When handling identifiers with spaces: use double quotes around \"First Date\" instead of backticks or unquoted forms.\n6) When referring to table roles: use T1 for Patient table and T2 for Laboratory table consistently throughout.\nOutput columns (ordered): T1.\"First Date\""
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.`First Date`\nFROM Patient p\nJOIN (\n    SELECT l.ID, MAX(l.LDH) AS MaxLDH\n    FROM Laboratory l\n    WHERE l.LDH < 500\n    GROUP BY l.ID\n    ORDER BY MaxLDH DESC\n    LIMIT 1\n) max_ldh ON p.ID = max_ldh.ID;",
            "SELECT p.ID, MIN(l.Date) as first_recorded_date\nFROM Patient p\nINNER JOIN Laboratory l ON p.ID = l.ID\nWHERE l.LDH < 500\nORDER BY l.LDH ASC\nLIMIT 1;",
            "SELECT T1.`First Date`\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH < 500\nORDER BY T2.LDH ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.\"First Date\"\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH < 500\nORDER BY T2.LDH DESC\nLIMIT 1"
        ]
    },
    "90": {
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "amends": [],
        "rules": [
            "A3 contains the data of region"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS eligible_accounts\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE d.A3 = 'Prague';"
        ],
        "rule_sql": []
    },
    "933": {
        "question": "What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.positionOrder FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.name = 'Chinese Grand Prix' AND T1.year = 2008",
        "amends": [],
        "rules": [
            "Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; final rank refers to positionOrder; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.positionOrder \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' \nAND ra.year = 2008 AND ra.name = 'Chinese Grand Prix';"
        ],
        "rule_sql": []
    },
    "843": {
        "question": "List the hero ID of superheroes have intellegence as their power.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.hero_id FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Intelligence'",
        "amends": [],
        "rules": [
            "hero ID refers to superhero.id; have intelligence as their power refers to power_name = 'Intelligence';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hp.hero_id\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Intelligence';"
        ],
        "rule_sql": []
    },
    "27": {
        "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
        "amends": [
            "Do use `LEFT JOIN` instead of `JOIN` to preserve all schools records regardless of SAT score availability. Do reference tables with aliases `T1` and `T2` instead of `s` and `sc` for clarity. Do remove the column aliases \"School Name\", \"Average Writing Score\", and \"Communication Number\" instead of keeping them. Do change the date filter to use `strftime('%Y', T2.OpenDate) > '1991'` and `strftime('%Y', T2.ClosedDate) < '2000'` instead of comparing full date strings to handle year comparisons properly. Do remove the `AND sc.AvgScrWrite IS NOT NULL` condition instead of keeping it to include all schools regardless of whether they have SAT scores. Do remove the `ORDER BY` clause instead of including it. The amended query now correctly returns all schools meeting the date criteria while preserving those without SAT scores through the left join.",
            "Do use `schools AS T2` as the left table in the `LEFT JOIN` instead of `satscores T1` to preserve all schools records. Do reverse the join condition to `T2.CDSCode = T1.cds` instead of `T1.cds = T2.CDSCode` for proper left join semantics. Do remove the unnecessary table alias prefixes from the SELECT list since they are unambiguous. The amended query now correctly returns all schools meeting the date criteria while preserving those without matching SAT scores through the left join, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining schools and SAT scores tables: use a left join to preserve all school records regardless of SAT score availability, linking rows where T1.CDSCode equals T2.cds.\n2) When filtering by opening year: include schools where the year extracted from T1.OpenDate is greater than '1991'.\n3) When filtering by closing year: include schools where the year extracted from T1.ClosedDate is less than '2000'.\n4) When handling missing SAT scores: do not filter out schools that have null values for T2.AvgScrWrite.\n5) When selecting output columns: include T1.School, T2.AvgScrWrite, and T1.Phone without applying column aliases.\n6) When ordering results: do not apply any sorting to the output.\nOutput columns (ordered): T1.School, T2.AvgScrWrite, T1.Phone",
            "1) When the question asks for school names and communication numbers: include \"School\" and \"Phone\" columns from the schools table (T2).\n2) When the question asks for average writing scores: include \"AvgScrWrite\" column from the satscores table (T1).\n3) When combining schools and satscores data: link rows where T2.CDSCode equals T1.cds to preserve all school records (left join semantics).\n4) When filtering schools by opening date after 1991: include schools where the year component of OpenDate is greater than '1991'.\n5) When filtering schools by closing date before 2000: include schools where the year component of ClosedDate is less than '2000'.\n6) When the question uses \"or\" logic for date conditions: include schools that satisfy either the opening date condition or the closing date condition.\n7) Output columns (ordered): School, AvgScrWrite, Phone"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.School AS \"School Name\", sc.AvgScrWrite AS \"Average Writing Score\", s.Phone AS \"Communication Number\"\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE (s.OpenDate > '1991-12-31' OR s.ClosedDate < '2000-01-01')\nAND sc.AvgScrWrite IS NOT NULL\nORDER BY s.School;",
            "SELECT T2.School, T1.AvgScrWrite, T2.Phone\nFROM satscores T1\nLEFT JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
            "SELECT T2.School, T1.AvgScrWrite, T2.Phone\nFROM schools AS T2\nLEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds\nWHERE (strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000')"
        ],
        "rule_sql": [
            "SELECT T1.School, T2.AvgScrWrite, T1.Phone \nFROM schools T1 \nLEFT JOIN satscores T2 ON T1.CDSCode = T2.cds \nWHERE (strftime('%Y', T1.OpenDate) > '1991' OR strftime('%Y', T1.ClosedDate) < '2000')"
        ]
    },
    "1407": {
        "question": "Among the budgets for Advertising, list out top three which have the most budgeted amount?",
        "db_id": "student_club",
        "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3",
        "amends": [
            "Do select only `budget_id` instead of all columns with `*` to return specific identifiers rather than the full row contents. The amended query now matches RIGHT_SQL's behavior by returning only the budget identifiers for the top 3 advertisement budgets by amount.",
            "Do filter on `category = 'Advertisement'` instead of `category = 'Advertising'` in the WHERE clause, correcting the category value to match the intended business logic. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for top three budgets by amount: rank rows by amount in descending order and keep the first 3 rows.\n2) When the question specifies budgets for Advertising: filter rows where category equals 'Advertisement' exactly.\n3) When selecting output columns: return only budget_id instead of all columns.\nOutput columns (ordered): budget_id",
            "1) When the question mentions \"top three\" by budgeted amount: rank rows by amount in descending order and keep the first 3 rows.\n2) When filtering for a specific category: use the exact literal value 'Advertisement' for the category column.\n3) When selecting output columns: include budget_id in the results.\n4) Output columns (ordered): budget_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3;",
            "SELECT budget_id FROM budget WHERE category = 'Advertising' ORDER BY amount DESC LIMIT 3;",
            "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3"
        ]
    },
    "690": {
        "question": "Identify the latest badge awarded to the user with the display name Emmett.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Emmett' ORDER BY T1.Date DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the latest badge refers to Name FROM badges where MAX(Date);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.DisplayName = 'Emmett'\nORDER BY b.Date DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1007": {
        "question": "What was the longest time that Lewis Hamilton had spent at a pit stop?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.duration DESC LIMIT 1",
        "amends": [],
        "rules": [
            "longest time refes to MAX(duration);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(p.duration) AS longest_pit_stop_time\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';"
        ],
        "rule_sql": []
    },
    "319": {
        "question": "How many elements are contained in bond_id TR001_3_4?",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(DISTINCT T1.element) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_3_4'",
        "amends": [],
        "rules": [
            "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a1.element) AS element_count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_3_4';"
        ],
        "rule_sql": []
    },
    "659": {
        "question": "How many tags have post count between 5,000 to 7,000?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM tags WHERE Count BETWEEN 5000 AND 7000",
        "amends": [],
        "rules": [
            "post count between 5,000 to 7,000 refers to Count BETWEEN 5000 and 7000;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000;"
        ],
        "rule_sql": []
    },
    "37": {
        "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.Street, s.City, s.State, s.Zip\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.NumTstTakr > 0\nORDER BY (sc.NumGE1500 * 1.0 / sc.NumTstTakr) ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "322": {
        "question": "What is the element of toxicology for the atom with the ID of TR000_1?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.element FROM atom AS T WHERE T.atom_id = 'TR000_1'",
        "amends": [],
        "rules": [
            "atom with ID refers to atom_id; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT element FROM atom WHERE atom_id = 'TR000_1';"
        ],
        "rule_sql": []
    },
    "881": {
        "question": "For the drivers who took part in the race in 1983/7/16, what's their race completion rate?",
        "db_id": "formula_1",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'",
        "amends": [],
        "rules": [
            "DIVIDE(COUNT(driverid when time has value ), (COUNT(driverid )) as percentage; in 1983/7/16 refers to when date = '1983-07-16'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH race_on_date AS (\n    SELECT raceId FROM races WHERE date = '1983-07-16'\n),\ndriver_participation AS (\n    SELECT r.driverId, s.status\n    FROM results r\n    JOIN race_on_date rod ON r.raceId = rod.raceId\n    JOIN status s ON r.statusId = s.statusId\n),\ncompletion_stats AS (\n    SELECT \n        COUNT(*) AS total_drivers,\n        SUM(CASE WHEN status = 'Finished' THEN 1 ELSE 0 END) AS completed_drivers\n    FROM driver_participation\n)\nSELECT \n    (completed_drivers * 100.0 / total_drivers) AS completion_rate_percentage\nFROM completion_stats;"
        ],
        "rule_sql": []
    },
    "1400": {
        "question": "Among all events hold by the Student_Club in 2019, find the percentage share of events related to 'Community Service'",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(type) FROM event WHERE SUBSTR(event_date, 1, 4) = '2019'",
        "amends": [],
        "rules": [
            "DIVIDE(SUM(type = 'Community Service'), COUNT(event_id)) * 100 where event_date BETWEEN' 2019-01-01' and '2019-12-31'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN type = 'Community Service' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_share\nFROM \n    event\nWHERE \n    strftime('%Y', event_date) = '2019';"
        ],
        "rule_sql": []
    },
    "1306": {
        "question": "How many patients diagnosed with SLE have a normal white blood cell level?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.WBC BETWEEN 3.5 AND 9",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than distinct patient IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do reference `T2.WBC BETWEEN 3.5 AND 9` instead of `L.WBC BETWEEN 3.5 AND 9.0` to use integer comparison without decimal precision. The amended query now correctly counts all patient records meeting the diagnostic and laboratory criteria without unnecessary distinct filtering."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) to count all matching rows rather than distinct patient IDs.\n2) When joining tables: use INNER JOIN explicitly for clarity between T1 and T2.\n3) When using table aliases: use T1 for Patient table and T2 for Laboratory table consistently.\n4) When filtering by white blood cell level: use T2.WBC BETWEEN 3.5 AND 9 for integer comparison without decimal precision.\n5) When filtering by diagnosis: use T1.Diagnosis = 'SLE' with exact literal value 'SLE'.\n6) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\nOutput columns (ordered): COUNT(T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'SLE' AND L.WBC BETWEEN 3.5 AND 9.0;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' \nAND T2.WBC BETWEEN 3.5 AND 9"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' \nAND T2.WBC BETWEEN 3.5 AND 9"
        ]
    },
    "907": {
        "question": "List all races in 2017 and the hosting country order by date of the event.",
        "db_id": "formula_1",
        "ground_truth": "SELECT DISTINCT T2.name, T1.country FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2017 ORDER BY T2.date ASC",
        "amends": [
            "Do select `T2.name` and `T1.country` instead of `r.name AS race_name`, `c.country`, and `r.date`. Do use `DISTINCT` instead of omitting it. Do reference tables as `circuits AS T1` and `races AS T2` instead of `races r` and `circuits c`. Do perform `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of `JOIN` on `r.circuitId = c.circuitId`. Do filter on `T2.year = 2017` instead of `r.year = 2017`. Do order by `T2.date ASC` instead of `r.date`. The amended query now correctly returns distinct circuit names with their countries for 2017 races in date order.",
            "Do remove `T2.date` from the SELECT list instead of including it, as the DISTINCT operation should only apply to the combination of race names and countries. Do keep the `INNER JOIN` on `T2.circuitID = T1.circuitId` unchanged. Do maintain the WHERE filter on `T2.year = 2017` unchanged. Do preserve the ORDER BY `T2.date ASC` clause despite removing the column from the SELECT list, as this ordering is still valid and meaningful for the result set. The amended query now correctly returns distinct race names with their corresponding countries for the 2017 season, ordered chronologically by race date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for races and hosting countries: select T2.name and T1.country as output columns. 2) When listing distinct values: use DISTINCT to return unique combinations of the selected columns. 3) When combining circuits and races tables: link rows where T2.circuitID = T1.circuitId and keep only matching pairs (inner match). 4) When filtering by year 2017: include only rows where T2.year = 2017. 5) When ordering by date of the event: sort results by T2.date in ascending order. 6) Output columns (ordered): T2.name, T1.country",
            "1) When the question asks for races and hosting countries: select distinct combinations of T2.name and T1.country. 2) When filtering for a specific year (2017): include only rows where T2.year equals 2017. 3) When ordering by date of the event: sort the results by T2.date in ascending order. 4) When joining circuits and races tables: link rows where T2.circuitId equals T1.circuitId using an inner match. 5) When using DISTINCT on multiple columns: ensure the combination of T2.name and T1.country is unique in the result set. 6) When ordering by a column not in the output: maintain the T2.date column for sorting purposes even though it's not displayed in the final results. Output columns (ordered): T2.name, T1.country"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name AS race_name, c.country, r.date FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2017 ORDER BY r.date;",
            "SELECT DISTINCT T2.name, T1.country, T2.date\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T2.year = 2017\nORDER BY T2.date ASC;",
            "SELECT DISTINCT T2.name, T1.country\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T2.year = 2017\nORDER BY T2.date ASC"
        ],
        "rule_sql": [
            "SELECT DISTINCT races.name, circuits.country\nFROM races\nINNER JOIN circuits ON races.circuitId = circuits.circuitId\nWHERE races.year = 2017\nORDER BY races.date ASC;"
        ]
    },
    "1057": {
        "question": "Calculate the average home team goal in the 2010/2011 season in the country of Poland.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Poland' AND t2.season = '2010/2011'",
        "amends": [],
        "rules": [
            "average home team goal = AVG(home_team_goal)= SUM(home_team_goal) / COUNT(DISTINCT Match.id) WHERE name = 'Poland' and season = '2010/2011';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(home_team_goal) AS average_home_team_goal\nFROM \"Match\"\nWHERE season = '2010/2011'\nAND country_id = (SELECT id FROM \"Country\" WHERE name = 'Poland');"
        ],
        "rule_sql": []
    },
    "531": {
        "question": "Which user has a higher reputation, Harlan or Jarrod Dixon?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = ( SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') )",
        "amends": [
            "Do remove `Reputation` from the SELECT list instead of including it, and do add a WHERE filter with `Reputation = (SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon'))` instead of the simple `ORDER BY Reputation DESC`, which only sorted results rather than filtering to the maximum reputation. Do remove the `ORDER BY Reputation DESC` clause instead of keeping it, as the subquery-based filtering now ensures only the user(s) with maximum reputation are returned. The amended query now correctly identifies and returns only the user(s) with the highest reputation among those specified, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the user with higher reputation between specific names: filter to only include users where DisplayName is exactly 'Harlan' or 'Jarrod Dixon'.\n2) When comparing reputation values between specific users: find the maximum Reputation value among the specified users and return only users matching that maximum value.\n3) When outputting results for reputation comparison: include only the DisplayName column to show which user(s) have the highest reputation.\n4) Output columns (ordered): DisplayName"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DisplayName, Reputation FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') ORDER BY Reputation DESC;",
            "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = (SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon'))"
        ],
        "rule_sql": [
            "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') ORDER BY Reputation DESC LIMIT 1;"
        ]
    },
    "1159": {
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
        "amends": [],
        "rules": [
            "albumin level lower than 3.5 refers to ALB < 3.5;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, p.SEX, p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.ALB < 3.5;"
        ],
        "rule_sql": []
    },
    "1443": {
        "question": "Give the event ID, location, and status of events conducted from November 2019 to March 2020.",
        "db_id": "student_club",
        "ground_truth": "SELECT event_id, location, status FROM event WHERE date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-11-01' AND '2020-03-31'",
        "amends": [],
        "rules": [
            "event_date BETWEEN '2019-11-01' and '2020-03-31'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';"
        ],
        "rule_sql": []
    },
    "686": {
        "question": "Identify the total number of posts with views above average.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "amends": [
            "Do select `Id` instead of `COUNT(*) AS TotalPostsAboveAverageViews` to return individual post identifiers rather than an aggregate count. Do remove the `COUNT` aggregation and alias entirely instead of including them. Do keep the same `FROM posts` source table and `WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts)` filter condition unchanged as they correctly identify posts with above-average view counts. The amended query now returns specific post IDs that meet the criteria rather than just counting them, matching the RIGHT_SQL's behavior of retrieving individual records."
        ],
        "rules": [
            "1) When the question asks for posts with views above average: filter rows from the posts table where ViewCount is greater than the average ViewCount from all posts. 2) When the question asks to identify posts rather than count them: return the individual Id values instead of performing aggregation. 3) When computing the average view count for comparison: calculate the average of ViewCount from all posts in the table. 4) Output columns (ordered): Id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS TotalPostsAboveAverageViews\nFROM posts\nWHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
            "SELECT Id FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts)"
        ],
        "rule_sql": [
            "SELECT Id FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts) ORDER BY Id;"
        ]
    },
    "302": {
        "question": "Name the elements that comprise the atoms of bond TR001_2_4.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_2_4'",
        "amends": [
            "Do select only `T1.element` instead of selecting both `a1.element` and `a2.element`. Do use `INNER JOIN` with `T1.atom_id = T2.atom_id` instead of joining twice with `c.atom_id = a1.atom_id` and `c.atom_id2 = a2.atom_id`. Do remove the second table alias `a2` and the second join condition instead of including them. Do keep the `WHERE` filter on `T2.bond_id` instead of changing it. The amended query now correctly returns only the elements from one side of the connection rather than attempting to return elements from both connected atoms, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for elements of a specific bond: filter rows where T2.bond_id equals the exact literal 'TR001_2_4'. 2) When combining the connected and atom tables: link rows where T1.atom_id equals T2.atom_id exactly and keep only matching pairs (inner match). 3) When selecting elements from a bond connection: output only the element from the first atom table (T1.element) rather than elements from both connected atoms. Output columns (ordered): T1.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a1.element, a2.element\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_2_4';",
            "SELECT T1.element \nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id = 'TR001_2_4'"
        ],
        "rule_sql": [
            "SELECT T1.element\nFROM connected T2\nJOIN atom T1 ON T2.atom_id = T1.atom_id\nWHERE T2.bond_id = 'TR001_2_4'\nGROUP BY T1.element"
        ]
    },
    "606": {
        "question": "List out the name of badges that users obtained on 7/19/2010 7:39:08 PM.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0'",
        "amends": [],
        "rules": [
            "on 7/19/2010 7:39:08 PM refers to Date = '2010-07-19 19:39:08.0'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0';"
        ],
        "rule_sql": []
    },
    "1041": {
        "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
        "amends": [
            "Do use a single query with subquery instead of CTEs, and move the date filter from the CTE to the main WHERE clause. Do change the join condition from `JOIN AvgChanceCreation ac ON ti.chanceCreationPassing < ac.avg_chance_creation` to a subquery comparison `t4.chanceCreationPassing < (SELECT ...)` instead of joining on a CTE. Do add the correct average calculation using `CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)` instead of simple `AVG(chanceCreationPassing)` to handle potential division issues. Do change the date filtering from range comparison `date >= '2014-01-01 00:00:00' AND date <= '2014-12-31 23:59:59'` to year extraction `SUBSTR(t2.date, 1, 4) = '2014'` instead of exact timestamp matching. Do remove the explicit column `ti.chanceCreationPassing` from SELECT list instead of including it, keeping only `t3.team_long_name`. Do maintain the same `ORDER BY t4.chanceCreationPassing DESC` instead of changing the sort order. The amended query now correctly calculates the average chance creation for 2014 teams with normal dribbling and filters teams below that average.",
            "Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference `Team_Attributes` as `t4` in the main query instead of `t2` and `Team` as `t3` instead of maintaining the original aliases. Do remove the `SUBSTR(t2.date, 1, 4) = '2014'` filter from the main WHERE clause instead of keeping it, as the date filtering should only apply to the subquery. Do change the subquery to reference `Team` as `t1` and `Team_Attributes` as `t2` instead of `t4` and `t5` for consistency. Do use backticks around `date` column in the subquery instead of unquoted to handle reserved keywords. Do reference `t4.chanceCreationPassing` in the ORDER BY instead of `t2.chanceCreationPassing` to match the main query's table alias. The amended query now correctly filters teams based on 2014 average chance creation passing values while maintaining proper table references throughout."
        ],
        "rules": [
            "1) When the question asks for teams with normal build-up play dribbling class: filter rows where t2.buildUpPlayDribblingClass equals 'Normal' exactly. 2) When the question specifies the year 2014: extract the year from t2.date using SUBSTR(t2.date, 1, 4) and compare it to '2014' exactly. 3) When calculating average chance creation passing: compute the average using CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) to handle division properly. 4) When filtering teams with less than average chance creation passing: compare t4.chanceCreationPassing to the calculated average using a subquery comparison instead of joining. 5) When ordering results in descending order of chance creation passing: sort by t4.chanceCreationPassing in descending order. 6) When selecting output columns: include only t3.team_long_name instead of including the chance creation passing value. 7) When combining tables for team information: link rows where t4.team_api_id equals t3.team_api_id to get team names. Output columns (ordered): t3.team_long_name",
            "1) When the question mentions teams with normal build-up play dribbling class: filter rows where Team_Attributes.buildUpPlayDribblingClass equals 'Normal' exactly.\n2) When the question specifies the year 2014: filter rows where the first 4 characters of Team_attributes.`date` equal '2014' exactly.\n3) When the question asks for teams with less than average chance creation passing: compare Team_Attributes.chanceCreationPassing against the average value computed from teams meeting the same buildUpPlayDribblingClass and year conditions.\n4) When computing the average chance creation passing: calculate the sum of Team_Attributes.chanceCreationPassing divided by the count of Team_Attributes.id for rows meeting the buildUpPlayDribblingClass = 'Normal' and year = '2014' conditions.\n5) When the question asks for team names: output Team.team_long_name.\n6) When the question specifies descending order of chance creation passing: sort results by Team_Attributes.chanceCreationPassing in descending order.\n7) When combining Team_Attributes and Team tables: link rows where Team_Attributes.team_api_id equals Team.team_api_id exactly.\n8) Output columns (ordered): Team.team_long_name"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "WITH AvgChanceCreation AS (\n    SELECT AVG(chanceCreationPassing) AS avg_chance_creation\n    FROM Team_Attributes\n),\nTeamsIn2014 AS (\n    SELECT team_api_id, chanceCreationPassing\n    FROM Team_Attributes\n    WHERE buildUpPlayDribblingClass = 'Normal'\n    AND date >= '2014-01-01 00:00:00' AND date <= '2014-12-31 23:59:59'\n)\nSELECT t.team_long_name, ti.chanceCreationPassing\nFROM TeamsIn2014 ti\nJOIN Team t ON ti.team_api_id = t.team_api_id\nJOIN AvgChanceCreation ac ON ti.chanceCreationPassing < ac.avg_chance_creation\nORDER BY ti.chanceCreationPassing DESC;",
            "SELECT t3.team_long_name\nFROM Team_Attributes t2\nJOIN Team t3 ON t2.team_api_id = t3.team_api_id\nWHERE t2.buildUpPlayDribblingClass = 'Normal'\nAND SUBSTR(t2.date, 1, 4) = '2014'\nAND t2.chanceCreationPassing < (\n    SELECT CAST(SUM(t4.chanceCreationPassing) AS REAL) / COUNT(t4.id)\n    FROM Team_Attributes t4\n    JOIN Team t5 ON t4.team_api_id = t5.team_api_id\n    WHERE t4.buildUpPlayDribblingClass = 'Normal'\n    AND SUBSTR(t4.date, 1, 4) = '2014'\n)\nORDER BY t2.chanceCreationPassing DESC;",
            "SELECT t3.team_long_name\nFROM Team_Attributes t4\nINNER JOIN Team t3 ON t4.team_api_id = t3.team_api_id\nWHERE t4.buildUpPlayDribblingClass = 'Normal'\nAND t4.chanceCreationPassing < (\n    SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)\n    FROM Team t1\n    INNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id\n    WHERE t2.buildUpPlayDribblingClass = 'Normal'\n    AND SUBSTR(t2.`date`, 1, 4) = '2014'\n)\nORDER BY t4.chanceCreationPassing DESC;"
        ],
        "rule_sql": [
            "SELECT t.team_long_name\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE ta.buildUpPlayDribblingClass = 'Normal'\nAND SUBSTR(ta.date, 1, 4) = '2014'\nAND ta.chanceCreationPassing < (\n    SELECT CAST(SUM(ta2.chanceCreationPassing) AS REAL) / COUNT(ta2.id)\n    FROM Team_Attributes ta2\n    WHERE ta2.buildUpPlayDribblingClass = 'Normal'\n    AND SUBSTR(ta2.date, 1, 4) = '2014'\n)\nORDER BY ta.chanceCreationPassing DESC;"
        ]
    },
    "805": {
        "question": "List the full names of superheroes with missing weight.",
        "db_id": "superhero",
        "ground_truth": "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0)",
        "amends": [
            "Do add `DISTINCT` instead of omitting it to eliminate duplicate full names. Do add `full_name IS NOT NULL` filter instead of omitting it to exclude null names. Do move the weight condition to parentheses `(weight_kg IS NULL OR weight_kg = 0)` instead of `weight_kg = 0 OR weight_kg IS NULL` for equivalent but clearer logic. The amended query now correctly returns distinct non-null superhero names where weight is either null or zero, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"full names\" of superheroes: include the exact column token \"full_name\" in the output. 2) When filtering for missing weight: use the condition (weight_kg IS NULL OR weight_kg = 0) to capture both null and zero weight values. 3) When eliminating duplicate names: apply DISTINCT to the full_name column. 4) When excluding null names: add the filter full_name IS NOT NULL. 5) Output columns (ordered): full_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT full_name FROM superhero WHERE weight_kg = 0 OR weight_kg IS NULL;",
            "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0)"
        ],
        "rule_sql": [
            "SELECT DISTINCT full_name FROM superhero WHERE (weight_kg IS NULL OR weight_kg = 0) AND full_name IS NOT NULL ORDER BY full_name;"
        ]
    },
    "1341": {
        "question": "Give the location for \"Spring Budget Review\".",
        "db_id": "student_club",
        "ground_truth": "SELECT location FROM event WHERE event_name = 'Spring Budget Review'",
        "amends": [],
        "rules": [
            "'Spring Budget Review' is an event name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM event WHERE event_name = 'Spring Budget Review';"
        ],
        "rule_sql": []
    },
    "885": {
        "question": "State the name and date of the last round of race in year 1999.",
        "db_id": "formula_1",
        "ground_truth": "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the last round refers to max(round);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "627": {
        "question": "How many users were adult?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "amends": [],
        "rules": [
            "adult refers to user where Age BETWEEN 19 and 65;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS adult_users_count FROM users WHERE Age BETWEEN 19 AND 65;"
        ],
        "rule_sql": []
    },
    "888": {
        "question": "In which country was the first European Grand Prix hosted? Name the circuit and location.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.country, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix' ORDER BY T2.year ASC LIMIT 1",
        "amends": [
            "Do remove `c.name AS circuit_name` from the SELECT list instead of including it. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference tables with aliases `T1` and `T2` instead of single letters `c` and `r`. Do fix the join condition to `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId` to ensure proper column matching. The amended query now correctly retrieves only the country and location data for the European Grand Prix race while maintaining the same ordering and limiting behavior."
        ],
        "rules": [
            "1) When the question asks for the first occurrence of an event by year: order rows by year in ascending order and keep only the first row. 2) When filtering for a specific race name: include only rows where the race name exactly matches 'European Grand Prix' with exact case and spacing. 3) When combining the races table (T2) and circuits table (T1): link rows where T2.circuitID equals T1.circuitId and keep only matching pairs. 4) When the question asks for country, circuit, and location information: include T1.country, T1.name, and T1.location in the output. 5) When using table aliases: refer to the circuits table as T1 and the races table as T2 consistently. Output columns (ordered): T1.country, T1.name, T1.location"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.country, c.name AS circuit_name, c.location\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'European Grand Prix'\nORDER BY r.year ASC\nLIMIT 1;",
            "SELECT T1.country, T1.location\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T2.name = 'European Grand Prix'\nORDER BY T2.date\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.country, T1.name, T1.location\nFROM circuits T1\nJOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T2.name = 'European Grand Prix'\nORDER BY T2.year ASC\nLIMIT 1;"
        ]
    },
    "878": {
        "question": "Who was the driver that got the best lap time in the race No. 348? Give his full name.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.forename, T2.surname FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 348 ORDER BY T1.time ASC LIMIT 1",
        "amends": [
            "Do select `forename` and `surname` as separate columns instead of concatenating them with `|| ' ' ||` into a single `full_name` alias. Do use `INNER JOIN` instead of just `JOIN` for explicit clarity. Do reverse the join condition to `T2.driverId = T1.driverId` instead of `lt.driverId = d.driverId` while maintaining the same logical relationship. Do use table aliases `T1` and `T2` consistently throughout instead of mixing `lt`/`d` with full table names. The amended query now correctly returns separate name columns while maintaining the same join logic and result filtering behavior."
        ],
        "rules": [
            "1) When the question asks for a driver's full name: return forename and surname as separate columns instead of concatenating them into a single column.\n2) When joining lapTimes (T1) and drivers (T2) tables: link rows where T2.driverId = T1.driverId using an inner match.\n3) When filtering for race No. 348: include only rows where T1.raceId equals 348.\n4) When finding the best lap time: order rows by T1.time in ascending order and keep only the first row.\n5) Output columns (ordered): T2.forename, T2.surname"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name\nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nWHERE lt.raceId = 348\nORDER BY lt.time ASC\nLIMIT 1;",
            "SELECT T2.forename, T2.surname\nFROM lapTimes T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T1.raceId = 348\nORDER BY T1.milliseconds ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT d.forename, d.surname\nFROM lapTimes lt\nINNER JOIN drivers d ON d.driverId = lt.driverId\nWHERE lt.raceId = 348\nORDER BY lt.time ASC\nLIMIT 1;"
        ]
    },
    "324": {
        "question": "Find the percentage of atoms with single bond.",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond t",
        "amends": [],
        "rules": [
            "single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(bond_type = '-'), COUNT(bond_id)) as percentage"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN bond_type = '-' THEN 1 ELSE 0 END) * 100.0 / COUNT(bond_id)) AS percentage_single_bonds FROM bond;"
        ],
        "rule_sql": []
    },
    "692": {
        "question": "How long did it take the user, known by his or her display name 'Zolomon' to get the badge? Count from the date the user's account was created.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Date - T2.CreationDate FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'",
        "amends": [
            "Do use `T1.Date - T2.CreationDate` for date subtraction instead of `julianday(b.Date) - julianday(u.CreationDate)` with julianday conversion. Do use table aliases `T1` and `T2` instead of `b` and `u`. Do remove the explicit column aliases `BadgeName`, `BadgeDate`, `AccountCreationDate`, and `DaysToGetBadge` instead of keeping them. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do remove the `ORDER BY b.Date` clause instead of including it. The amended query now correctly performs direct date subtraction and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about a user with display name 'Zolomon': filter rows where T2.DisplayName equals 'Zolomon' exactly. 2) When combining badges and users tables: link rows where T1.UserId equals T2.Id and keep only matching pairs (inner match). 3) When calculating time between account creation and badge date: compute T1.Date minus T2.CreationDate directly without date conversion functions. 4) When the question asks for how long it took to get the badge: output only the date difference result without additional columns. 5) Output columns (ordered): T1.Date - T2.CreationDate"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    b.Name AS BadgeName, \n    b.Date AS BadgeDate, \n    u.CreationDate AS AccountCreationDate, \n    julianday(b.Date) - julianday(u.CreationDate) AS DaysToGetBadge\nFROM \n    badges b\nJOIN \n    users u ON b.UserId = u.Id\nWHERE \n    u.DisplayName = 'Zolomon'\nORDER BY \n    b.Date;",
            "SELECT T1.Date - T2.CreationDate FROM badges T1 INNER JOIN users T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'"
        ],
        "rule_sql": [
            "SELECT (b.Date - u.CreationDate) \nFROM badges b\nINNER JOIN users u ON b.UserId = u.Id\nWHERE u.DisplayName = 'Zolomon'"
        ]
    },
    "471": {
        "question": "What is the expansion type of the set \"Hauptset Zehnte Edition\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "amends": [],
        "rules": [
            "card set \"Hauptset Zehnte Edition\" refers to translation = ' Hauptset Zehnte Edition'; expansion type refers to type"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.type \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Hauptset Zehnte Edition';"
        ],
        "rule_sql": []
    },
    "1501": {
        "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT DISTINCT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Date = '201306'",
        "amends": [
            "Do add `T2.Country` instead of `g.Country` for the SELECT list. Do add `yearmonth AS T3` as an additional INNER JOIN source instead of omitting it. Do change the join condition to `T1.CustomerID = T3.CustomerID` instead of not having this join. Do change the WHERE filter to use `T3.Date = '201306'` instead of `strftime('%Y%m', t.Date) = '201306'`. Do remove the DISTINCT modifier instead of keeping it. The amended query now correctly filters by joining with the yearmonth table and using its Date column directly instead of applying string formatting functions to the transaction date."
        ],
        "rules": [
            "1) When the question asks for countries of gas stations: include T2.Country in the output columns. 2) When joining tables for transaction data: perform an inner join between T1 and T2 using T1.GasStationID = T2.GasStationID. 3) When filtering for transactions in June 2013: join with T3 (yearmonth table) using T1.CustomerID = T3.CustomerID and filter where T3.Date = '201306'. 4) When listing distinct values: do not apply DISTINCT modifier to the output. 5) Output columns (ordered): T2.Country"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE strftime('%Y%m', t.Date) = '201306';",
            "SELECT T2.Country\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Date = '201306'"
        ],
        "rule_sql": [
            "SELECT T2.Country \nFROM transactions_1k T1\nINNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN yearmonth T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Date = '201306'"
        ]
    },
    "1261": {
        "question": "How many patients with a normal RF don't have thrombosis?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND T1.Thrombosis = 0",
        "amends": [],
        "rules": [
            "normal RF refers to RF < 20; don't have thrombosis refers to Thrombosis = '0';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.RF < 20 AND E.Thrombosis = 0;"
        ],
        "rule_sql": []
    },
    "1020": {
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
        "amends": [
            "Do select only `player_api_id` instead of including `p.player_api_id`, `p.player_name`, and `pa.overall_rating`. Do query from `Player_Attributes` alone instead of joining `Player` with `Player_Attributes` on `p.player_api_id = pa.player_api_id`. Do remove the subquery that finds the maximum rating and instead use `ORDER BY overall_rating DESC LIMIT 1` to get the single highest-rated player. Do omit the `WHERE` clause entirely instead of filtering for maximum rating through a subquery comparison. The amended query correctly identifies the player with the highest overall rating by sorting and limiting rather than attempting to match all players with the maximum rating value, which could return multiple players if there are ties."
        ],
        "rules": [
            "1) When the question asks for the highest overall rating: rank rows by overall_rating in descending order and keep the first 1 row.\n2) When the question asks for a player's api id: output the player_api_id column.\n3) When querying for player ratings: use the Player_Attributes table alone instead of joining with Player table.\n4) When finding maximum values: use ordering and limiting instead of subqueries that could return multiple matching rows.\n5) Output columns (ordered): player_api_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_api_id, p.player_name, pa.overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);",
            "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;"
        ]
    },
    "810": {
        "question": "What is the race of the superhero with maximum attribute value?",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN race AS T3 ON T1.race_id = T3.id ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [],
        "rules": [
            "maximum attribute value refers to MAX(attribute_value);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.race\nFROM race r\nJOIN superhero s ON r.id = s.race_id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nWHERE ha.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute)\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "475": {
        "question": "How many cards in the set Coldsnap have a black border color?",
        "db_id": "card_games",
        "ground_truth": "SELECT SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "amends": [],
        "rules": [
            "card set Coldsnap refers to name = 'Coldsnap'; black border color refers to borderColor = 'black'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') \nAND borderColor = 'black';"
        ],
        "rule_sql": []
    },
    "1114": {
        "question": "What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Marko Arnautovic' AND SUBSTR(t2.`date`, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'",
        "amends": [
            "Do use `CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id)` instead of `AVG(overall_rating)` to ensure proper floating-point division. Do join `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id` instead of querying `Player_Attributes` directly with a subquery. Do filter on `t1.player_name = 'Marko Arnautovic'` in the main WHERE clause instead of using a subquery for player lookup. Do use `SUBSTR(t2.\"date\", 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'` instead of direct date comparison to handle datetime values properly. The amended query now correctly calculates the average rating by joining on the proper foreign key relationship and handling date formatting appropriately."
        ],
        "rules": [
            "1) When calculating an average that requires floating-point precision: use CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) instead of AVG(overall_rating). 2) When joining Player and Player_Attributes tables: use INNER JOIN with t1.player_fifa_api_id = t2.player_fifa_api_id as the join condition. 3) When filtering by player name: apply t1.player_name = 'Marko Arnautovic' directly in the main WHERE clause instead of using a subquery. 4) When comparing date values that may contain datetime formatting: use SUBSTR(t2.\"date\", 1, 10) BETWEEN '2007-02-22' AND '2016-04-21' to extract the date portion. 5) Output columns (ordered): CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_overall_rating"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Marko Arnautovic')\nAND date BETWEEN '2007-02-22' AND '2016-04-21';",
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_rating\nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\nWHERE t1.player_name = 'Marko Arnautovic'\nAND SUBSTR(t2.\"date\", 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_overall_rating\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\nWHERE t1.player_name = 'Marko Arnautovic'\nAND SUBSTR(t2.\"date\", 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'"
        ]
    },
    "1194": {
        "question": "What sex is the patient who in a medical examination was diagnosed with PSS and in a laboratory examination had a blood level of C-reactive protein de 2+, createnine 1 and LDH 123?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T3.ID = T2.ID WHERE T2.Diagnosis = 'PSS' AND T3.CRP = '2+' AND T3.CRE = 1.0 AND T3.LDH = 123",
        "amends": [],
        "rules": [
            "PSS' refers to diagnosis; blood level of C-reactive protein de 2+refers to CRP > 2; createnine 1 refers to CRE = 1; LDH 123 refers to LDH = 123"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.SEX\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nJOIN Laboratory l ON p.ID = l.ID\nWHERE e.Diagnosis = 'PSS'\nAND l.CRP = '2+'\nAND l.CRE = 1\nAND l.LDH = 123;"
        ],
        "rule_sql": []
    },
    "656": {
        "question": "Describe the display name of the parent ID for child post with the highest score.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts WHERE ParentId IS NOT NULL ORDER BY Score DESC LIMIT 1 )",
        "amends": [
            "Do use a subquery to select `OwnerUserId` from `posts` with `ParentId IS NOT NULL` ordered by `Score DESC` instead of joining `posts` to itself on `ParentId = Id`. Do then query `users` table for `DisplayName` where `Id` matches the subquery result instead of selecting `OwnerDisplayName` directly from the posts table. Do remove the self-join condition and WHERE filter on `ParentId` since these are handled in the subquery instead of applying them in the main query. Do change the output column to `DisplayName` from the users table instead of `OwnerDisplayName` from the posts table to ensure proper user identification. The amended query now correctly identifies the user with the highest-scoring post that has a parent, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the highest score among child posts: find the post with the maximum Score value where ParentId IS NOT NULL. 2) When identifying the user associated with a post: use the OwnerUserId from the posts table to match with Id in the users table. 3) When retrieving user display information: select DisplayName from the users table instead of OwnerDisplayName from the posts table. 4) When combining user information with post data: link posts and users where posts.OwnerUserId equals users.Id. 5) Output columns (ordered): users.DisplayName"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p2.OwnerDisplayName\nFROM posts p1\nJOIN posts p2 ON p1.ParentId = p2.Id\nWHERE p1.ParentId IS NOT NULL\nORDER BY p1.Score DESC\nLIMIT 1;",
            "SELECT u.DisplayName\nFROM users u\nWHERE u.Id = (\n    SELECT p.OwnerUserId\n    FROM posts p\n    WHERE p.ParentId IS NOT NULL\n    ORDER BY p.Score DESC\n    LIMIT 1\n);"
        ],
        "rule_sql": [
            "SELECT u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Id = (\n    SELECT ParentId\n    FROM posts\n    WHERE ParentId IS NOT NULL\n    ORDER BY Score DESC\n    LIMIT 1\n)"
        ]
    },
    "263": {
        "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "amends": [],
        "rules": [
            "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS chlorine_percentage\nFROM \n    atom a\nJOIN \n    molecule m ON a.molecule_id = m.molecule_id\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nWHERE \n    b.bond_type = '-';"
        ],
        "rule_sql": []
    },
    "1368": {
        "question": "What does the person with the phone number \"809-555-3360\" major in?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.phone = '809-555-3360'",
        "amends": [],
        "rules": [
            "major in refers to major_name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.phone = '809-555-3360';"
        ],
        "rule_sql": []
    },
    "307": {
        "question": "Name the atoms' elements that form bond TR000_2_3.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3'",
        "amends": [
            "Do select only `T2.element` instead of both `a1.element` and `a2.element` with aliases. Do use `INNER JOIN` with `atom AS T2` on `T1.atom_id = T2.atom_id` instead of joining two separate `atom` tables on different conditions. Do remove the second join to `atom a2` on `c.atom_id2 = a2.atom_id` instead of keeping it. Do use table aliases `T1` for `connected` and `T2` for `atom` instead of `c`, `a1`, and `a2`. Do keep the `WHERE` filter on `T1.bond_id = 'TR000_2_3'` unchanged. The amended query now correctly retrieves only the element from the single joined atom table instead of attempting to join two different atom records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for atoms' elements that form a specific bond: select only the element column from the atom table. 2) When joining the connected table with the atom table: use an inner join where connected.atom_id equals atom.atom_id. 3) When filtering for a specific bond ID: use the exact literal value 'TR000_2_3' with the correct case and formatting. 4) When assigning table aliases: use T1 for the connected table and T2 for the atom table. 5) Output columns (ordered): T2.element"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a1.element AS element1, a2.element AS element2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR000_2_3';",
            "SELECT T2.element \nFROM connected AS T1 \nINNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id \nWHERE T1.bond_id = 'TR000_2_3'"
        ],
        "rule_sql": [
            "SELECT T2.element FROM connected T1 INNER JOIN atom T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3'"
        ]
    },
    "191": {
        "question": "How many loan accounts are for pre-payment of duration of 24 months with weekly issuance of statement.",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.duration = 24 AND T1.frequency = 'POPLATEK TYDNE'",
        "amends": [],
        "rules": [
            "Frequency = 'POPLATEK TYDNE' referes to weekly statement"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS loan_account_count\nFROM loan\nJOIN account ON loan.account_id = account.account_id\nWHERE loan.duration = 24\nAND account.frequency = 'POPLATEK TYDNE';"
        ],
        "rule_sql": []
    },
    "726": {
        "question": "Rank heroes published by Marvel Comics by their height in descending order.",
        "db_id": "superhero",
        "ground_truth": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
        "amends": [
            "Do add `RANK() OVER (ORDER BY height_cm DESC) AS HeightRank` to the SELECT list instead of omitting this window function. Do use `INNER JOIN` instead of `JOIN` for explicit clarity, though both are equivalent. Do remove the table alias `s` from `superhero_name` and `height_cm` instead of keeping the aliased references. Do remove the explicit `ORDER BY s.height_cm DESC` clause instead of keeping it, as the window function's ORDER BY handles the ranking without needing a final result set sort. The amended query now correctly calculates rank positions for Marvel Comics superheroes by height without redundant sorting.",
            "Do remove `full_name` from the SELECT list instead of including it. Do remove the explicit ORDER BY clause at the end instead of keeping it, as the window function's ORDER BY already provides the necessary sorting. The amended query now correctly returns only the superhero name, height, and rank for Marvel Comics characters without redundant columns or duplicate sorting."
        ],
        "rules": [
            "1) When the question mentions \"rank\" and asks for ordering by a specific column: use a ranking function that orders by the exact column token (height_cm) in the required direction (DESC) to assign rank positions. 2) When joining tables to filter by publisher: use an INNER JOIN between superhero and publisher tables where publisher_id equals id, keeping only matching pairs. 3) When filtering for a specific publisher: include only rows where publisher_name equals exactly 'Marvel Comics' with the exact case and spacing. 4) When selecting output columns: include both the entity identifier (superhero_name) and the ranking column (height_cm) without table aliases. 5) When ranking is performed through a window function: do not include a separate ORDER BY clause for the final result set. 6) Output columns (ordered): superhero_name, height_cm, HeightRank",
            "1) When the question asks to rank heroes by height in descending order: use a ranking function that orders by height_cm in descending order and assign rank positions starting from 1 for the tallest.\n2) When the question specifies \"published by Marvel Comics\": filter rows where publisher.publisher_name equals exactly 'Marvel Comics'.\n3) When combining superhero and publisher tables: link rows where superhero.publisher_id equals publisher.id and keep only matching pairs (inner match).\n4) When the output should show only superhero name, height, and rank: exclude full_name and other columns from the result set.\n5) When using window functions for ranking: do not add an additional explicit ORDER BY clause at the query end to avoid redundant sorting.\nOutput columns (ordered): superhero_name, height_cm, HeightRank"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name, s.height_cm\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'Marvel Comics'\nORDER BY s.height_cm DESC;",
            "SELECT \n    superhero_name,\n    full_name,\n    height_cm,\n    RANK() OVER (ORDER BY height_cm DESC) AS HeightRank\nFROM \n    superhero\nINNER JOIN \n    publisher ON superhero.publisher_id = publisher.id\nWHERE \n    publisher.publisher_name = 'Marvel Comics'\nORDER BY \n    height_cm DESC;",
            "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics';"
        ],
        "rule_sql": [
            "SELECT \n    superhero_name, \n    height_cm, \n    RANK() OVER (ORDER BY height_cm DESC) AS HeightRank\nFROM superhero\nINNER JOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel Comics'"
        ]
    },
    "305": {
        "question": "Name all bonds with single bond types and what atoms are connected to the molecules.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.bond_id, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "amends": [
            "Do select only `bond_id`, `atom_id`, and `atom_id2` instead of including additional columns like `molecule_id`, `bond_type`, `element1`, and `element2`. Do use `INNER JOIN` for the connected table instead of multiple joins to atom tables. Do remove the unnecessary joins to `atom a1` and `atom a2` instead of keeping them. Do use table aliases `T1` and `T2` instead of single-letter aliases. The amended query now correctly focuses on bond connectivity data without extraneous element information, matching the RIGHT_SQL's behavior.",
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T1.bond_id` instead of `bond.bond_id` in the SELECT list. Do reference `T2.atom_id` and `T2.atom_id2` instead of `connected.atom_id` and `connected.atom_id2`. Do use table aliases `bond AS T1` and `connected AS T2` instead of unaliased table names. Do filter on `T1.bond_type = '-'` instead of `bond.bond_type = 'single'`. The amended query now correctly matches the RIGHT_SQL's behavior with proper table aliasing and bond type filtering."
        ],
        "rules": [
            "1) When the question asks for bonds with single bond types: filter T1.bond_type to equal exactly '-'.\n2) When selecting bond connectivity information: include only T1.bond_id, T2.atom_id, and T2.atom_id2 in the output.\n3) When combining bond and connected tables: link rows where T1.bond_id equals T2.bond_id using inner matching.\n4) When the question mentions atoms connected to molecules: do not include element information from atom tables.\n5) Output columns (ordered): T1.bond_id, T2.atom_id, T2.atom_id2",
            "1) When the question asks for bonds with single bond types: filter rows where T1.bond_type equals '-' exactly. 2) When combining bond and connected tables: link rows where T1.bond_id equals T2.bond_id exactly and keep only matching pairs (inner match). 3) When the question asks for what atoms are connected to molecules: include both T2.atom_id and T2.atom_id2 in the output. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation for '-' value. 6) When referring to table roles: do not rename or swap the aliases T1 for bond and T2 for connected. Output columns (ordered): T1.bond_id, T2.atom_id, T2.atom_id2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_id, b.molecule_id, b.bond_type, c.atom_id AS atom1, c.atom_id2 AS atom2, a1.element AS element1, a2.element AS element2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_type = '-';",
            "SELECT bond.bond_id, connected.atom_id, connected.atom_id2\nFROM bond\nINNER JOIN connected ON bond.bond_id = connected.bond_id\nWHERE bond.bond_type = 'single'",
            "SELECT T1.bond_id, T2.atom_id, T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT T1.bond_id, T2.atom_id, T2.atom_id2 FROM bond T1 INNER JOIN connected T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'"
        ]
    },
    "558": {
        "question": "How many votes did the user No.58 take on 2010/7/19?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(Id) FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19'",
        "amends": [],
        "rules": [
            "user no. 58 refers to UserId = 58; on 2010/7/19 refers to CreationDate = '2010-07-19'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS vote_count FROM votes WHERE UserId = 58 AND DATE(CreationDate) = '2010-07-19';"
        ],
        "rule_sql": []
    },
    "760": {
        "question": "In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?",
        "db_id": "superhero",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180",
        "amends": [],
        "rules": [
            "height between 150 to 180 refers to height_cm BETWEEN 150 AND 180; heroes published by Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = MULTIPLY(DIVIDE(SUM(publisher.id = 13)), COUNT(publisher.id), 100)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_marvel\nFROM \n    superhero s\nLEFT JOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    s.height_cm BETWEEN 150 AND 180;"
        ],
        "rule_sql": []
    },
    "299": {
        "question": "Is molecule TR124 carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT label FROM molecule WHERE molecule_id = 'TR124';"
        ],
        "rule_sql": []
    },
    "995": {
        "question": "What is the average score of Lewis Hamilton among all the Turkish Grand Prix?",
        "db_id": "formula_1",
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T3.name = 'Turkish Grand Prix'",
        "amends": [
            "Do join `driverStandings` instead of `results` as the source for `points` data. Do use `INNER JOIN` on `drivers` to `driverStandings` via `driverId` instead of joining `results` to `drivers`. Do join `races` to `driverStandings` via `raceId` instead of joining `races` to `results`. Do use exact equality `T3.name = 'Turkish Grand Prix'` instead of pattern matching with `LIKE '%Turkish Grand Prix%'`. Do remove the `AS average_score` alias instead of keeping it. The amended query now correctly calculates Lewis Hamilton's average points from driver standings rather than race results, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating average points for a driver: use the driverStandings table instead of results table as the source for points data.\n2) When joining drivers to get points data: use INNER JOIN between drivers and driverStandings via driverId instead of joining results to drivers.\n3) When joining races to get points data: join races to driverStandings via raceId instead of joining races to results.\n4) When filtering for specific race names: use exact equality comparison (T3.name = 'Turkish Grand Prix') instead of pattern matching with LIKE.\n5) When outputting average score: do not use an alias for the average calculation.\n6) When combining tables for driver standings analysis: link rows where T1.driverId = T2.driverId and T2.raceId = T3.raceId, keeping only matching pairs (inner match).\n7) When filtering for Lewis Hamilton: use exact conditions T1.forename = 'Lewis' AND T1.surname = 'Hamilton'.\n8) Output columns (ordered): AVG(T2.points)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(r.points) AS average_score\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.name LIKE '%Turkish Grand Prix%'\nAND d.forename = 'Lewis' AND d.surname = 'Hamilton';",
            "SELECT AVG(ds.points) FROM driverStandings ds INNER JOIN drivers d ON ds.driverId = d.driverId INNER JOIN races r ON ds.raceId = r.raceId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' AND r.name = 'Turkish Grand Prix'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.points) \nFROM drivers T1\nINNER JOIN driverStandings T2 ON T1.driverId = T2.driverId\nINNER JOIN races T3 ON T2.raceId = T3.raceId\nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'\nAND T3.name = 'Turkish Grand Prix'"
        ]
    },
    "701": {
        "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
        "amends": [],
        "rules": [
            "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH most_influential_user AS (\n    SELECT Id\n    FROM users\n    ORDER BY Reputation DESC\n    LIMIT 1\n),\nuser_posts AS (\n    SELECT Id, Score\n    FROM posts\n    WHERE OwnerUserId = (SELECT Id FROM most_influential_user)\n),\ntotal_posts AS (\n    SELECT COUNT(*) AS total\n    FROM user_posts\n),\nhigh_score_posts AS (\n    SELECT COUNT(*) AS high_score\n    FROM user_posts\n    WHERE Score > 50\n)\nSELECT (high_score * 100.0 / total) AS percentage\nFROM high_score_posts, total_posts;"
        ],
        "rule_sql": []
    },
    "1394": {
        "question": "How many members of the Student_Club have major in 'Physics Teaching'?",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Physics Teaching'",
        "amends": [],
        "rules": [
            "'Physics Teaching' is the major_name;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Physics Teaching';"
        ],
        "rule_sql": []
    },
    "13": {
        "question": "Please list the phone numbers of the schools with the top 3 SAT excellence rate.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr DESC LIMIT 3",
        "amends": [],
        "rules": [
            "Excellence rate = NumGE1500 / NumTstTakr"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.Phone\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY (sc.NumGE1500 * 1.0 / sc.NumTstTakr) DESC\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "388": {
        "question": "What are the cards in set 10E with converted mana of 5 have translation and what are the languages?",
        "db_id": "card_games",
        "ground_truth": "SELECT id, language FROM set_translations WHERE id = ( SELECT id FROM cards WHERE convertedManaCost = 5 ) AND setCode = '10E'",
        "amends": [
            "Do select `id` and `language` from `set_translations` instead of `name` from `cards` and `language` from `set_translations`. Do use a subquery to get `id` from `cards` where `convertedManaCost = 5` instead of joining directly on `setCode`. Do filter `set_translations` with `setCode = '10E'` instead of applying this filter to both joined tables. Do remove the direct table join and instead correlate through the subquery predicate. The amended query now correctly retrieves translation data based on card criteria while maintaining the set code constraint."
        ],
        "rules": [
            "1) When the question asks for cards with specific criteria (set '10E' and converted mana cost 5) that have translations: use a subquery to get card IDs from the cards table where convertedManaCost = 5 and setCode = '10E' instead of direct table joins.\n2) When retrieving translation information: select the id and language columns from the set_translations table rather than name from cards and language from set_translations.\n3) When filtering set translations by set code: apply the condition setCode = '10E' directly to the set_translations table instead of applying it to both joined tables.\n4) When correlating card criteria with translations: use the subquery predicate to correlate through card IDs rather than joining directly on setCode.\n5) Output columns (ordered): set_translations.id, set_translations.language"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, st.language\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE c.setCode = '10E' AND c.convertedManaCost = 5;",
            "SELECT st.id, st.language \nFROM set_translations st \nWHERE st.setCode = '10E' \nAND st.id IN (\n    SELECT c.id \n    FROM cards c \n    WHERE c.convertedManaCost = 5\n)"
        ],
        "rule_sql": [
            "SELECT set_translations.id, set_translations.language \nFROM set_translations \nWHERE set_translations.setCode = '10E' \nAND set_translations.id IN (\n    SELECT c.id \n    FROM cards c \n    WHERE c.setCode = '10E' \n    AND c.convertedManaCost = 5\n)"
        ]
    },
    "950": {
        "question": "Please list the constructor names with 0 points at race 291.",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291",
        "amends": [
            "Do use table `constructorStandings` instead of `constructorResults` as the source table. Do join `constructors` with `constructorStandings` on `constructorId` instead of joining with `constructorResults`. Do reference columns `points` and `raceId` from `constructorStandings` instead of from `constructorResults`. Do use table alias `T1` for `constructorStandings` and `T2` for `constructors` instead of `c` and `cr`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do place both filter conditions in the `WHERE` clause instead of keeping them there. The amended query now correctly retrieves constructor names from standings data rather than results data, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for constructor names with 0 points at a specific race: use table \"constructorStandings\" as T1 and \"constructors\" as T2 instead of other tables. 2) When combining constructor standings with constructor information: link rows where T1.constructorId = T2.constructorId using an inner match. 3) When filtering for a specific race: include the condition T1.raceId = 291. 4) When filtering for zero points: include the condition T1.points = 0. 5) When outputting constructor names: select T2.name as the result. Output columns (ordered): T2.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM constructors c \nJOIN constructorResults cr ON c.constructorId = cr.constructorId \nWHERE cr.raceId = 291 AND cr.points = 0;",
            "SELECT T2.name \nFROM constructorStandings T1 \nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId \nWHERE T1.raceId = 291 AND T1.points = 0"
        ],
        "rule_sql": [
            "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId WHERE T1.raceId = 291 AND T1.points = 0"
        ]
    },
    "639": {
        "question": "Based on posts posted by Community, calculate the percentage of posts that use the R language.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId WHERE T1.DisplayName = 'Community'",
        "amends": [
            "Do use `SUM(IIF(T3.TagName = 'r', 1, 0))` with explicit `CAST` to `REAL` instead of `COUNT(CASE WHEN t.TagName = 'r' THEN 1 END)` for percentage calculation. Do change the FROM clause to use `users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId` instead of `posts p JOIN users u ON p.OwnerUserId = u.Id`, removing the posts table and adding postHistory with a different join condition. Do use `INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId` instead of `LEFT JOIN tags t ON p.Tags LIKE '%r%'`, changing both the join type and predicate to use ExcerptPostId rather than string matching. Do remove the unnecessary percentage alias and keep the WHERE filter on `T1.DisplayName = 'Community'` unchanged. The amended query now correctly calculates the percentage using proper table relationships and avoids the problematic LIKE pattern matching."
        ],
        "rules": [
            "1) When the question asks for posts posted by Community: filter rows where T1.DisplayName equals 'Community' exactly. 2) When combining user and post history data: link rows where T1.Id equals T2.UserId exactly and keep only matching pairs (inner match). 3) When combining post history and tag data: link rows where T3.ExcerptPostId equals T2.PostId exactly and keep only matching pairs (inner match). 4) When calculating percentage of posts using R language: compute (number of rows where T3.TagName equals 'r' exactly) divided by (total number of rows), converting the count to REAL type for decimal division. 5) When counting posts using R language: use SUM(IIF(T3.TagName = 'r', 1, 0)) to count occurrences where the tag name is exactly 'r'. 6) Output columns (ordered): percentage"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN t.TagName = 'r' THEN 1 END) * 100.0 / COUNT(p.Id)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    tags t ON p.Tags LIKE '%r%'\nWHERE \n    u.DisplayName = 'Community';",
            "SELECT \n    (CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) / COUNT(*)) * 100\nFROM \n    users AS T1 \n    INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId\n    INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId\nWHERE \n    T1.DisplayName = 'Community'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(t.TagName = 'r', 1, 0)) * 100.0 / COUNT(*)) AS percentage\nFROM \n    users u\nINNER JOIN \n    posts p ON u.Id = p.OwnerUserId\nINNER JOIN \n    tags t ON p.Id = t.ExcerptPostId\nWHERE \n    u.DisplayName = 'Community';"
        ]
    },
    "1108": {
        "question": "What was the build up play speed class for \"Willem II\" on 2011/2/22?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT t2.buildUpPlaySpeedClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Willem II' AND SUBSTR(t2.`date`, 1, 10) = '2011-02-22'",
        "amends": [
            "Do use table alias `t2` for the Team_Attributes table instead of `ta` and reference `t2.buildUpPlaySpeedClass` instead of `ta.buildUpPlaySpeedClass`. Do use explicit `INNER JOIN` instead of just `JOIN` while maintaining the same join condition `t1.team_api_id = t2.team_api_id`. Do add table alias `t1` for the Team table instead of `t` and reference `t1.team_long_name` instead of `t.team_long_name`. Do use `SUBSTR(t2.date, 1, 10)` for date comparison instead of direct equality `t2.date = '2011-02-22'` to handle potential timestamp values by extracting just the date portion. The amended query now correctly handles date filtering and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a specific team by name \"Willem II\": filter rows where T1.team_long_name equals exactly 'Willem II'. 2) When the question asks for data on a specific date 2011/2/22: filter rows where the date portion of T2.date (first 10 characters) equals '2011-02-22'. 3) When combining Team (T1) and Team_Attributes (T2) tables: link rows where T1.team_api_id equals T2.team_api_id and keep only matching pairs (inner match). 4) Output columns (ordered): T2.buildUpPlaySpeedClass"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT ta.buildUpPlaySpeedClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'Willem II' \nAND ta.date = '2011-02-22';",
            "SELECT t2.buildUpPlaySpeedClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Willem II' \nAND SUBSTR(t2.date, 1, 10) = '2011-02-22'"
        ],
        "rule_sql": [
            "SELECT T2.buildUpPlaySpeedClass \nFROM Team T1 \nINNER JOIN Team_Attributes T2 ON T1.team_api_id = T2.team_api_id \nWHERE T1.team_long_name = 'Willem II' \nAND substr(T2.date, 1, 10) = '2011-02-22'"
        ]
    },
    "526": {
        "question": "Among the card designed by Matthew D. Wilson, how many are available only in the paper?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper'",
        "amends": [],
        "rules": [
            "card designed by Matthew D. Wilson refers to artist = 'Matthew D. Wilson'; available only in the paper refers to availability = 'paper'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'Matthew D. Wilson' \nAND availability = 'paper';"
        ],
        "rule_sql": []
    },
    "861": {
        "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'",
        "amends": [
            "Do reference the `number` column from the `drivers` table as `T2.number` instead of `d.number`. Do use `INNER JOIN` with explicit table aliases `qualifying AS T1` and `drivers AS T2` instead of simple `JOIN` with aliases `d` and `q`. Do specify the join condition as `T2.driverId = T1.driverId` instead of `d.driverId = q.driverId`. Do use the `LIKE` operator with pattern `'1:54%'` for the `q3` filter instead of exact string comparison `= '0:01:54'`. The amended query now correctly matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a driver's number: use the exact column token T2.number from the drivers table. 2) When combining qualifying and drivers tables: link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match). 3) When filtering for qualifying race No.903: use exact literal value 903 for T1.raceId. 4) When filtering for Q3 time '0:01:54': use pattern matching with LIKE operator and pattern '1:54%' for T1.q3 instead of exact string comparison. 5) When handling time values in q3 column: preserve the exact pattern matching behavior shown in the amends with leading '1:54' pattern. Output columns (ordered): T2.number"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.number\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nWHERE q.raceId = 903 AND q.q3 = '0:01:54';",
            "SELECT T2.number \nFROM qualifying AS T1 \nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 903 \nAND T1.q3 LIKE '1:54%';"
        ],
        "rule_sql": [
            "SELECT T2.number FROM qualifying T1 INNER JOIN drivers T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'"
        ]
    },
    "194": {
        "question": "Provide the IDs and age of the client with high level credit card, which is eligible for loans.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'",
        "amends": [
            "Do calculate age using `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date)` instead of the complex birthday adjustment formula with `strftime('%Y', 'now') - strftime('%Y', c.birth_date)) - (strftime('%m-%d', 'now') < strftime('%m-%d', c.birth_date))`. Do use table aliases `T1`, `T2`, and `T3` instead of `c`, `d`, and `cd`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do join `card AS T2` on `T2.disp_id = T1.disp_id` instead of `cd ON d.disp_id = cd.disp_id`. Do join `client AS T3` on `T1.client_id = T3.client_id` instead of starting with client table. Do reference `T2.type` and `T1.type` in WHERE clause instead of `cd.type` and `d.type`. Do remove the age calculation adjustment for exact birthday comparison instead of keeping it. The amended query now correctly calculates age without the complex birthday adjustment and follows proper join relationships.",
            "Do remove the `INNER JOIN loan AS T4 ON T1.account_id = T4.account_id` and its associated `T4.status = 'A'` filter instead of including them, as the right query does not require loan data. Do keep the `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date)` age calculation without an alias instead of aliasing it as `age`. The amended query now correctly focuses only on clients with gold cards who are account owners, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When calculating client age: compute age as STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) without birthday adjustment. 2) When joining tables: use INNER JOIN between disposition table T1 and card table T2 on T2.disp_id = T1.disp_id, and INNER JOIN between disposition table T1 and client table T3 on T1.client_id = T3.client_id. 3) When filtering for high level credit card eligibility: include rows where T2.type = 'gold' and T1.type = 'OWNER'. 4) When selecting output columns: include T3.client_id and the computed age. Output columns (ordered): T3.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) AS age",
            "1) When the question asks for client IDs and age: output T3.client_id and the age calculation without an alias. 2) When calculating age from birth date: compute STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date). 3) When the question mentions \"high level credit card\": filter for T2.type = 'gold'. 4) When the question mentions \"eligible for loans\" but the amends remove loan-related conditions: do not include loan table joins or loan status filters. 5) When combining disp and card tables: link rows where T2.disp_id = T1.disp_id. 6) When combining disp and client tables: link rows where T1.client_id = T3.client_id. 7) When the question asks for account owners: filter for T1.type = 'OWNER'. 8) Output columns (ordered): T3.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.client_id, (strftime('%Y', 'now') - strftime('%Y', c.birth_date)) - (strftime('%m-%d', 'now') < strftime('%m-%d', c.birth_date)) AS age\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card cd ON d.disp_id = cd.disp_id\nWHERE cd.type = 'gold' AND d.type = 'OWNER';",
            "SELECT \n    T3.client_id,\n    STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) AS age\nFROM \n    disp AS T1\nINNER JOIN \n    card AS T2 ON T2.disp_id = T1.disp_id\nINNER JOIN \n    client AS T3 ON T1.client_id = T3.client_id\nINNER JOIN \n    loan AS T4 ON T1.account_id = T4.account_id\nWHERE \n    T2.type = 'gold' AND \n    T1.type = 'OWNER' AND \n    T4.status = 'A'",
            "SELECT T3.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) AS age\nFROM disp AS T1\nINNER JOIN card AS T2 ON T2.disp_id = T1.disp_id\nINNER JOIN client AS T3 ON T1.client_id = T3.client_id\nWHERE T2.type = 'gold' AND T1.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT T3.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) \nFROM disp T1 \nINNER JOIN card T2 ON T2.disp_id = T1.disp_id \nINNER JOIN client T3 ON T1.client_id = T3.client_id \nWHERE T2.type = 'gold' AND T1.type = 'OWNER'"
        ]
    },
    "45": {
        "question": "What is the average writing score of each of the schools managed by Ricci Ulrich? List the schools and the corresponding average writing scores.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.School, T1.AvgScrWrite FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'",
        "amends": [],
        "rules": [
            "Usually, administrators manage the school stuff."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.School, sc.AvgScrWrite\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE (s.AdmFName1 = 'Ricci' AND s.AdmLName1 = 'Ulrich') \n   OR (s.AdmFName2 = 'Ricci' AND s.AdmLName2 = 'Ulrich') \n   OR (s.AdmFName3 = 'Ricci' AND s.AdmLName3 = 'Ulrich')\nGROUP BY s.School;"
        ],
        "rule_sql": []
    },
    "152": {
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "db_id": "financial",
        "ground_truth": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "amends": [],
        "rules": [
            "A3 refers to region names; A15 stands for the average number of crimes commited in 1995."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(d.A15) AS average_crimes_1995\nFROM district d\nJOIN account a ON d.district_id = a.district_id\nWHERE d.A15 > 4000\nAND a.date >= '1997-01-01';"
        ],
        "rule_sql": []
    },
    "566": {
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "amends": [],
        "rules": [
            "post no. 65041 refers to Id = '65041'; reputation point refers to Reputation"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.Reputation\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Id = 65041;"
        ],
        "rule_sql": []
    },
    "218": {
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "db_id": "toxicology",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [
            "Do use a single query with `INNER JOIN` between `atom` and `molecule` tables instead of separate CTEs with `LEFT JOIN`. Do calculate the percentage using `CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END` instead of subtracting counts from separate CTEs. Do filter with `WHERE T2.label = '+'` instead of using a CTE for carcinogenic molecules. Do cast the count to `REAL` before division instead of using `100.0` with implicit casting. Do remove the CTE structure and perform the calculation directly in the main query instead of using intermediate result sets. The amended query now correctly calculates the percentage of carcinogenic molecules that do not contain fluorine atoms by joining the tables directly and using conditional counting."
        ],
        "rules": [
            "1) When the question asks for a percentage of carcinogenic-type molecules: filter molecules using the exact literal condition T2.label = '+'.\n2) When joining the atom and molecule tables: use an inner match where T1.molecule_id = T2.molecule_id to combine atom and molecule information.\n3) When checking for fluorine atoms: use the exact literal condition T1.element <> 'f' with the exact literal value 'f'.\n4) When counting molecules without fluorine: use conditional counting with CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END to identify molecules to count.\n5) When calculating percentages: cast the count to REAL type before division to ensure proper numeric precision.\n6) When computing ratios: calculate (count of molecules satisfying the condition) divided by (total count of carcinogenic molecules), guarding against division by zero.\n7) Output columns (ordered): the computed percentage value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "WITH carcinogenic_molecules AS (\n  SELECT DISTINCT m.molecule_id\n  FROM molecule m\n  WHERE m.label = '+'\n),\nfluorine_molecules AS (\n  SELECT DISTINCT a.molecule_id\n  FROM atom a\n  WHERE a.element = 'f'\n)\nSELECT \n  (COUNT(DISTINCT cm.molecule_id) - COUNT(DISTINCT fm.molecule_id)) * 100.0 / COUNT(DISTINCT cm.molecule_id) AS percentage\nFROM carcinogenic_molecules cm\nLEFT JOIN fluorine_molecules fm ON cm.molecule_id = fm.molecule_id;",
            "SELECT \n    (COUNT(DISTINCT CASE WHEN a.element <> 'f' THEN m.molecule_id ELSE NULL END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM \n    molecule m\nINNER JOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = '+'"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN a.element <> 'f' THEN m.molecule_id ELSE NULL END) AS REAL) / \n     CAST(COUNT(DISTINCT m.molecule_id) AS REAL)) * 100.0 AS percentage\nFROM \n    molecule m\nINNER JOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = '+'"
        ]
    },
    "862": {
        "question": "For the Bahrain Grand Prix in 2007, how many drivers not finished the game?",
        "db_id": "formula_1",
        "ground_truth": "SELECT COUNT(T3.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2007 AND T1.name = 'Bahrain Grand Prix' AND T2.time IS NULL",
        "amends": [],
        "rules": [
            "Bahrain Grand Prix refers to races.name = 'Bahrain Grand Prix'; drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS drivers_not_finished\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE name = 'Bahrain Grand Prix' AND year = 2007)\nAND time IS NULL;"
        ],
        "rule_sql": []
    },
    "183": {
        "question": "How many accounts in Beroun were opened after 1996?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) > '1996' AND T2.A2 = 'Beroun'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS account_count\nFROM account\nJOIN district ON account.district_id = district.district_id\nWHERE district.A2 = 'Beroun' AND strftime('%Y', account.date) > '1996';"
        ],
        "rule_sql": []
    },
    "992": {
        "question": "Find the full name, Wiki Pedia page link, and date of birth of German drivers born between 1971 and 1985. List it in descending order of date of birth.",
        "db_id": "formula_1",
        "ground_truth": "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND STRFTIME('%Y', dob) BETWEEN '1971' AND '1985' ORDER BY dob DESC",
        "amends": [
            "Do select individual columns `forename`, `surname`, `url`, and `dob` instead of concatenating `forename || ' ' || surname` as `full_name` and aliasing `url` as `wikipedia_link` and `dob` as `date_of_birth`. The amended query now matches RIGHT_SQL's behavior by returning the raw column values rather than transformed and aliased outputs."
        ],
        "rules": [
            "1) When selecting driver information: return the individual columns forename, surname, url, and dob instead of concatenating or aliasing them.\n2) When filtering for German drivers: include only rows where nationality equals 'German' exactly.\n3) When filtering by birth date range: include drivers born between 1971 and 1985 inclusive using the dob column.\n4) When ordering results: sort in descending order based on the dob column.\n5) Output columns (ordered): forename, surname, url, dob"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    forename || ' ' || surname AS full_name,\n    url AS wikipedia_link,\n    dob AS date_of_birth\nFROM \n    drivers\nWHERE \n    nationality = 'German' \n    AND strftime('%Y', dob) BETWEEN '1971' AND '1985'\nORDER BY \n    dob DESC;",
            "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND dob BETWEEN '1971-01-01' AND '1985-12-31' ORDER BY dob DESC;"
        ],
        "rule_sql": [
            "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND dob BETWEEN '1971-01-01' AND '1985-12-31' ORDER BY dob DESC;"
        ]
    },
    "480": {
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "amends": [],
        "rules": [
            "Italian refers to language = 'Italian'; flavor text refers to flavorText; \"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT fd.flavorText \nFROM foreign_data fd\nJOIN cards c ON fd.uuid = c.uuid\nWHERE c.name = 'Ancestor''s Chosen' AND fd.language = 'Italian';"
        ],
        "rule_sql": []
    },
    "1343": {
        "question": "With the biggest budget for the \"Food\", what was the remaining of it?",
        "db_id": "student_club",
        "ground_truth": "SELECT remaining FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget WHERE category = 'Food' )",
        "amends": [],
        "rules": [
            "remaining of budget refers to remaining, biggest budget for 'Food' refers to MAX(budget.amount) where category = 'Food'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT remaining FROM budget WHERE category = 'Food' ORDER BY amount DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1482": {
        "error": "something went wrong, tool did not call.",
        "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
        "amends": [
            "Do add explicit column aliases for each calculated percentage instead of omitting them, which would result in unnamed columns. Do use consistent CAST placement around the entire percentage calculation instead of only casting the numerator difference, ensuring proper floating-point division. Do maintain the same join condition `T1.CustomerID = T2.CustomerID` and filtering logic using `IIF` with `LIKE` patterns for year extraction instead of changing these elements. The amended query now correctly calculates percentage growth for each segment with proper type casting and explicit column naming, matching the RIGHT_SQL's behavior.",
            "Do use a single query with conditional aggregation instead of separate CTEs for each year. Do calculate percentage increases for each segment directly in the SELECT list using `IIF` conditions instead of joining separate aggregated results. Do filter for segments 'SME', 'LAM', and 'KAM' within the conditional expressions instead of using a WHERE clause on the final result. Do remove the explicit JOIN between CTEs and instead perform all calculations in the main query. Do use `INNER JOIN` between `customers` and `yearmonth` tables instead of separate joins in CTEs. Do cast the difference calculations to `FLOAT` instead of `REAL` for the percentage computation. Do eliminate the ORDER BY clause since the result now returns three scalar values instead of a rowset. The amended query now correctly computes percentage increases for each segment in a single row output.",
            "Do use explicit `CAST(... AS FLOAT)` for all percentage calculations instead of implicit casting in some cases. Do calculate percentage growth for three segments (`SME`, `LAM`, `KAM`) with proper year filtering using `LIKE '2013%'` and `LIKE '2012%'` instead of incorrect date handling. Do maintain the `INNER JOIN` between `customers AS T1` and `yearmonth AS T2` on `T1.CustomerID = T2.CustomerID` to correctly associate customer segments with consumption data. The amended query now properly computes year-over-year percentage growth for each customer segment using explicit type casting and correct date filtering to match the intended analytical behavior.",
            "Do place the `T1.Segment` condition before the `T2.Date` condition in all `IIF` functions instead of after it, though this is purely cosmetic. Do remove the `NULLIF` function calls and instead perform direct division by the denominator sum instead of using null protection. Do remove the `WHERE T1.Currency = 'EUR'` filter instead of keeping it, as the right query includes all currencies. Do remove the column aliases `SME_Percentage_Increase`, `LAM_Percentage_Increase`, and `KAM_Percentage_Increase` instead of keeping them. The amended query now matches the right SQL's behavior by calculating percentage increases for all segments without currency filtering."
        ],
        "rules": [
            "1) When calculating percentage increases between years: compute (2013 value minus 2012 value) divided by 2012 value, with proper floating-point casting around the entire calculation. 2) When filtering for specific years 2012 and 2013: use year extraction logic with LIKE patterns to identify the correct years. 3) When grouping by customer segments SME, LAM, and KAM: organize results by these segment categories. 4) When joining tables T1 and T2: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match). 5) When outputting calculated percentages: provide explicit column aliases for each percentage calculation instead of leaving them unnamed. 6) Output columns (ordered): Segment, PercentageIncreaseEUR",
            "1) When the question asks for percentage increases between 2012 and 2013 for specific segments: calculate consumption totals for each year using conditional aggregation with exact year patterns '2012%' and '2013%'.\n2) When filtering for specific segments 'SME', 'LAM', and 'KAM': include these segment values directly in the conditional aggregation expressions rather than using a separate WHERE clause.\n3) When combining customer and consumption data: link rows where customers.CustomerID equals yearmonth.CustomerID using an inner match.\n4) When calculating percentage increases: compute (2013_consumption - 2012_consumption) * 100.0 / 2012_consumption and cast the result to FLOAT type.\n5) When the question asks for EUR currency transactions: filter for customers.Currency = 'EUR' exactly as specified.\n6) When the result should return three scalar values: output each segment's percentage increase without ordering since the question asks for both biggest and lowest values.\n7) Output columns (ordered): SME percentage increase, LAM percentage increase, KAM percentage increase",
            "1) When calculating percentage increases between years: use explicit CAST(... AS FLOAT) for all percentage calculations instead of implicit casting. 2) When filtering for specific years 2012 and 2013: use LIKE '2012%' for 2012 data and LIKE '2013%' for 2013 data instead of incorrect date handling. 3) When combining customer segments with consumption data: perform an INNER JOIN between customers AS T1 and yearmonth AS T2 on T1.CustomerID = T2.CustomerID to correctly associate customer segments with consumption data. 4) When computing percentage growth for customer segments: calculate year-over-year percentage growth for each of the three segments (SME, LAM, KAM) using the proper year filtering and explicit type casting. 5) When handling customer segments: use the exact segment identifiers SME, LAM, and KAM as specified in the question. Output columns (ordered): T1.Segment, Percentage_Growth",
            "1) When the question asks for percentage increases in consumption between 2012 and 2013: calculate the percentage increase as ((2013 consumption - 2012 consumption) / 2012 consumption) * 100 for each segment.\n2) When the question mentions segments SME, LAM, and KAM: use the exact literal values 'SME', 'LAM', and 'KAM' for T1.Segment conditions.\n3) When filtering by years 2012 and 2013: use the exact date patterns '2012%' and '2013%' for T2.Date conditions.\n4) When combining T1 and T2 tables: link rows where T1.CustomerID = T2.CustomerID using inner match.\n5) When the question asks about consumption paid in EUR: do not apply currency filtering as the calculation should include all currencies.\n6) When calculating percentage increases: perform direct division without null protection functions.\n7) When organizing results by segment: place T1.Segment conditions before T2.Date conditions in conditional logic.\n8) When producing output: do not use column aliases for the percentage increase calculations.\nOutput columns (ordered): The percentage increase calculations for SME, LAM, and KAM segments"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "",
            "WITH Consumption2012 AS (\n    SELECT \n        c.Segment,\n        SUM(ym.Consumption) AS TotalConsumption2012\n    FROM \n        yearmonth ym\n    JOIN \n        customers c ON ym.CustomerID = c.CustomerID\n    WHERE \n        c.Currency = 'EUR' \n        AND ym.Date LIKE '2012%'\n    GROUP BY \n        c.Segment\n),\nConsumption2013 AS (\n    SELECT \n        c.Segment,\n        SUM(ym.Consumption) AS TotalConsumption2013\n    FROM \n        yearmonth ym\n    JOIN \n        customers c ON ym.CustomerID = c.CustomerID\n    WHERE \n        c.Currency = 'EUR' \n        AND ym.Date LIKE '2013%'\n    GROUP BY \n        c.Segment\n)\nSELECT \n    c12.Segment,\n    c12.TotalConsumption2012 AS Consumption_2012,\n    c13.TotalConsumption2013 AS Consumption_2013,\n    CAST((c13.TotalConsumption2013 - c12.TotalConsumption2012) * 100.0 / c12.TotalConsumption2012 AS REAL) AS PercentageIncrease\nFROM \n    Consumption2012 c12\nJOIN \n    Consumption2013 c13 ON c12.Segment = c13.Segment\nWHERE \n    c12.Segment IN ('SME', 'LAM', 'KAM')\nORDER BY \n    PercentageIncrease DESC;",
            "error",
            "SELECT \n    CAST((SUM(IIF(T2.Date LIKE '2013%' AND T1.Segment = 'SME', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'SME', T2.Consumption, 0))) AS FLOAT) / NULLIF(SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'SME', T2.Consumption, 0)), 0) * 100 AS SME_Percentage_Increase,\n    CAST((SUM(IIF(T2.Date LIKE '2013%' AND T1.Segment = 'LAM', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'LAM', T2.Consumption, 0))) AS FLOAT) / NULLIF(SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'LAM', T2.Consumption, 0)), 0) * 100 AS LAM_Percentage_Increase,\n    CAST((SUM(IIF(T2.Date LIKE '2013%' AND T1.Segment = 'KAM', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'KAM', T2.Consumption, 0))) AS FLOAT) / NULLIF(SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'KAM', T2.Consumption, 0)), 0) * 100 AS KAM_Percentage_Increase\nFROM \n    customers AS T1\nINNER JOIN \n    yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Currency = 'EUR'",
            "SELECT \n    CAST(SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)) * 100 AS SME_Percentage_Increase,\n    CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) * 100 AS LAM_Percentage_Increase,\n    CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) * 100 AS KAM_Percentage_Increase\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment IN ('SME', 'LAM', 'KAM');"
        ],
        "rule_sql": [
            "SELECT \n    T1.Segment,\n    ((SUM(CASE WHEN T2.Date LIKE '2013%' THEN T2.Consumption ELSE 0 END) - \n      SUM(CASE WHEN T2.Date LIKE '2012%' THEN T2.Consumption ELSE 0 END)) * 100.0 / \n     SUM(CASE WHEN T2.Date LIKE '2012%' THEN T2.Consumption ELSE 0 END)) AS PercentageIncreaseEUR\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment IN ('SME', 'LAM', 'KAM') AND T1.Currency = 'EUR'\nGROUP BY T1.Segment"
        ]
    },
    "160": {
        "question": "Among the weekly issuance accounts, how many have a loan of under 200000?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.amount < 200000",
        "amends": [],
        "rules": [
            "frequency = 'POPLATEK TYDNE' stands for weekly issuance"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS weekly_accounts_with_loan_under_200000\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND l.amount < 200000;"
        ],
        "rule_sql": []
    },
    "746": {
        "question": "Calculate the average attribute value of all superheroes.",
        "db_id": "superhero",
        "ground_truth": "SELECT AVG(attribute_value) FROM hero_attribute",
        "amends": [],
        "rules": [
            "average attribute value of all superheroes refers to AVG(attribute_value)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(attribute_value) AS average_attribute_value FROM hero_attribute;"
        ],
        "rule_sql": []
    },
    "53": {
        "question": "How many test takers are there at the school/s whose mailing city address is in Fresno?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'",
        "amends": [
            "Do use `T1.NumTstTakr` as the column selection instead of `SUM(s.NumTstTakr) AS TotalTestTakers` to return individual values rather than an aggregate sum. Do use table aliases `T1` and `T2` instead of `s` and `sc` for consistency. Do use `INNER JOIN` explicitly instead of just `JOIN` to clarify the join type. Do reference `T1.cds = T2.CDSCode` in the join condition instead of `s.cds = sc.CDSCode` to match the alias naming. Do remove the `AS TotalTestTakers` alias since the column is returned without aggregation. The amended query now correctly returns individual test taker counts for Fresno schools instead of summing them."
        ],
        "rules": [
            "1) When the question asks for test takers at schools: use T1.NumTstTakr to return individual values rather than aggregating them. 2) When combining SAT scores and schools data: link rows where T1.cds = T2.CDSCode using an inner match. 3) When filtering for schools with mailing city address in Fresno: include only rows where T2.MailCity equals 'Fresno' exactly. 4) When using table aliases: use T1 for the satscores table and T2 for the schools table consistently. 5) Output columns (ordered): T1.NumTstTakr"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(s.NumTstTakr) AS TotalTestTakers\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE sc.MailCity = 'Fresno';",
            "SELECT T1.NumTstTakr FROM satscores T1 INNER JOIN schools T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'"
        ],
        "rule_sql": [
            "SELECT T1.NumTstTakr FROM satscores T1 INNER JOIN schools T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'"
        ]
    },
    "1187": {
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "amends": [],
        "rules": [
            "examined between 1987/7/6 and 1996/1/31 refers to Date BETWEEN '1987-07-06' AND '1996-01-31'; GPT level greater than 30 refers to GPT > 30; ALB level less than 4 ALB < 4"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT ID\nFROM Laboratory\nWHERE Date BETWEEN '1987-07-06' AND '1996-01-31'\n  AND GPT > 30\n  AND ALB < 4;"
        ],
        "rule_sql": []
    },
    "246": {
        "question": "List the bond type and the bond ID of the atom 45.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.bond_type, T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE SUBSTR(T2.atom_id, 7, 2) = '45'",
        "amends": [],
        "rules": [
            "bond ID of atom 45 refers to SUBSTR(atom_id, 7, 2) + 0 = 45; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_type, b.bond_id\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE SUBSTR(a.atom_id, 7, 2) + 0 = 45;"
        ],
        "rule_sql": []
    },
    "1012": {
        "question": "What was the position of the circuits during Lewis Hamilton's fastest lap in a Formula_1 race?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.position FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.time ASC LIMIT 1",
        "amends": [
            "Do select `T1.position` instead of `c.lat, c.lng`. Do use `lapTimes AS T1` as the main table instead of multiple joins across `drivers`, `results`, `races`, and `circuits`. Do join `drivers AS T2` on `T1.driverId = T2.driverId` instead of joining `results` on `d.driverId = r.driverId` and subsequent circuit joins. Do move the driver name filter `T2.forename = 'Lewis' AND T2.surname = 'Hamilton'` to the WHERE clause instead of keeping it there but with different table references. Do remove the subquery for minimum time and instead use `ORDER BY T1.time ASC LIMIT 1` to get the fastest lap record instead of finding minimum time through a correlated subquery. Do add explicit `ORDER BY` and `LIMIT` clauses instead of relying on subquery aggregation. The amended query now correctly retrieves the position from lapTimes for Lewis Hamilton's fastest lap rather than attempting to get circuit coordinates for his fastest result time."
        ],
        "rules": [
            "1) When the question asks for position information during a fastest lap: select T1.position instead of circuit coordinates. 2) When working with lap time data: use lapTimes AS T1 as the main table instead of joining multiple other tables. 3) When filtering for a specific driver: join drivers AS T2 on T1.driverId = T2.driverId and apply the filter T2.forename = 'Lewis' AND T2.surname = 'Hamilton' in the WHERE clause. 4) When finding the fastest lap: order by T1.time in ascending order and take only the first record instead of using subqueries for minimum time. 5) Output columns (ordered): T1.position"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.lat, c.lng\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN races ra ON r.raceId = ra.raceId\nJOIN circuits c ON ra.circuitId = c.circuitId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND r.time = (SELECT MIN(time) FROM results WHERE driverId = d.driverId);",
            "SELECT T1.position \nFROM lapTimes AS T1\nJOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'\nORDER BY T1.time ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.position \nFROM lapTimes AS T1 \nJOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' \nORDER BY T1.time ASC \nLIMIT 1"
        ]
    },
    "18": {
        "question": "How many schools in Fresno (directly funded) have number of test takers not more than 250?",
        "db_id": "california_schools",
        "ground_truth": "SELECT COUNT(T1.CDSCode) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`County Name` = 'Fresno' AND T2.NumTstTakr <= 250",
        "amends": [
            "Do use `COUNT(T1.CDSCode)` instead of `COUNT(*)` to count specific non-null values. Do join from `frpm AS T1` instead of `schools s` as the primary table. Do use `INNER JOIN` with `satscores AS T2` instead of `JOIN` with `sc` for explicit join type clarity. Do reference `T1.`Charter Funding Type` = 'Directly funded'` instead of `s.FundingType = 'Directly Funded'` with corrected case sensitivity and column name. Do reference `T1.`County Name` = 'Fresno'` instead of `s.County = 'Fresno'` with the proper column name. Do maintain the condition `T2.NumTstTakr <= 250` instead of `sc.NumTstTakr <= 250` with consistent table alias. The amended query now correctly joins the appropriate tables with accurate column references and filtering conditions to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for schools in Fresno: filter rows where T1.\"County Name\" equals 'Fresno' exactly. 2) When the question mentions \"directly funded\": filter rows where T1.\"Charter Funding Type\" equals 'Directly funded' exactly (case-sensitive). 3) When the question asks for number of test takers not more than 250: filter rows where T2.NumTstTakr is less than or equal to 250. 4) When combining T1 and T2 for shared entities: link rows where T1.CDSCode equals T2.cds exactly and keep only matching pairs (inner match). 5) When counting schools: count using the canonical key T1.CDSCode to count specific non-null values. Output columns (ordered): COUNT(T1.CDSCode)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.County = 'Fresno' \nAND s.FundingType = 'Directly Funded' \nAND sc.NumTstTakr <= 250;",
            "SELECT COUNT(T1.CDSCode) \nFROM frpm AS T1 \nINNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds \nWHERE T1.\"County Name\" = 'Fresno' \nAND T1.\"Charter Funding Type\" = 'Directly funded' \nAND T2.NumTstTakr <= 250"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.CDSCode) \nFROM frpm T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nWHERE T1.\"County Name\" = 'Fresno' \nAND T1.\"Charter Funding Type\" = 'Directly funded'\nAND T2.NumTstTakr <= 250"
        ]
    },
    "879": {
        "question": "For the driver who set the fastest lap speed, what is his nationality?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the fastest lap speed refers to (MAX) fastestLapSpeed;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.nationality \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nWHERE r.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results);"
        ],
        "rule_sql": []
    },
    "547": {
        "question": "Among the posts owned by an elder user, how many of them have a score of over 19?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score >= 20 AND T2.Age > 65",
        "amends": [],
        "rules": [
            "elder users refers to Age > 65; Score of over 19 refers to Score > = 20"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS NumberOfPosts\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.Age > 65 AND p.Score >= 20;"
        ],
        "rule_sql": []
    },
    "413": {
        "question": "How many cards with print rarity have ruling text printed on 01/02/2007?",
        "db_id": "card_games",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'rare' AND T2.date = '2007-02-01'",
        "amends": [],
        "rules": [
            "with print rarity refers to rarity = 'rare'; on 01/02/2007 refers to date = '2007-02-01'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.id) \nFROM cards c \nJOIN rulings r ON c.uuid = r.uuid \nWHERE c.rarity = 'rare' AND r.date = '2007-02-01';"
        ],
        "rule_sql": []
    },
    "1134": {
        "question": "What is the difference between players 6 and 23's jumping scores?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) FROM Player_Attributes AS t1",
        "amends": [
            "Do use a single table reference `Player_Attributes AS t1` instead of multiple subqueries against the same table. Do aggregate with `SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END)` instead of separate scalar subqueries `(SELECT jumping FROM Player_Attributes WHERE player_api_id = 6)`. Do reference the correct column `t1.id` for player identification instead of `player_api_id`. Do subtract the aggregated sums directly instead of subtracting the results of separate subqueries. The amended query now correctly handles multiple rows per player and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a difference between specific players' attributes: use a single table reference with an alias (T1) instead of multiple subqueries against the same table. 2) When identifying players by their ID: use the exact column token T1.id instead of player_api_id. 3) When calculating differences between specific players' scores: aggregate using SUM(CASE WHEN T1.id = 6 THEN T1.jumping ELSE 0 END) - SUM(CASE WHEN T1.id = 23 THEN T1.jumping ELSE 0 END) instead of subtracting separate subquery results. 4) When handling multiple rows per player: ensure the aggregation correctly sums all relevant rows for each player before computing the difference. 5) Output columns (ordered): jumping_difference"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (SELECT jumping FROM Player_Attributes WHERE player_api_id = 6) - (SELECT jumping FROM Player_Attributes WHERE player_api_id = 23) AS jumping_difference;",
            "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) AS jumping_difference FROM Player_Attributes AS t1 WHERE t1.id IN (6, 23);"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN T1.id = 6 THEN T1.jumping ELSE 0 END) - \n    SUM(CASE WHEN T1.id = 23 THEN T1.jumping ELSE 0 END) AS jumping_difference\nFROM Player_Attributes T1\nWHERE T1.id IN (6, 23)"
        ]
    },
    "650": {
        "question": "Describe the last accessed date and location of the users who received the outliers badge.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.LastAccessDate, T1.Location FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'outliers'",
        "amends": [
            "Do select only `LastAccessDate` and `Location` instead of including `DisplayName`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do reference the join condition as `T1.Id = T2.UserId` instead of `b.UserId = u.Id`. Do filter on lowercase `'outliers'` instead of title case `'Outliers'`. Do remove the `ORDER BY` clause instead of keeping it. The amended query now correctly retrieves user access dates and locations for those with the 'outliers' badge without unnecessary columns or sorting.",
            "Do reference `T1.LastAccessDate` and `T1.Location` from the users table instead of `T2.LastAccessDate` and `T2.Location` from the wrong table alias. Do use `T2.Name` in the WHERE filter instead of `T1.Name` to correctly reference the badges table where the Name column exists. Do maintain the same INNER JOIN logic with `ON T1.Id = T2.UserId` but ensure proper table alias usage throughout. The amended query now correctly filters on badge names while returning user attributes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for user access dates and locations: select only T2.LastAccessDate and T2.Location columns. 2) When combining users and badges tables: link rows where T1.Id equals T2.UserId using an inner match. 3) When filtering for the outliers badge: use the exact literal 'outliers' (lowercase) instead of 'Outliers'. 4) When the question does not require ordering: do not apply any sorting to the results. 5) Output columns (ordered): T2.LastAccessDate, T2.Location",
            "1) When the question asks for user attributes like \"last accessed date\" and \"location\": use T1.LastAccessDate and T1.Location from the users table. 2) When filtering for badges with a specific name like \"outliers\": use T2.Name = 'outliers' from the badges table. 3) When combining users and badges tables: link rows where T1.Id = T2.UserId and keep only matching pairs (inner match). 4) Output columns (ordered): T1.LastAccessDate, T1.Location"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName, u.LastAccessDate, u.Location\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE b.Name = 'Outliers'\nORDER BY u.LastAccessDate DESC;",
            "SELECT T2.LastAccessDate, T2.Location\nFROM badges T1\nINNER JOIN users T2 ON T1.Id = T2.UserId\nWHERE T1.Name = 'outliers'",
            "SELECT T1.LastAccessDate, T1.Location\nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T2.Name = 'outliers'"
        ],
        "rule_sql": [
            "SELECT u.LastAccessDate, u.Location\nFROM users u\nINNER JOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'outliers'"
        ]
    },
    "1054": {
        "question": "What is the defensive work rate of the football player David Wilson\n?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t2.defensive_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'David Wilson'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pa.defensive_work_rate \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'David Wilson';"
        ],
        "rule_sql": []
    },
    "442": {
        "question": "Mention the base set size and set code of the set that was in block named \"Masques\" and \"Mirage\".",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.baseSetSize, T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block IN ('Masques', 'Mirage')",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the SELECT list to `T1.baseSetSize, T2.setCode` instead of `baseSetSize, code`. Do add `INNER JOIN set_translations AS T2 ON T2.setCode = T1.code` instead of querying only the `sets` table. Do add table aliases `T1` and `T2` instead of using unqualified column names. Do qualify the WHERE clause with `T1.block` instead of just `block`. The amended query now correctly joins with set_translations to retrieve the appropriate setCode values and ensures distinct results."
        ],
        "rules": [
            "1) When the question asks for \"set code\" and the schema shows setCode in a related table: retrieve T2.setCode from the set_translations table instead of code from the sets table. 2) When joining sets and set_translations tables: link rows where T2.setCode = T1.code using an inner match. 3) When the question mentions specific block names: filter T1.block to exactly match 'Masques' or 'Mirage' (case-sensitive). 4) When retrieving multiple columns from joined tables: use table aliases T1 for sets and T2 for set_translations. 5) When the question asks for distinct results: ensure only unique combinations of the selected columns are returned. 6) Output columns (ordered): T1.baseSetSize, T2.setCode"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT baseSetSize, code FROM sets WHERE block IN ('Masques', 'Mirage');",
            "SELECT DISTINCT T1.baseSetSize, T2.setCode\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code\nWHERE T1.block IN ('Masques', 'Mirage')"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.baseSetSize, T2.setCode\nFROM sets T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.code\nWHERE T1.block = 'Masques' OR T1.block = 'Mirage'"
        ]
    },
    "1013": {
        "question": "What is the lap record for the Austrian Grand Prix Circuit?",
        "db_id": "formula_1",
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.fastestLapTime FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL) SELECT MIN(fastest_lap_times.fastestLapTime) as lap_record FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix'",
        "amends": [
            "Do add a CTE `fastest_lap_times` that filters for `fastestLapTime IS NOT NULL` instead of querying the raw results table directly. Do change the join condition from `r.raceId = rc.raceId` to `fastest_lap_times.raceId = T2.raceId` with proper table aliasing. Do modify the WHERE clause to filter on `T2.name = 'Austrian Grand Prix'` instead of `c.name = 'Austrian Grand Prix Circuit'` to match the correct circuit naming convention. Do use `INNER JOIN` consistently instead of mixing `JOIN` syntax. The amended query now correctly handles NULL fastest lap times and uses the proper circuit name filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When filtering for fastest lap times: include only rows where fastestLapTime IS NOT NULL. 2) When joining fastest lap times with races: link rows where fastest_lap_times.raceId = T2.raceId using exact equality. 3) When filtering for Austrian Grand Prix Circuit: use the exact literal 'Austrian Grand Prix' for T2.name comparison. 4) When combining tables: perform inner matches only, keeping only rows present on both sides. 5) When finding the minimum fastest lap time: compute the smallest value of fastestLapTime from the filtered dataset. Output columns (ordered): lapRecord"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(r.fastestLapTime) AS lapRecord\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN circuits c ON rc.circuitId = c.circuitId\nWHERE c.name = 'Austrian Grand Prix Circuit';",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.circuitId,\n        r.name AS race_name,\n        res.fastestLapTime\n    FROM \n        results res\n    INNER JOIN \n        races r ON res.raceId = r.raceId\n    WHERE \n        res.fastestLapTime IS NOT NULL\n)\nSELECT \n    MIN(fastest_lap_times.fastestLapTime) AS lap_record\nFROM \n    fastest_lap_times\nINNER JOIN \n    races T2 ON fastest_lap_times.raceId = T2.raceId\nINNER JOIN \n    circuits c ON T2.circuitId = c.circuitId\nWHERE \n    T2.name = 'Austrian Grand Prix';"
        ],
        "rule_sql": [
            "SELECT MIN(fastestLapTime) AS lapRecord\nFROM results\nINNER JOIN races ON results.raceId = races.raceId\nWHERE races.name = 'Austrian Grand Prix'\nAND fastestLapTime IS NOT NULL;"
        ]
    },
    "1036": {
        "question": "List the long name of teams with above-average build-up play passing in 2012.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t4.team_long_name FROM Team_Attributes AS t3 INNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTR(t3.`date`, 1, 4) = '2012' AND t3.buildUpPlayPassing > ( SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE STRFTIME('%Y',t2.`date`) = '2012')",
        "amends": [],
        "rules": [
            "long name of teams refers to team_long_name; build-up play passing refers to buildUpPlayPassing; above-average build-up play passing = buildUpPlayPassing > DIVIDE(SUM(buildUpPlayPassing), COUNT(team_long_name) WHERE buildUpPlayPassing IS NOT NULL); in 2012 refers to strftime('%Y', date) = '2012'; "
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_long_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE strftime('%Y', ta.date) = '2012'\nAND ta.buildUpPlayPassing > (\n    SELECT AVG(buildUpPlayPassing)\n    FROM Team_Attributes\n    WHERE strftime('%Y', date) = '2012'\n);"
        ],
        "rule_sql": []
    },
    "510": {
        "question": "Among the cards that doesn't have multiple faces on the same card, who is the illustrator of the card art that has the highest cost of converted mana?",
        "db_id": "card_games",
        "ground_truth": "SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1",
        "amends": [],
        "rules": [
            "doesn't have multiple faces refers to side IS NULL; illustrator refers to artist"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist FROM cards WHERE otherFaceIds IS NULL ORDER BY convertedManaCost DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "312": {
        "question": "What is the carcinogenic label for bond TR001_2_4?",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.label \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.bond_id = 'TR001_2_4';"
        ],
        "rule_sql": []
    },
    "1251": {
        "question": "How many patients with an Ig G higher than normal?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
        "amends": [
            "Do add `Patient AS T1` and `Examination AS T3` as joined tables instead of querying only `Laboratory` alone. Do use `INNER JOIN` on `T1.ID = T2.ID` and `INNER JOIN` on `T3.ID = T2.ID` instead of no joins. Do specify `T1.ID` in the `COUNT(DISTINCT)` instead of just `ID` to avoid ambiguity. Do keep the `WHERE T2.IGG >= 2000` filter instead of the same condition but without table qualification. The amended query now correctly joins multiple tables and qualifies column references to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for count of patients with a specific laboratory condition: join Patient as T1, Laboratory as T2, and Examination as T3 using inner matches where T1.ID = T2.ID and T3.ID = T2.ID. 2) When filtering for Ig G higher than normal: apply the condition T2.IGG >= 2000 to identify abnormal values. 3) When counting distinct patients: use T1.ID as the counting key to avoid ambiguity across tables. 4) Output columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT ID) FROM Laboratory WHERE IGG >= 2000;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.IGG >= 2000"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.IGG >= 2000"
        ]
    },
    "1402": {
        "question": "What is the most popular size of t-shirt ordered by the club members?",
        "db_id": "student_club",
        "ground_truth": "SELECT t_shirt_size FROM member GROUP BY t_shirt_size ORDER BY COUNT(t_shirt_size) DESC LIMIT 1",
        "amends": [
            "Do select only `t_shirt_size` instead of including `COUNT(t_shirt_size) AS size_count` in the SELECT list. Do order by `COUNT(t_shirt_size)` directly instead of referencing the alias `size_count` in the ORDER BY clause. The amended query now correctly returns only the t_shirt_size with the highest count while maintaining the same grouping and limiting behavior."
        ],
        "rules": [
            "1) When the question asks for the most popular size of t-shirt: count occurrences of each t_shirt_size value and identify the one with the highest count.\n2) When counting occurrences of t-shirt sizes: use the exact column token t_shirt_size for counting.\n3) When ordering by popularity: sort the results by the count of t_shirt_size in descending order to place the most popular first.\n4) When limiting to the single most popular result: take only the first row after ordering by count in descending order.\n5) When selecting output columns: include only the t_shirt_size value, not the count itself.\nOutput columns (ordered): t_shirt_size"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t_shirt_size, COUNT(t_shirt_size) AS size_count FROM member GROUP BY t_shirt_size ORDER BY size_count DESC LIMIT 1;",
            "SELECT t_shirt_size FROM member GROUP BY t_shirt_size ORDER BY COUNT(t_shirt_size) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t_shirt_size FROM member GROUP BY t_shirt_size ORDER BY COUNT(t_shirt_size) DESC LIMIT 1;"
        ]
    },
    "1452": {
        "question": "What is the average amount paid by students in a position other than a member?",
        "db_id": "student_club",
        "ground_truth": "SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN member as T2 ON T1.link_to_member = T2.member_id WHERE T2.position != 'Member'",
        "amends": [
            "Do use `AVG(T1.cost)` instead of `SUM(e.cost) / COUNT(DISTINCT a.link_to_event)` to calculate the average expense amount directly. Do join only `expense AS T1` with `member as T2` instead of including an unnecessary `attendance a` table join. Do use `INNER JOIN` with `T1.link_to_member = T2.member_id` instead of the multi-table join structure. Do apply the filter `T2.position != 'Member'` directly in the WHERE clause instead of the original approach. Do remove the unnecessary DISTINCT operation and attendance table reference that incorrectly attempted to calculate average per event instead of average expense amount per member. The amended query now correctly calculates the average expense amount for non-Member positions by focusing only on the relevant expense and member tables."
        ],
        "rules": [
            "1) When calculating average expense amount: use AVG(T1.cost) instead of sum-and-count division. 2) When combining expense and member tables: link rows where T1.link_to_member = T2.member_id using inner match. 3) When filtering for non-Member positions: apply condition T2.position != 'Member' exactly. 4) When the question asks about students in positions other than member: focus only on expense and member tables without unnecessary attendance table joins. 5) When computing averages per member: do not use DISTINCT operations that incorrectly attempt to calculate per event instead of per member. Output columns (ordered): average_amount_paid"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(e.cost) / COUNT(DISTINCT a.link_to_event) AS average_amount_paid\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN attendance a ON m.member_id = a.link_to_member\nWHERE m.position != 'Member';",
            "SELECT AVG(T1.cost) AS average_amount\nFROM expense AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nWHERE T2.position != 'Member';"
        ],
        "rule_sql": [
            "SELECT AVG(expense.cost) AS average_amount_paid FROM expense INNER JOIN member ON expense.link_to_member = member.member_id WHERE member.position != 'Member'"
        ]
    },
    "807": {
        "question": "What is the superpowers of the superhero has Helen Parr as their full name?",
        "db_id": "superhero",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.full_name = 'Helen Parr'",
        "amends": [],
        "rules": [
            "superpowers refers to power_name; Helen Parr is the full name of superhero;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.full_name = 'Helen Parr';"
        ],
        "rule_sql": []
    },
    "1432": {
        "question": "Among the members with t-shirt size of medium, what is the percentage of the amount 50 received by the Student_Club?",
        "db_id": "student_club",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) AS REAL) * 100 / COUNT(T2.income_id) FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END)` instead of `COUNT(CASE WHEN i.amount = 50 AND i.source = 'Student_Club' THEN 1 END)` for accurate percentage calculation. Do change from `LEFT JOIN` to `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of `m.member_id = i.link_to_member` to exclude members without income records. Do add filter `T1.position = 'Member'` instead of omitting it to restrict to members only. Do remove the `source = 'Student_Club'` condition instead of keeping it to count all income records meeting the amount criteria. Do use `COUNT(T2.income_id)` instead of `COUNT(m.member_id)` to properly count income records rather than members. Do add explicit `CAST` to `REAL` instead of implicit conversion for precise floating-point division. The amended query now correctly calculates the percentage of income records with amount 50 among all income records for medium-sized members.",
            "Do move the division operation to after the multiplication instead of before it, changing the calculation order from `SUM(...) / COUNT(...) * 100` to `SUM(...) * 100 / COUNT(...)` to ensure correct percentage calculation. Do change the case sensitivity in the WHERE clause from `'medium'` to `'Medium'` to match the actual data values. Do remove the alias `AS percentage` from the SELECT clause instead of keeping it, as it's not needed in the result. Do reorder the WHERE conditions from `t_shirt_size` first to `position` first, though this is purely cosmetic. The amended query now correctly calculates the percentage of income records with amount equal to 50 among all income records for medium-sized member positions, with proper case matching and mathematical operation order."
        ],
        "rules": [
            "1) When the question asks for percentage of income records with amount 50 among medium-sized members: compute (sum of cases where T2.amount equals 50) divided by (count of T2.income_id), casting to real for precise floating-point division.\n2) When combining member table (T1) and income table (T2): link rows where T1.member_id equals T2.link_to_member using inner join instead of left join to exclude members without income records.\n3) When filtering for medium t-shirt size: include only rows where T1.t_shirt_size equals 'Medium' exactly.\n4) When restricting to members only: include only rows where T1.position equals 'Member' exactly.\n5) When counting income records: use T2.income_id as the counting key instead of member identifiers.\n6) When calculating percentage: use SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) for accurate numerator calculation instead of COUNT with conditional.\n7) Output columns (ordered): percentage",
            "1) When calculating percentages: perform multiplication by 100 before division to ensure correct percentage calculation. 2) When filtering by t_shirt_size values: use exact case-sensitive matching with 'Medium' instead of 'medium'. 3) When selecting output columns: do not include alias names in the final result. 4) When filtering member records: include only rows where position equals 'Member'. 5) When joining member and income tables: link rows where T1.member_id equals T2.link_to_member. 6) When counting income records: use T2.income_id as the counting key. 7) When calculating the percentage of amount 50: count rows where T2.amount equals 50 among all income records for medium-sized members. Output columns (ordered): the calculated percentage value"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN i.amount = 50 AND i.source = 'Student_Club' THEN 1 END) * 100.0 / COUNT(m.member_id)) AS percentage\nFROM member m\nLEFT JOIN income i ON m.member_id = i.link_to_member\nWHERE m.t_shirt_size = 'Medium';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) AS REAL) / COUNT(T2.income_id) * 100 AS percentage\nFROM \n    member T1\nINNER JOIN \n    income T2 ON T1.member_id = T2.link_to_member\nWHERE \n    T1.t_shirt_size = 'medium' \n    AND T1.position = 'Member'",
            "SELECT SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) * 100 / COUNT(T2.income_id) \nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nWHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) * 100.0 / COUNT(T2.income_id)) AS percentage\nFROM \n    member T1\nINNER JOIN \n    income T2 ON T1.member_id = T2.link_to_member\nWHERE \n    T1.t_shirt_size = 'Medium' \n    AND T1.position = 'Member';"
        ]
    },
    "730": {
        "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
        "db_id": "superhero",
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
        "amends": [],
        "rules": [
            "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; super power of \"Super Strength\" refers to power_name = 'Super Strength';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE p.publisher_name = 'Marvel Comics'\nAND sp.power_name = 'Super Strength';"
        ],
        "rule_sql": []
    },
    "651": {
        "question": "Provide the related post title of \"How to tell if something happened in a data set which monitors a value over time\".",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T3.Title FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN posts AS T3 ON T1.RelatedPostId = T3.Id WHERE T2.Title = 'How to tell if something happened in a data set which monitors a value over time'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p2.Title AS RelatedPostTitle\nFROM posts p1\nJOIN postLinks pl ON p1.Id = pl.PostId\nJOIN posts p2 ON pl.RelatedPostId = p2.Id\nWHERE p1.Title = 'How to tell if something happened in a data set which monitors a value over time';"
        ],
        "rule_sql": []
    },
    "578": {
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "amends": [],
        "rules": [
            "\"Understanding what Dassault iSight is doing?\" is the Title of post; user refers to DisplayName;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName, u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Understanding what Dassault iSight is doing?';"
        ],
        "rule_sql": []
    },
    "832": {
        "question": "Name the tallest superhero.",
        "db_id": "superhero",
        "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "amends": [],
        "rules": [
            "tallest superhero refers to MAX(height_cm);"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero_name\nFROM superhero\nWHERE height_cm = (SELECT MAX(height_cm) FROM superhero)\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "31": {
        "question": "What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?",
        "db_id": "california_schools",
        "ground_truth": "SELECT CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)` FROM frpm ORDER BY `Enrollment (K-12)` DESC LIMIT 9, 2",
        "amends": [
            "Do cast `Free Meal Count (K-12)` as `REAL` instead of using it directly in division to ensure proper numeric handling. Do remove the `School Name` column and the `Eligible Free Rate` alias instead of including them in the SELECT list. Do change the LIMIT clause to `9, 2` instead of `10, 2` to adjust the row offset and count. The amended query now correctly calculates the free meal eligibility rate with proper type casting and returns the appropriate result set."
        ],
        "rules": [
            "1) When the question asks for the \"eligible free rate\": compute the ratio of \"Free Meal Count (K-12)\" to \"Enrollment (K-12)\" with proper numeric casting of \"Free Meal Count (K-12)\" as REAL.\n2) When the question asks for specific ranked schools (10th and 11th): rank schools by \"Enrollment (K-12)\" in descending order and take rows from position 10 through 11 inclusive (using offset 9, count 2).\n3) When the question does not require school names: exclude the \"School Name\" column from the output.\n4) When computing ratios: do not use column aliases like \"Eligible Free Rate\" in the output.\n5) Output columns (ordered): (\"Free Meal Count (K-12)\" / \"Enrollment (K-12)\")"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    `School Name`,\n    `Free Meal Count (K-12)` / `Enrollment (K-12)` AS `Eligible Free Rate`\nFROM \n    frpm\nORDER BY \n    `Enrollment (K-12)` DESC\nLIMIT 10, 2;",
            "SELECT \n    CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\" AS eligible_free_rate\nFROM frpm\nWHERE \"Enrollment (K-12)\" IS NOT NULL \n    AND \"Free Meal Count (K-12)\" IS NOT NULL\nORDER BY \"Enrollment (K-12)\" DESC\nLIMIT 9, 2"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\")\nFROM frpm\nORDER BY \"Enrollment (K-12)\" DESC\nLIMIT 2 OFFSET 9;"
        ]
    },
    "1247": {
        "question": "Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'",
        "amends": [
            "Do use `T1` and `T2` table aliases instead of `P` and `L` for consistency. Do place the `FG` condition first in the WHERE clause instead of last, maintaining the same logical OR operation between `T2.FG <= 150` and `T2.FG >= 450`. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do remove the parentheses around the FG condition since operator precedence makes them unnecessary. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and results.",
            "Do use `T2.WBC > 3.5 AND T2.WBC < 9.0` instead of `T2.WBC BETWEEN 4.0 AND 10.0` for the WBC range filter. Do change the logical grouping by removing parentheses around `T2.FG <= 150 OR T2.FG >= 450` instead of keeping them, allowing proper operator precedence with the AND conditions. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.SEX = 'M'` filter without changes. The amended query now correctly implements the intended logic with adjusted WBC thresholds and proper condition grouping to match the RIGHT_SQL's behavior.",
            "Do use parentheses to properly group the `OR` condition `(T2.FG <= 150 OR T2.FG >= 450)` instead of applying it without grouping, which would incorrectly combine with the `AND` conditions due to operator precedence. Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` clause, `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` join structure, and all filter conditions including `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0`, and the FG range check, but ensure the logical grouping preserves the intended OR relationship between the FG thresholds. The amended query now correctly counts distinct male patients with WBC values between 3.5 and 9.0 and FG values either \u2264150 or \u2265450, matching the RIGHT_SQL's behavior.",
            "Do use the correct operator precedence with parentheses around `T2.FG <= 150 OR T2.FG >= 450` instead of incorrectly grouping it, and maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and all filter conditions including `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0`, and the FG range check. The amended query now correctly evaluates the logical conditions and matches RIGHT_SQL's behavior.",
            "Do use parentheses to properly group the `OR` condition `T2.FG <= 150 OR T2.FG >= 450` instead of having it incorrectly grouped with the `AND` conditions, which changes the logical evaluation order. Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` clause, `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` join structure, and all individual filter conditions including `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0`, and the FG range check, but with corrected operator precedence. The amended query now correctly evaluates the logical conditions to match the intended behavior.",
            "Do move the `T2.FG <= 150 OR T2.FG >= 450` condition to the beginning of the WHERE clause instead of placing it at the end, and do remove the parentheses around the FG condition instead of keeping them, while maintaining all other elements including the `COUNT(DISTINCT T1.ID)`, `INNER JOIN` on `T1.ID = T2.ID`, and the remaining filters `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0` unchanged. The amended query now matches RIGHT_SQL's behavior by preserving the same logical conditions while adjusting the syntax structure."
        ],
        "rules": [
            "1) When the question mentions \"male patients\": filter rows where T1.SEX equals exactly 'M'.\n2) When the question mentions \"normal level of white blood cells\": filter rows where T2.WBC is greater than 3.5 and less than 9.0.\n3) When the question mentions \"abnormal fibrinogen level\": filter rows where T2.FG is less than or equal to 150 or greater than or equal to 450.\n4) When combining T1 and T2 for shared entities: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match).\n5) When the question asks for \"how many of them\": count the number of distinct T1.ID values.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When the question asks for male patients: filter rows where T1.SEX equals exactly 'M'. 2) When the question asks for patients with normal white blood cells: filter rows where T2.WBC is greater than 3.5 and less than 9.0. 3) When the question asks for patients with abnormal fibrinogen level: filter rows where T2.FG is less than or equal to 150 or greater than or equal to 450. 4) When counting distinct patients: count the number of unique values of T1.ID. 5) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs. Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When the question asks for male patients: filter rows where T1.SEX equals exactly 'M'.\n2) When the question mentions patients with normal white blood cells: filter rows where T2.WBC is greater than 3.5 and less than 9.0.\n3) When the question asks for abnormal fibrinogen level: filter rows where T2.FG is less than or equal to 150 or greater than or equal to 450, and ensure this condition is properly grouped with parentheses.\n4) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match).\n5) When counting distinct male patients: count the number of unique values of T1.ID that satisfy all the specified conditions.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When the question asks for male patients: filter rows where T1.SEX equals 'M' exactly. 2) When the question asks for patients with normal white blood cells: filter rows where T2.WBC is greater than 3.5 and less than 9.0. 3) When the question asks for patients with abnormal fibrinogen level: filter rows where T2.FG is less than or equal to 150 or greater than or equal to 450, and group these conditions with parentheses to ensure correct operator precedence. 4) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match). 5) When counting distinct male patients: compute the number of unique values of T1.ID. 6) Output columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting distinct male patients: use T1.ID as the counting key with exact identifier case and quotes.\n2) When filtering for male patients: use the exact literal 'M' for T1.SEX comparison with case-sensitive matching.\n3) When identifying normal white blood cell levels: use the range T2.WBC > 3.5 AND T2.WBC < 9.0 with exact numeric bounds.\n4) When identifying abnormal fibrinogen levels: use the condition (T2.FG <= 150 OR T2.FG >= 450) with exact numeric bounds and proper parentheses grouping.\n5) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using exact identifier equality and perform inner matching only.\n6) When handling logical conditions: group OR conditions with parentheses to ensure proper operator precedence evaluation.\nOutput columns (ordered): COUNT(DISTINCT T1.ID)",
            "1) When counting distinct patients: use COUNT(DISTINCT T1.ID) as the counting mechanism. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for male patients: include only rows where T1.SEX = 'M'. 4) When filtering for normal white blood cell levels: include only rows where T2.WBC > 3.5 AND T2.WBC < 9.0. 5) When filtering for abnormal fibrinogen levels: place the condition T2.FG <= 150 OR T2.FG >= 450 at the beginning of the filtering conditions and do not use parentheses around this condition. 6) Output columns (ordered): COUNT(DISTINCT T1.ID)"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' \nAND L.WBC > 3.5 AND L.WBC < 9.0 \nAND (L.FG <= 150 OR L.FG >= 450);",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC BETWEEN 4.0 AND 10.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.FG <= 150 OR T2.FG >= 450\nAND T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)"
        ]
    },
    "1096": {
        "question": "Calculate the average overall rating of Pietro Marino.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Pietro Marino'",
        "amends": [],
        "rules": [
            "Pietro Marino refers to player_name = 'Pietro Marino'; average overall rating AVG(T1.overall_rating)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Pietro Marino');"
        ],
        "rule_sql": []
    },
    "1205": {
        "question": "Was the patient with the number 57266's uric acid within a normal range?",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 57266",
        "amends": [
            "Do use a boolean expression returning `true`/`false` instead of string labels `'Normal'`/`'Not Normal'` in the CASE statement. Do change the CASE logic to `(T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0)` instead of separate WHEN clauses with different thresholds. Do use table aliases `T1` and `T2` instead of `P` and `L` for the Patient and Laboratory tables. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do remove the column selection `P.SEX, L.UA` and only return the boolean result instead of including source columns. The amended query now correctly returns a boolean evaluation of uric acid status matching the specified gender-based thresholds.",
            "Do reverse the CASE WHEN logic to return `true` instead of `false` for abnormal uric acid conditions and `false` instead of `true` for normal conditions. Do remove the `ORDER BY T2.Date DESC LIMIT 1` clause instead of keeping it, as the right query returns all matching records rather than just the most recent one. Do remove the `AS is_normal_uric_acid` alias instead of including it, as the right query returns an unaliased result. The amended query now correctly identifies abnormal uric acid levels with true/false values and returns all relevant records without limiting to the most recent laboratory result."
        ],
        "rules": [
            "1) When the question asks about a specific patient by ID number: filter rows where T1.ID equals the exact numeric value 57266.\n2) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID equals T2.ID using an inner match.\n3) When evaluating uric acid status with gender-based thresholds: use the condition (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) to determine if within normal range.\n4) When returning boolean evaluation results: output only the true/false result of the condition without including source columns.\n5) Output columns (ordered): the boolean result of the uric acid evaluation condition",
            "1) When the question asks about uric acid levels for a specific patient ID: filter records to only include rows where T1.ID equals the exact patient number 57266.\n2) When determining normal uric acid ranges based on patient sex: use different threshold values for males and females, where for females (T1.SEX = 'F') the abnormal threshold is UA > 6.5, and for males (T1.SEX = 'M') the abnormal threshold is UA > 8.0.\n3) When evaluating uric acid test results: return true when the uric acid level (T2.UA) exceeds the sex-specific abnormal threshold, and false when it is within normal range.\n4) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID to associate laboratory results with the correct patient.\n5) When the question asks about all relevant records: return all matching records without limiting to the most recent result or applying any ordering.\n6) When returning results: do not apply any column aliases to the output.\nOutput columns (ordered): CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    P.SEX,\n    L.UA,\n    CASE \n        WHEN P.SEX = 'M' AND L.UA > 8.0 THEN 'Normal'\n        WHEN P.SEX = 'F' AND L.UA > 6.5 THEN 'Normal'\n        ELSE 'Not Normal'\n    END AS UricAcidStatus\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.ID = 57266;",
            "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN false ELSE true END AS is_normal_uric_acid\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.ID = 57266\nORDER BY T2.Date DESC\nLIMIT 1;",
            "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T1.ID = 57266"
        ],
        "rule_sql": [
            "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.ID = 57266"
        ]
    },
    "173": {
        "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
        "amends": [
            "Do join `account` table as `T1` instead of querying only `trans` table. Do use a subquery on `order` table with `SUM(amount)` grouped by `account_id` and `k_symbol` instead of aggregating directly on `trans` table. Do filter on `account_id = 3` in the WHERE clause instead of in a separate query. Do check for `total_amount = 3539` instead of using HAVING with the same value. Do select `T1.frequency` and `T2.k_symbol` instead of counting statement requests or showing k_symbol with total debit. Do remove the LIKE filter on k_symbol for statements instead of keeping it. The amended query now correctly identifies accounts with specific transaction totals rather than counting statement requests or showing aggregate amounts by k_symbol alone."
        ],
        "rules": [
            "1) When the question asks about account number 3: filter rows where T1.account_id = 3.\n2) When the question asks about debiting 3539 in total: check for total_amount = 3539 instead of using HAVING clause aggregation.\n3) When combining account and transaction data: join account table as T1 with trans table instead of querying only trans table.\n4) When calculating transaction totals: use a subquery on trans table with SUM(amount) grouped by account_id and k_symbol instead of aggregating directly on trans table.\n5) When selecting output columns: choose T1.frequency and T2.k_symbol instead of counting statement requests or showing k_symbol with total debit.\n6) When handling k_symbol filtering: remove the LIKE filter on k_symbol for statements instead of keeping pattern matching.\n7) Output columns (ordered): T1.frequency, T2.k_symbol"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "-- Query to find how often account number 3 requests an account statement to be released\nSELECT COUNT(*) AS statement_request_count\nFROM trans\nWHERE account_id = 3 AND k_symbol LIKE '%statement%';\n\n-- Query to find the aim of debiting 3539 in total\nSELECT k_symbol, SUM(amount) AS total_debit\nFROM trans\nGROUP BY k_symbol\nHAVING SUM(amount) = 3539;",
            "SELECT T1.frequency, T2.k_symbol\nFROM account AS T1\nJOIN (\n    SELECT account_id, k_symbol, SUM(amount) AS total_amount\n    FROM `order`\n    GROUP BY account_id, k_symbol\n) AS T2 ON T1.account_id = T2.account_id\nWHERE T1.account_id = 3 AND T2.total_amount = 3539"
        ],
        "rule_sql": [
            "SELECT T1.frequency, T2.k_symbol\nFROM account T1\nJOIN (\n    SELECT account_id, k_symbol, SUM(amount) as total_amount\n    FROM trans\n    GROUP BY account_id, k_symbol\n) T2 ON T1.account_id = T2.account_id\nWHERE T1.account_id = 3\nAND T2.total_amount = 3539"
        ]
    },
    "733": {
        "question": "How many gold-eyed superheroes did Marvel Comics publish?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.colour = 'Gold'",
        "amends": [],
        "rules": [
            "gold-eyed refers to colour = 'Gold' where eye_colour_id = colour.id; superheroes that Marvel Comics published refers to publisher_name = 'Marvel Comics'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE eye_colour_id = (SELECT id FROM colour WHERE colour = 'Gold') \nAND publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');"
        ],
        "rule_sql": []
    },
    "167": {
        "question": "List all the clients' IDs whose junior credit cards were issued after 1996.",
        "db_id": "financial",
        "ground_truth": "SELECT T2.client_id FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'junior' AND T1.issued >= '1997-01-01'",
        "amends": [],
        "rules": [
            "After 1996 means date > = '1997-01-01"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.type = 'junior' AND strftime('%Y', ca.issued) > '1996';"
        ],
        "rule_sql": []
    },
    "63": {
        "question": "In chartered schools with charter number 00D2, what are the names of all the administrators? Include the name of the school and the city to which it belongs",
        "db_id": "california_schools",
        "ground_truth": "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2'",
        "amends": [
            "Do select only `AdmFName1`, `AdmLName1`, `School`, and `City` columns instead of including concatenated administrator names and additional aliases. Do remove the concatenation expressions `AdmFName1 || ' ' || AdmLName1`, `AdmFName2 || ' ' || AdmLName2`, and `AdmFName3 || ' ' || AdmLName3` instead of keeping them. Do omit the column aliases \"School Name\", \"City\", \"Administrator 1\", \"Administrator 2\", and \"Administrator 3\" instead of including them. The amended query now correctly returns only the specified columns without unnecessary transformations or aliasing, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for administrators in chartered schools with charter number 00D2: select only the columns AdmFName1, AdmLName1, School, and City from the schools table.\n2) When filtering for chartered schools with specific charter number: include only rows where Charter = 1 and CharterNum = '00D2' exactly.\n3) When outputting results: do not concatenate administrator names or apply any column aliases, return the raw column values as they appear in the table.\n4) When handling text literals: preserve the exact value '00D2' with the specified case and no quotes in the filter condition.\n5) Output columns (ordered): AdmFName1, AdmLName1, School, City"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    School AS \"School Name\",\n    City AS \"City\",\n    AdmFName1 || ' ' || AdmLName1 AS \"Administrator 1\",\n    AdmFName2 || ' ' || AdmLName2 AS \"Administrator 2\",\n    AdmFName3 || ' ' || AdmLName3 AS \"Administrator 3\"\nFROM \n    schools\nWHERE \n    Charter = 1 \n    AND CharterNum = '00D2';",
            "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE CharterNum = '00D2'"
        ],
        "rule_sql": [
            "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2'"
        ]
    },
    "320": {
        "question": "What is the type of the bond which is presenting the connection between two atoms TR000_1 and TR000_2?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'",
        "amends": [],
        "rules": [
            "type of bond refers to bond_type; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR000_1' AND c.atom_id2 = 'TR000_2') OR (c.atom_id = 'TR000_2' AND c.atom_id2 = 'TR000_1');"
        ],
        "rule_sql": []
    },
    "1015": {
        "question": "In which Formula_1 race was the lap record for the Austrian Grand Prix Circuit set?",
        "db_id": "formula_1",
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T2.name FROM races AS T2 INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN results AS T1 on T2.raceId = T1.raceId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix'",
        "amends": [
            "Do use a CTE `fastest_lap_times` to convert `FastestLapTime` to seconds instead of directly using `MIN(r.time)`. Do select only `T2.name` instead of multiple columns `r.raceId, r.year, r.name`. Do join `circuits` with condition `T2.name = 'Austrian Grand Prix'` instead of `c.name = 'Austrian Grand Prix Circuit'`. Do add complex time conversion using `SUBSTR`, `INSTR`, and `CAST` operations on `FastestLapTime` instead of simple `res.time IS NOT NULL`. Do use a subquery to find the minimum time in seconds instead of direct aggregation. Do join on the converted time matching the minimum time instead of simple grouping. Do remove explicit `GROUP BY` and `ORDER BY` clauses instead of keeping them. The amended query now correctly identifies the Austrian Grand Prix race with the fastest lap time using proper time conversion and comparison logic.",
            "Do remove `r.year`, `r.name`, and `c.name AS circuit_name` from the CTE SELECT list instead of including them. Do change the time conversion calculation to handle milliseconds by adding `(CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000)` instead of the simpler conversion that ignores milliseconds. Do remove the joins to `races` and `circuits` from the CTE instead of keeping them. Do change the main query to join `races AS T2`, `circuits AS T3`, and `results AS T1` directly instead of using the CTE as the primary source. Do move the circuit filter to `WHERE T2.name = 'Austrian Grand Prix'` instead of filtering on `c.name`. Do use a subquery to calculate `MIN(time_in_seconds)` with proper joins to `races` and `circuits` instead of the incorrect CTE-based approach. Do change the join condition to match the precise time calculation with milliseconds instead of the simplified time comparison. The amended query now correctly handles millisecond precision in lap times and properly filters for the Austrian Grand Prix, matching the RIGHT_SQL's behavior.",
            "Do use a CTE `fastest_lap_times` to precompute time conversions instead of repeating the complex time calculation in multiple places. Do add proper table aliases `T1`, `T2`, `T3` for clarity instead of ambiguous joins. Do include `WHERE T1.FastestLapTime IS NOT NULL` in the CTE instead of filtering later. Do join `circuits` through `races.circuitId = circuits.circuitId` instead of incorrect join paths. Do calculate the minimum time in a subquery that joins `fastest_lap_times` with `races` and `circuits` filtered for 'Austrian Grand Prix' instead of incorrect aggregation scope. Do use the precomputed `time_in_seconds` from the CTE in the final join condition instead of recalculating the complex time conversion. Do maintain the filter `WHERE T2.name = 'Austrian Grand Prix'` in the main query instead of omitting it. The amended query now correctly identifies races with the fastest lap times for the Austrian Grand Prix by properly handling time conversions and join relationships.",
            "Do join `races` and `circuits` directly instead of using the CTE as the primary source, and do add an explicit `INNER JOIN` on `results` instead of relying on the CTE join. Do move the minimum time calculation to a subquery `T4` instead of using a correlated subquery in the `WHERE` clause. Do change the join condition to compare the calculated lap time directly with `T4.min_time_in_seconds` instead of using the CTE-derived `time_in_seconds`. Do keep the `WHERE` filter on `T2.name = 'Austrian Grand Prix'` but apply it to both the main query and the subquery instead of only in the subquery. The amended query now correctly identifies races with the fastest lap time by performing the time calculation consistently across both the main table and subquery, ensuring accurate comparison and matching behavior with the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for a Formula 1 race with a lap record: use the exact circuit name literal 'Austrian Grand Prix' instead of 'Austrian Grand Prix Circuit'.\n2) When converting lap times from the FastestLapTime column: convert to seconds using SUBSTR, INSTR, and CAST operations instead of direct time comparisons.\n3) When finding the minimum lap time: use a subquery to compute the minimum converted time in seconds instead of direct aggregation with MIN().\n4) When joining tables for lap time analysis: match rows where the converted lap time equals the minimum converted time instead of using GROUP BY and ORDER BY.\n5) When selecting output columns: return only the race name (T2.name) instead of multiple race identifiers.\n6) When combining circuit and race data: link rows where T1.circuitId = T2.circuitId to connect circuits to their races.\n7) Output columns (ordered): T2.name",
            "1) When the question asks for the race where a lap record was set: identify the race by name from the races table using alias T2.\n2) When handling lap time data with milliseconds: convert the fastestLapTime by extracting minutes, seconds, and milliseconds using exact string positions and calculations as shown in the amends.\n3) When filtering for a specific circuit: use the exact literal 'Austrian Grand Prix' with the races table name column (T2.name).\n4) When finding the minimum lap time: calculate the minimum converted time in seconds including millisecond precision.\n5) When combining tables for race results: link results (T1), races (T2), and circuits (T3) using their canonical key relationships as implied by the amends.\n6) When comparing lap times for record determination: match the exact calculated time including milliseconds to the minimum time found.\n7) Output columns (ordered): T2.name",
            "1) When computing fastest lap times: precompute time conversions in a CTE called fastest_lap_times instead of repeating complex calculations. 2) When joining multiple tables: use proper table aliases T1, T2, T3 for clarity instead of ambiguous joins. 3) When filtering for valid lap times: include WHERE T1.FastestLapTime IS NOT NULL in the CTE instead of filtering later. 4) When joining circuits table: link through races.circuitId = circuits.circuitId instead of incorrect join paths. 5) When finding minimum lap time for Austrian Grand Prix: calculate in a subquery that joins fastest_lap_times with races and circuits filtered for 'Austrian Grand Prix' instead of incorrect aggregation scope. 6) When comparing lap times: use the precomputed time_in_seconds from the CTE in final join conditions instead of recalculating complex time conversions. 7) When filtering for specific circuit: maintain WHERE T2.name = 'Austrian Grand Prix' in the main query instead of omitting it. Output columns (ordered): [race identification columns as implied by the query structure]",
            "1) When the question asks for the race where a lap record was set for a specific circuit: join tables \"races\" as T2, \"circuits\" as T3, and \"results\" as T1 using the exact key relationships T1.raceId = T2.raceId and T2.circuitId = T3.circuitId with inner matches only.\n2) When filtering for the Austrian Grand Prix circuit: apply the exact literal filter T2.name = 'Austrian Grand Prix' to both the main query and any subqueries.\n3) When calculating lap times from the FastestLapTime column: convert the time format using the exact calculation method shown in the amends (substring extraction and arithmetic conversion to seconds).\n4) When finding the minimum lap time: compute the minimum converted time in seconds using a subquery that applies the same circuit filter and time calculation method.\n5) When identifying the record-setting race: compare the calculated lap time in seconds from each result with the overall minimum time to find exact matches.\nOutput columns (ordered): T2.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.raceId, r.year, r.name, MIN(r.time) AS fastest_lap_time\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nJOIN results res ON r.raceId = res.raceId\nWHERE c.name = 'Austrian Grand Prix Circuit' AND res.time IS NOT NULL\nGROUP BY r.raceId, r.year, r.name\nORDER BY fastest_lap_time ASC\nLIMIT 1;",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.year,\n        r.name,\n        c.name AS circuit_name,\n        res.fastestLapTime,\n        CAST(SUBSTR(res.fastestLapTime, 1, INSTR(res.fastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, ':') + 1) AS REAL) AS time_in_seconds\n    FROM results res\n    JOIN races r ON res.raceId = r.raceId\n    JOIN circuits c ON r.circuitId = c.circuitId\n    WHERE res.fastestLapTime IS NOT NULL\n)\nSELECT T2.name\nFROM fastest_lap_times T2\nJOIN circuits c ON T2.circuit_name = c.name\nWHERE c.name = 'Austrian Grand Prix'\nAND T2.time_in_seconds = (\n    SELECT MIN(time_in_seconds)\n    FROM fastest_lap_times T1\n    JOIN circuits c1 ON T1.circuit_name = c1.name\n    WHERE c1.name = 'Austrian Grand Prix'\n)",
            "error",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.FastestLapTime,\n        (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 + \n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + \n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results AS T1\n    WHERE T1.FastestLapTime IS NOT NULL\n)\nSELECT T2.name\nFROM fastest_lap_times AS flt\nJOIN races AS T2 ON flt.raceId = T2.raceId\nJOIN circuits AS T3 ON T2.circuitId = T3.circuitId\nWHERE T2.name = 'Austrian Grand Prix'\nAND flt.time_in_seconds = (\n    SELECT MIN(flt2.time_in_seconds)\n    FROM fastest_lap_times AS flt2\n    JOIN races AS r2 ON flt2.raceId = r2.raceId\n    JOIN circuits AS c2 ON r2.circuitId = c2.circuitId\n    WHERE r2.name = 'Austrian Grand Prix'\n)",
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.FastestLapTime,\n        (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + \n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + \n        (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) AS time_in_seconds\n    FROM results AS T1\n    WHERE T1.FastestLapTime IS NOT NULL\n)\nSELECT T2.name\nFROM races AS T2\nINNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId\nINNER JOIN fastest_lap_times AS T1 ON T2.raceId = T1.raceId\nWHERE T2.name = 'Austrian Grand Prix'\nAND T1.time_in_seconds = (\n    SELECT MIN(T1.time_in_seconds)\n    FROM fastest_lap_times AS T1\n    INNER JOIN races AS T2 ON T1.raceId = T2.raceId\n    INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId\n    WHERE T2.name = 'Austrian Grand Prix'\n)"
        ],
        "rule_sql": [
            "WITH fastest_lap_times AS (\n    SELECT \n        T1.raceId,\n        T1.driverId,\n        T1.FastestLapTime,\n        CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results T1\n    WHERE T1.FastestLapTime IS NOT NULL\n)\nSELECT T2.name\nFROM fastest_lap_times flt\nJOIN races T2 ON flt.raceId = T2.raceId\nJOIN circuits T3 ON T2.circuitId = T3.circuitId\nWHERE T2.name = 'Austrian Grand Prix'\nAND flt.time_in_seconds = (\n    SELECT MIN(flt_sub.time_in_seconds)\n    FROM fastest_lap_times flt_sub\n    JOIN races T2_sub ON flt_sub.raceId = T2_sub.raceId\n    JOIN circuits T3_sub ON T2_sub.circuitId = T3_sub.circuitId\n    WHERE T2_sub.name = 'Austrian Grand Prix'\n)\nLIMIT 1;"
        ]
    },
    "576": {
        "question": "Name the user that commented 'thank you user93!'",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'thank you user93!'",
        "amends": [],
        "rules": [
            "\"thank you user93\" is the Text of comment; user refers to DisplayName"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Text = 'thank you user93!';"
        ],
        "rule_sql": []
    },
    "648": {
        "question": "Provide the users' display names and available website URLs of the post with favorite count of more than 150.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT T1.DisplayName, T1.WebsiteUrl FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.FavoriteCount > 150",
        "amends": [],
        "rules": [
            "favorite count of more than 150 refers to FavoriteCount > 150;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName, u.WebsiteUrl \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE p.FavoriteCount > 150;"
        ],
        "rule_sql": []
    },
    "1494": {
        "question": "What percentage of Slovakian gas stations are premium?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT CAST(SUM(IIF(Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / COUNT(GasStationID) FROM gasstations WHERE Country = 'SVK'",
        "amends": [
            "Do use `SUM(IIF(Segment = 'Premium', 1, 0))` instead of `COUNT(CASE WHEN Segment = 'Premium' THEN 1 END)` for counting premium segments. Do cast the sum to `FLOAT` instead of using `100.0` for proper decimal division. Do divide by `COUNT(GasStationID)` instead of `COUNT(*)` to count specific identifiers rather than all rows. Do change the country filter to `'SVK'` instead of `'Slovakia'` to use the country code format. Do remove the column alias `PercentagePremium` instead of keeping it. The amended query now correctly calculates the percentage using proper counting and casting methods with the appropriate country code filter."
        ],
        "rules": [
            "1) When counting premium gas stations: use SUM(IIF(Segment = 'Premium', 1, 0)) instead of COUNT(CASE WHEN Segment = 'Premium' THEN 1 END). 2) When performing decimal division: cast the sum to FLOAT instead of using 100.0 for proper decimal division. 3) When counting gas stations: use COUNT(GasStationID) instead of COUNT(*) to count specific identifiers rather than all rows. 4) When filtering by country: use 'SVK' instead of 'Slovakia' to use the country code format. 5) When calculating percentages: do not include column aliases in the output. Output columns (ordered): (SUM(IIF(Segment = 'Premium', 1, 0)) * 100.0 / COUNT(GasStationID))"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN Segment = 'Premium' THEN 1 END) * 100.0 / COUNT(*)) AS PercentagePremium\nFROM \n    gasstations\nWHERE \n    Country = 'Slovakia';",
            "SELECT (SUM(IIF(Segment = 'Premium', 1, 0)) * 100.0 / COUNT(GasStationID)) FROM gasstations WHERE Country = 'SVK';"
        ],
        "rule_sql": [
            "SELECT (SUM(IIF(Segment = 'Premium', 1, 0)) * 100.0 / COUNT(GasStationID)) FROM gasstations WHERE Country = 'SVK';"
        ]
    },
    "291": {
        "question": "How many chemical compounds in the database are identified as carcinogenic.",
        "db_id": "toxicology",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecule WHERE label = '+';"
        ],
        "rule_sql": []
    },
    "157": {
        "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
        "db_id": "financial",
        "ground_truth": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
        "amends": [],
        "rules": [
            "A15 contains information about number of committed crimes in 1995"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT A15 AS number_of_crimes_1995 FROM district WHERE district_id = (SELECT district_id FROM account WHERE account_id = 532);"
        ],
        "rule_sql": []
    },
    "33": {
        "question": "If there are any, what are the websites address of the schools with a free meal count of 1,900-2,000 to students aged 5-17? Include the name of the school.",
        "db_id": "california_schools",
        "ground_truth": "SELECT T2.Website, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000 AND T2.Website IS NOT NULL",
        "amends": [
            "Do select `T2.Website` and `T1.School Name` instead of `s.School` and `s.Website`. Do use `INNER JOIN` with alias `T1` for frpm and `T2` for schools instead of unaliased `f` and `s`. Do join on `T1.CDSCode = T2.CDSCode` instead of `f.CDSCode = s.CDSCode`. Do add filter `T2.Website IS NOT NULL` instead of omitting it. The amended query now correctly selects the website from the schools table and school name from frpm while ensuring non-null website values, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for school websites and school names: select T2.Website and T1.\"School Name\" as output columns. 2) When combining frpm and schools tables: link rows where T1.CDSCode equals T2.CDSCode and keep only matching pairs (inner match). 3) When filtering for free meal count between 1900 and 2000 for students aged 5-17: include only rows where T1.\"Free Meal Count (Ages 5-17)\" is between 1900 and 2000 inclusive. 4) When selecting website addresses: ensure T2.Website is not null. 5) Output columns (ordered): T2.Website, T1.\"School Name\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.School, s.Website\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.\"Free Meal Count (Ages 5-17)\" BETWEEN 1900 AND 2000;",
            "SELECT T2.Website, T1.\"School Name\"\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Free Meal Count (Ages 5-17)\" BETWEEN 1900 AND 2000\nAND T2.Website IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT T2.Website, T1.\"School Name\"\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Free Meal Count (Ages 5-17)\" BETWEEN 1900 AND 2000\nAND T2.Website IS NOT NULL;"
        ]
    },
    "949": {
        "question": "Which constructor has the highest point?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId ORDER BY T1.points DESC LIMIT 1",
        "amends": [
            "Do select only `T2.name` instead of `c.name, SUM(cs.points) AS total_points`. Do remove the `SUM` aggregate function and `GROUP BY cs.constructorId` instead of including them. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `cs` and `c`. Do keep the join condition `T1.constructorId = T2.constructorId` instead of `cs.constructorId = c.constructorId`. Do order by `T1.points DESC` instead of the aggregated `total_points DESC`. Do maintain `LIMIT 1` as in the original. The amended query now correctly retrieves the constructor with the highest points from a single standings record rather than attempting to sum points across multiple records."
        ],
        "rules": [
            "1) When the question asks for the constructor with the highest point: select only T2.name as the output column. 2) When combining constructor standings and constructors tables: link rows where T1.constructorId = T2.constructorId using an inner match. 3) When ordering to find the highest point: sort rows by T1.points in descending order. 4) When retrieving only the top result: keep the first row after ordering. 5) Output columns (ordered): T2.name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, SUM(cs.points) AS total_points\nFROM constructorStandings cs\nJOIN constructors c ON cs.constructorId = c.constructorId\nGROUP BY cs.constructorId\nORDER BY total_points DESC\nLIMIT 1;",
            "SELECT T2.name\nFROM constructorStandings T1\nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId\nORDER BY T1.points DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM constructorStandings T1\nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId\nORDER BY T1.points DESC\nLIMIT 1"
        ]
    },
    "1215": {
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "amends": [
            "Do use `T2.TP - 8.5` without an alias instead of `(L.TP - 8.5) AS TP_Deviation` with an alias. Do reference `T2.TP` instead of `L.TP` in the SELECT expression. Do use table aliases `T1` and `T2` instead of `P` and `L` throughout the query. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly matches the RIGHT_SQL's behavior without the column alias while maintaining the same logical filtering and calculation.",
            "Do use the literal 'F' for the SEX filter instead of 'female' to match the correct gender code representation. The amended query now correctly filters for female patients using the standardized code 'F' while maintaining the same join logic and calculation of TP - 8.5, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for female patients: filter rows where T1.SEX equals exactly 'F'. 2) When the question asks for patients with total protein beyond normal index: filter rows where T2.TP is greater than 8.5. 3) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner match). 4) When calculating deviation from normal TP index: compute T2.TP minus 8.5 without adding an alias. 5) Output columns (ordered): T1.ID, T2.TP - 8.5",
            "1) When filtering for female patients: use the exact literal 'F' for the SEX column instead of 'female' to match the standardized gender code representation. 2) When calculating deviation from normal TP index: compute T2.TP - 8.5 as the deviation value. 3) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 4) When filtering for abnormal TP values: include only rows where T2.TP > 8.5. 5) Output columns (ordered): T2.TP - 8.5"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT P.ID, (L.TP - 8.5) AS TP_Deviation\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'F' AND L.TP > 8.5;",
            "SELECT T2.TP - 8.5\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'female' AND T2.TP > 8.5",
            "SELECT T2.TP - 8.5\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F' AND T2.TP > 8.5"
        ],
        "rule_sql": [
            "SELECT T1.ID, T2.TP - 8.5\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F' AND T2.TP > 8.5"
        ]
    },
    "1340": {
        "question": "Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.",
        "db_id": "student_club",
        "ground_truth": "SELECT SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS num FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
        "amends": [],
        "rules": [
            "The first 4 strings of the event_date values in the event table can represent year; The difference of the total amount spent = SUBTRACT(spent where YEAR(event_date) = 2019, spent where YEAR(event_date) = 2020)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COALESCE(SUM(b.spent), 0) \n     FROM budget b \n     JOIN event e ON b.link_to_event = e.event_id \n     WHERE SUBSTR(e.event_date, 1, 4) = '2019') -\n    (SELECT COALESCE(SUM(b.spent), 0) \n     FROM budget b \n     JOIN event e ON b.link_to_event = e.event_id \n     WHERE SUBSTR(e.event_date, 1, 4) = '2020') AS difference_in_spending;"
        ],
        "rule_sql": []
    },
    "677": {
        "question": "How many posts did Jay Stevens have in 2010?",
        "db_id": "codebase_community",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2010' AND T1.DisplayName = 'Jay Stevens'",
        "amends": [],
        "rules": [
            "DisplayName = 'Jay Stevens'; in 2010 refers to YEAR(CreationDate) = 2010;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS post_count\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE users.DisplayName = 'Jay Stevens'\nAND strftime('%Y', posts.CreaionDate) = '2010';"
        ],
        "rule_sql": []
    },
    "1221": {
        "question": "Provide the ID, sex, birthday of all patients diagnosed with 'RA' that are within the UN normal index.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN < 30 AND T1.Diagnosis = 'RA'",
        "amends": [],
        "rules": [
            "within the UN normal index refers to UN < 30; Diagnosis = 'RA'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT P.ID, P.SEX, P.Birthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'RA' AND L.UN < 30;"
        ],
        "rule_sql": []
    },
    "774": {
        "question": "Which group does superhero A-Bomb belong to?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'",
        "amends": [],
        "rules": [
            "group refers to race; A-Bomb refers to superhero_name = 'A-Bomb';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.race \nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.superhero_name = 'A-Bomb';"
        ],
        "rule_sql": []
    },
    "334": {
        "question": "What is the element with the atom ID of TR004_7 in molecule that is not carcinogenic?",
        "db_id": "toxicology",
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR004_7' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.element \nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.atom_id = 'TR004_7' AND m.label != 'carcinogenic';"
        ],
        "rule_sql": []
    },
    "379": {
        "question": "What are the cards belong to duel deck a? List the ID.",
        "db_id": "card_games",
        "ground_truth": "SELECT id FROM cards WHERE duelDeck = 'a'",
        "amends": [],
        "rules": [
            "duel deck a refers to duelDeck = a;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM cards WHERE duelDeck = 'a';"
        ],
        "rule_sql": []
    },
    "470": {
        "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "amends": [
            "Do use `DISTINCT` on the result set instead of potentially returning duplicate release dates. Do reference the table as `T2` instead of `s` for the releaseDate column. Do use explicit `INNER JOIN` instead of just `JOIN` for clarity. Do reverse the join condition to `T2.code = T1.setCode` instead of `c.setCode = s.code` to maintain consistent table reference order. Do use table aliases `T1` and `T2` instead of `c` and `s` for standardized naming. The amended query now correctly returns distinct release dates without duplicates and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for release dates of cards with a specific name: filter rows where T1.name equals exactly 'Ancestor\\'s Chosen'.\n2) When combining T1 and T2 for shared entities: link rows where T2.code equals T1.setCode exactly; keep only matching pairs (inner match).\n3) When the question asks for distinct values of a column: return only unique values of T2.releaseDate without duplicates.\n4) Output columns (ordered): T2.releaseDate"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.releaseDate \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Ancestor\\'s Chosen';",
            "SELECT DISTINCT T2.releaseDate FROM cards T1 INNER JOIN sets T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.releaseDate\nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Ancestor''s Chosen'"
        ]
    },
    "724": {
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "amends": [],
        "rules": [
            "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; blond hair refers to colour = 'Blond' and hair_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id AND eye_colour.colour = 'Blue'\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id AND hair_colour.colour = 'Blond';\n"
        ],
        "rule_sql": []
    },
    "587": {
        "question": "Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.",
        "db_id": "codebase_community",
        "ground_truth": "SELECT AVG(T2.ViewCount), T2.Title, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.PostId  WHERE T2.Tags = '<humor>' GROUP BY T2.Title, T1.Text ",
        "amends": [
            "Do use `AVG(T2.ViewCount)` as the first column instead of placing `p.Title` first in the SELECT list. Do reference `T2.Title` and `T1.Text` instead of using aliases `p.Title` and `c.Text AS Comment`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with aliases `p` and `c`. Do use exact equality comparison `T2.Tags = '<humor>'` instead of pattern matching `LIKE '%<humor>%'` for the tag filter. Do group by `T2.Title, T1.Text` instead of including the unnecessary `p.Id` in the GROUP BY clause. The amended query now correctly calculates average view counts for humor-tagged posts with their comments using proper equality matching and optimized grouping."
        ],
        "rules": [
            "1) When the question asks for average view count of posts: compute the average of T2.ViewCount.\n2) When the question specifies posts tagged as 'humor': filter rows where T2.Tags equals exactly '<humor>'.\n3) When combining posts and comments tables: link rows where T2.Id equals T1.PostId using inner match.\n4) When the question asks to list title and comment: include T2.Title and T1.Text in the output.\n5) When grouping for aggregate calculations: organize results by T2.Title and T1.Text.\n6) When handling text literals: preserve exact case and punctuation as shown in '<humor>'.\n7) Output columns (ordered): AVG(T2.ViewCount), T2.Title, T1.Text"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.Title, c.Text AS Comment, AVG(p.ViewCount) AS AverageViewCount\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE p.Tags LIKE '%<humor>%'\nGROUP BY p.Id, p.Title, c.Text;",
            "SELECT AVG(T2.ViewCount) AS AverageViewCount, T2.Title, T1.Text\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Tags = '<humor>'\nGROUP BY T2.Title, T1.Text"
        ],
        "rule_sql": [
            "SELECT AVG(T2.ViewCount) AS \"AVG(T2.ViewCount)\", T2.Title, T1.Text\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Tags = '<humor>'\nGROUP BY T2.Title, T1.Text"
        ]
    },
    "999": {
        "question": "In terms of the fastest lap time, what is the name of the race which recorded the fastest lap speed by a racer?",
        "db_id": "formula_1",
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "amends": [],
        "rules": [
            "Fastest lap speed refers to MIN(fastestLapTime)\n\n"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name AS race_name\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nWHERE res.fastestLapTime IS NOT NULL\nORDER BY res.fastestLapTime ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "790": {
        "question": "Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.",
        "db_id": "superhero",
        "ground_truth": "SELECT ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky' ) - ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler' ) AS CALCULATE",
        "amends": [],
        "rules": [
            "difference = SUBTRACT(SUM(weight_kg WHERE full_name = 'Emil Blonsky'), SUM(weight_kg WHERE full_name = 'Charles Chandler')); Emil Blonsky is the full name of superhero; Charles Chandler is the full name of superhero;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT (e.weight_kg - c.weight_kg) AS weight_difference\nFROM superhero e, superhero c\nWHERE e.full_name = 'Emil Blonsky'\nAND c.full_name = 'Charles Chandler';"
        ],
        "rule_sql": []
    },
    "267": {
        "question": "List down the bond type for molecules from molecule id TR000 to TR050.",
        "db_id": "toxicology",
        "ground_truth": "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'",
        "amends": [
            "Do add `T2.molecule_id` to the SELECT list instead of omitting it. Do change the FROM clause to use `INNER JOIN` between `molecule AS T1` and `bond AS T2` with join condition `T1.molecule_id = T2.molecule_id` instead of querying only the `bond` table. Do move the filter condition to reference `T1.molecule_id` instead of `T2.molecule_id` while keeping the same `BETWEEN 'TR000' AND 'TR050'` predicate. The amended query now correctly joins the molecule and bond tables to return both molecule_id and bond_type for the specified molecule range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining molecule and bond tables: link rows where T1.molecule_id equals T2.molecule_id and keep only matching pairs (inner match). 2) When filtering by molecule_id range 'TR000' to 'TR050': apply the condition to T1.molecule_id using BETWEEN 'TR000' AND 'TR050' with exact literals. 3) When selecting output columns: include both T2.molecule_id and bond_type from the joined tables. Output columns (ordered): T2.molecule_id, bond_type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM bond WHERE molecule_id BETWEEN 'TR000' AND 'TR050';",
            "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'"
        ],
        "rule_sql": [
            "SELECT T2.molecule_id, bond_type \nFROM molecule T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'"
        ]
    },
    "357": {
        "question": "What type of promotion is of card 'Duress'?",
        "db_id": "card_games",
        "ground_truth": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL",
        "amends": [
            "Do add `AND promoTypes IS NOT NULL` to the WHERE clause instead of omitting this filter, ensuring only non-null promoTypes values are returned for cards named 'Duress' instead of potentially including null values. The amended query now matches RIGHT_SQL's behavior by filtering out records where promoTypes is null."
        ],
        "rules": [
            "1) When the question asks about a specific card by name 'Duress': filter rows where cards.name equals exactly 'Duress'.\n2) When returning promotion type information: ensure the promoTypes column contains non-null values by adding a condition that promoTypes IS NOT NULL.\n3) Output columns (ordered): cards.promoTypes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT promoTypes FROM cards WHERE name = 'Duress';",
            "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT cards.promoTypes FROM cards WHERE cards.name = 'Duress' AND cards.promoTypes IS NOT NULL"
        ]
    },
    "779": {
        "question": "How many powers does Amazo hero have?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(T1.power_id) FROM hero_power AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.superhero_name = 'Amazo'",
        "amends": [],
        "rules": [
            "Amazo hero refers to superhero_name = 'Amazo';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS power_count\nFROM hero_power\nWHERE hero_id = (SELECT id FROM superhero WHERE superhero_name = 'Amazo');"
        ],
        "rule_sql": []
    },
    "1208": {
        "question": "Provide IDs for male patients with ALT glutamic pylvic transaminase (GPT) that have history of ALT glutamic pylvic transaminase (GPT) exceed the normal range.",
        "db_id": "thrombosis_prediction",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.GPT >= 60",
        "amends": [],
        "rules": [
            "male refers to SEX = 'M'; ALT glutamic pylvic transaminase (GPT) exceed the normal range refers to GPT > = 60"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.GPT >= 60;"
        ],
        "rule_sql": []
    },
    "804": {
        "question": "Provide the name of superhero with superhero ID 294.",
        "db_id": "superhero",
        "ground_truth": "SELECT superhero_name FROM superhero WHERE id = 294",
        "amends": [],
        "rules": [
            "name of superhero refers to superhero_name; superhero ID 294 refers to superhero.id = 294;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero_name FROM superhero WHERE id = 294;"
        ],
        "rule_sql": []
    },
    "25": {
        "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.sname, T2.`Charter Funding Type` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T2.`District Name` LIKE 'Riverside%' GROUP BY T1.sname, T2.`Charter Funding Type` HAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400",
        "amends": [
            "Do select `sname` and `Charter Funding Type` instead of `School` and `FundingType`. Do join `frpm` table instead of `schools` table, using `INNER JOIN` on `cds = CDSCode` instead of `JOIN` on `CDSCode = cds`. Do filter with `District Name LIKE 'Riverside%'` instead of `County = 'Riverside'`. Do add `GROUP BY` on `sname` and `Charter Funding Type` instead of omitting grouping. Do move the math score filter to `HAVING` with `CAST(SUM(AvgScrMath) AS REAL) / COUNT(cds) > 400` instead of `WHERE AvgScrMath > 400` to properly calculate the average. The amended query now correctly aggregates math scores by school and funding type while filtering for Riverside district schools with average math scores above 400."
        ],
        "rules": [
            "1) When the question asks for school names and funding types: select \"sname\" and \"Charter Funding Type\" instead of \"School\" and \"FundingType\".\n2) When combining school data with SAT scores: use the \"frpm\" table as T1 and join with \"satscores\" as T2 where T1.CDSCode = T2.cds.\n3) When filtering for Riverside schools: use \"District Name LIKE 'Riverside%'\" instead of \"County = 'Riverside'\".\n4) When calculating average math scores per school: group by \"sname\" and \"Charter Funding Type\" and compute the average using CAST(SUM(AvgScrMath) AS REAL) / COUNT(cds).\n5) When filtering for average math scores greater than 400: apply the condition on the calculated average in the HAVING clause instead of filtering individual scores in WHERE.\n6) When handling text matching for district names: use the pattern 'Riverside%' to match districts starting with \"Riverside\".\n7) When computing aggregates: use COUNT(cds) as the counting mechanism for average calculations.\nOutput columns (ordered): T2.sname, T1.\"Charter Funding Type\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.School, s.FundingType\nFROM schools s\nJOIN satscores sat ON s.CDSCode = sat.cds\nWHERE s.County = 'Riverside' AND sat.AvgScrMath > 400;",
            "SELECT s.sname, f.\"Charter Funding Type\"\nFROM satscores s\nINNER JOIN frpm f ON s.cds = f.CDSCode\nWHERE f.\"District Name\" LIKE 'Riverside%'\nGROUP BY s.sname, f.\"Charter Funding Type\"\nHAVING CAST(SUM(s.AvgScrMath) AS REAL) / COUNT(s.cds) > 400"
        ],
        "rule_sql": [
            "SELECT T2.sname, T1.\"Charter Funding Type\"\nFROM frpm AS T1\nJOIN satscores AS T2 ON T1.CDSCode = T2.cds\nWHERE T1.\"District Name\" LIKE 'Riverside%'\nGROUP BY T2.sname, T1.\"Charter Funding Type\"\nHAVING CAST(SUM(T2.AvgScrMath) AS REAL) / COUNT(T2.cds) > 400"
        ]
    },
    "119": {
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "db_id": "financial",
        "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "amends": [],
        "rules": [
            "Records about district names could be found in A2; A3 contains the information about regions. 'POPLATEK PO OBRATU' stands for issuance after transaction"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.account_id, d.A2 AS district_name, d.A3 AS district_region\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE strftime('%Y', a.date) = '1993' AND a.frequency = 'POPLATEK PO OBRATU';"
        ],
        "rule_sql": []
    },
    "1147": {
        "question": "Please name one player whose overall strength is the greatest.",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = ( SELECT MAX(overall_rating) FROM Player_Attributes)",
        "amends": [
            "Do select only `player_name` instead of including `overall_rating` in the SELECT list. Do use `DISTINCT` to eliminate duplicate player names instead of potentially returning multiple identical records. Do use table aliases `t1` and `t2` instead of full table names for clarity. Do use `INNER JOIN` with explicit table aliases instead of simple JOIN syntax. Do add a WHERE clause filtering for `overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)` instead of relying on ORDER BY and LIMIT which could miss players tied for the highest rating. Do remove the ORDER BY and LIMIT clauses entirely instead of using them to find maximum values, as the subquery approach correctly handles ties by returning all players with the maximum rating. The amended query now correctly identifies all players with the highest overall rating rather than just one arbitrary top-rated player."
        ],
        "rules": [
            "1) When the question asks for players with the greatest overall strength: find all players whose overall_rating equals the maximum overall_rating value from Player_Attributes. 2) When selecting player names: use DISTINCT to eliminate duplicate player names. 3) When combining Player and Player_Attributes tables: link rows where t1.player_api_id equals t2.player_api_id using an inner match. 4) When filtering for maximum rating: use the condition overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes) instead of ORDER BY and LIMIT. 5) When choosing table aliases: use t1 for Player and t2 for Player_Attributes. 6) Output columns (ordered): t1.player_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.player_name, pa.overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;",
            "SELECT DISTINCT t2.player_name\nFROM Player_Attributes t1\nINNER JOIN Player t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)"
        ]
    },
    "836": {
        "question": "What is the total number of superheroes that have John as their first name?",
        "db_id": "superhero",
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name LIKE 'John%'",
        "amends": [],
        "rules": [
            "have John as their first name refers to full_name LIKE 'John%';"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superhero WHERE full_name LIKE 'John%';"
        ],
        "rule_sql": []
    },
    "1326": {
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "db_id": "student_club",
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
        "amends": [],
        "rules": [
            "'Environmental Engineering' is the major name"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Environmental Engineering';"
        ],
        "rule_sql": []
    },
    "73": {
        "question": "What is the free or reduced price meal count for ages 5 to 17 in the Youth Authority School with a mailing street address of PO Box 1040?",
        "db_id": "california_schools",
        "ground_truth": "SELECT T1.`FRPM Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.MailStreet = 'PO Box 1040' AND T2.SOCType = 'Youth Authority Facilities'",
        "amends": [
            "Do select `FRPM Count (Ages 5-17)` instead of `Free Meal Count (Ages 5-17)` as the column name. Do use table aliases `T1` and `T2` instead of `f` and `s` for better clarity. Do change the join from implicit `JOIN` to explicit `INNER JOIN` for consistency. Do remove the filter on `School = 'Youth Authority School'` instead of keeping it, as it's replaced by a more specific condition. Do add the filter `SOCType = 'Youth Authority Facilities'` instead of omitting it, which provides the proper school type identification. Do reorder the WHERE clause predicates for logical grouping. The amended query now correctly identifies youth authority facilities and retrieves the appropriate FRPM count data."
        ],
        "rules": [
            "1) When the question asks for \"free or reduced price meal count for ages 5 to 17\": use column T1.\"FRPM Count (Ages 5-17)\" instead of T1.\"Free Meal Count (Ages 5-17)\".\n2) When joining tables frpm and schools: use explicit inner join with T1.CDSCode = T2.CDSCode and assign T1 to frpm table and T2 to schools table.\n3) When identifying Youth Authority School facilities: use condition T2.SOCType = 'Youth Authority Facilities' instead of T2.School = 'Youth Authority School'.\n4) When filtering by mailing street address: use exact literal T2.MailStreet = 'PO Box 1040'.\n5) When organizing WHERE clause predicates: group logical conditions together for clarity.\nOutput columns (ordered): T1.\"FRPM Count (Ages 5-17)\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT f.\"Free Meal Count (Ages 5-17)\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.School = 'Youth Authority School' AND s.MailStreet = 'PO Box 1040';",
            "SELECT T1.\"FRPM Count (Ages 5-17)\"\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.MailStreet = 'PO Box 1040'\nAND T2.SOCType = 'Youth Authority Facilities'\nORDER BY T1.\"FRPM Count (Ages 5-17)\" DESC;"
        ],
        "rule_sql": [
            "SELECT T1.\"FRPM Count (Ages 5-17)\"\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.SOCType = 'Youth Authority Facilities'\nAND T2.MailStreet = 'PO Box 1040'"
        ]
    },
    "116": {
        "error": "something went wrong, tool did not call.",
        "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
        "db_id": "financial",
        "ground_truth": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
        "amends": [],
        "rules": [
            "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "WITH first_loan_client AS (\n    SELECT l.account_id, c.client_id\n    FROM loan l\n    JOIN account a ON l.account_id = a.account_id\n    JOIN disp d ON a.account_id = d.account_id\n    JOIN client c ON d.client_id = c.client_id\n    WHERE l.date = '1993-07-05'\n    ORDER BY l.loan_id\n    LIMIT 1\n),\nbalance_b AS (\n    SELECT t.account_id, t.balance\n    FROM trans t\n    JOIN first_loan_client flc ON t.account_id = flc.account_id\n    WHERE t.date = '1993-03-22'\n    ORDER BY t.trans_id DESC\n    LIMIT 1\n),\nbalance_a AS (\n    SELECT t.account_id, t.balance\n    FROM trans t\n    JOIN first_loan_client flc ON t.account_id = flc.account_id\n    WHERE t.date = '1998-12-27'\n    ORDER BY t.trans_id DESC\n    LIMIT 1\n)\nSELECT \n    ((ba.balance - bb.balance) * 100.0 / bb.balance) AS increase_rate\nFROM balance_a ba\nJOIN balance_b bb ON ba.account_id = bb.account_id;"
        ],
        "rule_sql": []
    },
    "165": {
        "question": "Please list all the transactions made by accounts from district 5.",
        "db_id": "financial",
        "ground_truth": "SELECT T3.trans_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T1.district_id = 5",
        "amends": [
            "Do select only `trans_id` instead of all columns `t.*`. Do join `district` table as `T1` instead of omitting it. Do use `INNER JOIN` between `district` and `account` on `T1.district_id = T2.district_id` instead of missing this relationship. Do maintain `INNER JOIN` between `account` and `trans` on `T2.account_id = T3.account_id` instead of the similar `t.account_id = a.account_id`. Do filter on `T1.district_id = 5` instead of `a.district_id = 5` to correctly reference the district table. The amended query now correctly joins through the district table to filter transactions by district_id.",
            "Do reference `T3.trans_id` in the SELECT list instead of `t.trans_id` to correctly specify the table alias. Do use explicit table aliases `AS T1`, `AS T2`, and `AS T3` in the FROM clause instead of omitting the AS keyword for better readability. The amended query now correctly references the trans_id column from the trans table with proper alias usage while maintaining the same join logic and filter condition."
        ],
        "rules": [
            "1) When the question asks for transactions from a specific district: join district table as T1, account table as T2, and trans table as T3 using the exact key relationships T1.district_id = T2.district_id and T2.account_id = T3.account_id. 2) When filtering for district 5: apply the condition T1.district_id = 5 to the district table. 3) When selecting transaction information: output only the trans_id column from the trans table. 4) When combining tables for shared entities: perform inner matches only, keeping only rows where district, account, and transaction records all exist. 5) Output columns (ordered): T3.trans_id",
            "1) When the question asks for transactions from accounts in a specific district: include T3.trans_id in the output columns. 2) When joining district, account, and trans tables: use explicit aliases AS T1 for district, AS T2 for account, and AS T3 for trans. 3) When filtering for district 5: use the exact literal value 5 for T1.district_id. 4) When combining district and account tables: link rows where T1.district_id equals T2.district_id exactly. 5) When combining account and trans tables: link rows where T2.account_id equals T3.account_id exactly. 6) When the question specifies district 5: keep only rows where T1.district_id equals 5. Output columns (ordered): T3.trans_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.* FROM trans t JOIN account a ON t.account_id = a.account_id WHERE a.district_id = 5;",
            "SELECT t.trans_id\nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nINNER JOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T1.district_id = 5",
            "SELECT T3.trans_id\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T1.district_id = 5"
        ],
        "rule_sql": [
            "SELECT T3.trans_id\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T1.district_id = 5"
        ]
    },
    "345": {
        "question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL",
        "amends": [
            "Do select only `T2.status` instead of `c.name, l.status` and add `DISTINCT` instead of omitting it. Do use `INNER JOIN` with table aliases `T1` and `T2` instead of `JOIN` with `c` and `l`. Do filter with exact equality `T1.type = 'Artifact'` instead of pattern matching `LIKE '%Artifact%'`. The amended query now correctly retrieves distinct legality statuses for vintage format artifacts without side designations, matching the intended behavior.",
            "Do use lowercase `vintage` instead of uppercase `Vintage` in the WHERE clause filter on `T2.format`. Do maintain the same SELECT list with `T2.status`, FROM sources with `cards AS T1` and `legalities AS T2`, INNER JOIN condition on `T1.uuid = T2.uuid`, and all other filters including `T1.type = 'Artifact'` and `T1.side IS NULL`. The amended query now correctly matches the case-sensitive format value and produces the same result behavior as the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for legalities status: output only T2.status instead of multiple columns.\n2) When retrieving distinct values for legalities status: use DISTINCT to eliminate duplicate status values.\n3) When joining cards and legalities tables: use INNER JOIN with T1 for cards and T2 for legalities, linking rows where T1.uuid = T2.uuid.\n4) When filtering for artifact type cards: use exact equality T1.type = 'Artifact' instead of pattern matching.\n5) When filtering for cards without multiple faces: include condition T1.side IS NULL.\n6) When filtering for vintage play format: include condition T2.format = 'vintage' with exact literal 'vintage'.\nOutput columns (ordered): T2.status",
            "1) When filtering on format values from the legalities table: use lowercase 'vintage' exactly as specified in the schema instead of uppercase 'Vintage'. 2) When selecting legal status information: maintain T2.status as the output column. 3) When combining cards and legalities tables: link rows where T1.uuid = T2.uuid using inner match. 4) When filtering for artifact type cards: use T1.type = 'Artifact' exactly. 5) When identifying cards without multiple faces: use T1.side IS NULL condition. 6) Output columns (ordered): T2.status"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.types LIKE '%Artifact%'\nAND c.side IS NULL\nAND l.format = 'vintage';",
            "SELECT DISTINCT T2.status\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.type = 'Artifact' \nAND T2.format = 'Vintage'\nAND T1.side IS NULL",
            "SELECT DISTINCT T2.status\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T1.type = 'Artifact'\nAND T1.side IS NULL\nAND T2.format = 'vintage'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.status\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.type = 'Artifact'\nAND T1.side IS NULL\nAND T2.format = 'vintage'"
        ]
    },
    "482": {
        "question": "What's the German type of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "ground_truth": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German'",
        "amends": [
            "Do use `DISTINCT T1.type` instead of `fd.type` to eliminate duplicate results. Do reference `cards AS T1` instead of `cards c` and `foreign_data AS T2` instead of `foreign_data fd` with proper table aliasing. Do use `INNER JOIN` with `T2.uuid = T1.uuid` instead of `JOIN` with `fd.uuid = c.uuid` for explicit join specification and corrected join condition direction. Do filter on `T1.name = 'Ancestor''s Chosen'` instead of `c.name = 'Ancestor''s Chosen'` and `T2.language = 'German'` instead of `fd.language = 'German'` to maintain consistent table alias usage throughout the query. The amended query now correctly returns distinct card types without duplicates while maintaining the same logical behavior."
        ],
        "rules": [
            "1) When the question asks for the German type of a specific card: use T1 as the alias for the cards table and T2 as the alias for the foreign_data table. 2) When joining T1 and T2: link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match). 3) When filtering for a specific card name: use T1.name = 'Ancestor''s Chosen' with exact punctuation and spacing. 4) When filtering for German language data: use T2.language = 'German' with exact case. 5) When selecting type information to eliminate duplicates: use distinct T1.type instead of T2.type. Output columns (ordered): T1.type"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT fd.type \nFROM foreign_data fd \nJOIN cards c ON fd.uuid = c.uuid \nWHERE c.name = 'Ancestor''s Chosen' AND fd.language = 'German';",
            "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.type FROM cards T1 INNER JOIN foreign_data T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German'"
        ]
    },
    "1141": {
        "question": "Does the KSV Cercle Brugge team have a slow, balanced or fast speed class?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT DISTINCT t1.buildUpPlaySpeedClass FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.team_long_name = 'KSV Cercle Brugge'",
        "amends": [
            "Do select `t1.buildUpPlaySpeedClass` instead of `t.team_long_name, ta.buildUpPlaySpeedClass`. Do use `DISTINCT` instead of omitting it. Do reference `Team_Attributes AS t1` instead of `Team_Attributes ta` and `Team AS t2` instead of `Team t`. Do use `INNER JOIN` with `t1.team_api_id = t2.team_api_id` instead of `JOIN` with `t.team_api_id = ta.team_api_id`. Do filter on `t2.team_long_name` instead of `t.team_long_name`. The amended query now correctly retrieves distinct build-up play speed classes for the specified team."
        ],
        "rules": [
            "1) When the question asks for a specific team's speed class: filter on t2.team_long_name with the exact literal 'KSV Cercle Brugge'. 2) When combining Team_Attributes and Team tables: link rows where t1.team_api_id = t2.team_api_id using an inner match. 3) When retrieving categorical attributes like speed class: use DISTINCT to return only unique values. 4) When the output requires only the speed class attribute: select only t1.buildUpPlaySpeedClass. Output columns (ordered): t1.buildUpPlaySpeedClass"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.team_long_name, ta.buildUpPlaySpeedClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_long_name = 'KSV Cercle Brugge';",
            "SELECT DISTINCT t1.buildUpPlaySpeedClass \nFROM Team_Attributes AS t1 \nINNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t2.team_long_name = 'KSV Cercle Brugge';"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.buildUpPlaySpeedClass\nFROM Team_Attributes t1\nINNER JOIN Team t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.team_long_name = 'KSV Cercle Brugge';"
        ]
    },
    "272": {
        "question": "List down two molecule id of triple bond non carcinogenic molecules with element carbon.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element = 'c' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "carbon refers to element = 'c'; triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT m.molecule_id\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '-'\nAND b.bond_type = '#'\nAND a.element = 'c'\nLIMIT 2;"
        ],
        "rule_sql": []
    },
    "1378": {
        "question": "What is the highest amount of budget spend for an event?",
        "db_id": "student_club",
        "ground_truth": "SELECT MAX(spent) FROM budget",
        "amends": [],
        "rules": [
            "highest amount of budget spend refers to MAX(spent)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(spent) AS highest_budget_spend FROM budget;"
        ],
        "rule_sql": []
    },
    "1117": {
        "question": "What are the player api id of 10 heaviest players?",
        "db_id": "european_football_2",
        "ground_truth": "SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10",
        "amends": [],
        "rules": [
            "heaviest refers to MAX(weight)"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10;"
        ],
        "rule_sql": []
    },
    "247": {
        "question": "List all the elements of atoms that can not bond with any other atoms.",
        "db_id": "toxicology",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.element NOT IN ( SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id )",
        "amends": [
            "Do reference the table as `T` instead of `a` in the SELECT clause. Do filter by `T.element NOT IN` instead of `a.atom_id NOT IN` to check for elements rather than atom IDs. Do use a single subquery with `SELECT DISTINCT T1.element` instead of two separate subqueries checking different columns. Do perform an `INNER JOIN` between `atom AS T1` and `connected AS T2` on `T1.atom_id = T2.atom_id` instead of using NOT IN with separate subqueries against the connected table. Do remove the second NOT IN condition checking `atom_id2` instead of keeping it, as the join approach captures all relevant connections. The amended query now correctly identifies elements that have no connections by checking against joined data rather than individual column comparisons, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for elements that cannot bond with any other atoms: filter for elements where no connections exist in the connected table.\n2) When checking for unconnected elements: use the element column from the atom table (T1.element) rather than atom_id for filtering.\n3) When combining atom and connected tables: link rows where T1.atom_id equals T2.atom_id to find all connections.\n4) When identifying elements with no connections: select only those elements that do not appear in the joined result set of connected atoms.\n5) When handling the output: return distinct element values to avoid duplicates.\nOutput columns (ordered): T1.element"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT a.element FROM atom a WHERE a.atom_id NOT IN (SELECT atom_id FROM connected) AND a.atom_id NOT IN (SELECT atom_id2 FROM connected);",
            "SELECT DISTINCT T.element\nFROM atom AS T\nWHERE T.element NOT IN (\n    SELECT DISTINCT T1.element\n    FROM atom AS T1\n    INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT a.element\nFROM atom a\nWHERE a.atom_id NOT IN (\n    SELECT atom_id FROM connected\n    UNION\n    SELECT atom_id2 FROM connected\n)\nORDER BY a.element;"
        ]
    },
    "1331": {
        "question": "What is the amount of the funds that the Vice President received?",
        "db_id": "student_club",
        "ground_truth": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "amends": [],
        "rules": [
            "'Vice President' is a position of Student Club; funds received refers to amount."
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(i.amount) AS total_funds_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.position = 'Vice President';"
        ],
        "rule_sql": []
    },
    "184": {
        "question": "How many female customers have a junior credit card?",
        "db_id": "financial",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "amends": [],
        "rules": [
            "Female refers to gender = 'F'"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.client_id) AS female_junior_card_holders\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE c.gender = 'F' AND ca.type = 'junior';"
        ],
        "rule_sql": []
    },
    "754": {
        "question": "What is the superpower of hero ID 56?",
        "db_id": "superhero",
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 56",
        "amends": [],
        "rules": [
            "superpower refers to hero_power"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sp.power_name \nFROM superhero sh \nJOIN hero_power hp ON sh.id = hp.hero_id \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE sh.id = 56;"
        ],
        "rule_sql": []
    },
    "819": {
        "question": "In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.",
        "db_id": "superhero",
        "ground_truth": "SELECT SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL",
        "amends": [],
        "rules": [
            "missing weight data refers to weight_kg = 0 OR T1.weight_kg = NULL; difference = SUBTRACT(SUM(colour.id = 7), SUM(colour.id = 1)); blue eyes refers to eye_colour_id WHERE colour.id = 7; no eye color refers to eye_colour_id WHERE colour.id = 1;"
        ],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN s.eye_colour_id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN s.eye_colour_id = 1 THEN 1 ELSE 0 END)) AS difference\nFROM \n    superhero s\nWHERE \n    s.weight_kg = 0 OR s.weight_kg IS NULL;"
        ],
        "rule_sql": []
    },
    "1488": {
        "question": "Who among KAM's customers consumed the most? How much did it consume?",
        "db_id": "debit_card_specializing",
        "ground_truth": "SELECT T2.CustomerID, SUM(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' GROUP BY T2.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.CustomerID, SUM(ym.Consumption) AS TotalConsumption\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Segment = 'KAM'\nGROUP BY c.CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "839": {
        "question": "In superheroes with weight less than 100, list the full name of the superheroes with brown eyes.",
        "db_id": "superhero",
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Brown'",
        "amends": [
            "Do use explicit `INNER JOIN` instead of implicit `JOIN` for clarity. Do reference the colour table as `T2` instead of `c` for consistent aliasing. Do use uppercase `'Brown'` instead of lowercase `'brown'` for the colour filter to match the exact case in the data. Do qualify all column references with table aliases (`T1.full_name`, `T1.weight_kg`, `T2.colour`) instead of using unqualified column names for better readability and to avoid potential ambiguity. The amended query now correctly filters for brown eye colour with proper case sensitivity and maintains consistent table aliasing throughout."
        ],
        "rules": [
            "1) When the question mentions superheroes with weight less than 100: filter rows where T1.weight_kg < 100.\n2) When the question asks for superheroes with brown eyes: filter rows where T2.colour = 'Brown' (exact case match).\n3) When combining superhero and colour tables: link rows where T1.eye_colour_id = T2.id using inner match only.\n4) When handling text literals: use exact case 'Brown' as specified in the data, not 'brown'.\n5) When referring to table roles: use T1 for superhero table and T2 for colour table consistently.\n6) When qualifying column references: use table aliases (T1.full_name, T1.weight_kg, T2.colour) instead of unqualified names.\n7) Output columns (ordered): T1.full_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.weight_kg < 100 AND c.colour = 'brown';",
            "SELECT T1.full_name\nFROM superhero T1\nINNER JOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T1.weight_kg < 100\nAND T2.colour = 'Brown';"
        ],
        "rule_sql": [
            "SELECT T1.full_name\nFROM superhero T1\nINNER JOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T1.weight_kg < 100\nAND T2.colour = 'Brown'"
        ]
    }
}