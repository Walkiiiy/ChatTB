{
    "1349": {
        "sql": [
            "SELECT SUM(amount) AS total_budget_amount\nFROM budget\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'September Speaker');"
        ],
        "question": "Provide the total number of the budget amount for \"September Speaker\" event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'September Speaker'",
        "amends": [],
        "rules": [
            "'September Speaker' is an event name; total number of budget amount refers to SUM(amount)"
        ]
    },
    "977": {
        "sql": [
            "SELECT COUNT(*) AS disqualified_finishers\nFROM results\nWHERE raceId > 50 AND raceId < 100\n  AND time IS NOT NULL\n  AND statusId = 2;"
        ],
        "question": "From race no. 50 to 100, how many finishers have been disqualified?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(time IS NOT NULL, 1, 0)) FROM results WHERE statusId = 2 AND raceID < 100 AND raceId > 50",
        "amends": [],
        "rules": [
            "disqualified refers to statusID = 2, finisher refers to time! = null; race no. refers to raceId; raceId > 50 and raceId < 100;"
        ]
    },
    "932": {
        "sql": [
            "SELECT DISTINCT r.year\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';\n"
        ],
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "amends": [],
        "rules": []
    },
    "1345": {
        "sql": [
            "SELECT COUNT(*) FROM major WHERE college = 'College of Humanities and Social Sciences';"
        ],
        "question": "How many majors are there in \"College of Humanities and Social Sciences\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(major_name) FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "amends": [],
        "rules": []
    },
    "100": {
        "sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS female_customers_before_1950_Sokolov\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN district di ON c.district_id = di.district_id\nWHERE c.gender = 'F'\nAND c.birth_date < '1950-01-01'\nAND di.A2 = 'Sokolov';"
        ],
        "question": "Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND STRFTIME('%Y', T2.birth_date) < '1950' AND T1.A2 = 'Sokolov'",
        "amends": [],
        "rules": [
            "Customers refer to clients; Female refers to gender = 'F'; Names of districts appear in column A2"
        ]
    },
    "611": {
        "sql": [
            "SELECT u.Reputation, u.DisplayName\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE b.Date = '2010-07-19 19:39:08.0';",
            "SELECT T1.Reputation\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.Id = T2.UserId\nWHERE T2.Date = '2010-07-19 19:39:08'",
            "SELECT T1.Reputation\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.Id = T2.UserId\nWHERE T2.Date = '2010-07-19 19:39:08.0'"
        ],
        "question": "Mention the reputation of users who had obtained the badge on 7/19/2010 7:39:08 PM.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'",
        "amends": [
            "Do use `T1.Reputation` instead of `u.Reputation, u.DisplayName` to select only the reputation column instead of both reputation and display name. Do use `users AS T1` and `badges AS T2` instead of `users u` and `badges b` for explicit table aliasing. Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do use `T1.Id = T2.UserId` instead of `b.UserId = u.Id` for the join condition, maintaining the same logical relationship but with consistent alias usage. Do use `T2.Date` instead of `b.Date` in the WHERE clause filter, ensuring the date condition is applied to the badges table with the correct alias. The amended query now correctly returns only reputation data for users with badges on the specified date, matching the RIGHT_SQL's behavior.",
            "Do use the exact timestamp format '2010-07-19 19:39:08.0' with milliseconds precision in the WHERE filter instead of '2010-07-19 19:39:08' without milliseconds to ensure proper date matching with the stored timestamp values in the database. The amended query now correctly matches the RIGHT_SQL's behavior by using the precise timestamp format that includes milliseconds for accurate date comparison."
        ],
        "rules": [
            "on 7/19/2010 7:39:08 PM refers to Date = '2010-07-19 19:39:08.0'"
        ]
    },
    "383": {
        "sql": [
            "SELECT COUNT(*) AS banned_white_border_cards\nFROM legalities\nJOIN cards ON legalities.uuid = cards.uuid\nWHERE legalities.status = 'Banned' AND cards.borderColor = 'white';"
        ],
        "question": "How many of the banned cards are white border?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Banned' AND T1.borderColor = 'white'",
        "amends": [],
        "rules": [
            "banned card refers to status = 'Banned'; white border refers to borderColor = 'white';"
        ]
    },
    "24": {
        "sql": [
            "SELECT f.\"School Name\"\nFROM frpm f\nJOIN satscores s ON f.CDSCode = s.cds\nWHERE f.\"Percent (%) Eligible Free (K-12)\" > 0.1 AND s.NumGE1500 >= 1;"
        ],
        "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.`School Name` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(T2.`Free Meal Count (K-12)` AS REAL) / T2.`Enrollment (K-12)` > 0.1 AND T1.NumGE1500 > 0",
        "amends": [],
        "rules": [
            "Percent eligible for free meals = Free Meal Count (K-12) / Total (Enrollment (K-12)"
        ]
    },
    "61": {
        "sql": [
            "SELECT COUNT(*) AS NumberOfCharteredSchools\nFROM schools\nWHERE City = 'Hickman' AND Charter = 1 AND DOC = '52';"
        ],
        "question": "How many chartered schools located in the city of Hickman are owned by the Elementary School District?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE DOC = 52 AND Charter = 1 AND City = 'Hickman'",
        "amends": [],
        "rules": [
            "Elementary School District refers to DOC = 52; Chartered schools refer to Charter = 1 in the table schools"
        ]
    },
    "1396": {
        "sql": [
            "WITH luisa_info AS (\n    SELECT member_id, link_to_major\n    FROM member\n    WHERE first_name = 'Luisa' AND last_name = 'Guidi'\n)\nSELECT \n    COUNT(a.link_to_event) AS number_of_events_attended,\n    m.major_name\nFROM \n    luisa_info li\nLEFT JOIN \n    attendance a ON li.member_id = a.link_to_member\nLEFT JOIN \n    major m ON li.link_to_major = m.major_id\nGROUP BY \n    m.major_name;"
        ],
        "question": "Provide the number of events attended by Luisa Guidi. What is her major?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.link_to_event), T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'",
        "amends": [],
        "rules": [
            "major refers to major_name;"
        ]
    },
    "1018": {
        "sql": [
            "SELECT AVG(p.milliseconds) AS average_pitstop_time_ms\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';"
        ],
        "question": "What was the average time in milliseconds Lewis Hamilton spent at a pit stop during Formula_1 races?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(milliseconds) FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'",
        "amends": [],
        "rules": [
            "average time in milliseconds spent at pit stop refers to AVG(milliseconds)"
        ]
    },
    "466": {
        "sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT setCode FROM set_translations WHERE translation = 'Hauptset Zehnte Edition') \nAND artist = 'Adam Rex';"
        ],
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "amends": [],
        "rules": [
            "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; designed by Adam refers to artist = 'Adam Rex'"
        ]
    },
    "1335": {
        "sql": [
            "SELECT SUM(b.spent) AS total_spent_on_advertisement\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'September Meeting' AND b.category = 'Advertisement';"
        ],
        "question": "How much did the Student_Club members spend on advertisement in September Meeting?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Advertisement' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "amends": [],
        "rules": [
            "amount spent refers to spent; spend on food in September Meeting refers to category = 'Advertisement' where event_name = 'September Meeting'"
        ]
    },
    "1299": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.TG < 200 AND E.Symptoms IS NOT NULL;",
            "SELECT COUNT(T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL"
        ],
        "question": "Among the patients with the normal level of triglyceride, how many of them have other symptoms observed?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows. Do reference `Examination AS T1` and `Laboratory AS T2` instead of `Patient P`, `Laboratory L`, and `Examination E` to join the correct tables. Do use `INNER JOIN` between Examination and Laboratory instead of joining both to Patient to properly relate test results. Do join on `T1.ID = T2.ID` instead of separate joins to Patient ID to directly connect examination and lab records. Do filter with `T2.TG < 200` and `T1.Symptoms IS NOT NULL` instead of the same conditions but on different table aliases. Do remove the Patient table entirely instead of including it since the count should be based on examination records with matching lab results. The amended query now correctly counts examination records that have corresponding laboratory results meeting the specified criteria."
        ],
        "rules": [
            "normal level of triglyceride refers to TG < 200; have other symptoms refers to Symptoms is not null;"
        ]
    },
    "237": {
        "sql": [
            "SELECT m.molecule_id, m.label,\n       CASE WHEN m.label = '+' THEN 'Carcinogenic' ELSE 'Not Carcinogenic' END AS carcinogenic_status\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.atom_id = 'TR001_10';",
            "SELECT T2.molecule_id, IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.atom_id = 'TR001_10'"
        ],
        "question": "Which molecule does the atom TR001_10 belong to? Please state whether this molecule is carcinogenic or not.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.molecule_id , IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'",
        "amends": [
            "Do use `T2.molecule_id` and `IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic` instead of `m.molecule_id, m.label, CASE WHEN m.label = '+' THEN 'Carcinogenic' ELSE 'Not Carcinogenic' END AS carcinogenic_status`. Do use `INNER JOIN` with explicit alias `AS T2` instead of `JOIN` with simple alias `m`. Do use table alias `AS T1` for atom table instead of no alias. Do use `flag_carcinogenic` as the column alias instead of `carcinogenic_status`. The amended query now correctly returns 'YES'/'NO' flags for carcinogenic status and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "TR001_10 is the atom id; label = '+' mean molecules are carcinogenic"
        ]
    },
    "375": {
        "sql": [
            "SELECT id FROM cards WHERE convertedManaCost = 0;"
        ],
        "question": "List down all the card IDs with converted mana cost of 0.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE convertedManaCost = 0",
        "amends": [],
        "rules": [
            "converted mana cost of 0 refers to covertedManaCost = 0;"
        ]
    },
    "1522": {
        "sql": [
            "SELECT c.Currency\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201306' AND ym.Consumption = 214582.17;"
        ],
        "question": "There's one customer spent 214582.17 in the June of 2013, which currency did he/she use?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Currency FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '201306' AND T1.Consumption = 214582.17",
        "amends": [],
        "rules": [
            "June of 2013 means Date contains '201306' in the yearmonth.date of the database"
        ]
    },
    "682": {
        "sql": [
            "SELECT p.Id, u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE strftime('%Y', p.CreationDate) = '2010'\nORDER BY p.FavoriteCount DESC\nLIMIT 1;",
            "SELECT T2.OwnerUserId, T1.DisplayName \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T1.CreationDate) = '2010' \nORDER BY T2.FavoriteCount DESC \nLIMIT 1;"
        ],
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "amends": [
            "Do reference `T2.OwnerUserId` and `T1.DisplayName` in the SELECT list instead of `p.Id` and `u.DisplayName`. Do use `INNER JOIN` with explicit table aliases `AS T1` and `AS T2` instead of simple aliases `p` and `u`. Do apply the date filter on `T1.CreationDate` using `STRFTIME('%Y', T1.CreationDate) = '2010'` instead of filtering on `p.CreationDate`. Do order by `T2.FavoriteCount DESC` instead of `p.FavoriteCount DESC`. The amended query now correctly filters users created in 2010 rather than posts, and returns the appropriate user information matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "the most valuable post in 2015 refers to MAX(FavoriteCount) where year(CreationDate) = 2010;"
        ]
    },
    "1131": {
        "sql": [
            "SELECT AVG(P.height) AS average_height\nFROM Player P\nJOIN Match M ON P.player_api_id IN (\n    M.home_player_1, M.home_player_2, M.home_player_3, M.home_player_4, M.home_player_5,\n    M.home_player_6, M.home_player_7, M.home_player_8, M.home_player_9, M.home_player_10, M.home_player_11,\n    M.away_player_1, M.away_player_2, M.away_player_3, M.away_player_4, M.away_player_5,\n    M.away_player_6, M.away_player_7, M.away_player_8, M.away_player_9, M.away_player_10, M.away_player_11\n)\nJOIN Country C ON M.country_id = C.id\nWHERE C.name = 'Italy';",
            "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) AS average_height\nFROM Player AS T1\nINNER JOIN Match AS T2 ON T1.player_api_id IN (\n    T2.home_player_1, T2.home_player_2, T2.home_player_3, T2.home_player_4, T2.home_player_5,\n    T2.home_player_6, T2.home_player_7, T2.home_player_8, T2.home_player_9, T2.home_player_10, T2.home_player_11,\n    T2.away_player_1, T2.away_player_2, T2.away_player_3, T2.away_player_4, T2.away_player_5,\n    T2.away_player_6, T2.away_player_7, T2.away_player_8, T2.away_player_9, T2.away_player_10, T2.away_player_11\n)\nINNER JOIN Country AS T3 ON T2.country_id = T3.id\nWHERE T3.name = 'Italy'",
            "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) \nFROM Player AS T1\nINNER JOIN Match AS T2 ON T1.id = T2.id\nINNER JOIN Country AS T3 ON T2.country_id = T3.ID\nWHERE T3.NAME = 'Italy'"
        ],
        "question": "What is the average heights of Italy players?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) FROM Player AS T1 INNER JOIN Match AS T2 ON T1.id = T2.id INNER JOIN Country AS T3 ON T2.country_id = T3.ID WHERE T3.NAME = 'Italy'",
        "amends": [
            "Do use `CAST(SUM(T1.height) AS REAL) / COUNT(T1.id)` instead of `AVG(P.height)` for precise average calculation. Do join `Match AS T2` on `T1.id = T2.id` instead of checking if `P.player_api_id` is in multiple player columns. Do use `INNER JOIN` consistently instead of mixing `JOIN` and `INNER JOIN` syntax. Do reference tables with aliases `T1`, `T2`, `T3` instead of `P`, `M`, `C` for clarity. Do filter on `T3.NAME = 'Italy'` instead of `C.name = 'Italy'` to match the table alias. The amended query now correctly calculates the average height by joining directly on player IDs rather than checking against multiple position columns, ensuring accurate results.",
            "Do `INNER JOIN` on `T1.id = T2.id` instead of the complex `INNER JOIN` condition checking against multiple player columns. Do remove the alias `AS average_height` instead of keeping it. Do use `T3.ID` instead of `T3.id` in the join condition. Do use `T3.NAME` instead of `T3.name` in the WHERE filter. The amended query now correctly joins on the primary key relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "average heights refers to Avg(height); Italy is name of country"
        ]
    },
    "546": {
        "sql": [
            "SELECT DISTINCT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ClosedDate IS NOT NULL;"
        ],
        "question": "Please list the display names of all the users who owns a post that is well-finished.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.ClosedDate IS NOT NULL",
        "amends": [],
        "rules": [
            "the post that is well-finished refers to ClosedDate IS NOT Null"
        ]
    },
    "1344": {
        "sql": [
            "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14';"
        ],
        "question": "What was the notes of the fundraising on 2019/9/14?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'",
        "amends": [],
        "rules": [
            "fundraising on 2019/9/14 refers to source = 'Fundraising' where date_received = '2019-09-14'"
        ]
    },
    "423": {
        "sql": [
            "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId ASC LIMIT 3;",
            "SELECT cardKingdomFoilId, cardKingdomId \nFROM cards \nWHERE cardKingdomFoilId IS NOT NULL \nAND cardKingdomId IS NOT NULL \nORDER BY cardKingdomFoilId \nLIMIT 3"
        ],
        "question": "Please provide the ids of top three powerful pairs of Kingdom Foil and Kingdom Cards sorted by Kingdom Foil id in alphabetical order.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId LIMIT 3",
        "amends": [
            "Do select `cardKingdomFoilId, cardKingdomId` instead of just `id` in the SELECT list. Do remove the redundant `ASC` keyword from the ORDER BY clause instead of keeping it. The amended query now correctly returns both card kingdom identifiers while maintaining the same filtering and ordering behavior as the RIGHT_SQL."
        ],
        "rules": [
            "poweful refers to cardKingdomFoilId is not null AND cardKingdomId is not null"
        ]
    },
    "991": {
        "sql": [
            "SELECT forename || ' ' || surname AS full_name, dob FROM drivers WHERE nationality = 'Austrian' AND strftime('%Y', dob) BETWEEN '1981' AND '1991';",
            "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'"
        ],
        "question": "What is the full name and date of birth of Austrian drivers born between 1981 and 1991?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `full_name`. Do keep the same `dob` column selection instead of changing it. Do maintain the same `WHERE` filter on `nationality = 'Austrian'` instead of altering it. Do preserve the same date range filter using `STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'` instead of modifying it. The amended query now correctly returns separate forename and surname columns instead of a concatenated full name while maintaining the same filtering logic for Austrian drivers born between 1981 and 1991."
        ],
        "rules": [
            "Full name refers to forname, surname; Date of birth refers to dob; year(dob) BETWEEN '1981' AND '1991'; Austrian is a nationality"
        ]
    },
    "645": {
        "sql": [
            "SELECT COUNT(*) AS negative_comments_count FROM comments WHERE UserId = 13 AND Score < 60;"
        ],
        "question": "How many negative comments were given by user ID 13?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13 AND Score < 60",
        "amends": [],
        "rules": [
            "negative comments refer to Score < 60;"
        ]
    },
    "1444": {
        "sql": [
            "SELECT expense_id, expense_description, expense_date, cost, approved, link_to_member, link_to_budget FROM expense WHERE cost > (SELECT AVG(cost) FROM expense) AND (SELECT AVG(cost) FROM expense) > 50;",
            "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50"
        ],
        "question": "List the expenses that spend more than fifty dollars on average.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50",
        "amends": [
            "Do select only `expense_description` instead of multiple columns including `expense_id`, `expense_date`, `cost`, `approved`, `link_to_member`, and `link_to_budget`. Do use `GROUP BY expense_description` with `HAVING AVG(cost) > 50` instead of filtering individual rows with `WHERE cost > (SELECT AVG(cost) FROM expense)` and an additional subquery condition. Do remove the redundant subquery that calculated the same average twice instead of keeping it. Do eliminate the unnecessary subquery correlation that didn't reference outer scope instead of maintaining it. The amended query now correctly groups expenses by description and filters for groups where the average cost exceeds 50, matching the intended behavior."
        ],
        "rules": [
            "expense refers to expense_description; spend more than fifty dollars on average refers to DIVIDE( SUM(cost), COUNT(expense_id) ) > 50"
        ]
    },
    "945": {
        "sql": [
            "SELECT COUNT(*) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia';"
        ],
        "question": "How many circuits are there in Adelaide, Australia?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia'",
        "amends": [],
        "rules": [
            "Australia is the country; Melbourne is the location of circuit;"
        ]
    },
    "323": {
        "sql": [
            "-- The schema does not provide any information about carcinogenicity, so the query cannot determine if molecule TR000 is carcinogenic.\n-- The following query retrieves the label of molecule TR000, but it does not confirm carcinogenicity.\nSELECT label FROM molecule WHERE molecule_id = 'TR000';"
        ],
        "question": "Is molecule TR000 is carcinogenic or not?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT label FROM molecule AS T WHERE T.molecule_id = 'TR000'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
        ]
    },
    "1410": {
        "sql": [
            "SELECT m.first_name || ' ' || m.last_name AS full_name, SUM(e.cost) AS total_cost\nFROM member m\nLEFT JOIN expense e ON m.member_id = e.link_to_member\nWHERE m.member_id = 'rec4BLdZHS2Blfp4v'\nGROUP BY m.member_id;",
            "SELECT m.first_name, m.last_name, SUM(e.cost) \nFROM member m\nINNER JOIN expense e ON m.member_id = e.link_to_member\nWHERE m.member_id = 'rec4BLdZHS2Blfp4v'"
        ],
        "question": "List out the full name and total cost that member id \"rec4BLdZHS2Blfp4v\" incurred?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'",
        "amends": [
            "Do use separate columns `first_name` and `last_name` instead of concatenating them as `full_name`. Do use `INNER JOIN` instead of `LEFT JOIN` to exclude members without expenses. Do remove the `GROUP BY` clause instead of keeping it since the WHERE filter returns only one member. Do omit the alias `total_cost` for the aggregate instead of including it. The amended query now correctly returns the first name, last name, and total expense sum for the specified member while excluding those without expenses."
        ],
        "rules": [
            "full name refers to first_name, last name"
        ]
    },
    "1374": {
        "sql": [
            "SELECT COUNT(*) \nFROM attendance \nWHERE link_to_member = (SELECT member_id FROM member WHERE phone = '954-555-6240');"
        ],
        "question": "How many events did the member with the phone number \"954-555-6240\" attend?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.link_to_event) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member WHERE T1.phone = '954-555-6240'",
        "amends": [],
        "rules": []
    },
    "1426": {
        "sql": [
            "SELECT m.last_name, ma.department, ma.college\nFROM member m\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE ma.major_name = 'Environmental Engineering';"
        ],
        "question": "List the last name of members with a major in environmental engineering and include its department and college name.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.last_name, T1.department, T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'",
        "amends": [],
        "rules": [
            "'Environmental Engineering' is the major_name;"
        ]
    },
    "534": {
        "sql": [
            "SELECT DisplayName FROM users ORDER BY Views DESC LIMIT 1;"
        ],
        "question": "What is the display name of the user who has the most number of views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "amends": [],
        "rules": [
            "user who has the most number of view refers to Max(Views)"
        ]
    },
    "1251": {
        "sql": [
            "SELECT COUNT(DISTINCT ID) FROM Laboratory WHERE IGG >= 2000;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.IGG >= 2000"
        ],
        "question": "How many patients with an Ig G higher than normal?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
        "amends": [
            "Do add `Patient AS T1` and `Examination AS T3` as joined tables instead of querying only `Laboratory` alone. Do use `INNER JOIN` on `T1.ID = T2.ID` and `INNER JOIN` on `T3.ID = T2.ID` instead of no joins. Do specify `T1.ID` in the `COUNT(DISTINCT)` instead of just `ID` to avoid ambiguity. Do keep the `WHERE T2.IGG >= 2000` filter instead of the same condition but without table qualification. The amended query now correctly joins multiple tables and qualifies column references to match the intended behavior."
        ],
        "rules": [
            "Ig G higher than normal refers to IGG >= 2000; Should consider DISTINCT in the final result;"
        ]
    },
    "786": {
        "sql": [
            "WITH strength_attribute AS (\n    SELECT id FROM attribute WHERE attribute_name = 'Strength'\n),\nmax_strength AS (\n    SELECT MAX(attribute_value) AS max_value\n    FROM hero_attribute\n    WHERE attribute_id = (SELECT id FROM strength_attribute)\n)\nSELECT COUNT(DISTINCT hero_id) AS hero_count\nFROM hero_attribute\nWHERE attribute_id = (SELECT id FROM strength_attribute)\nAND attribute_value = (SELECT max_value FROM max_strength);"
        ],
        "question": "How many heroes have the highest attribute value in strength?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )",
        "amends": [],
        "rules": [
            "highest attribute value in strength refers to MAX(attribute_value) WHERE attribute_name = 'Strength';"
        ]
    },
    "1001": {
        "sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nJOIN races r ON q.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Marina Bay Street Circuit'\n  AND r.year = 2008\n  AND q.position = 1\n  AND q.q3 IS NOT NULL\nORDER BY q.q3 ASC\nLIMIT 1;",
            "SELECT T1.forename, T1.surname\nFROM drivers T1\nJOIN qualifying T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nWHERE T3.year = 2008\nAND T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')\nAND T3.round = 3\nORDER BY CAST(SUBSTR(T2.q3, 1, INSTR(T2.q3, ':') - 1) AS INTEGER) * 60 + \n         CAST(SUBSTR(T2.q3, INSTR(T2.q3, ':') + 1, INSTR(T2.q3, '.') - INSTR(T2.q3, ':') - 1) AS REAL) + \n         CAST(SUBSTR(T2.q3, INSTR(T2.q3, '.') + 1) AS REAL) / 1000 ASC\nLIMIT 1;",
            "SELECT T2.forename, T2.surname\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T1.raceId = T3.raceId\nWHERE T3.year = 2008\nAND T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')\nAND T3.round = 3\nAND T1.q3 IS NOT NULL\nORDER BY CAST(SUBSTR(T1.q3, 1, INSTR(T1.q3, ':') - 1) AS INTEGER) * 60 + \n         CAST(SUBSTR(T1.q3, INSTR(T1.q3, ':') + 1, INSTR(T1.q3, '.') - INSTR(T1.q3, ':') - 1) AS REAL) + \n         CAST(SUBSTR(T1.q3, INSTR(T1.q3, '.') + 1) AS REAL) / 1000 ASC\nLIMIT 1;",
            "SELECT T2.forename, T2.surname\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races T3 ON T1.raceId = T3.raceId\nWHERE T3.year = 2008\nAND T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')\nAND T1.q3 IS NOT NULL\nORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000\nLIMIT 1"
        ],
        "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
        "amends": [
            "Do select individual columns `forename` and `surname` instead of concatenating them as `full_name`. Do use table aliases `T1`, `T2`, and `T3` instead of single letters. Do remove the explicit `JOIN` with `circuits` table and instead use a subquery `circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit')` in the `WHERE` clause instead of direct table join. Do change the `ORDER BY` to use a complex time conversion formula `CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000` instead of simple `q3 ASC` to properly handle time format conversion. Do remove the `q.position = 1` filter instead of keeping it. The amended query now correctly handles time-based ordering and subquery filtering to match the intended behavior.",
            "Do use `T2.forename` and `T2.surname` from the drivers table instead of `T1.forename` and `T1.surname` from the drivers table. Do join `qualifying AS T1` first instead of starting with `drivers T1`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do join `drivers AS T2` on `T1.driverId = T2.driverId` instead of joining `qualifying T2` on `T1.driverId = T2.driverId`. Do join `races T3` on `T1.raceid = T3.raceid` instead of on `T2.raceId = T3.raceId`. Do add `q3 IS NOT NULL` filter instead of omitting it. Do remove `T3.round = 3` condition instead of keeping it. Do reference `q3` directly instead of `T2.q3` in the ORDER BY expression. The amended query now correctly identifies the fastest qualifying driver at Marina Bay Street Circuit in 2008 by properly handling table joins and ensuring valid qualifying times are considered.",
            "Do remove the redundant `T3.round = 3` filter instead of keeping it, as the circuit condition already uniquely identifies the specific race. Do reference `q3` directly without table alias instead of using `T1.q3` since there's no ambiguity. Do maintain the same `SELECT` list, `FROM` sources with `INNER JOIN` conditions, `WHERE` filters for `year` and circuit subquery, `ORDER BY` time conversion logic, and `LIMIT 1` to find the fastest qualifying driver at Marina Bay in 2008."
        ],
        "rules": [
            "Ranked 1st in the 3rd qualifying race refer to MIN(q3); 2008 is the year of race; full name of racer = forename, surname"
        ]
    },
    "784": {
        "sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Vampire';"
        ],
        "question": "Provide the full names of vampire heroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
        "amends": [],
        "rules": [
            "vampire heroes refers to race = 'Vampire';"
        ]
    },
    "729": {
        "sql": [
            "SELECT AVG(height_cm) AS average_height\nFROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel Comics';"
        ],
        "question": "What is the average height of the superheroes from Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "amends": [],
        "rules": [
            "superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; average height of the superheroes refers to AVG(height_cm)"
        ]
    },
    "969": {
        "sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) = '1980';"
        ],
        "question": "How many British drivers who were born in 1980?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) = '1980'",
        "amends": [],
        "rules": [
            "born in 1980 refers to year(dob) = 1980;"
        ]
    },
    "1343": {
        "sql": [
            "SELECT remaining FROM budget WHERE category = 'Food' ORDER BY amount DESC LIMIT 1;"
        ],
        "question": "With the biggest budget for the \"Food\", what was the remaining of it?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT remaining FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget WHERE category = 'Food' )",
        "amends": [],
        "rules": [
            "remaining of budget refers to remaining, biggest budget for 'Food' refers to MAX(budget.amount) where category = 'Food'"
        ]
    },
    "90": {
        "sql": [
            "SELECT COUNT(DISTINCT a.account_id) AS eligible_accounts\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE d.A3 = 'Prague';"
        ],
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "amends": [],
        "rules": [
            "A3 contains the data of region"
        ]
    },
    "810": {
        "sql": [
            "SELECT r.race\nFROM race r\nJOIN superhero s ON r.id = s.race_id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nWHERE ha.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute)\nLIMIT 1;"
        ],
        "question": "What is the race of the superhero with maximum attribute value?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN race AS T3 ON T1.race_id = T3.id ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [],
        "rules": [
            "maximum attribute value refers to MAX(attribute_value);"
        ]
    },
    "429": {
        "sql": [
            "SELECT s.type AS expansion_type, st.language FROM sets s LEFT JOIN set_translations st ON s.code = st.setCode WHERE s.id = 206;",
            "SELECT T2.language, s.type FROM sets s INNER JOIN set_translations T2 ON s.code = T2.setCode WHERE T2.id = 206"
        ],
        "question": "What is the language and expansion type of set number 206?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language, T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 206",
        "amends": [
            "Do use `INNER JOIN` instead of `LEFT JOIN` to ensure only matching records are returned. Do reference `T2.id` in the WHERE clause instead of `s.id` to filter by the set_translations table's ID rather than the sets table's ID. Do swap the column order in the SELECT list, placing `T2.language` first instead of `s.type AS expansion_type` second. Do use table aliases `T1` and `T2` instead of `s` and `st` for better clarity. Do remove the alias `expansion_type` for the type column instead of keeping it. The amended query now correctly filters by the set_translations table ID and returns only matching records between the two tables."
        ],
        "rules": [
            "set number 206 refers to id = 206"
        ]
    },
    "1465": {
        "sql": [
            "SELECT b.category\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nWHERE e.expense_description = 'Posters';"
        ],
        "question": "Which budget category does the expense 'Posters' fall to?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Posters'",
        "amends": [],
        "rules": [
            "'Posters' refers to expense description"
        ]
    },
    "25": {
        "sql": [
            "SELECT s.School, s.FundingType\nFROM schools s\nJOIN satscores sat ON s.CDSCode = sat.cds\nWHERE s.County = 'Riverside' AND sat.AvgScrMath > 400;",
            "SELECT s.sname, f.\"Charter Funding Type\"\nFROM satscores s\nINNER JOIN frpm f ON s.cds = f.CDSCode\nWHERE f.\"District Name\" LIKE 'Riverside%'\nGROUP BY s.sname, f.\"Charter Funding Type\"\nHAVING CAST(SUM(s.AvgScrMath) AS REAL) / COUNT(s.cds) > 400"
        ],
        "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.sname, T2.`Charter Funding Type` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T2.`District Name` LIKE 'Riverside%' GROUP BY T1.sname, T2.`Charter Funding Type` HAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400",
        "amends": [
            "Do select `sname` and `Charter Funding Type` instead of `School` and `FundingType`. Do join `frpm` table instead of `schools` table, using `INNER JOIN` on `cds = CDSCode` instead of `JOIN` on `CDSCode = cds`. Do filter with `District Name LIKE 'Riverside%'` instead of `County = 'Riverside'`. Do add `GROUP BY` on `sname` and `Charter Funding Type` instead of omitting grouping. Do move the math score filter to `HAVING` with `CAST(SUM(AvgScrMath) AS REAL) / COUNT(cds) > 400` instead of `WHERE AvgScrMath > 400` to properly calculate the average. The amended query now correctly aggregates math scores by school and funding type while filtering for Riverside district schools with average math scores above 400."
        ],
        "rules": [
            "Average of average math = sum(average math scores) / count(schools)."
        ]
    },
    "220": {
        "sql": [
            "SELECT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element ASC LIMIT 3;",
            "SELECT DISTINCT T.element FROM atom T WHERE T.molecule_id = 'TR000' ORDER BY T.element"
        ],
        "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
        "amends": [
            "Do add `DISTINCT` to eliminate duplicate elements instead of returning all occurrences. Do add table alias `T` and qualify column references as `T.element` and `T.molecule_id` instead of using unqualified column names. Do remove the explicit `ASC` direction from the `ORDER BY` clause instead of specifying it, as ascending is the default. The amended query now correctly returns only unique elements from the atom table for molecule_id 'TR000' in alphabetical order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "TR000 is the molecule id;"
        ]
    },
    "243": {
        "sql": [
            "SELECT DISTINCT b.bond_id, b.molecule_id, b.bond_type\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE (a1.element = 'p' AND a2.element = 'n') OR (a1.element = 'n' AND a2.element = 'p');",
            "SELECT b.bond_id\nFROM bond b\nWHERE b.bond_id IN (\n    SELECT c.bond_id\n    FROM connected c\n    JOIN atom a1 ON c.atom_id = a1.atom_id\n    JOIN atom a2 ON c.atom_id2 = a2.atom_id\n    WHERE (a1.element = 'P' AND a2.element = 'N') OR (a1.element = 'N' AND a2.element = 'P')\n)",
            "SELECT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'n'\nAND T2.bond_id IN (\n    SELECT T3.bond_id\n    FROM connected AS T3\n    INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id\n    WHERE T4.element = 'p'\n)"
        ],
        "question": "What are the bonds that have phosphorus and nitrogen as their atom elements?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id IN ( SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p' ) AND T1.element = 'n'",
        "amends": [
            "Do remove `DISTINCT` and the `b.molecule_id` and `b.bond_type` columns instead of including them. Do change the FROM clause to use a single `atom` table aliased as `T1` instead of multiple `atom` and `bond` tables. Do use an `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of complex multi-table joins. Do move the phosphorus element filter to a subquery instead of using OR conditions in the main WHERE clause. Do add a subquery with `T3` and `T4` aliases to find bonds connected to phosphorus atoms instead of checking both atom elements in the main query. Do change the WHERE clause to use `T1.element = 'n'` and an IN condition with the subquery instead of the OR-based element pairing. Do remove the second atom join and the bond table join entirely instead of keeping unnecessary table relationships. The amended query now correctly identifies bonds connecting nitrogen and phosphorus atoms using a more efficient subquery approach that matches the RIGHT_SQL's behavior.",
            "Do change the FROM clause to use `atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id` instead of starting with `bond b` alone. Do add a WHERE filter `T1.element = 'n'` instead of omitting it. Do replace the complex subquery checking for both P-N and N-P pairs with a simpler subquery `SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p'` instead of the original dual-condition OR logic. Do remove the second join to atom table `a2` in the subquery instead of keeping it. The amended query now correctly finds bonds connected to both nitrogen and phosphorus atoms through separate conditions rather than attempting to find P-N bonds in a single operation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "have phosphorus as atom elements refers to element = 'p'; have nitrogen as atom elements refers to element = 'n'"
        ]
    },
    "447": {
        "sql": [
            "SELECT code FROM sets WHERE type = 'expansion' OR type = 'commander';",
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'"
        ],
        "question": "Give the code of sets have expansion commander type?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
        "amends": [
            "Do select `T2.setCode` instead of `code` and change the source to `sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code` instead of just `sets`. Do use the filter `T1.type = 'commander'` instead of `type = 'expansion' OR type = 'commander'` and remove the `OR` condition. The amended query now correctly joins the translation table and filters for only commander sets instead of both expansion and commander types."
        ],
        "rules": [
            "code of sets refers to setCode"
        ]
    },
    "522": {
        "sql": [
            "SELECT c.name AS card_name, l.format AS banned_format\nFROM cards c\nLEFT JOIN legalities l ON c.uuid = l.uuid\nWHERE c.edhrecRank = 1 AND l.status = 'Banned';\n"
        ],
        "question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
        "amends": [],
        "rules": [
            "ranked 1st on EDHRec refers to edhrecRank = 1; banned refers to status = 'Banned'; play format refers to format; cards name refers to name"
        ]
    },
    "909": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN c.country = 'Germany' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_in_germany\nFROM \n    races r\nJOIN \n    circuits c ON r.circuitId = c.circuitId\nWHERE \n    r.name = 'European Grand Prix';"
        ],
        "question": "Among all European Grand Prix races, what is the percentage of the races were hosted in Germany?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.country = 'Germany' THEN T2.circuitID END) AS REAL) * 100 / COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix'",
        "amends": [],
        "rules": [
            "European Grand Prix races refers to races.name = 'European Grand Prix';percentage = divide(COUNT(races where country = Germany and name = 'Europearn Grand Prix'),COUNT(races where name = 'Europearn Grand Prix'))*100"
        ]
    },
    "1213": {
        "sql": [
            "SELECT p.ID, l.ALP, \n       CASE WHEN l.ALP < 300 THEN 'Within normal range' ELSE 'Above normal range' END AS ALP_Status\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Birthday = '1982-04-01';",
            "SELECT T1.ID, \n       CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Birthday = '1982-04-01';"
        ],
        "question": "Name the ID of the patient who is born on the April 1st, 1982. Is his/her alkaliphophatase (ALP) within normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID , CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1982-04-01'",
        "amends": [
            "Do use `CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END` instead of `CASE WHEN l.ALP < 300 THEN 'Within normal range' ELSE 'Above normal range' END AS ALP_Status` for the case expression and alias. Do use `INNER JOIN` instead of `JOIN` for explicit join type specification. Do use table aliases `T1` and `T2` instead of `p` and `l` for Patient and Laboratory tables respectively. Do remove the explicit column alias `ALP_Status` instead of keeping it. The amended query now correctly matches the RIGHT_SQL's behavior with simplified case expression output and standardized table aliasing."
        ],
        "rules": [
            "alkaliphophatase (ALP) within normal range refers to ALP < 300"
        ]
    },
    "1106": {
        "sql": [
            "SELECT pa.defensive_work_rate \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Kevin Berigaud' \nAND pa.date = '2013-02-22 00:00:00';"
        ],
        "question": "Tell the defensive work rate for Kevin Berigaud on 2013/2/22.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.defensive_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-02-22' AND t1.player_name = 'Kevin Berigaud'",
        "amends": [],
        "rules": [
            "Kevin Berigaud refers to player_name = 'Kevin Berigaud'; on 2013/2/22 refers to date = '2013-02-22 00:00:00'"
        ]
    },
    "910": {
        "sql": [
            "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit';"
        ],
        "question": "What's the location coordinates of Silverstone Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit'",
        "amends": [],
        "rules": [
            "location coordinates refers to (lat, lng); Silverstone Circuit refers to circuits.name = 'Silverstone Circuit'"
        ]
    },
    "1086": {
        "sql": [
            "SELECT p_a.heading_accuracy \nFROM Player_Attributes p_a\nJOIN Player p ON p_a.player_api_id = p.player_api_id\nWHERE p.player_name = 'Ariel Borysiuk'\nORDER BY p_a.date DESC\nLIMIT 1;",
            "SELECT t2.heading_accuracy \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Ariel Borysiuk'"
        ],
        "question": "What's the heading accuracy of Ariel Borysiuk?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.heading_accuracy FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ariel Borysiuk'",
        "amends": [
            "Do reference `t2.heading_accuracy` instead of `p_a.heading_accuracy` in the SELECT list. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference `Player AS t1` and `Player_Attributes AS t2` instead of `Player p` and `Player_Attributes p_a` with different aliases. Do remove the `ORDER BY p_a.date DESC LIMIT 1` clause instead of keeping it, as the RIGHT_SQL retrieves all matching records without temporal ordering or row limitation. The amended query now matches RIGHT_SQL's behavior of returning all heading_accuracy values for the specified player without date-based filtering."
        ],
        "rules": []
    },
    "956": {
        "sql": [
            "SELECT d.forename, d.surname\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE strftime('%Y', d.dob) > '1975' AND r.positionOrder = 2;",
            "SELECT T2.forename, T2.surname \nFROM results T1 \nJOIN drivers T2 ON T1.driverId = T2.driverId \nWHERE T1.rank = 2 \nAND STRFTIME('%Y', T2.dob) > '1975'"
        ],
        "question": "Which drivers born after 1975 have been ranked 2? Please give their forenames and surnames.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.forename, T2.surname FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) > '1975' AND T1.rank = 2",
        "amends": [
            "Do use `T1.rank = 2` instead of `r.positionOrder = 2` for the position filter. Do reference the drivers table as `T2` instead of `d` and the results table as `T1` instead of `r` while maintaining the same join condition `T1.driverId = T2.driverId`. Do keep the date filter `STRFTIME('%Y', T2.dob) > '1975'` unchanged. The amended query now correctly filters by rank instead of positionOrder to match the intended logic."
        ],
        "rules": [
            "born after 1975 refers to year(dob) >1975;"
        ]
    },
    "728": {
        "sql": [
            "SELECT c.colour AS eye_colour, COUNT(s.id) AS superhero_count\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'Marvel Comics'\nGROUP BY c.colour\nORDER BY superhero_count DESC;",
            "SELECT \n    c.colour AS EyeColor,\n    COUNT(s.id) AS Count,\n    RANK() OVER (ORDER BY COUNT(s.id) DESC) AS PopularityRank\nFROM \n    superhero s\nINNER JOIN \n    colour c ON s.eye_colour_id = c.id\nINNER JOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    p.publisher_name = 'Marvel Comics'\nGROUP BY \n    c.colour"
        ],
        "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
        "amends": [
            "Do add `RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank` instead of omitting the window function. Do use `INNER JOIN` explicitly instead of just `JOIN` for both joins. Do change the alias `eye_colour` to `EyeColor` instead of keeping the original casing. Do remove the `ORDER BY superhero_count DESC` clause instead of keeping it since the ranking function handles ordering. Do add the `Count` alias instead of `superhero_count` for the aggregate column. The amended query now correctly calculates popularity rankings for eye colors among Marvel Comics superheroes."
        ],
        "rules": [
            "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; most common color refers to COUNT(superhero.id) DESC;"
        ]
    },
    "1030": {
        "sql": [
            "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2015/2016' AND m.home_team_goal = m.away_team_goal\nGROUP BY m.league_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "question": "Give the name of the league had the most matches end as draw in the 2016 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal GROUP BY t2.name ORDER BY COUNT(t1.id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "most matches end as draw refers to MAX(SUM(home_team_goal = away_team_goal)); 2016 season refers to season = '2015/2016';"
        ]
    },
    "957": {
        "sql": [
            "SELECT COUNT(DISTINCT d.driverId) AS italian_drivers_not_finished\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE d.nationality = 'Italian' AND r.time IS NULL;",
            "SELECT COUNT(T1.driverId)\nFROM results AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'Italian' AND T1.time IS NULL"
        ],
        "question": "How many Italian drivers haven't finished the race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Italian' AND T1.time IS NULL",
        "amends": [
            "Do use `COUNT(T1.driverId)` without DISTINCT instead of `COUNT(DISTINCT d.driverId)` to count all Italian drivers who didn't finish rather than unique ones. Do reference `results AS T1` and `drivers AS T2` instead of `drivers d` and `results r` for table aliases. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do place the join condition `T1.driverId = T2.driverId` instead of `d.driverId = r.driverId` to maintain the same logical relationship. Do keep the filter `T2.nationality = 'Italian'` instead of `d.nationality = 'Italian'` and `T1.time IS NULL` instead of `r.time IS NULL` to maintain the same filtering logic. Do remove the column alias `AS italian_drivers_not_finished` instead of keeping it since the right query doesn't include it. The amended query now correctly counts all Italian drivers who didn't finish races rather than just distinct ones, matching the right SQL's behavior."
        ],
        "rules": [
            "haven't finished the race refers to time is null;"
        ]
    },
    "1302": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.CPK < 250\nAND (E.KCT = '+' OR E.RVVT = '+' OR E.LAC = '+');",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.CPK BETWEEN 60 AND 400\nAND (T3.KCT = 'positive' OR T3.RVVT = 'positive' OR T3.LAC = 'positive')",
            "SELECT COUNT(T1.ID)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.CPK < 250\nAND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')"
        ],
        "question": "For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.CPK < 250 AND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')",
        "amends": [
            "Do use `COUNT(T1.ID)` without `DISTINCT` instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patients. Do use explicit `INNER JOIN` instead of implicit `JOIN` for clarity. Do reference columns with table aliases `T2.CPK` and `T3.KCT`/`T3.RVVT`/`T3.LAC` instead of unqualified `L.CPK` and `E.KCT`/`E.RVVT`/`E.LAC` to avoid ambiguity. Do omit the `AS PatientCount` alias instead of including it since the result column name is not needed. The amended query now correctly counts all patient records meeting the laboratory and examination criteria without unnecessary deduplication.",
            "Do change the `T2.CPK` filter to `< 250` instead of `BETWEEN 60 AND 400`. Do change the examination result comparisons to `= '+'` instead of `= 'positive'` for `T3.KCT`, `T3.RVVT`, and `T3.LAC` conditions. The amended query now correctly filters for lower CPK values and uses the proper positive indicator format, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "normal range of creatinine phosphokinase refers to CPK < 250; positive measure of degree of coagulation refers to KCT = '+' or RVVT = '+' or LAC = '+' ;"
        ]
    },
    "809": {
        "sql": [
            "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.id = 38;"
        ],
        "question": "What is the publisher name of the superhero ID 38?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.id = 38",
        "amends": [],
        "rules": [
            "superhero ID 38 refers to superhero.id = 38;"
        ]
    },
    "753": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.height_cm BETWEEN 170 AND 190\nAND c.colour = 'No Colour';"
        ],
        "question": "Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'",
        "amends": [],
        "rules": [
            "height from 170 to 190 refers to height_cm BETWEEN 170 AND 190; no eye color refers to colour = 'No Colour'"
        ]
    },
    "1312": {
        "sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Angela' AND mb.last_name = 'Sanders';"
        ],
        "question": "What's Angela Sanders's major?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "amends": [],
        "rules": [
            "Angela Sanders is the full name; full name refers to first_name, last_name; major refers to major_name."
        ]
    },
    "4": {
        "sql": [
            "SELECT Phone FROM schools WHERE FundingType LIKE '%Direct%' AND OpenDate > '2000-01-01';",
            "SELECT T2.Phone\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Charter School (Y/N)\" = 1\nAND T1.\"Charter Funding Type\" = 'Directly funded'\nAND T2.OpenDate > '2000-01-01'"
        ],
        "question": "Please list the phone numbers of the direct charter-funded schools that are opened after 2000/1/1.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`Charter School (Y/N)` = 1 AND T2.OpenDate > '2000-01-01'",
        "amends": [
            "Do join `frpm AS T1` with `schools AS T2` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table without any join. Do select `T2.Phone` instead of just `Phone` to specify the table source. Do filter on `T1.Charter Funding Type = 'Directly funded'` instead of `FundingType LIKE '%Direct%'` for more precise matching. Do add the condition `T1.Charter School (Y/N) = 1` instead of omitting this charter school filter. Do keep the `T2.OpenDate > '2000-01-01'` filter but reference it through the joined table instead of the original table. The amended query now correctly joins the necessary tables and applies precise filtering conditions to match the intended logic."
        ],
        "rules": [
            "Charter schools refers to `Charter School (Y/N)` = 1 in the frpm"
        ]
    },
    "118": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN l.status = 'C' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    loan l\nJOIN \n    account a ON l.account_id = a.account_id\nWHERE \n    l.amount < 100000;"
        ],
        "question": "For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) FROM loan WHERE amount < 100000",
        "amends": [],
        "rules": [
            "Status = 'C' stands for running contract, ok so far; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100."
        ]
    },
    "1045": {
        "sql": [
            "SELECT pa.attacking_work_rate\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Franco Zennaro';"
        ],
        "question": "What is the attacking work rate of the football playerr Franco Zennaro?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Franco Zennaro'",
        "amends": [],
        "rules": []
    },
    "639": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN t.TagName = 'r' THEN 1 END) * 100.0 / COUNT(p.Id)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    tags t ON p.Tags LIKE '%r%'\nWHERE \n    u.DisplayName = 'Community';",
            "SELECT \n    (CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) / COUNT(*)) * 100\nFROM \n    users AS T1 \n    INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId\n    INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId\nWHERE \n    T1.DisplayName = 'Community'"
        ],
        "question": "Based on posts posted by Community, calculate the percentage of posts that use the R language.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId WHERE T1.DisplayName = 'Community'",
        "amends": [
            "Do use `SUM(IIF(T3.TagName = 'r', 1, 0))` with explicit `CAST` to `REAL` instead of `COUNT(CASE WHEN t.TagName = 'r' THEN 1 END)` for percentage calculation. Do change the FROM clause to use `users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId` instead of `posts p JOIN users u ON p.OwnerUserId = u.Id`, removing the posts table and adding postHistory with a different join condition. Do use `INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId` instead of `LEFT JOIN tags t ON p.Tags LIKE '%r%'`, changing both the join type and predicate to use ExcerptPostId rather than string matching. Do remove the unnecessary percentage alias and keep the WHERE filter on `T1.DisplayName = 'Community'` unchanged. The amended query now correctly calculates the percentage using proper table relationships and avoids the problematic LIKE pattern matching."
        ],
        "rules": [
            "DIVIDE(COUNT(PostId WHERE TagName = 'r')), (COUNT(PostId WHERE DisplayName = 'Community')) as percentage; R language refers to tagname = 'r'"
        ]
    },
    "902": {
        "sql": [
            "SELECT r.name AS race_name, r.date, r.year, r.round \nFROM results res \nJOIN drivers d ON res.driverId = d.driverId \nJOIN races r ON res.raceId = r.raceId \nWHERE d.forename = 'Alex' AND d.surname = 'Yoong' AND res.position < 20;",
            "SELECT races.name FROM races INNER JOIN driverStandings ON driverStandings.raceId = races.raceId INNER JOIN drivers ON drivers.driverId = driverStandings.driverId WHERE drivers.forename = 'Alex' AND drivers.surname = 'Yoong' AND driverStandings.position < 20"
        ],
        "question": "Which race was Alex Yoong in when he was in track number less than 20?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
        "amends": [
            "Do select only `name` instead of multiple columns `race_name`, `date`, `year`, `round`. Do join `driverStandings` instead of `results` as the primary table. Do use `INNER JOIN` on `driverStandings.raceId = races.raceId` instead of joining directly on `results.raceId = races.raceId`. Do join `drivers` through `driverStandings.driverId` instead of `results.driverId`. Do filter on `driverStandings.position < 20` instead of `results.position < 20`. Do remove the `AS` aliases for table names instead of keeping them. The amended query now correctly uses the driver standings data instead of race results to find positions, matching the intended behavior."
        ],
        "rules": [
            "Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;track number less than 10 refers to position < 20"
        ]
    },
    "811": {
        "sql": [
            "SELECT a.alignment, GROUP_CONCAT(sp.power_name, ', ') AS superpowers\nFROM superhero sh\nJOIN alignment a ON sh.alignment_id = a.id\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Atom IV'\nGROUP BY a.alignment;"
        ],
        "question": "Give the alignment and superpowers of the superhero named Atom IV.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T4.alignment, T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN alignment AS T4 ON T1.alignment_id = T4.id WHERE T1.superhero_name = 'Atom IV'",
        "amends": [],
        "rules": [
            "superpowers refers to power_name;"
        ]
    },
    "996": {
        "sql": [
            "SELECT AVG(race_count) AS annual_average_races\nFROM (\n    SELECT year, COUNT(*) AS race_count\n    FROM races\n    WHERE date BETWEEN '2000-01-01' AND '2010-12-31'\n    GROUP BY year\n);",
            "SELECT CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 AS average_races FROM races"
        ],
        "question": "What is the annual average number of races held during the first 10 years of the 21st century?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 FROM races WHERE date BETWEEN '2000-01-01' AND '2010-12-31'",
        "amends": [
            "Do calculate the average using `CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10` instead of `AVG(race_count)` from a subquery. Do remove the subquery structure and `GROUP BY year` instead of keeping them. Do move the year range filter from the subquery's `WHERE` clause to a `CASE` expression in the main query instead of filtering in the subquery. Do handle the division explicitly with `/ 10` instead of relying on `AVG` over grouped counts. The amended query now correctly calculates the average number of races per year between 2000 and 2010 by counting qualifying races and dividing by the 10-year span, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "races in date between '2000-01-01' and '2010-12-31'"
        ]
    },
    "414": {
        "sql": [
            "SELECT st.language\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Ravnica' AND s.baseSetSize = 180;"
        ],
        "question": "What language is the set of 180 cards that belongs to the Ravnica block translated into?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Ravnica' AND T1.baseSetSize = 180",
        "amends": [],
        "rules": [
            "set of 180 cards refers to baseSetSize = 180"
        ]
    },
    "677": {
        "sql": [
            "SELECT COUNT(*) AS post_count\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE users.DisplayName = 'Jay Stevens'\nAND strftime('%Y', posts.CreaionDate) = '2010';"
        ],
        "question": "How many posts did Jay Stevens have in 2010?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2010' AND T1.DisplayName = 'Jay Stevens'",
        "amends": [],
        "rules": [
            "DisplayName = 'Jay Stevens'; in 2010 refers to YEAR(CreationDate) = 2010;"
        ]
    },
    "1390": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN e.event_name = 'Yearly Kickoff' THEN ex.cost ELSE 0 END) / SUM(ex.cost)) * 100 AS percentage_cost\nFROM \n    event e\nJOIN \n    budget b ON e.event_id = b.link_to_event\nJOIN \n    expense ex ON b.budget_id = ex.link_to_budget;"
        ],
        "question": "Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) AS REAL) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "amends": [],
        "rules": [
            "percentage = DIVIDE(SUM(cost where event_name = 'Yearly Kickoff'), SUM(cost)) * 100"
        ]
    },
    "1211": {
        "sql": [
            "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.LDH BETWEEN 600 AND 800;",
            "SELECT DISTINCT T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) - (STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', T1.Birthday)) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH > 600 AND T2.LDH < 800",
            "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.LDH > 600 AND T2.LDH < 800"
        ],
        "question": "Provide the ID and age of patient with lactate dehydrogenase (LDH) between 100-300 index above the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 600 AND T2.LDH < 800",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate patient records. Do reference `STRFTIME('%Y', CURRENT_TIMESTAMP)` instead of `strftime('%Y', 'now')` for proper current year calculation. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do change the LDH filter to `T2.LDH > 600 AND T2.LDH < 800` instead of `L.LDH BETWEEN 600 AND 800` to exclude the boundary values 600 and 800. Do remove the column alias `AS age` instead of keeping it. The amended query now correctly returns distinct patients with LDH values strictly between 600 and 800, matching the intended behavior.",
            "Do remove the age calculation adjustment `- (STRFTIME('%m-%d', CURRENT_TIMESTAMP) < STRFTIME('%m-%d', T1.Birthday)` instead of including it, as the right query only calculates the year difference without adjusting for whether the birthday has occurred this year. Do keep the `SELECT DISTINCT T1.ID` and the basic year difference calculation `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)` instead of modifying it. Do maintain the `INNER JOIN Laboratory T2 ON T1.ID = T2.ID` and the `WHERE T2.LDH > 600 AND T2.LDH < 800` filter unchanged. The amended query now correctly calculates age based solely on year differences without the premature birthday adjustment logic, matching the right SQL's behavior."
        ],
        "rules": [
            "age refers to SUBTRACT(year(current_timestamp), year(Birthday)); lactate dehydrogenase (LDH) between 100-300 index above the normal range refers to LDH between 600 and 800;"
        ]
    },
    "1109": {
        "sql": [
            "SELECT t.team_short_name, ta.buildUpPlayDribblingClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_short_name = 'LEI' AND ta.date = '2015-09-10 00:00:00';",
            "SELECT t2.buildUpPlayDribblingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_short_name = 'LEI' \nAND SUBSTR(t2.date, 1, 10) = '2015-09-10'"
        ],
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "amends": [
            "Do select only `buildUpPlayDribblingClass` instead of including `team_short_name` in the SELECT list. Do use table aliases `t1` and `t2` instead of `t` and `ta`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do change the date comparison to use `SUBSTR(t2.date, 1, 10) = '2015-09-10'` instead of exact timestamp matching `ta.date = '2015-09-10 00:00:00'` to handle potential time components in the date field. The amended query now correctly filters by date substring and returns only the required buildUpPlayDribblingClass value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "\"LEI\" refers to team_short_name = 'LEI'; on 2015/9/10 refers to\u00a0 date = '2015-09-10 00:00:00'"
        ]
    },
    "325": {
        "sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '+' AND a.element = 'n';"
        ],
        "question": "How many carcinogenic molecules that consisted of Nitrogen?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'n' AND T1.label = '+'",
        "amends": [],
        "rules": [
            "nitrogen refers to element = 'n'; label = '+' mean molecules are carcinogenic;"
        ]
    },
    "790": {
        "sql": [
            "SELECT (e.weight_kg - c.weight_kg) AS weight_difference\nFROM superhero e, superhero c\nWHERE e.full_name = 'Emil Blonsky'\nAND c.full_name = 'Charles Chandler';"
        ],
        "question": "Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky' ) - ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler' ) AS CALCULATE",
        "amends": [],
        "rules": [
            "difference = SUBTRACT(SUM(weight_kg WHERE full_name = 'Emil Blonsky'), SUM(weight_kg WHERE full_name = 'Charles Chandler')); Emil Blonsky is the full name of superhero; Charles Chandler is the full name of superhero;"
        ]
    },
    "1181": {
        "sql": [
            "SELECT \n    strftime('%Y', '1991-10-21') - strftime('%Y', p.Birthday) - \n    (CASE \n        WHEN strftime('%m-%d', '1991-10-21') < strftime('%m-%d', p.Birthday) THEN 1 \n        ELSE 0 \n    END) AS Age\nFROM \n    Patient p\nJOIN \n    Laboratory l ON p.ID = l.ID\nWHERE \n    l.UA = 8.4 AND l.Date = '1991-10-21';"
        ],
        "question": "For the patient who got the laboratory test of uric acid level as 8.4 on 1991-10-21, how old was he/she at that time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UA = 8.4 AND T2.Date = '1991-10-21'",
        "amends": [],
        "rules": [
            "how old at that time refers to SUBTRACT(year(test date), year(Birthday)); uric acid level as 8.4 refers to UA = '8.4'; 1991/10/21 refers to Date = '1991-10-21'"
        ]
    },
    "846": {
        "sql": [
            "SELECT d.driverRef\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 20 AND q.q1 IS NOT NULL\nORDER BY q.q1 DESC\nLIMIT 5;"
        ],
        "question": "Please list the reference names of the drivers who are eliminated in the first period in race number 20.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverRef FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 20 ORDER BY T1.q1 DESC LIMIT 5",
        "amends": [],
        "rules": [
            "driver reference name refers to driverRef; first qualifying period refers to q1; drivers who are eliminated in the first qualifying period refers to 5 drivers with MAX(q1); race number refers to raceId;"
        ]
    },
    "33": {
        "sql": [
            "SELECT s.School, s.Website\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.\"Free Meal Count (Ages 5-17)\" BETWEEN 1900 AND 2000;",
            "SELECT T2.Website, T1.\"School Name\"\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Free Meal Count (Ages 5-17)\" BETWEEN 1900 AND 2000\nAND T2.Website IS NOT NULL;"
        ],
        "question": "If there are any, what are the websites address of the schools with a free meal count of 1,900-2,000 to students aged 5-17? Include the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Website, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000 AND T2.Website IS NOT NULL",
        "amends": [
            "Do select `T2.Website` and `T1.School Name` instead of `s.School` and `s.Website`. Do use `INNER JOIN` with alias `T1` for frpm and `T2` for schools instead of unaliased `f` and `s`. Do join on `T1.CDSCode = T2.CDSCode` instead of `f.CDSCode = s.CDSCode`. Do add filter `T2.Website IS NOT NULL` instead of omitting it. The amended query now correctly selects the website from the schools table and school name from frpm while ensuring non-null website values, matching the intended behavior."
        ],
        "rules": []
    },
    "1178": {
        "sql": [
            "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' ORDER BY `First Date` ASC LIMIT 1;",
            "SELECT p.SEX\nFROM Patient p\nWHERE p.Diagnosis = 'AORTITIS' \nAND p.\"First Date\" IS NOT NULL\nORDER BY p.\"First Date\" ASC\nLIMIT 1;"
        ],
        "question": "What was the gender of the first AORTITIS diagnosed patient?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
        "amends": [
            "Do add `AND First Date IS NOT NULL` to the WHERE filter instead of omitting it, which ensures only records with non-null date values are considered for ordering. This prevents potential issues with NULL values being included in the ORDER BY clause and ensures the query returns a meaningful result when sorting by date. The amended query now matches RIGHT_SQL's behavior by properly handling NULL date values."
        ],
        "rules": [
            "gender means SEX; 'AORTITIS' refers to Diagnosis;"
        ]
    },
    "897": {
        "sql": [
            "SELECT d.forename || ' ' || d.surname AS full_name, d.nationality, MAX(ds.points) AS max_points\nFROM drivers d\nJOIN driverStandings ds ON d.driverId = ds.driverId\nWHERE ds.wins = (SELECT MAX(wins) FROM driverStandings)\nGROUP BY d.driverId, d.forename, d.surname, d.nationality\nLIMIT 1;",
            "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) AS max_points\nFROM drivers T1\nINNER JOIN driverStandings T2 ON T2.driverId = T1.driverId\nWHERE T2.wins >= 1\nGROUP BY T1.forename, T1.surname, T1.nationality\nORDER BY COUNT(T2.wins) DESC\nLIMIT 1;"
        ],
        "question": "Name the driver with the most winning. Mention his nationality and what is his maximum point scores.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE T2.wins >= 1 GROUP BY T1.forename, T1.surname, T1.nationality ORDER BY COUNT(T2.wins) DESC LIMIT 1",
        "amends": [
            "Do use `T1.forename`, `T1.surname`, and `T1.nationality` as separate columns instead of concatenating them into `full_name`. Do change the join to `INNER JOIN` instead of `JOIN` and reverse the join condition to `T2.driverId = T1.driverId` instead of `d.driverId = ds.driverId`. Do modify the WHERE filter to `T2.wins >= 1` instead of `ds.wins = (SELECT MAX(wins) FROM driverStandings)`. Do remove `d.driverId` from the GROUP BY clause instead of including it. Do add `ORDER BY COUNT(T2.wins) DESC` instead of omitting ordering. The amended query now correctly identifies drivers with at least one win and orders by win count rather than finding drivers with maximum wins."
        ],
        "rules": [
            "Full name of the driver refers to drivers.forename and drivers.surname; the most winning refers to MAX(COUNT(wins)); average point scores refers to MAX(points);"
        ]
    },
    "567": {
        "sql": [
            "SELECT COUNT(*) AS post_count\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Tiago Pasqualini');"
        ],
        "question": "For the user with the display name of \"Tiago Pasqualini\", how many posts did he/she own?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Tiago Pasqualini'",
        "amends": [],
        "rules": [
            "\"Tiago Pasqualini\" is the DisplayName;"
        ]
    },
    "1080": {
        "sql": [
            "SELECT COUNT(*) AS count_left_foot_players_stay_back\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.preferred_foot = 'left' AND pa.attacking_work_rate = 'low';"
        ],
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "amends": [],
        "rules": [
            "preferred foot when attacking was the left refers to preferred_foot = 'left'; players who would remain in his position when the team attacked refers to attacking_work_rate = 'low';"
        ]
    },
    "1063": {
        "sql": [
            "SELECT p.player_name, pa.potential\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Aaron Doran';",
            "SELECT t2.potential FROM Player t1 INNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'"
        ],
        "question": "What is Aaron Doran's potential score?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
        "amends": [
            "Do select only `potential` instead of including `player_name` in the SELECT list. Do use `INNER JOIN` with explicit table aliases `t1` and `t2` instead of implicit table names `p` and `pa`. Do reference `t2.potential` instead of `pa.potential` to correctly specify the source table. The amended query now matches RIGHT_SQL's behavior by focusing solely on retrieving the potential attribute from the joined tables."
        ],
        "rules": [
            "potential score refers to potential;"
        ]
    },
    "1204": {
        "sql": [
            "SELECT DATEDIFF(`Examination Date`, `First Date`) AS days_to_evaluation\nFROM Examination e\nJOIN Patient p ON e.ID = p.ID\nWHERE e.ID = 821298;",
            "SELECT STRFTIME('%d', T3.\"Examination Date\") - STRFTIME('%d', T1.\"First Date\") \nFROM Patient T1\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T1.ID = 821298"
        ],
        "question": "How long did it take after patient number 821298 arrived at the hospital for the first time before her evaluation began?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%d', T3.`Examination Date`) - STRFTIME('%d', T1.`First Date`) FROM Patient AS T1 INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.ID = 821298",
        "amends": [
            "Do calculate the day difference using `STRFTIME('%d', date)` subtraction instead of `DATEDIFF` function. Do reference `Patient` as `T1` and `Examination` as `T3` instead of using single-letter aliases. Do use `INNER JOIN` with `T1.ID = T3.ID` instead of `JOIN` with `e.ID = p.ID`. Do filter on `T1.ID = 821298` instead of `e.ID = 821298`. Do omit the column alias `days_to_evaluation` instead of including it. The amended query now correctly calculates the day difference between examination and first dates using SQLite-compatible date functions and proper table references."
        ],
        "rules": [
            "DATEDIFF(`Examination Date`, `First Date`)"
        ]
    },
    "1472": {
        "sql": [
            "SELECT c.CustomerID, SUM(ym.Consumption) AS TotalConsumption\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Segment = 'LAM' AND ym.Date LIKE '2012%'\nGROUP BY c.CustomerID\nORDER BY TotalConsumption ASC\nLIMIT 1;",
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;"
        ],
        "question": "In 2012, who had the least consumption in LAM?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do reference the customer table as `T1` instead of `c` and the yearmonth table as `T2` instead of `ym` for consistency. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do change the date filter to use `SUBSTR(T2.Date, 1, 4) = '2012'` instead of `ym.Date LIKE '2012%'` for more precise year extraction. Do remove the `SUM(ym.Consumption) AS TotalConsumption` from the SELECT list instead of including it, as only the CustomerID is needed. Do move the aggregate function to the ORDER BY clause with `ORDER BY SUM(T2.Consumption) ASC` instead of ordering by the alias `TotalConsumption`. The amended query now correctly identifies the customer with the lowest total consumption in 2012 while maintaining the same logical behavior as the RIGHT_SQL."
        ],
        "rules": [
            "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year."
        ]
    },
    "76": {
        "sql": [
            "SELECT s.City\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.EILCode = 'HS'\nAND f.`NSLP Provision Status` = '2'\nAND f.`Low Grade` = '9'\nAND f.`High Grade` = '12'\nAND f.`County Name` = 'Merced';",
            "SELECT T2.City\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"NSLP Provision Status\" = 'Lunch Provision 2'\nAND T1.\"Low Grade\" = 9\nAND T1.\"High Grade\" = 12\nAND T2.County = 'Merced';"
        ],
        "question": "What is the city location of the high school level school with Lunch Provision 2 whose lowest grade is 9 and the highest grade is 12 in the county of Merced?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Lunch Provision 2' AND T2.County = 'Merced' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12 AND T2.EILCode = 'HS'",
        "amends": [
            "Do reference `T2.City` instead of `s.City` and use table alias `T2` for schools instead of `s`. Do use `INNER JOIN` with `frpm AS T1` and `schools AS T2` instead of `JOIN` with `schools s` and `frpm f`. Do filter on `T1.`NSLP Provision Status` = 'Lunch Provision 2'` instead of `'2'` to match the correct value format. Do filter on `T2.County = 'Merced'` instead of `f.`County Name` = 'Merced'` to use the correct table and column for county filtering. Do use numeric values `9` and `12` for grade filters instead of string values `'9'` and `'12'` to match the correct data type. The amended query now correctly joins the tables with proper aliases, uses accurate filter values and data types, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "High school can be represented as EILCode = 'HS'"
        ]
    },
    "1428": {
        "sql": [
            "SELECT z.city, z.state\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE maj.department = 'Electrical and Computer Engineering Department'\nAND m.position = 'Member';"
        ],
        "question": "List the city and state of members enrolled under electrical and computer engineering department.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT city, state FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN zip_code AS T3 ON T3.zip_code = T1.zip WHERE department = 'Electrical and Computer Engineering Department' AND position = 'Member'",
        "amends": [],
        "rules": [
            "'Electrical and Computer Engineering Department' is the department; members enrolled refers to position = 'Member'"
        ]
    },
    "159": {
        "sql": [
            "SELECT t.*\nFROM trans t\nJOIN disp d ON t.account_id = d.account_id\nWHERE d.client_id = 3356 AND t.operation = 'VYBER';",
            "SELECT T4.trans_id\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN account AS T3 ON T2.account_id = T3.account_id\nINNER JOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 3356\nAND T4.operation = 'VYBER KARTOU'\nAND T4.type = 'VYDAJ'",
            "SELECT T4.trans_id\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN account AS T3 ON T2.account_id = T3.account_id\nINNER JOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 3356\nAND T4.operation = 'VYBER'"
        ],
        "question": "List all the withdrawals in cash transactions that the client with the id 3356 makes.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.trans_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 3356 AND T4.operation = 'VYBER'",
        "amends": [
            "Do select `T4.trans_id` instead of `t.*` to return only transaction IDs instead of all transaction columns. Do add joins through `client AS T1` and `account AS T3` instead of omitting them, establishing the proper relationship path from client to transactions. Do use `INNER JOIN` on `T1.client_id = T2.client_id` instead of missing the client table entirely. Do use `INNER JOIN` on `T2.account_id = T3.account_id` instead of joining directly from disposition to transactions without the account intermediary. Do use `INNER JOIN` on `T3.account_id = T4.account_id` instead of joining directly on `t.account_id = d.account_id` which misses the proper account relationship. Do filter on `T1.client_id = 3356` instead of `d.client_id = 3356` to use the client table's primary key. The amended query now correctly navigates the relationship hierarchy from client through disposition and account to transactions, matching the RIGHT_SQL's behavior.",
            "Do use `T4.operation = 'VYBER'` instead of `T4.operation = 'VYBER KARTOU'` in the WHERE clause. Do remove the `AND T4.type = 'VYDAJ'` filter instead of keeping it, as the right query only requires the operation condition without the additional type constraint. The amended query now correctly filters for transactions with operation 'VYBER' only, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "operation = 'VYBER' refers to withdrawal in cash"
        ]
    },
    "941": {
        "sql": [
            "SELECT SUM(points) AS total_points\nFROM results\nWHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton');"
        ],
        "question": "How many points did Lewis Hamilton get in total in all the Formula_1 races he participated?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.points) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'",
        "amends": [],
        "rules": []
    },
    "1148": {
        "sql": [
            "SELECT (COUNT(CASE WHEN p.height < 180 AND pa.strength > 70 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id;",
            "SELECT \n    (CAST(COUNT(CASE WHEN t1.height < 180 AND t2.overall_rating > 70 THEN t1.id ELSE NULL END) AS REAL) / \n     CAST(COUNT(t1.id) AS REAL)) * 100.0 AS percentage\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id;",
            "SELECT \n    (COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) * 100.0 / COUNT(t1.id)) AS percent\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.height < 180"
        ],
        "question": "What is the percentage of players that are under 180 cm who have an overall strength of more than 70?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height < 180",
        "amends": [
            "Do use `t1.id` for counting instead of `*` to avoid potential NULL issues. Do add explicit table aliases `t1` and `t2` instead of ambiguous table references. Do move the `height < 180` filter to the `WHERE` clause instead of including it in the CASE expression. Do change the condition to `overall_rating > 70` instead of `strength > 70` to use the correct column. Do add explicit `CAST` to `REAL` instead of using `100.0` for proper type handling. Do use `ELSE NULL` in the CASE expression instead of implicit NULL handling for clarity. Do specify `INNER JOIN` explicitly instead of just `JOIN` for join type clarity. The amended query now correctly calculates the percentage of players under 180cm height with overall rating above 70, matching the intended behavior.",
            "Do remove the `height < 180` condition from the CASE expression instead of including it there, and do add a WHERE clause filter for `t1.height < 180` instead of omitting it. Do simplify the percentage calculation by using direct multiplication and division instead of the complex nested CAST operations. Do change the alias from `percentage` to `percent` instead of keeping the longer form. The amended query now correctly filters players by height in the WHERE clause before applying the rating condition in the CASE expression, ensuring accurate percentage calculation of players under 180cm with ratings above 70."
        ],
        "rules": [
            "percentage refers to DIVIDE(COUNT(height < 180 AND overall_rating > 70),COUNT(id)) * 100"
        ]
    },
    "978": {
        "sql": [
            "SELECT c.name, c.location, c.lat, c.lng, COUNT(r.raceId) AS race_count\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nWHERE c.country = 'Austria'\nGROUP BY c.circuitId, c.name, c.location, c.lat, c.lng;",
            "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria';"
        ],
        "question": "How many times the circuits were held in Austria? Please give their location and coordinates.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
        "amends": [
            "Do remove the `JOIN races` clause and all race-related columns instead of including them, as the query only needs circuit location data. Do remove the `COUNT(r.raceId)` aggregate and `GROUP BY` clause instead of performing unnecessary grouping and counting. Do add `DISTINCT` to ensure unique location records instead of potentially returning duplicates. Do simplify the SELECT list to only `location, lat, lng` instead of including `name` and unnecessary circuit identifiers. Do keep the `WHERE country = 'Austria'` filter unchanged as it correctly restricts to Austrian circuits. The amended query now correctly returns only distinct location coordinates for Austrian circuits without the race count aggregation."
        ],
        "rules": [
            "location coordinates refers to (lat,lng); Austria refers to country = 'Austria';"
        ]
    },
    "740": {
        "sql": [
            "SELECT COUNT(DISTINCT s.id) AS female_heroes_with_strength_100\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE g.gender = 'Female'\nAND a.attribute_name = 'Strength'\nAND ha.attribute_value = 100;"
        ],
        "question": "How many female superheroes have a strength value of 100?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.attribute_name = 'Strength' AND T2.attribute_value = 100 AND T4.gender = 'Female'",
        "amends": [],
        "rules": [
            "female refers to gender = 'Female'; strength value of 100 refers to attribute_name = 'Strength' AND attribute_value = 100"
        ]
    },
    "222": {
        "sql": [
            "SELECT (SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN label = '-' THEN 1 ELSE 0 END)) AS difference FROM molecule;"
        ],
        "question": "What is the difference between the number of molecules that are carcinogenic and those that are not?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar FROM molecule t",
        "amends": [],
        "rules": [
            "label = '+' means molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; difference = SUBTRACT(SUM(label = '+'), SUM(label = '-'))"
        ]
    },
    "386": {
        "sql": [
            "SELECT COUNT(c.id) AS total_future_frame_cards, l.status AS legality_status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.frameVersion = 'future'\nGROUP BY l.status;",
            "SELECT COUNT(*) \nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.frameVersion = 'future'"
        ],
        "question": "How many cards are having future frame version and what are the legality status of these cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future'",
        "amends": [
            "Do remove the `GROUP BY l.status` clause and the `l.status AS legality_status` column from the SELECT list instead of grouping by legality status and including it in the output. Do use table aliases `T1` for cards and `T2` for legalities instead of the original table names. Do change the join from a simple `JOIN` to an explicit `INNER JOIN` instead of the implicit join type. Do remove the column alias `AS total_future_frame_cards` from the count expression instead of keeping it. The amended query now correctly counts all future frame cards without grouping by legality status, matching the intended behavior."
        ],
        "rules": [
            "future frame version refers to frameVersion = 'future'; legility status refers to status = 'legal';"
        ]
    },
    "610": {
        "sql": [
            "SELECT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Reputation = (SELECT MAX(Reputation) FROM users);",
            "SELECT T2.Name \nFROM users AS T1 \nINNER JOIN badges AS T2 ON T1.Id = T2.UserId \nORDER BY T1.Reputation DESC \nLIMIT 1"
        ],
        "question": "What are the name of badge that users who have the highest reputation obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` instead of `b.Name` to reference the correct table alias. Do use `INNER JOIN` with `users AS T1` and `badges AS T2` instead of `JOIN users u` and `badges b` with proper table aliasing. Do specify the join condition as `T1.Id = T2.UserId` instead of `b.UserId = u.Id` to correctly reference the primary-foreign key relationship. Do remove the subquery filter `WHERE u.Reputation = (SELECT MAX(Reputation) FROM users)` instead of keeping it, as the subquery approach is inefficient for finding maximum reputation. Do add `ORDER BY T1.Reputation DESC LIMIT 1` instead of omitting it, which directly retrieves the badge from the user with highest reputation without requiring a subquery. The amended query now correctly returns the badge name from the user with the highest reputation using an efficient top-1 approach instead of the inefficient subquery comparison."
        ],
        "rules": [
            "highest reputation refers to Max(Reputation); user refers to UserId"
        ]
    },
    "752": {
        "sql": [
            "SELECT superhero.superhero_name\nFROM superhero\nJOIN race ON superhero.race_id = race.id\nWHERE race.race = 'Alien';"
        ],
        "question": "Give the name of the alien superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "amends": [],
        "rules": [
            "alien superheroes refers to race = 'Alien'; name of superhero refers to superhero_name;"
        ]
    },
    "927": {
        "sql": [
            "SELECT d.forename, d.surname\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;"
        ],
        "question": "Which driver created the fastest lap speed in a Formula_1 race? Please give both his forename and surname.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [],
        "rules": []
    },
    "266": {
        "sql": [
            "SELECT COUNT(*) AS total_carcinogenic_molecules\nFROM molecule\nWHERE molecule_id BETWEEN 'TR000' AND 'TR030'\nAND label = '+';"
        ],
        "question": "Calculate the total carcinogenic molecules for molecule id from TR000 to TR030.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.molecule_id BETWEEN 'TR000' AND 'TR030' AND T.label = '+'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic"
        ]
    },
    "71": {
        "sql": [
            "SELECT f.`District Code`\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.City = 'Fresno' AND s.Magnet != 1;"
        ],
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "amends": [],
        "rules": [
            "When magent is equal to 0 in the database, it means ths school doesn't offer a magnet program."
        ]
    },
    "744": {
        "sql": [
            "SELECT \n    (SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics') - \n    (SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'DC Comics') AS difference;"
        ],
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "amends": [],
        "rules": [
            "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = SUBTRACT(SUM(publisher_name = 'Marvel Comics'), SUM(publisher_name = 'DC Comics'))"
        ]
    },
    "850": {
        "sql": [
            "SELECT r.name AS race_name\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Germany';"
        ],
        "question": "Please give the name of the race held on the circuits in Germany.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "amends": [],
        "rules": [
            "Germany is a name of country;"
        ]
    },
    "727": {
        "sql": [
            "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Sauron';"
        ],
        "question": "Who is the publisher of Sauron?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Sauron'",
        "amends": [],
        "rules": [
            "the publisher refers to publisher_name; Sauron refers to superhero_name = 'Sauron'"
        ]
    },
    "448": {
        "sql": [
            "SELECT fd.name AS foreign_name, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'abzan';",
            "SELECT DISTINCT T1.name, T1.type\nFROM cards T1\nINNER JOIN foreign_data T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'abzan'"
        ],
        "question": "Name the foreign name of the card that has abzan watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'abzan'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do use table aliases `T1` and `T2` instead of `c` and `fd` for clarity. Do specify `INNER JOIN` explicitly instead of just `JOIN` to make the join type clear. Do reverse the join condition to `T2.uuid = T1.uuid` instead of `c.uuid = fd.uuid` while maintaining the same logical relationship. Do reference `T1.name` and `T1.type` instead of `fd.name AS foreign_name` and `c.type` to correctly select from the cards table rather than foreign_data. The amended query now correctly returns distinct card names and types from the cards table joined with foreign_data where the watermark condition is met, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "470": {
        "sql": [
            "SELECT s.releaseDate \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Ancestor\\'s Chosen';",
            "SELECT DISTINCT T2.releaseDate FROM cards T1 INNER JOIN sets T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'"
        ],
        "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "amends": [
            "Do use `DISTINCT` on the result set instead of potentially returning duplicate release dates. Do reference the table as `T2` instead of `s` for the releaseDate column. Do use explicit `INNER JOIN` instead of just `JOIN` for clarity. Do reverse the join condition to `T2.code = T1.setCode` instead of `c.setCode = s.code` to maintain consistent table reference order. Do use table aliases `T1` and `T2` instead of `c` and `s` for standardized naming. The amended query now correctly returns distinct release dates without duplicates and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "card set \"Ancestor's Chosen\" refers to name = 'Ancestor''s Chosen'; when released refers to releaseDate"
        ]
    },
    "803": {
        "sql": [
            "SELECT id FROM superpower WHERE power_name = 'cryokinesis';",
            "SELECT id FROM superpower WHERE power_name = 'Cryokinesis';"
        ],
        "question": "What is the power ID of cryokinesis?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT id FROM superpower WHERE power_name = 'Cryokinesis'",
        "amends": [
            "Do use the exact case-sensitive string 'Cryokinesis' instead of 'cryokinesis' in the WHERE filter condition to ensure proper string matching, as the correct value appears to have capital letter formatting in the database. The amended query now correctly matches the RIGHT_SQL's case-sensitive filtering behavior."
        ],
        "rules": [
            "power ID refers to superpower.id; cryokinesis refers to power_name = 'cryokinesis';"
        ]
    },
    "420": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1;"
        ],
        "question": "How many cards are oversized, reprinted, and printed for promotions?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1",
        "amends": [],
        "rules": [
            "are oversized refers to isOversized = 1; reprinted refers to isReprint = 1; printed for promotions refers to isPromo = 1"
        ]
    },
    "673": {
        "sql": [
            "WITH OldestUsers AS (\n    SELECT Id\n    FROM users\n    WHERE Age = (SELECT MAX(Age) FROM users)\n)\nSELECT AVG(PostCount) AS AveragePostsVoted\nFROM (\n    SELECT COUNT(v.PostId) AS PostCount\n    FROM OldestUsers ou\n    LEFT JOIN votes v ON ou.Id = v.UserId\n    GROUP BY ou.Id\n);",
            "SELECT AVG(PostId) \nFROM votes \nWHERE UserId IN (\n    SELECT Id \n    FROM users \n    ORDER BY CreationDate ASC \n    LIMIT 10\n)",
            "SELECT AVG(PostId) \nFROM votes \nWHERE UserId IN (\n    SELECT Id \n    FROM users \n    WHERE Age = (SELECT MAX(Age) FROM users)\n)"
        ],
        "question": "What is the average number of posts voted by the oldest users?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(PostId) FROM votes WHERE UserId IN ( SELECT Id FROM users WHERE Age = ( SELECT MAX(Age) FROM users ) )",
        "amends": [
            "Do use `AVG(PostId)` instead of `AVG(PostCount)` to calculate the average directly from vote records rather than from a grouped count. Do move the user filtering logic to a `WHERE UserId IN` subquery instead of using a CTE with joins. Do remove the `LEFT JOIN` and grouping operation entirely instead of maintaining the complex join structure. Do eliminate the intermediate `PostCount` calculation and nested subquery structure instead of preserving the multi-layered aggregation. Do reference `PostId` directly in the aggregate function instead of counting post IDs through a separate aggregation. The amended query now correctly calculates the average post ID for votes from the oldest users, matching the RIGHT_SQL's behavior.",
            "Do use a subquery that filters users by `Age = (SELECT MAX(Age) FROM users)` instead of ordering by `CreationDate ASC` with `LIMIT 10`. Do remove the unnecessary `ORDER BY` and `LIMIT` clauses from the subquery instead of keeping them. Do add a WHERE condition to select users with maximum age instead of selecting the first 10 users by creation date. The amended query now correctly calculates the average PostId for votes from users who have the maximum age, rather than from an arbitrary set of the 10 earliest created users."
        ],
        "rules": [
            "average number of posts voted refers to AVG(PostId) FROM votes; the oldest users refer to MAX(Age);"
        ]
    },
    "797": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id\nWHERE eye_colour.colour = 'Blue' AND hair_colour.colour = 'Brown';"
        ],
        "question": "Which superheroes have blue eyes with brown hair?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'",
        "amends": [],
        "rules": [
            "which superheroes refers to superhero_name; blue eyes refers to color = 'Blue' and color.id = eye_colour_id; brown hair refers to color = 'Brown' and color.id = hair_colour_id;"
        ]
    },
    "1424": {
        "sql": [
            "SELECT COUNT(*) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large';"
        ],
        "question": "Among the members, how many of them have an extra large t-shirt size?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(member_id) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large'",
        "amends": [],
        "rules": [
            "among the members refers to position = 'Member'; extra large t-shirt size refers to t_shirt_size = 'X-Large'"
        ]
    },
    "451": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE availability LIKE '%paper%' AND hand = '3';"
        ],
        "question": "How many cards available in paper have a positive starting maximum hand size?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN availability = 'paper' AND hAND = '3' THEN 1 ELSE 0 END) FROM cards",
        "amends": [],
        "rules": [
            "available in paper refers to availability like '%paper%'; have a positive starting maximum hand size refers to hand = '3'"
        ]
    },
    "1515": {
        "sql": [
            "SELECT c.Segment\nFROM customers c\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE t.Date = '2012-08-23' AND t.Time = '21:20:00';"
        ],
        "question": "What segment did the customer have at 2012/8/23 21:20:00?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.date = '2012-08-23' AND T1.time = '21:20:00'",
        "amends": [],
        "rules": [
            "'2012/8/23' can be represented by '2012-08-23'"
        ]
    },
    "1088": {
        "sql": [
            "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.volleys > 70 AND pa.dribbling > 70;"
        ],
        "question": "Please list the names of the players whose volley score and dribbling score are over 70.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.volleys > 70 AND t2.dribbling > 70",
        "amends": [],
        "rules": [
            "volley score are over 70 refers to volleys > 70; dribbling score refers to dribbling are over 70 refers to dribbling > 70;"
        ]
    },
    "970": {
        "sql": [
            "SELECT d.driverId, d.forename, d.surname, MIN(l.time) AS earliest_lap_time\nFROM drivers d\nJOIN lapTimes l ON d.driverId = l.driverId\nWHERE d.nationality = 'German' AND strftime('%Y', d.dob) BETWEEN '1980' AND '1990'\nGROUP BY d.driverId, d.forename, d.surname\nORDER BY earliest_lap_time ASC\nLIMIT 3;",
            "SELECT T2.driverId \nFROM pitStops AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T2.nationality = 'German' \nAND strftime('%Y', T2.dob) BETWEEN '1980' AND '1990' \nORDER BY T1.time \nLIMIT 3"
        ],
        "question": "List out top 3 German drivers who were born from 1980-1990 and have the earliest lap time.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990' ORDER BY T1.time LIMIT 3",
        "amends": [
            "Do select only `T2.driverId` instead of including `d.forename`, `d.surname`, and `MIN(l.time)` with an alias. Do use `pitStops AS T1` as the primary table instead of `drivers d` and change to `INNER JOIN drivers AS T2` instead of `JOIN lapTimes l`. Do remove the `GROUP BY` clause entirely instead of grouping by driver details. Do order by `T1.time` directly instead of ordering by the aggregated `earliest_lap_time`. Do maintain the same `WHERE` filter on `nationality` and `dob` year range but reference `T2` instead of `d`. The amended query now correctly finds German drivers born between 1980-1990 with pit stop times instead of lap times, ordering by individual pit stop time rather than minimum lap time, and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "born from 1980-1990 refers to year(dob) between 1980 and 1990; earliest lap time refers to Min(time);"
        ]
    },
    "1136": {
        "sql": [
            "SELECT COUNT(*) AS number_of_players\nFROM Player_Attributes\nWHERE crossing = (SELECT MAX(crossing) FROM Player_Attributes)\nAND preferred_foot = 'left'\nAND attacking_work_rate IS NOT NULL;"
        ],
        "question": "How many players had the highest potential score for crossing that preferred to use their left foots while attacking?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t1.id) FROM Player_Attributes AS t1 WHERE t1.preferred_foot = 'left' AND t1.crossing = ( SELECT MAX(crossing) FROM Player_Attributes)",
        "amends": [],
        "rules": [
            "highest potential score for crossing refers to MAX(crossing); preferred to use their left foots while attacking refers to preferred_foot = 'left'"
        ]
    },
    "32": {
        "sql": [
            "SELECT \n    f.`School Name`,\n    f.`FRPM Count (K-12)`,\n    f.`Enrollment (K-12)`,\n    (f.`FRPM Count (K-12)` / f.`Enrollment (K-12)`) AS `Eligible Rate`\nFROM \n    frpm f\nJOIN \n    schools s ON f.CDSCode = s.CDSCode\nWHERE \n    s.DOC = '66'\nORDER BY \n    f.`FRPM Count (K-12)` DESC\nLIMIT 5;",
            "SELECT CAST(T1.\"FRPM Count (K-12)\" AS REAL) / T1.\"Enrollment (K-12)\" \nFROM frpm T1 \nJOIN schools T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.SOC = 66 \nORDER BY T1.\"FRPM Count (K-12)\" DESC \nLIMIT 5"
        ],
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "amends": [
            "Do cast `FRPM Count (K-12)` as `REAL` in the division instead of using integer division. Do reference the table as `T1` instead of `f` and `T2` instead of `s` for the join. Do filter on `T2.SOC = 66` instead of `s.DOC = '66'` with proper numeric comparison instead of string comparison. Do remove the explicit column selection and aliases `School Name`, `FRPM Count (K-12)`, `Enrollment (K-12)`, and `Eligible Rate` instead of including them, focusing only on the calculated division result. The amended query now correctly handles numeric division and filtering while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "grades 1-12 means K-12; Eligible free or reduced price meal rate for K-12 = `FRPM Count (K-12)` / `Enrollment (K-12)`"
        ]
    },
    "697": {
        "sql": [
            "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';"
        ],
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "amends": [],
        "rules": []
    },
    "1039": {
        "sql": [
            "SELECT AVG(long_shots) AS average_long_shots\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Ahmed Samir Farag');"
        ],
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
        "amends": [],
        "rules": [
            "average number of long shot = DIVIDE(SUM(long_shots), COUNT(player_fifa_api_id));"
        ]
    },
    "1405": {
        "sql": [
            "SELECT b.category, b.amount\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'April Speaker'\nORDER BY b.amount ASC;"
        ],
        "question": "Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category, SUM(T2.amount) FROM event AS T1 JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'April Speaker' GROUP BY T2.category ORDER BY SUM(T2.amount) ASC",
        "amends": [],
        "rules": [
            "'April Speaker' is an event name; amount budgeted refers to SUM(amount); budget categories refers to category"
        ]
    },
    "400": {
        "sql": [
            "SELECT DISTINCT setCode \nFROM set_translations \nWHERE language = 'Spanish';"
        ],
        "question": "Lists the set code of all cards translated into Spanish.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT setCode FROM set_translations WHERE language = 'Spanish'",
        "amends": [],
        "rules": [
            "Spanish refer to language; set code refers to setCode"
        ]
    },
    "356": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE power = '*';"
        ],
        "question": "How many cards have infinite power?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM cards WHERE power = '*'",
        "amends": [],
        "rules": [
            "infinite power refers to power = '*';"
        ]
    },
    "17": {
        "sql": [
            "SELECT s.sname, s.AvgScrWrite, sc.CharterNum\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE s.AvgScrWrite > 499\nORDER BY s.AvgScrWrite DESC;",
            "SELECT \n    sc.CharterNum,\n    s.AvgScrWrite,\n    RANK() OVER (ORDER BY s.AvgScrWrite DESC) as ranking\nFROM \n    satscores s\nINNER JOIN \n    schools sc ON s.cds = sc.CDSCode\nWHERE \n    s.AvgScrWrite > 499\n    AND sc.CharterNum IS NOT NULL"
        ],
        "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
        "amends": [
            "Do select `CharterNum`, `AvgScrWrite`, and `RANK() OVER (ORDER BY AvgScrWrite DESC)` instead of `s.sname`, `s.AvgScrWrite`, and `sc.CharterNum`. Do use `INNER JOIN` with `T1.CDSCode = T2.cds` instead of `JOIN` with `s.cds = sc.CDSCode`. Do add filter `CharterNum is not null` instead of omitting it. Do remove `ORDER BY s.AvgScrWrite DESC` instead of keeping it since the ranking function handles ordering. The amended query now correctly ranks writing scores while ensuring charter schools are properly identified and filtered."
        ],
        "rules": [
            "Valid charter number means the number is not null"
        ]
    },
    "1012": {
        "sql": [
            "SELECT c.lat, c.lng\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN races ra ON r.raceId = ra.raceId\nJOIN circuits c ON ra.circuitId = c.circuitId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND r.time = (SELECT MIN(time) FROM results WHERE driverId = d.driverId);",
            "SELECT T1.position \nFROM lapTimes AS T1\nJOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'\nORDER BY T1.time ASC\nLIMIT 1;"
        ],
        "question": "What was the position of the circuits during Lewis Hamilton's fastest lap in a Formula_1 race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.position FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.time ASC LIMIT 1",
        "amends": [
            "Do select `T1.position` instead of `c.lat, c.lng`. Do use `lapTimes AS T1` as the main table instead of multiple joins across `drivers`, `results`, `races`, and `circuits`. Do join `drivers AS T2` on `T1.driverId = T2.driverId` instead of joining `results` on `d.driverId = r.driverId` and subsequent circuit joins. Do move the driver name filter `T2.forename = 'Lewis' AND T2.surname = 'Hamilton'` to the WHERE clause instead of keeping it there but with different table references. Do remove the subquery for minimum time and instead use `ORDER BY T1.time ASC LIMIT 1` to get the fastest lap record instead of finding minimum time through a correlated subquery. Do add explicit `ORDER BY` and `LIMIT` clauses instead of relying on subquery aggregation. The amended query now correctly retrieves the position from lapTimes for Lewis Hamilton's fastest lap rather than attempting to get circuit coordinates for his fastest result time."
        ],
        "rules": [
            "fastest lap refers to MIN(time)"
        ]
    },
    "1449": {
        "sql": [
            "SELECT m.first_name, m.last_name, ma.major_name\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE e.cost > 100;"
        ],
        "question": "What is the name and major of members who had to spend more than a hundred dollars on an expense?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.first_name, T1.last_name, T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE T3.cost > 100",
        "amends": [],
        "rules": [
            "full name refers to first_name, last_name; major of members refers to major_name; spend more than a hundred dollars on an expense refers to cost > 100"
        ]
    },
    "608": {
        "sql": [
            "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:25:47.0';",
            "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:16:14.0';"
        ],
        "question": "State the detailed content of the comment which was created on 7/19/2010 7:25:47 PM.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:16:14.0'",
        "amends": [
            "Do filter by `CreationDate = '2010-07-19 19:16:14.0'` instead of `CreationDate = '2010-07-19 19:25:47.0'` to query comments created at the correct timestamp. The amended query now matches RIGHT_SQL's behavior by selecting comments from the specified date and time."
        ],
        "rules": [
            "detailed content of the comment refers to Text; created on 7/19/2010 7:16:14 PM refers to CreationDate = '2010-07-19 19:16:14.0'"
        ]
    },
    "206": {
        "sql": [
            "SELECT a.element \nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_id = 'TR004_8_9';\n"
        ],
        "question": "What elements are in the TR004_8_9 bond atoms?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'",
        "amends": [],
        "rules": [
            "TR004_8_9 bond atoms refers to bond_id = 'TR004_8_9';"
        ]
    },
    "1184": {
        "sql": [
            "SELECT e.Symptoms\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Birthday = '1959-03-01'\nAND e.`Examination Date` = '1993-09-27';"
        ],
        "question": "For the patient whose birthday was 1959/3/1, what symptoms did he/she have during the examination on 1993/9/27?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-03-01' AND T2.`Examination Date` = '1993-09-27'",
        "amends": [],
        "rules": []
    },
    "508": {
        "sql": [
            "SELECT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1;"
        ],
        "question": "What are the available printing types of the cards that doesn't have a text box created by Aleksi Briclot?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1",
        "amends": [],
        "rules": [
            "created by Aleksi Briclot refers to artist = 'Aleksi Briclot'; doesn't have a text box refers to isTextless = 1; available printing types refers to availability"
        ]
    },
    "1274": {
        "sql": [
            "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE (l.SSB IN ('negative', '0')) AND e.Symptoms IS NOT NULL;",
            "SELECT COUNT(T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Symptoms IS NOT NULL"
        ],
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "amends": [
            "Do use `T1.ID` as the count column instead of `p.ID`. Do join `Examination AS T1` as the primary table instead of `Patient p`. Do use `INNER JOIN Laboratory AS T2` with `T1.ID = T2.ID` instead of separate joins on Patient, Laboratory, and Examination tables. Do change the WHERE condition to `T2.SSB = 'negative' OR '0'` instead of `l.SSB IN ('negative', '0')`. Do keep `T1.Symptoms IS NOT NULL` filter but reference it through the T1 alias instead of e alias. Do remove the DISTINCT modifier from the COUNT function instead of keeping it. The amended query now correctly counts patients from Examination with matching Laboratory records having specific SSB values and non-null Symptoms, matching the RIGHT_SQL's behavior.",
            "Do add `DISTINCT` to `COUNT(T1.ID)` instead of counting duplicates. Do fix the WHERE clause predicate by removing the incorrect `T2.SSB =` before '0' instead of having redundant column reference. Do keep all other elements including the `INNER JOIN` on `T1.ID = T2.ID`, the `SSB` filter conditions, and the `Symptoms IS NOT NULL` check unchanged. The amended query now correctly counts distinct patient IDs and properly handles the SSB filter condition.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR conditions to ensure correct logical evaluation where both conditions test the SSB column values rather than comparing against a literal string '0' as a standalone boolean expression.",
            "Do use the correct logical operator precedence by removing parentheses around `T2.SSB = 'negative' OR T2.SSB = '0'` instead of enclosing them, which changes the evaluation order. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Symptoms IS NOT NULL` filter without alteration. The amended query now correctly evaluates the OR condition without unnecessary grouping and matches the RIGHT_SQL's behavior.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would always evaluate to true due to the literal '0' being treated as a truthy value. The amended query properly groups the OR conditions to ensure only records with SSB equal to 'negative' or '0' are filtered, fixing the logical bug where the second condition would incorrectly match all records. The amended query now correctly implements the intended filtering logic and matches the RIGHT_SQL's behavior.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. Do maintain the `INNER JOIN` on `T1.ID = T2.ID` and the `COUNT(DISTINCT T1.ID)` aggregation with the `T1.Symptoms IS NOT NULL` filter unchanged. The amended query now correctly handles the SSB filter logic and matches the RIGHT_SQL's intended behavior.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of omitting them, which changes the logical evaluation order and could produce incorrect results due to operator precedence. The amended query now correctly groups the OR conditions together before applying the AND condition with `T1.Symptoms IS NOT NULL`, ensuring the query matches the intended logic and behavior of the RIGHT_SQL.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to correctly filter for SSB values that are either 'negative' or '0' while maintaining the Symptoms IS NOT NULL filter. The amended query now matches RIGHT_SQL's behavior with correct logical grouping.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to correctly filter for SSB values that are either 'negative' or '0', ensuring accurate counting of distinct IDs from patients with non-null symptoms. The amended query now matches RIGHT_SQL's behavior with proper logical grouping.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to ensure both SSB values are correctly compared against the T2.SSB column, maintaining the intended logic of counting distinct IDs where SSB is either 'negative' or '0' and symptoms are not null. The amended query now matches RIGHT_SQL's behavior with correct conditional logic.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of omitting them, which changes the logical evaluation order and could produce incorrect results due to operator precedence. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Symptoms IS NOT NULL` filter without changes. The amended query now correctly groups the OR condition to ensure proper boolean logic evaluation, matching the RIGHT_SQL's behavior.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would always evaluate as true for the second condition. The amended query properly groups the OR conditions to ensure correct logical evaluation while maintaining the same join structure, SELECT list, and other filters. The corrected query now matches the intended behavior of counting distinct IDs where SSB is either 'negative' or '0' and Symptoms are not null.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of omitting them, which changes the logical evaluation order and could include unintended records. Do maintain the explicit column reference `T2.SSB = '0'` instead of using the literal string `'0'` alone, which would always evaluate to true and fundamentally alter the filter logic. The amended query now correctly matches RIGHT_SQL's behavior by preserving the intended filtering conditions.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to ensure correct logical evaluation where SSB must be either 'negative' or '0', rather than allowing any row where SSB equals 'negative' or where the literal string '0' is truthy. This change fixes the predicate logic to match the intended filtering behavior.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would cause a logical error by treating the string literal '0' as a boolean condition. The amended query properly groups the OR conditions to correctly filter for SSB values that are either 'negative' or '0' while maintaining the Symptoms filter, ensuring the count accurately reflects patients with either negative or zero SSB results who have reported symptoms.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrect grouping that changes the logic. The WHERE clause should be `WHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Symptoms IS NOT NULL` instead of `WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL` which incorrectly treats '0' as a boolean expression rather than a value comparison. This ensures proper filtering for SSB values of either 'negative' or '0' while also requiring non-null Symptoms, matching the intended logic and behavior of the RIGHT_SQL.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the OR condition with the AND operator. Specifically, do use `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of `T2.SSB = 'negative' OR '0'` to properly evaluate the SSB condition before applying the Symptoms filter. The amended query now correctly counts distinct IDs from patients with either negative or zero SSB results who also have non-null symptoms, matching the intended behavior.",
            "Do use the correct WHERE clause predicate `T2.SSB = 'negative' OR '0'` instead of the incorrect `(T2.SSB = 'negative' OR T2.SSB = '0')` which has redundant parentheses and duplicate column references. The amended query now correctly matches the RIGHT_SQL's behavior with the proper logical condition structure.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the OR condition with the AND operator. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` between Examination and Laboratory tables. Do keep the `T1.Symptoms IS NOT NULL` filter unchanged. The amended query now correctly evaluates the OR condition before applying the AND operator, matching the RIGHT_SQL's behavior.",
            "Do use the correct logical operator precedence with parentheses around the OR condition instead of incorrectly grouping the conditions, specifically changing the WHERE clause to `T2.SSB = 'negative' OR '0'` instead of `(T2.SSB = 'negative' OR T2.SSB = '0')` to properly handle the OR logic with the AND condition. The amended query now correctly matches the RIGHT_SQL's behavior by fixing the predicate structure."
        ],
        "rules": [
            "anti-SSB are normal refers to SSB IN ('negative', '0'); have other symptoms refers to Symptoms IS NOT NULL; Should compute the number of distinct ones"
        ]
    },
    "896": {
        "sql": [
            "WITH hamilton_races AS (\n    SELECT COUNT(*) AS total_races\n    FROM results r\n    JOIN drivers d ON r.driverId = d.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE d.surname = 'Hamilton' AND rc.year >= 2010\n),\nhamilton_not_first AS (\n    SELECT COUNT(*) AS not_first_races\n    FROM results r\n    JOIN drivers d ON r.driverId = d.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE d.surname = 'Hamilton' AND rc.year >= 2010 AND r.position > 1\n)\nSELECT (not_first_races * 100.0 / total_races) AS percentage\nFROM hamilton_races, hamilton_not_first;",
            "SELECT \n    (CAST(COUNT(CASE WHEN ds.position <> 1 THEN ds.driverStandingsId END) AS REAL) / \n     CAST(COUNT(ds.driverStandingsId) AS REAL)) * 100 AS percentage_not_first\nFROM \n    driverStandings ds\nJOIN \n    races r ON ds.raceId = r.raceId\nJOIN \n    drivers d ON ds.driverId = d.driverId\nWHERE \n    d.surname = 'Hamilton' \n    AND r.year >= 2010;"
        ],
        "question": "Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.surname = 'Hamilton' AND T1.year >= 2010",
        "amends": [
            "Do use `driverStandings` table instead of `results` table for position data. Do join `races` with `driverStandings` on `raceId` instead of joining `results` with `races`. Do filter on `T3.surname = 'Hamilton'` and `T1.year >= 2010` in WHERE clause instead of using CTEs. Do calculate percentage using `COUNT(CASE WHEN T2.position <> 1 THEN T2.position END)` for non-first positions instead of separate CTE counts. Do use `CAST(... AS REAL)` for precise division instead of implicit casting. Do remove CTE structure and perform single query instead of multiple common table expressions. Do reference `driverStandingsId` for total count instead of counting all rows. The amended query now correctly calculates the percentage of races where Hamilton didn't finish first using the appropriate standings data."
        ],
        "rules": [
            "percentage = DIVIDE(COUNT(raceId) where surname = 'Hamilton' and position>1), (COUNT(raceId) where surname = 'Hamilton'); since 2010 refers to year >= 2010"
        ]
    },
    "998": {
        "sql": [
            "SELECT wins FROM driverStandings WHERE driverId = (SELECT driverId FROM driverStandings ORDER BY points DESC LIMIT 1 OFFSET 90);",
            "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) AS total_wins FROM driverStandings;"
        ],
        "question": "In terms of number of points acquired, how many victories did the driver who ranked 91st acquired?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) FROM driverStandings",
        "amends": [
            "Do use `SUM(CASE WHEN points = 91 THEN wins ELSE 0 END)` instead of selecting `wins` directly. Do remove the subquery `(SELECT driverId FROM driverStandings ORDER BY points DESC LIMIT 1 OFFSET 90)` instead of using it to filter by driverId. Do aggregate the wins for all rows where points equal 91 instead of retrieving wins for a single driver at a specific ranking position. The amended query now correctly calculates the total wins for drivers with exactly 91 points, matching the intended behavior."
        ],
        "rules": [
            "victories refer to wins; 91st refers to points\n\n"
        ]
    },
    "317": {
        "sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN a.element = 'cl' THEN m.molecule_id END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage\nFROM \n    molecule m\nLEFT JOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = '+';",
            "SELECT \n    (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'Cl' THEN T2.molecule_id END) * 100) / COUNT(CASE WHEN T2.label = '+' THEN T2.molecule_id END) AS percentage\nFROM \n    atom T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T2.label = '+'",
            "SELECT \n    (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id END) * 100 / COUNT(T2.molecule_id)\nFROM \n    atom T1\nINNER JOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id;",
            "SELECT \n    (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id)\nFROM \n    atom AS T1\nINNER JOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id;",
            "SELECT (COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id)) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id;"
        ],
        "question": "Calculate the percentage of carcinogenic molecules which contain the Chlorine element.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "amends": [
            "Do use `INNER JOIN` between `atom` and `molecule` instead of `LEFT JOIN` to ensure only molecules with atoms are considered. Do reference the joined tables as `T1` for atom and `T2` for molecule instead of the original table names. Do place the `label = '+'` filter in the `CASE` condition instead of the `WHERE` clause to include all molecules in the denominator calculation. Do use `COUNT()` without `DISTINCT` instead of `COUNT(DISTINCT)` since molecule_id values are already unique within the context. Do calculate the percentage using integer division instead of floating-point multiplication by `100.0`. Do remove the explicit `ELSE NULL` from the `CASE` statement as it's the default behavior. The amended query now correctly calculates the percentage of molecules labeled '+' that contain chlorine atoms by ensuring proper join semantics and accurate denominator inclusion.",
            "Do use `COUNT(T2.molecule_id)` in the denominator instead of `COUNT(CASE WHEN T2.label = '+' THEN T2.molecule_id END)` to count all joined molecules rather than filtering by label again. Do add `ELSE NULL` to the CASE expression instead of omitting it for explicit NULL handling. Do use lowercase `'cl'` instead of `'Cl'` for the element comparison to match case-sensitive requirements. Do remove the WHERE clause filter `T2.label = '+'` instead of keeping it since the label filtering is already handled within the CASE expressions. Do omit the column alias `AS percentage` instead of including it as the query no longer requires named output. The amended query now correctly calculates the percentage of chlorine atoms in positively labeled molecules by counting all molecules in the denominator while maintaining proper case sensitivity and NULL handling.",
            "Do add `ELSE NULL` to the `CASE` expression instead of omitting it, ensuring proper handling of non-matching cases in the conditional count. Do use explicit `AS` aliases for table references `atom AS T1` and `molecule AS T2` instead of implicit aliasing. The amended query now correctly handles NULL values in the CASE expression and maintains the same join logic and aggregation behavior.",
            "Do use the exact same SELECT expression without any formatting changes instead of adding unnecessary line breaks and indentation, as both queries have identical logical structure with the same columns, aggregates, join conditions, and calculations. The amended query now matches RIGHT_SQL's behavior with no functional differences."
        ],
        "rules": [
            "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+' and element = 'cl'), COUNT(molecule_id)) as percentage"
        ]
    },
    "419": {
        "sql": [
            "SELECT COUNT(*) FROM cards WHERE borderColor = 'borderless' AND edhrecRank > 12000;"
        ],
        "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
        "amends": [],
        "rules": [
            "color cards with no borders refers to borderColor = 'borderless'; ranked higher than 12000 on EDHRec refers to edhrecRank > 12000"
        ]
    },
    "250": {
        "sql": [
            "SELECT m.molecule_id, COUNT(b.bond_id) AS double_bond_count\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE m.label = '+' AND b.bond_type = ' = '\nGROUP BY m.molecule_id\nORDER BY double_bond_count DESC\nLIMIT 1;",
            "SELECT molecule_id FROM (\n    SELECT m.molecule_id, COUNT(T1.bond_type) AS double_bond_count\n    FROM molecule m\n    INNER JOIN bond T1 ON m.molecule_id = T1.molecule_id\n    WHERE m.label = 'carcinogenic' AND T1.bond_type = '='\n    GROUP BY m.molecule_id\n    ORDER BY COUNT(T1.bond_type) DESC\n    LIMIT 1\n) T",
            "SELECT T.molecule_id\nFROM (\n    SELECT T3.molecule_id, COUNT(T1.bond_type) \n    FROM bond T1\n    INNER JOIN molecule T3 ON T1.molecule_id = T3.molecule_id\n    WHERE T3.label = '+' AND T1.bond_type = '='\n    GROUP BY T3.molecule_id\n    ORDER BY COUNT(T1.bond_type) DESC\n    LIMIT 1\n) T"
        ],
        "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do use `T1.bond_type = '='` instead of `b.bond_type = ' = '` to remove the extra spaces around the equals sign. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do alias tables as `T1` and `T3` instead of `b` and `m` for consistency. Do wrap the entire query in a subquery `T` instead of selecting directly from the main query. Do order by `COUNT(T1.bond_type)` instead of `double_bond_count` to reference the aggregate function directly. Do select only `molecule_id` in the outer query instead of including both `molecule_id` and `double_bond_count`. The amended query now correctly matches the behavior of counting double bonds with proper equality comparison and returns only the molecule_id with the highest count.",
            "Do filter on `T3.label = '+'` instead of `m.label = 'carcinogenic'` in the WHERE clause. Do reference the subquery alias as `T` instead of omitting it in the outer SELECT. Do use table alias `T3` for molecule table instead of `m` in the subquery. Do remove the column alias `AS double_bond_count` instead of keeping it. The amended query now correctly filters for molecules with '+' label and returns the molecule_id with the highest count of double bonds from the subquery."
        ],
        "rules": [
            "label = '+' mean molecules are carcinogenic; double bond refers to bond_type = ' = ';"
        ]
    },
    "1494": {
        "sql": [
            "SELECT \n    (COUNT(CASE WHEN Segment = 'Premium' THEN 1 END) * 100.0 / COUNT(*)) AS PercentagePremium\nFROM \n    gasstations\nWHERE \n    Country = 'Slovakia';",
            "SELECT (SUM(IIF(Segment = 'Premium', 1, 0)) * 100.0 / COUNT(GasStationID)) FROM gasstations WHERE Country = 'SVK';"
        ],
        "question": "What percentage of Slovakian gas stations are premium?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / COUNT(GasStationID) FROM gasstations WHERE Country = 'SVK'",
        "amends": [
            "Do use `SUM(IIF(Segment = 'Premium', 1, 0))` instead of `COUNT(CASE WHEN Segment = 'Premium' THEN 1 END)` for counting premium segments. Do cast the sum to `FLOAT` instead of using `100.0` for proper decimal division. Do divide by `COUNT(GasStationID)` instead of `COUNT(*)` to count specific identifiers rather than all rows. Do change the country filter to `'SVK'` instead of `'Slovakia'` to use the country code format. Do remove the column alias `PercentagePremium` instead of keeping it. The amended query now correctly calculates the percentage using proper counting and casting methods with the appropriate country code filter."
        ],
        "rules": [
            "Percentage of premium gas station = (Total of premium gas station in Slovakia / Total of gas station in Slovakia) * 100%."
        ]
    },
    "518": {
        "sql": [
            "WITH banned_counts AS (\n    SELECT format, COUNT(*) AS banned_count\n    FROM legalities\n    WHERE status = 'Banned'\n    GROUP BY format\n),\nmax_banned AS (\n    SELECT format, banned_count\n    FROM banned_counts\n    WHERE banned_count = (SELECT MAX(banned_count) FROM banned_counts)\n)\nSELECT c.name AS card_name, mb.format\nFROM max_banned mb\nJOIN legalities l ON mb.format = l.format AND l.status = 'Banned'\nJOIN cards c ON l.uuid = c.uuid\nORDER BY c.name;",
            "WITH banned_counts AS (\n    SELECT \n        format,\n        COUNT(*) AS count_banned\n    FROM legalities\n    WHERE status = 'Banned'\n    GROUP BY format\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)\nSELECT \n    T2.format,\n    T1.name\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nINNER JOIN banned_counts AS bc ON T2.format = bc.format\nWHERE T2.status = 'Banned';"
        ],
        "question": "Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
        "amends": [
            "Do use `COUNT(*) AS count_banned` instead of `COUNT(*) AS banned_count` in the CTE definition. Do restructure the CTE to use `ORDER BY COUNT(*) DESC LIMIT 1` instead of a subquery with `MAX(banned_count)` to find the format with maximum banned cards. Do change the join order to start with `cards AS T1` instead of beginning with the CTE results. Do use `INNER JOIN legalities AS T2` instead of joining legalities through the CTE relationship. Do move the `status = 'Banned'` filter to the `WHERE` clause instead of keeping it in the join condition. Do select `T2.format, T1.name` instead of `c.name AS card_name, mb.format` for the output columns. Do remove the explicit `ORDER BY c.name` clause instead of keeping it since the RIGHT_SQL doesn't require sorted results. The amended query now correctly identifies cards that are banned in the format with the highest number of banned cards and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "play format refers to format; banned status refers to status = 'Banned'; the highest number of banned status refers to MAX(COUNT(status = 'Banned'))"
        ]
    },
    "554": {
        "sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN (\n    SELECT UserId, COUNT(*) AS badge_count\n    FROM badges\n    GROUP BY UserId\n) b ON u.Id = b.UserId\nORDER BY b.badge_count DESC\nLIMIT 1;"
        ],
        "question": "What is the display name of the user who has obtained the most number of badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id GROUP BY T2.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "who obtained the most number of badges refers to UserID with Max(Count(Id))"
        ]
    },
    "235": {
        "sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '+' AND a.element = 'br';"
        ],
        "question": "How many molecules are carcinogenic and have the bromine element?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'br'",
        "amends": [],
        "rules": [
            "label = '+' mean molecules are carcinogenic; have bromine element refers to element = 'br'"
        ]
    },
    "656": {
        "sql": [
            "SELECT p2.OwnerDisplayName\nFROM posts p1\nJOIN posts p2 ON p1.ParentId = p2.Id\nWHERE p1.ParentId IS NOT NULL\nORDER BY p1.Score DESC\nLIMIT 1;",
            "SELECT u.DisplayName\nFROM users u\nWHERE u.Id = (\n    SELECT p.OwnerUserId\n    FROM posts p\n    WHERE p.ParentId IS NOT NULL\n    ORDER BY p.Score DESC\n    LIMIT 1\n);"
        ],
        "question": "Describe the display name of the parent ID for child post with the highest score.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts WHERE ParentId IS NOT NULL ORDER BY Score DESC LIMIT 1 )",
        "amends": [
            "Do use a subquery to select `OwnerUserId` from `posts` with `ParentId IS NOT NULL` ordered by `Score DESC` instead of joining `posts` to itself on `ParentId = Id`. Do then query `users` table for `DisplayName` where `Id` matches the subquery result instead of selecting `OwnerDisplayName` directly from the posts table. Do remove the self-join condition and WHERE filter on `ParentId` since these are handled in the subquery instead of applying them in the main query. Do change the output column to `DisplayName` from the users table instead of `OwnerDisplayName` from the posts table to ensure proper user identification. The amended query now correctly identifies the user with the highest-scoring post that has a parent, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "If the parent id is not null, the post is the child post; the highest score refers to MAX(Score);"
        ]
    },
    "930": {
        "sql": [
            "SELECT r.name AS race_name, rs.rank, rs.positionText, rs.points\nFROM results rs\nJOIN races r ON rs.raceId = r.raceId\nJOIN drivers d ON rs.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nORDER BY rs.rank ASC\nLIMIT 1;",
            "SELECT name FROM races WHERE raceId IN (SELECT raceId FROM results WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') AND rank = 1);"
        ],
        "question": "In which Formula_1 race did Lewis Hamilton rank the highest?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE raceId IN ( SELECT raceId FROM results WHERE rank = 1 AND driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) )",
        "amends": [
            "Do select only `name` instead of multiple columns including `race_name`, `rank`, `positionText`, and `points`. Do use a subquery in the `WHERE` clause with `raceId IN` instead of joining directly to `races` and `drivers`. Do filter for `rank = 1` in the subquery instead of ordering by `rank ASC` with `LIMIT 1`. Do use a nested subquery to get the `driverId` from `drivers` with the name conditions instead of joining to the `drivers` table. Do remove the explicit `ORDER BY` and `LIMIT` clauses instead of keeping them, as the `rank = 1` filter achieves the same result. The amended query now correctly identifies races where Lewis Hamilton achieved first place by using proper subquery filtering instead of join-based ranking."
        ],
        "rules": [
            "rank the highest refers to min(rank); Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;"
        ]
    },
    "898": {
        "sql": [
            "SELECT forename, surname, (strftime('%Y', 'now') - strftime('%Y', dob)) AS age FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1;",
            "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename, surname FROM drivers WHERE nationality = 'Japanese' ORDER BY STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob) ASC LIMIT 1;"
        ],
        "question": "How old is the youngest Japanese driver? What is his name?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
        "amends": [
            "Do calculate age directly as `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob)` instead of using an alias `age` in the SELECT list. Do place the age calculation expression first in the SELECT list instead of after the name columns. Do use `CURRENT_TIMESTAMP` instead of the string literal `'now'` for the current date reference. Do remove the explicit column alias `AS age` instead of keeping it. The amended query now correctly calculates age without aliasing and uses proper timestamp functions to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);"
        ]
    },
    "771": {
        "sql": [
            "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Flight';"
        ],
        "question": "List the name of superheroes with flight power.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Flight'",
        "amends": [],
        "rules": [
            "name of superheroes refers to superhero_name; flight power refers to power_name = 'Flight';"
        ]
    },
    "398": {
        "sql": [
            "SELECT SUM(manaCost) AS total_unconverted_mana_cost FROM cards WHERE artist = 'Rob Alexander';",
            "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'"
        ],
        "question": "What is the  unconverted mana do all the cards created by Rob Alexander cost in total?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
        "amends": [
            "Do remove the `SUM` aggregate function and `AS total_unconverted_mana_cost` alias instead of keeping them, and do return the raw `manaCost` values instead of summing them. Do maintain the same `FROM cards` source and `WHERE artist = 'Rob Alexander'` filter without changes. The amended query now returns individual mana cost values rather than an aggregated sum, matching the right SQL's behavior."
        ],
        "rules": [
            "unconverted mana refer to manaCost; Rob Alexander refer to artist"
        ]
    },
    "1506": {
        "sql": [
            "SELECT p.Description\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE g.Country = 'CZE';"
        ],
        "question": "Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.Description FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Country = 'CZE'",
        "amends": [],
        "rules": [
            "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; "
        ]
    },
    "1281": {
        "sql": [
            "SELECT MAX(p.Birthday) AS YoungestBirthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GOT >= 60;"
        ],
        "question": "Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60 ORDER BY T1.Birthday DESC LIMIT 1",
        "amends": [],
        "rules": [
            "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; The larger the birthday value, the younger the person is, and vice versa;"
        ]
    },
    "315": {
        "sql": [
            "SELECT DISTINCT m.molecule_id, m.label\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE LOWER(a.element) = 'cl' AND m.label = '+';",
            "SELECT T1.molecule_id\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'cl' AND T2.label = '+'"
        ],
        "question": "Among the molecules which contain \"cl\" element, which of them are carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'cl' AND T2.label = '+'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `a` and `m`. Do select only `T1.molecule_id` instead of both `m.molecule_id` and `m.label`. Do use `INNER JOIN` instead of `JOIN` (though they are equivalent). Do reference `T1.element` directly instead of applying `LOWER()` function to `a.element`. Do remove the `DISTINCT` keyword instead of keeping it. Do reference `T2.label` instead of `m.label`. The amended query now correctly filters for chlorine atoms without case conversion and returns only molecule IDs from matching molecules with the '+' label."
        ],
        "rules": [
            "label = '+' mean molecules are carcinogenic;"
        ]
    },
    "690": {
        "sql": [
            "SELECT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.DisplayName = 'Emmett'\nORDER BY b.Date DESC\nLIMIT 1;"
        ],
        "question": "Identify the latest badge awarded to the user with the display name Emmett.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Emmett' ORDER BY T1.Date DESC LIMIT 1",
        "amends": [],
        "rules": [
            "the latest badge refers to Name FROM badges where MAX(Date);"
        ]
    },
    "1294": {
        "sql": [
            "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE l.CRE < 1.5\nAND e.`aCL IgA` = (SELECT MAX(`aCL IgA`) FROM Examination WHERE `aCL IgA` IS NOT NULL);",
            "SELECT T2.ID\nFROM Laboratory AS T1\nJOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.CRE < 1.5\nORDER BY T2.\"aCL IgA\" DESC\nLIMIT 1"
        ],
        "question": "Please list the patient's ID whose creatinine level is normal and whose anti Cardiolipin antibody concentration level is the highest.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.CRE < 1.5 ORDER BY T2.`aCL IgA` DESC LIMIT 1",
        "amends": [
            "Do select `T2.ID` instead of `p.ID` and remove the subquery. Do join `Laboratory AS T1` with `Examination AS T2` using `T1.ID = T2.ID` instead of joining Patient with both Laboratory and Examination separately. Do keep the `T1.CRE < 1.5` filter but remove the complex subquery condition. Do add `ORDER BY T2.aCL IgA DESC LIMIT 1` instead of using a subquery to find the maximum value, which more efficiently retrieves the single record with the highest aCL IgA value. The amended query now correctly identifies the Examination record with the maximum aCL IgA value for patients with CRE < 1.5, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "creatinine level is normal refers to CRE < 1.5; anti Cardiolipin antibody concentration level is the highest refers to MAX(aCL IgA);"
        ]
    },
    "1173": {
        "sql": [
            "SELECT Diagnosis, COUNT(Diagnosis) AS DiagnosisCount\nFROM Examination\nWHERE `Examination Date` BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY Diagnosis\nORDER BY DiagnosisCount DESC\nLIMIT 1;",
            "SELECT T2.Diagnosis, COUNT(T2.Diagnosis) AS DiagnosisCount\nFROM Examination AS T1\nINNER JOIN Patient AS T2 ON T1.ID = T2.ID\nINNER JOIN Laboratory AS T3 ON T1.ID = T3.ID\nWHERE T3.Date BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.Diagnosis\nORDER BY COUNT(T2.Diagnosis) DESC\nLIMIT 1;",
            "SELECT T2.Diagnosis\nFROM Examination AS T1\nINNER JOIN Patient AS T2 ON T1.ID = T2.ID\nWHERE T1.\"Examination Date\" BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.Diagnosis\nORDER BY COUNT(T2.Diagnosis) DESC\nLIMIT 1;"
        ],
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "amends": [
            "Do join `Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID` instead of querying only `Examination` table. Do reference `T2.Diagnosis` instead of `Diagnosis` directly from Examination. Do group by `T2.Diagnosis` instead of grouping by Diagnosis without table qualification. Do order by `COUNT(T2.Diagnosis)` instead of ordering by the alias `DiagnosisCount`. The amended query now correctly joins the Patient table to access the Diagnosis field and properly qualifies all column references, matching the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(T2.Diagnosis) AS DiagnosisCount` column from the SELECT list instead of including it. Do remove the `INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID` join and its associated table instead of keeping it. Do change the WHERE filter to use `T1.Examination Date BETWEEN '1985-01-01' AND '1995-12-31'` instead of `T3.Date BETWEEN '1985-01-01' AND '1995-12-31'`. The amended query now correctly filters by examination dates from the Examination table rather than incorrectly joining and filtering by laboratory dates, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "the most common illness refers to MAX(COUNT(Diagnosis)); lab work between 1/1/1985 and 12/31/1995 refers to `Examination Date` between '1985-01-01' and '1995-12-31 '"
        ]
    },
    "832": {
        "sql": [
            "SELECT superhero_name\nFROM superhero\nWHERE height_cm = (SELECT MAX(height_cm) FROM superhero)\nLIMIT 1;"
        ],
        "question": "Name the tallest superhero.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "amends": [],
        "rules": [
            "tallest superhero refers to MAX(height_cm);"
        ]
    },
    "142": {
        "sql": [
            "SELECT DISTINCT o.account_id\nFROM `order` o\nJOIN account a ON o.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE o.k_symbol = 'SIPO' AND d.A2 = 'Pisek';",
            "SELECT DISTINCT account.account_id\nFROM trans\nJOIN account ON trans.account_id = account.account_id\nJOIN district ON account.district_id = district.district_id\nWHERE trans.k_symbol = 'SIPO'\nAND district.A2 = 'Pisek'"
        ],
        "question": "Which accounts placed orders for household payment in Pisek?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.k_symbol = 'SIPO' AND T3.A2 = 'Pisek'",
        "amends": [
            "Do use `trans` table as the primary source instead of `order` table for filtering by `k_symbol`. Do join `account` on `trans.account_id = account.account_id` instead of joining `order` with `account` on the same column. Do maintain the same join with `district` on `account.district_id = district.district_id` instead of the original join condition. Do keep the same WHERE filter conditions for `k_symbol = 'SIPO'` and `A2 = 'Pisek'` but apply them to the correct tables. Do preserve the `DISTINCT` selection of `account_id` from the correct table. The amended query now correctly filters transactions by k_symbol instead of orders and returns the expected account results matching the right SQL's behavior."
        ],
        "rules": [
            "k_symbol = 'SIPO' refers to household payment"
        ]
    },
    "699": {
        "sql": [
            "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat';"
        ],
        "question": "When did the user known as 'IrishStat' create his or her account?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat'",
        "amends": [],
        "rules": [
            "DisplayName = 'IrishStat'; when create his or her account refers to CreationDate;"
        ]
    },
    "202": {
        "sql": [
            "SELECT COUNT(*) FROM bond WHERE bond_type = '#';"
        ],
        "question": "How many triple type bonds are there?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '#'",
        "amends": [],
        "rules": [
            "triple type bonds refers to bond_type = '#'"
        ]
    },
    "1394": {
        "sql": [
            "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Physics Teaching';"
        ],
        "question": "How many members of the Student_Club have major in 'Physics Teaching'?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Physics Teaching'",
        "amends": [],
        "rules": [
            "'Physics Teaching' is the major_name;"
        ]
    },
    "1206": {
        "sql": [
            "SELECT Date FROM Laboratory WHERE ID = 48473 AND GOT >= 60;"
        ],
        "question": "When is the laboratory examination of patient '48473' where his/her AST glutamic oxaloacetic transaminase (GOT) index is above the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT Date FROM Laboratory WHERE ID = 48473 AND GOT >= 60",
        "amends": [],
        "rules": [
            "AST glutamic oxaloacetic transaminase (GOT) index is above the normal range refers to GOT > = 60; when refers to DATE"
        ]
    },
    "529": {
        "sql": [
            "SELECT DISTINCT s.name\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.code NOT IN (\n    SELECT setCode\n    FROM set_translations\n    WHERE language LIKE '%Japanese%'\n)\nAND s.code IN (\n    SELECT setCode\n    FROM set_translations\n    WHERE language = 'Korean'\n);",
            "SELECT name FROM sets WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%')"
        ],
        "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
        "amends": [
            "Do remove the `DISTINCT` modifier instead of keeping it, and do remove the explicit `JOIN` with `set_translations` instead of including it. Do change the `WHERE` clause to use a single subquery with `language = 'Korean' AND language NOT LIKE '%Japanese%'` instead of separate `NOT IN` and `IN` subqueries. Do remove the table alias `s` from the `SELECT` list instead of keeping it, and do simplify the query structure by eliminating the redundant join condition. The amended query now correctly filters for sets with Korean translations that don't contain Japanese text, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "names of sets refers to name; doesn't have Japanese translation refers to language not like '%Japanese%'; have Korean translation refers to language = 'Korean'"
        ]
    },
    "67": {
        "sql": [
            "SELECT COUNT(*) AS TotalClosures\nFROM schools\nWHERE strftime('%Y', ClosedDate) = '1989'\nAND City = 'San Francisco'\nAND District LIKE '%Community College%';",
            "SELECT COUNT(School) FROM schools WHERE DOCType = 'Community College District' AND ClosedDate LIKE '1989%' AND City = 'San Francisco'"
        ],
        "question": "What is the total amount of Community College District closure in 1989 in the city of San Francisco?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', ClosedDate) = '1989' AND City = 'San Francisco' AND DOCType = 'Community College District'",
        "amends": [
            "Do count `School` column instead of `COUNT(*)` to exclude null values. Do change the filter condition to `DOCType = 'Community College District'` instead of `District LIKE '%Community College%'` for exact matching. The amended query now correctly counts non-null School entries with precise district type filtering."
        ],
        "rules": []
    },
    "1409": {
        "sql": [
            "SELECT SUM(cost) AS total_expense FROM expense WHERE expense_date = '2019-08-20';"
        ],
        "question": "Mention the total expense used on 8/20/2019.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20'",
        "amends": [],
        "rules": [
            "total expense refers SUM(cost) where expense_date = '2019-08-20'"
        ]
    },
    "1230": {
        "sql": [
            "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Admission = '-' AND l.CPK < 250;"
        ],
        "question": "List all outpatient within normal range of creatinine phosphokinase. Give me the distinct ids.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CPK < 250 AND T1.Admission = '-'",
        "amends": [],
        "rules": [
            "outpatient refers to Admission = '-'; normal range of creatinine phosphokinase refers to CPK < 250;"
        ]
    },
    "658": {
        "sql": [
            "SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5;"
        ],
        "question": "What are the titles of the top 5 posts with the highest popularity?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5",
        "amends": [],
        "rules": [
            "Higher view count means the post has higher popularity; the highest popularity refers to MAX(ViewCount);"
        ]
    },
    "618": {
        "sql": [
            "SELECT u.Age\nFROM users u\nINNER JOIN badges b ON u.Id = b.UserId\nWHERE u.Location = 'Vienna, Austria';"
        ],
        "question": "List out the age of users who located in Vienna, Austria obtained the badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Age FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'Vienna, Austria'",
        "amends": [],
        "rules": [
            "\"Vienna, Austria\" is the Location"
        ]
    },
    "934": {
        "sql": [
            "SELECT d.forename, d.surname\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 1989 AND rc.name = 'Australian Grand Prix' AND r.grid = 4;"
        ],
        "question": "Which driver was in the no. 4 grid formation when starting the race in 1989's Australian Grand Prix? Please give his forename and surname.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T2.grid = 4 AND T1.name = 'Australian Grand Prix' AND T1.year = 1989",
        "amends": [],
        "rules": [
            "the no. 4 grid formation refers to grid = 4"
        ]
    },
    "1509": {
        "sql": [
            "SELECT COUNT(*) AS NumberOfTransactions\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE' AND t.Date > '2012-01-01';"
        ],
        "question": "Among the transactions made in the gas stations in the Czech Republic, how many of them are taken place after 2012/1/1?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND STRFTIME('%Y', T1.Date) >= '2012'",
        "amends": [],
        "rules": [
            "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'"
        ]
    },
    "1144": {
        "sql": [
            "SELECT p.player_name, pa.finishing AS finishing_rate, pa.curve AS curve_score\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.weight = (SELECT MAX(weight) FROM Player);",
            "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1) LIMIT 1;"
        ],
        "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
        "amends": [
            "Do select `id`, `finishing`, and `curve` columns from the `Player_Attributes` table instead of selecting `player_name`, `finishing_rate`, and `curve_score` with aliases from a joined query. Do use a subquery to find the `player_api_id` of the heaviest player with `ORDER BY weight DESC LIMIT 1` instead of joining tables and using `WHERE p.weight = (SELECT MAX(weight) FROM Player)`. Do remove the explicit table join between `Player` and `Player_Attributes` and instead filter directly in the `WHERE` clause with `player_api_id = (subquery)`. Do add `LIMIT 1` to ensure only one row is returned instead of potentially multiple rows from the join approach. The amended query now correctly identifies and returns attributes for the single heaviest player, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "finishing rate refer to finishing; curve score refer to curve; heaviest weight refers to MAX(weight)"
        ]
    },
    "709": {
        "sql": [
            "SELECT COUNT(DISTINCT p.Id) AS PostCount\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE c.Score = 0 AND p.ViewCount < 5;",
            "SELECT COUNT(T1.Id) \nFROM comments AS T1 \nJOIN posts AS T2 ON T1.PostId = T2.Id \nWHERE T2.Score = 0 AND T2.ViewCount < 5"
        ],
        "question": "In comments with 0 score, how many of the posts have view count lower than 5?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ViewCount < 5 AND T2.Score = 0",
        "amends": [
            "Do use `COUNT(T1.Id)` instead of `COUNT(DISTINCT p.Id) AS PostCount` to count comment IDs without distinct aggregation. Do join `comments AS T1` with `posts AS T2` instead of joining `posts` with `comments` to properly establish the relationship from comments to posts. Do use join condition `T1.PostId = T2.Id` instead of `p.Id = c.PostId` to correctly reference the foreign key relationship. Do move the `Score = 0` filter from comments to posts by using `T2.Score = 0` instead of `c.Score = 0` to filter based on post score rather than comment score. Do keep the `ViewCount < 5` filter on posts but reference it as `T2.ViewCount < 5` instead of `p.ViewCount < 5` to match the new table alias. Do remove the unnecessary DISTINCT modifier and column alias instead of keeping them. The amended query now correctly counts comments from posts with low view count and zero score, matching the intended behavior."
        ],
        "rules": [
            "view count lower than 5 refers to ViewCount < 5;"
        ]
    },
    "1202": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'M'\nAND E.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31'\nAND E.Diagnosis = 'Behcet'\nAND P.Admission = '-';"
        ],
        "question": "How many male patients who underwent testing between 1995 and 1997 and were subsequently diagnosed with Behcet disease did not stay in the hospital for treatment?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'Behcet' AND T1.SEX = 'M' AND STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1995' AND '1997' AND T1.Admission = '-'",
        "amends": [],
        "rules": [
            "male refers to SEX = 'M'; underwent testing between 1995 and 1997 refers to `Examination Date` between '1995' and '1997'; Behcet refers to diagnosis; did not stay in the hospital refers to Admission = '-'"
        ]
    },
    "582": {
        "sql": [
            "SELECT DISTINCT p.Title\nFROM posts p\nJOIN postHistory ph ON p.Id = ph.PostId\nJOIN users u ON ph.UserId = u.Id\nWHERE u.DisplayName = 'Vebjorn Ljosa' AND ph.PostHistoryTypeId IS NOT NULL;"
        ],
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "amends": [],
        "rules": [
            "\"Vebjorn Ljosa\" is the DisplayName; last edited refers to LastEditorUserId"
        ]
    },
    "1007": {
        "sql": [
            "SELECT MAX(p.duration) AS longest_pit_stop_time\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';"
        ],
        "question": "What was the longest time that Lewis Hamilton had spent at a pit stop?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.duration DESC LIMIT 1",
        "amends": [],
        "rules": [
            "longest time refes to MAX(duration);"
        ]
    },
    "1354": {
        "sql": [
            "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'Vice President';"
        ],
        "question": "State the major name for the Vice President of the club.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Vice President'",
        "amends": [],
        "rules": [
            "'Vice President' is a position of Student Club"
        ]
    },
    "525": {
        "sql": [
            "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'banned' OR status = 'restricted');",
            "SELECT uuid FROM legalities WHERE format = 'Old School' AND status IN ('Banned', 'Restricted')",
            "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')"
        ],
        "question": "Find the uuid of cards in which the old school format is restricted or banned.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')",
        "amends": [
            "Do use uppercase status values `'Banned'` and `'Restricted'` in the WHERE clause filter instead of lowercase `'banned'` and `'restricted'` to match the correct case sensitivity in the data. The amended query now correctly filters for the intended status values with proper capitalization, ensuring it matches the RIGHT_SQL's behavior.",
            "Do use lowercase `'oldschool'` for the format comparison instead of `'Old School'` to match the actual data format. Do use explicit `OR` conditions with parentheses `(status = 'Banned' OR status = 'Restricted')` instead of `IN ('Banned', 'Restricted')` to ensure proper boolean logic evaluation. The amended query now correctly filters for the 'oldschool' format and properly handles the banned/restricted status conditions to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "old school format refers to format = 'oldschool'; restricted or banned refers to status = 'banned' or 'restricted'"
        ]
    },
    "680": {
        "sql": [
            "SELECT AVG(Score) AS AverageScore\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Stephen Turner');"
        ],
        "question": "What is the average score of Stephen Turner's posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.Score) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Stephen Turner'",
        "amends": [],
        "rules": [
            "DisplayName = 'Stephen Turner'; average score refers to AVG(Score);"
        ]
    },
    "861": {
        "sql": [
            "SELECT d.number\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nWHERE q.raceId = 903 AND q.q3 = '0:01:54';",
            "SELECT T2.number \nFROM qualifying AS T1 \nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 903 \nAND T1.q3 LIKE '1:54%';"
        ],
        "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'",
        "amends": [
            "Do reference the `number` column from the `drivers` table as `T2.number` instead of `d.number`. Do use `INNER JOIN` with explicit table aliases `qualifying AS T1` and `drivers AS T2` instead of simple `JOIN` with aliases `d` and `q`. Do specify the join condition as `T2.driverId = T1.driverId` instead of `d.driverId = q.driverId`. Do use the `LIKE` operator with pattern `'1:54%'` for the `q3` filter instead of exact string comparison `= '0:01:54'`. The amended query now correctly matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "race number refers to raceId; finished 0:0M:SS in the Q3 refers to q3 LIKE 'M:SS%'"
        ]
    },
    "29": {
        "sql": [
            "SELECT s.OpenDate\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nORDER BY f.[Enrollment (K-12)] DESC\nLIMIT 1;"
        ],
        "question": "When did the first-through-twelfth-grade school with the largest enrollment open?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.OpenDate FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "amends": [],
        "rules": [
            "K-12 means First-through-twelfth-grade"
        ]
    },
    "1448": {
        "sql": [
            "SELECT e.event_name, e.event_date\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.expense_description LIKE '%pizza%'\nAND ex.cost > 50\nAND ex.cost < 100;"
        ],
        "question": "Find the name and date of events with expenses for pizza that were more than fifty dollars but less than a hundred dollars.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name, T1.event_date FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.expense_description = 'Pizza' AND T3.cost > 50 AND T3.cost < 100",
        "amends": [],
        "rules": [
            "name of event refers to event_name; date of event refers to event_date; expenses for pizza refers to expense_description = 'Pizza' where cost > 50 and cost < 100"
        ]
    },
    "925": {
        "sql": [
            "SELECT c.url \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE r.name = 'Spanish Grand Prix' AND r.year = 2009;"
        ],
        "question": "Please give the link of the website that shows more information about the circuits the Spanish Grand Prix used in 2009.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "amends": [],
        "rules": [
            "link of the website refers to url"
        ]
    },
    "722": {
        "sql": [
            "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE s.superhero_name = 'Apocalypse';"
        ],
        "question": "What is the colour of Apocalypse's skin?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id WHERE T1.superhero_name = 'Apocalypse'",
        "amends": [],
        "rules": [
            "Apocalypse refers to superhero_name = 'Apocalypse'; colour of skin refers to colour where skin_colour_id = colour.id"
        ]
    },
    "358": {
        "sql": [
            "SELECT borderColor FROM cards WHERE name = 'Ancestor''s Chosen';"
        ],
        "question": "What is the border color of card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT borderColor FROM cards WHERE name = 'Ancestor''s Chosen'",
        "amends": [],
        "rules": [
            "name of card  = 'Ancestor''s Chosen' ;"
        ]
    },
    "1171": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) AS UnderagePatientsExamined\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE E.`Examination Date` BETWEEN '1990-01-01' AND '1993-12-31'\nAND (strftime('%Y', E.`Examination Date`) - strftime('%Y', P.Birthday) - \n    (strftime('%m-%d', E.`Examination Date`) < strftime('%m-%d', P.Birthday))) < 18;"
        ],
        "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.Birthday) < 18",
        "amends": [],
        "rules": [
            "underage patients refers to year(Birthday) < 18; three-year period from 1990 to 1993 refers to year(`Examination Date`) between '1990' and '1993'"
        ]
    },
    "962": {
        "sql": [
            "WITH drivers_2000_2005 AS (\n    SELECT DISTINCT d.driverId, d.dob\n    FROM drivers d\n    JOIN results r ON d.driverId = r.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE rc.year BETWEEN 2000 AND 2005\n),\ndrivers_before_1985_over_50_laps AS (\n    SELECT DISTINCT d.driverId\n    FROM drivers d\n    JOIN results r ON d.driverId = r.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE strftime('%Y', d.dob) < '1985'\n    AND r.laps > 50\n    AND rc.year BETWEEN 2000 AND 2005\n)\nSELECT \n    (COUNT(d.driverId) * 100.0 / (SELECT COUNT(*) FROM drivers_2000_2005)) AS percentage\nFROM drivers_before_1985_over_50_laps d;",
            "SELECT \n    CAST(SUM(IIF(strftime('%Y', d.dob) < '1985' AND r.laps > 50, 1, 0)) AS REAL) * 100.0 / COUNT(*) AS percentage\nFROM \n    results r\nINNER JOIN \n    races rc ON r.raceId = rc.raceId\nINNER JOIN \n    drivers d ON r.driverId = d.driverId\nWHERE \n    rc.year BETWEEN 2000 AND 2005;"
        ],
        "error": "something went wrong, tool did not call.",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "amends": [
            "Do use a single query with conditional aggregation instead of multiple CTEs and subqueries. Do calculate the percentage directly with `SUM(IIF(condition, 1, 0)) * 100 / COUNT(*)` instead of using separate CTEs and subquery division. Do add explicit `CAST` to `REAL` instead of implicit type conversion. Do use `INNER JOIN` on `T1.raceId = T2.raceId` and `T1.driverId = T3.driverId` instead of the previous join structure. Do move the `strftime('%Y', dob) < '1985'` and `laps > 50` conditions into the `IIF` function instead of filtering in a separate CTE. Do keep the `year BETWEEN 2000 AND 2005` filter in the `WHERE` clause instead of duplicating it across CTEs. Do remove the `DISTINCT` operations and multiple CTEs instead of maintaining complex subquery structure. The amended query now correctly calculates the percentage of drivers born before 1985 who completed over 50 laps in races between 2000-2005 using efficient conditional aggregation."
        ],
        "rules": [
            "born before 1985 refers to year(dob)<1985; in 2000 to 2005 refers to year between 2000 and 2005; percentage = Divide(COUNT(driverId where year (dob) <1985 and laps >50),COUNT(DriverID where year between 2000 and 2005) *100;"
        ]
    },
    "773": {
        "sql": [
            "SELECT s.superhero_name, p.publisher_name\nFROM superhero s\nJOIN colour eye ON s.eye_colour_id = eye.id\nJOIN colour hair ON s.hair_colour_id = hair.id\nJOIN colour skin ON s.skin_colour_id = skin.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE eye.id = hair.id AND hair.id = skin.id\nGROUP BY s.superhero_name, p.publisher_name;"
        ],
        "question": "Which superhero has the same eyes, hair and skin colour? Indicate the publisher of the superhero.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name, T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id",
        "amends": [],
        "rules": [
            "which superhero refers to superhero_name; the same eyes, hair and skin colour refers to hair_colour_id = skin_colour_id AND hair_colour_id = eye_colour_id; publisher refers to publisher_name;"
        ]
    },
    "491": {
        "sql": [
            "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';"
        ],
        "question": "What's the magic card market name for the set which was released on 2017/6/9?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "amends": [],
        "rules": [
            "magic card market name refers to mcmName"
        ]
    },
    "1332": {
        "sql": [
            "SELECT SUM(b.spent) AS total_spent_on_food\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'September Meeting' AND b.category = 'Food';"
        ],
        "question": "How much did the Student_Club members spend on food in September Meeting?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Food' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "amends": [],
        "rules": [
            "amount spent refers to spent; spend on food in September Meeting refers to category = 'Food' where event_name = 'September Meeting'"
        ]
    },
    "311": {
        "sql": [
            "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m\nWHERE m.molecule_id NOT IN (\n    SELECT DISTINCT a.molecule_id \n    FROM atom a \n    WHERE a.element = 's'\n)\nAND m.molecule_id NOT IN (\n    SELECT DISTINCT b.molecule_id \n    FROM bond b \n    WHERE b.bond_type = ' = '\n);",
            "SELECT COUNT(DISTINCT m.molecule_id)\nFROM molecule m\nWHERE m.molecule_id NOT IN (\n    SELECT DISTINCT a.molecule_id\n    FROM atom a\n    WHERE a.element = 's'\n)\nAND m.molecule_id NOT IN (\n    SELECT DISTINCT b.molecule_id\n    FROM bond b\n    WHERE b.bond_type = '='\n)",
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM atom T1\nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element <> 's' AND T2.bond_type <> '='"
        ],
        "question": "How many molecules without sulphur element is not having double bond?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element <> 's' AND T2.bond_type <> '='",
        "amends": [
            "Do use `INNER JOIN` between `atom` and `bond` tables on `molecule_id` instead of separate `NOT IN` subqueries. Do filter with `T1.element <> 's'` instead of `NOT IN` subquery for sulfur atoms. Do filter with `T2.bond_type <> '='` instead of `NOT IN` subquery for double bonds. Do remove the `DISTINCT` from the subqueries since the join approach handles uniqueness inherently. Do change the table structure to join atom and bond tables directly instead of querying molecule table with exclusion conditions. The amended query now correctly counts molecules that contain neither sulfur atoms nor double bonds by using a positive join condition instead of negative exclusion logic, matching the RIGHT_SQL's behavior.",
            "Do use `INNER JOIN` between `atom` and `bond` tables on `molecule_id` instead of separate `NOT IN` subqueries. Do filter with `T1.element <> 's'` instead of excluding molecules with sulfur atoms. Do filter with `T2.bond_type <> '='` instead of excluding molecules with double bonds. Do remove the `DISTINCT` from the subquery predicates since the join approach inherently handles uniqueness. Do change the table source to joined `atom` and `bond` tables instead of querying the `molecule` table directly. The amended query now correctly counts molecules that contain no sulfur atoms and no double bonds by using an inner join approach instead of the less efficient subquery method."
        ],
        "rules": [
            "double bond refers to bond_type = ' = '; bond_type ! = ' = '; sulphur refers to element = 's'"
        ]
    },
    "1071": {
        "sql": [
            "SELECT t.team_short_name \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE ta.buildUpPlaySpeed = 31 \nAND ta.buildUpPlayDribbling = 53 \nAND ta.buildUpPlayPassing = 32;"
        ],
        "question": "List the football team that has a build up play speed of 31, build up plan dribbling of 53, and build up play passing of 32. Only indicate the short name of the team.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeed = 31 AND t2.buildUpPlayDribbling = 53 AND t2.buildUpPlayPassing = 32",
        "amends": [],
        "rules": [
            "build up play speed refers to buildUpPlaySpeed; buildUpPlaySpeed = 31; build up play dribbling refers to buildUpPlayDribbling; buildUpPlayDribbling = 53; build up play passing refers to buildUpPlayPassing; buildUpPlayPassing = 32; short name of the team refers to team_short_name;"
        ]
    },
    "888": {
        "sql": [
            "SELECT c.country, c.name AS circuit_name, c.location\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'European Grand Prix'\nORDER BY r.year ASC\nLIMIT 1;",
            "SELECT T1.country, T1.location\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T2.name = 'European Grand Prix'\nORDER BY T2.date\nLIMIT 1;"
        ],
        "question": "In which country was the first European Grand Prix hosted? Name the circuit and location.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.country, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix' ORDER BY T2.year ASC LIMIT 1",
        "amends": [
            "Do remove `c.name AS circuit_name` from the SELECT list instead of including it. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference tables with aliases `T1` and `T2` instead of single letters `c` and `r`. Do fix the join condition to `T2.circuitID = T1.circuitId` instead of `r.circuitId = c.circuitId` to ensure proper column matching. The amended query now correctly retrieves only the country and location data for the European Grand Prix race while maintaining the same ordering and limiting behavior."
        ],
        "rules": [
            "the first refers to min(year);"
        ]
    },
    "161": {
        "sql": [
            "SELECT c.type \nFROM card c \nJOIN disp d ON c.disp_id = d.disp_id \nWHERE d.client_id = 13539;"
        ],
        "question": "What type of credit card does the client with the id 13539 own?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.type FROM disp AS T1 INNER JOIN client AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T1.disp_id = T3.disp_id WHERE T2.client_id = 13539",
        "amends": [],
        "rules": []
    },
    "1501": {
        "sql": [
            "SELECT DISTINCT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE strftime('%Y%m', t.Date) = '201306';",
            "SELECT T2.Country\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Date = '201306'"
        ],
        "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Date = '201306'",
        "amends": [
            "Do add `T2.Country` instead of `g.Country` for the SELECT list. Do add `yearmonth AS T3` as an additional INNER JOIN source instead of omitting it. Do change the join condition to `T1.CustomerID = T3.CustomerID` instead of not having this join. Do change the WHERE filter to use `T3.Date = '201306'` instead of `strftime('%Y%m', t.Date) = '201306'`. Do remove the DISTINCT modifier instead of keeping it. The amended query now correctly filters by joining with the yearmonth table and using its Date column directly instead of applying string formatting functions to the transaction date."
        ],
        "rules": [
            "June 2013 refers to '201306'; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month;"
        ]
    },
    "1499": {
        "sql": [
            "SELECT MAX(ym.Consumption) AS BiggestMonthlyConsumption\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Currency = 'euro';",
            "SELECT SUM(T2.Consumption) / 12 AS MonthlyConsumption\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY T1.CustomerID\nORDER BY MonthlyConsumption DESC\nLIMIT 1"
        ],
        "question": "What is the biggest monthly consumption of the customers who use euro as their currency?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.Consumption) / 12 AS MonthlyConsumption FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY MonthlyConsumption DESC LIMIT 1",
        "amends": [
            "Do calculate `SUM(T2.Consumption) / 12` as `MonthlyConsumption` instead of `MAX(ym.Consumption)` as `BiggestMonthlyConsumption`. Do use `INNER JOIN` with aliases `T1` and `T2` instead of `JOIN` with aliases `c` and `ym`. Do filter on `T1.Currency = 'EUR'` instead of `c.Currency = 'euro'`. Do add `GROUP BY T1.CustomerID` instead of omitting grouping. Do add `ORDER BY MonthlyConsumption DESC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly calculates average monthly consumption per customer rather than finding the single maximum consumption value."
        ],
        "rules": [
            "Monthly consumption = SUM(consumption) / 12"
        ]
    },
    "1468": {
        "sql": [
            "SELECT z.city AS hometown\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Garrett' AND m.last_name = 'Gerke';"
        ],
        "question": "Where is the hometown of Garrett Gerke?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.city FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'",
        "amends": [],
        "rules": [
            "hometown refers to city"
        ]
    },
    "1062": {
        "sql": [
            "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating > 80\nAND pa.date BETWEEN '2008-01-01' AND '2010-12-31';\n"
        ],
        "question": "Which players had an overall rating of over 80 from 2008 to 2010? Please list player names.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating > 80 AND SUBSTR(t2.`date`, 1, 4) BETWEEN '2008' AND '2010'",
        "amends": [],
        "rules": [
            "overall_rating > 80; from 2008 to 2010 refers to strftime('%Y', date) BETWEEN '2008' AND '2010';"
        ]
    },
    "791": {
        "sql": [
            "SELECT superhero_name, AVG(height_cm) AS average_height FROM superhero GROUP BY superhero_name;",
            "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero;"
        ],
        "question": "Calculate the average height for each superhero.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero",
        "amends": [
            "Do use `CAST(SUM(height_cm) AS REAL) / COUNT(id)` instead of `AVG(height_cm) AS average_height` to calculate the average with proper type casting and count by `id` instead of relying on the built-in AVG function. Do remove `superhero_name` from the SELECT list and `GROUP BY superhero_name` instead of grouping by name when calculating an overall average across all superheroes. Do omit the column alias `average_height` instead of including it since the query now returns a single aggregate value. The amended query now correctly calculates the overall average height across all superheroes by summing heights and dividing by count with proper real number casting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "average = DIVIDE(SUM(height_cm), COUNT(all heros));"
        ]
    },
    "777": {
        "sql": [
            "SELECT g.gender\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE s.superhero_name = 'Agent 13';"
        ],
        "question": "What is the gender of Agent 13 hero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'",
        "amends": [],
        "rules": [
            "Agent 13 hero refers to superhero_name = 'Agent 13';"
        ]
    },
    "1096": {
        "sql": [
            "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Pietro Marino');"
        ],
        "question": "Calculate the average overall rating of Pietro Marino.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Pietro Marino'",
        "amends": [],
        "rules": [
            "Pietro Marino refers to player_name = 'Pietro Marino'; average overall rating AVG(T1.overall_rating)"
        ]
    },
    "198": {
        "sql": [
            "SELECT AVG(single_bond_count) AS average_single_bonded\nFROM (\n    SELECT m.molecule_id, COUNT(b.bond_id) AS single_bond_count\n    FROM molecule m\n    JOIN bond b ON m.molecule_id = b.molecule_id\n    WHERE m.label = '+' AND b.bond_type = '-'\n    GROUP BY m.molecule_id\n);",
            "SELECT AVG(bond_count) AS avg_carcinogenic_single_bonded_molecules\nFROM (\n    SELECT T3.molecule_id, COUNT(T1.bond_type) AS bond_count\n    FROM bond AS T1\n    INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id\n    WHERE T1.bond_type = '-' AND T3.label = '+'\n    GROUP BY T3.molecule_id\n)"
        ],
        "question": "On average how many carcinogenic molecules are single bonded?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
        "amends": [
            "Do join `bond` with `atom` on `molecule_id` instead of joining `molecule` directly with `bond`. Do add `INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id` instead of omitting the atom table entirely. Do change the join path to `INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id` instead of `JOIN bond b ON m.molecule_id = b.molecule_id`. Do keep the same `WHERE` filters `T1.bond_type = '-' AND T3.label = '+'` instead of changing the filter logic. Do maintain the same `GROUP BY T3.molecule_id` and `COUNT(T1.bond_type)` aggregation instead of altering the grouping or counting. The amended query now correctly incorporates the atom table in the join path to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "carcinogenic molecules refers to label = '+'; single-bonded refers to bond_type = '-'; average = DIVIDE(SUM(bond_type = '-'), COUNT(atom_id))"
        ]
    },
    "263": {
        "sql": [
            "SELECT \n    (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS chlorine_percentage\nFROM \n    atom a\nJOIN \n    molecule m ON a.molecule_id = m.molecule_id\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nWHERE \n    b.bond_type = '-';"
        ],
        "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "amends": [],
        "rules": [
            "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'"
        ]
    },
    "36": {
        "sql": [
            "WITH top_school AS (\n    SELECT cds\n    FROM satscores\n    ORDER BY NumGE1500 DESC\n    LIMIT 1\n)\nSELECT \n    CASE \n        WHEN AdmFName1 IS NOT NULL AND AdmLName1 IS NOT NULL THEN AdmFName1 || ' ' || AdmLName1\n        ELSE NULL\n    END AS admin1,\n    CASE \n        WHEN AdmFName2 IS NOT NULL AND AdmLName2 IS NOT NULL THEN AdmFName2 || ' ' || AdmLName2\n        ELSE NULL\n    END AS admin2,\n    CASE \n        WHEN AdmFName3 IS NOT NULL AND AdmLName3 IS NOT NULL THEN AdmFName3 || ' ' || AdmLName3\n        ELSE NULL\n    END AS admin3\nFROM schools\nWHERE CDSCode = (SELECT cds FROM top_school);",
            "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1;"
        ],
        "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "amends": [
            "Do select individual columns `AdmFName1`, `AdmLName1`, `AdmFName2`, `AdmLName2`, `AdmFName3`, and `AdmLName3` instead of concatenating them with CASE statements into `admin1`, `admin2`, and `admin3` aliases. Do use an `INNER JOIN` between `satscores AS T1` and `schools AS T2` on `T1.cds = T2.CDSCode` instead of a CTE subquery with `WHERE CDSCode = (SELECT cds FROM top_school)`. Do add `ORDER BY T1.NumGE1500 DESC LIMIT 1` at the query level instead of using a separate CTE to find the top school. Do remove the CASE expressions and CTE structure entirely instead of keeping them. The amended query now correctly joins the tables and retrieves the administrator names for the school with the highest NumGE1500 value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500"
        ]
    },
    "566": {
        "sql": [
            "SELECT u.Reputation\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Id = 65041;"
        ],
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "amends": [],
        "rules": [
            "post no. 65041 refers to Id = '65041'; reputation point refers to Reputation"
        ]
    },
    "122": {
        "sql": [
            "SELECT d.A2 AS district, d.A3 AS region\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.loan_id = 4990;"
        ],
        "question": "State the district and region for loan ID '4990'.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.loan_id = 4990",
        "amends": [],
        "rules": [
            "A2, A3 contains the information about district and region respectively."
        ]
    },
    "52": {
        "sql": [
            "SELECT COUNT(DISTINCT s.CDSCode) \nFROM schools s \nJOIN satscores sat ON s.CDSCode = sat.cds \nWHERE sat.NumGE1500 > 0 AND s.MailCity = 'Lakeport';"
        ],
        "question": "What is the total number of schools whose total SAT scores are greater or equal to 1500 whose mailing city is Lakeport?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.cds) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Lakeport' AND (T1.AvgScrRead + T1.AvgScrMath + T1.AvgScrWrite) >= 1500",
        "amends": [],
        "rules": [
            "Total SAT scores can be computed by AvgScrRead + AvgScrMath + AvgScrWrite"
        ]
    },
    "1498": {
        "sql": [
            "SELECT MAX(monthly_consumption) AS highest_monthly_consumption\nFROM (\n    SELECT SUM(Consumption) AS monthly_consumption\n    FROM yearmonth\n    WHERE substr(Date, 1, 4) = '2012'\n    GROUP BY substr(Date, 5, 2)\n);"
        ],
        "question": "What is the highest monthly consumption in the year 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1",
        "amends": [],
        "rules": [
            "The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
        ]
    },
    "638": {
        "sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Organizer';"
        ],
        "question": "List all the name of users that obtained the Organizer Badges.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Organizer'",
        "amends": [],
        "rules": [
            "name of users refers to DisplayName; the Organizer Badges refer to badges where Name = 'Organizer';"
        ]
    },
    "226": {
        "sql": [
            "SELECT \n    ROUND((SUM(CASE WHEN bond_type = '=' THEN 1 ELSE 0 END) * 100.0 / COUNT(bond_id), 5) AS percentage\nFROM \n    bond\nWHERE \n    molecule_id = 'TR008';",
            "SELECT \n    (COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) * 100.0 / COUNT(T.bond_id)) \nFROM \n    bond T\nJOIN \n    molecule M ON T.molecule_id = M.molecule_id\nWHERE \n    M.label = 'TR008';",
            "SELECT ROUND(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id END) * 100.0 / COUNT(T.bond_id), 5) FROM bond AS T WHERE T.molecule_id = 'TR008';"
        ],
        "question": "What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) FROM bond AS T WHERE T.molecule_id = 'TR008'",
        "amends": [
            "Do use `COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END)` instead of `SUM(CASE WHEN bond_type = '=' THEN 1 ELSE 0 END)` to properly count non-NULL values. Do add table alias `T` to all column references instead of using unqualified column names. Do cast the count to `REAL` instead of using `100.0` to ensure floating-point division. Do remove the column alias `percentage` instead of keeping it. The amended query now correctly calculates the percentage using proper NULL handling and explicit casting for accurate division.",
            "Do remove the `JOIN` with `molecule` table and instead filter directly on `T.molecule_id = 'TR008'` instead of joining on `T.molecule_id = M.molecule_id` and filtering `M.label = 'TR008'`. Do add `ROUND` function with precision `5` instead of omitting rounding. Do cast the count to `REAL` instead of using implicit integer division. Do remove the `ELSE NULL` clause from the `CASE` statement as it's redundant. Do use table alias `AS T` instead of just `T` in the FROM clause. The amended query now correctly calculates the percentage of double bonds for molecule TR008 without unnecessary joins and with proper numeric handling."
        ],
        "rules": [
            "double bond refers to bond_type = '='; TR008 is the molecule id; percentage = DIVIDE(SUM(bond_type = '='), COUNT(bond_id)) as percent where molecule_id = 'TR008'"
        ]
    },
    "1169": {
        "sql": [
            "WITH male_abnormal AS (\n    SELECT COUNT(DISTINCT L.ID) AS male_count\n    FROM Laboratory L\n    JOIN Patient P ON L.ID = P.ID\n    WHERE P.SEX = 'M' AND L.UA <= 8.0\n),\nfemale_abnormal AS (\n    SELECT COUNT(DISTINCT L.ID) AS female_count\n    FROM Laboratory L\n    JOIN Patient P ON L.ID = P.ID\n    WHERE P.SEX = 'F' AND L.UA <= 6.5\n)\nSELECT \n    male_count AS male_patients,\n    female_count AS female_patients,\n    CASE \n        WHEN female_count = 0 THEN NULL\n        ELSE ROUND(CAST(male_count AS REAL) / female_count, 2)\n    END AS male_to_female_ratio\nFROM male_abnormal, female_abnormal;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.UA > 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN T2.UA > 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END), 0) AS male_to_female_ratio\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    (T2.UA > 8.0 AND T1.SEX = 'M') OR (T2.UA > 6.5 AND T1.SEX = 'F');",
            "SELECT \n    CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / \n    SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END)\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID"
        ],
        "question": "What is the ratio of male to female patients among all those with abnormal uric acid counts?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate CTEs for male and female counts. Do calculate counts using `SUM(CASE WHEN ... THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT L.ID)` with separate joins. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of separate joins in CTEs. Do apply the UA threshold conditions directly in the CASE statements (`T2.UA <= 8.0 AND T1.SEX = 'M'` and `T2.UA <= 6.5 AND T1.SEX = 'F'`) instead of filtering in WHERE clauses. Do compute the ratio directly as `CAST(... AS REAL) / SUM(...)` instead of using a CASE statement to handle division by zero, as the original approach would return NULL while the corrected query handles this through division semantics. Do remove the separate male and female count columns and ratio calculation logic, instead performing the division directly in the SELECT clause. The amended query now correctly calculates the male-to-female ratio of abnormal UA values with the appropriate gender-specific thresholds in a single efficient operation.",
            "Do use `<=` comparison operators instead of `>` in both conditional aggregates, changing `T2.UA > 8.0` to `T2.UA <= 8.0` for males and `T2.UA > 6.5` to `T2.UA <= 6.5` for females. Do remove the `NULLIF` function wrapper and denominator protection instead of keeping it, allowing division by zero to return NULL naturally. Do remove the entire WHERE clause filter instead of including it, as the conditional aggregates should operate on the full joined dataset without pre-filtering. Do eliminate the column alias `male_to_female_ratio` instead of specifying it, making the result anonymous. The amended query now correctly calculates the ratio of male to female patients meeting the specified UA threshold criteria without premature filtering."
        ],
        "rules": [
            "male refers to SEX = 'M'; female refers to SEX = 'F'; abnormal uric acid refers to UA < = '8.0' where SEX = 'M', UA < = '6.5' where SEX = 'F'; calculation = DIVIDE(SUM(UA <= '8.0' and SEX = 'M'), SUM(UA <= '6.5 and SEX = 'F'))"
        ]
    },
    "887": {
        "sql": [
            "SELECT r2017.name\nFROM races r2017\nWHERE r2017.year = 2017\nAND r2017.circuitId NOT IN (\n    SELECT r2000.circuitId\n    FROM races r2000\n    WHERE r2000.year = 2000\n);",
            "SELECT name FROM races WHERE year = 2017 AND name NOT IN (SELECT name FROM races WHERE year = 2000)"
        ],
        "question": "Name the races in year 2017 that are not hosted in year 2000.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE year = 2017 AND name NOT IN ( SELECT name FROM races WHERE year = 2000 )",
        "amends": [
            "Do filter by `name NOT IN` instead of `circuitId NOT IN` to correctly compare race names across years. Do remove the table aliases `r2017` and `r2000` instead of keeping them as they are unnecessary for this simple query. Do reference the same column `name` in both the outer query and subquery instead of mixing `name` and `circuitId` which ensures proper comparison of race names between 2000 and 2017. The amended query now correctly identifies races from 2017 that didn't occur in 2000 by comparing names rather than circuit IDs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "not hosted means not in;"
        ]
    },
    "1339": {
        "sql": [
            "SELECT AVG(e.cost) AS average_cost\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event ev ON a.link_to_event = ev.event_id\nWHERE m.first_name = 'Elijah' AND m.last_name = 'Allen'\nAND (SUBSTR(ev.event_date, 6, 2) = '09' OR SUBSTR(ev.event_date, 6, 2) = '10');",
            "SELECT AVG(T2.cost) AS average_cost\nFROM member T1\nINNER JOIN expense T2 ON T1.member_id = T2.link_to_member\nWHERE T1.last_name = 'Allen' \nAND T1.first_name = 'Elijah'\nAND SUBSTR(T2.expense_date, 6, 2) IN ('09', '10')"
        ],
        "question": "Calculate the total average cost that Elijah Allen spent in the events on September and October.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.last_name = 'Allen' AND T1.first_name = 'Elijah' AND (SUBSTR(T2.expense_date, 6, 2) = '09' OR SUBSTR(T2.expense_date, 6, 2) = '10')",
        "amends": [
            "Do reference `T2.cost` directly instead of using an alias like `average_cost`. Do join only `member` and `expense` tables instead of including unnecessary `attendance` and `event` tables. Do use `INNER JOIN` between `member` and `expense` with predicate `T1.member_id = T2.link_to_member` instead of the multi-table join chain. Do filter on `T1.last_name = 'Allen'` and `T1.first_name = 'Elijah'` in the WHERE clause instead of the same conditions. Do apply the month filter on `SUBSTR(T2.expense_date, 6, 2)` for September and October instead of filtering on `SUBSTR(ev.event_date, 6, 2)`. Do remove the unnecessary table aliases and simplify the query structure. The amended query now correctly calculates average expenses for the specified member during September and October months based on expense dates rather than event dates."
        ],
        "rules": [
            "Elijah Allen is the full name; full name refers to first_name, last_name; The 5th and 6th string of the expense_date in the expense table can refer to month; events in September and October refers to month(expense_date) = 9 OR month(expense_date) = 10"
        ]
    },
    "110": {
        "sql": [
            "SELECT d.disp_id\nFROM trans t\nJOIN disp d ON t.account_id = d.account_id\nWHERE t.amount = 5100 AND t.date = '1998-09-02';",
            "SELECT T1.disp_id\nFROM disp AS T1\nJOIN account AS T2 ON T1.account_id = T2.account_id\nJOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T3.amount = 5100\nAND T3.date = '1997-08-20';"
        ],
        "question": "What is the disposition id of the client who made 5100 USD transaction in 1998/9/2?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.disp_id FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.date='1997-08-20' AND T3.amount = 5100",
        "amends": [
            "Do join `account AS T2` on `T1.account_id = T2.account_id` instead of omitting the account table entirely. Do then join `trans AS T3` on `T2.account_id = T3.account_id` instead of directly joining `trans t` on `t.account_id = d.account_id`. Do filter on `T3.date='1997-08-20'` instead of `'1998-09-02'` while keeping the `T3.amount = 5100` condition. Do select `T1.disp_id` with table alias instead of `d.disp_id`. The amended query now correctly follows the three-table relationship path and uses the proper date filter to match the intended behavior."
        ],
        "rules": []
    },
    "742": {
        "sql": [
            "SELECT COUNT(*) \nFROM superhero \nWHERE race_id = (SELECT id FROM race WHERE race = 'Vampire');"
        ],
        "question": "How many vampire superheroes are there?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.superhero_name) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
        "amends": [],
        "rules": [
            "vampire superheroes refers to race = 'Vampire'"
        ]
    },
    "123": {
        "sql": [
            "SELECT a.account_id, d.A2 AS district, d.A3 AS region\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.amount > 300000;"
        ],
        "question": "Provide the account ID, district and region for loan amount greater than USD300,000.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.amount > 300000",
        "amends": [],
        "rules": [
            "A2 contains district names and A3 contains region names."
        ]
    },
    "1277": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.DNA < 8 AND P.Description IS NULL;"
        ],
        "question": "How many patients have a normal anti-DNA level, yet their data are not recorded.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA < 8 AND T1.Description IS NULL",
        "amends": [],
        "rules": [
            "normal anti-DNA level refers to DNA < 8; data are not recorded refers to Description IS NULL; Should compute the number of unique ones"
        ]
    },
    "1006": {
        "sql": [
            "SELECT MIN(milliseconds) AS fastest_lap_milliseconds, time AS fastest_lap_time FROM lapTimes;",
            "SELECT time FROM lapTimes ORDER BY (CAST(substr(time, 1, instr(time, ':') - 1) AS REAL) * 60 + CAST(substr(time, instr(time, ':') + 1) AS REAL)) ASC LIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE \n        WHEN time LIKE '%:%:%' THEN \n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 + \n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 + \n            CAST(SUBSTR(time, INSTR(time, ':', INSTR(time, ':') + 1) + 1) AS REAL)\n        ELSE \n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n            CAST(SUBSTR(time, INSTR(time, ':') + 1) AS REAL)\n    END \nLIMIT 1;",
            "SELECT time\nFROM lapTimes\nORDER BY \n    CASE \n        WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - INSTR(time, ':') - 1) AS REAL) +\n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n        ELSE\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n    END ASC\nLIMIT 1;",
            "SELECT time\nFROM lapTimes\nORDER BY \n    CASE \n        WHEN INSTR(time, ':') = 0 THEN CAST(time AS REAL)\n        WHEN INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') > 0 THEN\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(time, ':') + INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + 1) AS REAL)\n        ELSE\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1) AS REAL)\n    END ASC\nLIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE \n        WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - INSTR(time, ':') - 1) AS REAL) +\n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n        ELSE\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 +\n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n            CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n    END ASC\nLIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n         THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 \n         ELSE 0 \n    END +\n    CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n         THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 \n         ELSE CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 \n    END +\n    CAST(SUBSTR(time, INSTR(time, ':') + 1 + CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n                                               THEN INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + 1 \n                                               ELSE 0 \n                                          END, \n               INSTR(time, '.') - INSTR(time, ':') - 1 - CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n                                                           THEN INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + 1 \n                                                           ELSE 0 \n                                                      END) AS REAL) +\n    CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 \nASC \nLIMIT 1;",
            "SELECT time\nFROM lapTimes\nORDER BY \n    CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN\n        CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 +\n        CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n        CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n    ELSE\n        CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n        CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n    END ASC\nLIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE \n        WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n        THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 \n        ELSE 0 \n    END +\n    CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60 +\n    CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n    CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 \nASC \nLIMIT 1;"
        ],
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "amends": [
            "Do remove the `MIN(milliseconds)` aggregate and `fastest_lap_milliseconds` alias instead of calculating the minimum milliseconds value. Do completely change the SELECT list to only include `time` instead of selecting both milliseconds and time. Do remove the FROM clause entirely instead of keeping the table reference. Do add a complex ORDER BY clause that parses and converts the time string to seconds for proper sorting instead of ordering by milliseconds. Do add a LIMIT 1 clause to return only the single fastest lap time instead of returning all rows. The amended query now correctly identifies the fastest lap by parsing and converting the time format rather than relying on milliseconds, matching the RIGHT_SQL's behavior.",
            "Do use a comprehensive CASE expression to handle both minute:second.millisecond and hour:minute:second.millisecond time formats instead of assuming only minute:second format. Do add proper hour conversion with `* 3600` when detecting a second colon instead of omitting hour handling. Do fix the minute extraction logic to account for position variations instead of using a simple substring from the colon. Do add proper millisecond handling with division by 1000 instead of ignoring fractional seconds. Do include all time components (hours, minutes, seconds, milliseconds) in the sorting calculation instead of only minutes and seconds. The amended query now correctly handles various time formats and matches RIGHT_SQL's behavior.",
            "Do use a single CASE expression that checks for the presence of multiple colons with `INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')` instead of using `LIKE '%:%:%'` to detect time format. Do calculate hours component as `CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600` only when multiple colons exist instead of the complex nested substring approach. Do handle minutes calculation with conditional logic based on colon count using `INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')` instead of separate ELSE branch. Do extract seconds with proper decimal handling using `CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)` instead of simple substring. Do add millisecond precision with `CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000` instead of omitting fractional seconds. Do combine all time components into a single arithmetic expression for ordering instead of separate CASE branches. Do specify explicit `ASC` ordering instead of relying on default behavior. The amended query now correctly handles both time formats with proper decimal second precision and matches RIGHT_SQL's behavior.",
            "Do use a simplified arithmetic expression with proper conditional logic for time parsing instead of the complex nested CASE structure with incorrect substring calculations. Do add explicit ELSE 0 for the hour component instead of omitting it when there's only one colon. Do fix the minute extraction logic by using proper conditional positioning instead of the flawed INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') approach. Do maintain the same ORDER BY ASC and LIMIT 1 structure but with corrected time conversion that properly handles both mm:ss.fff and hh:mm:ss.fff formats. The amended query now correctly parses lap times by extracting hours only when two colons are present and properly calculates total seconds for accurate ordering.",
            "Do use a single CASE expression that checks `INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')` to detect three-part time format instead of nested INSTR checks. Do calculate hours component as `CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600` only for three-part times instead of using multiple conditional branches. Do extract minutes using `CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60` with proper position calculation instead of simple substring extraction. Do handle seconds and milliseconds separately with `CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)` for seconds and `CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000` for milliseconds instead of treating time as whole seconds. Do combine all time components with addition instead of using different calculation paths for different time formats. The amended query now correctly handles time parsing with milliseconds and matches RIGHT_SQL's behavior.",
            "Do use a simplified arithmetic expression with separate CASE and arithmetic components instead of nested conditional logic with complex substring calculations. Do add explicit ELSE 0 for the hour component instead of omitting it in the first CASE. Do restructure the minute calculation with proper conditional logic based on colon count instead of relying on complex nested substring operations. Do maintain the same second and millisecond extraction logic but with proper positioning instead of the incorrect offset calculations. Do fix the ORDER BY expression to properly handle both mm:ss.SSS and hh:mm:ss.SSS formats instead of the flawed conditional logic that miscalculated time component positions. The amended query now correctly parses and orders lap times by converting them to seconds regardless of whether they contain hours or not, matching the RIGHT_SQL's behavior.",
            "Do simplify the ORDER BY expression by removing redundant CASE statements and complex substring calculations instead of using nested CASE statements with repeated INSTR checks. Do use direct arithmetic operations for minute conversion instead of conditional logic that incorrectly handles single vs double colon formats. Do fix the minute extraction by using proper substring positioning with `INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':'))` instead of the flawed conditional approach that miscalculated minute values. Do streamline the second extraction by using `INSTR(time, '.') - INSTR(time, ':') - 1` for proper positioning instead of the complex nested CASE structure that incorrectly adjusted for colon positions. The amended query now correctly handles time format conversion for proper sorting while maintaining the same result behavior.",
            "Do simplify the CASE expression by removing the ELSE branch and instead adding an explicit `ELSE 0` for the hour component instead of having two separate calculation branches. Do restructure the time conversion calculation by breaking it into separate additive components with parentheses instead of having a single complex expression. Do maintain the same `ORDER BY` logic and `LIMIT 1` clause instead of changing the overall query structure. The amended query now correctly handles time conversion for both formats while maintaining the same result behavior as the RIGHT_SQL."
        ],
        "rules": []
    },
    "332": {
        "sql": [
            "SELECT COUNT(DISTINCT molecule_id) \nFROM bond \nWHERE bond_type = '-' \nAND molecule_id BETWEEN 'TR004' AND 'TR010';"
        ],
        "question": "Among the molecules between TR004 to TR010, how many of them has single bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.molecule_id BETWEEN 'TR004' AND 'TR010' AND T.bond_type = '-'",
        "amends": [],
        "rules": [
            "single bond refers to bond_type = '-'; molecules between TR004 to TR010 refers molecule_id BETWEEN 'TR004' and 'TR010';"
        ]
    },
    "1201": {
        "sql": [
            "SELECT (SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_women\nFROM Patient\nWHERE YEAR(Birthday) = '1980' AND Diagnosis = 'RA';",
            "SELECT (SUM(CASE WHEN p.SEX = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(p.ID)) \nFROM Patient p \nWHERE p.Diagnosis = 'RA' \nAND STRFTIME('%Y', p.Birthday) = '1980';"
        ],
        "question": "What percentage of patients who were born in 1980 and were diagnosed with RA are women?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE Diagnosis = 'RA' AND STRFTIME('%Y', Birthday) = '1980'",
        "amends": [
            "Do cast the SUM result as REAL instead of using implicit conversion, and do use COUNT(ID) instead of COUNT(*) to count only non-null IDs. Do move the Diagnosis filter before the Birthday condition instead of after it, and do use STRFTIME('%Y', Birthday) instead of YEAR(Birthday) for proper date extraction. Do remove the column alias percentage_women instead of keeping it. The amended query now correctly handles type conversion, counts specific non-null values, uses proper date formatting, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "born in 1980 refers to YEAR(BIRTHDAY) = '1980'; 'RA' refers to Diagnosis='RA' ; women refers to SEX = 'F'; calculation = DIVIDE(SUM(SEX = 'F'), COUNT(SEX)) * 100"
        ]
    },
    "1233": {
        "sql": [
            "SELECT p.ID, l.GLU\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE strftime('%Y', p.Description) = '1991'\nAND l.GLU < 180;",
            "SELECT DISTINCT T1.ID, T2.GLU\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE strftime('%Y', T1.\"First Date\") = '1991'\nAND T2.GLU < 180;"
        ],
        "question": "List each patient's ID and blood glucose (GLU) index that were within normal range for patient's whose data was first recorded in 1991.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T2.GLU FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) = '1991' AND T2.GLU < 180",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do reference `T1.ID` and `T2.GLU` instead of `p.ID` and `l.GLU` with different aliases. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do filter on `T1.First Date` instead of `p.Description` to correctly identify patients from 1991. Do maintain the same join condition `T1.ID = T2.ID` and glucose filter `T2.GLU < 180`. The amended query now correctly identifies distinct patients from 1991 with glucose readings below 180, matching the intended behavior."
        ],
        "rules": [
            "blood glucose (GLU) index that were within normal range refers to GLU < 180; data that was first recorded in 1991 refers to year(Description) = 1991;"
        ]
    },
    "297": {
        "sql": [
            "SELECT a.atom_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'c' AND m.label = '-';"
        ],
        "question": "Among the atoms that contain element carbon, which one does not contain compound carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
        "amends": [],
        "rules": [
            "label = '-' means molecules are non-carcinogenic; carbon refers to element = 'c'"
        ]
    },
    "1263": {
        "sql": [
            "SELECT E.ID\nFROM Examination E\nJOIN Laboratory L ON E.ID = L.ID\nWHERE L.HCT <= 29 OR L.HCT >= 52\nORDER BY E.`aCL IgA` DESC\nLIMIT 1;"
        ],
        "question": "Among the patients whose level of Hematoclit isn't normal, which patient has the highest anti-Cardiolipin antibody concentration? Please list his or her ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 on T1.ID = T3.ID WHERE (T3.HCT >= 52 OR T3.HCT <= 29) ORDER BY T2.`aCL IgA` DESC LIMIT 1",
        "amends": [],
        "rules": [
            "Hematoclit is normal refers to 29 < N < 52; highest anti-Cardiolipin antibody concentration refers to MAX(`aCL IgA`);"
        ]
    },
    "462": {
        "sql": [
            "SELECT st.translation AS italian_set_name\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE c.name = 'Ancestor''s Chosen' AND st.language = 'Italian';"
        ],
        "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
        "amends": [],
        "rules": [
            "Italian is a language which refers to language = 'Italian'; with \"Ancestor's Chosen\" in the card set refers to name = 'Ancestor''s Chosen'"
        ]
    },
    "517": {
        "sql": [
            "SELECT COUNT(DISTINCT c.uuid)\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.name = 'Abundance'\n  AND c.rarity = 'rare'\n  AND c.types LIKE '%Enchantment%'\nGROUP BY c.uuid\nHAVING SUM(CASE WHEN l.status != 'Legal' THEN 1 ELSE 0 END) = 0;",
            "SELECT COUNT(T1.id) \nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'Rare' \nAND T1.types = 'Enchantment' \nAND T1.name = 'Abundance' \nAND T2.status = 'Legal'",
            "SELECT COUNT(T1.id) \nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nWHERE T1.rarity = 'rare' \nAND T1.types = 'Enchantment' \nAND T1.name = 'Abundance' \nAND T2.status = 'Legal'"
        ],
        "question": "How many rare enchantment Abundance cards are there whose play format status are all legal?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.rarity = 'rare' AND T1.types = 'Enchantment' AND T1.name = 'Abundance' AND T2.status = 'Legal'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(DISTINCT c.uuid)` to count individual card IDs rather than distinct UUIDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use `T2.status = 'Legal'` as a direct filter instead of the complex `HAVING SUM(CASE WHEN l.status != 'Legal' THEN 1 ELSE 0 END) = 0` logic. Do use exact equality `T1.types = 'Enchantment'` instead of `LIKE '%Enchantment%'` for precise type matching. Do remove the unnecessary `GROUP BY c.uuid` clause since we're doing a simple count aggregation. Do add table aliases `T1` and `T2` consistently throughout the query instead of mixing `c` and `l` with unaliased references. The amended query now correctly counts cards with rare rarity, exact Enchantment type, specific name, and legal status, matching the intended behavior.",
            "Do use `T2.uuid = T1.uuid` for the join condition instead of `T1.uuid = T2.uuid` to maintain proper join semantics. Do change the `rarity` filter to lowercase `'rare'` instead of `'Rare'` to match the correct case sensitivity in the data. The amended query now correctly counts cards with the specified criteria while maintaining proper join relationships and case-sensitive filtering."
        ],
        "rules": [
            "rare refers to rarity = 'rare'; enchantment card refers to types = 'Enchantment'; Abundance cards refers to name = 'Abundance'; format status are all legal refers to status = 'Legal'"
        ]
    },
    "800": {
        "sql": [
            "SELECT (COUNT(CASE WHEN eye_colour_id = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_blue_eyes\nFROM superhero;"
        ],
        "question": "Calculate the percentage of superheroes with blue eyes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id",
        "amends": [],
        "rules": [
            "percentage = MULTIPLY(DIVIDE(SUM(superhero_name WHERE color = 'Blue'), COUNT(superhero_name)), 100.0); blue eyes refers to color = 'Blue' and color.id =  eye_colour_id = 7;"
        ]
    },
    "1337": {
        "sql": [
            "SELECT SUM(amount) AS total_budgeted_amount\nFROM budget\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'October Speaker');"
        ],
        "question": "What is the total budgeted amount for all category in \"October Speaker\" event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.amount) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'October Speaker'",
        "amends": [],
        "rules": [
            "total budgeted amount refers to SUM(amount) where event_name = 'October Speaker'"
        ]
    },
    "1089": {
        "sql": [
            "SELECT COUNT(*) AS number_of_matches\nFROM Match\nWHERE season = '2008/2009'\nAND country_id = (SELECT id FROM Country WHERE name = 'Belgium');"
        ],
        "question": "How many matches in the 2008/2009 season were held in Belgium?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Belgium' AND t2.season = '2008/2009'",
        "amends": [],
        "rules": [
            "Belgium refers to Country.name = 'Belgium';"
        ]
    },
    "59": {
        "sql": [
            "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName2 = 'Mike' AND AdmLName2 = 'Larson') OR (AdmFName3 = 'Mike' AND AdmLName3 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez') OR (AdmFName2 = 'Dante' AND AdmLName2 = 'Alvarez') OR (AdmFName3 = 'Dante' AND AdmLName3 = 'Alvarez');"
        ],
        "question": "What is the website for the schools under the administrations of Mike Larson and Dante Alvarez?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez')",
        "amends": [],
        "rules": []
    },
    "1514": {
        "sql": [
            "SELECT c.Currency\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-24' AND t.Time = '16:25:00';"
        ],
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "amends": [],
        "rules": [
            "'2012/8/24' can be represented by '2012-08-24'; "
        ]
    },
    "1203": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'F' AND L.WBC < 3.5;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.WBC < 3.5 AND T1.SEX = 'F'"
        ],
        "question": "How many patients who were female got white blood cells that were below 3.5?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC < 3.5 AND T1.SEX = 'F'",
        "amends": [
            "Do use `COUNT(T1.ID)` without DISTINCT instead of `COUNT(DISTINCT P.ID)` to count all matching rows rather than unique patient IDs. Do use table aliases `T1` and `T2` instead of `P` and `L` for consistency. Do place the `T2.WBC < 3.5` filter before `T1.SEX = 'F'` in the WHERE clause instead of the reverse order, though this is functionally equivalent. The amended query now correctly counts all laboratory results meeting the criteria rather than distinct patients, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "female refers to SEX = 'F'; white blood cells that were below 3.5 refers to WBC < 3.5"
        ]
    },
    "953": {
        "sql": [
            "SELECT COUNT(DISTINCT c.constructorId) \nFROM constructors c\nJOIN results r ON c.constructorId = r.constructorId\nWHERE c.nationality = 'French' AND r.laps > 50;"
        ],
        "question": "How many French constructors have a lap number of over 50?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "amends": [],
        "rules": [
            "lap numbers of over 50 refers to laps > 50;"
        ]
    },
    "1356": {
        "sql": [
            "SELECT m.department\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'President';"
        ],
        "question": "Which department was the President of the club in?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'President'",
        "amends": [],
        "rules": [
            "'President' is a position of Student Club"
        ]
    },
    "82": {
        "sql": [
            "SELECT f.\"Low Grade\", f.\"High Grade\"\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.Longitude = (SELECT MAX(Longitude) FROM schools);",
            "SELECT GSoffered FROM schools ORDER BY ABS(Longitude) DESC LIMIT 1;"
        ],
        "question": "What is the grade span offered in the school with the highest longitude?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
        "amends": [
            "Do select `GSoffered` instead of `\"Low Grade\", \"High Grade\"` from the `frpm` table. Do remove the `JOIN` with `schools` table and instead query only from `schools` table. Do remove the subquery with `MAX(Longitude)` and instead use `ORDER BY ABS(longitude) DESC` to find the school with maximum absolute longitude. Do add `LIMIT 1` instead of omitting it to return only the top result. Do remove the `WHERE` clause with subquery and instead incorporate the ordering directly in the main query. The amended query now correctly returns the GSoffered value from the school with the maximum absolute longitude instead of attempting to join and filter with complex subqueries."
        ],
        "rules": [
            "the highest longitude refers to the school with the maximum absolute longitude value."
        ]
    },
    "176": {
        "sql": [
            "SELECT l.amount AS debt_amount, l.status AS payment_status\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.client_id = 992;"
        ],
        "question": "What is the amount of debt that client number 992 has, and how is this client doing with payments?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.amount, T4.status FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 on T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 992",
        "amends": [],
        "rules": []
    },
    "556": {
        "sql": [
            "SELECT AVG(badge_count) AS average_badges\nFROM (\n    SELECT u.Id, COUNT(b.Id) AS badge_count\n    FROM users u\n    LEFT JOIN badges b ON u.Id = b.UserId\n    WHERE u.Views > 200\n    GROUP BY u.Id\n) AS user_badges;"
        ],
        "question": "What is the average number of badges obtained by a user with over 200 views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Views > 200",
        "amends": [],
        "rules": [
            "user with over 200 views refers to Views > 200; average number of badges = Divide (Count(Id), Count(DisplayName))"
        ]
    },
    "1065": {
        "sql": [
            "SELECT t.team_long_name \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE ta.buildUpPlaySpeedClass = 'Fast';"
        ],
        "question": "Please list all team names which the speed class is fast.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "amends": [],
        "rules": [
            "team names refers to team_long_name; speed class refers to buildUpPlaySpeedClass; buildUpPlaySpeedClass = 'Fast';"
        ]
    },
    "836": {
        "sql": [
            "SELECT COUNT(*) FROM superhero WHERE full_name LIKE 'John%';"
        ],
        "question": "What is the total number of superheroes that have John as their first name?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name LIKE 'John%'",
        "amends": [],
        "rules": [
            "have John as their first name refers to full_name LIKE 'John%';"
        ]
    },
    "814": {
        "sql": [
            "SELECT c.colour\nFROM hero_attribute ha\nJOIN superhero s ON ha.hero_id = s.id\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE ha.attribute_value = 100;"
        ],
        "question": "List the skin colour of the superheroes with 100 attribute value.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id WHERE T3.attribute_value = 100",
        "amends": [],
        "rules": [
            "skin colour refers to colour.colour where skin_colour_id = colour.id; 100 attribute value refers to attribute_value = 100;"
        ]
    },
    "81": {
        "sql": [
            "SELECT s.City, s.School, f.\"Low Grade\"\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.State = 'CA'\nORDER BY s.Latitude ASC\nLIMIT 1;",
            "SELECT T1.\"School Name\", T1.\"Low Grade\", T2.City\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.State = 'CA'\nORDER BY T2.Latitude ASC\nLIMIT 1;",
            "SELECT T2.City, T1.`Low Grade`, T1.`School Name`\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.State = 'CA'\nORDER BY T2.Latitude ASC\nLIMIT 1;"
        ],
        "question": "In which city can you find the school in the state of California with the lowest latitude coordinates and what is its lowest grade? Indicate the school name.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.City, T1.`Low Grade`, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.State = 'CA' ORDER BY T2.Latitude ASC LIMIT 1",
        "amends": [
            "Do select `T1.School Name` instead of `s.School`, and do select `T1.Low Grade` instead of `f.Low Grade` with proper table aliases. Do use `INNER JOIN` with explicit `AS` table aliases `T1` and `T2` instead of simple aliases `s` and `f`. Do join on `T1.CDSCode = T2.CDSCode` instead of `s.CDSCode = f.CDSCode` to maintain proper table reference consistency. Do filter on `T2.State = 'CA'` instead of `s.State = 'CA'` to correctly reference the joined table. Do order by `T2.Latitude ASC` instead of `s.Latitude ASC` with consistent table alias usage. The amended query now correctly selects the intended columns from the proper table sources and maintains consistent join logic throughout.",
            "Do reorder the SELECT list to `T2.City, T1.Low Grade, T1.School Name` instead of `T1.School Name, T1.Low Grade, T2.City`. Do use backticks for column names `Low Grade` and `School Name` instead of double quotes. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column order and identifier quoting."
        ],
        "rules": [
            "State of California refers to state = 'CA'"
        ]
    },
    "662": {
        "sql": [
            "SELECT COUNT(DISTINCT p.Id) \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE strftime('%Y', v.CreationDate) = '2011' \nAND v.BountyAmount = 50;"
        ],
        "question": "How many posts with votes that were created in 2011 have a bounty of 50?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.BountyAmount = 50 AND STRFTIME('%Y', T2.CreationDate) = '2011'",
        "amends": [],
        "rules": [
            "created in 2012 refers YEAR(CreationDate) = 2011; BountyAmount = 50;"
        ]
    },
    "436": {
        "sql": [
            "SELECT COUNT(*) AS count, GROUP_CONCAT(id) AS card_ids FROM cards WHERE frameEffects = 'extendedart';",
            "SELECT id FROM cards WHERE frameEffects LIKE '%extendedart%' GROUP BY id;",
            "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id"
        ],
        "question": "How many cards have frame effect as extendedart? List out the id of those cards.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id",
        "amends": [
            "Do select individual `id` values instead of aggregating with `COUNT(*)` and `GROUP_CONCAT(id)`. Do add `GROUP BY id` instead of omitting grouping. Do remove the `AS count` and `AS card_ids` aliases instead of keeping them. The amended query now correctly returns individual card IDs rather than aggregated counts and concatenated ID lists, matching the RIGHT_SQL's behavior of selecting distinct card records with extended art frame effects.",
            "Do use exact equality comparison `frameEffects = 'extendedart'` instead of the LIKE pattern match `frameEffects LIKE '%extendedart%'` to ensure precise matching of the exact string value rather than partial substring matching, which could incorrectly include records with additional frame effects. The amended query now correctly filters for cards that have exactly the 'extendedart' frame effect and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "\nframe effect as extendedart refers to frameEffects = 'extendedart'\n"
        ]
    },
    "1163": {
        "sql": [
            "SELECT MIN(strftime('%Y', `First Date`) - strftime('%Y', Birthday) - (strftime('%m-%d', `First Date`) < strftime('%m-%d', Birthday))) AS youngest_age FROM Patient;"
        ],
        "question": "What was the age of the youngest patient when they initially arrived at the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT MIN(STRFTIME('%Y', `First Date`) - STRFTIME('%Y', Birthday)) FROM Patient",
        "amends": [],
        "rules": [
            "age refers to SUBTRACT(YEAR(`First Date`),YEAR(Birthday))"
        ]
    },
    "1032": {
        "sql": [
            "SELECT l.name AS league_name, COUNT(m.league_id) AS match_count\nFROM Match m\nJOIN League l ON m.league_id = l.id\nGROUP BY m.league_id\nORDER BY match_count DESC\nLIMIT 1;",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(*) AS match_count\n    FROM Match\n    GROUP BY league_id\n) AS league_counts\nJOIN (\n    SELECT MAX(match_count) AS max_count\n    FROM (\n        SELECT league_id, COUNT(*) AS match_count\n        FROM Match\n        GROUP BY league_id\n    )\n) AS t1 ON league_counts.match_count = t1.max_count\nJOIN League AS t2 ON league_counts.league_id = t2.id",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, MAX(cnt) AS max_count\n    FROM (\n        SELECT league_id, COUNT(id) AS cnt\n        FROM Match\n        GROUP BY league_id\n    )\n) t1\nJOIN League t2 ON t1.league_id = t2.id"
        ],
        "question": "Give the name of the league with the highest matches of all time and how many matches were played in the said league.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name, t1.max_count FROM League AS t2 JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery) AS t1 ON t1.league_id = t2.id",
        "amends": [
            "Do select `t2.name` and `t1.max_count` instead of `l.name` and `COUNT(m.league_id)`. Do use a subquery to calculate the maximum match count per league instead of counting matches directly. Do join the League table with a derived table containing the maximum count instead of joining directly with Match. Do include a subquery that first counts matches by `league_id` and then finds the maximum count instead of grouping by `league_id` directly. Do remove the `ORDER BY` and `LIMIT 1` clauses instead of keeping them, as the maximum value is now calculated through aggregation. The amended query now correctly identifies the league with the maximum match count by using proper aggregation techniques instead of relying on ordering and limiting.",
            "Do use `MAX(cnt)` in the outer subquery instead of selecting `MAX(match_count)` from a separate subquery. Do join directly on `t1.league_id = t2.id` instead of matching `league_counts.match_count = t1.max_count`. Do remove the redundant intermediate subquery that calculates maximum match count separately instead of keeping it. Do reference `COUNT(id)` as `cnt` instead of `COUNT(*) AS match_count` in the innermost subquery. Do eliminate the unnecessary join condition based on match count equality instead of preserving it. The amended query now correctly identifies leagues with their maximum match counts by joining directly on league_id rather than attempting to match count values across different aggregation levels."
        ],
        "rules": [
            " league with highest matches of all time refers to MAX(COUNT(league_id));"
        ]
    },
    "193": {
        "sql": [
            "SELECT DISTINCT c.client_id, c.district_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nWHERE d.type = 'OWNER'\nAND NOT EXISTS (\n    SELECT 1\n    FROM disp d2\n    WHERE d2.client_id = c.client_id\n    AND d2.type != 'OWNER'\n);",
            "SELECT c.client_id, c.district_id, d.A2\nFROM client c\nINNER JOIN disp dp ON c.client_id = dp.client_id\nINNER JOIN account a ON dp.account_id = a.account_id\nINNER JOIN district d ON c.district_id = d.district_id\nWHERE dp.type = 'OWNER'\nAND NOT EXISTS (\n    SELECT 1 \n    FROM disp dp2 \n    WHERE dp2.client_id = c.client_id \n    AND dp2.type != 'OWNER'\n)",
            "SELECT T3.client_id, T2.district_id, d.A2\nFROM account T2\nINNER JOIN disp T3 ON T2.account_id = T3.account_id\nINNER JOIN district d ON T2.district_id = d.district_id\nWHERE T3.type = 'OWNER'"
        ],
        "question": "List all ID and district for clients that can only have the right to issue permanent orders or apply for loans.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.client_id, T2.district_id, T2.A2 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id WHERE T3.type = 'OWNER'",
        "amends": [
            "Do select `client_id`, `district_id`, and `A2` instead of only `client_id` and `district_id`. Do join `account` and `district` tables on `district_id` instead of only accessing the `client` table. Do use `INNER JOIN` between `account` and `disp` on `account_id` instead of joining `client` directly to `disp` on `client_id`. Do remove the `DISTINCT` modifier and the `NOT EXISTS` subquery checking for non-OWNER types instead of keeping them. Do add the `A2` column from the `district` table instead of omitting it. The amended query now correctly joins through the account relationship and retrieves the additional district information while eliminating the unnecessary subquery logic.",
            "Do join `account` to `district` on `district_id` instead of joining `client` to `district` on `district_id`. Do remove the `client` table entirely instead of including it as a source. Do remove the `NOT EXISTS` subquery checking for non-OWNER dispositions instead of keeping this exclusion logic. Do select `T3.client_id` and `T2.district_id` instead of `c.client_id` and `c.district_id`. Do maintain the filter on `T3.type = 'OWNER'` instead of changing this condition. The amended query now correctly identifies account owners through the disposition table without unnecessary client table joins or subquery exclusions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "Only the owner accounts have the right to issue permanent orders or apply for loans"
        ]
    },
    "847": {
        "sql": [
            "SELECT d.surname \nFROM qualifying q \nJOIN drivers d ON q.driverId = d.driverId \nWHERE q.raceId = 19 \nAND q.q2 IS NOT NULL \nORDER BY q.q2 ASC \nLIMIT 1;",
            "SELECT T2.surname \nFROM qualifying T1 \nINNER JOIN drivers T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 19 \nORDER BY T1.q2 ASC \nLIMIT 1"
        ],
        "question": "What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 19 ORDER BY T1.q2 ASC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do reference `drivers` as `T2` with alias `T2.surname` instead of `d.surname`. Do specify the join condition as `T2.driverId = T1.driverId` instead of `q.driverId = d.driverId` for consistent table reference order. Do remove the filter `q.q2 IS NOT NULL` instead of keeping it since the ORDER BY ASC with LIMIT 1 naturally handles NULL values by placing them last. Do maintain the `WHERE T1.raceId = 19` filter, `ORDER BY T1.q2 ASC` sorting, and `LIMIT 1` clause unchanged. The amended query now correctly returns the fastest qualifying driver for race 19 without unnecessary NULL filtering."
        ],
        "rules": [
            "race number refers to raceId; second qualifying period refers to q2; best lap time refers to MIN(q2);"
        ]
    },
    "1279": {
        "sql": [
            "SELECT (COUNT(DISTINCT CASE WHEN l.GOT >= 60 AND p.Diagnosis = 'SLE' THEN l.ID END) * 100.0 / COUNT(DISTINCT CASE WHEN l.GOT >= 60 THEN l.ID END)) AS percentage\nFROM Laboratory l\nJOIN Patient p ON l.ID = p.ID;",
            "SELECT \n    COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) * 1.0 / COUNT(T1.ID) AS percentage\nFROM \n    (SELECT DISTINCT p.ID, p.Diagnosis\n     FROM Patient p\n     INNER JOIN Laboratory l ON p.ID = l.ID\n     WHERE l.GOT >= 60) T1"
        ],
        "question": "What is the percentage of patient who has a abnormal level of glutamic oxaloacetic transaminase level, yet he or she is diagnosed with SLE?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`GOT` >= 60",
        "amends": [
            "Do use `COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) / COUNT(T1.ID)` instead of `COUNT(DISTINCT CASE WHEN l.GOT >= 60 AND p.Diagnosis = 'SLE' THEN l.ID END) * 100.0 / COUNT(DISTINCT CASE WHEN l.GOT >= 60 THEN l.ID END)` for the percentage calculation. Do change the join to `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of `JOIN Patient p ON l.ID = p.ID` to properly relate patients to laboratory results. Do move the `GOT >= 60` filter to the `WHERE` clause instead of embedding it in CASE expressions. Do use `LIKE '%SLE%'` instead of `= 'SLE'` to capture all SLE-related diagnoses. Do remove the DISTINCT operations and percentage multiplication since the division already produces the correct ratio. The amended query now correctly calculates the proportion of SLE patients among those with elevated GOT levels."
        ],
        "rules": [
            "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; percentage = MULTIPLY(DIVIDE(COUNT(ID WHERE GOT > = 60 AND Diagnosis = 'SLE'), COUNT(ID WHERE GOT > = 60)), 1.0);"
        ]
    },
    "144": {
        "sql": [
            "SELECT \n    strftime('%m', t.date) AS month,\n    AVG(t.amount) AS average_amount\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nWHERE \n    t.operation = 'VYBER KARTOU'\n    AND strftime('%Y', t.date) = '2021'\nGROUP BY \n    month\nORDER BY \n    month;",
            "SELECT AVG(T4.amount) AS average_amount\nFROM card AS T1\nJOIN disp AS T2 ON T1.disp_id = T2.disp_id\nJOIN account AS T3 ON T2.account_id = T3.account_id\nJOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE STRFTIME('%Y', T4.date) = '1998'\nAND T4.operation = 'VYBER KARTOU'"
        ],
        "question": "How much is the average amount in credit card made by account holders in a month, in year 2021?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT AVG(T4.amount) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE STRFTIME('%Y', T4.date) = '1998' AND T4.operation = 'VYBER KARTOU'",
        "amends": [
            "Do use `AVG(T4.amount)` without month grouping instead of `strftime('%m', t.date) AS month` with `AVG(t.amount)` and grouping. Do join `card AS T1` and `disp AS T2` on `T1.disp_id = T2.disp_id` instead of omitting these tables entirely. Do join `account AS T3` on `T2.account_id = T3.account_id` instead of directly joining `account a` on `t.account_id = a.account_id`. Do join `trans AS T4` on `T3.account_id = T4.account_id` instead of the direct account-trans join. Do filter with `STRFTIME('%Y', T4.date) = '1998'` instead of `'2021'` while keeping `T4.operation = 'VYBER KARTOU'`. Do remove the `GROUP BY month` and `ORDER BY month` clauses instead of including them. The amended query now correctly calculates the average amount for card withdrawal operations in 1998 across the proper table relationships."
        ],
        "rules": [
            "Operation = 'VYBER KARTOU' refers to credit card withdrawn"
        ]
    },
    "1351": {
        "sql": [
            "SELECT m.major_name \nFROM member mb \nJOIN major m ON mb.link_to_major = m.major_id \nWHERE mb.first_name = 'Brent' AND mb.last_name = 'Thomason';"
        ],
        "question": "What was Brent Thomason's major?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'",
        "amends": [],
        "rules": [
            "Brent Thomason is the full name; full name refers to first_name, last_name; major refers to major_name"
        ]
    },
    "915": {
        "sql": [
            "SELECT nationality FROM drivers WHERE dob = (SELECT MIN(dob) FROM drivers);"
        ],
        "question": "Which country is the oldest driver from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1",
        "amends": [],
        "rules": [
            "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;"
        ]
    },
    "68": {
        "sql": [
            "SELECT County, COUNT(*) AS NumberOfClosures\nFROM schools\nWHERE SOC = '11' AND ClosedDate BETWEEN '1980-01-01' AND '1989-12-31'\nGROUP BY County\nORDER BY NumberOfClosures DESC\nLIMIT 1;",
            "SELECT County, COUNT(School) \nFROM schools \nWHERE StatusType = 'Closed' \nAND strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' \nAND SOC = 11 \nGROUP BY County \nORDER BY COUNT(School) DESC \nLIMIT 1;",
            "SELECT County FROM schools WHERE StatusType = 'Closed' AND strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND SOC = 11 GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1"
        ],
        "question": "Which county reported the most number of school closure in the 1980s with school wonership code belonging to Youth Authority Facilities (CEA)?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT County FROM schools WHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND StatusType = 'Closed' AND SOC = 11 GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1",
        "amends": [
            "Do use `strftime('%Y', ClosedDate)` for year extraction instead of direct date range comparison with `BETWEEN '1980-01-01' AND '1989-12-31'`. Do add filter `StatusType = 'Closed'` instead of omitting it to ensure only closed schools are counted. Do change `SOC = 11` (numeric) instead of `SOC = '11'` (string) to match the correct data type. Do count `COUNT(School)` instead of `COUNT(*)` to specifically count school closures rather than all records. Do order by `COUNT(School) DESC` instead of `NumberOfClosures DESC` since the alias is no longer used. Do remove the alias `AS NumberOfClosures` instead of keeping it as the result set only returns County. The amended query now correctly identifies counties with the most school closures in the 1980s by properly filtering for closed status and using appropriate year extraction and counting methods.",
            "Do remove `COUNT(School)` from the SELECT list instead of including it, as the query only needs to return the County. Do keep the same FROM source `schools` and maintain all WHERE filters including `StatusType = 'Closed'`, `strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989'`, and `SOC = 11` with the same logic. Do preserve the GROUP BY `County` and ORDER BY `COUNT(School) DESC` with LIMIT 1 to find the county with the most closed schools in the 1980s. The amended query now correctly returns only the County column while maintaining the same aggregation and filtering behavior."
        ],
        "rules": [
            "Youth Authority Facilities (CEA) refers to SOC = 11; 1980s = years between 1980 and 1989"
        ]
    },
    "453": {
        "sql": [
            "SELECT convertedManaCost FROM cards WHERE name = 'Ancestor`s Chosen';",
            "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen';"
        ],
        "question": "What's the unconverted mana cost of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
        "amends": [
            "Do select `manaCost` instead of `convertedManaCost` and add `DISTINCT` instead of omitting it. Do use escaped apostrophes `''` in the string literal instead of a backtick `'` for the name filter condition. The amended query now correctly retrieves distinct mana cost values with proper string escaping."
        ],
        "rules": [
            "card \"Ancestor's Chosen\" refers to name = 'Ancestor`s Chosen'"
        ]
    },
    "378": {
        "sql": [
            "SELECT id FROM cards WHERE hasFoil = 1 AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;"
        ],
        "question": "What are the foiled cards that are incredibly powerful when paired with non foiled cards? List the IDs.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "amends": [],
        "rules": [
            "Incredibly powerful refers to both cardKingdomFoilId and cardKingdomId IS NOT Null;"
        ]
    },
    "1373": {
        "sql": [
            "SELECT COUNT(DISTINCT m.member_id) \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE z.state = 'Maryland';"
        ],
        "question": "How many of the members' hometowns are from Maryland state?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.member_id) FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T1.state = 'Maryland'",
        "amends": [],
        "rules": []
    },
    "1379": {
        "sql": [
            "SELECT COUNT(*) FROM event WHERE type = 'Meeting' AND event_date LIKE '%2020%';"
        ],
        "question": "How many meeting events were held in 2020?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(event_id) FROM event WHERE type = 'Meeting' AND SUBSTR(event_date, 1, 4) = '2020'",
        "amends": [],
        "rules": [
            "meeting events refers to type = 'Meeting'; held in 2020 refers to YEAR(event_date) = 2020"
        ]
    },
    "1517": {
        "sql": [
            "SELECT Segment FROM customers WHERE CustomerID = (SELECT MIN(CustomerID) FROM customers);",
            "SELECT T2.Segment \nFROM transactions_1k AS T1 \nJOIN customers AS T2 ON T1.CustomerID = T2.CustomerID \nORDER BY T1.Date ASC \nLIMIT 1"
        ],
        "question": "For the earliest customer, what segment did he/she have?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID ORDER BY Date ASC LIMIT 1",
        "amends": [
            "Do join `transactions_1k AS T1` with `customers AS T2` on `T1.CustomerID = T2.CustomerID` instead of querying `customers` alone with a subquery for `MIN(CustomerID)`. Do select `T2.Segment` with table qualification instead of just `Segment`. Do remove the `WHERE` filter with subquery entirely instead of using it to find the minimum CustomerID. Do add `ORDER BY Date ASC` and `LIMIT 1` to get the earliest transaction's customer segment instead of relying on minimum CustomerID value. The amended query now correctly retrieves the customer segment from the earliest transaction rather than the customer with the lowest ID value, matching the RIGHT_SQL's behavior."
        ],
        "rules": []
    },
    "875": {
        "sql": [
            "SELECT s.url\nFROM seasons s\nJOIN races r ON s.year = r.year\nWHERE r.raceId = 901;"
        ],
        "question": "Show me the season page of year when the race No. 901 took place.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "amends": [],
        "rules": [
            "the season page refers to url; race number refers to raceId;"
        ]
    },
    "455": {
        "sql": [
            "SELECT name FROM cards WHERE isPromo = 1 AND otherFaceIds IS NOT NULL AND otherFaceIds != '';"
        ],
        "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "amends": [],
        "rules": [
            "are a promotional painting refers to isPromo = 1; have multiple faces on the same card refers to side is not Null"
        ]
    },
    "585": {
        "sql": [
            "SELECT SUM(v.BountyAmount) AS TotalBountyAmount\nFROM posts p\nJOIN votes v ON p.Id = v.PostId\nWHERE p.Title LIKE '%data%';"
        ],
        "question": "How much is the total bounty amount of the post titled about 'data'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.BountyAmount) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data%'",
        "amends": [],
        "rules": [
            "About data means the title contains 'data'; total bounty Amount refers to Sum(BountyAmount)"
        ]
    },
    "1248": {
        "sql": [
            "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Birthday > '1980-01-01'\nAND (L.FG < 150 OR L.FG > 450);",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.FG <= 150 OR T2.FG >= 450)\nAND T1.Birthday > '1980-01-01'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.FG <= 150 OR T2.FG >= 450\nAND T1.Birthday > '1980-01-01'"
        ],
        "question": "How many patients born after 1980/1/1 have an abnormal fibrinogen level?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T1.Birthday > '1980-01-01'",
        "amends": [
            "Do use `T1.ID` and `T2.ID` with table aliases instead of `P.ID` and `L.ID` without aliases. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do change the FG condition to `T2.FG <= 150 OR T2.FG >= 450` instead of `L.FG < 150 OR L.FG > 450` to include the boundary values 150 and 450. Do reorder the WHERE clause with the FG condition first instead of the Birthday condition first. The amended query now correctly counts patients with FG values at or beyond the specified thresholds while maintaining the same join logic and birthday filter.",
            "Do remove the parentheses around the `T2.FG` conditions in the WHERE clause instead of keeping them, as the parentheses incorrectly group the OR condition and change the logical evaluation order. Do maintain the same SELECT list with `COUNT(DISTINCT T1.ID)`, FROM sources with `INNER JOIN` on `T1.ID = T2.ID`, and all other elements unchanged. The amended query now correctly evaluates the OR condition without artificial grouping and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "born after 1980/1/1 refers to Birthday > '1980-01-01'; normal fibrinogen level refers to FG between 150 and 450; Should return the number of distinct patients."
        ]
    },
    "224": {
        "sql": [
            "SELECT DISTINCT c1.bond_id\nFROM connected c1\nJOIN connected c2 ON c1.atom_id2 = c2.atom_id2\nWHERE c2.atom_id = 'TR000_2' OR c2.atom_id2 = 'TR000_2';"
        ],
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "amends": [],
        "rules": [
            "TR000_2 is the atom id; atom ID 2 refers to atom_id2"
        ]
    },
    "1346": {
        "sql": [
            "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs';"
        ],
        "question": "Tell the phone number of \"Carlo Jacobs\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs'",
        "amends": [],
        "rules": [
            "Carlo Jacobs is the full name; full name refers to first_name, last_name;"
        ]
    },
    "344": {
        "sql": [
            "SELECT c.* FROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic'\nAND l.format = 'gladiator'\nAND l.status = 'Banned';",
            "SELECT DISTINCT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T2.format = 'gladiator' \n  AND T2.status = 'banned'\n  AND T1.rarity = 'mythic'",
            "SELECT DISTINCT T1.id\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T2.format = 'gladiator'\nAND T2.status = 'Banned'\nAND T1.rarity = 'mythic'"
        ],
        "question": "List all the mythic rarity print cards banned in gladiator format.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "amends": [
            "Do select `DISTINCT T1.id` instead of `c.*` to return only unique card identifiers rather than all columns. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `JOIN` with single-letter aliases. Do maintain the same join condition `T1.uuid = T2.uuid` but with consistent table reference. Do keep all three filter conditions on `format`, `status`, and `rarity` in the `WHERE` clause with proper table qualification. The amended query now correctly returns distinct banned mythic rare cards in the gladiator format, matching the intended behavior.",
            "Do use `status = 'Banned'` with uppercase 'B' instead of `status = 'banned'` with lowercase 'b' to match the correct case sensitivity in the data. Do keep all other elements identical including `SELECT DISTINCT T1.id`, `FROM cards T1 INNER JOIN legalities T2 ON T1.uuid = T2.uuid`, `WHERE T2.format = 'gladiator'`, and `AND T1.rarity = 'mythic'` as they are correctly implemented. The amended query now matches RIGHT_SQL's behavior by properly filtering for the exact case-sensitive status value."
        ],
        "rules": [
            "mythic rarity printing refers to rarity = 'mythic'; card banned refers to status = 'Banned'; in gladiator format refers to format = 'gladiator';"
        ]
    },
    "750": {
        "sql": [
            "SELECT AVG(s.weight_kg) AS average_weight\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Female';"
        ],
        "question": "What is the average weight of all female superheroes?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'",
        "amends": [],
        "rules": [
            "female refers to gender = 'Female'; average weight refers to AVG(weight_kg)"
        ]
    },
    "1267": {
        "sql": [
            "SELECT COUNT(DISTINCT E.ID) \nFROM Examination E\nJOIN Patient P ON E.ID = P.ID\nWHERE (E.SM IN('-', '+-')) AND E.Thrombosis = 0;",
            "SELECT COUNT(T1.ID)\nFROM Examination T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.SM IN ('negative', '0')\nAND T1.Thrombosis = 0;"
        ],
        "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
        "amends": [
            "Do join `Laboratory AS T2` instead of `Patient P` and use `INNER JOIN` instead of `JOIN`. Do reference `T2.SM` instead of `E.SM` and check for values `('negative','0')` instead of `('-', '+-')`. Do remove `DISTINCT` from the count instead of keeping it and count `T1.ID` instead of `E.ID`. Do reference `T1.Thrombosis` instead of `E.Thrombosis` while keeping the same filter condition. The amended query now correctly counts examinations with specific laboratory results instead of patient joins."
        ],
        "rules": [
            "normal anti-SM refers to SM IN('-', '+-'); SM = 'negative' means '-'; SM = '0' means '+-'; SM = '1' means '+'; does not have thrombosis refers to Thrombosis = 0;"
        ]
    },
    "1073": {
        "sql": [
            "SELECT COUNT(*) AS match_count\nFROM Match\nWHERE league_id = (SELECT id FROM League WHERE name = 'Germany 1. Bundesliga')\nAND strftime('%Y-%m', date) BETWEEN '2008-08' AND '2008-10';"
        ],
        "question": "How many matches were held in the league Germany 1. Bundesliga\nfrom August to October 2008?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Germany 1. Bundesliga' AND SUBSTR(t2.`date`, 1, 7) BETWEEN '2008-08' AND '2008-10'",
        "amends": [],
        "rules": [
            "Germany 1. Bundesliga refers to League.name = 'Germany 1. Bundesliga'; from August to October 2008 refers to strftime('%Y-%m', date) BETWEEN '2008-08' AND '2008-10';"
        ]
    }
}