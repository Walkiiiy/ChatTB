{
    "287": {
        "sql": "SELECT (COUNT(CASE WHEN bond_type = '=' THEN 1 END) * 100.0 / COUNT(*)) AS percent_double_bonds\nFROM bond\nWHERE molecule_id = 'TR047';",
        "question": "Among all chemical compounds that contain molecule TR047, identify the percent that form a double-bond.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T WHERE T.molecule_id = 'TR047'",
        "explain": "TR047 is the molecule id; double bond refers to bond_type = ' = '; percentage = DIVIDE(SUM(bond_type = ' = '), COUNT(all bond_id)) as percent where molecule_id = 'TR047'",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Filter the Bonds**: Select all bonds from the `bond` table where the `molecule_id` is 'TR047'.\n\n2. **Count Total Bonds**: Calculate the total number of bonds for the molecule 'TR047'.\n\n3. **Count Double Bonds**: From the filtered bonds, count how many have a `bond_type` equal to '=' (indicating a double bond).\n\n4. **Calculate Percentage**: Divide the count of double bonds by the total number of bonds and multiply by 100 to get the percentage of double bonds among all bonds for the molecule 'TR047'.\n\nThis sequence of operations ensures that the percentage of double bonds for the molecule 'TR047' is accurately determined."
        ]
    },
    "1013": {
        "sql": "WITH fastest_lap_times AS (\n    SELECT raceId, fastestLapTime\n    FROM results\n    WHERE fastestLapTime IS NOT NULL\n)\nSELECT MIN(f.fastestLapTime) AS lap_record\nFROM fastest_lap_times f\nJOIN races r ON f.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Austrian Grand Prix';",
        "question": "What is the lap record for the Austrian Grand Prix Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.fastestLapTime FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL) SELECT MIN(fastest_lap_times.fastestLapTime) as lap_record FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix'",
        "explain": "lap record means the fastest time recorded which refers to time",
        "solution": [
            "To find the lap record for the Austrian Grand Prix Circuit, follow these steps:\n\n1. **Filter Results with Fastest Lap Times**:\n   - Start by selecting all records from the `results` table where the `fastestLapTime` is not null. This ensures we only consider races where lap times were recorded.\n   - Store these records in a temporary table called `fastest_lap_times`, which includes the `raceId` and `fastestLapTime` columns.\n\n2. **Join with Races and Circuits**:\n   - Join the `fastest_lap_times` table with the `races` table using the `raceId` column to get details about each race.\n   - Further join the result with the `circuits` table using the `circuitId` column to identify the circuit associated with each race.\n\n3. **Filter for Austrian Grand Prix**:\n   - Apply a filter to the joined data to include only races where the `name` in the `races` table is 'Austrian Grand Prix'.\n\n4. **Calculate the Lap Record**:\n   - From the filtered data, find the minimum value of the `fastestLapTime` column. This represents the fastest lap time ever recorded for the Austrian Grand Prix Circuit, which is the lap record.\n\n5. **Output the Result**:\n   - Display the calculated minimum `fastestLapTime` as the lap record for the Austrian Grand Prix Circuit."
        ]
    },
    "989": {
        "sql": "SELECT T1.time\nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___';\n",
        "question": "Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___'",
        "explain": "Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\";",
        "solution": [
            "To find the champion of the Canadian Grand Prix in 2008 along with their finish time, the following steps are performed:\n\n1. **Join the tables**: The `results` table (aliased as `T1`) is joined with the `races` table (aliased as `T2`) using the `raceId` column to link the results to the corresponding race.\n\n2. **Filter the race**: The query filters the `races` table to only include the race named 'Canadian Grand Prix' and the year 2008.\n\n3. **Filter the results**: The query further filters the `results` table to include only those entries where the `time` column matches the pattern '_:%:__.___', which represents a valid finish time format (e.g., '1:23:45.678').\n\n4. **Select the time**: The query selects the `time` column from the `results` table, which contains the finish time of the champion.\n\nThis solution ensures that the champion's finish time for the specified race and year is accurately retrieved."
        ]
    },
    "148": {
        "sql": "SELECT a.account_id\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nJOIN disp dp ON a.account_id = dp.account_id\nWHERE d.A2 = 'Tabor' AND dp.type = 'OWNER';",
        "question": "Please list the accounts whose district is Tabor that are eligible for loans.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.account_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'OWNER' AND T1.A2 = 'Tabor'",
        "explain": "District refers to column A2; when the account type = 'OWNER', it's eligible for loans",
        "solution": []
    },
    "495": {
        "sql": "SELECT s.releaseDate \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Evacuation';",
        "question": "What was the release date for the set which card \"Evacuation\" in it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Evacuation'",
        "explain": "\"Evacuation\" refers to name = 'Evacuation'; release date refers to releaseDate",
        "solution": []
    },
    "1465": {
        "sql": "SELECT b.category\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nWHERE e.expense_description = 'Posters';",
        "question": "Which budget category does the expense 'Posters' fall to?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Posters'",
        "explain": "'Posters' refers to expense description",
        "solution": []
    },
    "355": {
        "sql": "SELECT keywords FROM cards WHERE name = 'Angel of Mercy';",
        "question": "What is the keyword found on card 'Angel of Mercy'?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy'",
        "explain": "Angel of Mercy' is the name of card;",
        "solution": []
    },
    "775": {
        "sql": "SELECT \n    (COUNT(CASE WHEN c.colour = 'Blue' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_blue_female\nFROM \n    superhero s\nJOIN \n    gender g ON s.gender_id = g.id\nLEFT JOIN \n    colour c ON s.skin_colour_id = c.id\nWHERE \n    g.gender = 'Female';",
        "question": "What is the percentage of blue female superheroes among all female superheroes?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.colour = 'Blue' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.gender = 'Female'",
        "explain": "percentage = MULTIPLY(DIVIDE(SUM(colour = 'Blue' WHERE gender = 'Female'), COUNT(gender = 'Female')), 100); blue refers to the color = 'Blue' WHERE skin_colour_id = colour.id; female refers to gender = 'Female';",
        "solution": []
    },
    "505": {
        "sql": "SELECT st.translation FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE st.language = 'Chinese Simplified' AND s.name = 'Mirrodin';",
        "question": "Show the Simplified Chinese translation of the name of the set \"Mirrodin\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT code FROM sets WHERE name = 'Mirrodin' ) AND language = 'Chinese Simplified'",
        "explain": "Simplified Chinese translation refers to language = 'Chinese Simplified'; name of the set \"Mirrodin\" refers to name = 'Mirrodin'",
        "solution": []
    },
    "1064": {
        "sql": "SELECT DISTINCT t1.id, t1.player_name\nFROM Player t1\nJOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.preferred_foot = 'left';",
        "question": "List out of players whose preferred foot is left.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "explain": "preferred_foot = 'left';",
        "solution": [
            "To list out players whose preferred foot is left, follow these steps:\n\n1. **Select Distinct Players**: Retrieve unique player records to avoid duplicates.\n\n2. **Join Tables**: Combine the `Player` table (aliased as `t1`) with the `Player_Attributes` table (aliased as `t2`) using the `player_api_id` field as the common key.\n\n3. **Filter by Preferred Foot**: Apply a condition to only include players where the `preferred_foot` attribute in the `Player_Attributes` table is set to 'left'.\n\n4. **Output Specific Columns**: Display the `id` and `player_name` columns from the `Player` table for the filtered players.\n\nThis ensures you get a list of distinct players who prefer using their left foot."
        ]
    },
    "1080": {
        "sql": "SELECT COUNT(*) AS count_left_foot_players_stay_back\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.preferred_foot = 'left' AND pa.attacking_work_rate = 'low';",
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "explain": "preferred foot when attacking was the left refers to preferred_foot = 'left'; players who would remain in his position when the team attacked refers to attacking_work_rate = 'low';",
        "solution": []
    },
    "1397": {
        "sql": "SELECT AVG(spent) AS average_food_spending\nFROM budget\nWHERE category = 'Food' AND link_to_event IN (SELECT event_id FROM event WHERE status = 'Closed');",
        "question": "On average, how much did the Student_Club spend on food for the typical event in the past?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(spent) / COUNT(spent) FROM budget WHERE category = 'Food' AND event_status = 'Closed'",
        "explain": "DIVIDE(SUM(spent), COUNT(spent)) where category = 'Food'; 'event in the past' means event_status = 'Closed'",
        "solution": []
    },
    "159": {
        "sql": "SELECT t.trans_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN trans t ON a.account_id = t.account_id\nWHERE c.client_id = 3356 AND t.operation = 'VYBER';",
        "question": "List all the withdrawals in cash transactions that the client with the id 3356 makes.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.trans_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 3356 AND T4.operation = 'VYBER'",
        "explain": "operation = 'VYBER' refers to withdrawal in cash",
        "solution": [
            "To list all the withdrawals in cash transactions made by the client with the ID 3356, follow these steps:\n\n1. **Identify the client**: Start by locating the client with the ID 3356 in the `client` table (referred to as T1 in the SQL).\n\n2. **Link to the disp table**: Connect the client to their account(s) by joining the `client` table (T1) with the `disp` table (T2) using the `client_id` field. This ensures you are working with the accounts associated with the client.\n\n3. **Link to the account table**: Next, join the `disp` table (T2) with the `account` table (T3) using the `account_id` field. This step connects the client's accounts to their respective account details.\n\n4. **Link to the trans table**: Finally, join the `account` table (T3) with the `trans` table (T4) using the `account_id` field. This allows you to access all transactions linked to the client's accounts.\n\n5. **Filter transactions**: Apply a filter to the `trans` table (T4) to only include transactions where the `operation` field is 'VYBER' (which means 'withdrawal' in cash).\n\n6. **Filter by client ID**: Ensure the results are specific to the client with the ID 3356 by filtering the `client` table (T1) for `client_id = 3356`.\n\n7. **Retrieve transaction IDs**: The final output will be the `trans_id` values from the `trans` table (T4) that meet all the above criteria, representing all cash withdrawals made by the client."
        ]
    },
    "165": {
        "sql": "SELECT t.trans_id\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE d.district_id = 5;",
        "question": "Please list all the transactions made by accounts from district 5.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.trans_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T1.district_id = 5",
        "explain": "",
        "solution": [
            "To list all the transactions made by accounts from district 5, follow these steps:\n\n1. **Identify the district**: Start by locating the district with the ID 5 in the `district` table (referred to as T1 in the SQL).\n\n2. **Link accounts to the district**: Join the `account` table (T2) with the `district` table (T1) using the `district_id` field. This ensures you only consider accounts that belong to district 5.\n\n3. **Retrieve transactions for the accounts**: Join the `trans` table (T3) with the `account` table (T2) using the `account_id` field. This links each transaction to its corresponding account.\n\n4. **Filter transactions by district**: Apply a filter to include only those transactions where the `district_id` in the `district` table (T1) is equal to 5. This ensures the final list includes transactions exclusively from accounts in district 5.\n\n5. **Select transaction IDs**: Finally, extract the `trans_id` from the `trans` table (T3) for all transactions that meet the above criteria.\n\nThis process ensures that the result is a list of transaction IDs for all transactions made by accounts from district 5."
        ]
    },
    "36": {
        "sql": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.NumGE1500 DESC\nLIMIT 1;",
        "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "explain": "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500",
        "solution": [
            "1. **Joining the SAT scores and schools data:**  \n   The query uses an `INNER JOIN` between two tables: `satscores` (aliased as T1) and `schools` (aliased as T2). These tables are linked using the `CDSCode` from the `schools` table and the `cds` column from the `satscores` table. This ensures that each school's SAT score data is matched with its corresponding administrative details.\n\n2. **Selecting the relevant administrative names:**  \n   From the `schools` table (T2), the query selects the columns `AdmFName1`, `AdmLName1`, `AdmFName2`, `AdmLName2`, `AdmFName3`, and `AdmLName3`. These columns represent the full names of the administrators associated with the school.\n\n3. **Ordering by the number of high SAT scorers:**  \n   The results are ordered based on the column `NumGE1500` from the `satscores` table, which represents the number of students who scored 1500 or more on the SAT. The sorting is in descending order (`DESC`), so the school with the highest number of such students appears at the top.\n\n4. **Limiting to the top result:**  \n   The query applies a `LIMIT 1`, which restricts the output to only the first record. This ensures that only the school with the highest number of students scoring 1500 or more on the SAT is returned, along with the full names of its administrators."
        ]
    },
    "152": {
        "sql": "SELECT AVG(d.A15) AS average_crimes_1995\nFROM district d\nJOIN account a ON d.district_id = a.district_id\nWHERE d.A15 > 4000\nAND a.date >= '1997-01-01';",
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "explain": "A3 refers to region names; A15 stands for the average number of crimes commited in 1995.",
        "solution": []
    },
    "824": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Wind Control'\nORDER BY s.superhero_name ASC;",
        "question": "Identify superheroes who can control wind and list their names in alphabetical order.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Wind Control' ORDER BY T1.superhero_name",
        "explain": "superheroes refers to superhero_name; can control wind refers to power_name = 'Wind Control';",
        "solution": []
    },
    "1235": {
        "sql": "SELECT DISTINCT T1.Diagnosis, T1.ID, (strftime('%Y', 'now') - strftime('%Y', T1.Birthday)) AS Age FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5;",
        "question": "What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.Diagnosis, T1.ID , STRFTIME('%Y', CURRENT_TIMESTAMP) -STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
        "explain": "patient's diagnosis refers to Diagnosis; lower red blood cell refers to RBC < 3.5; age = SUBTRACT(year(current_timestamp), year(Birthday)); ",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct Records**: Retrieve unique records to avoid duplicates.\n\n2. **Fields to Retrieve**:\n   - `Diagnosis` from the `Patient` table (aliased as `T1`).\n   - `ID` from the `Patient` table.\n   - Calculate the age of the patient by subtracting the birth year (from the `Birthday` field in `T1`) from the current year.\n\n3. **Join Tables**:\n   - Perform an inner join between the `Patient` table (`T1`) and the `Laboratory` table (`T2`) using the `ID` field as the common key.\n\n4. **Filter Condition**:\n   - Only include records where the `RBC` (Red Blood Cell count) in the `Laboratory` table is less than 3.5.\n\nThis sequence of operations ensures that the result includes the diagnosis, ID, and age of patients with a lower red blood cell count."
        ]
    },
    "890": {
        "sql": "SELECT COUNT(DISTINCT r.year) AS seasons_hosted\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit' AND r.name = 'British Grand Prix';",
        "question": "How many seasons has Silverstone Circuit hosted the United Kindom grand prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.circuitid) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit' AND T2.name = 'British Grand Prix'",
        "explain": "British Grand Prix is the name of race; British refers to the United Kindom",
        "solution": []
    },
    "291": {
        "sql": "SELECT COUNT(*) FROM molecule WHERE label = '+';",
        "question": "How many chemical compounds in the database are identified as carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
        "explain": "label = '+' mean molecules are carcinogenic;",
        "solution": []
    },
    "410": {
        "sql": "SELECT T1.id FROM cards T1 JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper';",
        "question": "Is there any card from Erica Yang artist in pauper format and available in paper? If so, indicate its ID.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper'",
        "explain": "available in paper refers to availability = 'paper'",
        "solution": [
            "To find any card from the artist Erica Yang in the pauper format that is available in paper, follow these steps:\n\n1. **Join the tables**: Combine the `cards` table (referred to as T1) with the `legalities` table (referred to as T2) using the `uuid` field as the common key.\n\n2. **Filter by artist**: From the joined tables, select only those records where the `artist` field in the `cards` table (T1) is 'Erica Yang'.\n\n3. **Filter by format**: Further filter the records to include only those where the `format` field in the `legalities` table (T2) is 'pauper'.\n\n4. **Filter by availability**: Additionally, ensure that the `availability` field in the `cards` table (T1) is 'paper'.\n\n5. **Retrieve the ID**: Finally, extract the `id` field from the `cards` table (T1) for the records that meet all the above criteria.\n\nThis process will return the ID(s) of the card(s) that satisfy all the specified conditions."
        ]
    },
    "265": {
        "sql": "SELECT molecule_id FROM molecule WHERE label = '-';",
        "question": "List down the molecule id for non carcinogenic molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM molecule AS T WHERE T.label = '-'",
        "explain": "label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "455": {
        "sql": "SELECT name FROM cards WHERE isPromo = 1 AND otherFaceIds IS NOT NULL AND otherFaceIds != '';",
        "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "explain": "are a promotional painting refers to isPromo = 1; have multiple faces on the same card refers to side is not Null",
        "solution": []
    },
    "1312": {
        "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Angela' AND mb.last_name = 'Sanders';",
        "question": "What's Angela Sanders's major?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "explain": "Angela Sanders is the full name; full name refers to first_name, last_name; major refers to major_name.",
        "solution": []
    },
    "867": {
        "sql": "SELECT d.nationality\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE r.raceId = 933\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;",
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "explain": "fastest lap speed refers to MAX(fastestLapSpeed);",
        "solution": []
    },
    "314": {
        "sql": "SELECT COUNT(*) AS single_bond_count FROM bond WHERE bond_type = '-';",
        "question": "How many single bonds are there in the list?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '-'",
        "explain": "single bond refers to bond_type = '-';",
        "solution": []
    },
    "213": {
        "sql": "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR004_8' AND c.atom_id2 = 'TR004_20') OR (c.atom_id = 'TR004_20' AND c.atom_id2 = 'TR004_8');",
        "question": "What type of bond is there between the atoms TR004_8 and TR004_20?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20'",
        "explain": "type of bond refers to bond_type; between the atoms TR004_8 and TR004_20 refers to atom_id = 'TR004_8' AND atom_id2 = 'TR004_20' OR another way around",
        "solution": []
    },
    "206": {
        "sql": "SELECT a.element \nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_id = 'TR004_8_9';\n",
        "question": "What elements are in the TR004_8_9 bond atoms?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'",
        "explain": "TR004_8_9 bond atoms refers to bond_id = 'TR004_8_9';",
        "solution": []
    },
    "51": {
        "sql": "SELECT T2.MailStreet, T2.School\nFROM satscores T1\nJOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;",
        "question": "In which mailing street address can you find the school that has the lowest average score in reading? Also give the school's name.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "explain": "",
        "solution": [
            "To find the mailing street address and the name of the school with the lowest average score in reading, follow these steps:\n\n1. **Join the Tables**: Combine the `satscores` table (aliased as `T1`) and the `schools` table (aliased as `T2`) using the common field `cds` from `T1` and `CDSCode` from `T2`.\n\n2. **Filter Valid Scores**: Ensure that only records with a non-null average reading score (`AvgScrRead`) are considered.\n\n3. **Sort by Reading Score**: Arrange the filtered records in ascending order based on the `AvgScrRead` column to prioritize the lowest scores.\n\n4. **Retrieve the Top Result**: Select the first record from the sorted list, which will have the lowest average reading score.\n\n5. **Extract Required Information**: From this record, retrieve the `MailStreet` (mailing street address) and `School` (school name) fields.\n\nThis process ensures you get the school's mailing street address and name with the lowest average reading score."
        ]
    },
    "1297": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nJOIN Examination T3 ON T1.ID = T3.ID \nWHERE T2.\"T-CHO\" >= 250 AND T3.KCT = '-'",
        "question": "For the patients whose total cholesterol is higher than normal, how many of them have a negative measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-CHO` >= 250 AND T3.KCT = '-'",
        "explain": "total cholesterol is higher than normal refers to `T-CHO` > = 250; negative measure of degree of coagulation refers to KCT = '-' ;",
        "solution": [
            "To solve the question, we need to perform the following operations:\n\n1. **Identify Patients with High Cholesterol**: Filter the `Patient` table to include only those patients whose total cholesterol (`T-CHO`) is 250 or higher. This is done by joining the `Patient` table with the `Laboratory` table where the `T-CHO` value is >= 250.\n\n2. **Check for Negative Coagulation Measure**: For the patients identified in step 1, further filter them to include only those who have a negative measure of degree of coagulation (`KCT` is '-'). This is done by joining the result with the `Examination` table where the `KCT` value is '-'.\n\n3. **Count the Patients**: Finally, count the number of patients who meet both criteria (high cholesterol and negative coagulation measure).\n\nThe SQL query accomplishes this by:\n- Joining the `Patient` table (`T1`) with the `Laboratory` table (`T2`) on the patient ID.\n- Further joining the result with the `Examination` table (`T3`) on the patient ID.\n- Applying the conditions `T2.\"T-CHO\" >= 250` (high cholesterol) and `T3.KCT = '-'` (negative coagulation measure).\n- Counting the number of such patients (`COUNT(T1.ID)`).",
            "To solve the question, we need to perform the following operations:\n\n1. **Identify Patients with High Cholesterol**: Filter the `Patient` table to include only those patients whose total cholesterol (`T-CHO`) is 250 or higher. This is done by joining the `Patient` table with the `Laboratory` table where the `T-CHO` value is >= 250.\n\n2. **Check for Negative Coagulation Measure**: For the patients identified in step 1, further filter them to include only those who have a negative measure of degree of coagulation (`KCT` is '-'). This is done by joining the result with the `Examination` table where the `KCT` value is '-'.\n\n3. **Count the Patients**: Finally, count the number of patients who meet both criteria (high cholesterol and negative coagulation measure).\n\nThe SQL query accomplishes this by:\n- Joining the `Patient` table (`T1`) with the `Laboratory` table (`T2`) on the patient ID.\n- Further joining the result with the `Examination` table (`T3`) on the patient ID.\n- Applying the conditions `T2.\"T-CHO\" >= 250` (high cholesterol) and `T3.KCT = '-'` (negative coagulation measure).\n- Counting the number of such patients (`COUNT(T1.ID)`)."
        ]
    },
    "1346": {
        "sql": "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs';",
        "question": "Tell the phone number of \"Carlo Jacobs\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs'",
        "explain": "Carlo Jacobs is the full name; full name refers to first_name, last_name;",
        "solution": []
    },
    "1501": {
        "sql": "SELECT DISTINCT T2.Country\nFROM transactions_1k T1\nJOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nJOIN yearmonth T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Date = '201306';",
        "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Date = '201306'",
        "explain": "June 2013 refers to '201306'; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month;",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join the tables**: The `transactions_1k` table (aliased as `T1`) is joined with the `gasstations` table (aliased as `T2`) using the `GasStationID` field to link them. This ensures that each transaction is associated with its corresponding gas station.\n\n2. **Further join with the `yearmonth` table**: The result from the first join is then joined with the `yearmonth` table (aliased as `T3`) using the `CustomerID` field. This links each transaction to its corresponding date in the `yearmonth` table.\n\n3. **Filter for June 2013**: The `WHERE` clause filters the results to include only those records where the `Date` field in the `yearmonth` table is '201306', representing June 2013.\n\n4. **Select distinct countries**: The `SELECT DISTINCT` statement retrieves only the unique values from the `Country` field in the `gasstations` table (`T2.Country`), ensuring no duplicates are included in the final output.\n\nThis sequence of operations ensures that the query lists all unique countries where gas stations had transactions in June 2013."
        ]
    },
    "1035": {
        "sql": "SELECT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60;",
        "question": "Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60",
        "explain": "teams with more than 50 but less than 60 build-up play speed refers to buildUpPlaySpeed >50 AND buildUpPlaySpeed <60; ",
        "solution": []
    },
    "802": {
        "sql": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;",
        "question": "Who is the tallest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "explain": "who refers to superhero_name; tallest superhero refers to MAX(height_cm);",
        "solution": [
            "To find the tallest superhero, retrieve the name of the superhero from the 'superhero' table. The superheroes should be ordered by their height in descending order (from tallest to shortest), and then limit the result to only the first entry, which will be the tallest superhero."
        ]
    },
    "892": {
        "sql": "SELECT d.forename, d.surname, ds.points\nFROM driverStandings ds\nJOIN drivers d ON ds.driverId = d.driverId\nORDER BY ds.points DESC\nLIMIT 1;",
        "question": "State the driver with the most points scored. Find his full name with that points.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
        "explain": "the most points scored refers to max(points); Full name of the driver refers to drivers.forename and drivers.surname;",
        "solution": [
            "To find the driver with the most points scored, follow these steps:\n\n1. **Join the tables**: Combine the `races` table (referred to as T1), the `driverStandings` table (referred to as T2), and the `drivers` table (referred to as T3).\n   - Link T1 and T2 using the `raceId` field.\n   - Link T2 and T3 using the `driverId` field.\n\n2. **Sort the results**: Order the combined data by the `points` column from the `driverStandings` table (T2) in descending order. This ensures the driver with the highest points appears first.\n\n3. **Limit the output**: Retrieve only the top result (the driver with the highest points) by applying a limit of 1.\n\n4. **Select the required fields**: Display the `forename` and `surname` from the `drivers` table (T3) and the `points` from the `driverStandings` table (T2) for the top driver."
        ]
    },
    "489": {
        "sql": "SELECT keyruneCode FROM sets WHERE code = 'PKHC';",
        "question": "List the keyrune code for the set whose code is 'PKHC'.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT keyruneCode FROM sets WHERE code = 'PKHC'",
        "explain": "keyrune code refers to keyruneCode",
        "solution": []
    },
    "280": {
        "sql": "SELECT b.bond_id, m.label AS carcinogenic_status\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '#';",
        "question": "Enumerate the bond ID of triple bond type molecules and tell me if they are carcinogenic or not.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.bond_id, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "explain": "triple bond refers to bond_type = '#'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "1200": {
        "sql": "SELECT \n    (COUNT(DISTINCT CASE WHEN e.Diagnosis = 'SLE' THEN e.ID END) * 100.0 / COUNT(DISTINCT e.ID)) AS proportion\nFROM \n    Examination e\nWHERE \n    e.Symptoms LIKE '%thrombocytopenia%';",
        "question": "What proportion of patients who had signs of thrombocytopenia had SLE diagnosed?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Examination WHERE Symptoms = 'thrombocytopenia'",
        "explain": "thrombocytopenia' refers to symptoms; 'SLE' refers to diagnosis; calculation =  DIVIDE(SUM(DIAGNOSIS LIKE '%ITP%'), SUM(DIAGNOSIS LIKE '%SLE%')) MULTIPLY 100",
        "solution": [
            "To determine the proportion of patients who had signs of thrombocytopenia and were diagnosed with SLE, follow these steps:\n\n1. **Filter the Data**: Identify all records in the `Examination` table where the `Symptoms` column indicates 'thrombocytopenia'.\n\n2. **Count Total Patients**: Calculate the total number of patients in this filtered dataset by counting the unique `ID` values.\n\n3. **Count SLE Diagnoses**: Within the same filtered dataset, count how many patients have a `Diagnosis` of 'SLE'.\n\n4. **Calculate Proportion**: Divide the number of SLE diagnoses by the total number of patients with thrombocytopenia, then multiply by 100 to convert the result into a percentage.\n\nThis will give you the proportion of patients with thrombocytopenia who were diagnosed with SLE, expressed as a percentage."
        ]
    },
    "27": {
        "sql": "SELECT T2.School, T1.AvgScrWrite, T2.Phone\nFROM schools T2\nLEFT JOIN satscores T1 ON T2.CDSCode = T1.cds\nWHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000';\n",
        "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
        "explain": "Communication number refers to phone number.",
        "solution": [
            "1. **Joining the schools and SAT scores data:**  \n   The query uses a `LEFT JOIN` between two tables: `schools` (aliased as T2) and `satscores` (aliased as T1). These tables are linked using the `CDSCode` from the `schools` table and the `cds` column from the `satscores` table. This ensures that each school record is matched with its corresponding SAT score data, if available.\n\n2. **Filtering schools based on opening and closing dates:**  \n   The query filters the schools based on two conditions:  \n   - Schools that were opened after 1991, determined by the `OpenDate` column in the `schools` table. The year is extracted using `strftime('%Y', T2.OpenDate)` and compared to '1991'.  \n   - Schools that were closed before 2000, determined by the `ClosedDate` column in the `schools` table. The year is extracted using `strftime('%Y', T2.ClosedDate)` and compared to '2000'.  \n   The conditions are combined with an `OR` operator, meaning a school will be included if either condition is met.\n\n3. **Selecting the relevant data:**  \n   From the `schools` table (T2), the query selects the `School` column (the name of the school) and the `Phone` column (the communication number of the school). From the `satscores` table (T1), the query selects the `AvgScrWrite` column (the average writing score).\n\n4. **Outputting the results:**  \n   The query returns the school names, their average writing scores, and their communication numbers (if available) for all schools that meet the specified date criteria."
        ]
    },
    "1383": {
        "sql": "SELECT m.first_name, m.last_name\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE z.city = 'Georgetown' AND z.state = 'South Carolina';",
        "question": "State the name of students from Georgetown, South Carolina.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Georgetown' AND T2.state = 'South Carolina'",
        "explain": "name of students means the full name; full name refers to first_name, last_name; Georgetown is a city; South Carolina is a state",
        "solution": []
    },
    "1316": {
        "sql": "SELECT m.phone\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = \"Women's Soccer\";",
        "question": "Please list the phone numbers of the students from the Student_Club that has attended the event \"Women's Soccer\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.phone FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer'",
        "explain": "Women's Soccer is an event name; phone numbers refers to phone",
        "solution": []
    },
    "437": {
        "sql": "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1;",
        "question": "Among black card borders, which card has full artwork?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1",
        "explain": "white card borders refers to borderColor = 'white'; has full artwork refers to isFullArt = 1",
        "solution": [
            "To find the card with a black border that has full artwork, the database performs the following operations:\n1. It searches the 'cards' table for entries where the 'borderColor' is set to 'black'.\n2. From these entries, it further filters to include only those where the 'isFullArt' field is equal to 1 (indicating full artwork).\n3. Finally, it retrieves the 'id' of the card(s) that meet both criteria."
        ]
    },
    "1017": {
        "sql": "SELECT c.lat, c.lng FROM lapTimes lt JOIN races r ON lt.raceId = r.raceId JOIN circuits c ON r.circuitId = c.circuitId WHERE lt.time = '1:29.488';",
        "error": "something went wrong, tool did not call.",
        "question": "Please list the location coordinates of the circuits whose lap record is 1:29.488.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.lat, T3.lng FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T1.time = '1:29.488'",
        "explain": "lap records means the fastest time recorded which refers to time; coordinates are expressed as latitude and longitude which refers to (lat, lng)",
        "solution": [
            "To list the location coordinates (latitude and longitude) of the circuits where the lap record is 1:29.488, follow these steps:\n\n1. **Join the `lapTimes` table (T1) with the `races` table (T2)** using the `raceId` field to link the lap times to the corresponding races.\n2. **Join the result with the `circuits` table (T3)** using the `circuitId` field from the `races` table to link the races to their respective circuits.\n3. **Filter the records** to only include those where the lap time (`time` field in the `lapTimes` table) is exactly '1:29.488'.\n4. **Retrieve the latitude (`lat`) and longitude (`lng`)** from the `circuits` table for the filtered records.\n\nThis process ensures that you get the coordinates of the circuits where the specified lap record was achieved."
        ]
    },
    "919": {
        "sql": "SELECT c.name AS circuit_name FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2009 AND r.name = 'Spanish Grand Prix';",
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "explain": "",
        "solution": []
    },
    "692": {
        "sql": "SELECT badges.Name, badges.Date, users.CreationDate, julianday(badges.Date) - julianday(users.CreationDate) AS days_to_badge\nFROM badges\nJOIN users ON badges.UserId = users.Id\nWHERE users.DisplayName = 'Zolomon';\n",
        "question": "How long did it take the user, known by his or her display name 'Zolomon' to get the badge? Count from the date the user's account was created.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.Date - T2.CreationDate FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'",
        "explain": "SUBTRACT(Date from stats_badges, CreationDate) where DisplayName = 'Zolomon';",
        "solution": [
            "To determine how long it took the user with the display name 'Zolomon' to earn a badge, measured from the date the user's account was created, follow these steps:\n\n1. **Retrieve the user's account creation date**: From the `users` table, find the `CreationDate` for the user whose `DisplayName` is 'Zolomon'.\n\n2. **Retrieve the badge date**: From the `badges` table, find the `Date` when the badge was awarded to the same user. This is done by matching the `UserId` in the `badges` table with the `Id` of the user in the `users` table.\n\n3. **Calculate the time difference**: Subtract the `CreationDate` from the `Date` of the badge to determine the duration between the account creation and the badge award.\n\nThe result will be the time taken for the user 'Zolomon' to earn the badge after account creation.",
            "To determine how long it took the user with the display name 'Zolomon' to earn a badge, measured from the date the user's account was created, follow these detailed steps:\n\n1. **Identify the user 'Zolomon' in the `users` table**: Locate the row in the `users` table where the `DisplayName` column matches 'Zolomon'. This row contains the user's unique identifier (`Id`) and the account creation date (`CreationDate`).\n\n2. **Retrieve the badge award date for 'Zolomon'**: In the `badges` table, find all rows where the `UserId` column matches the `Id` of 'Zolomon' obtained from the `users` table. Each of these rows represents a badge awarded to 'Zolomon', and the `Date` column in these rows indicates when the badge was awarded.\n\n3. **Calculate the time difference for each badge**: For each badge awarded to 'Zolomon', subtract the `CreationDate` (from the `users` table) from the `Date` (from the `badges` table). This calculation yields the duration between the account creation and the badge award.\n\n4. **Return the results**: The final output is a list of time differences, each representing how long it took 'Zolomon' to earn a specific badge after account creation.\n\nThe SQL query accomplishes this by joining the `badges` and `users` tables on the `UserId` and `Id` columns, filtering for 'Zolomon' using the `DisplayName` condition, and computing the difference between the `Date` and `CreationDate` columns."
        ]
    },
    "755": {
        "sql": "SELECT s.full_name\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Demi-God'\nLIMIT 5;",
        "question": "List down at least five full name of Demi-God superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Demi-God'",
        "explain": "Demi-God superheroes refers to race = 'Demi-God'",
        "solution": []
    },
    "1425": {
        "sql": "SELECT COUNT(*) FROM major WHERE college = 'College of Agriculture and Applied Sciences' AND department = 'School of Applied Sciences, Technology and Education';",
        "question": "In the College of Agriculture and Applied Sciences, how many majors are under the department of School of Applied Sciences, Technology and Education?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(major_id) FROM major WHERE department = 'School of Applied Sciences, Technology and Education' AND college = 'College of Agriculture and Applied Sciences'",
        "explain": "",
        "solution": []
    },
    "174": {
        "sql": "SELECT STRFTIME('%Y', T1.birth_date) AS birth_year\nFROM client T1\nJOIN disp T3 ON T1.client_id = T3.client_id\nJOIN account T2 ON T3.account_id = T2.account_id\nWHERE T2.account_id = 130;",
        "question": "What year was account owner number 130 born?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', T1.birth_date) FROM client AS T1 INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T2 ON T3.account_id = T2.account_id WHERE T2.account_id = 130",
        "explain": "",
        "solution": [
            "To find the year the account owner number 130 was born, follow these steps:\n\n1. **Join the Tables**: Combine the `client`, `disp`, and `account` tables to link the account owner's information with their account details.\n   - Join the `client` table (`T1`) with the `disp` table (`T3`) using the `client_id` field.\n   - Then, join the result with the `account` table (`T2`) using the `account_id` field.\n\n2. **Filter the Account**: Narrow down the results to only include the account with the `account_id` equal to 130.\n\n3. **Extract the Birth Year**: From the filtered result, extract the year from the `birth_date` field of the `client` table (`T1`) using the `STRFTIME` function with the format `%Y` to get the year.\n\nThe final output will be the birth year of the account owner associated with account number 130."
        ]
    },
    "1082": {
        "sql": "SELECT l.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE c.name = 'Germany';",
        "question": "Please list the leagues from Germany.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Germany'",
        "explain": "Germany refers to Country.name = 'Germany';",
        "solution": []
    },
    "1497": {
        "sql": "SELECT T1.CustomerID\nFROM customers T1\nJOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201206' AND T1.Segment = 'SME'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;",
        "question": "Which SME customer consumed the least in June 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "explain": "June 2012 refers to yearmonth.date = '201206'",
        "solution": [
            "To find the SME customer who consumed the least in June 2012, follow these steps:\n\n1. **Join the Tables**: Combine the `customers` table (referred to as `T1`) with the `yearmonth` table (referred to as `T2`) using the `CustomerID` field to link them.\n\n2. **Filter the Data**:\n   - From the `yearmonth` table (`T2`), select only the records where the `Date` is '201206' (June 2012).\n   - From the `customers` table (`T1`), select only the records where the `Segment` is 'SME'.\n\n3. **Group the Results**: Group the combined data by `CustomerID` to aggregate the consumption for each customer.\n\n4. **Calculate Total Consumption**: For each customer, calculate the sum of their consumption from the `yearmonth` table.\n\n5. **Sort the Results**: Order the grouped results by the total consumption in ascending order to find the customer with the least consumption.\n\n6. **Retrieve the Result**: Limit the output to the first record, which will be the SME customer with the least consumption in June 2012.\n\nThe final output will be the `CustomerID` of this customer."
        ]
    },
    "1128": {
        "sql": "SELECT t1.name\nFROM Country t1\nJOIN Match t2 ON t1.id = t2.country_id\nJOIN Player t3 ON t2.home_player_1 = t3.player_api_id\nGROUP BY t1.name\nORDER BY AVG(t3.weight) DESC\nLIMIT 1;",
        "question": "Which country's players have the heaviest average weights?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id GROUP BY t1.name ORDER BY AVG(t3.weight) DESC LIMIT 1",
        "explain": "heaviest average weights refers to MAX(AVG(weight))",
        "solution": [
            "To determine which country's players have the heaviest average weights, follow these steps:\n\n1. **Join the Tables**: Combine the `Country` table (aliased as `t1`), the `Match` table (aliased as `t2`), and the `Player` table (aliased as `t3`). The join conditions are:\n   - `t1.id` (Country ID) matches `t2.country_id` (Country ID in the Match table).\n   - `t2.home_player_1` (Player ID in the Match table) matches `t3.player_api_id` (Player ID in the Player table).\n\n2. **Group by Country**: Group the results by the `name` column from the `Country` table (`t1.name`).\n\n3. **Calculate Average Weight**: For each country, calculate the average weight of the players using the `AVG(t3.weight)` function.\n\n4. **Order by Average Weight**: Sort the grouped results in descending order based on the calculated average weight.\n\n5. **Limit Results**: Retrieve only the top result (the country with the highest average player weight) using `LIMIT 1`.\n\nThe final output will be the name of the country whose players have the heaviest average weights.",
            "To determine which country's players have the heaviest average weights, follow these steps:\n\n1. **Select the Country Name**: Retrieve the `name` column from the `Country` table (aliased as `t1`).\n\n2. **Join the Country and Match Tables**: Perform an inner join between the `Country` table (`t1`) and the `Match` table (aliased as `t2`) using the condition `t1.id = t2.country_id`. This links each country to its matches.\n\n3. **Join the Match and Player Tables**: Perform another inner join between the `Match` table (`t2`) and the `Player` table (aliased as `t3`) using the condition `t2.home_player_1 = t3.player_api_id`. This links each match to the player involved.\n\n4. **Group by Country Name**: Group the results by the `name` column from the `Country` table (`t1.name`) to aggregate data by country.\n\n5. **Calculate Average Weight**: For each country, compute the average weight of the players using the `AVG(t3.weight)` function.\n\n6. **Order by Average Weight**: Sort the grouped results in descending order based on the calculated average weight to prioritize countries with heavier players.\n\n7. **Limit Results**: Retrieve only the top result (the country with the highest average player weight) using `LIMIT 1`.\n\nThe final output will be the name of the country whose players have the heaviest average weights."
        ]
    },
    "1201": {
        "sql": "WITH FilteredPatients AS (\n    SELECT ID, SEX\n    FROM Patient\n    WHERE Diagnosis = 'RA' AND strftime('%Y', Birthday) = '1980'\n),\nTotalPatients AS (\n    SELECT COUNT(*) AS Total\n    FROM FilteredPatients\n),\nFemalePatients AS (\n    SELECT COUNT(*) AS FemaleCount\n    FROM FilteredPatients\n    WHERE SEX = 'F'\n)\nSELECT (FemaleCount * 100.0 / Total) AS PercentageFemale\nFROM FemalePatients, TotalPatients;",
        "question": "What percentage of patients who were born in 1980 and were diagnosed with RA are women?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE Diagnosis = 'RA' AND STRFTIME('%Y', Birthday) = '1980'",
        "explain": "born in 1980 refers to YEAR(BIRTHDAY) = '1980'; 'RA' refers to Diagnosis='RA' ; women refers to SEX = 'F'; calculation = DIVIDE(SUM(SEX = 'F'), COUNT(SEX)) * 100",
        "solution": [
            "To determine the percentage of female patients born in 1980 who were diagnosed with RA, follow these steps:\n\n1. **Filter the Patients**: Select all patients from the database who meet the following criteria:\n   - Their diagnosis is 'RA'.\n   - Their birth year is 1980 (extracted from the 'Birthday' field).\n\n2. **Count Total Patients**: Calculate the total number of patients who meet the above criteria.\n\n3. **Count Female Patients**: From the filtered list, count how many patients are female (where 'SEX' is 'F').\n\n4. **Calculate Percentage**: Divide the number of female patients by the total number of patients and multiply by 100 to get the percentage.\n\nThe result will be the percentage of female patients among those born in 1980 and diagnosed with RA."
        ]
    },
    "1255": {
        "sql": "SELECT T1.Diagnosis, COUNT(*) AS DiagnosisCount\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGM NOT BETWEEN 40 AND 400\nGROUP BY T1.Diagnosis\nORDER BY DiagnosisCount DESC\nLIMIT 1;",
        "question": "For the patients with an abnormal Ig M level, what is the most common disease they are diagnosed with?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGM NOT BETWEEN 40 AND 400 GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1",
        "explain": "abnormal Ig M level refers to IGM <=40 OR IGM >= 400; most common disease refers to MAX(COUNT(Diagnosis));",
        "solution": [
            "To find the most common disease diagnosed among patients with an abnormal IgM level, follow these steps:\n\n1. **Identify Patients with Abnormal IgM Levels**: Filter the `Laboratory` table to include only those records where the `IGM` value is not within the normal range (i.e., not between 40 and 400).\n\n2. **Join with Patient Data**: Link these filtered laboratory records with the corresponding patient records in the `Patient` table using the `ID` field as the common key.\n\n3. **Group by Diagnosis**: Group the resulting records by the `Diagnosis` field from the `Patient` table to categorize patients based on their diagnosed diseases.\n\n4. **Count Diagnoses**: For each diagnosis group, count the number of patients to determine how many patients have each disease.\n\n5. **Sort by Count**: Order the grouped results by the count of diagnoses in descending order to prioritize the most frequently occurring diseases.\n\n6. **Select the Most Common Disease**: Retrieve the top result (i.e., the diagnosis with the highest count) to identify the most common disease among patients with abnormal IgM levels.",
            "To determine the most common disease diagnosed among patients with an abnormal IgM level, the following steps are executed in the SQL query:\n\n1. **Filter Abnormal IgM Levels**: The query starts by filtering records in the `Laboratory` table (aliased as `T2`) to include only those where the `IGM` value is outside the normal range (i.e., not between 40 and 400).\n\n2. **Join with Patient Data**: The filtered laboratory records are then joined with the `Patient` table (aliased as `T1`) using the `ID` field as the common key. This ensures that only patients with abnormal IgM levels are considered.\n\n3. **Group by Diagnosis**: The joined records are grouped by the `Diagnosis` field from the `Patient` table. This groups patients based on their diagnosed diseases.\n\n4. **Count Diagnoses**: For each diagnosis group, the query counts the number of patients to determine the frequency of each disease among the filtered patients.\n\n5. **Sort by Count**: The grouped results are ordered by the count of diagnoses in descending order. This places the most frequently occurring diseases at the top of the list.\n\n6. **Retrieve the Most Common Disease**: The query limits the result to the top entry (using `LIMIT 1`), which corresponds to the diagnosis with the highest count, thereby identifying the most common disease among patients with abnormal IgM levels.\n\nThe final output is the `Diagnosis` field from the `Patient` table for the most common disease."
        ]
    },
    "332": {
        "sql": "SELECT COUNT(DISTINCT molecule_id) \nFROM bond \nWHERE bond_type = '-' \nAND molecule_id BETWEEN 'TR004' AND 'TR010';",
        "question": "Among the molecules between TR004 to TR010, how many of them has single bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.molecule_id BETWEEN 'TR004' AND 'TR010' AND T.bond_type = '-'",
        "explain": "single bond refers to bond_type = '-'; molecules between TR004 to TR010 refers molecule_id BETWEEN 'TR004' and 'TR010';",
        "solution": []
    },
    "417": {
        "sql": "SELECT (SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM sets T1\nJOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.type = 'expansion';",
        "question": "What percentage of Japanese translated sets are expansion sets?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.type = 'expansion'",
        "explain": "Japanese translated refers to language = 'Japanese'; expansion sets refers to type = 'expansion'; percentage = DIVIDE(COUNT(language = 'Japanese'),COUNT(language))*100",
        "solution": [
            "To determine the percentage of Japanese translated sets that are expansion sets, follow these steps:\n\n1. **Join the tables**: Combine the `sets` table (referred to as `T1`) with the `set_translations` table (referred to as `T2`) using the condition `T1.code = T2.setCode`. This links each set to its translations.\n\n2. **Filter for expansion sets**: From the joined tables, filter the records to include only those where the `type` column in the `sets` table (`T1.type`) is 'expansion'. This ensures we are only considering expansion sets.\n\n3. **Count total expansion sets**: Calculate the total number of expansion sets by counting the number of records in the filtered result (using `COUNT(T1.id)`).\n\n4. **Count Japanese translations**: For each record in the filtered result, check if the `language` column in the `set_translations` table (`T2.language`) is 'Japanese'. Sum the number of such records (using `SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END)`).\n\n5. **Calculate the percentage**: Divide the count of Japanese translations by the total count of expansion sets, multiply by 100, and cast the result to a real number to get the percentage. The formula is `(Japanese translations count / total expansion sets count) * 100`.\n\nThis process ensures that the percentage accurately reflects the proportion of Japanese translated sets among all expansion sets."
        ]
    },
    "471": {
        "sql": "SELECT s.type \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Hauptset Zehnte Edition';",
        "question": "What is the expansion type of the set \"Hauptset Zehnte Edition\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "explain": "card set \"Hauptset Zehnte Edition\" refers to translation = ' Hauptset Zehnte Edition'; expansion type refers to type",
        "solution": []
    },
    "423": {
        "sql": "SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId ASC LIMIT 3;",
        "question": "Please provide the ids of top three powerful pairs of Kingdom Foil and Kingdom Cards sorted by Kingdom Foil id in alphabetical order.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId LIMIT 3",
        "explain": "poweful refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
        "solution": [
            "To solve the question, the database performs the following operations:\n1. It selects the columns `cardKingdomFoilId` and `cardKingdomId` from the table `cards`.\n2. It filters the rows where both `cardKingdomFoilId` and `cardKingdomId` are not NULL.\n3. It sorts the resulting rows by the `cardKingdomFoilId` column in alphabetical (ascending) order.\n4. It limits the output to the top 3 rows from the sorted result.\n\nThis ensures that the ids of the top three powerful pairs of Kingdom Foil and Kingdom Cards are provided, sorted by Kingdom Foil id in alphabetical order."
        ]
    },
    "768": {
        "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Dark Horse Comics');",
        "question": "How many superheroes were published by Dark Horse Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Dark Horse Comics'",
        "explain": "published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "solution": []
    },
    "401": {
        "sql": "SELECT \n    (COUNT(CASE WHEN isOnlineOnly = 1 AND frameEffects = 'legendary' THEN 1 END) * 100.0 / \n    COUNT(CASE WHEN frameEffects = 'legendary' THEN 1 END)) AS percentage\nFROM \n    cards\nWHERE \n    frameEffects = 'legendary';",
        "question": "What percentage of legendary frame effect cards that are only available in online game variations?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN isOnlineOnly = 1 THEN 1.0 ELSE 0 END) / COUNT(id) * 100 FROM cards WHERE frameEffects = 'legendary'",
        "explain": "only available in online game variationsrefer to isOnlineOnly =1 ; legendary frame effect cards refer to frameEffects = 'legendary'; percentage refer to DIVIDE(COUNT(isOnlineOnly=1), COUNT(id)) from cards where frameEffects = 'legendary'",
        "solution": []
    },
    "993": {
        "sql": "SELECT location, country, lat, lng FROM circuits WHERE name = 'Hungaroring';",
        "question": "In which location does the Hungaroring circuit located? Also, find the country and coordinates of this circuit?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring'",
        "explain": "coordinates expressed in latitude and longitude refers to (lat, lng)",
        "solution": [
            "To find the country and coordinates of the Hungaroring circuit, perform the following steps:\n1. Query the 'circuits' table.\n2. Filter the records to only include the circuit with the name 'Hungaroring'.\n3. Retrieve the 'country', 'lat' (latitude), and 'lng' (longitude) columns from the filtered record.",
            "To find the country and coordinates of the Hungaroring circuit, follow these detailed steps:\n1. Access the 'circuits' table in the database.\n2. Search for the record where the 'name' column exactly matches the string 'Hungaroring'.\n3. From the matching record, extract the values of the 'country', 'lat' (latitude), and 'lng' (longitude) columns.\n4. Return these extracted values as the result of the query."
        ]
    },
    "855": {
        "sql": "SELECT DISTINCT T1.url FROM circuits T1 INNER JOIN races T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Sepang International Circuit';",
        "question": "Where can I find the information about the races held on Sepang International Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "explain": "information about races refers to url;",
        "solution": [
            "To find the information about the races held on the Sepang International Circuit, follow these steps:\n\n1. **Identify the Circuit**: First, locate the circuit named 'Sepang International Circuit' in the `circuits` table. This table contains details about various racing circuits.\n\n2. **Join with Races Table**: Next, join the `circuits` table with the `races` table using the `circuitID` field. This links the circuit to all the races that have been held there.\n\n3. **Retrieve URLs**: From the joined tables, select the distinct URLs (`url` field) associated with the races held at the Sepang International Circuit. These URLs will provide the information about the races.\n\n4. **Filter by Circuit Name**: Ensure the query only includes races where the circuit name is 'Sepang International Circuit' to focus on the relevant data.\n\nThis process will return the URLs where you can find detailed information about the races held at the Sepang International Circuit.",
            "To find the information about the races held on the Sepang International Circuit, follow these detailed steps:\n\n1. **Identify the Circuit**: Query the `circuits` table to locate the circuit named 'Sepang International Circuit'. This table contains details about various racing circuits, including the `circuitId` which uniquely identifies each circuit.\n\n2. **Join with Races Table**: Perform an inner join between the `circuits` table (aliased as `T1`) and the `races` table (aliased as `T2`) using the `circuitId` field. This join ensures that only races associated with the Sepang International Circuit are considered.\n\n3. **Retrieve URLs**: From the joined tables, select the distinct URLs (`url` field) from the `circuits` table (`T1.url`). These URLs provide direct links to detailed information about the races.\n\n4. **Filter by Circuit Name**: Apply a filter to the query to include only records where the `name` field in the `circuits` table (`T1.name`) matches 'Sepang International Circuit'. This ensures the results are specific to the requested circuit.\n\nThe final SQL query combines these steps to return the distinct URLs of all races held at the Sepang International Circuit."
        ]
    },
    "1056": {
        "sql": "SELECT l.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE c.name = 'Netherlands';",
        "question": "What is the name of the football league in the country of Netherlands?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Netherlands'",
        "explain": "name of the football league refers to League.name;",
        "solution": []
    },
    "113": {
        "sql": "SELECT c.birth_date\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.amount = 98832 AND l.date = '1996-01-03';",
        "question": "For the client who applied 98832 USD loan in 1996/1/3, when was his/her birthday?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.birth_date FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T1.date = '1996-01-03' AND T1.amount = 98832",
        "explain": "",
        "solution": []
    },
    "69": {
        "sql": "SELECT NCESDist FROM schools WHERE SOC IS NOT NULL AND SOCType = 'State Special Schools';",
        "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT NCESDist FROM schools WHERE SOC = 31",
        "explain": "State Special Schools means that SOC = 31.",
        "solution": []
    },
    "526": {
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'Matthew D. Wilson' \nAND availability = 'paper';",
        "question": "Among the card designed by Matthew D. Wilson, how many are available only in the paper?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper'",
        "explain": "card designed by Matthew D. Wilson refers to artist = 'Matthew D. Wilson'; available only in the paper refers to availability = 'paper'",
        "solution": []
    },
    "1154": {
        "sql": "SELECT p.SEX, p.Birthday, e.\"Examination Date\", e.Symptoms\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.ID = 163109;",
        "question": "State the sex and birthday of patient ID '163109'. When was the examination taken and what symptom does the patient had.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.SEX, T1.Birthday, T2.`Examination Date`, T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = 163109",
        "explain": "When was the examination taken refers to `Examination Date`",
        "solution": []
    },
    "29": {
        "sql": "SELECT s.OpenDate\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nORDER BY f.[Enrollment (K-12)] DESC\nLIMIT 1;",
        "question": "When did the first-through-twelfth-grade school with the largest enrollment open?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.OpenDate FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "explain": "K-12 means First-through-twelfth-grade",
        "solution": []
    },
    "500": {
        "sql": "SELECT T2.translation\nFROM cards T1\nJOIN set_translations T2 ON T1.setCode = T2.setCode\nWHERE T1.name = 'Fellwar Stone'\nAND T2.language = 'Japanese'\nAND T2.translation IS NOT NULL;",
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "explain": "Japanese name refers to language = 'Japanese'; card \"Fellwar Stone\" refers to name = 'Fellwar Stone'",
        "solution": [
            "To find the Japanese name of the set containing the card \"Fellwar Stone\", follow these steps:\n1. **Join the tables**: Combine the `cards` table (referred to as `T1`) with the `set_translations` table (referred to as `T2`) using the `setCode` field as the common key.\n2. **Filter the card**: From the `cards` table (`T1`), select the row where the `name` field is \"Fellwar Stone\".\n3. **Filter the translation**: From the `set_translations` table (`T2`), ensure the `language` field is \"Japanese\" and the `translation` field is not null.\n4. **Retrieve the result**: Extract the `translation` field from the `set_translations` table (`T2`), which will give the Japanese name of the set containing the card \"Fellwar Stone\"."
        ]
    },
    "648": {
        "sql": "SELECT u.DisplayName, u.WebsiteUrl \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE p.FavoriteCount > 150;",
        "question": "Provide the users' display names and available website URLs of the post with favorite count of more than 150.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName, T1.WebsiteUrl FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.FavoriteCount > 150",
        "explain": "favorite count of more than 150 refers to FavoriteCount > 150;",
        "solution": []
    },
    "306": {
        "sql": "SELECT DISTINCT T1.molecule_id, T2.element\nFROM bond T1\nJOIN atom T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#';",
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "explain": "triple bond refers to bond_type = '#'; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "solution": [
            "To solve the question, \"Which molecules have triple bonds and list all the elements they contain,\" the following steps are performed:\n\n1. **Filter Bonds**: Identify all bonds in the database where the bond type is a triple bond (represented by the symbol '#'). This is done by querying the `bond` table with the condition `bond_type = '#'`.\n\n2. **Join with Atoms**: For each molecule identified in the previous step, join the `bond` table with the `atom` table using the `molecule_id` as the common key. This ensures that we retrieve all atoms (and their elements) associated with the molecules that have triple bonds.\n\n3. **Select Distinct Pairs**: To avoid duplicates, select distinct pairs of `molecule_id` and `element` from the joined result. This ensures that each molecule and its constituent elements are listed only once in the output.\n\nThe final output is a list of unique molecule IDs along with all the elements they contain, specifically for molecules that have triple bonds.",
            "To solve the question, \"Which molecules have triple bonds and list all the elements they contain,\" the following detailed steps are performed:\n\n1. **Filter Bonds by Triple Bond Type**: Query the `bond` table (aliased as `T1`) to select all records where the `bond_type` is a triple bond, represented by the symbol '#'. This filters out all bonds that are not triple bonds.\n\n2. **Join with Atom Table**: For each molecule identified in the filtered `bond` table, join the `bond` table (`T1`) with the `atom` table (aliased as `T2`) using the `molecule_id` as the common key. This join operation ensures that all atoms (and their corresponding elements) associated with the molecules that have triple bonds are retrieved.\n\n3. **Select Distinct Molecule-Element Pairs**: From the joined result, select distinct pairs of `molecule_id` (from `T1`) and `element` (from `T2`). This ensures that each molecule and its constituent elements are listed only once in the output, avoiding duplicates.\n\nThe final output is a list of unique molecule IDs along with all the distinct elements they contain, specifically for molecules that have triple bonds."
        ]
    },
    "328": {
        "sql": "SELECT DISTINCT T1.element FROM atom T1 JOIN bond T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '=';",
        "question": "List all the elements with double bond, consisted in molecule TR024.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='",
        "explain": "double bond refers to bond_type = '='; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "solution": [
            "To list all the elements with a double bond in the molecule TR024, the following steps are performed:\n\n1. **Select the elements**: The query retrieves the `element` column from the `atom` table (aliased as `T1`).\n\n2. **Join with the bond table**: The `atom` table is joined with the `bond` table (aliased as `T2`) using the `molecule_id` column to ensure the data is related to the same molecule.\n\n3. **Filter by molecule ID**: The query filters the results to only include atoms from the molecule with the ID `TR024`.\n\n4. **Filter by bond type**: The query further filters the results to only include bonds of type `=`, which represents a double bond.\n\nThis ensures that only elements involved in double bonds within the molecule TR024 are listed."
        ]
    },
    "1324": {
        "sql": "SELECT AVG(attendance_count) AS average_attendance\nFROM (\n    SELECT COUNT(*) AS attendance_count\n    FROM event e\n    JOIN attendance a ON e.event_id = a.link_to_event\n    WHERE e.event_date LIKE '2020%'\n    GROUP BY e.event_id\n);",
        "question": "What is the average attendance of meetings in 2020?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE SUBSTR(T1.event_date, 1, 4) = '2020' AND T1.type = 'Meeting'",
        "explain": "meetings in 2020 refers to type = 'Meeting' where YEAR(event_date) = 2020; average = DIVIDE(COUNT(event_id), COUNT(DISTINCT event_name))",
        "solution": []
    },
    "1102": {
        "sql": "SELECT p.player_name\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE pa.overall_rating = 77 AND pa.date LIKE '2016-06-23%'\nORDER BY p.birthday ASC\nLIMIT 1;",
        "question": "For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-06-23' AND t2.overall_rating = 77 ORDER BY t1.birthday ASC LIMIT 1",
        "explain": "77 points overall rating refers to overall_rating = 77; on 2016/6/23 refers to date LIKE '2016-06-23%'; The larger the birthday value, the younger the person is, and vice versa;",
        "solution": []
    },
    "116": {
        "sql": "WITH first_loan_client AS (\n    SELECT l.account_id, c.client_id\n    FROM loan l\n    JOIN account a ON l.account_id = a.account_id\n    JOIN disp d ON a.account_id = d.account_id\n    JOIN client c ON d.client_id = c.client_id\n    WHERE l.date = '1993-07-05'\n    ORDER BY l.loan_id\n    LIMIT 1\n),\nbalance_b AS (\n    SELECT t.account_id, t.balance\n    FROM trans t\n    JOIN first_loan_client flc ON t.account_id = flc.account_id\n    WHERE t.date = '1993-03-22'\n    ORDER BY t.trans_id DESC\n    LIMIT 1\n),\nbalance_a AS (\n    SELECT t.account_id, t.balance\n    FROM trans t\n    JOIN first_loan_client flc ON t.account_id = flc.account_id\n    WHERE t.date = '1998-12-27'\n    ORDER BY t.trans_id DESC\n    LIMIT 1\n)\nSELECT \n    ((ba.balance - bb.balance) * 100.0 / bb.balance) AS increase_rate\nFROM balance_a ba\nJOIN balance_b bb ON ba.account_id = bb.account_id;",
        "error": "something went wrong, tool did not call.",
        "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
        "explain": "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%",
        "solution": []
    },
    "385": {
        "sql": "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Beacon of Immortality';",
        "question": "Write down the ruling of Beacon of Immortality.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "explain": "Beacon of Immortality' is the name of card;",
        "solution": []
    },
    "463": {
        "sql": "SELECT COUNT(DISTINCT st.translation) AS translation_count\nFROM set_translations st\nWHERE st.setCode IN (\n    SELECT DISTINCT c.setCode\n    FROM cards c\n    WHERE c.name = 'Angel of Mercy'\n) AND st.translation IS NOT NULL;",
        "question": "How many translations are there for the set of cards with \"Angel of Mercy\" in it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT translation) FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Angel of Mercy' ) AND translation IS NOT NULL",
        "explain": "set of cards with \"Angel of Mercy\" in it refers to name = 'Angel of Mercy'",
        "solution": [
            "To determine how many distinct translations exist for the set of cards that include \"Angel of Mercy\", follow these steps:\n\n1. **Identify the sets containing \"Angel of Mercy\":**\n   - Query the `cards` table to find all `setCode` values where the `name` column matches \"Angel of Mercy\".\n\n2. **Retrieve translations for these sets:**\n   - Using the `setCode` values obtained from the previous step, query the `set_translations` table to retrieve all `translation` values where the `translation` is not `NULL`.\n\n3. **Count distinct translations:**\n   - Count the number of unique `translation` values from the results of the previous query.\n\nThis process ensures that only distinct translations are counted for the sets containing \"Angel of Mercy\"."
        ]
    },
    "1368": {
        "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.phone = '809-555-3360';",
        "question": "What does the person with the phone number \"809-555-3360\" major in?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.phone = '809-555-3360'",
        "explain": "major in refers to major_name",
        "solution": []
    },
    "833": {
        "sql": "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';",
        "question": "Name the superhero, otherwise known as Charles Chandler.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler'",
        "explain": "name the superhero refers to superhero_name; Charles Chandler is the full name of superhero;",
        "solution": []
    },
    "23": {
        "sql": "SELECT T1.School, T1.Street\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE ABS(T2.[Enrollment (K-12)] - T2.[Enrollment (Ages 5-17)]) > 30;",
        "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
        "explain": "Diffrence in enrollement = `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
        "solution": [
            "1. **Joining the schools and enrollment data:**  \n   The query uses an `INNER JOIN` between two tables: `schools` (aliased as T1) and `frpm` (aliased as T2). These tables are linked using the `CDSCode` column, ensuring that each school record is matched with its corresponding enrollment data.\n\n2. **Selecting the school name and address:**  \n   From the `schools` table (T1), the query selects the columns `School` (the name of the school) and `Street` (the full street address of the school). These are the specific details requested in the question.\n\n3. **Filtering by enrollment difference:**  \n   The query includes a `WHERE` clause to filter schools where the difference between `Enrollment (K-12)` and `Enrollment (Ages 5-17)` from the `frpm` table (T2) is greater than 30. This ensures only schools with a significant discrepancy in enrollment between these two age groups are included in the results."
        ]
    },
    "1424": {
        "sql": "SELECT COUNT(*) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large';",
        "question": "Among the members, how many of them have an extra large t-shirt size?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(member_id) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large'",
        "explain": "among the members refers to position = 'Member'; extra large t-shirt size refers to t_shirt_size = 'X-Large'",
        "solution": []
    },
    "1001": {
        "sql": "SELECT d.forename || ' ' || d.surname AS full_name\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nJOIN races r ON q.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.year = 2008\nAND c.name = 'Marina Bay Street Circuit'\nAND q.q3 IS NOT NULL\nORDER BY (\n    CAST(SUBSTR(q.q3, 1, 2) AS INTEGER) * 60 +\n    CAST(SUBSTR(q.q3, 4, 2) AS INTEGER) +\n    CAST(SUBSTR(q.q3, 7, 3) AS REAL) / 1000\nLIMIT 1;",
        "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
        "explain": "Ranked 1st in the 3rd qualifying race refer to MIN(q3); 2008 is the year of race; full name of racer = forename, surname",
        "solution": [
            "To find the full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008, follow these steps:\n\n1. **Identify the qualifying race data**:\n   - Use the `qualifying` table (referred to as `T1`) to access qualifying race details.\n   - Filter the data to include only entries where the `q3` field (representing the 3rd qualifying time) is not null.\n\n2. **Join with driver information**:\n   - Join the `qualifying` table (`T1`) with the `drivers` table (`T2`) using the `driverId` field to get the racer's details.\n\n3. **Join with race information**:\n   - Join the `qualifying` table (`T1`) with the `races` table (`T3`) using the `raceId` field to get the race details.\n   - Filter the races to include only those from the year 2008.\n   - Further filter the races to include only those held at the 'Marina Bay Street Circuit' by checking the `circuitId` against a subquery that retrieves the `circuitId` for 'Marina Bay Street Circuit' from the `circuits` table.\n\n4. **Calculate and sort qualifying times**:\n   - Convert the `q3` time (formatted as `MM:SS.sss`) into a numerical value for sorting:\n     - Extract the minutes (`MM`) and convert to seconds.\n     - Extract the seconds (`SS`) and add to the converted minutes.\n     - Extract the milliseconds (`sss`) and convert to seconds, then add to the total.\n   - Sort the results in ascending order to rank the fastest time first.\n\n5. **Retrieve the top racer**:\n   - Limit the results to the first entry (the fastest racer) and return their forename and surname from the `drivers` table (`T2`).\n\nThe final output will be the full name (forename and surname) of the racer who achieved the fastest time in the 3rd qualifying race at the Marina Bay Street Circuit in 2008.",
            "To find the full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008, follow these steps:\n\n1. **Identify the qualifying race data**:\n   - Query the `qualifying` table (referred to as `T1`) to access qualifying race details.\n   - Filter the data to include only entries where the `q3` field (representing the 3rd qualifying time) is not null.\n\n2. **Join with driver information**:\n   - Join the `qualifying` table (`T1`) with the `drivers` table (`T2`) using the `driverId` field to get the racer's details.\n\n3. **Join with race information**:\n   - Join the `qualifying` table (`T1`) with the `races` table (`T3`) using the `raceId` field to get the race details.\n   - Filter the races to include only those from the year 2008.\n   - Further filter the races to include only those held at the 'Marina Bay Street Circuit' by checking the `circuitId` against a subquery that retrieves the `circuitId` for 'Marina Bay Street Circuit' from the `circuits` table.\n\n4. **Calculate and sort qualifying times**:\n   - Convert the `q3` time (formatted as `MM:SS.sss`) into a numerical value for sorting:\n     - Extract the minutes (`MM`) and convert to seconds by multiplying by 60.\n     - Extract the seconds (`SS`) and add to the converted minutes.\n     - Extract the milliseconds (`sss`) and convert to seconds by dividing by 1000, then add to the total.\n   - Sort the results in ascending order to rank the fastest time first.\n\n5. **Retrieve the top racer**:\n   - Limit the results to the first entry (the fastest racer) and return their forename and surname from the `drivers` table (`T2`).\n\nThe final output will be the full name (forename and surname) of the racer who achieved the fastest time in the 3rd qualifying race at the Marina Bay Street Circuit in 2008."
        ]
    },
    "1076": {
        "sql": "WITH diallo_avg AS (\n    SELECT AVG(pa.ball_control) AS avg_ball_control\n    FROM Player_Attributes pa\n    JOIN Player p ON pa.player_api_id = p.player_api_id\n    WHERE p.player_name = 'Abdou Diallo'\n),\nappindangoye_avg AS (\n    SELECT AVG(pa.ball_control) AS avg_ball_control\n    FROM Player_Attributes pa\n    JOIN Player p ON pa.player_api_id = p.player_api_id\n    WHERE p.player_name = 'Aaron Appindangoye'\n)\nSELECT diallo_avg.avg_ball_control - appindangoye_avg.avg_ball_control AS difference_in_avg_ball_control\nFROM diallo_avg, appindangoye_avg;",
        "question": "What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye\n?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.id ELSE NULL END) - CAST(SUM(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.id ELSE NULL END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "explain": "difference of the average ball control = SUBTRACT(AVG(ball_control WHERE player_name = 'Abdou Diallo'), AVG(ball_control WHERE player_name = 'Aaron Appindangoye')); AVG(ball_control WHERE player_name = 'XX XX') = SUM(CASE WHEN player_name = 'XX XX' THEN ball_control ELSE 0 END) / COUNT(CASE WHEN player_name = 'XX XX' THEN id ELSE NULL END)",
        "solution": []
    },
    "1123": {
        "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes);",
        "question": "What is the name of players with the highest potential?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.potential DESC LIMIT 1",
        "explain": "highest potential refers to MAX(potential)",
        "solution": []
    },
    "929": {
        "sql": "SELECT DISTINCT r.name FROM races r JOIN results res ON r.raceId = res.raceId JOIN drivers d ON res.driverId = d.driverId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "question": "Please list the Formula_1 races that Lewis Hamilton participated.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "explain": "",
        "solution": [
            "To list the Formula 1 races that Lewis Hamilton participated in, follow these steps:\n\n1. **Access the races table (T1)**: This table contains information about all Formula 1 races.\n2. **Join the results table (T2)**: Link the races table to the results table using the `raceId` field. This will allow you to find all race results.\n3. **Join the drivers table (T3)**: Further link the results table to the drivers table using the `driverId` field. This will help identify the drivers associated with each race result.\n4. **Filter for Lewis Hamilton**: Apply a condition to the drivers table to only include rows where the driver's forename is 'Lewis' and the surname is 'Hamilton'.\n5. **Retrieve the race names**: Finally, select the `name` column from the races table to list the names of the races where Lewis Hamilton participated."
        ]
    },
    "266": {
        "sql": "SELECT COUNT(*) AS total_carcinogenic_molecules\nFROM molecule\nWHERE molecule_id BETWEEN 'TR000' AND 'TR030'\nAND label = '+';",
        "question": "Calculate the total carcinogenic molecules for molecule id from TR000 to TR030.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.molecule_id BETWEEN 'TR000' AND 'TR030' AND T.label = '+'",
        "explain": "label = '+' mean molecules are carcinogenic",
        "solution": []
    },
    "684": {
        "sql": "SELECT (COUNT(CASE WHEN Age BETWEEN 13 AND 18 THEN 1 END) * 100.0 / COUNT(Id)) AS percentage FROM users;",
        "question": "Identify the percentage of teenage users.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(Id) FROM users",
        "explain": "DIVIDE(COUNT(Id where Age BETWEEN 13 and 18), COUNT(Id)) as percentage;",
        "solution": []
    },
    "178": {
        "sql": "SELECT c.type \nFROM card c \nJOIN disp d ON c.disp_id = d.disp_id \nWHERE d.client_id = 9;",
        "question": "Which kind of credit card does client number 9 possess?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.type FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.client_id = 9",
        "explain": "",
        "solution": []
    },
    "1358": {
        "sql": "SELECT m.first_name, m.last_name\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nORDER BY i.date_received ASC\nLIMIT 1;",
        "question": "Who was the first one paid his/her dues? Tell the full name.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.source = 'Dues' ORDER BY T2.date_received LIMIT 1",
        "explain": "full name refers to first_name, last_name; first paid dues refers to MIN(received_date) where source = 'Dues'",
        "solution": []
    },
    "1524": {
        "sql": "SELECT g.Country AS Nationality\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-24' AND t.Price = 548.4;",
        "question": "What's the nationality of the customer who spent 548.4 in 2012/8/24?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Price = 548.4",
        "explain": "'2012/8/24' can be represented by '2012-08-24'",
        "solution": []
    },
    "1147": {
        "sql": "SELECT DISTINCT t1.player_name\nFROM Player t1\nJOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);",
        "question": "Please name one player whose overall strength is the greatest.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = ( SELECT MAX(overall_rating) FROM Player_Attributes)",
        "explain": "overall strength is the greatest refers to MAX(overall_rating)",
        "solution": [
            "To solve the question, \"Please name one player whose overall strength is the greatest,\" the following steps are performed:\n\n1. **Identify the Maximum Overall Rating**: First, the database finds the highest value in the `overall_rating` column from the `Player_Attributes` table. This is done using the subquery `SELECT MAX(overall_rating) FROM Player_Attributes`.\n\n2. **Join Tables**: The `Player` table (aliased as `t1`) is joined with the `Player_Attributes` table (aliased as `t2`) using the `player_api_id` column as the common key. This ensures that the player's name can be linked to their attributes.\n\n3. **Filter for Maximum Rating**: The query filters the joined tables to only include rows where the `overall_rating` in the `Player_Attributes` table matches the maximum rating identified in the first step.\n\n4. **Select Distinct Player Name**: Finally, the query selects the `player_name` from the `Player` table, ensuring that only distinct names are returned to avoid duplicates.\n\nThe result is the name of one player who has the greatest overall strength based on the `overall_rating` attribute."
        ]
    },
    "1133": {
        "sql": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%';",
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "explain": "first name \"Aaron\" refers to player_name LIKE 'Aaron%'; born after the 1990s refers to birthday > '1990'",
        "solution": [
            "To solve the question \"How many football players born after the 1990s have the first name 'Aaron'?\", follow these steps:\n\n1. **Identify the table**: The data is stored in the `Player` table.\n2. **Filter by birth year**: Select players whose `birthday` is after the year 1990. This is done by checking if `birthday > '1990'`.\n3. **Filter by first name**: Further filter the players to include only those whose `player_name` starts with \"Aaron\". This is achieved using the condition `player_name LIKE 'Aaron%'`.\n4. **Count the results**: Finally, count the number of player IDs (`id`) that meet both criteria using `COUNT(id)`.\n\nThe SQL query combines these steps to return the count of players who satisfy both conditions."
        ]
    },
    "1386": {
        "sql": "SELECT SUM(e.cost) AS total_expense\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Yearly Kickoff';",
        "question": "What is the total expense for the Yearly Kickoff?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'Yearly Kickoff'",
        "explain": "'Yearly Kickoff' is an event name; total expense refers to SUM(cost)",
        "solution": []
    },
    "68": {
        "sql": "SELECT County, COUNT(*) AS NumberOfClosures\nFROM schools\nWHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989'\n  AND StatusType = 'Closed'\n  AND SOC = '11'\nGROUP BY County\nORDER BY NumberOfClosures DESC\nLIMIT 1;",
        "question": "Which county reported the most number of school closure in the 1980s with school wonership code belonging to Youth Authority Facilities (CEA)?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT County FROM schools WHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND StatusType = 'Closed' AND SOC = 11 GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1",
        "explain": "Youth Authority Facilities (CEA) refers to SOC = 11; 1980s = years between 1980 and 1989",
        "solution": [
            "To determine which county reported the most number of school closures in the 1980s with school ownership code belonging to Youth Authority Facilities (CEA), follow these steps:\n\n1. **Filter the Data**:\n   - Select records from the `schools` table where:\n     - The `ClosedDate` falls within the 1980s (i.e., between the years 1980 and 1989).\n     - The `StatusType` is 'Closed'.\n     - The `SOC` (School Ownership Code) is 11, which corresponds to Youth Authority Facilities (CEA).\n\n2. **Group the Data**:\n   - Group the filtered records by the `County` field to aggregate the data by county.\n\n3. **Count the Schools**:\n   - For each county, count the number of schools that meet the above criteria.\n\n4. **Order the Results**:\n   - Sort the counties in descending order based on the count of schools to identify the county with the highest number of closures.\n\n5. **Retrieve the Top Result**:\n   - Limit the results to the top county (i.e., the one with the highest count of school closures).\n\nThe final output will be the name of the county that reported the most school closures under the specified conditions.",
            "To determine which county reported the most number of school closures in the 1980s with school ownership code belonging to Youth Authority Facilities (CEA), follow these detailed steps:\n\n1. **Filter the Data**:\n   - Query the `schools` table to select records where:\n     - The `ClosedDate` is in the 1980s (i.e., the year extracted from `ClosedDate` is between 1980 and 1989).\n     - The `StatusType` is 'Closed'.\n     - The `SOC` (School Ownership Code) is 11, representing Youth Authority Facilities (CEA).\n\n2. **Group the Data**:\n   - Group the filtered records by the `County` field to organize the data by county.\n\n3. **Count the Schools**:\n   - For each county, calculate the number of schools that meet the filtering criteria.\n\n4. **Order the Results**:\n   - Sort the grouped data in descending order based on the count of schools to prioritize counties with the highest number of closures.\n\n5. **Retrieve the Top Result**:\n   - Select the county with the highest count of school closures by limiting the results to the first record.\n\nThe final output will be the name of the county that reported the most school closures under the specified conditions."
        ]
    },
    "64": {
        "sql": "SELECT COUNT(*) FROM schools WHERE MailCity = 'Hickman' AND CharterNum = '00D4';",
        "question": "What is the total number of schools with a mailing city in Hickman belonging to the charter number 00D4?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM schools WHERE CharterNum = '00D4' AND MailCity = 'Hickman'",
        "explain": "",
        "solution": []
    },
    "570": {
        "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'DatEpicCoderGuyWhoPrograms';",
        "question": "For the user whose display name is \"DatEpicCoderGuyWhoPrograms\", what is his/her badge's name?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'DatEpicCoderGuyWhoPrograms'",
        "explain": "\"DatEpicCoderGuyWhoPrograms\" is the DisplayName;",
        "solution": []
    },
    "1526": {
        "sql": "WITH target_customer AS (\n    SELECT t.CustomerID\n    FROM transactions_1k t\n    WHERE t.Price = 634.8 AND t.Date = '2012-08-25'\n),\nconsumption_2012 AS (\n    SELECT SUM(Consumption) AS total_2012\n    FROM yearmonth\n    WHERE CustomerID = (SELECT CustomerID FROM target_customer) AND strftime('%Y', Date) = '2012'\n),\nconsumption_2013 AS (\n    SELECT SUM(Consumption) AS total_2013\n    FROM yearmonth\n    WHERE CustomerID = (SELECT CustomerID FROM target_customer) AND strftime('%Y', Date) = '2013'\n)\nSELECT CAST((c2012.total_2012 - c2013.total_2013) / c2012.total_2012 AS FLOAT) AS consumption_decrease_rate\nFROM consumption_2012 c2012, consumption_2013 c2013;",
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "explain": "'2012/8/24' can be represented by '2012-08-24'; Consumption decrease rate = (consumption_2012 - consumption_2013) / consumption_2012",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Identify the Customer**: First, find the customer who paid exactly 634.8 on August 25, 2012. This is done by querying the `transactions_1k` table and joining it with the `gasstations` table to ensure the correct customer is identified.\n\n2. **Retrieve Consumption Data**: For the identified customer, retrieve their consumption data for the years 2012 and 2013 from the `yearmonth` table.\n\n3. **Calculate Total Consumption for 2012**: Sum the consumption values where the year part of the date is '2012'.\n\n4. **Calculate Total Consumption for 2013**: Similarly, sum the consumption values where the year part of the date is '2013'.\n\n5. **Compute the Decrease Rate**: Subtract the total consumption for 2013 from the total consumption for 2012, then divide the result by the total consumption for 2012. This gives the consumption decrease rate from 2012 to 2013.\n\n6. **Cast to Float**: Ensure the result is cast to a float to handle any decimal values accurately.\n\nThe SQL query combines these steps to directly compute the required decrease rate.",
            "To solve the question, follow these detailed steps:\n\n1. **Identify the Customer**: Query the `transactions_1k` table to find the customer who made a payment of exactly 634.8 on August 25, 2012. Join this table with the `gasstations` table to ensure the correct customer is identified. The result of this subquery will be the `CustomerID` of the target customer.\n\n2. **Retrieve Consumption Data**: Using the identified `CustomerID`, query the `yearmonth` table to retrieve the customer's consumption data for the years 2012 and 2013.\n\n3. **Calculate Total Consumption for 2012**: For the year 2012, sum the `Consumption` values where the year part of the `Date` field is '2012'. This is done using the `SUM` function combined with the `IIF` function to filter records for 2012.\n\n4. **Calculate Total Consumption for 2013**: Similarly, for the year 2013, sum the `Consumption` values where the year part of the `Date` field is '2013'.\n\n5. **Compute the Decrease Rate**: Subtract the total consumption for 2013 from the total consumption for 2012. Divide this difference by the total consumption for 2012 to get the consumption decrease rate. The result is cast to a `FLOAT` to ensure accurate decimal handling.\n\n6. **Final Output**: The result of the calculation is the consumption decrease rate from 2012 to 2013 for the identified customer.\n\nThe SQL query combines these steps into a single operation, directly computing the required decrease rate."
        ]
    },
    "140": {
        "sql": "SELECT COUNT(*) AS account_count\nFROM account\nJOIN district ON account.district_id = district.district_id\nWHERE district.A2 = 'Pisek';",
        "question": "How many accounts are there in the district of \"Pisek\"?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Pisek'",
        "explain": "A2 refers to district name",
        "solution": []
    },
    "14": {
        "sql": "SELECT T1.NCESSchool\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.[Enrollment (Ages 5-17)] DESC\nLIMIT 5;",
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "explain": "",
        "solution": [
            "1. **Joining the schools and enrollment data:**  \n   The query uses an `INNER JOIN` between two tables: `schools` (aliased as T1) and `frpm` (aliased as T2). These two tables are linked together using a common key, the `CDSCode`. This ensures that each school record is matched with its corresponding enrollment data.\n\n2. **Selecting the relevant identifier:**  \n   From the `schools` table (T1), the query specifically selects the column `NCESSchool`. This is the unique identifier assigned by NCES to each school, which the question explicitly requests.\n\n3. **Ordering by enrollment:**  \n   The results are ordered based on the column `Enrollment (Ages 5-17)` from the `frpm` table. The sorting is in descending order (`DESC`), so that schools with the largest number of students enrolled in the 5\u201317 age group appear at the top.\n\n4. **Limiting to the top five:**  \n   Finally, the query applies a `LIMIT 5`, which restricts the output to only the first five records. These will be the five schools with the highest student enrollments in the specified age range.",
            "1. **Joining the schools and enrollment data:**  \n   The query employs an `INNER JOIN` operation to combine records from the `schools` table (aliased as T1) with the `frpm` table (aliased as T2). The join is performed using the `CDSCode` column, which serves as the common key between the two tables. This ensures that each school's record in the `schools` table is accurately paired with its corresponding enrollment data in the `frpm` table, guaranteeing data integrity and relevance.\n\n2. **Selecting the relevant identifier:**  \n   The query explicitly retrieves the `NCESSchool` column from the `schools` table (T1). This column contains the National Center for Education Statistics (NCES) school identification number, which is the unique identifier requested in the question. By selecting this column, the query ensures that the output directly addresses the requirement to list the NCES school IDs.\n\n3. **Ordering by enrollment:**  \n   The results are sorted in descending order (`DESC`) based on the `Enrollment (Ages 5-17)` column from the `frpm` table (T2). This sorting criterion prioritizes schools with the highest enrollment numbers for students aged 5 to 17, placing them at the top of the result set. This step is crucial for identifying the schools with the most students in the specified age range.\n\n4. **Limiting to the top five:**  \n   The query includes a `LIMIT 5` clause, which restricts the output to the top five records after sorting. These five records represent the schools with the highest enrollment numbers for students aged 5 to 17, fulfilling the question's request for the top five schools in this category."
        ]
    },
    "487": {
        "sql": "SELECT \n    (CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.id)) * 100 AS percentage_powerful_cards\nFROM \n    cards T1\nJOIN \n    sets T2 ON T1.setCode = T2.code\nWHERE \n    T2.name = 'Coldsnap';",
        "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "explain": "card set Coldsnap refers to name = 'Coldsnap'; foil is incredibly powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null; the percentage of incredibly powerful cards in the set refers to DIVIDE(SUM(incredibly powerful), SUM(name = 'Coldsnap'))*100",
        "solution": [
            "To determine the percentage of incredibly powerful cards in the set 'Coldsnap', follow these steps:\n\n1. **Identify the relevant tables and columns**:\n   - The `cards` table (`T1`) contains information about individual cards, including their `id`, `setCode`, `cardKingdomFoilId`, and `cardKingdomId`.\n   - The `sets` table (`T2`) contains information about card sets, including the `code` and `name` of each set.\n\n2. **Filter the cards from the 'Coldsnap' set**:\n   - Join the `cards` table (`T1`) with the `sets` table (`T2`) using the `setCode` from `T1` and the `code` from `T2`.\n   - Filter the results to include only cards where the set name (`T2.name`) is 'Coldsnap'.\n\n3. **Count the total number of cards in 'Coldsnap'**:\n   - Use the `COUNT` function on the `id` column of the `cards` table (`T1`) to get the total number of cards in the 'Coldsnap' set.\n\n4. **Identify incredibly powerful cards**:\n   - A card is considered incredibly powerful if both `cardKingdomFoilId` and `cardKingdomId` are not `NULL`.\n   - Use the `SUM` function combined with a `CASE` statement to count how many cards meet this condition.\n\n5. **Calculate the percentage**:\n   - Divide the count of incredibly powerful cards by the total number of cards in 'Coldsnap'.\n   - Multiply the result by 100 to convert it to a percentage.\n   - Use the `CAST` function to ensure the division is performed as a real number (floating-point division) for accurate results.\n\nThis process will yield the percentage of incredibly powerful cards in the 'Coldsnap' set."
        ]
    },
    "480": {
        "sql": "SELECT fd.flavorText \nFROM foreign_data fd\nJOIN cards c ON fd.uuid = c.uuid\nWHERE c.name = 'Ancestor''s Chosen' AND fd.language = 'Italian';",
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "explain": "Italian refers to language = 'Italian'; flavor text refers to flavorText; \"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'",
        "solution": []
    },
    "688": {
        "sql": "SELECT COUNT(*) \nFROM posts \nWHERE ViewCount > 35000 AND (CommentCount = 0 OR CommentCount IS NULL);",
        "question": "Identify the number of posts that have been viewed over 35000 times but have received no comments from other users.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM posts WHERE ViewCount > 35000 AND CommentCount = 0",
        "explain": "have been viewed over 35000 times refers to ViewCount > 35000; received no comments refers to CommentCount = 0;",
        "solution": []
    },
    "1338": {
        "sql": "SELECT T3.approved\nFROM event T1\nJOIN budget T2 ON T1.event_id = T2.link_to_event\nJOIN expense T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%';",
        "question": "Was each expense in October Meeting on October 8, 2019 approved?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
        "explain": "event_name = 'October Meeting' where event_date = '2019-10-08'; approved = True means expenses was approved; approved = False means expenses was not approved",
        "solution": [
            "To determine whether each expense in the 'October Meeting' event on October 8, 2019, was approved, follow these steps:\n\n1. **Identify the Event**: Locate the event named 'October Meeting' that occurred on October 8, 2019, in the `event` table.\n2. **Link to Budget**: Using the `event_id` from the identified event, find all related budget entries in the `budget` table where the `link_to_event` matches the `event_id`.\n3. **Retrieve Expenses**: For each budget entry found, locate all associated expenses in the `expense` table where the `link_to_budget` matches the `budget_id` from the budget entries.\n4. **Check Approval Status**: For each expense retrieved, check the `approved` column to determine if the expense was approved.\n\nThe result will show the approval status (`approved` column) for each expense linked to the 'October Meeting' event on October 8, 2019.",
            "To determine whether each expense in the 'October Meeting' event on October 8, 2019, was approved, follow these detailed steps:\n\n1. **Identify the Event**: Query the `event` table (aliased as `T1`) to locate the event named 'October Meeting' with the date matching '2019-10-08'. This is done using the condition `T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'`.\n\n2. **Link to Budget**: Using the `event_id` from the identified event, join the `budget` table (aliased as `T2`) where the `link_to_event` column in `T2` matches the `event_id` from `T1`. This is achieved with the join condition `T1.event_id = T2.link_to_event`.\n\n3. **Retrieve Expenses**: For each budget entry found in `T2`, join the `expense` table (aliased as `T3`) where the `link_to_budget` column in `T3` matches the `budget_id` from `T2`. This is done using the join condition `T2.budget_id = T3.link_to_budget`.\n\n4. **Check Approval Status**: For each expense retrieved from `T3`, select the `approved` column to determine the approval status of the expense.\n\nThe final result will display the `approved` status for each expense associated with the 'October Meeting' event on October 8, 2019."
        ]
    },
    "1213": {
        "sql": "SELECT T1.ID, \n       CASE \n           WHEN T2.ALP < 300 THEN 'normal'\n           ELSE 'abNormal'\n       END AS ALP_Status\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Birthday = '1982-04-01';",
        "question": "Name the ID of the patient who is born on the April 1st, 1982. Is his/her alkaliphophatase (ALP) within normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID , CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1982-04-01'",
        "explain": "alkaliphophatase (ALP) within normal range refers to ALP < 300",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Retrieve Patient Information**: Identify the patient(s) born on April 1st, 1982, from the `Patient` table.\n2. **Join Laboratory Data**: For the identified patient(s), join the `Laboratory` table to access their alkaliphophatase (ALP) levels.\n3. **Check ALP Levels**: For each patient, check if their ALP level is below 300. If it is, label it as 'normal'; otherwise, label it as 'abNormal'.\n4. **Return Results**: Display the patient's ID along with the ALP status ('normal' or 'abNormal').\n\nThe SQL query accomplishes this by:\n- Selecting the patient's ID from the `Patient` table (aliased as T1).\n- Joining the `Laboratory` table (aliased as T2) on the patient's ID to access their ALP levels.\n- Filtering for patients born on April 1st, 1982, using the condition `T1.Birthday = '1982-04-01'`.\n- Using a `CASE` statement to determine if the ALP level is within the normal range (below 300) and labeling it accordingly."
        ]
    },
    "18": {
        "sql": "SELECT COUNT(DISTINCT T1.CDSCode) AS SchoolCount\nFROM frpm T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nWHERE T1.`Charter Funding Type` = 'Directly funded'\nAND T1.`County Name` = 'Fresno'\nAND T2.NumTstTakr <= 250;",
        "question": "How many schools in Fresno (directly funded) have number of test takers not more than 250?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.CDSCode) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`County Name` = 'Fresno' AND T2.NumTstTakr <= 250",
        "explain": "",
        "solution": [
            "1. **Joining the enrollment and test score data:**  \n   The query uses an `INNER JOIN` between two tables: `frpm` (aliased as T1) and `satscores` (aliased as T2). These tables are linked using the `CDSCode` from `frpm` and the `cds` column from `satscores`. This ensures that each school's enrollment data is matched with its corresponding test score data.\n\n2. **Filtering by funding type and county:**  \n   The query filters the results to include only schools where the `Charter Funding Type` is 'Directly funded' and the `County Name` is 'Fresno'. This narrows down the dataset to schools in Fresno that are directly funded.\n\n3. **Applying the test taker threshold:**  \n   The query further filters the results to include only schools where the number of test takers (`NumTstTakr`) is 250 or fewer. This ensures that only schools meeting this specific criterion are counted.\n\n4. **Counting the qualifying schools:**  \n   The query counts the number of unique `CDSCode` values from the `frpm` table that meet all the specified conditions. This provides the total count of schools in Fresno (directly funded) with no more than 250 test takers."
        ]
    },
    "1205": {
        "sql": "SELECT \n    CASE \n        WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN 'true' \n        ELSE 'false' \n    END AS is_abnormal_ua\nFROM \n    Patient T1\nJOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.ID = 57266;",
        "question": "Was the patient with the number 57266's uric acid within a normal range?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 57266",
        "explain": "uric acid within a normal range refers to UA > 8.0 and SEX = 'M'OR UA > 6.5 and SEX = 'F'",
        "solution": [
            "To determine if the patient with the number 57266's uric acid (UA) level is within a normal range, follow these steps:\n\n1. **Retrieve the patient's data**: Access the `Patient` table (referred to as `T1`) to get the patient's details, specifically their sex (SEX).\n\n2. **Retrieve the laboratory data**: Access the `Laboratory` table (referred to as `T2`) to get the patient's uric acid (UA) level.\n\n3. **Join the tables**: Link the `Patient` and `Laboratory` tables using the patient's ID (`T1.ID = T2.ID`) to ensure the data corresponds to the same patient.\n\n4. **Filter for the specific patient**: Apply a condition to only consider the patient with the ID `57266` (`T1.ID = 57266`).\n\n5. **Check the uric acid level against normal ranges**:\n   - If the patient is female (`T1.SEX = 'F'`), check if the uric acid level (`T2.UA`) is greater than `6.5`.\n   - If the patient is male (`T1.SEX = 'M'`), check if the uric acid level (`T2.UA`) is greater than `8.0`.\n\n6. **Determine the result**:\n   - If either of the above conditions is met, the uric acid level is **not** within the normal range, and the result is `true`.\n   - Otherwise, the uric acid level is within the normal range, and the result is `false`.\n\nThis process ensures that the patient's uric acid level is evaluated based on their sex and the corresponding normal range thresholds.",
            "To determine if the patient with the number 57266's uric acid (UA) level is within a normal range, follow these steps:\n\n1. **Retrieve the patient's data**: Access the `Patient` table (referred to as `T1`) to get the patient's details, specifically their sex (SEX).\n\n2. **Retrieve the laboratory data**: Access the `Laboratory` table (referred to as `T2`) to get the patient's uric acid (UA) level.\n\n3. **Join the tables**: Link the `Patient` and `Laboratory` tables using the patient's ID (`T1.ID = T2.ID`) to ensure the data corresponds to the same patient.\n\n4. **Filter for the specific patient**: Apply a condition to only consider the patient with the ID `57266` (`T1.ID = 57266`).\n\n5. **Check the uric acid level against normal ranges**:\n   - If the patient is female (`T1.SEX = 'F'`), check if the uric acid level (`T2.UA`) is greater than `6.5`.\n   - If the patient is male (`T1.SEX = 'M'`), check if the uric acid level (`T2.UA`) is greater than `8.0`.\n\n6. **Determine the result**:\n   - If either of the above conditions is met, the uric acid level is **not** within the normal range, and the result is `true`.\n   - Otherwise, the uric acid level is within the normal range, and the result is `false`.\n\nThis process ensures that the patient's uric acid level is evaluated based on their sex and the corresponding normal range thresholds."
        ]
    },
    "311": {
        "sql": "SELECT COUNT(DISTINCT a.molecule_id) \nFROM atom a\nLEFT JOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.element <> 's' AND (b.bond_id IS NULL OR b.bond_type <> '=');",
        "question": "How many molecules without sulphur element is not having double bond?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element <> 's' AND T2.bond_type <> '='",
        "explain": "double bond refers to bond_type = ' = '; bond_type ! = ' = '; sulphur refers to element = 's'",
        "solution": [
            "To solve the question \"How many molecules without sulphur element is not having double bond?\", the following steps are performed:\n\n1. **Filter Atoms Without Sulphur**: Identify all atoms in the `atom` table where the element is not sulphur (`element <> 's'`).\n\n2. **Filter Bonds Without Double Bonds**: Identify all bonds in the `bond` table where the bond type is not a double bond (`bond_type <> '='`).\n\n3. **Join Tables**: Combine the results from the `atom` and `bond` tables by matching the `molecule_id` in both tables. This ensures that only molecules with atoms not containing sulphur and bonds not being double bonds are considered.\n\n4. **Count Distinct Molecules**: Count the distinct `molecule_id` values from the joined result to determine the number of unique molecules that meet both criteria.\n\nThe final count represents the number of molecules that do not contain sulphur and do not have any double bonds."
        ]
    },
    "254": {
        "sql": "WITH bond_counts AS (\n  SELECT T2.bond_type, COUNT(T1.atom_id) AS count\n  FROM connected T1\n  JOIN bond T2 ON T1.bond_id = T2.bond_id\n  GROUP BY T2.bond_type\n),\nmax_bond AS (\n  SELECT bond_type, count\n  FROM bond_counts\n  ORDER BY count DESC\n  LIMIT 1\n),\ntotal_bonds AS (\n  SELECT COUNT(atom_id) AS total\n  FROM connected\n)\nSELECT (max_bond.count * 100.0 / total_bonds.total) AS percentage\nFROM max_bond, total_bonds;",
        "question": "What percentage of bonds have the most common combination of atoms' elements?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST((SELECT COUNT(T1.atom_id) FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id GROUP BY T2.bond_type ORDER BY COUNT(T2.bond_id) DESC LIMIT 1 ) AS REAL) * 100 / ( SELECT COUNT(atom_id) FROM connected )",
        "explain": "DIVIDE(COUNT(bond_id), COUNT(atom_id where MAX(COUNT(atom_id)) ))",
        "solution": [
            "To determine the percentage of bonds that have the most common combination of atoms' elements, follow these steps:\n\n1. **Count the number of bonds for each bond type**:\n   - Join the `connected` table (aliased as `T1`) with the `bond` table (aliased as `T2`) using the `bond_id` field.\n   - Group the results by `bond_type` from the `bond` table.\n   - For each group, count the number of `atom_id` entries from the `connected` table.\n\n2. **Identify the most common bond type**:\n   - Order the grouped results by the count of `bond_id` entries in descending order.\n   - Select the top result (the most common bond type) using the `LIMIT 1` clause.\n\n3. **Calculate the percentage**:\n   - Convert the count of the most common bond type to a real number.\n   - Multiply this count by 100 to convert it to a percentage.\n   - Divide this result by the total number of `atom_id` entries in the `connected` table to get the percentage.\n\nThe final result is the percentage of bonds that have the most common combination of atoms' elements."
        ]
    },
    "923": {
        "sql": "SELECT COUNT(*) AS race_count\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Italy';",
        "question": "How many Formula_1 races took place on the circuits in Italy?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Italy'",
        "explain": "",
        "solution": []
    },
    "150": {
        "sql": "SELECT COUNT(DISTINCT T2.account_id) AS account_count\nFROM district T1\nJOIN account T2 ON T1.district_id = T2.district_id\nJOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T1.A3 = 'north Bohemia' AND T3.bank = 'AB';",
        "question": "How many accounts in North Bohemia has made a transaction with the partner's bank being AB?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.bank = 'AB' AND T1.A3 = 'north Bohemia'",
        "explain": "A3 contains the region names; North Bohemia is a region.",
        "solution": [
            "To solve the question \"How many accounts in North Bohemia have made a transaction with the partner's bank being AB?\", follow these steps:\n\n1. **Identify the relevant tables and columns**:\n   - The `district` table (aliased as `T1`) contains information about districts, including the region (`A3` column).\n   - The `account` table (aliased as `T2`) contains account information, including the district each account belongs to (`district_id` column).\n   - The `trans` table (aliased as `T3`) contains transaction details, including the partner bank (`bank` column) and the account involved in the transaction (`account_id` column).\n\n2. **Filter the districts**:\n   - From the `district` table (`T1`), filter rows where the region (`A3` column) is \"north Bohemia\".\n\n3. **Join the tables**:\n   - Join the filtered `district` table (`T1`) with the `account` table (`T2`) using the `district_id` column to link accounts to their respective districts.\n   - Join the resulting table with the `trans` table (`T3`) using the `account_id` column to link transactions to their respective accounts.\n\n4. **Filter the transactions**:\n   - From the joined tables, filter rows where the partner bank (`bank` column in `T3`) is \"AB\".\n\n5. **Count the accounts**:\n   - Count the distinct `account_id` values from the `account` table (`T2`) that meet all the above criteria.\n\nThe final count represents the number of accounts in North Bohemia that have made a transaction with the partner's bank being AB.",
            "To solve the question \"How many accounts in North Bohemia have made a transaction with the partner's bank being AB?\", follow these steps:\n\n1. **Identify the relevant tables and columns**:\n   - The `district` table (aliased as `T1`) contains information about districts, including the region (`A3` column).\n   - The `account` table (aliased as `T2`) contains account information, including the district each account belongs to (`district_id` column).\n   - The `trans` table (aliased as `T3`) contains transaction details, including the partner bank (`bank` column) and the account involved in the transaction (`account_id` column).\n\n2. **Filter the districts**:\n   - From the `district` table (`T1`), filter rows where the region (`A3` column) is \"north Bohemia\".\n\n3. **Join the tables**:\n   - Join the filtered `district` table (`T1`) with the `account` table (`T2`) using the `district_id` column to link accounts to their respective districts.\n   - Join the resulting table with the `trans` table (`T3`) using the `account_id` column to link transactions to their respective accounts.\n\n4. **Filter the transactions**:\n   - From the joined tables, filter rows where the partner bank (`bank` column in `T3`) is \"AB\".\n\n5. **Count the accounts**:\n   - Count the distinct `account_id` values from the `account` table (`T2`) that meet all the above criteria.\n\nThe final count represents the number of accounts in North Bohemia that have made a transaction with the partner's bank being AB."
        ]
    },
    "534": {
        "sql": "SELECT DisplayName FROM users ORDER BY Views DESC LIMIT 1;",
        "question": "What is the display name of the user who has the most number of views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "explain": "user who has the most number of view refers to Max(Views)",
        "solution": []
    },
    "1045": {
        "sql": "SELECT pa.attacking_work_rate\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Franco Zennaro';",
        "question": "What is the attacking work rate of the football playerr Franco Zennaro?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Franco Zennaro'",
        "explain": "",
        "solution": []
    },
    "1207": {
        "sql": "SELECT DISTINCT T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60 AND STRFTIME('%Y', T2.Date) = '1994';",
        "question": "List all patients with their sex and date of birthday, whose AST glutamic oxaloacetic transaminase (GOT) index is within normal range for loboratory examination in 1994.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND STRFTIME('%Y', T2.Date) = '1994'",
        "explain": "AST glutamic oxaloacetic transaminase (GOT) index is within normal range refers to GOT < 60; examination in 1994 refers to year(Date) = 1994",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Select Distinct Patient Attributes**: Retrieve the distinct values of `SEX` and `Birthday` from the `Patient` table (aliased as `T1`).\n\n2. **Join with Laboratory Data**: Perform an inner join between the `Patient` table (`T1`) and the `Laboratory` table (aliased as `T2`) using the `ID` column as the join condition.\n\n3. **Filter by GOT Index**: Include only those records where the `GOT` value in the `Laboratory` table (`T2`) is less than 60, indicating the AST glutamic oxaloacetic transaminase (GOT) index is within the normal range.\n\n4. **Filter by Year**: Further filter the records to include only those where the year of the `Date` field in the `Laboratory` table (`T2`) is 1994. This is done using the `STRFTIME` function to extract the year from the `Date` field.\n\n5. **Output the Result**: The final output will be a list of distinct patient records (combinations of `SEX` and `Birthday`) that meet the specified criteria."
        ]
    },
    "981": {
        "sql": "WITH youngest_driver AS (\n    SELECT driverId\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 1\n)\nSELECT T3.year, T3.name, T3.date, T3.time\nFROM qualifying T1\nJOIN youngest_driver T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T1.raceId = T3.raceId\nORDER BY T3.date ASC\nLIMIT 1;",
        "question": "On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.year, T3.name, T3.date, T3.time FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T1.driverId = ( SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1 ) ORDER BY T3.date ASC LIMIT 1",
        "explain": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; first qualifying race refers to MIN(races.date);",
        "solution": [
            "To find the year, name, date, and time of the first qualifying race for the youngest driver, follow these steps:\n\n1. **Identify the youngest driver**:\n   - Retrieve the driver with the most recent date of birth (dob) from the `drivers` table. This is done by ordering the drivers by their date of birth in descending order and selecting the first record.\n\n2. **Find the qualifying races for this driver**:\n   - Using the `driverId` of the youngest driver, join the `qualifying` table with the `drivers` table to get all qualifying races for this driver.\n\n3. **Retrieve race details**:\n   - Join the result with the `races` table to get the year, name, date, and time of each qualifying race.\n\n4. **Sort and limit the results**:\n   - Order the qualifying races by date in ascending order to find the earliest race.\n   - Limit the result to the first record to get the details of the first qualifying race for the youngest driver.\n\nThe final output will include the year, name, date, and time of the first qualifying race for the youngest driver.",
            "To find the year, name, date, and time of the first qualifying race for the youngest driver, follow these steps:\n\n1. **Identify the youngest driver**:\n   - Execute a subquery to retrieve the `driverId` of the youngest driver from the `drivers` table. This is done by ordering the drivers by their date of birth (`dob`) in descending order and selecting the first record using `LIMIT 1`.\n\n2. **Join tables to retrieve qualifying races**:\n   - Use the `driverId` obtained from the subquery to join the `qualifying` table (`T1`) with the `drivers` table (`T2`) on the `driverId` field. This ensures we only consider qualifying races for the youngest driver.\n\n3. **Retrieve race details**:\n   - Further join the result with the `races` table (`T3`) on the `raceId` field to obtain the year (`year`), name (`name`), date (`date`), and time (`time`) of each qualifying race.\n\n4. **Sort and limit the results**:\n   - Order the qualifying races by the race date (`T3.date`) in ascending order to find the earliest qualifying race for the youngest driver.\n   - Limit the result to the first record using `LIMIT 1` to get the details of the first qualifying race.\n\nThe final output will include the year, name, date, and time of the first qualifying race for the youngest driver, as specified in the SQL query."
        ]
    },
    "1251": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) AS \"Number of Patients with High Ig G\"\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nJOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.IGG >= 2000;",
        "question": "How many patients with an Ig G higher than normal?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
        "explain": "Ig G higher than normal refers to IGG >= 2000; Should consider DISTINCT in the final result;",
        "solution": [
            "To determine how many patients have an Ig G level higher than normal, follow these steps:\n\n1. **Identify the relevant tables**: The data is spread across three tables:\n   - `Patient` (aliased as `T1`): Contains patient information.\n   - `Laboratory` (aliased as `T2`): Contains laboratory test results, including Ig G levels.\n   - `Examination` (aliased as `T3`): Contains examination details.\n\n2. **Join the tables**:\n   - Join the `Patient` table (`T1`) with the `Laboratory` table (`T2`) using the `ID` field to link patients to their laboratory results.\n   - Further join the result with the `Examination` table (`T3`) using the `ID` field to include examination details.\n\n3. **Filter the results**:\n   - Apply a filter to include only those records where the Ig G level (`T2.IGG`) is greater than or equal to 2000, which is considered higher than normal.\n\n4. **Count distinct patients**:\n   - Count the distinct `ID` values from the `Patient` table (`T1.ID`) to ensure each patient is only counted once, regardless of how many tests they have.\n\nThe final result will be the number of unique patients with an Ig G level of 2000 or higher."
        ]
    },
    "839": {
        "sql": "SELECT T1.full_name\nFROM superhero T1\nJOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T1.weight_kg < 100 AND T2.colour = 'Brown';",
        "question": "In superheroes with weight less than 100, list the full name of the superheroes with brown eyes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Brown'",
        "explain": "weight less than 100 refers to weight_kg < 100",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join Tables**: The `superhero` table (referred to as `T1`) is joined with the `colour` table (referred to as `T2`) using the condition `T1.eye_colour_id = T2.id`. This links each superhero's eye color to its corresponding color name in the `colour` table.\n\n2. **Filter by Weight**: From the joined tables, only those records where the superhero's weight (`T1.weight_kg`) is less than 100 are selected.\n\n3. **Filter by Eye Color**: Further, only those records where the eye color (`T2.colour`) is 'Brown' are selected.\n\n4. **Select Full Name**: Finally, the `full_name` column from the `superhero` table (`T1.full_name`) is retrieved for the filtered records.\n\nThis sequence of operations ensures that only the full names of superheroes who weigh less than 100 kg and have brown eyes are listed."
        ]
    },
    "1210": {
        "sql": "SELECT AVG(LDH) AS average_LDH FROM Laboratory WHERE LDH < 500;",
        "question": "What is the average index of the lactate dehydrogenase (LDH) for all patients with lactate dehydrogenase (LDH) within the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(LDH) FROM Laboratory WHERE LDH < 500",
        "explain": "average index of the lactate dehydrogenase (LDH) refers to AVG(LDH); (LDH) within the normal range refers to LDH < 500",
        "solution": []
    },
    "638": {
        "sql": "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Organizer';",
        "question": "List all the name of users that obtained the Organizer Badges.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Organizer'",
        "explain": "name of users refers to DisplayName; the Organizer Badges refer to badges where Name = 'Organizer';",
        "solution": []
    },
    "43": {
        "sql": "SELECT T1.AvgScrMath, T2.County\nFROM satscores T1\nJOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath IS NOT NULL\nORDER BY (T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite) ASC\nLIMIT 1;",
        "question": "What is the average math score of the school with the lowest average score for all subjects, and in which county is it located?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.AvgScrMath, T2.County FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath IS NOT NULL ORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC LIMIT 1",
        "explain": "Average score for all subjects can be computed by AvgScrMath + AvgScrRead + AvgScrWrite",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter Valid Records**: From the `satscores` table (aliased as `T1`), only records where the `AvgScrMath` field is not null are considered.\n\n2. **Calculate Total Average Score**: For each valid record, the sum of the average scores for math (`AvgScrMath`), reading (`AvgScrRead`), and writing (`AvgScrWrite`) is calculated. This sum represents the total average score for all subjects.\n\n3. **Sort by Total Average Score**: The records are sorted in ascending order based on the total average score calculated in the previous step. This ensures that the school with the lowest combined average score appears first.\n\n4. **Join with Schools Table**: The `satscores` table is joined with the `schools` table (aliased as `T2`) using the `cds` field from `T1` and the `CDSCode` field from `T2`. This join is used to retrieve additional information about the school, specifically the county (`County`).\n\n5. **Select the Top Record**: The first record from the sorted and joined result is selected, which corresponds to the school with the lowest average score for all subjects.\n\n6. **Retrieve Required Information**: From this record, the average math score (`AvgScrMath`) and the county (`County`) are retrieved to answer the question.\n\nThe SQL query ensures that the result is accurate by filtering out null values, calculating the correct total score, and joining the necessary tables to provide the required details."
        ]
    },
    "1303": {
        "sql": "SELECT MIN(P.Birthday) AS OldestPatientBirthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.GLU > 180;",
        "question": "When is the birthday of the oldest patient whose blood glucose is abnormal?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU > 180 ORDER BY T1.Birthday ASC LIMIT 1",
        "explain": "oldest patient refers to MIN(Birthday); blood glucose is abnormal refers to GLU > 180;",
        "solution": []
    },
    "1193": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Examination T2 ON T1.ID = T2.ID \nWHERE T2.[ANA Pattern] != 'P' \nAND T1.SEX = 'F' \nAND strftime('%Y', T1.Birthday) BETWEEN '1980' AND '1989';",
        "question": "Excluding all P only ANA Pattern patients, how many of the remainder are women born between 1980 and 1989?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.`ANA Pattern` != 'P' AND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989' AND T1.SEX = 'F'",
        "explain": "Excluding all P only ANA Pattern refers to `ANA Pattern`! = 'P'; women refers to SEX = 'F'; born between 1980 and 1989 refers to BIRTHDAY",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join Tables**: Combine the `Patient` table (referred to as `T1`) and the `Examination` table (referred to as `T2`) using the `ID` column as the common key.\n\n2. **Filter Conditions**: Apply the following filters to the joined data:\n   - Exclude all records where the `ANA Pattern` in the `Examination` table (`T2`) is 'P'.\n   - Include only records where the `Birthday` year in the `Patient` table (`T1`) falls between 1980 and 1989.\n   - Include only records where the `SEX` in the `Patient` table (`T1`) is 'F' (female).\n\n3. **Count Distinct IDs**: Count the number of distinct `ID` values from the `Patient` table (`T1`) that meet all the above conditions.\n\nThe result of these operations will give the number of female patients born between 1980 and 1989 who do not have an 'P' ANA Pattern."
        ]
    },
    "334": {
        "sql": "SELECT a.element \nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.atom_id = 'TR004_7' AND m.label != 'carcinogenic';",
        "question": "What is the element with the atom ID of TR004_7 in molecule that is not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR004_7' AND T2.label = '-'",
        "explain": "label = '-' means molecules are non-carcinogenic; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "solution": []
    },
    "294": {
        "sql": "SELECT T1.bond_id FROM bond T1 JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.bond_type = '=';",
        "question": "Which bond ids are double-bond with carcinogenic compound?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.bond_type = '='",
        "explain": "label = '+' mean molecules are carcinogenic; double bond refers to bond_type = ' = ';",
        "solution": [
            "To find the bond IDs that are double-bonded with carcinogenic compounds, follow these steps:\n\n1. **Join the Tables**: Combine the `bond` table (referred to as `T1`) with the `molecule` table (referred to as `T2`) using the `molecule_id` field as the common key.\n\n2. **Filter for Carcinogenic Compounds**: From the joined tables, filter the records to include only those where the `label` field in the `molecule` table (`T2.label`) is `'+'`, indicating a carcinogenic compound.\n\n3. **Filter for Double Bonds**: Further filter the records to include only those where the `bond_type` field in the `bond` table (`T1.bond_type`) is `'='`, indicating a double bond.\n\n4. **Select Bond IDs**: Finally, retrieve the `bond_id` field from the `bond` table (`T1.bond_id`) for the filtered records.\n\nThis process ensures that only bond IDs of double bonds associated with carcinogenic compounds are selected."
        ]
    },
    "1057": {
        "sql": "SELECT AVG(home_team_goal) AS average_home_team_goal\nFROM \"Match\"\nWHERE season = '2010/2011'\nAND country_id = (SELECT id FROM \"Country\" WHERE name = 'Poland');",
        "question": "Calculate the average home team goal in the 2010/2011 season in the country of Poland.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Poland' AND t2.season = '2010/2011'",
        "explain": "average home team goal = AVG(home_team_goal)= SUM(home_team_goal) / COUNT(DISTINCT Match.id) WHERE name = 'Poland' and season = '2010/2011';",
        "solution": []
    },
    "187": {
        "sql": "SELECT COUNT(DISTINCT T2.client_id) AS client_count\nFROM account T1\nJOIN disp T2 ON T1.account_id = T2.account_id\nWHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "question": "How many clients who choose statement of weekly issuance are Owner?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'",
        "explain": "Frequency = 'POPLATEK TYDNE' refers to weekly issuance",
        "solution": [
            "To solve the question \"How many clients who choose a statement of weekly issuance are Owner?\", the following steps are performed:\n\n1. **Join the Tables**: The `account` table (aliased as `T1`) is joined with the `disp` table (aliased as `T2`) using the `account_id` field. This links each account to its corresponding disposition record.\n\n2. **Filter for Weekly Issuance**: From the joined tables, filter the records where the `frequency` field in the `account` table (`T1.frequency`) is set to \"POPLATEK TYDNE\", which indicates a weekly issuance statement.\n\n3. **Filter for Owner Type**: Further filter the records to include only those where the `type` field in the `disp` table (`T2.type`) is \"OWNER\", indicating that the client is the owner of the account.\n\n4. **Count the Clients**: Finally, count the number of distinct `account_id` values from the `disp` table (`T2.account_id`) that meet the above criteria. This count represents the number of clients who are owners and have opted for weekly issuance statements."
        ]
    },
    "235": {
        "sql": "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '+' AND a.element = 'br';",
        "question": "How many molecules are carcinogenic and have the bromine element?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'br'",
        "explain": "label = '+' mean molecules are carcinogenic; have bromine element refers to element = 'br'",
        "solution": []
    },
    "955": {
        "sql": "SELECT \n    r.year,\n    AVG(\n        CAST(SUBSTR(res.time, 1, 2) AS INTEGER) * 3600 + \n        CAST(SUBSTR(res.time, 4, 2) AS INTEGER) * 60 + \n        CAST(SUBSTR(res.time, 7, 2) AS INTEGER) + \n        CAST(SUBSTR(res.time, 10) AS FLOAT) / 1000\n    ) AS avg_champion_time_seconds\nFROM \n    results res\nJOIN \n    races r ON res.raceId = r.raceId\nWHERE \n    res.position = 1 \n    AND r.year < 1975 \n    AND res.time IS NOT NULL\nGROUP BY \n    r.year\nHAVING \n    avg_champion_time_seconds IS NOT NULL;",
        "question": "What is the average time in seconds of champion for each year, before year 1975?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
        "explain": "only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null; before year 1975 refers to year < 1975;",
        "solution": [
            "To solve the question \"What is the average time in seconds of the champion for each year before 1975?\", the following steps are performed:\n\n1. **Extract Time in Seconds**:\n   - For each race result, check if the driver's position is 1 (champion).\n   - If the position is 1, convert the time from the format `HH:MM:SS.MS` to seconds. This involves:\n     - Extracting the hours (first digit), multiplying by 3600.\n     - Extracting the minutes (digits 3-4), multiplying by 60.\n     - Extracting the seconds (digits 6-7).\n     - Extracting the milliseconds (digits 9 onwards), dividing by 1000, and adding to the total.\n   - If the position is not 1, set the time to 0.\n   - This is done for all races where the time is not null.\n\n2. **Filter Champion Times**:\n   - From the results of the first step, select only the rows where the position is 1 (champion).\n\n3. **Calculate Average Time per Year**:\n   - Group the champion times by year.\n   - Calculate the average time in seconds for each year.\n   - Only include years before 1975.\n   - Exclude any years where the average time is null.\n\nThe final output is a list of years and their corresponding average champion times in seconds, for years before 1975.",
            "To solve the question \"What is the average time in seconds of the champion for each year before 1975?\", the following detailed steps are performed:\n\n1. **Extract Time in Seconds**:\n   - For each race result, check if the driver's position is 1 (champion).\n   - If the position is 1, convert the time from the format `HH:MM:SS.MS` to seconds. This involves:\n     - Extracting the hours (first digit), multiplying by 3600.\n     - Extracting the minutes (digits 3-4), multiplying by 60.\n     - Extracting the seconds (digits 6-7).\n     - Extracting the milliseconds (digits 9 onwards), dividing by 1000, and adding to the total.\n   - If the position is not 1, set the time to 0.\n   - This is done for all races where the time is not null.\n\n2. **Filter Champion Times**:\n   - From the results of the first step, select only the rows where the position is 1 (champion).\n\n3. **Calculate Average Time per Year**:\n   - Group the champion times by year.\n   - Calculate the average time in seconds for each year.\n   - Only include years before 1975.\n   - Exclude any years where the average time is null.\n\nThe final output is a list of years and their corresponding average champion times in seconds, for years before 1975."
        ]
    },
    "252": {
        "sql": "SELECT T2.atom_id2 AS connected_atom_id\nFROM atom T1\nJOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'Pb'",
        "question": "What are the atoms that can bond with the atom that has the element lead?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'pb'",
        "explain": "atom that has the element lead refers to atom_id where element = 'pb'",
        "solution": [
            "To find the atoms that can bond with the atom that has the element lead (Pb), follow these steps:\n\n1. **Identify the lead atom**: First, locate the atom in the database where the element is 'Pb' (lead). This is done by querying the `atom` table (referred to as T1 in the SQL) for records where the `element` column equals 'Pb'.\n\n2. **Find connected atoms**: Once the lead atom is identified, use its `atom_id` to find all atoms that are connected to it. This is done by joining the `connected` table (referred to as T2 in the SQL) with the `atom` table. The join condition is that the `atom_id` in the `atom` table (T1) matches the `atom_id` in the `connected` table (T2).\n\n3. **Retrieve the connected atoms**: From the `connected` table, retrieve the `atom_id2` column, which represents the IDs of the atoms connected to the lead atom. The result will include both the ID of the lead atom (`atom_id`) and the IDs of the atoms it is bonded with (`atom_id2`).\n\nThis process ensures that all atoms capable of bonding with lead are identified and returned in the result set.",
            "To find the atoms that can bond with the atom that has the element lead (Pb), follow these detailed steps:\n\n1. **Query the `atom` table for lead**: Start by querying the `atom` table (referred to as T1 in the SQL) to identify the atom(s) where the `element` column is 'Pb' (lead). This will give you the `atom_id` of the lead atom(s).\n\n2. **Join with the `connected` table**: Use the `atom_id` obtained from the `atom` table to join with the `connected` table (referred to as T2 in the SQL). The join condition is that the `atom_id` in the `atom` table (T1) must match the `atom_id` in the `connected` table (T2). This ensures you are only looking at connections involving the lead atom.\n\n3. **Retrieve the connected atoms**: From the `connected` table, select the `atom_id` (representing the lead atom) and `atom_id2` (representing the atoms connected to the lead atom). This will give you a list of all atoms that can bond with lead, along with their connection details.\n\n4. **Filter for lead**: The SQL includes a WHERE clause (`T1.element = 'pb'`) to ensure only the lead atom is considered in the query. This step is critical to focus the results on bonds involving lead.\n\n5. **Return the results**: The final output will include pairs of `atom_id` (lead) and `atom_id2` (connected atoms), providing a complete list of atoms that can bond with lead."
        ]
    },
    "543": {
        "sql": "SELECT MAX(AnswerCount) AS MaxAnswerCount\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');",
        "question": "For the post that got the most number of answers owned by csgillespie, how many answers did it get?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT MAX(T1.AnswerCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "explain": "\"csgillespie\" is the DisplayName of user; the most number of answer refers to Max(AnswerCount)",
        "solution": []
    },
    "872": {
        "sql": "SELECT d.code FROM qualifying q JOIN drivers d ON q.driverId = d.driverId WHERE q.raceId = 45 AND q.q3 LIKE '1:33%';",
        "question": "In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'",
        "explain": "race number refers to raceId; had the Q3 time as 0:0M:SS refers to q3 LIKE 'M:SS%'",
        "solution": [
            "To find the abbreviated code of the driver who had a Q3 time of 0:01:33 in race No. 45, follow these steps:\n\n1. **Join the Tables**: Combine the `qualifying` table (referred to as T1) with the `drivers` table (referred to as T2) using the `driverId` field as the common key.\n\n2. **Filter by Race ID**: From the joined tables, filter the records to only include those where the `raceId` is 45.\n\n3. **Filter by Q3 Time**: Further filter the records to include only those where the `q3` time starts with '1:33' (indicating a time of 0:01:33).\n\n4. **Select the Abbreviated Code**: From the filtered records, select the `code` field from the `drivers` table (T2), which represents the abbreviated code of the driver.\n\nThis process ensures that you retrieve the correct abbreviated code for the specified driver in the given race."
        ]
    },
    "451": {
        "sql": "SELECT COUNT(*) FROM cards WHERE availability LIKE '%paper%' AND hand = '3';",
        "question": "How many cards available in paper have a positive starting maximum hand size?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN availability = 'paper' AND hAND = '3' THEN 1 ELSE 0 END) FROM cards",
        "explain": "available in paper refers to availability like '%paper%'; have a positive starting maximum hand size refers to hand = '3'",
        "solution": []
    },
    "1429": {
        "sql": "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nWHERE m.position = 'Vice President'\nAND e.type = 'Social'\nAND e.location = '900 E. Washington St.';",
        "question": "What is the name of the social event that was attended by the vice president of the Student_Club located at 900 E. Washington St.?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T3.position = 'Vice President' AND T2.location = '900 E. Washington St.' AND T2.type = 'Social'",
        "explain": "name of social event refers to event_name where type = 'Social'; 'Vice President' is position; located at refers to location",
        "solution": []
    },
    "131": {
        "sql": "SELECT d.A3 AS district_name\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.status IN ('C', 'D')\nGROUP BY d.A3\nORDER BY SUM(l.amount) DESC\nLIMIT 1;",
        "question": "Which district has highest active loan?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.status IN ('C', 'D') GROUP BY T2.A3 ORDER BY SUM(T3.amount) DESC LIMIT 1",
        "explain": "A3 refers to district names; Active loan refers to running contracts; Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
        "solution": [
            "To find the district with the highest active loan, follow these steps:\n\n1. **Join the Tables**: Combine the `account`, `district`, and `loan` tables. The `account` table is linked to the `district` table using the `district_id` field, and the `account` table is linked to the `loan` table using the `account_id` field.\n\n2. **Filter Active Loans**: Only include loans where the `status` is either 'C' or 'D' (indicating active loans).\n\n3. **Group by District**: Group the results by the district name (stored in the `A3` column of the `district` table).\n\n4. **Calculate Total Loan Amount**: For each district, calculate the sum of the loan amounts (`amount` column in the `loan` table).\n\n5. **Sort Districts by Total Loan Amount**: Order the districts in descending order based on the total loan amount.\n\n6. **Select the Top District**: Retrieve the district with the highest total loan amount by limiting the result to the first row.\n\nThe final output will be the name of the district (`A3` column from the `district` table) with the highest active loan amount."
        ]
    },
    "550": {
        "sql": "SELECT p.Body \nFROM posts p \nJOIN tags t ON p.Id = t.ExcerptPostId \nWHERE t.Count = (SELECT MAX(Count) FROM tags);",
        "question": "From which post is the most popular tag excerpted from? Please give the body of the post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Body FROM posts WHERE id = ( SELECT ExcerptPostId FROM tags ORDER BY Count DESC LIMIT 1 )",
        "explain": "most popular tag refers to Max(Count); excerpt from refer to ExcerptPostId",
        "solution": []
    },
    "848": {
        "sql": "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.location = 'Shanghai';",
        "question": "Please list the year during which the race is held on circuits in Shanghai.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.location = 'Shanghai'",
        "explain": "Shanghai is a name of location;",
        "solution": []
    },
    "1055": {
        "sql": "SELECT p.birthday\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);",
        "question": "When is the birthday of the football player who has the highest overall rating?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.birthday FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
        "explain": "football player who has the highest overall rating refers to MAX(overall_rating);",
        "solution": []
    },
    "251": {
        "sql": "SELECT a.element, COUNT(DISTINCT m.molecule_id) AS molecule_count\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+'\nGROUP BY a.element\nORDER BY molecule_count ASC\nLIMIT 1;",
        "question": "What is the least common element of all carcinogenic molecules?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "explain": "label = '+' mean molecules are carcinogenic",
        "solution": [
            "To find the least common element of all carcinogenic molecules, follow these steps:\n\n1. **Filter carcinogenic molecules**: Identify all molecules labeled as carcinogenic (denoted by the label '+').\n\n2. **Join with atom data**: For each carcinogenic molecule, retrieve all the atoms it contains by joining the `molecule` table with the `atom` table using the `molecule_id` as the common key.\n\n3. **Group by element**: Group the resulting data by the `element` column to organize the atoms by their elemental type.\n\n4. **Count distinct molecules per element**: For each element, count how many distinct carcinogenic molecules contain that element.\n\n5. **Order by count**: Sort the elements in ascending order based on the count of distinct molecules they appear in. This ensures the least common element appears first.\n\n6. **Select the least common element**: Retrieve the element with the smallest count, which is the least common element among all carcinogenic molecules.\n\nThe SQL query accomplishes this by:\n- Filtering molecules with the label '+'.\n- Joining with the `atom` table to get all atoms in these molecules.\n- Grouping by element and counting distinct molecule occurrences.\n- Ordering by the count and limiting the result to the first row (the least common element).",
            "To determine the least common element among all carcinogenic molecules, the following steps are executed in the SQL query:\n\n1. **Filter Carcinogenic Molecules**: The query starts by selecting all molecules from the `molecule` table where the `label` is '+', indicating they are carcinogenic.\n\n2. **Join with Atom Data**: Each carcinogenic molecule is then joined with the `atom` table using the `molecule_id` as the linking key. This retrieves all atoms that belong to these carcinogenic molecules.\n\n3. **Group by Element**: The resulting dataset is grouped by the `element` column from the `atom` table. This groups all atoms by their elemental type.\n\n4. **Count Distinct Molecules per Element**: For each element, the query counts the number of distinct `molecule_id` values. This count represents how many unique carcinogenic molecules contain that particular element.\n\n5. **Order by Count**: The elements are then ordered in ascending order based on their respective counts. This ensures that the element with the smallest count (i.e., the least common element) appears first in the result set.\n\n6. **Select the Least Common Element**: Finally, the query limits the result to the first row, which corresponds to the element with the smallest count, thereby identifying the least common element among all carcinogenic molecules.\n\nThe SQL query effectively combines these operations to answer the question by filtering, joining, grouping, counting, ordering, and limiting the results."
        ]
    },
    "594": {
        "sql": "SELECT u.Id, u.Reputation FROM users u JOIN posts p ON u.Id = p.OwnerUserId WHERE p.Id = 1;",
        "question": "Which user created post ID 1 and what is the reputation of this user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Id, T2.Reputation FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.PostId = 1",
        "explain": "",
        "solution": [
            "To find out which user created post ID 1 and what the reputation of this user is, follow these steps:\n\n1. **Identify the tables involved**: The query involves two tables, `comments` (referred to as `T1`) and `users` (referred to as `T2`).\n\n2. **Understand the join condition**: The query joins the `comments` table (`T1`) with the `users` table (`T2`) using the condition `T1.UserId = T2.Id`. This means it matches each comment to the user who made it based on the `UserId` in the `comments` table and the `Id` in the `users` table.\n\n3. **Apply the filter condition**: The query filters the results to only include comments where the `PostId` is equal to 1 (`T1.PostId = 1`). This narrows down the comments to those associated with post ID 1.\n\n4. **Select the required columns**: The query selects the `Id` and `Reputation` columns from the `users` table (`T2`). This retrieves the user's ID and their reputation score.\n\n5. **Result**: The final result will be the ID and reputation of the user who created the comment on post ID 1."
        ]
    },
    "806": {
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.full_name = 'Karen Beecher-Duncan';",
        "question": "Provide the eye colour of the superhero who has Karen Beecher-Duncan as their full name.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Karen Beecher-Duncan'",
        "explain": "eye colour refers to colour.colour where eye_colour_id = colour.id; Karen Beecher-Duncan is the full name of superhero;",
        "solution": []
    },
    "1441": {
        "sql": "SELECT COUNT(T1.member_id) AS member_count\nFROM member T1\nJOIN major T2 ON T2.major_id = T1.link_to_major\nWHERE T1.position = 'Member'\nAND T2.major_name LIKE '%Education%'\nAND T2.college = 'College of Education & Human Services';",
        "question": "How many members have education major in the College of Education & Human Services?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member' AND T2.major_name LIKE '%Education%' AND T2.college = 'College of Education & Human Services'",
        "explain": "'education' is the major name; 'Member' is a position of club;",
        "solution": [
            "To solve the question \"How many members have education major in the College of Education & Human Services?\", the following steps are performed:\n\n1. **Identify the relevant tables**: The query involves two tables, `member` (aliased as `T1`) and `major` (aliased as `T2`).\n\n2. **Join the tables**: The `member` table is joined with the `major` table using the condition `T2.major_id = T1.link_to_major`. This links each member to their respective major.\n\n3. **Apply filters**:\n   - Filter members where the `position` is 'Member'.\n   - Filter majors where the `major_name` contains the word 'Education' (using `LIKE '%Education%'`).\n   - Filter majors where the `college` is exactly 'College of Education & Human Services'.\n\n4. **Count the results**: The query counts the number of `member_id` entries that meet all the above conditions, giving the total number of members with an education major in the specified college."
        ]
    },
    "1263": {
        "sql": "SELECT E.ID\nFROM Examination E\nJOIN Laboratory L ON E.ID = L.ID\nWHERE L.HCT <= 29 OR L.HCT >= 52\nORDER BY E.`aCL IgA` DESC\nLIMIT 1;",
        "question": "Among the patients whose level of Hematoclit isn't normal, which patient has the highest anti-Cardiolipin antibody concentration? Please list his or her ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 on T1.ID = T3.ID WHERE (T3.HCT >= 52 OR T3.HCT <= 29) ORDER BY T2.`aCL IgA` DESC LIMIT 1",
        "explain": "Hematoclit is normal refers to 29 < N < 52; highest anti-Cardiolipin antibody concentration refers to MAX(`aCL IgA`);",
        "solution": []
    },
    "765": {
        "sql": "SELECT COUNT(DISTINCT hero_id) AS hero_count FROM hero_power T1 JOIN superpower T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth';",
        "question": "How many heroes have stealth power?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'",
        "explain": "stealth power refers to power_name = 'stealth';",
        "solution": [
            "To determine how many heroes have the stealth power, follow these steps:\n1. **Join the Tables**: Combine the `hero_power` table (aliased as `T1`) with the `superpower` table (aliased as `T2`) using the `power_id` from `hero_power` and the `id` from `superpower`.\n2. **Filter for Stealth Power**: From the joined tables, filter the records to only include those where the `power_name` in the `superpower` table is 'Stealth'.\n3. **Count the Heroes**: Count the number of distinct `hero_id` entries from the `hero_power` table that meet the filtered condition.\n\nThe result will be the total number of heroes who possess the stealth power."
        ]
    },
    "1394": {
        "sql": "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Physics Teaching';",
        "question": "How many members of the Student_Club have major in 'Physics Teaching'?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Physics Teaching'",
        "explain": "'Physics Teaching' is the major_name;",
        "solution": []
    },
    "368": {
        "sql": "SELECT (COUNT(CASE WHEN borderColor = 'borderless' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_borderless_cards FROM cards;",
        "question": "What is the percentage of borderless cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "explain": "borderless card refers to borderColor = 'borderless'; percentage = Divide(Count (id) where borderColor = 'borderless', Count(id)) *100",
        "solution": []
    },
    "588": {
        "sql": "SELECT COUNT(*) AS TotalComments FROM comments WHERE UserId = 13;",
        "question": "Give the total number of comments posted by user ID 13.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13",
        "explain": "",
        "solution": []
    },
    "1448": {
        "sql": "SELECT e.event_name, e.event_date\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense ex ON b.budget_id = ex.link_to_budget\nWHERE ex.expense_description LIKE '%pizza%'\nAND ex.cost > 50\nAND ex.cost < 100;",
        "question": "Find the name and date of events with expenses for pizza that were more than fifty dollars but less than a hundred dollars.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name, T1.event_date FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.expense_description = 'Pizza' AND T3.cost > 50 AND T3.cost < 100",
        "explain": "name of event refers to event_name; date of event refers to event_date; expenses for pizza refers to expense_description = 'Pizza' where cost > 50 and cost < 100",
        "solution": []
    },
    "1299": {
        "sql": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL",
        "question": "Among the patients with the normal level of triglyceride, how many of them have other symptoms observed?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL",
        "explain": "normal level of triglyceride refers to TG < 200; have other symptoms refers to Symptoms is not null;",
        "solution": [
            "To solve the question, we need to perform the following operations:\n\n1. **Join the Examination and Laboratory tables**: Combine the data from the `Examination` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) using the `ID` field as the common key.\n\n2. **Filter patients with normal triglyceride levels**: From the joined data, select only those records where the triglyceride level (`TG`) in the `Laboratory` table is less than 200, indicating a normal level.\n\n3. **Filter patients with observed symptoms**: Further refine the filtered data to include only those patients who have non-null entries in the `Symptoms` column of the `Examination` table.\n\n4. **Count the qualifying patients**: Finally, count the number of unique patient IDs (`ID`) that meet both the triglyceride and symptoms criteria.\n\nThe result will be the count of patients who have normal triglyceride levels and also exhibit other symptoms.",
            "To solve the question, we need to perform the following operations:\n\n1. **Join the Examination and Laboratory tables**: Combine the data from the `Examination` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) using the `ID` field as the common key. This ensures that we have both the symptom data from the `Examination` table and the triglyceride level data from the `Laboratory` table for each patient.\n\n2. **Filter patients with normal triglyceride levels**: From the joined data, select only those records where the triglyceride level (`TG`) in the `Laboratory` table is less than 200. This condition (`T2.TG < 200`) identifies patients with normal triglyceride levels.\n\n3. **Filter patients with observed symptoms**: Further refine the filtered data to include only those patients who have non-null entries in the `Symptoms` column of the `Examination` table. This condition (`T1.Symptoms IS NOT NULL`) ensures that we only count patients with recorded symptoms.\n\n4. **Count the qualifying patients**: Finally, count the number of unique patient IDs (`ID`) from the `Examination` table that meet both the triglyceride and symptoms criteria. The result will be the count of patients who have normal triglyceride levels and also exhibit other symptoms.\n\nThe SQL query `SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL` precisely performs these operations to answer the question."
        ]
    },
    "1229": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.TG >= 200 \nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 50;",
        "question": "For all patients with triglyceride (TG) level beyond the normal range, how many are age more than 50 years?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200 AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 50",
        "explain": "triglyceride (TG) level beyond the normal range refers to TG > = 200; more than 50 years of age = SUBTRACT(year(current_timestamp), year(Birthday)) > 50; Should consider DISTINCT in the final result;",
        "solution": []
    },
    "1089": {
        "sql": "SELECT COUNT(*) AS number_of_matches\nFROM Match\nWHERE season = '2008/2009'\nAND country_id = (SELECT id FROM Country WHERE name = 'Belgium');",
        "question": "How many matches in the 2008/2009 season were held in Belgium?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Belgium' AND t2.season = '2008/2009'",
        "explain": "Belgium refers to Country.name = 'Belgium';",
        "solution": []
    },
    "488": {
        "sql": "SELECT code FROM sets WHERE releaseDate = '2017-07-14';",
        "question": "What's the code for the set which was released on 2017/7/14?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT code FROM sets WHERE releaseDate = '2017-07-14' GROUP BY releaseDate, code",
        "explain": "released on 2017/7/14 refers to releaseDate = '2017-07-14'",
        "solution": []
    },
    "1323": {
        "sql": "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nWHERE e.type != 'fundraiser'\nGROUP BY e.event_id\nHAVING COUNT(a.link_to_member) > 20;",
        "question": "List all the names of events that had an attendance of over 20 students but were not fundraisers.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id HAVING COUNT(T2.link_to_event) > 20 EXCEPT SELECT T1.event_name FROM event AS T1  WHERE T1.type = 'Fundraiser'",
        "explain": "name of events refers to event_name; attendance of over 20 students COUNT(event_id) > 20.",
        "solution": []
    },
    "443": {
        "sql": "SELECT DISTINCT s.code FROM sets s JOIN set_translations st ON s.code = st.setCode WHERE s.type = 'expansion';",
        "question": "Give the code of sets have expansion type of 'expansion'?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'expansion' GROUP BY T2.setCode",
        "explain": "code of sets refers to setCode",
        "solution": [
            "To solve the question \"Give the code of sets that have an expansion type of 'expansion',\" the following operations are performed:\n\n1. **Join the tables**: The `sets` table (referred to as T1) is joined with the `set_translations` table (referred to as T2) using the condition that the `setCode` column in T2 matches the `code` column in T1.\n\n2. **Filter the data**: Only rows where the `type` column in T1 is equal to 'expansion' are selected.\n\n3. **Group the results**: The results are grouped by the `setCode` column from T2 to ensure each set code is listed only once.\n\n4. **Select the output**: The `setCode` column from T2 is selected as the final output, which gives the codes of the sets that meet the criteria."
        ]
    },
    "1450": {
        "sql": "SELECT DISTINCT z.city, z.county\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE i.amount > 40;",
        "question": "In the events with more than forty incomes, list the city and country in which the event is happening.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.city, T3.county FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip WHERE T1.amount > 40",
        "explain": "more than fifty incomes refers to income > 40",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Filter Incomes**: First, filter the `income` table to include only those records where the `amount` is greater than 40. This ensures we only consider incomes that meet the specified condition.\n\n2. **Join with Member Table**: Next, join the filtered `income` table (referred to as `T1`) with the `member` table (referred to as `T2`). The join condition is that the `link_to_member` field in the `income` table matches the `member_id` field in the `member` table. This links each income record to its corresponding member.\n\n3. **Join with Zip Code Table**: Then, join the result from the previous step with the `zip_code` table (referred to as `T3`). The join condition is that the `zip_code` field in the `member` table matches the `zip_code` field in the `zip_code` table. This links each member to their respective city and county.\n\n4. **Select Distinct City and County**: Finally, select the distinct combinations of `city` and `county` from the `zip_code` table. This ensures that each unique city and county pair is listed only once in the result, even if multiple events in the same location meet the income condition.\n\nThe result is a list of cities and counties where events with incomes greater than 40 are happening."
        ]
    },
    "1519": {
        "sql": "SELECT ProductID FROM transactions_1k WHERE Date = '2012-08-23' AND Time = '21:20:00';",
        "question": "What was the product id of the transaction happened at 2012/8/23 21:20:00?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.ProductID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'",
        "explain": "'2012/8/23 21:20:00' can refer to date = '2012-08-23' AND T1.time = '21:20:00' in the database",
        "solution": []
    },
    "22": {
        "sql": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1;",
        "question": "Which school in Contra Costa has the highest number of test takers?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1",
        "explain": "",
        "solution": [
            "1. **Filtering by county and non-null school names:**  \n   The query starts by filtering the `satscores` table to include only records where the county name (`cname`) is 'Contra Costa' and the school name (`sname`) is not null. This ensures that the results are specific to Contra Costa and exclude any entries with missing school names.\n\n2. **Selecting the school name:**  \n   From the filtered records, the query selects the column `sname`, which represents the name of the school. This is the primary information requested by the question.\n\n3. **Ordering by the number of test takers:**  \n   The results are ordered based on the column `NumTstTakr` in descending order (`DESC`). This ensures that the school with the highest number of test takers appears at the top of the list.\n\n4. **Limiting to the top result:**  \n   The query applies a `LIMIT 1` clause, which restricts the output to only the first record. This guarantees that only the school with the highest number of test takers in Contra Costa is returned."
        ]
    },
    "1401": {
        "sql": "SELECT e.cost\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'September Speaker' AND (b.category = 'posters' OR e.expense_description LIKE '%posters%');",
        "question": "Indicate the cost of posters for 'September Speaker' event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Posters'",
        "explain": "'Posters' is the expense description; 'September Speaker' is an event name",
        "solution": []
    },
    "968": {
        "sql": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';",
        "question": "What is reference name of Robert Kubica?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica'",
        "explain": "reference name refers to driverRef;",
        "solution": []
    },
    "930": {
        "sql": "WITH lewis_id AS (\n    SELECT driverId\n    FROM drivers\n    WHERE forename = 'Lewis' AND surname = 'Hamilton'\n),\nhighest_rank_races AS (\n    SELECT r.raceId, r.name\n    FROM results res\n    JOIN races r ON res.raceId = r.raceId\n    JOIN lewis_id l ON res.driverId = l.driverId\n    WHERE res.rank = 1\n)\nSELECT name\nFROM highest_rank_races;",
        "question": "In which Formula_1 race did Lewis Hamilton rank the highest?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE raceId IN ( SELECT raceId FROM results WHERE rank = 1 AND driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) )",
        "explain": "rank the highest refers to min(rank); Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "solution": [
            "To find out in which Formula 1 race Lewis Hamilton ranked the highest, follow these steps:\n\n1. **Identify Lewis Hamilton's Driver ID**: First, locate the unique identifier (driverId) for Lewis Hamilton in the drivers table. This is done by searching for a driver with the forename 'Lewis' and surname 'Hamilton'.\n\n2. **Find Races Where He Ranked Highest**: Using the driverId obtained in the first step, search the results table for all races where Lewis Hamilton achieved the highest rank (rank = 1). This will give you the raceId(s) of the races where he ranked first.\n\n3. **Retrieve Race Names**: Finally, use the raceId(s) from the previous step to fetch the names of the corresponding races from the races table.\n\nThis sequence of operations ensures that you accurately identify the Formula 1 races where Lewis Hamilton secured the highest rank."
        ]
    },
    "419": {
        "sql": "SELECT COUNT(*) FROM cards WHERE borderColor = 'borderless' AND edhrecRank > 12000;",
        "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
        "explain": "color cards with no borders refers to borderColor = 'borderless'; ranked higher than 12000 on EDHRec refers to edhrecRank > 12000",
        "solution": []
    },
    "20": {
        "sql": "SELECT COUNT(DISTINCT CDSCode) \nFROM frpm \nWHERE `County Name` = 'Amador' \nAND `Low Grade` = '9' \nAND `High Grade` = '12';",
        "question": "How many schools in Amador which the Low Grade is 9 and the High Grade is 12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.`School Name`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Amador' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12",
        "explain": "",
        "solution": []
    },
    "599": {
        "sql": "SELECT ph.PostHistoryTypeId, (SELECT COUNT(DISTINCT c.UserId) FROM comments c WHERE c.PostId = 3720) AS NumberOfUsers FROM postHistory ph WHERE ph.PostId = 3720;",
        "question": "What are the post history type IDs for post ID 3720 and how many unique users have commented on the post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory AS T1 WHERE T1.PostId = 3720",
        "explain": "",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Retrieve Post History Type IDs**: The database is queried to fetch all `PostHistoryTypeId` values from the `postHistory` table where the `PostId` is 3720.\n\n2. **Count Unique Commenting Users**: A subquery is executed to count the distinct `UserId` values from the `comments` table where the `PostId` is 3720. This count is labeled as `NumberOfUsers`.\n\n3. **Combine Results**: The results from the first query (PostHistoryTypeId) and the subquery (NumberOfUsers) are combined into a single result set.\n\nThis solution ensures that all post history type IDs for post ID 3720 are listed alongside the count of unique users who have commented on the post."
        ]
    },
    "245": {
        "sql": "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) AS average_bonds_per_iodine_atom\nFROM atom T1\nLEFT JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'i';",
        "question": "What is the average number of bonds the atoms with the element iodine have?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'i'",
        "explain": "atoms with the element iodine refers to element = 'i'; average = DIVIDE(COUND(bond_id), COUNT(atom_id)) where element = 'i'",
        "solution": [
            "To find the average number of bonds for atoms with the element iodine, follow these steps:\n\n1. **Filter the atoms**: Identify all atoms in the `atom` table where the element is iodine ('i').\n2. **Join with connected bonds**: For each iodine atom, find all bonds connected to it by joining the `atom` table with the `connected` table on the `atom_id` field.\n3. **Count the bonds**: For each iodine atom, count the number of bonds it has.\n4. **Calculate the average**: Divide the total number of bonds by the total number of iodine atoms to get the average number of bonds per iodine atom.\n\nThe SQL query performs these operations by:\n- Counting the total number of bonds (`COUNT(T2.bond_id)`).\n- Counting the total number of iodine atoms (`COUNT(T1.atom_id)`).\n- Dividing the total bonds by the total atoms (using `CAST` to ensure real division).",
            "To determine the average number of bonds for atoms with the element iodine, the following steps are executed in the SQL query:\n\n1. **Filter iodine atoms**: The query starts by selecting all rows from the `atom` table (aliased as `T1`) where the `element` column is equal to 'i' (iodine).\n\n2. **Join with connected bonds**: The query then joins the filtered `atom` table (`T1`) with the `connected` table (aliased as `T2`) using the `atom_id` column. This join ensures that only bonds connected to iodine atoms are considered.\n\n3. **Count bonds and atoms**: The query counts the total number of bonds (`COUNT(T2.bond_id)`) and the total number of iodine atoms (`COUNT(T1.atom_id)`).\n\n4. **Calculate the average**: The total number of bonds is cast to a real number (`CAST(COUNT(T2.bond_id) AS REAL)`) to ensure real division, and then divided by the total number of iodine atoms to compute the average number of bonds per iodine atom.\n\nThe SQL query succinctly combines these steps into a single operation to produce the desired result."
        ]
    },
    "620": {
        "sql": "SELECT u.Views\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Date = '2010-07-19 19:39:08.0';",
        "question": "State the number of views of users who obtained the badge on 7/19/2010 7:39:08 PM.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Views FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'",
        "explain": "on 7/19/2010 7:39:08 PM refers to Date = '2010-07-19 19:39:08.0'",
        "solution": []
    },
    "296": {
        "sql": "SELECT T2.molecule_id, T2.bond_id, T1.atom_id\nFROM connected T1\nJOIN bond T2 ON T1.bond_id = T2.bond_id\nWHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2';",
        "question": "Indicate the molecule id is belonging to the TR000_1_2 bond that has the first atom named TR000_1.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.molecule_id, T2.bond_id, T1.atom_id FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'",
        "explain": "",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: The `connected` table (aliased as `T1`) is joined with the `bond` table (aliased as `T2`) using the `bond_id` column. This ensures that only records with matching `bond_id` values in both tables are considered.\n\n2. **Filter by Atom ID**: From the joined tables, only the records where the `atom_id` in the `connected` table (`T1.atom_id`) is equal to 'TR000_1' are selected.\n\n3. **Filter by Bond ID**: Additionally, only the records where the `bond_id` in the `bond` table (`T2.bond_id`) is equal to 'TR000_1_2' are selected.\n\n4. **Select Columns**: Finally, the query retrieves the `molecule_id` and `bond_id` from the `bond` table (`T2.molecule_id` and `T2.bond_id`), and the `atom_id` from the `connected` table (`T1.atom_id`).\n\nThis sequence of operations ensures that the result includes the molecule ID belonging to the bond 'TR000_1_2' where the first atom is named 'TR000_1'."
        ]
    },
    "577": {
        "sql": "SELECT c.Text FROM comments c JOIN users u ON c.UserId = u.Id WHERE u.DisplayName = 'A Lion';",
        "question": "Write all comments made by user 'A Lion.'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Text FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'A Lion'",
        "explain": "\"A Lion\" is the DisplayName of user; comment refers to Text",
        "solution": []
    },
    "318": {
        "sql": "SELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';",
        "question": "What is the molecule id of bond id TR001_1_7?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "explain": "",
        "solution": []
    },
    "988": {
        "sql": "SELECT T2.forename, T2.surname, AVG(T1.duration) AS avg_pit_stop_duration\nFROM pitStops T1\nJOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985'\nGROUP BY T2.forename, T2.surname\nORDER BY avg_pit_stop_duration ASC\nLIMIT 3;",
        "question": "List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3",
        "explain": "Full name of the driver refers to drivers.forename and drivers.surname; born between 1980-1985 refers to 1980< year(dob)>1985; Average pitstop duration refers to Divide(SUM(duration),COUNT(duration)); shortest average refers to Min(avg(duration));",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Join the Tables**: Combine the `pitStops` table (referred to as `T1`) with the `drivers` table (referred to as `T2`) using the `driverId` field to link them.\n\n2. **Filter by Nationality and Birth Year**: From the combined data, filter out only those drivers who have the nationality 'German' and were born between the years 1980 and 1985. This is done by checking the `nationality` field and the `dob` (date of birth) field in the `drivers` table.\n\n3. **Group by Driver Names**: Group the filtered data by the `forename` and `surname` fields of the drivers to ensure each driver's data is aggregated correctly.\n\n4. **Calculate Average Pit Stop Duration**: For each driver, calculate the average duration of their pit stops from the `pitStops` table.\n\n5. **Order by Average Duration**: Sort the grouped data in ascending order based on the calculated average pit stop duration to find the drivers with the shortest average pit stop times.\n\n6. **Limit the Results**: Finally, limit the results to the top 3 drivers with the shortest average pit stop durations.\n\nThe SQL query accomplishes all these steps to return the forenames and surnames of the top 3 German drivers born between 1980 and 1985 with the shortest average pit stop durations.",
            "To solve the question, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `pitStops` table (aliased as `T1`) and the `drivers` table (aliased as `T2`) using the `driverId` field as the common key. This ensures that only records with matching `driverId` values in both tables are included.\n\n2. **Filter by Nationality and Birth Year**: Apply a filter to the joined data to include only those drivers who meet the following criteria:\n   - Their `nationality` field in the `drivers` table (`T2`) must be 'German'.\n   - Their `dob` (date of birth) field in the `drivers` table (`T2`) must fall between the years 1980 and 1985. This is checked using the `STRFTIME('%Y', T2.dob)` function to extract the year from the date of birth.\n\n3. **Group by Driver Names**: Group the filtered data by the `forename` and `surname` fields of the `drivers` table (`T2`). This ensures that the subsequent calculations (average pit stop duration) are performed for each unique driver.\n\n4. **Calculate Average Pit Stop Duration**: For each grouped driver, compute the average of the `duration` field from the `pitStops` table (`T1`). This gives the average time each driver spent during pit stops.\n\n5. **Order by Average Duration**: Sort the grouped and aggregated data in ascending order based on the calculated average pit stop duration. This places the drivers with the shortest average pit stop times at the top of the list.\n\n6. **Limit the Results**: Restrict the output to only the top 3 records from the sorted list, which correspond to the 3 German drivers born between 1980 and 1985 with the shortest average pit stop durations.\n\nThe SQL query effectively combines these operations to return the `forename` and `surname` of the top 3 qualifying drivers."
        ]
    },
    "642": {
        "sql": "SELECT COUNT(Id) AS PostCount FROM posts WHERE DATE(CreaionDate) = '2010-07-21';",
        "question": "How many posts were created on 21st July, 2010?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'",
        "explain": "created on 21st July, 2010 refers to CreationDate BETWEEN '2010-07-21 00:00:00' and '2012-07-21 23:59:59';",
        "solution": [
            "To determine how many posts were created on 21st July, 2010, follow these steps:\n\n1. **Access the Data**: Retrieve data from the `postHistory` table, which contains records of posts along with their creation dates.\n\n2. **Filter by Date**: Focus only on the posts where the `CreationDate` matches the date '2010-07-21'. This involves converting the `CreationDate` to a date format (ignoring any time component) and comparing it to the specified date.\n\n3. **Count the Posts**: Count the number of post IDs (`id`) that meet the filtered criteria. This will give the total number of posts created on 21st July, 2010.\n\nThe result will be a single number representing the count of posts created on that specific date.",
            "To determine how many posts were created on 21st July, 2010, follow these steps:\n\n1. **Access the Data**: Retrieve data from the `postHistory` table, which contains records of posts along with their creation dates.\n\n2. **Filter by Date**: Focus only on the posts where the `CreationDate` matches the date '2010-07-21'. This involves converting the `CreationDate` to a date format (ignoring any time component) and comparing it to the specified date.\n\n3. **Count the Posts**: Count the number of post IDs (`id`) that meet the filtered criteria. This will give the total number of posts created on 21st July, 2010.\n\nThe result will be a single number representing the count of posts created on that specific date."
        ]
    },
    "414": {
        "sql": "SELECT st.language\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Ravnica' AND s.baseSetSize = 180;",
        "question": "What language is the set of 180 cards that belongs to the Ravnica block translated into?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Ravnica' AND T1.baseSetSize = 180",
        "explain": "set of 180 cards refers to baseSetSize = 180",
        "solution": []
    },
    "403": {
        "sql": "WITH total_cards AS (\n    SELECT COUNT(*) AS total_count\n    FROM foreign_data\n),\nspanish_cards AS (\n    SELECT COUNT(*) AS spanish_count\n    FROM foreign_data\n    WHERE language = 'Spanish'\n)\nSELECT \n    (spanish_cards.spanish_count * 100.0 / total_cards.total_count) AS percentage_spanish,\n    fd.name AS spanish_card_name\nFROM \n    foreign_data fd, \n    total_cards, \n    spanish_cards\nWHERE \n    fd.language = 'Spanish';",
        "question": "Calculate the percentage of cards in Spanish. List them by name.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
        "explain": "Spanish refer to language; Percentage refer to DIVIDE(SUM(ID where language = 'Spanish'), COUNT(id))*100",
        "solution": [
            "To calculate the percentage of cards in Spanish and list them by name, follow these steps:\n\n1. **Count the total number of cards in the `foreign_data` table.**\n2. **Count the number of cards where the language is 'Spanish'.**\n3. **Calculate the percentage of Spanish cards by dividing the count of Spanish cards by the total count of cards and multiplying by 100.**\n4. **List the names of all cards where the language is 'Spanish'.**\n\nThe SQL query performs these operations by:\n- Using a subquery to calculate the percentage of Spanish cards.\n- Selecting the calculated percentage and the names of the Spanish cards from the `foreign_data` table where the language is 'Spanish'."
        ]
    },
    "959": {
        "sql": "SELECT T1.fastestLap\nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2009\nAND T1.time LIKE '_:%:__.___'\nORDER BY T1.fastestLap ASC\nLIMIT 1;",
        "question": "What is the fastest lap number of the champion in 2009?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "explain": "in 2009 refers to year = 2009; Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\"",
        "solution": [
            "To find the fastest lap number of the champion in 2009, follow these steps:\n\n1. **Join the tables**: Combine the `results` table (aliased as `T1`) with the `races` table (aliased as `T2`) using the `raceId` column as the common key.\n\n2. **Filter by year**: From the joined tables, select only those records where the year (`T2.year`) is 2009.\n\n3. **Filter by time format**: Further filter the results to include only those records where the time (`T1.time`) matches the pattern '_:%:__.___', which represents a valid lap time format.\n\n4. **Retrieve the fastest lap**: Finally, extract the `fastestLap` column from the filtered results to get the fastest lap number of the champion in 2009.",
            "To determine the fastest lap number of the champion in 2009, the following steps are executed in the database:\n\n1. **Join the `results` and `races` tables**: The `results` table (aliased as `T1`) is joined with the `races` table (aliased as `T2`) using the `raceId` column as the common key. This ensures that each result record is linked to its corresponding race record.\n\n2. **Filter for the year 2009**: From the joined tables, only the records where the `year` column (from the `races` table, `T2.year`) equals 2009 are selected. This narrows down the data to only those races that occurred in 2009.\n\n3. **Filter for valid lap times**: The results are further refined to include only those records where the `time` column (from the `results` table, `T1.time`) matches the pattern '_:%:__.___'. This pattern ensures that the time is in a valid lap time format (e.g., '1:23.456').\n\n4. **Retrieve the fastest lap number**: Finally, the `fastestLap` column (from the `results` table, `T1.fastestLap`) is selected to obtain the fastest lap number of the champion in 2009."
        ]
    },
    "654": {
        "sql": "SELECT u.DisplayName, u.Location\nFROM tags t\nJOIN posts p ON t.ExcerptPostId = p.Id\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE t.TagName = 'hypothesis-testing';",
        "question": "Mention the display name and location of the user who owned the excerpt post with hypothesis-testing tag.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.DisplayName, T3.Location FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id INNER JOIN users AS T3 ON T3.Id = T2.OwnerUserId WHERE T1.TagName = 'hypothesis-testing'",
        "explain": "user who owned the excerpt post with hypothesis-testing tag refers to OwnerUserId WHERE TagName = 'hypothesis-testing';",
        "solution": []
    },
    "380": {
        "sql": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "question": "List the edhrecRank for cards with frame version 2015.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "explain": "",
        "solution": []
    },
    "1379": {
        "sql": "SELECT COUNT(*) FROM event WHERE type = 'Meeting' AND event_date LIKE '%2020%';",
        "question": "How many meeting events were held in 2020?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(event_id) FROM event WHERE type = 'Meeting' AND SUBSTR(event_date, 1, 4) = '2020'",
        "explain": "meeting events refers to type = 'Meeting'; held in 2020 refers to YEAR(event_date) = 2020",
        "solution": []
    },
    "340": {
        "sql": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
        "error": "something went wrong, tool did not call.",
        "question": "Which are the cards that have incredibly powerful foils.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
        "explain": "incredibly poweful foils refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
        "solution": [
            "To find the cards that have incredibly powerful foils, the database operation involves querying the 'cards' table. The solution retrieves the 'id' of all cards where both 'cardKingdomFoilId' and 'cardKingdomId' fields are not null. This ensures that the cards have entries in both foil and non-foil versions, indicating their powerful foil status.",
            "To identify the cards that have incredibly powerful foils, the database operation involves querying the 'cards' table. The solution retrieves the 'id' of all cards where both the 'cardKingdomFoilId' and 'cardKingdomId' fields are not null. This ensures that the cards have entries in both foil and non-foil versions, indicating their powerful foil status. The SQL query used is: `SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL`."
        ]
    },
    "1023": {
        "sql": "SELECT COUNT(*) AS number_of_players\nFROM Player_Attributes\nWHERE overall_rating BETWEEN 60 AND 65\nAND defensive_work_rate = 'low';",
        "question": "Among the players with an overall rating between 60 to 65, how many players whose going to be in all of your attack moves instead of defensing?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player_Attributes WHERE overall_rating BETWEEN 60 AND 65 AND defensive_work_rate = 'low'",
        "explain": "overall_rating > = 60 AND overall_rating < 65; players whose going to be in all of your attack moves instead of defensing refers to defensive_work_rate = 'low';",
        "solution": []
    },
    "1414": {
        "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Phillip' AND mb.last_name = 'Cullen';",
        "question": "State the name of major that Phillip Cullen has joined.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "explain": "name of major refers to major_name",
        "solution": []
    },
    "173": {
        "sql": "SELECT T1.frequency, T2.k_symbol\nFROM account AS T1\nJOIN (\n    SELECT account_id, k_symbol, SUM(amount) AS total_amount\n    FROM `order`\n    GROUP BY account_id, k_symbol\n) AS T2 ON T1.account_id = T2.account_id\nWHERE T1.account_id = 3 AND T2.total_amount = 3539;",
        "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
        "explain": "k_symbol refers to the purpose of payments",
        "solution": [
            "To answer the question, the database performs the following operations:\n\n1. **Join Tables**: The `account` table (aliased as T1) is joined with a subquery result (aliased as T2). The subquery aggregates data from the `order` table.\n\n2. **Subquery Operations**: The subquery (T2) does the following:\n   - Groups records in the `order` table by `account_id` and `k_symbol`.\n   - Calculates the sum of the `amount` column for each group, naming the result `total_amount`.\n\n3. **Join Condition**: The join is performed where the `account_id` in T1 matches the `account_id` in T2.\n\n4. **Filtering**: The combined result is filtered to include only records where:\n   - The `account_id` in T1 is 3.\n   - The `total_amount` in T2 equals 3539.\n\n5. **Select Columns**: Finally, the query selects the `frequency` column from T1 and the `k_symbol` column from T2 for the filtered records.\n\nThis operation retrieves the frequency of account statements requested by account number 3 and identifies the purpose (k_symbol) of debiting a total of 3539."
        ]
    },
    "1305": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) AS Normal_WBC_Patients\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '+' AND T2.WBC BETWEEN 3.5 AND 9;",
        "question": "How many patients accepted to the hospital have a normal level of white blood cells?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC BETWEEN 3.5 AND 9 AND T1.Admission = '+'",
        "explain": "accepted to the hospital refers to Admission = '+'; normal level of white blood cells refers to WBC between 3.5 and 9.0;",
        "solution": [
            "To determine how many patients admitted to the hospital have a normal level of white blood cells, follow these steps:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (aliased as `T1`): Contains patient information, including their admission status.\n   - `Laboratory` (aliased as `T2`): Contains laboratory test results, including white blood cell (WBC) levels.\n\n2. **Join the Tables**: The query joins the `Patient` and `Laboratory` tables using the `ID` column to link each patient to their laboratory results.\n\n3. **Filter for Admitted Patients**: The query filters the `Patient` table to include only those patients where the `Admission` column has a value of `'+'`, indicating they were admitted to the hospital.\n\n4. **Filter for Normal WBC Levels**: The query filters the `Laboratory` table to include only those records where the `WBC` (white blood cell) level is between 3.5 and 9, which is considered the normal range.\n\n5. **Count the Patients**: Finally, the query counts the number of patients who meet both criteria (admitted to the hospital and having a normal WBC level).\n\nThe result is the total count of such patients.",
            "To determine how many patients admitted to the hospital have a normal level of white blood cells, follow these detailed steps:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (aliased as `T1`): Contains patient information, including their admission status (`Admission` column).\n   - `Laboratory` (aliased as `T2`): Contains laboratory test results, including white blood cell (WBC) levels (`WBC` column).\n\n2. **Join the Tables**: The query performs an inner join between the `Patient` table (`T1`) and the `Laboratory` table (`T2`) using the `ID` column as the join key. This ensures that only patients with corresponding laboratory results are included.\n\n3. **Filter for Admitted Patients**: The query filters the `Patient` table (`T1`) to include only those patients where the `Admission` column has a value of `'+'`. This indicates that the patient was admitted to the hospital.\n\n4. **Filter for Normal WBC Levels**: The query filters the `Laboratory` table (`T2`) to include only those records where the `WBC` level falls within the range of 3.5 to 9. This range is considered normal for white blood cell levels.\n\n5. **Count the Patients**: The query then counts the number of distinct patient IDs (`T1.ID`) that meet both criteria:\n   - The patient was admitted to the hospital (`T1.Admission = '+'`).\n   - The patient has a normal WBC level (`T2.WBC BETWEEN 3.5 AND 9`).\n\nThe final result is the total count of such patients."
        ]
    },
    "1350": {
        "sql": "SELECT T1.event_status FROM budget T1 JOIN expense T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20';",
        "question": "What is the status of the event which bought \"Post Cards, Posters\" on 2019/8/20?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'",
        "explain": "'Post Cards, Posters' is an expense description; on 2019/8/20 refers to expense_date = '2019-8-20'; status of event refers to event_status",
        "solution": [
            "To determine the status of the event where the expense was for \"Post Cards, Posters\" on August 20, 2019, follow these steps:\n\n1. **Identify the relevant tables**: The query involves two tables, `budget` (referred to as `T1`) and `expense` (referred to as `T2`).\n\n2. **Join the tables**: The tables are joined using the condition `T1.budget_id = T2.link_to_budget`. This means we are linking each expense record in the `expense` table to its corresponding budget record in the `budget` table.\n\n3. **Filter the expense records**: From the `expense` table (`T2`), filter for records where:\n   - The `expense_description` is \"Post Cards, Posters\".\n   - The `expense_date` is \"2019-08-20\".\n\n4. **Retrieve the event status**: For the filtered records, retrieve the `event_status` from the `budget` table (`T1`).\n\nThis process ensures that we find the status of the event associated with the specified expense on the given date."
        ]
    },
    "461": {
        "sql": "SELECT name FROM cards WHERE frameVersion = '2003' ORDER BY convertedManaCost DESC LIMIT 3;",
        "question": "Please list the names of the top 3 cards with the highest converted mana cost and have a 2003 card frame style.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM cards WHERE frameVersion = 2003 ORDER BY convertedManaCost DESC LIMIT 3",
        "explain": "name of cards refers to name; 2003 card frame style refers to frameVersion = '2003'",
        "solution": []
    },
    "1029": {
        "sql": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed DESC LIMIT 4",
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4",
        "explain": "speed in which attacks are put together refers to buildUpPlaySpeed;highest build up play speed refers to MAX(buildUpPlaySpeed)",
        "solution": [
            "To find the speed at which attacks are put together for the top 4 teams with the highest build-up play speed, follow these steps:\n\n1. **Retrieve Data**: Access the \"Team_Attributes\" table to get the build-up play speed values for all teams.\n2. **Join Tables**: Link the \"Team_Attributes\" table with the \"Team\" table using the \"team_api_id\" field to ensure the data corresponds to the correct teams.\n3. **Sort Data**: Order the results by the \"buildUpPlaySpeed\" column in ascending order to prioritize the highest values.\n4. **Limit Results**: Select only the top 4 records from the sorted list to focus on the teams with the highest build-up play speeds.\n5. **Display Results**: Output the \"buildUpPlaySpeed\" values for these top 4 teams.",
            "To determine the speed at which attacks are put together for the top 4 teams with the highest build-up play speed, follow these detailed steps:\n\n1. **Access the Team_Attributes Table**: Retrieve all records from the \"Team_Attributes\" table, which contains the \"buildUpPlaySpeed\" attribute for each team.\n\n2. **Join with the Team Table**: Perform an inner join between the \"Team_Attributes\" table (aliased as \"t1\") and the \"Team\" table (aliased as \"t2\") using the \"team_api_id\" field. This ensures that the build-up play speed data is correctly matched with the corresponding team names or identifiers.\n\n3. **Sort by Build-Up Play Speed**: Order the joined results by the \"buildUpPlaySpeed\" column in ascending order (ASC). This sorting prioritizes the highest values of build-up play speed, as ascending order will place the highest values at the top when the column is numeric.\n\n4. **Limit to Top 4 Teams**: Restrict the output to only the first 4 records from the sorted list. This focuses the results on the top 4 teams with the highest build-up play speeds.\n\n5. **Display the Build-Up Play Speed**: Finally, output the \"buildUpPlaySpeed\" values for these top 4 teams, providing the specific speeds at which their attacks are put together.\n\nThe SQL query for this operation is:\n```sql\nSELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4\n```"
        ]
    },
    "393": {
        "sql": "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'",
        "question": "On how many cards designed by John Avon is its foil non-powerful?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'",
        "explain": "John Avon refer to artist; foil poweful foils refers to cardKingdomId and cardKingdomFoildId is NOT NULL \n",
        "solution": [
            "To determine the number of cards designed by John Avon where the foil version is non-powerful, the following steps are taken:\n\n1. **Filter the cards**: Select all cards from the database where the artist is 'John Avon'.\n2. **Check for non-powerful foil**: From the filtered cards, further narrow down to those where either the `cardKingdomId` is NULL or the `cardKingdomFoilId` is NULL. This indicates that the foil version of the card is non-powerful.\n3. **Count the results**: Finally, count the number of cards that meet both criteria.\n\nThe SQL query `SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'` performs these operations to provide the answer."
        ]
    },
    "345": {
        "sql": "SELECT DISTINCT T2.status FROM legalities T2 JOIN cards T1 ON T2.uuid = T1.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL;",
        "question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL",
        "explain": "Artifact type of cards refers to types = 'Artifact'; card does not have multiple faces on the same card refers to side is NULL'; vintage play format refers to format = 'vintage';",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select** the distinct `status` values from the `legalities` table (referred to as `T2`).\n2. **Join** the `cards` table (referred to as `T1`) with the `legalities` table (`T2`) using the `uuid` field as the common key.\n3. **Filter** the results to include only those records where:\n   - The `type` field in the `cards` table (`T1`) is 'Artifact'.\n   - The `format` field in the `legalities` table (`T2`) is 'vintage'.\n   - The `side` field in the `cards` table (`T1`) is `NULL`, indicating that the card does not have multiple faces.\n\nThis ensures that the query retrieves the legal status for artifact-type cards that are single-faced (no multiple faces) in the 'vintage' play format."
        ]
    },
    "956": {
        "sql": "SELECT T2.forename, T2.surname FROM results T1 JOIN drivers T2 ON T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) > '1975' AND T1.rank = 2;",
        "question": "Which drivers born after 1975 have been ranked 2? Please give their forenames and surnames.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.forename, T2.surname FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) > '1975' AND T1.rank = 2",
        "explain": "born after 1975 refers to year(dob) >1975;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the tables**: The `results` table (referred to as T1) is joined with the `drivers` table (referred to as T2) using the `driverId` field. This ensures that each result record is linked to its corresponding driver record.\n\n2. **Filter by birth year**: The query filters the drivers to include only those whose birth year (extracted from the `dob` field in the `drivers` table) is after 1975. This is done using the `STRFTIME('%Y', T2.dob) > '1975'` condition.\n\n3. **Filter by rank**: The query further filters the results to include only those records where the `rank` field in the `results` table is equal to 2.\n\n4. **Select specific columns**: Finally, the query selects the `forename` and `surname` columns from the `drivers` table (T2) to display the names of the drivers who meet the specified criteria.\n\nThis sequence of operations ensures that the query retrieves the forenames and surnames of drivers born after 1975 who have been ranked 2 in any race."
        ]
    },
    "1279": {
        "sql": "SELECT \n    (COUNT(DISTINCT CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID END) * 100.0 / COUNT(DISTINCT T1.ID)) AS Percentage\nFROM \n    Patient T1\nJOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T2.GOT >= 60;",
        "question": "What is the percentage of patient who has a abnormal level of glutamic oxaloacetic transaminase level, yet he or she is diagnosed with SLE?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`GOT` >= 60",
        "explain": "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; percentage = MULTIPLY(DIVIDE(COUNT(ID WHERE GOT > = 60 AND Diagnosis = 'SLE'), COUNT(ID WHERE GOT > = 60)), 1.0);",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: Combine the `Patient` table (referred to as `T1`) and the `Laboratory` table (referred to as `T2`) using the `ID` column as the common key. This ensures that each patient's laboratory results are linked to their respective records.\n\n2. **Filter by GOT Level**: From the joined tables, filter out only those records where the `GOT` (Glutamic Oxaloacetic Transaminase) level in the `Laboratory` table is 60 or higher. This identifies patients with an abnormal level of GOT.\n\n3. **Count Total Patients**: Calculate the total number of patients who meet the above criteria (i.e., have a GOT level of 60 or higher).\n\n4. **Count SLE Patients**: Among the filtered patients, count how many have a diagnosis that includes the term \"SLE\" (Systemic Lupus Erythematosus). This is done by checking if the `Diagnosis` field in the `Patient` table contains the substring \"SLE\".\n\n5. **Calculate Percentage**: Divide the count of SLE patients by the total count of patients with abnormal GOT levels to determine the percentage of such patients diagnosed with SLE.\n\nThe final result is the percentage of patients with abnormal GOT levels who are also diagnosed with SLE.",
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: Combine the `Patient` table (referred to as `T1`) and the `Laboratory` table (referred to as `T2`) using the `ID` column as the common key. This ensures that each patient's laboratory results are linked to their respective records.\n\n2. **Filter by GOT Level**: From the joined tables, filter out only those records where the `GOT` (Glutamic Oxaloacetic Transaminase) level in the `Laboratory` table is 60 or higher. This identifies patients with an abnormal level of GOT.\n\n3. **Count Total Patients**: Calculate the total number of patients who meet the above criteria (i.e., have a GOT level of 60 or higher). This is done by counting all the `ID` values in the `Patient` table (`T1`) after the join and filter.\n\n4. **Count SLE Patients**: Among the filtered patients, count how many have a diagnosis that includes the term \"SLE\" (Systemic Lupus Erythematosus). This is done by checking if the `Diagnosis` field in the `Patient` table (`T1`) contains the substring \"SLE\". For each patient where this condition is true, their `ID` is counted; otherwise, it is ignored.\n\n5. **Calculate Percentage**: Divide the count of SLE patients by the total count of patients with abnormal GOT levels to determine the percentage of such patients diagnosed with SLE. The result is expressed as a fraction, which can be interpreted as a percentage when multiplied by 100.\n\nThe final result is the percentage of patients with abnormal GOT levels who are also diagnosed with SLE."
        ]
    },
    "189": {
        "sql": "WITH oldest_female_clients AS (\n    SELECT c.client_id, c.birth_date, d.A11 AS average_salary\n    FROM client c\n    JOIN district d ON c.district_id = d.district_id\n    WHERE c.gender = 'F'\n    ORDER BY c.birth_date ASC, d.A11 ASC\n    LIMIT 1\n)\nSELECT a.account_id\nFROM oldest_female_clients ofc\nJOIN disp dp ON ofc.client_id = dp.client_id\nJOIN account a ON dp.account_id = a.account_id;",
        "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
        "explain": "Female refers to 'F' in the gender; A11 contains information about average salary",
        "solution": []
    },
    "153": {
        "sql": "SELECT COUNT(*) AS classic_cards_eligible_for_loan\nFROM card\nJOIN disp ON card.disp_id = disp.disp_id\nJOIN account ON disp.account_id = account.account_id\nWHERE card.type = 'classic' AND disp.type = 'OWNER';",
        "question": "How many 'classic' cards are eligible for loan?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'classic' AND T2.type = 'OWNER'",
        "explain": "when the account type = 'OWNER', it's eligible for loan",
        "solution": []
    },
    "1007": {
        "sql": "SELECT MAX(p.duration) AS longest_pit_stop_time\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "question": "What was the longest time that Lewis Hamilton had spent at a pit stop?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.duration DESC LIMIT 1",
        "explain": "longest time refes to MAX(duration);",
        "solution": []
    },
    "697": {
        "sql": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "explain": "",
        "solution": []
    },
    "17": {
        "sql": "SELECT \n    T1.CharterNum,\n    T2.AvgScrWrite,\n    RANK() OVER (ORDER BY T2.AvgScrWrite DESC) AS Rank\nFROM \n    schools T1\nINNER JOIN \n    satscores T2 ON T1.CDSCode = T2.cds\nWHERE \n    T2.AvgScrWrite > 499\n    AND T1.CharterNum IS NOT NULL\nORDER BY \n    T2.AvgScrWrite DESC;",
        "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
        "explain": "Valid charter number means the number is not null",
        "solution": [
            "1. **Joining the schools and SAT scores data:**  \n   The query uses an `INNER JOIN` between two tables: `schools` (aliased as T1) and `satscores` (aliased as T2). These two tables are linked together using a common key, the `CDSCode` from the `schools` table and `cds` from the `satscores` table. This ensures that each school record is matched with its corresponding SAT score data.\n\n2. **Filtering for relevant scores and charter schools:**  \n   The query includes a condition to filter out records where the average writing score (`AvgScrWrite`) is greater than 499. Additionally, it ensures that only schools with a valid `CharterNum` (i.e., not null) are included in the results.\n\n3. **Selecting the charter number and average writing score:**  \n   From the joined tables, the query selects the `CharterNum` (the unique identifier for charter schools) and the `AvgScrWrite` (the average writing score). These are the primary fields requested by the question.\n\n4. **Ranking the schools by writing score:**  \n   The query uses the `RANK()` window function to assign a rank to each school based on their average writing score. The ranking is done in descending order (`ORDER BY AvgScrWrite DESC`), so schools with higher scores receive a lower (better) rank.\n\n5. **Outputting the results:**  \n   The final output includes the charter number, the average writing score, and the assigned rank for each school that meets the specified criteria."
        ]
    },
    "1431": {
        "sql": "SELECT m.last_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Women''s Soccer' AND m.position = 'Member';",
        "question": "List the last name of the members of the club that attended the women's soccer event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.last_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T2.event_name = 'Women''s Soccer' AND T3.position = 'Member'",
        "explain": "members of the club refers to position = 'Member'; 'Women's Soccer' is event name;",
        "solution": []
    },
    "826": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'DC Comics'\nORDER BY s.weight_kg DESC\nLIMIT 1;",
        "question": "Identify the heaviest superhero in DC Comics.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "explain": "heaviest refers to MAX(weight_kg); DC Comics refers to publisher_name = 'DC Comics'; superhero refers to superhero_name;",
        "solution": [
            "To identify the heaviest superhero in DC Comics, follow these steps:\n\n1. **Access the Superhero Table**: Retrieve data from the `superhero` table, which contains information about various superheroes, including their names and weights.\n\n2. **Join with Publisher Table**: Link the `superhero` table with the `publisher` table using the `publisher_id` field in the `superhero` table and the `id` field in the `publisher` table. This ensures we only consider superheroes associated with DC Comics.\n\n3. **Filter for DC Comics**: Apply a filter to include only those superheroes where the `publisher_name` in the `publisher` table is 'DC Comics'.\n\n4. **Sort by Weight**: Arrange the filtered superheroes in descending order based on their `weight_kg` to prioritize the heaviest superheroes.\n\n5. **Select the Heaviest**: Limit the results to the top entry (the first one after sorting) to identify the single heaviest superhero in DC Comics.\n\n6. **Retrieve the Name**: Extract and display the `superhero_name` of the identified superhero."
        ]
    },
    "52": {
        "sql": "SELECT COUNT(DISTINCT s.CDSCode) \nFROM schools s \nJOIN satscores sat ON s.CDSCode = sat.cds \nWHERE sat.NumGE1500 > 0 AND s.MailCity = 'Lakeport';",
        "question": "What is the total number of schools whose total SAT scores are greater or equal to 1500 whose mailing city is Lakeport?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.cds) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Lakeport' AND (T1.AvgScrRead + T1.AvgScrMath + T1.AvgScrWrite) >= 1500",
        "explain": "Total SAT scores can be computed by AvgScrRead + AvgScrMath + AvgScrWrite",
        "solution": []
    },
    "879": {
        "sql": "SELECT d.nationality \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nWHERE r.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results);",
        "question": "For the driver who set the fastest lap speed, what is his nationality?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "explain": "the fastest lap speed refers to (MAX) fastestLapSpeed;",
        "solution": []
    },
    "1141": {
        "sql": "SELECT DISTINCT t_a.buildUpPlaySpeedClass \nFROM Team t \nJOIN Team_Attributes t_a ON t.team_api_id = t_a.team_api_id \nWHERE t.team_long_name = 'KSV Cercle Brugge';",
        "question": "Does the KSV Cercle Brugge team have a slow, balanced or fast speed class?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.buildUpPlaySpeedClass FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.team_long_name = 'KSV Cercle Brugge'",
        "explain": "KSV Cercle Brugge refers to team_long_name = 'KSV Cercle Brugge'; speed class refers to buildUpPlaySpeedClass",
        "solution": [
            "To determine the speed class (slow, balanced, or fast) of the KSV Cercle Brugge team, follow these steps:\n\n1. **Identify the Team**: Locate the team named 'KSV Cercle Brugge' in the `Team` table.\n2. **Retrieve Team Attributes**: Using the team's unique identifier (`team_api_id`), fetch the corresponding attributes from the `Team_Attributes` table.\n3. **Extract Speed Class**: From the retrieved attributes, specifically select the `buildUpPlaySpeedClass` field, which indicates the team's speed class.\n4. **Ensure Uniqueness**: Since the query uses `DISTINCT`, it ensures that only unique speed class values are returned, avoiding duplicates.\n\nThe result will show whether the KSV Cercle Brugge team is classified as slow, balanced, or fast in their build-up play speed."
        ]
    },
    "1283": {
        "sql": "SELECT COUNT(*) AS MalePatientsWithNormalGOT\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60 AND T1.SEX = 'M';",
        "question": "For the patients with the normal glutamic pylvic transaminase level, how many of them are male?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "explain": "normal glutamic pylvic transaminase level refers to GOT < 60; male refers to Sex = 'M';",
        "solution": [
            "To solve the question, we need to count the number of male patients who have a normal glutamic pyruvic transaminase (GOT) level. The steps are as follows:\n\n1. **Identify the tables involved**: The `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) are used.\n2. **Join the tables**: The tables are joined on the `ID` column, which links patient records to their laboratory results.\n3. **Filter for normal GOT levels**: Only records where the GOT level (`T2.GOT`) is less than 60 are considered, as this indicates a normal level.\n4. **Filter for male patients**: Only records where the patient's sex (`T1.SEX`) is 'M' (male) are included.\n5. **Count the results**: The number of records that meet both criteria is counted.\n\nThe final count represents the number of male patients with normal GOT levels."
        ]
    },
    "714": {
        "sql": "SELECT c.Text FROM comments c JOIN users u ON c.UserId = u.Id WHERE u.DisplayName = 'Harvey Motulsky';",
        "question": "List the comments commented by the user with a username of Harvey Motulsky.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky'",
        "explain": "comments refer to Text; username of Harvey Motulsky refers to DisplayName = 'Harvey Motulsky';",
        "solution": [
            "To list the comments made by the user with the username 'Harvey Motulsky', follow these steps:\n\n1. **Join the tables**: Combine the `comments` table (referred to as `T1`) and the `users` table (referred to as `T2`) using the `UserId` field from `T1` and the `Id` field from `T2`. This ensures that each comment is linked to its respective user.\n\n2. **Filter the user**: From the joined tables, filter the records to only include those where the `DisplayName` in the `users` table (`T2`) matches the name 'Harvey Motulsky'.\n\n3. **Select the comments**: From the filtered records, extract the `Text` column from the `comments` table (`T1`), which contains the actual comments made by the user.\n\nThis process will retrieve all comments authored by the user 'Harvey Motulsky'."
        ]
    },
    "1190": {
        "sql": "SELECT (SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) * 100.0 / COUNT(ID)) AS percentage\nFROM Laboratory\nWHERE `U-PRO` > 0 AND `U-PRO` < 30;",
        "error": "something went wrong, tool did not call.",
        "question": "What percentage of patients with a proteinuria level within the normal range have a uric acid level below the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Laboratory WHERE `U-PRO` > 0 AND `U-PRO` < 30",
        "explain": "proteinuria level within the normal range refers to `U-PRO` > 0 AND `U-PRO` < 30; uric acid level below the normal range refers to UA < = 6.5; calculation = MULTIPLY(DIVIDE(UA < = 6.5, `U-PRO` > 0 AND `U-PRO` < 30)\uff0c100)",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter the Data**: Select all records from the `Laboratory` table where the proteinuria level (`U-PRO`) is within the normal range (greater than 0 and less than 30).\n\n2. **Count Eligible Patients**: Calculate the total number of patients (using `COUNT(ID)`) who meet the proteinuria criteria.\n\n3. **Identify Subset**: Within this filtered group, identify patients whose uric acid level (`UA`) is below the normal range (less than or equal to 6.5). This is done using a `CASE` statement that assigns 1 if the condition is met and 0 otherwise.\n\n4. **Sum the Subset**: Sum the values from the `CASE` statement to get the count of patients with uric acid levels below the normal range.\n\n5. **Calculate Percentage**: Divide the count of patients with low uric acid levels by the total count of eligible patients and multiply by 100 to get the percentage.\n\n6. **Cast to Real**: Ensure the division is performed as a real number to avoid integer division issues.\n\nThe final result is the percentage of patients with normal proteinuria levels who also have uric acid levels below the normal range."
        ]
    },
    "347": {
        "sql": "SELECT T1.id, T2.text, T1.hasContentWarning\nFROM cards T1\nJOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele';",
        "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
        "explain": "cards have missing or degraded properties and value refers to hasContentWarning = 1; 'Stephen Daniele' is artist; Find all cards refers to return card id",
        "solution": [
            "To solve the question, perform the following operations on the database:\n\n1. **Select** the columns `id`, `text`, and `hasContentWarning` from the `cards` table (aliased as `T1`).\n2. **Join** the `rulings` table (aliased as `T2`) with the `cards` table using the `uuid` column as the common key.\n3. **Filter** the results to include only those records where the `artist` column in the `cards` table matches the value 'Stephen Daniele'.\n4. **Return** the resulting records, which will include the card ID, the text of the ruling, and a flag indicating if the card has any content warnings (missing or degraded properties)."
        ]
    },
    "1509": {
        "sql": "SELECT COUNT(*) AS NumberOfTransactions\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE' AND t.Date > '2012-01-01';",
        "question": "Among the transactions made in the gas stations in the Czech Republic, how many of them are taken place after 2012/1/1?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND STRFTIME('%Y', T1.Date) >= '2012'",
        "explain": "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'",
        "solution": []
    },
    "221": {
        "sql": "SELECT 'TR001_2' AS atom_id1, 'TR001_6' AS atom_id2 FROM bond WHERE molecule_id = 'TR001' AND bond_id = 'TR001_2_6';",
        "question": "What are the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1 , T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'",
        "explain": "TR001 is the molecule id; TR001_2_6 is the bond id",
        "solution": [
            "To find the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6, follow these steps:\n\n1. **Filter the bond table**: Retrieve the record from the bond table where the molecule_id is 'TR001' and the bond_id is 'TR001_2_6'.\n\n2. **Extract the first atom ID**: From the bond_id 'TR001_2_6', extract the first 7 characters to form the first atom ID. This is done by taking the substring from position 1 to 7 of the bond_id.\n\n3. **Construct the second atom ID**: Combine the molecule_id 'TR001' with the substring of the bond_id starting from position 8 for 2 characters. This forms the second atom ID.\n\n4. **Return the results**: Display the extracted atom_id1 and constructed atom_id2 as the result.\n\nThe SQL query achieves this by selecting these values directly from the filtered bond table.",
            "To find the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6, follow these steps:\n\n1. **Filter the bond table**: Retrieve the record from the bond table where the molecule_id is 'TR001' and the bond_id is 'TR001_2_6'.\n\n2. **Extract the first atom ID**: From the bond_id 'TR001_2_6', extract the first 7 characters to form the first atom ID. This is done by taking the substring from position 1 to 7 of the bond_id, resulting in 'TR001_2'.\n\n3. **Construct the second atom ID**: Combine the molecule_id 'TR001' with the substring of the bond_id starting from position 8 for 2 characters. This forms the second atom ID, resulting in 'TR001_6'.\n\n4. **Return the results**: Display the extracted atom_id1 ('TR001_2') and constructed atom_id2 ('TR001_6') as the result.\n\nThe SQL query achieves this by selecting these values directly from the filtered bond table."
        ]
    },
    "1504": {
        "sql": "SELECT AVG(Amount * Price) AS average_total_price\nFROM transactions_1k\nWHERE strftime('%Y-%m', Date) = '2012-01';",
        "question": "What is the average total price of the transactions taken place in January, 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(Amount) FROM transactions_1k WHERE Date LIKE '2012-01%'",
        "explain": "In January, 2012 means Date contains '2012-01'",
        "solution": []
    },
    "352": {
        "sql": "SELECT (SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage_chinese_simplified\nFROM cards T1\nLEFT JOIN foreign_data T2 ON T1.uuid = T2.uuid;",
        "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
        "explain": "Chinese Simplified' is the language; percentage = Divide(Sum(id where language = 'Chinese Simplified'), Count(id)) *100",
        "solution": [
            "To calculate the percentage of cards available in Chinese Simplified, follow these steps:\n\n1. **Join the Tables**: Combine the `cards` table (referred to as `T1`) with the `foreign_data` table (referred to as `T2`) using the `uuid` column as the common key. This ensures that each card is matched with its corresponding language data.\n\n2. **Count Total Cards**: Count the total number of cards in the `cards` table (`T1`) by using the `COUNT(T1.id)` function. This gives the denominator for the percentage calculation.\n\n3. **Count Chinese Simplified Cards**: For each card, check if its language in the `foreign_data` table (`T2`) is 'Chinese Simplified'. If it is, count it as 1; otherwise, count it as 0. Sum these values using `SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END)` to get the total number of cards in Chinese Simplified.\n\n4. **Calculate Percentage**: Convert the count of Chinese Simplified cards to a real number (to ensure decimal division), multiply by 100, and divide by the total number of cards. This gives the percentage of cards available in Chinese Simplified.\n\nThe final result is the percentage of cards in Chinese Simplified out of the total cards.",
            "To calculate the percentage of cards available in Chinese Simplified, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `cards` table (aliased as `T1`) and the `foreign_data` table (aliased as `T2`) using the `uuid` column as the joining key. This ensures that each card in the `cards` table is matched with its corresponding language data in the `foreign_data` table.\n\n2. **Count Total Cards**: Use the `COUNT(T1.id)` function to count the total number of cards in the `cards` table (`T1`). This count serves as the denominator for the percentage calculation.\n\n3. **Count Chinese Simplified Cards**: For each card, evaluate the `language` column in the `foreign_data` table (`T2`). If the language is 'Chinese Simplified', count it as 1; otherwise, count it as 0. Sum these values using the expression `SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END)` to obtain the total number of cards available in Chinese Simplified.\n\n4. **Calculate Percentage**: Convert the count of Chinese Simplified cards to a real number (to ensure decimal division), multiply by 100, and then divide by the total number of cards (from step 2). This yields the percentage of cards available in Chinese Simplified.\n\nThe final result is the percentage of cards in Chinese Simplified out of the total cards, calculated as `(Number of Chinese Simplified Cards / Total Number of Cards) * 100`."
        ]
    },
    "405": {
        "sql": "SELECT COUNT(DISTINCT T1.id) \nFROM sets T1 \nJOIN set_translations T2 ON T1.code = T2.setCode \nWHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander';",
        "question": "How many Brazilian Portuguese translated sets are inside the Commander block?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'",
        "explain": "Commander block refer to block = 'Commander'; sets refer to code = setCode; Portuguese refer to language = 'Portuguese (Brasil)'",
        "solution": [
            "To determine how many Brazilian Portuguese translated sets are inside the Commander block, follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables: `sets` (referred to as T1) and `set_translations` (referred to as T2).\n\n2. **Join the tables**: Combine the `sets` table (T1) with the `set_translations` table (T2) using the condition that the `code` column in T1 matches the `setCode` column in T2.\n\n3. **Filter the data**: From the joined tables, filter the records to include only those where:\n   - The `language` column in T2 is 'Portuguese (Brazil)'.\n   - The `block` column in T1 is 'Commander'.\n\n4. **Count the results**: Count the number of unique `id` values from the `sets` table (T1) that meet the above conditions.\n\nThe final count represents the number of Brazilian Portuguese translated sets within the Commander block."
        ]
    },
    "238": {
        "sql": "SELECT COUNT(DISTINCT molecule_id) FROM bond WHERE bond_type = '#';",
        "question": "How many molecules have a triple bond type?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.bond_type = '#'",
        "explain": "triple bond refers to bond_type = '#';",
        "solution": []
    },
    "6": {
        "sql": "SELECT T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.Magnet = 1 AND T1.NumTstTakr > 500;",
        "question": "Among the schools with the SAT test takers of over 500, please list the schools that are magnet schools or offer a magnet program.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Magnet = 1 AND T1.NumTstTakr > 500",
        "explain": "Magnet schools or offer a magnet program means that Magnet = 1",
        "solution": [
            "1. **Joining the SAT scores and schools data:**  \n   The query uses an `INNER JOIN` between two tables: `satscores` (aliased as T1) and `schools` (aliased as T2). These tables are linked using the `cds` column from `satscores` and the `CDSCode` column from `schools`, ensuring that each school's SAT data is matched with its corresponding school record.\n\n2. **Filtering for magnet schools or programs:**  \n   The query includes a condition (`T2.Magnet = 1`) to filter the results to only include schools that are magnet schools or offer a magnet program. This ensures that the output is restricted to schools meeting this specific criterion.\n\n3. **Filtering for schools with over 500 SAT test takers:**  \n   Another condition (`T1.NumTstTakr > 500`) is applied to further filter the results, ensuring that only schools with more than 500 SAT test takers are included in the output.\n\n4. **Selecting the school names:**  \n   The query selects the `School` column from the `schools` table (T2), which provides the names of the schools that meet both the magnet program and SAT test taker criteria."
        ]
    },
    "559": {
        "sql": "SELECT CreationDate\nFROM votes\nGROUP BY CreationDate\nORDER BY COUNT(Id) DESC\nLIMIT 1;",
        "question": "Indicate the creation date of the maximum number of votes.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CreationDate FROM votes GROUP BY CreationDate ORDER BY COUNT(Id) DESC LIMIT 1",
        "explain": "the creation date of the maximum number of votes refers to CreationDate where Max(Count(Id))",
        "solution": []
    },
    "1280": {
        "sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "question": "How many male patients have their glutamic oxaloacetic transaminase in the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "explain": "male refers to Sex = 'M'; glutamic oxaloacetic transaminase in the normal range refers to GOT < 60;",
        "solution": [
            "To solve the question \"How many male patients have their glutamic oxaloacetic transaminase (GOT) in the normal range?\", follow these steps:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (aliased as `T1`): Contains patient information, including their ID and sex.\n   - `Laboratory` (aliased as `T2`): Contains laboratory test results, including the GOT value for each patient.\n\n2. **Join the Tables**: Perform an inner join between the `Patient` and `Laboratory` tables using the patient ID (`T1.ID = T2.ID`) to combine patient information with their laboratory results.\n\n3. **Filter for Male Patients**: From the joined data, filter for patients where the sex is male (`T1.SEX = 'M'`).\n\n4. **Filter for Normal GOT Range**: Further filter the results to include only those patients whose GOT value is less than 60 (`T2.GOT < 60`), which is considered the normal range in this context.\n\n5. **Count the Patients**: Finally, count the number of patient IDs (`T1.ID`) that meet the above criteria to determine how many male patients have GOT in the normal range.\n\nThe SQL query `SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'` precisely performs these operations to answer the question."
        ]
    },
    "627": {
        "sql": "SELECT COUNT(*) AS adult_users_count FROM users WHERE Age BETWEEN 19 AND 65;",
        "question": "How many users were adult?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "explain": "adult refers to user where Age BETWEEN 19 and 65;",
        "solution": []
    },
    "983": {
        "sql": "SELECT T1.url\nFROM constructors T1\nJOIN constructorStandings T2 ON T1.constructorId = T2.constructorId\nWHERE T1.nationality = 'Italian'\nORDER BY T2.points DESC\nLIMIT 1;",
        "question": "Which of the Italian constructor got the highest point to date? Give its introduction website?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1",
        "explain": "introduction website refers to url; Italian is a nationality",
        "solution": [
            "To solve the question, \"Which of the Italian constructor got the highest point to date? Give its introduction website?\", the following steps are performed:\n\n1. **Join Tables**: The `constructors` table (aliased as `T1`) is joined with the `constructorStandings` table (aliased as `T2`) using the `constructorId` field. This links the constructor details with their standings.\n\n2. **Filter by Nationality**: The query filters the results to only include constructors with the nationality 'Italian' by checking the `nationality` field in the `constructors` table (`T1.nationality = 'Italian'`).\n\n3. **Order by Points**: The results are then ordered in descending order based on the `points` field from the `constructorStandings` table (`T2.points DESC`). This ensures the constructor with the highest points appears first.\n\n4. **Limit Results**: The query limits the output to just the top result (`LIMIT 1`), which will be the Italian constructor with the highest points.\n\n5. **Select Website URL**: Finally, the query selects the `url` field from the `constructors` table (`T1.url`), which provides the introduction website of the identified constructor.\n\nThis sequence of operations ensures that the correct constructor is identified and their website URL is returned."
        ]
    },
    "301": {
        "sql": "SELECT bond_type FROM bond WHERE bond_id = 'TR007_4_19';",
        "question": "What is the bond type of TR007_4_19?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_type FROM bond AS T WHERE T.bond_id = 'TR007_4_19'",
        "explain": "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
        "solution": []
    },
    "363": {
        "sql": "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1 \nJOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Restricted' AND T1.isStarter = 1;",
        "question": "How many cards of legalities whose status is restricted are found in a starter deck?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isStarter = 1",
        "explain": "restricted refers to status = 'restricted'; found in the starter deck refers to isStarter = 1;",
        "solution": [
            "To solve the question \"How many cards of legalities whose status is restricted are found in a starter deck?\", the following steps are performed:\n\n1. **Join the Tables**: Combine the `cards` table (referred to as `T1`) and the `legalities` table (referred to as `T2`) using the `uuid` field as the common key.\n\n2. **Filter by Status**: From the joined tables, filter the records to include only those where the `status` in the `legalities` table (`T2`) is 'Restricted'.\n\n3. **Filter by Starter Deck**: Further filter the records to include only those cards where the `isStarter` field in the `cards` table (`T1`) is set to 1, indicating the card is part of a starter deck.\n\n4. **Count Distinct Cards**: Count the number of distinct `id` values from the `cards` table (`T1`) that meet the above criteria. This ensures each card is counted only once, even if it appears multiple times in the dataset.\n\nThe final result is the count of unique cards that are both restricted in legalities and part of a starter deck."
        ]
    },
    "163": {
        "sql": "SELECT T1.A2 AS district_name\nFROM district T1\nJOIN account T2 ON T1.district_id = T2.district_id\nJOIN loan T3 ON T2.account_id = T3.account_id\nWHERE T3.status = 'A'\nGROUP BY T1.district_id\nORDER BY COUNT(T2.account_id) DESC\nLIMIT 1;",
        "question": "Which district has the most accounts with loan contracts finished with no problems?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.A2 FROM District AS T1 INNER JOIN Account AS T2 ON T1.District_id = T2.District_id INNER JOIN Loan AS T3 ON T2.Account_id = T3.Account_id WHERE T3.status = 'A' GROUP BY T1.District_id ORDER BY COUNT(T2.Account_id) DESC LIMIT 1",
        "explain": "status = 'A' refers to loan contracts finished with no problems",
        "solution": [
            "To determine which district has the most accounts with loan contracts finished with no problems, follow these steps:\n\n1. **Join the Tables**: Combine the `District`, `Account`, and `Loan` tables. Link them as follows:\n   - The `District` table (aliased as `T1`) is joined with the `Account` table (aliased as `T2`) using the `District_id` field.\n   - The `Account` table is then joined with the `Loan` table (aliased as `T3`) using the `Account_id` field.\n\n2. **Filter the Data**: Only include records where the loan status (`T3.status`) is 'A', indicating that the loan contract was finished with no problems.\n\n3. **Group the Results**: Group the filtered records by the `District_id` from the `District` table (`T1.District_id`).\n\n4. **Count Accounts**: For each district, count the number of accounts (`T2.Account_id`) that meet the criteria.\n\n5. **Sort the Results**: Order the grouped results by the count of accounts in descending order to prioritize districts with the highest number of qualifying accounts.\n\n6. **Retrieve the Top Result**: Limit the output to the top result, which will be the district with the most accounts meeting the specified conditions.\n\nThe final output will display the name of the district (`T1.A2`) that has the highest number of accounts with loan contracts finished without any problems."
        ]
    },
    "784": {
        "sql": "SELECT s.full_name\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Vampire';",
        "question": "Provide the full names of vampire heroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
        "explain": "vampire heroes refers to race = 'Vampire';",
        "solution": []
    },
    "30": {
        "sql": "SELECT s.City, SUM(f.\"Enrollment (K-12)\") AS TotalEnrollment\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nGROUP BY s.City\nORDER BY TotalEnrollment ASC\nLIMIT 5;",
        "question": "Which cities have the top 5 lowest enrollment number for students in grades 1 through 12?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode GROUP BY T2.City ORDER BY SUM(T1.`Enrollment (K-12)`) ASC LIMIT 5",
        "explain": "K-12 refers to students in grades 1 through 12.",
        "solution": [
            "To find the cities with the top 5 lowest enrollment numbers for students in grades 1 through 12, follow these steps:\n\n1. **Join the Tables**: Combine the `frpm` table (T1) and the `schools` table (T2) using the `CDSCode` field as the common key. This links enrollment data to the corresponding schools.\n\n2. **Group by City**: Group the combined data by the `City` field from the `schools` table (T2). This aggregates all enrollment data for each city.\n\n3. **Calculate Total Enrollment**: For each city, sum the values in the `Enrollment (K-12)` column from the `frpm` table (T1). This gives the total enrollment for grades 1 through 12 in each city.\n\n4. **Order by Enrollment**: Sort the cities in ascending order based on their total enrollment. This ensures the cities with the lowest enrollment appear first.\n\n5. **Limit Results**: Select only the top 5 cities from the sorted list, which will be the ones with the lowest enrollment numbers.\n\nThe final output is a list of the 5 cities with the lowest total enrollment for students in grades 1 through 12.",
            "To determine the cities with the top 5 lowest enrollment numbers for students in grades 1 through 12, the following steps are executed:\n\n1. **Table Join**: The `frpm` table (T1) is joined with the `schools` table (T2) using the `CDSCode` field as the matching key. This ensures that enrollment data is linked to the corresponding school information.\n\n2. **Grouping by City**: The combined data is grouped by the `City` column from the `schools` table (T2). This step aggregates all enrollment records for each city.\n\n3. **Summing Enrollment**: For each city, the values in the `Enrollment (K-12)` column from the `frpm` table (T1) are summed. This calculation provides the total enrollment for grades 1 through 12 in each city.\n\n4. **Sorting by Enrollment**: The cities are sorted in ascending order based on their total enrollment. This arrangement places the cities with the lowest enrollment at the top of the list.\n\n5. **Limiting Results**: Only the top 5 cities from the sorted list are selected, which represent the cities with the lowest enrollment numbers.\n\nThe final output is a list of the 5 cities with the lowest total enrollment for students in grades 1 through 12."
        ]
    },
    "65": {
        "sql": "SELECT \n    (CAST(SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) AS REAL) * 100) / \n    NULLIF(SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END), 0) AS ratio_percentage\nFROM schools\nWHERE County = 'Santa Clara' AND Charter = 1;",
        "question": "What is the ratio in percentage of Santa Clara County schools that are locally funded compared to all other types of charter school funding?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END) FROM schools WHERE County = 'Santa Clara' AND Charter = 1",
        "explain": "Ratio in percentage = (count(locally funded schools in Santa Clara) / count(all funding type schools in Santa Clara) * 100%",
        "solution": [
            "To find the ratio in percentage of Santa Clara County schools that are locally funded compared to all other types of charter school funding, follow these steps:\n\n1. **Filter the Data**: Select all schools in Santa Clara County that are charter schools.\n2. **Count Locally Funded Schools**: Count the number of schools where the funding type is 'Locally funded'.\n3. **Count Other Funded Schools**: Count the number of schools where the funding type is not 'Locally funded'.\n4. **Calculate the Ratio**: Divide the count of locally funded schools by the count of other funded schools, then multiply by 100 to convert the ratio into a percentage.\n\nThe result will give you the percentage ratio of locally funded charter schools compared to all other funding types in Santa Clara County.",
            "To determine the ratio in percentage of Santa Clara County schools that are locally funded compared to all other types of charter school funding, follow these detailed steps:\n\n1. **Filter the Data**: Extract all schools located in Santa Clara County that are identified as charter schools (where `County = 'Santa Clara'` and `Charter = 1`).\n\n2. **Count Locally Funded Schools**: Calculate the number of schools within the filtered dataset where the `FundingType` is 'Locally funded'. This is done by summing 1 for each school that meets the condition (`SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END)`).\n\n3. **Count Other Funded Schools**: Similarly, calculate the number of schools where the `FundingType` is not 'Locally funded' by summing 1 for each such school (`SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END)`).\n\n4. **Calculate the Ratio**: Divide the count of locally funded schools by the count of other funded schools. Convert this ratio into a percentage by multiplying the result by 100 (`CAST(...) * 100 / ...`).\n\nThe final result will be the percentage ratio of locally funded charter schools compared to all other funding types in Santa Clara County."
        ]
    },
    "723": {
        "sql": "SELECT COUNT(DISTINCT s.id) AS count\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id AND c.colour = 'Blue'\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id AND sp.power_name = 'Agility';",
        "question": "Among the superheroes with blue eyes, how many of them have the super power of \"Agility\"?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id WHERE T3.power_name = 'Agility' AND T4.colour = 'Blue'",
        "explain": "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'",
        "solution": []
    },
    "1087": {
        "sql": "SELECT COUNT(DISTINCT p.player_api_id) \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE p.height > 180 AND pa.volleys > 70;",
        "question": "Among the players whose height is over 180, how many of them have a volley score of over 70?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 AND t2.volleys > 70",
        "explain": "height > 180; volley score refers to volleys; volleys > 70;",
        "solution": []
    },
    "607": {
        "sql": "SELECT COUNT(*) AS positive_comments_count FROM comments WHERE Score > 60;",
        "question": "How many positive comments are there on the list?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM comments WHERE score > 60",
        "explain": "Positive comment refers to score > 60",
        "solution": []
    },
    "145": {
        "sql": "SELECT DISTINCT T2.account_id\nFROM trans T1\nJOIN account T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1998'\nAND T1.operation = 'VYBER KARTOU'\nAND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998');",
        "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
        "explain": "Operation = 'VYBER KARTOU' refers to credit card withdrawal",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter Transactions for 1998**: Identify all transactions that occurred in the year 1998.\n2. **Filter Credit Card Transactions**: From the filtered transactions, select only those with the operation type 'VYBER KARTOU' (credit card transactions).\n3. **Calculate Average Amount**: Compute the average amount of all transactions that occurred in 1998.\n4. **Compare Transaction Amounts**: From the credit card transactions in 1998, select those where the transaction amount is less than the calculated average amount.\n5. **Retrieve Account IDs**: Finally, retrieve the account holder identification numbers (account_id) associated with these transactions by joining the transaction data with the account data.\n\nThe SQL query accomplishes this by:\n- Joining the `trans` table (T1) with the `account` table (T2) on the `account_id` field.\n- Filtering transactions for the year 1998 using `STRFTIME('%Y', T1.date) = '1998'`.\n- Further filtering for credit card transactions with `T1.operation = 'VYBER KARTOU'`.\n- Comparing the transaction amount to the average amount of 1998 transactions using a subquery: `T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')`.\n- Selecting the `account_id` from the resulting records."
        ]
    },
    "603": {
        "sql": "SELECT SUM(DISTINCT p.FavoriteCount) AS TotalFavoriteCount\nFROM posts p\nJOIN postHistory ph ON p.Id = ph.PostId\nWHERE ph.UserId = 686\nAND strftime('%Y', ph.CreationDate) = '2011'",
        "question": "What is the sum of favourite count gained by user ID 686 in 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(DISTINCT FavoriteCount) FROM posts WHERE Id IN ( SELECT PostId FROM postHistory WHERE UserId = 686 AND STRFTIME('%Y', CreationDate) = '2011' )",
        "explain": "in 2011 refers to year (CreatinDate) = 2011",
        "solution": [
            "To find the sum of the distinct favorite counts gained by user ID 686 in the year 2011, follow these steps:\n\n1. **Identify the relevant posts**: First, locate all the posts where the user with ID 686 has interacted in 2011. This is done by querying the `postHistory` table for entries where the `UserId` is 686 and the `CreationDate` falls within the year 2011. The `PostId` values from these entries are collected.\n\n2. **Retrieve the favorite counts**: Using the `PostId` values obtained from the previous step, query the `posts` table to retrieve the `FavoriteCount` for each of these posts. Ensure that only distinct values of `FavoriteCount` are considered to avoid duplication.\n\n3. **Calculate the sum**: Sum all the distinct `FavoriteCount` values retrieved in the previous step to get the total sum of favorite counts gained by user ID 686 in 2011."
        ]
    },
    "1428": {
        "sql": "SELECT z.city, z.state\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE maj.department = 'Electrical and Computer Engineering Department'\nAND m.position = 'Member';",
        "question": "List the city and state of members enrolled under electrical and computer engineering department.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT city, state FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN zip_code AS T3 ON T3.zip_code = T1.zip WHERE department = 'Electrical and Computer Engineering Department' AND position = 'Member'",
        "explain": "'Electrical and Computer Engineering Department' is the department; members enrolled refers to position = 'Member'",
        "solution": []
    },
    "474": {
        "sql": "SELECT COUNT(DISTINCT s.code)\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Italian' AND s.baseSetSize < 100;",
        "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 100?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 100 AND T2.language = 'Italian'",
        "explain": "Italian translation refers to language = 'Italian'; have a translation means translation is not null; base set number of under 100 refers to baseSetSize < 10",
        "solution": []
    },
    "89": {
        "sql": "SELECT COUNT(T2.account_id) AS account_count\nFROM district T1\nJOIN account T2 ON T1.district_id = T2.district_id\nWHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU';",
        "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
        "explain": "A3 contains the data of region; 'POPLATEK PO OBRATU' represents for 'issuance after transaction'.",
        "solution": [
            "To solve the question, we need to count the number of accounts that meet two specific conditions:\n1. The account's associated district is in the 'East Bohemia' region.\n2. The account's frequency is 'POPLATEK PO OBRATU' (which translates to 'issuance after transaction').\n\nThe steps to achieve this are as follows:\n1. **Join the tables**: Link the `district` table (referred to as T1) with the `account` table (referred to as T2) using the `district_id` field. This ensures we can access both the district information and the account details.\n2. **Filter by region**: From the joined tables, filter the records to only include those where the `A3` field in the `district` table (T1) is 'east Bohemia'.\n3. **Filter by frequency**: Further filter the records to include only those accounts where the `frequency` field in the `account` table (T2) is 'POPLATEK PO OBRATU'.\n4. **Count the accounts**: Finally, count the number of `account_id` entries in the `account` table (T2) that meet both conditions.\n\nThe result will be the total number of accounts in the 'East Bohemia' region with the specified frequency."
        ]
    },
    "967": {
        "sql": "WITH youngest_drivers AS (\n    SELECT code, nationality\n    FROM drivers\n    ORDER BY dob DESC\n    LIMIT 3\n)\nSELECT \n    COUNT(*) AS netherlandic_drivers_count\nFROM youngest_drivers\nWHERE nationality IN ('Dutch', 'Netherlandic');",
        "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
        "explain": "youngest driver refers to Max (year(dob)); Netherlandic and Dutch refer to the same country",
        "solution": []
    },
    "394": {
        "sql": "SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
        "question": "How many white bordered cards are powerful?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "explain": "white bordered cards refer to borderColor = 'white'; powerful cards refers to cardKingdomFoilId is not null AND cardKingdomId is not null (replace)",
        "solution": []
    },
    "1361": {
        "sql": "SELECT SUM(cost) AS total_pizza_cost FROM expense WHERE expense_description LIKE '%pizza%';",
        "question": "What is the total cost of the pizzas for all the events?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza'",
        "explain": "total cost of the pizzas refers to SUM(cost) where expense_description = 'Pizza'",
        "solution": []
    },
    "866": {
        "sql": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes T1 JOIN drivers T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%';",
        "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
        "explain": "player and driver are synonyms; the lap time of 0:0M:SS refers to lapTime.time LIKE 'M:SS%';race number refers to raceId; introduction website of the drivers refers to url;",
        "solution": [
            "To find the player who achieved a lap time of 0:01:27 in race No. 161 and display their introduction website, follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables:\n   - `lapTimes` (referred to as `T1` in the SQL) contains lap time records.\n   - `drivers` (referred to as `T2` in the SQL) contains driver information, including their names and introduction websites.\n\n2. **Join the tables**: Combine the `lapTimes` and `drivers` tables using the `driverId` field to link the lap time records to the corresponding driver information.\n\n3. **Filter the data**: Apply the following filters:\n   - Select only the records where the `raceId` in the `lapTimes` table is `161`.\n   - Further filter to include only those records where the `time` field in the `lapTimes` table starts with `1:27` (indicating a lap time of 0:01:27).\n\n4. **Retrieve the required information**: From the filtered and joined data, extract the distinct values of the driver's forename (`forename`), surname (`surname`), and introduction website (`url`).\n\n5. **Display the results**: The output will show the name and introduction website of the player who achieved the specified lap time in the given race."
        ]
    },
    "7": {
        "sql": "SELECT s.Phone\nFROM schools s\nJOIN satscores sat ON s.CDSCode = sat.cds\nWHERE sat.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);",
        "question": "What is the phone number of the school that has the highest number of test takers with an SAT score of over 1500?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "explain": "",
        "solution": []
    },
    "982": {
        "sql": "SELECT COUNT(DISTINCT d.driverId) AS american_drivers_with_puncture\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN status s ON r.statusId = s.statusId\nWHERE d.nationality = 'American' AND s.status = 'Puncture';",
        "question": "How many American drivers have puncture status.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN results AS T2 on T1.driverId = T2.driverId INNER JOIN status AS T3 on T2.statusId = T3.statusId WHERE T3.status = 'Puncture' AND T1.nationality = 'American'",
        "explain": "puncture status refers to status = Puncture;",
        "solution": []
    },
    "909": {
        "sql": "SELECT \n    (COUNT(CASE WHEN c.country = 'Germany' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_in_germany\nFROM \n    races r\nJOIN \n    circuits c ON r.circuitId = c.circuitId\nWHERE \n    r.name = 'European Grand Prix';",
        "question": "Among all European Grand Prix races, what is the percentage of the races were hosted in Germany?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.country = 'Germany' THEN T2.circuitID END) AS REAL) * 100 / COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix'",
        "explain": "European Grand Prix races refers to races.name = 'European Grand Prix';percentage = divide(COUNT(races where country = Germany and name = 'Europearn Grand Prix'),COUNT(races where name = 'Europearn Grand Prix'))*100",
        "solution": []
    },
    "138": {
        "sql": "WITH SecondHighestCrimeDistrict AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A15 DESC\n    LIMIT 1 OFFSET 1\n)\nSELECT COUNT(*) AS male_clients_count\nFROM client\nWHERE gender = 'M' AND district_id = (SELECT district_id FROM SecondHighestCrimeDistrict);",
        "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
        "explain": "Male refers to gender = 'M'; A15 stands for no. of commited crimes 1995",
        "solution": []
    },
    "473": {
        "sql": "SELECT CASE WHEN T2.isForeignOnly = 1 THEN 'YES' ELSE 'NO' END AS isOnlyAvailableOutsideUS\nFROM cards T1\nJOIN sets T2 ON T1.setCode = T2.code\nWHERE T1.name = 'Adarkar Valkyrie';",
        "question": "Is the set of cards with Adarkar Valkyrie only available outside the United States?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT IIF(isForeignOnly = 1, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Adarkar Valkyrie'",
        "explain": "card set Adarkar Valkyrie refers to name = 'Adarkar Valkyrie'; isForeignOnly = 1 means only available outside the United States;",
        "solution": [
            "To determine if the set of cards with 'Adarkar Valkyrie' is only available outside the United States, follow these steps:\n\n1. **Join the Tables**: Combine the `cards` table (referred to as `T1`) with the `sets` table (referred to as `T2`) using the `setCode` from `T1` and the `code` from `T2` as the joining condition.\n\n2. **Filter the Card**: From the joined tables, filter the records to only include the card named 'Adarkar Valkyrie'.\n\n3. **Check Availability**: For the filtered record, examine the `isForeignOnly` field from the `sets` table. If this field has a value of `1`, it means the card is only available outside the United States. If it is `0` or any other value, it means the card is available in the United States.\n\n4. **Return the Result**: Convert the `isForeignOnly` value into a human-readable response. If `isForeignOnly` is `1`, return 'YES'; otherwise, return 'NO'.\n\nThis process ensures that the answer accurately reflects whether the 'Adarkar Valkyrie' card is exclusively available outside the United States."
        ]
    },
    "701": {
        "sql": "WITH most_influential_user AS (\n    SELECT Id\n    FROM users\n    ORDER BY Reputation DESC\n    LIMIT 1\n),\nuser_posts AS (\n    SELECT Id, Score\n    FROM posts\n    WHERE OwnerUserId = (SELECT Id FROM most_influential_user)\n),\ntotal_posts AS (\n    SELECT COUNT(*) AS total\n    FROM user_posts\n),\nhigh_score_posts AS (\n    SELECT COUNT(*) AS high_score\n    FROM user_posts\n    WHERE Score > 50\n)\nSELECT (high_score * 100.0 / total) AS percentage\nFROM high_score_posts, total_posts;",
        "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
        "explain": "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));",
        "solution": []
    },
    "1206": {
        "sql": "SELECT Date FROM Laboratory WHERE ID = 48473 AND GOT >= 60;",
        "question": "When is the laboratory examination of patient '48473' where his/her AST glutamic oxaloacetic transaminase (GOT) index is above the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT Date FROM Laboratory WHERE ID = 48473 AND GOT >= 60",
        "explain": "AST glutamic oxaloacetic transaminase (GOT) index is above the normal range refers to GOT > = 60; when refers to DATE",
        "solution": []
    },
    "845": {
        "sql": "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.height_cm > (SELECT 0.8 * AVG(height_cm) FROM superhero);",
        "question": "List the power of superheroes with height greater than 80% of the average height of all superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm * 100 > ( SELECT AVG(height_cm) FROM superhero ) * 80",
        "explain": "power of superheroes refers to power_name; height greater than 80% of the average height of all superheroes = height_cm > MULTIPLY(AVG(height_cm), 0.8);",
        "solution": []
    },
    "900": {
        "sql": "SELECT circuits.name AS circuit_name, circuits.location, races.name AS race_name\nFROM circuits\nJOIN races ON circuits.circuitId = races.circuitId\nWHERE races.year = 2006 AND circuits.country = 'USA';",
        "question": "List circuits in USA which hosted f1 races in 2006. State the name and location of circuit and the name of the race it hosted.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.location, T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'USA' AND T2.year = 2006",
        "explain": "",
        "solution": []
    },
    "1234": {
        "sql": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0\nGROUP BY T1.SEX, T1.ID\nORDER BY T1.Birthday ASC;",
        "question": "List the patient ID, sex and birthday who has abnormal white blood cell count. Group them by sex and list the patient by age in ascending order.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0 GROUP BY T1.SEX,T1.ID ORDER BY T1.Birthday ASC",
        "explain": "abnormal white blood cell count refers to WBC < = 3.5 or WBC > = 9.0;",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Select Distinct Patient Information**: Retrieve the distinct patient ID, sex, and birthday from the `Patient` table (aliased as `T1`).\n\n2. **Join with Laboratory Data**: Perform an inner join with the `Laboratory` table (aliased as `T2`) using the patient ID as the join condition. This ensures we only consider patients who have laboratory records.\n\n3. **Filter Abnormal White Blood Cell Count**: Apply a filter to include only those patients whose white blood cell count (WBC) is either less than or equal to 3.5 or greater than or equal to 9.0. This identifies patients with abnormal WBC levels.\n\n4. **Group by Sex and Patient ID**: Group the results by the patient's sex and ID. This ensures that each patient is counted only once per sex group.\n\n5. **Order by Birthday in Ascending Order**: Finally, sort the results by the patient's birthday in ascending order to list them from youngest to oldest.\n\nThe SQL query accomplishes all these steps in a single statement, ensuring the solution is both efficient and accurate."
        ]
    },
    "1054": {
        "sql": "SELECT pa.defensive_work_rate \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'David Wilson';",
        "question": "What is the defensive work rate of the football player David Wilson\n?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.defensive_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'David Wilson'",
        "explain": "",
        "solution": []
    },
    "841": {
        "sql": "SELECT s.weight_kg, r.race FROM superhero s JOIN race r ON s.race_id = r.id WHERE s.id = 40;",
        "question": "Provide the weight and race of the superhero with superhero ID 40.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.weight_kg, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.id = 40",
        "explain": "weight refers to weight_kg; superhero ID 40 refers to superhero.id = 40;",
        "solution": []
    },
    "483": {
        "sql": "SELECT DISTINCT T1.text\nFROM foreign_data T1\nJOIN cards T2 ON T1.uuid = T2.uuid\nJOIN sets T3 ON T2.setCode = T3.code\nWHERE T3.name = 'Coldsnap' AND T1.language = 'Italian';",
        "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
        "explain": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'",
        "solution": [
            "To list the Italian text ruling of all the cards in the set 'Coldsnap', follow these steps:\n\n1. **Identify the relevant tables**: The query involves three tables:\n   - `foreign_data` (aliased as `T1`), which contains the foreign language text of the cards.\n   - `cards` (aliased as `T2`), which contains the card details.\n   - `sets` (aliased as `T3`), which contains the set details.\n\n2. **Join the tables**:\n   - Join the `foreign_data` table (`T1`) with the `cards` table (`T2`) using the `uuid` field to link the card's foreign text to its details.\n   - Join the `cards` table (`T2`) with the `sets` table (`T3`) using the `setCode` field to link the card to its set.\n\n3. **Apply the filters**:\n   - Filter the `sets` table (`T3`) to only include records where the set name is 'Coldsnap'.\n   - Filter the `foreign_data` table (`T1`) to only include records where the language is 'Italian'.\n\n4. **Select the distinct Italian text rulings**:\n   - Retrieve the `text` field from the `foreign_data` table (`T1`), ensuring that only distinct (unique) entries are returned.\n\nThis process ensures that you get a list of all unique Italian text rulings for the cards in the 'Coldsnap' set."
        ]
    },
    "62": {
        "sql": "SELECT COUNT(*) AS TotalNonCharteredSchools\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.Charter = 0\nAND s.County = 'Los Angeles'\nAND (f.[Free Meal Count (K-12)] * 100.0 / f.[Enrollment (K-12)]) < 0.18;",
        "question": "What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.School) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.Charter = 0 AND CAST(T1.`Free Meal Count (K-12)` AS REAL) * 100 / T1.`Enrollment (K-12)` < 0.18",
        "explain": "non-chartered schools refer to schools whose Charter = 0; K-12 means grades 1 through 12; percent of eligible free rate for K-12 = `Free Meal Count (K-12)` * 100 / `Enrollment (K-12)`",
        "solution": []
    },
    "1408": {
        "sql": "SELECT SUM(cost) AS total_parking_cost FROM expense WHERE expense_description LIKE '%Parking%';",
        "question": "Calculate the total cost spent for Parking in the list.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Parking'",
        "explain": "total cost spent for Parking refers to SUM(cost) where expense_description = 'Parking'",
        "solution": []
    },
    "1306": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) AS PatientCount\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND T2.WBC BETWEEN 3.5 AND 9;",
        "question": "How many patients diagnosed with SLE have a normal white blood cell level?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.WBC BETWEEN 3.5 AND 9",
        "explain": "diagnosed with SLE refers to Diagnosis = 'SLE'; normal white blood cell level refers to WBC between 3.5 and 9.0;",
        "solution": [
            "To find the number of patients diagnosed with SLE who have a normal white blood cell (WBC) level, follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables, `Patient` (referred to as `T1`) and `Laboratory` (referred to as `T2`).\n\n2. **Join the tables**: Link the `Patient` and `Laboratory` tables using the common column `ID` to ensure the data corresponds to the same patient.\n\n3. **Filter by diagnosis**: From the joined data, select only those patients whose diagnosis is 'SLE' (Systemic Lupus Erythematosus).\n\n4. **Filter by WBC level**: Further refine the selection to include only patients whose white blood cell (WBC) level falls within the normal range, which is between 3.5 and 9.\n\n5. **Count the patients**: Finally, count the number of patients who meet both criteria (diagnosis of SLE and normal WBC level).\n\nThe result will be the total count of such patients.",
            "To determine the number of patients diagnosed with Systemic Lupus Erythematosus (SLE) who have a normal white blood cell (WBC) level, the following steps are executed:\n\n1. **Table Selection**: The query involves two tables: `Patient` (aliased as `T1`) and `Laboratory` (aliased as `T2`).\n\n2. **Table Join**: The tables are joined using the `INNER JOIN` operation on the common column `ID` to ensure that the data corresponds to the same patient in both tables.\n\n3. **Diagnosis Filtering**: The query filters the joined data to include only those records where the `Diagnosis` column in the `Patient` table (`T1.Diagnosis`) is equal to 'SLE'.\n\n4. **WBC Level Filtering**: The query further filters the data to include only those records where the `WBC` column in the `Laboratory` table (`T2.WBC`) falls within the normal range, specifically between 3.5 and 9.\n\n5. **Counting Patients**: The query then counts the number of distinct patient IDs (`T1.ID`) that meet both the diagnosis and WBC level criteria.\n\nThe final result is the count of patients diagnosed with SLE who have a normal WBC level."
        ]
    },
    "1020": {
        "sql": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
        "explain": "highest overall rating refers to MAX(overall_rating);",
        "solution": [
            "To find the player with the highest overall rating and indicate their API ID, follow these steps:\n\n1. **Access the Player_Attributes table**: This table contains the data about players' attributes, including their overall ratings.\n\n2. **Sort the players by overall rating**: Arrange the players in descending order based on their overall rating. This ensures the player with the highest rating appears at the top of the list.\n\n3. **Select the top player**: Retrieve the player at the top of the sorted list, which will be the one with the highest overall rating.\n\n4. **Extract the player's API ID**: From the selected player, obtain their `player_api_id` to identify them uniquely.\n\nThe final result will be the `player_api_id` of the player with the highest overall rating."
        ]
    },
    "41": {
        "sql": "WITH RankedSchools AS (\n    SELECT \n        T2.School AS SchoolName,\n        T2.County AS County,\n        T1.AvgScrRead AS AvgReadingScore,\n        RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk\n    FROM \n        satscores T1\n    JOIN \n        schools T2 ON T1.cds = T2.CDSCode\n    WHERE \n        T2.Virtual = 'F'\n)\nSELECT \n    SchoolName\nFROM \n    RankedSchools\nWHERE \n    rnk <= 5\nORDER BY \n    County, rnk;",
        "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
        "explain": "Exclusively virtual refers to Virtual = 'F'; respective counties means PARTITION BY County",
        "solution": [
            "To solve the question, we need to list the names of virtual schools that are among the top 5 in their respective counties based on average reading scores. Here's the step-by-step solution:\n\n1. **Join Tables**: Combine the `satscores` table (aliased as `T1`) and the `schools` table (aliased as `T2`) using the common field `cds` from `satscores` and `CDSCode` from `schools`.\n\n2. **Filter Virtual Schools**: Ensure that only virtual schools are considered by filtering records where `T2.Virtual` equals 'F'.\n\n3. **Calculate Rankings**: For each county, rank the schools based on their average reading scores (`T1.AvgScrRead`) in descending order. This is done using the `RANK()` window function partitioned by `T2.County`.\n\n4. **Filter Top 5 Schools**: Select only those schools whose rank (`rnk`) is 5 or lower, meaning they are in the top 5 for their county.\n\n5. **Retrieve School Names**: Finally, extract the names of these top-ranked schools from the result set.\n\nThe SQL query accomplishes this by creating a subquery that ranks the schools and then filtering the results to include only the top 5 schools per county."
        ]
    },
    "721": {
        "sql": "SELECT COUNT(*) AS blue_eyed_superheroes\nFROM superhero\nWHERE eye_colour_id = (SELECT id FROM colour WHERE colour = 'Blue');",
        "question": "How many superheroes have blue eyes?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue'",
        "explain": "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id;",
        "solution": []
    },
    "310": {
        "sql": "SELECT \n    COUNT(DISTINCT T1.molecule_id) AS total_molecules_with_double_bonds,\n    SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS carcinogenic_compounds\nFROM \n    bond T1\nJOIN \n    molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T1.bond_type = '=';",
        "question": "How many molecules have a double bond type and among these molecule, how many are labeled as carcinogenic compound?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id), SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '='",
        "explain": "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Filter Bonds by Type**: First, filter the `bond` table (referred to as `T1`) to include only those records where the `bond_type` is a double bond, indicated by the value `=`.\n\n2. **Join with Molecules**: Next, join the filtered `bond` table (`T1`) with the `molecule` table (referred to as `T2`) using the `molecule_id` field. This ensures that only molecules with at least one double bond are considered.\n\n3. **Count Distinct Molecules**: Calculate the count of distinct `molecule_id` values from the joined result. This gives the total number of unique molecules that have at least one double bond.\n\n4. **Count Carcinogenic Compounds**: Among the molecules identified in the previous step, count how many are labeled as carcinogenic. This is done by summing up the cases where the `label` field in the `molecule` table (`T2`) is `+`. Each `+` label increments the count by 1, while other labels do not contribute to the count.\n\nThe final result will display two values:\n- The first value is the count of distinct molecules with double bonds.\n- The second value is the count of these molecules that are labeled as carcinogenic."
        ]
    },
    "1366": {
        "sql": "SELECT DISTINCT m.member_id\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'October Meeting';",
        "question": "List all the members who attended the event \"October Meeting\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.member_id FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'October Meeting'",
        "explain": "'October Meeting' is an event name;",
        "solution": [
            "To list all the members who attended the event \"October Meeting\", follow these steps:\n\n1. **Identify the event**: Locate the event named \"October Meeting\" in the `event` table (referred to as `T1`).\n\n2. **Link to attendance records**: Using the `event_id` from the identified event, find all corresponding records in the `attendance` table (referred to as `T2`) where the `link_to_event` field matches the `event_id`.\n\n3. **Link to member records**: For each attendance record found, use the `link_to_member` field to locate the corresponding member in the `member` table (referred to as `T3`).\n\n4. **Retrieve member IDs**: Extract the `member_id` from each of these member records.\n\n5. **Ensure uniqueness**: Remove any duplicate `member_id` entries to ensure each member is listed only once.\n\nThe result will be a distinct list of `member_id` values for all members who attended the \"October Meeting\" event."
        ]
    },
    "1286": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) AS AdmittedPatientsWithAbnormalALP\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP >= 300 AND T1.Admission = '+'",
        "question": "For the patient with an abnormal alkaliphophatase level, how many of them are admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP >= 300 AND T1.Admission = '+'",
        "explain": "abnormal alkaliphophatase level refers to ALP > = 300; admitted to the hospital refers to Admission = '+';",
        "solution": [
            "To solve the question, we need to count the number of patients who have an abnormal alkaline phosphatase level (ALP \u2265 300) and are also admitted to the hospital. The solution involves the following steps:\n\n1. **Identify Patients with Abnormal ALP Levels**: Filter the `Laboratory` table to find all records where the `ALP` (alkaline phosphatase) level is 300 or higher.\n\n2. **Check Hospital Admission Status**: For each patient identified in the first step, check their admission status in the `Patient` table. Only include patients where the `Admission` field is marked as '+' (indicating they are admitted).\n\n3. **Count the Patients**: Count the number of patients who meet both criteria (abnormal ALP level and admitted to the hospital).\n\nThe SQL query performs these operations by joining the `Patient` and `Laboratory` tables on the patient ID, filtering for the specified conditions, and then counting the results.",
            "To solve the question, we need to count the number of patients who have an abnormal alkaline phosphatase level (ALP \u2265 300) and are also admitted to the hospital. The solution involves the following detailed steps:\n\n1. **Join Tables on Patient ID**: Combine the `Patient` table (referred to as `T1`) and the `Laboratory` table (referred to as `T2`) using the patient ID (`ID`) as the common key. This ensures that each patient's laboratory results are linked to their admission status.\n\n2. **Filter for Abnormal ALP Levels**: From the joined tables, filter the records to include only those where the `ALP` (alkaline phosphatase) level in the `Laboratory` table (`T2.ALP`) is 300 or higher. This identifies patients with abnormal ALP levels.\n\n3. **Filter for Admitted Patients**: Further refine the filtered records to include only those patients whose admission status in the `Patient` table (`T1.Admission`) is marked as '+', indicating they are admitted to the hospital.\n\n4. **Count the Patients**: Finally, count the number of unique patient IDs (`T1.ID`) that meet both criteria (abnormal ALP level and hospital admission). This count represents the answer to the question.\n\nThe SQL query performs these operations in a single step by joining the tables, applying the filters, and then counting the results."
        ]
    },
    "1062": {
        "sql": "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating > 80\nAND pa.date BETWEEN '2008-01-01' AND '2010-12-31';\n",
        "question": "Which players had an overall rating of over 80 from 2008 to 2010? Please list player names.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating > 80 AND SUBSTR(t2.`date`, 1, 4) BETWEEN '2008' AND '2010'",
        "explain": "overall_rating > 80; from 2008 to 2010 refers to strftime('%Y', date) BETWEEN '2008' AND '2010';",
        "solution": []
    },
    "904": {
        "sql": "SELECT T1.name AS race_name, T1.year AS race_year\nFROM races T1\nJOIN lapTimes T2 ON T1.raceId = T2.raceId\nJOIN drivers T3 ON T2.driverId = T3.driverId\nWHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher'\nORDER BY T2.milliseconds ASC\nLIMIT 1;",
        "question": "State the race and year of race in which Michael Schumacher had his fastest lap.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' ORDER BY T2.milliseconds ASC LIMIT 1",
        "explain": "fastest lap refers to min(milliseconds); Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "solution": [
            "To find the race and year in which Michael Schumacher had his fastest lap, follow these steps:\n\n1. **Join the tables**: Combine the `races` table (aliased as `T1`), the `lapTimes` table (aliased as `T2`), and the `drivers` table (aliased as `T3`).\n   - Link `T2.raceId` to `T1.raceId` to associate lap times with their respective races.\n   - Link `T3.driverId` to `T2.driverId` to associate lap times with the driver.\n\n2. **Filter for Michael Schumacher**: Use the condition `T3.forename = 'Michael' AND T3.surname = 'Schumacher'` to ensure only data related to Michael Schumacher is considered.\n\n3. **Order by lap time**: Sort the results by `T2.milliseconds` in ascending order to find the fastest lap (lowest milliseconds).\n\n4. **Limit the result**: Retrieve only the top result (`LIMIT 1`) to get the race and year of Michael Schumacher's fastest lap.\n\nThe final output will display the `name` of the race and the `year` it occurred."
        ]
    },
    "37": {
        "sql": "SELECT s.Street, s.City, s.State, s.Zip\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.NumTstTakr > 0\nORDER BY (sc.NumGE1500 * 1.0 / sc.NumTstTakr) ASC\nLIMIT 1;",
        "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
        "explain": "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code",
        "solution": []
    },
    "1131": {
        "sql": "SELECT AVG(P.height) AS average_height\nFROM Player P\nJOIN Match M ON P.player_api_id = M.home_player_1 OR P.player_api_id = M.home_player_2 OR P.player_api_id = M.home_player_3 OR P.player_api_id = M.home_player_4 OR P.player_api_id = M.home_player_5 OR P.player_api_id = M.home_player_6 OR P.player_api_id = M.home_player_7 OR P.player_api_id = M.home_player_8 OR P.player_api_id = M.home_player_9 OR P.player_api_id = M.home_player_10 OR P.player_api_id = M.home_player_11 OR P.player_api_id = M.away_player_1 OR P.player_api_id = M.away_player_2 OR P.player_api_id = M.away_player_3 OR P.player_api_id = M.away_player_4 OR P.player_api_id = M.away_player_5 OR P.player_api_id = M.away_player_6 OR P.player_api_id = M.away_player_7 OR P.player_api_id = M.away_player_8 OR P.player_api_id = M.away_player_9 OR P.player_api_id = M.away_player_10 OR P.player_api_id = M.away_player_11\nJOIN Country C ON M.country_id = C.id\nWHERE C.name = 'Italy';",
        "question": "What is the average heights of Italy players?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) FROM Player AS T1 INNER JOIN Match AS T2 ON T1.id = T2.id INNER JOIN Country AS T3 ON T2.country_id = T3.ID WHERE T3.NAME = 'Italy'",
        "explain": "average heights refers to Avg(height); Italy is name of country",
        "solution": [
            "To find the average height of Italy players, follow these steps:\n1. **Join the tables**: Combine the `Player` table (T1), `Match` table (T2), and `Country` table (T3) where the player's ID matches the match's player ID and the match's country ID matches the country's ID.\n2. **Filter for Italy**: From the joined tables, select only the records where the country name is 'Italy'.\n3. **Calculate the average height**: Sum the heights of all Italy players and divide this sum by the total number of Italy players to get the average height. The result is cast to a real number for precision.",
            "To find the average height of Italy players, follow these steps:\n1. **Join the tables**: Combine the `Player` table (T1) and the `Match` table (T2) where the player's ID in the `Player` table matches the player's ID in the `Match` table. Then, join the result with the `Country` table (T3) where the country ID in the `Match` table matches the country ID in the `Country` table.\n2. **Filter for Italy**: From the joined tables, select only the records where the country name in the `Country` table is 'Italy'.\n3. **Calculate the average height**: Sum the heights of all Italy players from the `Player` table and divide this sum by the total number of Italy players (counted by their IDs in the `Player` table). The result is cast to a real number for precision."
        ]
    },
    "2": {
        "sql": "SELECT T2.Zip\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1;",
        "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
        "explain": "Charter schools refers to `Charter School (Y/N)` = 1 in the table fprm",
        "solution": [
            "1. **Joining the enrollment and schools data:**  \n   The query uses an `INNER JOIN` between two tables: `frpm` (aliased as T1) and `schools` (aliased as T2). These tables are linked together using the `CDSCode` column, ensuring that each enrollment record is matched with its corresponding school data.\n\n2. **Filtering for Fresno County Office of Education and charter schools:**  \n   The query applies two conditions in the `WHERE` clause:  \n   - The `District Name` in the `frpm` table (T1) must be exactly \"Fresno County Office of Education\".  \n   - The `Charter School (Y/N)` column in the `frpm` table (T1) must have a value of 1, indicating that the school is a charter school.\n\n3. **Selecting the zip code:**  \n   From the `schools` table (T2), the query selects the `Zip` column, which contains the zip code of each school. This is the specific information requested by the question.\n\n4. **Output:**  \n   The result of the query will list the zip codes of all charter schools under the Fresno County Office of Education, as filtered and joined in the previous steps."
        ]
    },
    "1252": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nJOIN Examination T3 ON T1.ID = T3.ID \nWHERE T2.IGG BETWEEN 900 AND 2000 \nAND T3.Symptoms IS NOT NULL;",
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "explain": "normal Ig G level refers to IGG > 900 and IGG < 2000; have symptoms refers to Symptoms IS NOT NULL;",
        "solution": [
            "To solve the question, 'Among the patients with a normal Ig G level, how many of them have symptoms?', the following steps are performed:\n\n1. **Identify Patients with Normal Ig G Levels**: Filter the `Laboratory` table to include only those records where the Ig G level (`IGG`) falls within the normal range (between 900 and 2000).\n\n2. **Join Relevant Tables**: Combine the `Patient`, `Laboratory`, and `Examination` tables using the `ID` field to link them. This ensures that the data from all three tables is aligned correctly for each patient.\n\n3. **Filter Patients with Symptoms**: From the joined data, further filter the records to include only those patients who have symptoms, i.e., where the `Symptoms` field in the `Examination` table is not null.\n\n4. **Count the Patients**: Finally, count the number of patients who meet both criteria (normal Ig G levels and presence of symptoms).\n\nThe SQL query accomplishes this by selecting the count of patient IDs (`T1.ID`) from the joined tables where the Ig G level is between 900 and 2000 and symptoms are present.",
            "To solve the question, 'Among the patients with a normal Ig G level, how many of them have symptoms?', the following detailed steps are performed:\n\n1. **Identify Patients with Normal Ig G Levels**: Filter the `Laboratory` table to include only those records where the Ig G level (`IGG`) is within the normal range, specifically between 900 and 2000.\n\n2. **Join the Patient Table**: Combine the `Patient` table with the filtered `Laboratory` table using the `ID` field to link them. This ensures that each patient's laboratory data is correctly associated with their patient record.\n\n3. **Join the Examination Table**: Further join the result with the `Examination` table using the `ID` field to link it. This step ensures that each patient's examination data is included in the dataset.\n\n4. **Filter Patients with Symptoms**: From the joined dataset, filter the records to include only those patients who have symptoms, i.e., where the `Symptoms` field in the `Examination` table is not null.\n\n5. **Count the Patients**: Finally, count the number of distinct patient IDs (`T1.ID`) from the filtered and joined dataset. This count represents the number of patients with normal Ig G levels who also have symptoms.\n\nThe SQL query accomplishes this by selecting the count of patient IDs (`T1.ID`) from the joined tables where the Ig G level is between 900 and 2000 and symptoms are present."
        ]
    },
    "299": {
        "sql": "SELECT label FROM molecule WHERE molecule_id = 'TR124';",
        "question": "Is molecule TR124 carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
        "explain": "label = '+' mean molecules are carcinogenic;",
        "solution": []
    },
    "1267": {
        "sql": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
        "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
        "explain": "normal anti-SM refers to SM IN('-', '+-'); SM = 'negative' means '-'; SM = '0' means '+-'; SM = '1' means '+'; does not have thrombosis refers to Thrombosis = 0;",
        "solution": [
            "To solve the question, 'Among the patients with normal anti-SM, how many of them do not have thrombosis?', the following steps are performed:\n\n1. **Join the Tables**: Combine the `Examination` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) using the `ID` column as the common key.\n\n2. **Filter for Normal Anti-SM**: From the joined tables, filter the records where the `SM` column in the `Laboratory` table (`T2.SM`) has values 'negative' or '0', indicating normal anti-SM levels.\n\n3. **Filter for No Thrombosis**: Further filter the records to include only those where the `Thrombosis` column in the `Examination` table (`T1.Thrombosis`) is '0', indicating no thrombosis.\n\n4. **Count the Patients**: Finally, count the number of unique patient IDs (`T1.ID`) that meet both criteria (normal anti-SM and no thrombosis).\n\nThis process ensures that we accurately count the patients who have normal anti-SM levels and do not have thrombosis.",
            "To solve the question, 'Among the patients with normal anti-SM, how many of them do not have thrombosis?', the following detailed steps are performed:\n\n1. **Join the Tables**: The `Examination` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) are joined together using the `ID` column as the common key. This ensures that each patient's examination and laboratory data are linked.\n\n2. **Filter for Normal Anti-SM**: From the joined tables, filter the records to include only those where the `SM` column in the `Laboratory` table (`T2.SM`) has values 'negative' or '0'. These values indicate normal anti-SM levels.\n\n3. **Filter for No Thrombosis**: Further refine the filtered records to include only those where the `Thrombosis` column in the `Examination` table (`T1.Thrombosis`) is '0'. This indicates that the patient does not have thrombosis.\n\n4. **Count the Patients**: Finally, count the number of unique patient IDs (`T1.ID`) that meet both criteria (normal anti-SM levels and no thrombosis). This count represents the number of patients with normal anti-SM who do not have thrombosis.\n\nThe SQL query for this operation is: `SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0`."
        ]
    },
    "1335": {
        "sql": "SELECT SUM(b.spent) AS total_spent_on_advertisement\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'September Meeting' AND b.category = 'Advertisement';",
        "question": "How much did the Student_Club members spend on advertisement in September Meeting?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Advertisement' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "explain": "amount spent refers to spent; spend on food in September Meeting refers to category = 'Advertisement' where event_name = 'September Meeting'",
        "solution": []
    },
    "169": {
        "sql": "WITH male_loans AS (\n    SELECT \n        STRFTIME('%Y', l.date) AS year,\n        SUM(l.amount) AS total_amount\n    FROM \n        loan l\n    JOIN \n        account a ON l.account_id = a.account_id\n    JOIN \n        disp d ON a.account_id = d.account_id\n    JOIN \n        client c ON d.client_id = c.client_id\n    WHERE \n        c.gender = 'M' AND d.type = 'OWNER'\n        AND (STRFTIME('%Y', l.date) IN ('1996', '1997')\n    GROUP BY \n        STRFTIME('%Y', l.date)\nSELECT \n    ((SELECT total_amount FROM male_loans WHERE year = '1997') - \n     (SELECT total_amount FROM male_loans WHERE year = '1996')) * 100.0 / \n    (SELECT total_amount FROM male_loans WHERE year = '1996') AS growth_rate_percentage;",
        "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
        "explain": "Growth rate = (sum of amount_1997 - sum of amount_1996) / (sum of amount_1996) * 100%; Male refers to gender = 'M'",
        "solution": [
            "To determine the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997, follow these steps:\n\n1. **Filter Data**:\n   - Retrieve loan records from the `loan` table (`T1`).\n   - Join the `account` table (`T2`) to link loans to accounts using the `account_id`.\n   - Join the `disp` table (`T3`) to link accounts to clients, ensuring the client is the owner (`type = 'OWNER'`).\n   - Join the `client` table (`T4`) to filter for male clients (`gender = 'M'`).\n\n2. **Calculate Loan Amounts by Year**:\n   - Sum the loan amounts for the year 1996 (`STRFTIME('%Y', T1.date) = '1996'`).\n   - Sum the loan amounts for the year 1997 (`STRFTIME('%Y', T1.date) = '1997'`).\n\n3. **Compute Growth Rate**:\n   - Subtract the total loan amount for 1996 from the total loan amount for 1997.\n   - Divide the result by the total loan amount for 1996.\n   - Multiply by 100 to convert the growth rate into a percentage.\n\n4. **Output the Result**:\n   - The final result is the growth rate expressed as a percentage.",
            "To determine the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997, follow these steps:\n\n1. **Filter Data**:\n   - Retrieve loan records from the `loan` table (`T1`).\n   - Join the `account` table (`T2`) to link loans to accounts using the `account_id`.\n   - Join the `disp` table (`T3`) to link accounts to clients, ensuring the client is the owner (`type = 'OWNER'`).\n   - Join the `client` table (`T4`) to filter for male clients (`gender = 'M'`).\n\n2. **Calculate Loan Amounts by Year**:\n   - Sum the loan amounts for the year 1996 (`STRFTIME('%Y', T1.date) = '1996'`).\n   - Sum the loan amounts for the year 1997 (`STRFTIME('%Y', T1.date) = '1997'`).\n\n3. **Compute Growth Rate**:\n   - Subtract the total loan amount for 1996 from the total loan amount for 1997.\n   - Divide the result by the total loan amount for 1996.\n   - Multiply by 100 to convert the growth rate into a percentage.\n\n4. **Output the Result**:\n   - The final result is the growth rate expressed as a percentage.\n\n**SQL Translation**:\nThe SQL query performs the following operations:\n- Joins the `loan`, `account`, `disp`, and `client` tables to filter loans for male clients who are account owners.\n- Uses conditional aggregation to sum loan amounts for 1996 and 1997 separately.\n- Computes the growth rate by comparing the sums for 1996 and 1997, then converts it to a percentage."
        ]
    },
    "907": {
        "sql": "SELECT DISTINCT T2.name, T1.country FROM circuits T1 JOIN races T2 ON T1.circuitId = T2.circuitId WHERE T2.year = 2017 ORDER BY T2.date;",
        "question": "List all races in 2017 and the hosting country order by date of the event.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name, T1.country FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2017 ORDER BY T2.date ASC",
        "explain": "",
        "solution": [
            "To list all races in 2017 along with their hosting countries, ordered by the date of the event, follow these steps:\n\n1. **Identify the tables involved**: The query uses two tables, `circuits` (aliased as `T1`) and `races` (aliased as `T2`).\n\n2. **Join the tables**: The query performs an inner join between `circuits` and `races` on the condition that the `circuitID` in the `races` table matches the `circuitId` in the `circuits` table.\n\n3. **Filter the data**: The query filters the results to include only races from the year 2017 by checking the `year` column in the `races` table.\n\n4. **Select the required columns**: The query selects the `name` column from the `races` table (aliased as `T2`) and the `country` column from the `circuits` table (aliased as `T1`).\n\n5. **Remove duplicates**: The `DISTINCT` keyword ensures that only unique combinations of race names and hosting countries are returned.\n\n6. **Order the results**: The results are ordered by the `date` column in the `races` table in ascending order (from earliest to latest).\n\nThis sequence of operations will produce the desired list of races and their hosting countries for the year 2017, sorted by the event date."
        ]
    },
    "408": {
        "sql": "SELECT T2.text\nFROM cards T1\nJOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE (T1.power IS NULL OR T1.power = '*')\nAND T2.text LIKE '%triggered ability%';",
        "question": "How many unknown power cards contain info about the triggered ability",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power = '*') AND T2.text LIKE '%triggered ability%'",
        "explain": "unknown power cards refers to power is null or power = '*';contain info about the triggered ability refers to text contains 'triggered ability'",
        "solution": [
            "To solve the question \"How many unknown power cards contain info about the triggered ability,\" the following steps are performed:\n\n1. **Join the Tables**: Combine the `cards` table (referred to as `T1`) and the `rulings` table (referred to as `T2`) using the `uuid` field as the common key. This ensures that each card is matched with its corresponding rulings.\n\n2. **Filter for Unknown Power Cards**: From the joined tables, filter the cards where the `power` field in the `cards` table (`T1.power`) is either `NULL` or equal to `'*'`. This identifies cards with unknown or unspecified power values.\n\n3. **Search for Triggered Ability Info**: Further filter the results to include only those entries where the `text` field in the `rulings` table (`T2.text`) contains the phrase \"triggered ability\". This ensures that only rulings mentioning triggered abilities are considered.\n\n4. **Retrieve Relevant Text**: Finally, select the `text` field from the `rulings` table (`T2.text`) for the filtered entries, which provides the specific information about the triggered ability for the unknown power cards.\n\nThis process ensures that the query accurately identifies and retrieves the relevant information as specified in the question.",
            "To solve the question \"How many unknown power cards contain info about the triggered ability,\" the following detailed steps are performed:\n\n1. **Select the Relevant Data**: The query begins by selecting the `text` field from the `rulings` table (aliased as `T2`). This field contains the information about the rulings for each card.\n\n2. **Join the Tables**: The `cards` table (aliased as `T1`) is joined with the `rulings` table (aliased as `T2`) using the `uuid` field as the common key. This ensures that each card is matched with its corresponding rulings.\n\n3. **Filter for Unknown Power Cards**: The query filters the joined tables to include only those cards where the `power` field in the `cards` table (`T1.power`) is either `NULL` or equal to `'*'`. This identifies cards with unknown or unspecified power values.\n\n4. **Search for Triggered Ability Info**: The query further filters the results to include only those entries where the `text` field in the `rulings` table (`T2.text`) contains the phrase \"triggered ability\". This ensures that only rulings mentioning triggered abilities are considered.\n\n5. **Retrieve the Results**: The final output is the `text` field from the `rulings` table (`T2.text`) for the filtered entries, which provides the specific information about the triggered ability for the unknown power cards.\n\nThis process ensures that the query accurately identifies and retrieves the relevant information as specified in the question."
        ]
    },
    "726": {
        "sql": "SELECT \n    s.superhero_name,\n    s.height_cm,\n    RANK() OVER (ORDER BY s.height_cm DESC) AS height_rank\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    p.publisher_name = 'Marvel Comics'\nORDER BY \n    s.height_cm DESC;",
        "question": "Rank heroes published by Marvel Comics by their height in descending order.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
        "explain": "name refers to superhero_name; the tallest hero refers to MAX(height_cm); published by Marvel Comics refers to publisher_name = 'Marvel Comics'",
        "solution": [
            "To solve the question \"Rank heroes published by Marvel Comics by their height in descending order,\" the following steps are performed:\n\n1. **Select the Required Columns**: The query retrieves the `superhero_name` and `height_cm` columns from the `superhero` table.\n\n2. **Join with Publisher Table**: The `superhero` table is joined with the `publisher` table using the `publisher_id` column to ensure we only consider heroes published by Marvel Comics.\n\n3. **Filter by Publisher**: The query filters the results to include only those heroes where the `publisher_name` is 'Marvel Comics'.\n\n4. **Rank by Height**: The `RANK()` window function is used to assign a rank to each hero based on their `height_cm` in descending order. This means the tallest hero will have the highest rank (1).\n\n5. **Display the Results**: The final output includes the hero's name, their height in centimeters, and their rank based on height.\n\nThis solution ensures that the heroes are correctly ranked by height, with the tallest hero at the top of the list."
        ]
    },
    "1003": {
        "sql": "SELECT COUNT(*) AS accident_count\nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nJOIN status T3 ON T1.statusId = T3.statusId\nWHERE T3.statusId = 3 AND T2.name = 'Canadian Grand Prix'\nGROUP BY T1.driverId\nORDER BY accident_count DESC\nLIMIT 1;",
        "question": "How many accidents did the driver who had the highest number accidents in the Canadian Grand Prix have?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN status AS T3 on T1.statusId = T3.statusId WHERE T3.statusId = 3 AND T2.name = 'Canadian Grand Prix' GROUP BY T1.driverId ORDER BY COUNT(T1.driverId) DESC LIMIT 1",
        "explain": "number of accidents refers to the number where statusid = 3; Canadian Grand Prix refers to the race of name\n",
        "solution": [
            "To determine how many accidents the driver with the highest number of accidents in the Canadian Grand Prix had, follow these steps:\n\n1. **Join the Tables**: Combine the `results` table (T1), the `races` table (T2), and the `status` table (T3).\n   - Link `results` (T1) and `races` (T2) using the `raceId` field.\n   - Link `results` (T1) and `status` (T3) using the `statusId` field.\n\n2. **Filter the Data**:\n   - Only include records where the `statusId` in the `status` table (T3) is `3` (indicating an accident).\n   - Only include records where the race name in the `races` table (T2) is `Canadian Grand Prix`.\n\n3. **Group the Data**: Group the filtered records by the `driverId` from the `results` table (T1).\n\n4. **Count Accidents**: For each driver, count the number of accidents (records) they have in the filtered dataset.\n\n5. **Sort and Limit**:\n   - Sort the results in descending order based on the count of accidents.\n   - Limit the output to the top result, which represents the driver with the highest number of accidents.\n\n6. **Retrieve the Count**: The final output is the count of accidents for the driver who had the highest number of accidents in the Canadian Grand Prix."
        ]
    },
    "1337": {
        "sql": "SELECT SUM(amount) AS total_budgeted_amount\nFROM budget\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'October Speaker');",
        "question": "What is the total budgeted amount for all category in \"October Speaker\" event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.amount) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'October Speaker'",
        "explain": "total budgeted amount refers to SUM(amount) where event_name = 'October Speaker'",
        "solution": []
    },
    "933": {
        "sql": "SELECT r.positionOrder \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' \nAND ra.year = 2008 AND ra.name = 'Chinese Grand Prix';",
        "question": "What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.positionOrder FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.name = 'Chinese Grand Prix' AND T1.year = 2008",
        "explain": "Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; final rank refers to positionOrder; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
        "solution": []
    },
    "1287": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) AS Normal_ALP_Patient_Count\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '-' AND T2.ALP < 300;",
        "question": "Among the patients followed at the outpatient clinic, how many of them have a normal level of alkaliphophatase?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300 AND T1.Admission = '-'",
        "explain": "followed at the outpatient clinic refers to Admission = '-'; normal level of alkaliphophatase refers to ALP < 300;",
        "solution": [
            "To determine how many patients followed at the outpatient clinic have a normal level of alkaline phosphatase, follow these steps:\n\n1. **Identify the Patients**: Focus on the `Patient` table (referred to as `T1` in the SQL query).\n2. **Filter Outpatient Clinic Patients**: From the `Patient` table, select only those patients where the `Admission` field is marked as `'-'`, indicating they are followed at the outpatient clinic.\n3. **Join with Laboratory Data**: Link the filtered patients to their corresponding records in the `Laboratory` table (referred to as `T2` in the SQL query) using the `ID` field as the common key.\n4. **Check Alkaline Phosphatase Levels**: From the joined data, further filter the records to include only those where the `ALP` (alkaline phosphatase) value in the `Laboratory` table is less than 300, which indicates a normal level.\n5. **Count the Patients**: Finally, count the number of unique patient IDs (`ID`) that meet all the above criteria.\n\nThe result will be the total number of outpatient clinic patients with a normal alkaline phosphatase level.",
            "To determine how many patients followed at the outpatient clinic have a normal level of alkaline phosphatase, follow these steps:\n\n1. **Identify the Patients**: Focus on the `Patient` table (referred to as `T1` in the SQL query).\n2. **Filter Outpatient Clinic Patients**: From the `Patient` table, select only those patients where the `Admission` field is marked as `'-'`, indicating they are followed at the outpatient clinic.\n3. **Join with Laboratory Data**: Link the filtered patients to their corresponding records in the `Laboratory` table (referred to as `T2` in the SQL query) using the `ID` field as the common key.\n4. **Check Alkaline Phosphatase Levels**: From the joined data, further filter the records to include only those where the `ALP` (alkaline phosphatase) value in the `Laboratory` table is less than 300, which indicates a normal level.\n5. **Count the Patients**: Finally, count the number of unique patient IDs (`ID`) that meet all the above criteria.\n\nThe result will be the total number of outpatient clinic patients with a normal alkaline phosphatase level."
        ]
    },
    "856": {
        "sql": "SELECT r.time \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.name = 'Sepang International Circuit';",
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "explain": "",
        "solution": []
    },
    "1138": {
        "sql": "SELECT c.name \nFROM League l \nJOIN Country c ON l.country_id = c.id \nWHERE l.name = 'Poland Ekstraklasa';",
        "question": "In what country did the Poland Ekstraklasa take place?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT name FROM Country WHERE id IN ( SELECT country_id FROM League WHERE name = 'Poland Ekstraklasa' )",
        "explain": "",
        "solution": []
    },
    "743": {
        "sql": "WITH total_superheroes AS (\n    SELECT COUNT(*) AS total_count FROM superhero\n),\nbad_superheroes AS (\n    SELECT COUNT(*) AS bad_count FROM superhero\n    JOIN alignment ON superhero.alignment_id = alignment.id\n    WHERE alignment.alignment = 'Bad'\n),\nmarvel_bad_superheroes AS (\n    SELECT COUNT(*) AS marvel_bad_count FROM superhero\n    JOIN alignment ON superhero.alignment_id = alignment.id\n    JOIN publisher ON superhero.publisher_id = publisher.id\n    WHERE alignment.alignment = 'Bad' AND publisher.publisher_name = 'Marvel Comics'\n)\nSELECT \n    (bad_superheroes.bad_count * 100.0 / total_superheroes.total_count) AS percentage_bad,\n    marvel_bad_superheroes.marvel_bad_count AS marvel_bad_count\nFROM \n    total_superheroes, \n    bad_superheroes, \n    marvel_bad_superheroes;",
        "question": "What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT (CAST(COUNT(*) AS REAL) * 100 / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE T3.alignment = 'Bad'",
        "explain": "published by Marvel Comics refers to publisher_name = 'Marvel Comics'; superheroes who act in their own self-interest or make decisions based on their own moral code refers to alignment = 'Bad'; calculation = MULTIPLY(DIVIDE(SUM(alignment = 'Bad); count(id)), 100)",
        "solution": []
    },
    "1443": {
        "sql": "SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';",
        "question": "Give the event ID, location, and status of events conducted from November 2019 to March 2020.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT event_id, location, status FROM event WHERE date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-11-01' AND '2020-03-31'",
        "explain": "event_date BETWEEN '2019-11-01' and '2020-03-31'",
        "solution": []
    },
    "1078": {
        "sql": "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1;",
        "question": "Which player is older, Aaron Lennon or Abdelaziz Barrada?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1",
        "explain": "The larger the birthday value, the younger the person is, and vice versa;",
        "solution": [
            "To determine which player is older between Aaron Lennon and Abdelaziz Barrada, follow these steps:\n\n1. **Retrieve the Players**: Access the `Player` table to fetch the records for the players named 'Aaron Lennon' and 'Abdelaziz Barrada'.\n\n2. **Sort by Birthday**: Arrange the retrieved players in ascending order based on their `birthday` field. This will place the older player (the one with the earlier birthday) first in the list.\n\n3. **Select the Older Player**: From the sorted list, pick the first player, as this will be the older one due to the ascending order sorting.\n\n4. **Return the Result**: Display the name of the older player.\n\nThis process ensures that the player with the earlier birthday (and thus the older one) is identified and returned.",
            "To determine which player is older between Aaron Lennon and Abdelaziz Barrada, follow these detailed steps:\n\n1. **Filter the Players**: Query the `Player` table to specifically retrieve the records for the players named 'Aaron Lennon' and 'Abdelaziz Barrada' using the condition `WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada')`.\n\n2. **Sort by Birthday**: Once the players are retrieved, sort them in ascending order based on their `birthday` field. This ensures that the player with the earlier birthday (the older one) appears first in the result set. The sorting is done using `ORDER BY birthday ASC`.\n\n3. **Limit the Result**: Since we only need the oldest player among the two, limit the result to the first record in the sorted list using `LIMIT 1`.\n\n4. **Retrieve the Player Name**: Finally, select and return the `player_name` of the first record in the sorted and limited result set, which corresponds to the older player.\n\nThis method guarantees that the correct older player is identified by leveraging the database's sorting and filtering capabilities."
        ]
    },
    "369": {
        "sql": "SELECT COUNT(DISTINCT c.uuid) \nFROM cards c \nJOIN foreign_data fd ON c.uuid = fd.uuid \nWHERE fd.language = 'German' AND c.isReprint = 1;",
        "question": "How many cards that illusrtated in German have been reprinted?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.isReprint = 1",
        "explain": "German' is the language; reprinted refers to isReprint = 1;",
        "solution": []
    },
    "1178": {
        "sql": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND \"First Date\" IS NOT NULL ORDER BY \"First Date\" ASC LIMIT 1;",
        "question": "What was the gender of the first AORTITIS diagnosed patient?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
        "explain": "gender means SEX; 'AORTITIS' refers to Diagnosis;",
        "solution": [
            "To determine the gender of the first patient diagnosed with AORTITIS, follow these steps:\n\n1. **Filter the Patient Table**: Identify all patients in the Patient table whose diagnosis is 'AORTITIS' and whose 'First Date' field is not null. This ensures we only consider patients with a recorded diagnosis date.\n\n2. **Sort by First Date**: Arrange the filtered patients in ascending order based on their 'First Date'. This will list the patients from the earliest to the latest diagnosis date.\n\n3. **Select the First Patient**: From the sorted list, pick the very first patient (the one with the earliest diagnosis date).\n\n4. **Retrieve the Gender**: Extract the 'SEX' field of this patient to determine their gender.\n\nThe result will be the gender of the first patient diagnosed with AORTITIS."
        ]
    },
    "829": {
        "sql": "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'DC Comics')) - \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) AS difference;",
        "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "explain": "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; difference = SUBTRACT(SUM(publisher_name = 'DC Comics'), SUM(publisher_name = 'Marvel Comics'));",
        "solution": []
    },
    "91": {
        "sql": "SELECT CASE WHEN AVG(A13) > AVG(A12) THEN '1996' ELSE '1995' END AS higher_unemployment_year FROM district;",
        "question": "The average unemployment ratio of 1995 and 1996, which one has higher percentage?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT IIF(AVG(A13) > AVG(A12), '1996', '1995') FROM district",
        "explain": "A12 refers to unemploymant rate 1995; A13 refers to unemploymant rate 1996",
        "solution": [
            "To determine which year, 1995 or 1996, has a higher average unemployment ratio, the following steps are performed:\n\n1. Calculate the average unemployment ratio for the year 1995 (represented by column `A12` in the database).\n2. Calculate the average unemployment ratio for the year 1996 (represented by column `A13` in the database).\n3. Compare the two average values:\n   - If the average of `A13` (1996) is greater than the average of `A12` (1995), the result is '1996'.\n   - Otherwise, the result is '1995'.\n\nThe final output is a single distinct value indicating the year with the higher average unemployment ratio."
        ]
    },
    "231": {
        "sql": "SELECT bond_type FROM (SELECT bond_type, COUNT(*) AS bond_count FROM bond WHERE molecule_id = 'TR010' GROUP BY bond_type ORDER BY bond_count DESC LIMIT 1);",
        "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
        "explain": "TR010 is the molecule id; majority of the bond found refers to MAX(COUNT(bond_type)); ",
        "solution": [
            "To determine which bond type accounted for the majority of the bonds found in molecule TR010, follow these steps:\n\n1. **Filter the bonds**: Focus only on the bonds associated with the molecule ID 'TR010'.\n2. **Group by bond type**: Organize the bonds into groups based on their bond type.\n3. **Count the bonds**: For each bond type, count how many bonds exist in the molecule.\n4. **Order by count**: Sort the bond types in descending order based on their counts to identify the most common bond type.\n5. **Select the top result**: Retrieve the bond type with the highest count, which represents the majority of bonds in the molecule.\n\nThis process ensures that the bond type with the highest occurrence in molecule TR010 is identified.",
            "To determine which bond type accounted for the majority of the bonds found in molecule TR010, follow these steps:\n\n1. **Filter the bonds**: Retrieve all bonds from the `bond` table where the `molecule_id` is 'TR010'.\n2. **Group by bond type**: Group these bonds by their `bond_type` to categorize them.\n3. **Count the bonds**: For each bond type, count the number of bonds associated with it.\n4. **Order by count**: Sort the bond types in descending order based on their counts to prioritize the most common bond type.\n5. **Limit the result**: Select only the top result (the bond type with the highest count) to identify the majority bond type in the molecule.\n\nThe SQL query accomplishes this by:\n- Selecting the `bond_type` from a subquery.\n- The subquery filters bonds for 'TR010', groups them by `bond_type`, counts the bonds per type, orders them by count in descending order, and limits the result to the top entry.\n\nThis ensures the bond type with the highest occurrence in molecule TR010 is accurately identified."
        ]
    },
    "1000": {
        "sql": "SELECT T1.location FROM circuits T1 JOIN races T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1;",
        "question": "Which racetrack hosted the most recent race? Indicate the full location.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1",
        "explain": "full location refers to location+country; most recent race = MAX(date)\n\n",
        "solution": [
            "To determine which racetrack hosted the most recent race and indicate its full location, follow these steps:\n\n1. **Join the tables**: Combine the `circuits` table (aliased as `T1`) and the `races` table (aliased as `T2`) using the `circuitId` field as the common key. This links each race to its corresponding racetrack.\n\n2. **Sort the races by date**: Order the combined data by the `date` field in the `races` table (`T2.date`) in descending order (`DESC`). This ensures the most recent race appears first.\n\n3. **Retrieve the top result**: Limit the results to the first row (`LIMIT 1`) to get only the most recent race.\n\n4. **Extract the location**: From the result, select the `location` field from the `circuits` table (`T1.location`), which provides the full location of the racetrack that hosted the most recent race.\n\nThe final output will be the full location of the racetrack where the most recent race took place."
        ]
    },
    "60": {
        "sql": "SELECT Website FROM schools WHERE Virtual = 'P' AND Charter = 1 AND County = 'San Joaquin';",
        "question": "What are the websites for all the partially virtual chartered schools located in San Joaquin?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT Website FROM schools WHERE County = 'San Joaquin' AND Virtual = 'P' AND Charter = 1",
        "explain": "Virtual = 'P' means partially virtual; Charter schools refers to Charter = 1 in the table schools",
        "solution": []
    },
    "942": {
        "sql": "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS REAL) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) AS average_fastest_lap_time_seconds\nFROM drivers T1\nINNER JOIN results T2 ON T1.driverId = T2.driverId\nWHERE T1.surname = 'Hamilton' AND T1.forename = 'Lewis' AND T2.fastestLapTime IS NOT NULL;",
        "question": "What is the average fastest lap time in seconds for Lewis Hamilton in all the Formula_1 races?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.surname = 'Hamilton' AND T1.forename = 'Lewis'",
        "explain": "average fastest lap time = avg(fastestLapTime); The time is recorded on 'MM:SS.mmm'",
        "solution": [
            "To find the average fastest lap time in seconds for Lewis Hamilton in all Formula 1 races, follow these steps:\n\n1. **Join the Tables**: Combine the `drivers` table (referred to as `T1`) and the `results` table (referred to as `T2`) using the `driverId` field to link them.\n\n2. **Filter for Lewis Hamilton**: From the joined tables, filter the records where the `surname` is 'Hamilton' and the `forename` is 'Lewis' to isolate Lewis Hamilton's data.\n\n3. **Extract and Convert Lap Time**: For each of Lewis Hamilton's fastest lap times (stored in the `fastestLapTime` column of `T2`), perform the following operations:\n   - Extract the minutes part: This is the substring before the colon (`:`) in the `fastestLapTime`.\n   - Convert the minutes to an integer and multiply by 60 to convert it to seconds.\n   - Extract the seconds part: This is the substring after the colon (`:`) in the `fastestLapTime`.\n   - Convert the seconds to a real number (to handle fractional seconds).\n   - Add the converted minutes and seconds to get the total lap time in seconds.\n\n4. **Calculate the Average**: Compute the average of all these converted lap times to get the final result.\n\nThe SQL query accomplishes this by:\n- Using `INNER JOIN` to combine the tables.\n- Applying the `WHERE` clause to filter for Lewis Hamilton.\n- Using `SUBSTR` and `INSTR` functions to parse the `fastestLapTime` string.\n- Converting the parsed values to numbers and performing arithmetic to get the total time in seconds.\n- Finally, using the `AVG` function to calculate the average of these times."
        ]
    },
    "1166": {
        "sql": "SELECT T2.Symptoms, T1.Diagnosis\nFROM Patient T1\nJOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.Symptoms IS NOT NULL\nORDER BY T1.Birthday DESC\nLIMIT 1;",
        "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.Symptoms, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Symptoms IS NOT NULL ORDER BY T1.Birthday DESC LIMIT 1",
        "explain": "The larger the birthday value, the younger the person is, and vice versa; symptoms observed refers to the symptoms is not NULL",
        "solution": [
            "To find the symptoms observed by the youngest patient who ever underwent a medical examination and identify their diagnosis, follow these steps:\n\n1. **Join the Patient and Examination Tables**: Combine the data from the `Patient` table (referred to as `T1`) and the `Examination` table (referred to as `T2`) using the `ID` field as the common key.\n\n2. **Filter for Non-Null Symptoms**: Ensure that only records where the `Symptoms` field in the `Examination` table (`T2.Symptoms`) is not null are considered.\n\n3. **Sort by Birthday in Descending Order**: Arrange the results by the `Birthday` field in the `Patient` table (`T1.Birthday`) in descending order. This ensures the youngest patient (with the most recent birthday) appears first.\n\n4. **Limit to the Youngest Patient**: Retrieve only the top record from the sorted list, which corresponds to the youngest patient.\n\n5. **Select Symptoms and Diagnosis**: From the filtered and sorted data, extract the `Symptoms` from the `Examination` table (`T2.Symptoms`) and the `Diagnosis` from the `Patient` table (`T1.Diagnosis`).\n\nThe final output will display the symptoms observed by the youngest patient and their corresponding diagnosis."
        ]
    },
    "1052": {
        "sql": "SELECT COUNT(DISTINCT p.player_api_id) AS left_footed_players_under_130_weight\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.weight < 130 AND pa.preferred_foot = 'left';",
        "question": "Among all the players whose weight is under 130, how many of them preferred foot in attacking is left?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.weight < 130 AND t2.preferred_foot = 'left'",
        "explain": "weight < 130; preferred foot in attacking refers to preferred_foot; preferred_foot = 'left';",
        "solution": [
            "To solve the question, we need to perform the following operations:\n\n1. **Filter Players by Weight**: Identify all players whose weight is under 130. This is done by checking the `weight` column in the `Player` table.\n\n2. **Join with Player Attributes**: Combine the filtered players with their corresponding attributes by matching the `player_api_id` in both the `Player` and `Player_Attributes` tables.\n\n3. **Filter by Preferred Foot**: From the joined data, select only those players whose preferred foot is 'left'. This is checked in the `preferred_foot` column of the `Player_Attributes` table.\n\n4. **Count Distinct Players**: Finally, count the number of distinct players who meet both criteria (weight under 130 and left-footed). This ensures each player is only counted once, even if they appear multiple times in the data.\n\nThe result will be the total number of left-footed players with a weight under 130."
        ]
    },
    "574": {
        "sql": "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com';",
        "question": "Which user has the website URL listed at 'http://stackoverflow.com'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com'",
        "explain": "\"http://stackoverflow.com\" is the WebsiteUrl; user refers to DisplayName",
        "solution": []
    },
    "84": {
        "sql": "WITH CommonNames AS (\n    SELECT AdmFName1, COUNT(*) AS NameCount\n    FROM schools\n    WHERE AdmFName1 IS NOT NULL\n    GROUP BY AdmFName1\n    ORDER BY NameCount DESC\n    LIMIT 2\n)\nSELECT DISTINCT T1.AdmFName1, T1.District\nFROM schools T1\nJOIN CommonNames T2 ON T1.AdmFName1 = T2.AdmFName1\nORDER BY T1.AdmFName1;",
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "explain": "",
        "solution": [
            "To find the two most common first names among school administrators and indicate the districts they administer, follow these steps:\n\n1. **Identify the two most common first names**:\n   - Group the records in the `schools` table by the `AdmFName1` column.\n   - Count the occurrences of each first name.\n   - Order the results by the count in descending order to prioritize the most common names.\n   - Limit the results to the top two names.\n\n2. **Retrieve the districts for these names**:\n   - Join the original `schools` table (aliased as `T1`) with the subquery result (aliased as `T2`) that contains the two most common first names.\n   - The join condition ensures that only records with matching first names are included.\n   - Select the distinct combinations of `AdmFName1` and `District` from the joined result to avoid duplicates.\n\nThis process ensures that you get the two most common first names among administrators along with the districts they administer, without altering any information from the original SQL query."
        ]
    },
    "747": {
        "sql": "SELECT COUNT(*) FROM superhero WHERE full_name IS NULL;",
        "question": "What is the total number of superheroes without full name?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL",
        "explain": "superheroes without full name refers to full_name IS NULL",
        "solution": []
    },
    "524": {
        "sql": "SELECT DISTINCT artist FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability NOT LIKE '%paper%' AND availability NOT LIKE '%mtgo%';",
        "question": "List the artists who illustrated cards with black borders which are available only in arena.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT artist FROM cards WHERE availability = 'arena' AND BorderColor = 'black'",
        "explain": "black borders refers to BorderColor = 'black'; available only in arena refers to availability = 'arena'",
        "solution": []
    },
    "606": {
        "sql": "SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0';",
        "question": "List out the name of badges that users obtained on 7/19/2010 7:39:08 PM.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0'",
        "explain": "on 7/19/2010 7:39:08 PM refers to Date = '2010-07-19 19:39:08.0'",
        "solution": []
    },
    "1503": {
        "sql": "SELECT DISTINCT p.ProductID, p.Description\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE c.Currency = 'EUR';",
        "question": "Please list the product description of the products bought in transactions in euro.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ProductID, T3.Description FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Currency = 'EUR'",
        "explain": "",
        "solution": [
            "To list the product descriptions of the products bought in transactions in euros, follow these steps:\n\n1. **Identify the relevant tables**: The data is spread across three tables:\n   - `transactions_1k` (aliased as `T1`) contains transaction details, including `ProductID` and `CustomerID`.\n   - `customers` (aliased as `T2`) contains customer details, including `CustomerID` and `Currency`.\n   - `products` (aliased as `T3`) contains product details, including `ProductID` and `Description`.\n\n2. **Join the tables**:\n   - Join `transactions_1k` (`T1`) with `customers` (`T2`) using the `CustomerID` field to link transactions to customers.\n   - Join the result with `products` (`T3`) using the `ProductID` field to link transactions to product descriptions.\n\n3. **Filter transactions in euros**:\n   - Apply a filter to include only those transactions where the customer's currency is 'EUR' (euros).\n\n4. **Select distinct product details**:\n   - Retrieve the `ProductID` and `Description` from the `products` table, ensuring that each product is listed only once (using `DISTINCT`).\n\nThe final output will be a list of unique product IDs and their descriptions for products bought in transactions where the customer's currency is euros."
        ]
    },
    "779": {
        "sql": "SELECT COUNT(*) AS power_count\nFROM hero_power\nWHERE hero_id = (SELECT id FROM superhero WHERE superhero_name = 'Amazo');",
        "question": "How many powers does Amazo hero have?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.power_id) FROM hero_power AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.superhero_name = 'Amazo'",
        "explain": "Amazo hero refers to superhero_name = 'Amazo';",
        "solution": []
    },
    "852": {
        "sql": "SELECT COUNT(*) AS race_count\nFROM races T3\nJOIN circuits T1 ON T3.circuitId = T1.circuitId\nWHERE T3.year = 2010\nAND T1.country NOT IN ('Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK');",
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "explain": "",
        "solution": [
            "To solve the question \"How many races in the year 2010 are held on grand prixs outside Asia and Europe?\", follow these steps:\n\n1. **Identify the tables involved**: The query uses the `circuits` table (aliased as `T1`) and the `races` table (aliased as `T3`).\n\n2. **Join the tables**: The query joins the `circuits` table with the `races` table on the condition that the `circuitID` in the `races` table matches the `circuitId` in the `circuits` table.\n\n3. **Filter by year**: The query filters the races to only include those from the year 2010 by checking the `year` column in the `races` table.\n\n4. **Exclude specific countries**: The query excludes races held in countries listed in Asia and Europe. The excluded countries are: 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', and 'UK'.\n\n5. **Count the races**: Finally, the query counts the number of races that meet all the above conditions by counting the `raceId` values in the `races` table.\n\nThis solution ensures that only races held in 2010 on circuits outside Asia and Europe are counted."
        ]
    },
    "634": {
        "sql": "SELECT u.DisplayName, SUM(p.ViewCount) AS TotalViews\nFROM users u\nJOIN postHistory ph ON u.Id = ph.UserId\nJOIN posts p ON ph.PostId = p.Id\nWHERE u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')\nGROUP BY u.DisplayName\nORDER BY TotalViews DESC\nLIMIT 1;",
        "question": "Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1",
        "explain": "Has higher popularity means the post has higher view count ; calculation = MAX(SUM(ViewCount)) where DisplayName = 'Harvey Motulsky' OR DisplayName = 'Noah Snyder';",
        "solution": [
            "To determine which post by Harvey Motulsky or Noah Snyder has higher popularity, follow these steps:\n\n1. **Identify the Users**: Locate the users with the display names 'Harvey Motulsky' and 'Noah Snyder' in the `users` table.\n\n2. **Retrieve Their Posts**: Join the `users` table with the `postHistory` table using the `Id` from `users` and the `UserId` from `postHistory` to find all posts associated with these users.\n\n3. **Link to Post Details**: Further join the result with the `posts` table using the `PostId` from `postHistory` and the `Id` from `posts` to access the view counts of each post.\n\n4. **Filter the Users**: Apply a filter to include only posts by 'Harvey Motulsky' or 'Noah Snyder'.\n\n5. **Calculate Popularity**: Group the results by the user's display name and calculate the sum of the `ViewCount` for each user's posts to determine their total popularity.\n\n6. **Order by Popularity**: Sort the results in descending order based on the total view count to identify the user with the highest popularity.\n\n7. **Select the Top Result**: Limit the output to the top result, which will be the user with the highest popularity among the two.\n\nThe final output will display the name of the user (either 'Harvey Motulsky' or 'Noah Snyder') whose posts have the highest combined view count.",
            "To determine which post by Harvey Motulsky or Noah Snyder has higher popularity, follow these steps:\n\n1. **Identify the Users**: Locate the users with the display names 'Harvey Motulsky' and 'Noah Snyder' in the `users` table.\n\n2. **Retrieve Their Posts**: Join the `users` table with the `postHistory` table using the `Id` from `users` and the `UserId` from `postHistory` to find all posts associated with these users.\n\n3. **Link to Post Details**: Further join the result with the `posts` table using the `PostId` from `postHistory` and the `Id` from `posts` to access the view counts of each post.\n\n4. **Filter the Users**: Apply a filter to include only posts by 'Harvey Motulsky' or 'Noah Snyder'.\n\n5. **Calculate Popularity**: Group the results by the user's display name and calculate the sum of the `ViewCount` for each user's posts to determine their total popularity.\n\n6. **Order by Popularity**: Sort the results in descending order based on the total view count to identify the user with the highest popularity.\n\n7. **Select the Top Result**: Limit the output to the top result, which will be the user with the highest popularity among the two.\n\nThe final output will display the name of the user (either 'Harvey Motulsky' or 'Noah Snyder') whose posts have the highest combined view count."
        ]
    },
    "362": {
        "sql": "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Condemn';",
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "explain": "Ancestor's Chosen' is the name of card; description about the ruling refers to text;",
        "solution": []
    },
    "137": {
        "sql": "SELECT COUNT(DISTINCT a.account_id) AS number_of_accounts\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE a.district_id = 1 AND (l.status = 'C' OR l.status = 'D');",
        "question": "How many accounts have running contracts in Branch location 1?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
        "explain": "Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
        "solution": []
    },
    "683": {
        "sql": "SELECT (SUM(IIF(T1.Reputation > 1000 AND STRFTIME('%Y', T2.CreationDate) = '2011', 1, 0)) * 100.0 / COUNT(T2.Id)) AS Percentage\nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE STRFTIME('%Y', T2.CreationDate) = '2011';",
        "question": "What is the percentage of posts whose owners had a reputation of over 1000 in 2011?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
        "explain": "percentage = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2011 and Reputation > 1000), COUNT(Id) ) * 100;",
        "solution": [
            "To determine the percentage of posts whose owners had a reputation of over 1000 in 2011, follow these steps:\n\n1. **Join the Tables**: Combine the `users` table (referred to as `T1`) and the `posts` table (referred to as `T2`) using the `INNER JOIN` operation. The join condition is that the `Id` column in the `users` table matches the `OwnerUserId` column in the `posts` table.\n\n2. **Filter for the Year 2011**: From the joined data, filter the posts to include only those where the creation date (`CreationDate`) in the `posts` table falls in the year 2011. This is done by extracting the year from the `CreationDate` column and checking if it equals '2011'.\n\n3. **Check Reputation Condition**: For each post, check if the owner's reputation (from the `users` table) is greater than 1000.\n\n4. **Count Eligible Posts**: Sum the number of posts that meet both conditions (created in 2011 and owner reputation > 1000). This is done using the `SUM` function with an `IIF` (immediate if) statement that returns 1 for posts meeting the conditions and 0 otherwise.\n\n5. **Calculate Total Posts**: Count the total number of posts in the dataset by counting the `Id` values in the `users` table.\n\n6. **Compute Percentage**: Divide the count of eligible posts by the total number of posts, multiply by 100, and cast the result to a real number to get the percentage.\n\nThe final result is the percentage of posts whose owners had a reputation of over 1000 in 2011.",
            "To determine the percentage of posts whose owners had a reputation of over 1000 in 2011, follow these detailed steps:\n\n1. **Join the Tables**: Perform an `INNER JOIN` between the `users` table (aliased as `T1`) and the `posts` table (aliased as `T2`). The join condition is that the `Id` column in the `users` table (`T1.Id`) must match the `OwnerUserId` column in the `posts` table (`T2.OwnerUserId`). This ensures that each post is linked to its owner.\n\n2. **Filter for the Year 2011**: From the joined dataset, filter the posts to include only those created in the year 2011. This is achieved by using the `STRFTIME` function to extract the year from the `CreationDate` column in the `posts` table (`T2.CreationDate`) and checking if it equals '2011'.\n\n3. **Check Reputation Condition**: For each post, verify if the owner's reputation (from the `users` table, `T1.Reputation`) is greater than 1000. This ensures that only posts from high-reputation users are considered.\n\n4. **Count Eligible Posts**: Use the `SUM` function combined with an `IIF` (immediate if) statement to count the number of posts that meet both conditions (created in 2011 and owner reputation > 1000). The `IIF` function returns 1 for posts that satisfy the conditions and 0 otherwise, and the `SUM` function aggregates these values.\n\n5. **Calculate Total Posts**: Count the total number of posts in the dataset by counting the `Id` values in the `users` table (`T1.Id`). This provides the denominator for the percentage calculation.\n\n6. **Compute Percentage**: Divide the count of eligible posts (from step 4) by the total number of posts (from step 5), multiply the result by 100 to convert it to a percentage, and cast the final value to a `REAL` number for precision.\n\nThe final result is the percentage of posts whose owners had a reputation of over 1000 in 2011."
        ]
    },
    "319": {
        "sql": "SELECT COUNT(DISTINCT a1.element) AS element_count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE c.bond_id = 'TR001_3_4';",
        "question": "How many elements are contained in bond_id TR001_3_4?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.element) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_3_4'",
        "explain": "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "solution": []
    },
    "979": {
        "sql": "SELECT raceId, COUNT(*) AS finisher_count FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY finisher_count DESC LIMIT 1;",
        "question": "What race number has the most finishers?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT raceId FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1",
        "explain": "finisher refers to time is not null;",
        "solution": [
            "To find the race number with the most finishers, follow these steps:\n1. **Group the results by raceId**: This organizes all the data entries in the 'results' table by their 'raceId'.\n2. **Count the number of finishers for each raceId**: For each group (raceId), count how many entries have a non-null 'time' value, as this indicates a finisher.\n3. **Order the groups in descending order of finisher count**: This sorts the raceIds from the one with the highest number of finishers to the lowest.\n4. **Select the top raceId**: The first entry in the ordered list will be the raceId with the most finishers.\n\nThe SQL query achieves this by grouping, counting, ordering, and limiting the result to the top entry.",
            "To determine the race number with the most finishers, follow these detailed steps:\n\n1. **Group the data by raceId**: The 'results' table is grouped by the 'raceId' column. This means all entries with the same 'raceId' are treated as a single group.\n\n2. **Count finishers for each raceId**: For each group (raceId), count the number of entries where the 'time' column is not null. A non-null 'time' indicates that the participant finished the race.\n\n3. **Order the groups by finisher count**: The groups are sorted in descending order based on the count of finishers. This ensures the race with the highest number of finishers appears first.\n\n4. **Select the top raceId**: The query returns only the first entry from the ordered list, which corresponds to the 'raceId' with the most finishers.\n\nThe SQL query accomplishes this by using the `GROUP BY` clause to group the data, the `COUNT` function with a condition (`time IS NOT NULL`) to count finishers, the `ORDER BY` clause to sort the results, and the `LIMIT` clause to restrict the output to the top result."
        ]
    },
    "1209": {
        "sql": "SELECT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT > 60\nORDER BY p.Birthday ASC;",
        "question": "Please provide the diagnosis of patients with ALT glutamic pylvic transaminase beyond the normal range by ascending order of their date of birth.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT > 60 ORDER BY T1.Birthday ASC",
        "explain": "ALT glutamic pylvic transaminase beyond the normal range refers to GPT > 60; The larger the birthday value, the younger the person is, and vice versa; ",
        "solution": []
    },
    "157": {
        "sql": "SELECT A15 AS number_of_crimes_1995 FROM district WHERE district_id = (SELECT district_id FROM account WHERE account_id = 532);",
        "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
        "explain": "A15 contains information about number of committed crimes in 1995",
        "solution": []
    },
    "823": {
        "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female') \nAND publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');",
        "question": "How many female superheroes are in Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.gender = 'Female'",
        "explain": "female refers to gender = 'Female'; Marvel Comics refers to publisher_name = 'Marvel Comics';",
        "solution": []
    },
    "147": {
        "sql": "SELECT COUNT(DISTINCT a.account_id) AS female_clients_in_south_bohemia\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE c.gender = 'F' AND di.A3 = 'south Bohemia';",
        "question": "How many female clients' accounts are in the region of South Bohemia?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A3 = 'south Bohemia'",
        "explain": "Female refers to gender = 'F'; A3 contains the region 'south Bohemia'",
        "solution": []
    },
    "1130": {
        "sql": "SELECT t.team_short_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE ta.chanceCreationPassingClass = 'Safe';",
        "question": "What are the short name of team who played safe while creating chance of passing?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Safe'",
        "explain": "played safe while creating chance of passing refers to chanceCreationPassingClass = 'Safe'; short name of team refers to team_short_name",
        "solution": []
    },
    "1475": {
        "sql": "SELECT COUNT(DISTINCT T2.CustomerID) \nFROM customers T1 \nJOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Segment = 'KAM' \nAND SUBSTR(T2.Date, 1, 4) = '2012' \nGROUP BY T2.CustomerID \nHAVING SUM(T2.Consumption) < 30000;",
        "question": "How many customers in KAM had a consumption of less than 30,000 for the year 2012?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T2.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND SUBSTRING(T2.Date, 1, 4) = '2012' GROUP BY T2.CustomerID HAVING SUM(T2.Consumption) < 30000 ) AS t1",
        "explain": "Year 2012 can be presented as Between 201201 And 201212, which means between January and December in 2012",
        "solution": [
            "To solve the question \"How many customers in KAM had a consumption of less than 30,000 for the year 2012?\", follow these steps:\n\n1. **Join the Tables**: Combine the `customers` table (referred to as `T1`) and the `yearmonth` table (referred to as `T2`) using the `CustomerID` field. This ensures that each customer's details are linked to their consumption records.\n\n2. **Filter by Segment and Year**: From the joined tables, filter the records to include only those where:\n   - The `Segment` field in the `customers` table (`T1`) is equal to \"KAM\".\n   - The year part of the `Date` field in the `yearmonth` table (`T2`) is \"2012\". This is done by extracting the first four characters of the `Date` field.\n\n3. **Group by Customer**: Group the filtered records by `CustomerID` to aggregate the consumption data for each customer.\n\n4. **Filter by Consumption**: From the grouped records, include only those customers whose total consumption (sum of the `Consumption` field in `T2`) for the year 2012 is less than 30,000.\n\n5. **Count the Customers**: Finally, count the number of customers who meet all the above criteria.\n\nThe result of this operation will give the number of customers in the KAM segment with a total consumption of less than 30,000 for the year 2012.",
            "To solve the question \"How many customers in KAM had a consumption of less than 30,000 for the year 2012?\", follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `customers` table (aliased as `T1`) and the `yearmonth` table (aliased as `T2`) using the `CustomerID` field. This ensures that each customer's details are linked to their consumption records.\n\n2. **Filter by Segment and Year**: Apply the following filters to the joined tables:\n   - The `Segment` field in the `customers` table (`T1`) must be equal to \"KAM\".\n   - The year part of the `Date` field in the `yearmonth` table (`T2`) must be \"2012\". This is achieved by extracting the first four characters of the `Date` field using the `SUBSTRING` function.\n\n3. **Group by Customer**: Group the filtered records by the `CustomerID` field from the `yearmonth` table (`T2`). This step aggregates the consumption data for each customer.\n\n4. **Filter by Consumption**: From the grouped records, include only those customers whose total consumption (sum of the `Consumption` field in `T2`) for the year 2012 is less than 30,000. This is done using the `HAVING` clause.\n\n5. **Count the Customers**: Finally, count the number of distinct `CustomerID` values that meet all the above criteria. This count represents the number of customers in the KAM segment with a total consumption of less than 30,000 for the year 2012.\n\nThe SQL query provided accomplishes all these steps in a single operation, ensuring accuracy and efficiency."
        ]
    },
    "1340": {
        "sql": "SELECT \n    (SELECT COALESCE(SUM(b.spent), 0) \n     FROM budget b \n     JOIN event e ON b.link_to_event = e.event_id \n     WHERE SUBSTR(e.event_date, 1, 4) = '2019') -\n    (SELECT COALESCE(SUM(b.spent), 0) \n     FROM budget b \n     JOIN event e ON b.link_to_event = e.event_id \n     WHERE SUBSTR(e.event_date, 1, 4) = '2020') AS difference_in_spending;",
        "question": "Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS num FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
        "explain": "The first 4 strings of the event_date values in the event table can represent year; The difference of the total amount spent = SUBTRACT(spent where YEAR(event_date) = 2019, spent where YEAR(event_date) = 2020)",
        "solution": []
    },
    "1047": {
        "sql": "SELECT p.player_name, pa.heading_accuracy\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Francois Affolter' AND substr(pa.date, 1, 10) = '2014-09-18';",
        "question": "What is the football player Francois Affolter header's finishing rate on 18/09/2014?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t2.heading_accuracy FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Francois Affolter' AND SUBSTR(t2.`date`, 1, 10) = '2014-09-18'",
        "explain": "header's finishing rate refers to heading_accuracy; on 18/09/2014 refers to date = '2014-09-18 00:00:00';",
        "solution": [
            "To find the football player Francois Affolter's header finishing rate on 18/09/2014, follow these steps:\n\n1. **Identify the Player**: Locate the player named 'Francois Affolter' in the `Player` table.\n2. **Retrieve Player Attributes**: Join the `Player` table with the `Player_Attributes` table using the `player_api_id` to access the player's attributes.\n3. **Filter by Date**: From the joined data, filter the records to only include the entry where the date is '2014-09-18' (18th September 2014).\n4. **Extract Header Accuracy**: From the filtered record, select the `heading_accuracy` attribute, which represents the player's header finishing rate.\n\nThe result will be Francois Affolter's header finishing rate on the specified date.",
            "To determine the header finishing rate of football player Francois Affolter on 18/09/2014, execute the following steps:\n\n1. **Identify the Player**: Query the `Player` table to locate the record for the player named 'Francois Affolter'.\n2. **Join with Player Attributes**: Perform an inner join between the `Player` table and the `Player_Attributes` table using the `player_api_id` field to link the player's basic information with their performance attributes.\n3. **Filter by Date**: Apply a filter to the joined dataset to include only the record where the date is exactly '2014-09-18'. This is done by extracting the first 10 characters of the `date` field in the `Player_Attributes` table and comparing it to the string '2014-09-18'.\n4. **Retrieve Header Accuracy**: From the filtered record, select the `heading_accuracy` attribute, which quantifies the player's header finishing rate.\n\nThe result of this operation will be Francois Affolter's header finishing rate on the specified date."
        ]
    },
    "600": {
        "sql": "SELECT T1.ViewCount AS Popularity\nFROM posts T1\nJOIN postLinks T2 ON T1.Id = T2.RelatedPostId\nWHERE T2.PostId = 61217;",
        "question": "List out all post that are related to post ID 61217 and what is the popularity of this post?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.ViewCount FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 61217",
        "explain": "post related refers to RelatedPostId; popularity refers to ViewCount",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join Tables**: The `posts` table (aliased as `T1`) is joined with the `postLinks` table (aliased as `T2`) using the `Id` column from `T1` and the `PostId` column from `T2`. This ensures that only posts with corresponding entries in the `postLinks` table are considered.\n\n2. **Filter by Post ID**: The joined data is filtered to include only those records where the `PostId` in the `postLinks` table (`T2.PostId`) matches the specified post ID `61217`.\n\n3. **Select ViewCount**: From the filtered and joined data, the `ViewCount` column from the `posts` table (`T1.ViewCount`) is selected. This column represents the popularity of the post.\n\nThe result of these operations will list the popularity (view count) of all posts related to post ID `61217`.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Table Selection and Joining**: The `posts` table (aliased as `T1`) is selected and joined with the `postLinks` table (aliased as `T2`). The join condition is based on the `Id` column from the `posts` table (`T1.Id`) matching the `PostId` column from the `postLinks` table (`T2.PostId`). This ensures that only posts with corresponding entries in the `postLinks` table are included in the result set.\n\n2. **Filtering by Post ID**: The joined data is filtered to retain only those records where the `PostId` in the `postLinks` table (`T2.PostId`) is equal to the specified post ID `61217`. This step isolates the posts that are directly related to post ID `61217`.\n\n3. **Selecting the Popularity Metric**: From the filtered and joined data, the `ViewCount` column from the `posts` table (`T1.ViewCount`) is selected. This column represents the popularity of the post, as it indicates how many times the post has been viewed.\n\nThe result of these operations will provide a list of the popularity (view count) for all posts that are related to post ID `61217`."
        ]
    },
    "719": {
        "sql": "SELECT COUNT(*) \nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Super Strength' AND s.height_cm > 200;",
        "question": "Among the superheroes with the super power of \"Super Strength\", how many of them have a height of over 200cm?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.height_cm > 200",
        "explain": "super power of \"Super Strength\" refers to power_name = 'Super Strength'; a height of over 200cm refers to height_cm > 200",
        "solution": []
    },
    "382": {
        "sql": "SELECT T1.name FROM cards T1 JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'Japanese';",
        "question": "What are the cards that only available in paper and Japanese language?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'Japanese'",
        "explain": "available in paper refers to availability = 'paper'; 'Japanese is the language;",
        "solution": [
            "To find the cards that are only available in paper format and in the Japanese language, follow these steps:\n\n1. **Join the Tables**: Combine the `cards` table (referred to as `T1`) with the `foreign_data` table (referred to as `T2`) using the `uuid` field as the common key. This ensures that each card in the `cards` table is matched with its corresponding entry in the `foreign_data` table.\n\n2. **Filter by Availability**: From the joined tables, filter the results to include only those cards where the `availability` field in the `cards` table (`T1.availability`) is set to 'paper'. This ensures that only cards available in paper format are considered.\n\n3. **Filter by Language**: Further filter the results to include only those entries where the `language` field in the `foreign_data` table (`T2.language`) is set to 'Japanese'. This ensures that only cards with Japanese language data are included.\n\n4. **Select the Card Names**: Finally, retrieve the `name` field from the `cards` table (`T1.name`) for the filtered results. This provides the names of the cards that meet both criteria (paper availability and Japanese language).\n\nThe SQL query performs these operations in a single step, but the logical breakdown above explains how the data is processed to arrive at the correct answer."
        ]
    },
    "499": {
        "sql": "SELECT COUNT(DISTINCT T2.translation) AS translation_count\nFROM sets T1\nJOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL;",
        "question": "How many translations of the name of the set \"Tenth Edition\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL",
        "explain": "translations of the name refers to translation; translation is not NULL; set \"Salvat 2011\" refers to name = 'Tenth Edition'",
        "solution": [
            "To find the number of distinct translations for the name of the set \"Tenth Edition\", follow these steps:\n\n1. **Identify the set**: Locate the set with the name \"Tenth Edition\" in the `sets` table (referred to as T1).\n2. **Join with translations**: Connect this set to the `set_translations` table (referred to as T2) using the `setCode` from T2 and the `code` from T1.\n3. **Filter valid translations**: Ensure that only rows where the `translation` field in T2 is not NULL are considered.\n4. **Count distinct translations**: Calculate the count of unique `translation` values from the filtered results.\n\nThe final result will be the number of distinct translations available for the set \"Tenth Edition\"."
        ]
    },
    "377": {
        "sql": "SELECT COUNT(*) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel';",
        "question": "How many cards with original type of \"Summon - Angel\" have subtype other than \"Angel\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'",
        "explain": "subtype other than Angel refers to subtypes is not 'Angel';",
        "solution": [
            "To solve the question, we need to count the number of cards in the database where the original type is \"Summon - Angel\" and the subtype is not \"Angel\". The steps are as follows:\n\n1. Filter the cards in the database to only include those where the `originalType` field is equal to \"Summon - Angel\".\n2. From the filtered cards, further exclude any cards where the `subtypes` field is equal to \"Angel\".\n3. Count the remaining cards that meet both criteria.\n\nThe result will be the total number of cards that have the original type \"Summon - Angel\" but do not have the subtype \"Angel\"."
        ]
    },
    "927": {
        "sql": "SELECT d.forename, d.surname\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;",
        "question": "Which driver created the fastest lap speed in a Formula_1 race? Please give both his forename and surname.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "explain": "",
        "solution": []
    },
    "1377": {
        "sql": "SELECT COUNT(*) FROM member WHERE position = 'President';",
        "question": "How many student have the position of president?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(member_id) FROM member WHERE position = 'President'",
        "explain": "'President' is a position of Student Club",
        "solution": []
    },
    "777": {
        "sql": "SELECT g.gender\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE s.superhero_name = 'Agent 13';",
        "question": "What is the gender of Agent 13 hero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'",
        "explain": "Agent 13 hero refers to superhero_name = 'Agent 13';",
        "solution": []
    },
    "1137": {
        "sql": "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) FROM Player_Attributes",
        "question": "What percentage of players have a strength and stamina score of more than 80?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) FROM Player_Attributes t",
        "explain": "strength and stamina score of more than 80 refers to stamina > 80 and strength > 80",
        "solution": [
            "To determine the percentage of players who have both a strength and stamina score of more than 80, follow these steps:\n\n1. **Count the Players Meeting the Criteria**: Identify all players in the `Player_Attributes` table where both the `strength` and `stamina` scores are greater than 80. For each such player, include their `id` in the count; otherwise, exclude them (treat as NULL).\n\n2. **Total Players**: Count the total number of players in the `Player_Attributes` table by counting all `id` values.\n\n3. **Calculate the Percentage**: Divide the count of players meeting the criteria (from step 1) by the total number of players (from step 2). Multiply the result by 100 to convert it into a percentage.\n\n4. **Cast to Real**: Ensure the division is performed as a floating-point operation by casting the count of qualifying players to a `REAL` type before division.\n\nThe final result will be the percentage of players with both strength and stamina scores above 80.",
            "To determine the percentage of players who have both a strength and stamina score of more than 80, follow these detailed steps:\n\n1. **Filter Players by Criteria**: Query the `Player_Attributes` table to identify players where both the `strength` and `stamina` attributes are greater than 80. For each player meeting this condition, include their `id` in the count; otherwise, exclude them (treat as NULL).\n\n2. **Count Qualifying Players**: Use the `COUNT` function to tally the number of `id` values from the filtered players in step 1. This count represents the number of players with both strength and stamina scores above 80.\n\n3. **Count Total Players**: Use the `COUNT` function again to tally all `id` values in the `Player_Attributes` table. This count represents the total number of players.\n\n4. **Calculate Percentage**: Divide the count of qualifying players (from step 2) by the total count of players (from step 3). To ensure the division is performed as a floating-point operation, cast the count of qualifying players to `REAL` before division. Multiply the result by 100 to convert it into a percentage.\n\n5. **Return the Result**: The final output will be the calculated percentage of players with both strength and stamina scores above 80.\n\nThe SQL query for this operation is:\n```sql\nSELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) FROM Player_Attributes t\n```"
        ]
    },
    "691": {
        "sql": "SELECT COUNT(*) AS NumberOfAdultUsersWithHighUpvotes\nFROM users\nWHERE Age >= 18 AND UpVotes > 5000;",
        "question": "Identify the number of adult users who have cast over 5000 upvotes.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000",
        "explain": "adult users refer to Age BETWEEN 19 and 65; over 5000 upvotes refer to UpVotes > 5000;",
        "solution": []
    },
    "1302": {
        "sql": "SELECT COUNT(DISTINCT P.ID) AS PatientCount\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.CPK < 250\nAND (E.KCT = '+' OR E.RVVT = '+' OR E.LAC = '+');",
        "question": "For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.CPK < 250 AND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')",
        "explain": "normal range of creatinine phosphokinase refers to CPK < 250; positive measure of degree of coagulation refers to KCT = '+' or RVVT = '+' or LAC = '+' ;",
        "solution": [
            "To solve the question, we need to perform the following operations:\n\n1. **Join the Tables**: Combine the `Patient`, `Laboratory`, and `Examination` tables using the patient ID (`ID`) as the common key.\n\n2. **Filter Patients with Normal Creatinine Phosphokinase (CPK)**: From the joined data, select only those patients whose CPK level is below 250 (indicating a normal range).\n\n3. **Check for Positive Coagulation Measures**: Further filter the results to include only those patients who have at least one positive measure of coagulation. This is determined by checking if any of the following fields in the `Examination` table have a '+' value: `KCT`, `RVVT`, or `LAC`.\n\n4. **Count the Patients**: Finally, count the number of patients who meet both criteria (normal CPK and positive coagulation measures).\n\nThe SQL query accomplishes this by joining the tables, applying the filters, and then counting the qualifying patients.",
            "To solve the question, we need to perform the following operations:\n\n1. **Join the Tables**: Combine the `Patient`, `Laboratory`, and `Examination` tables using the patient ID (`ID`) as the common key. This ensures that all relevant data for each patient is linked together.\n\n2. **Filter Patients with Normal Creatinine Phosphokinase (CPK)**: From the joined data, select only those patients whose CPK level is below 250. This threshold indicates a normal range for CPK levels.\n\n3. **Check for Positive Coagulation Measures**: Further filter the results to include only those patients who have at least one positive measure of coagulation. This is determined by checking if any of the following fields in the `Examination` table have a '+' value: `KCT`, `RVVT`, or `LAC`. A '+' in any of these fields signifies a positive coagulation measure.\n\n4. **Count the Patients**: Finally, count the number of patients who meet both criteria (normal CPK and positive coagulation measures). This count answers the question by quantifying how many patients fit the specified conditions.\n\nThe SQL query accomplishes this by joining the tables, applying the filters, and then counting the qualifying patients."
        ]
    },
    "1515": {
        "sql": "SELECT c.Segment\nFROM customers c\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE t.Date = '2012-08-23' AND t.Time = '21:20:00';",
        "question": "What segment did the customer have at 2012/8/23 21:20:00?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.date = '2012-08-23' AND T1.time = '21:20:00'",
        "explain": "'2012/8/23' can be represented by '2012-08-23'",
        "solution": []
    },
    "1474": {
        "sql": "SELECT T1.CustomerID\nFROM customers T1\nJOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK'\n  AND T2.Date BETWEEN '201101' AND '201112'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
        "question": "Which customers, paying in CZK, consumed the most gas in 2011?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Date BETWEEN 201101 AND 201112 GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "explain": "Year 2011 can be presented as Between 201101 And 201112, which means between January and December in 2011",
        "solution": [
            "To find the customer who paid in CZK and consumed the most gas in 2011, follow these steps:\n\n1. **Identify the tables involved**: The query uses the `customers` table (aliased as `T1`) and the `yearmonth` table (aliased as `T2`).\n\n2. **Filter customers by currency**: From the `customers` table, select only those customers whose `Currency` is 'CZK'.\n\n3. **Filter consumption data by date**: From the `yearmonth` table, select only the records where the `Date` falls between January 2011 (201101) and December 2011 (201112).\n\n4. **Join the tables**: Combine the filtered `customers` and `yearmonth` tables by matching the `CustomerID` in both tables.\n\n5. **Group the results**: Group the joined data by `CustomerID` to aggregate the consumption data for each customer.\n\n6. **Calculate total consumption**: For each customer, sum the `Consumption` values from the `yearmonth` table.\n\n7. **Order the results**: Sort the customers in descending order based on their total gas consumption.\n\n8. **Limit the results**: Return only the top customer with the highest total gas consumption.\n\nThe final result is the `CustomerID` of the customer who paid in CZK and consumed the most gas in 2011."
        ]
    },
    "338": {
        "sql": "SELECT T1.atom_id FROM atom T1 JOIN molecule T2 ON T1.molecule_id = T2.molecule_id JOIN bond T3 ON T2.molecule_id = T3.molecule_id WHERE T2.molecule_id = 'TR012' AND T3.bond_type = '=' AND T1.element = 'c';",
        "question": "What is the atom ID of double bonded carbon in TR012 molecule?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T2.molecule_id = 'TR012' AND T3.bond_type = '=' AND T1.element = 'c'",
        "explain": "carbon refers to element = 'c'; double bond refers to bond_type = ' = ';",
        "solution": [
            "To find the atom ID of the double-bonded carbon in the TR012 molecule, follow these steps:\n\n1. **Select the atom ID**: Retrieve the `atom_id` from the `atom` table.\n2. **Join the `molecule` table**: Link the `atom` table with the `molecule` table using the `molecule_id` field to ensure the atom belongs to the TR012 molecule.\n3. **Join the `bond` table**: Further link the `molecule` table with the `bond` table using the `molecule_id` field to identify bonds associated with the TR012 molecule.\n4. **Filter for the TR012 molecule**: Apply a condition to only include records where the `molecule_id` is 'TR012'.\n5. **Filter for double bonds**: Include only bonds where the `bond_type` is '=' (indicating a double bond).\n6. **Filter for carbon atoms**: Ensure the element of the atom is 'c' (carbon).\n\nThe result will be the `atom_id` of the double-bonded carbon in the TR012 molecule.",
            "To find the atom ID of the double-bonded carbon in the TR012 molecule, follow these detailed steps:\n\n1. **Select the atom ID**: Retrieve the `atom_id` from the `atom` table, which is labeled as `T1` in the SQL query.\n2. **Join the `molecule` table**: Link the `atom` table (`T1`) with the `molecule` table (`T2`) using the `molecule_id` field. This ensures that the atom belongs to the TR012 molecule.\n3. **Join the `bond` table**: Further link the `molecule` table (`T2`) with the `bond` table (`T3`) using the `molecule_id` field. This step identifies all bonds associated with the TR012 molecule.\n4. **Filter for the TR012 molecule**: Apply a condition to only include records where the `molecule_id` in the `molecule` table (`T2`) is 'TR012'.\n5. **Filter for double bonds**: Include only bonds where the `bond_type` in the `bond` table (`T3`) is '=', indicating a double bond.\n6. **Filter for carbon atoms**: Ensure the element of the atom in the `atom` table (`T1`) is 'c' (carbon).\n\nThe result of this query will be the `atom_id` of the double-bonded carbon in the TR012 molecule."
        ]
    },
    "1290": {
        "sql": "SELECT l.Date AS \"Examination Date\" FROM Laboratory l WHERE l.ALB > 3.5 AND l.ALB < 5.5 ORDER BY l.ALB DESC LIMIT 1;",
        "question": "What is the examination date of the patient whose albumin is the highest in the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1",
        "explain": "examination date refers to Date; albumin is the highest in the normal range refers to MAX(ALB > 3.5 and ALB < 5.5);",
        "solution": [
            "To find the examination date of the patient whose albumin (ALB) level is the highest within the normal range (greater than 3.5 and less than 5.5), follow these steps:\n\n1. **Filter the Laboratory Data**: Retrieve all records from the Laboratory table where the albumin (ALB) level is within the normal range (ALB > 3.5 and ALB < 5.5).\n\n2. **Sort the Results**: Order the filtered records by the albumin (ALB) level in descending order to ensure the highest value appears first.\n\n3. **Limit the Results**: Select only the top record (the one with the highest ALB level) from the sorted list.\n\n4. **Extract the Date**: From the selected record, retrieve the examination date (Date).\n\nThis process ensures that you get the examination date of the patient with the highest albumin level within the specified normal range."
        ]
    },
    "742": {
        "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE race_id = (SELECT id FROM race WHERE race = 'Vampire');",
        "question": "How many vampire superheroes are there?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.superhero_name) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
        "explain": "vampire superheroes refers to race = 'Vampire'",
        "solution": []
    },
    "1072": {
        "sql": "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Aaron Doran');",
        "question": "What is the average overall rating of the football player Aaron Doran?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
        "explain": "average overall rating = AVG(overall_rating);",
        "solution": []
    },
    "645": {
        "sql": "SELECT COUNT(*) AS negative_comments_count FROM comments WHERE UserId = 13 AND Score < 60;",
        "question": "How many negative comments were given by user ID 13?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13 AND Score < 60",
        "explain": "negative comments refer to Score < 60;",
        "solution": []
    },
    "9": {
        "sql": "SELECT COUNT(T2.`School Code`) AS DirectlyFundedCharterSchools\nFROM satscores T1\nINNER JOIN frpm T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath > 560\nAND T2.`Charter Funding Type` = 'Directly funded';",
        "question": "Among the schools with the average score in Math over 560 in the SAT test, how many schools are directly charter-funded?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.`School Code`) FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath > 560 AND T2.`Charter Funding Type` = 'Directly funded'",
        "explain": "",
        "solution": [
            "1. **Joining the SAT scores and funding data:**  \n   The query uses an `INNER JOIN` between two tables: `satscores` (aliased as T1) and `frpm` (aliased as T2). These tables are linked using the `cds` column from `satscores` and the `CDSCode` column from `frpm`. This ensures that each school's SAT scores are matched with its corresponding funding data.\n\n2. **Filtering by average Math score:**  \n   The query includes a condition (`WHERE T1.AvgScrMath > 560`) to filter schools where the average Math score in the SAT test exceeds 560. This narrows down the dataset to only those schools meeting this academic criterion.\n\n3. **Filtering by charter funding type:**  \n   Another condition (`WHERE T2.`Charter Funding Type` = 'Directly funded'`) is applied to further filter the results. This ensures that only schools with a charter funding type of \"Directly funded\" are included in the count.\n\n4. **Counting the qualifying schools:**  \n   The query selects the count of `School Code` from the `frpm` table (T2). This count represents the number of schools that meet both the academic and funding criteria specified in the question."
        ]
    },
    "941": {
        "sql": "SELECT SUM(points) AS total_points\nFROM results\nWHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton');",
        "question": "How many points did Lewis Hamilton get in total in all the Formula_1 races he participated?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.points) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'",
        "explain": "",
        "solution": []
    },
    "201": {
        "sql": "SELECT (COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id END) * 100.0 / COUNT(DISTINCT T1.atom_id)) AS percentage_carbon\nFROM atom T1\nJOIN bond T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.bond_type = '=';",
        "question": "What is the percentage of carbon in double-bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
        "explain": "carbon refers to element = 'c'; double-bond molecules refers to bond_type = '='; percentage = DIVIDE(SUM(element = 'c'), COUNT(atom_id))",
        "solution": [
            "To determine the percentage of carbon atoms in double-bond molecules, follow these steps:\n\n1. **Filter Double-Bond Molecules**: Identify all bonds in the database where the bond type is a double bond (denoted by '=').\n\n2. **Join Tables**: Combine the `atom` table (`T1`) with the `bond` table (`T2`) using the `molecule_id` as the common key to link atoms to their respective bonds.\n\n3. **Count Carbon Atoms**: From the joined tables, count the distinct carbon atoms (where `T1.element` is 'c') in the double-bond molecules.\n\n4. **Count Total Atoms**: Count the total distinct atoms in the double-bond molecules.\n\n5. **Calculate Percentage**: Divide the count of carbon atoms by the total count of atoms, multiply by 100, and cast the result to a real number to get the percentage.\n\nThe final result will be the percentage of carbon atoms in double-bond molecules."
        ]
    },
    "1108": {
        "sql": "SELECT ta.buildUpPlaySpeedClass \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE t.team_long_name = 'Willem II' \nAND substr(ta.date, 1, 10) = '2011-02-22';",
        "question": "What was the build up play speed class for \"Willem II\" on 2011/2/22?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.buildUpPlaySpeedClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Willem II' AND SUBSTR(t2.`date`, 1, 10) = '2011-02-22'",
        "explain": "\"Willem II\" refers to team_long_name = 'Willem II'; on 2011/2/22 refers to date = '2012-02-22'",
        "solution": [
            "To find the build-up play speed class for the team \"Willem II\" on February 22, 2011, follow these steps:\n\n1. **Identify the Team**: Locate the team named \"Willem II\" in the `Team` table.\n2. **Join with Team Attributes**: Link the team's record in the `Team` table with its corresponding attributes in the `Team_Attributes` table using the `team_api_id` as the common key.\n3. **Filter by Date**: From the joined records, filter out the attributes that have a date matching \"2011-02-22\". The date is checked by extracting the first 10 characters of the `date` field in the `Team_Attributes` table.\n4. **Retrieve the Attribute**: Finally, extract the `buildUpPlaySpeedClass` value from the filtered record.\n\nThis process ensures that you retrieve the correct build-up play speed class for \"Willem II\" on the specified date."
        ]
    },
    "1168": {
        "sql": "SELECT T1.Date AS \"Laboratory Work Date\", (STRFTIME('%Y', T2.\"First Date\") - STRFTIME('%Y', T2.Birthday)) AS \"Age at Arrival\", T2.Birthday\nFROM Laboratory T1\nJOIN Patient T2 ON T1.ID = T2.ID\nWHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL\nORDER BY T2.Birthday ASC\nLIMIT 1;",
        "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Date, STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday),T2.Birthday FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL ORDER BY T2.Birthday ASC LIMIT 1",
        "explain": "The larger the birthday value, the younger the person is, and vice versa; 'SJS' refers to diagnosis; (SUBTRACT(year(`First Date`)), year(Birthday)); age of the patients when they initially arrived at the hospital refers to year(Birthday)",
        "solution": [
            "To find the date when the oldest SJS patient's medical laboratory work was completed and the patient's age upon their initial arrival at the hospital, follow these steps:\n\n1. **Join Tables**: Combine the `Laboratory` table (referred to as `T1`) and the `Patient` table (referred to as `T2`) using the `ID` field as the common key.\n\n2. **Filter Patients**: From the joined tables, select only those patients who have a diagnosis of 'SJS' and whose `Birthday` field is not null.\n\n3. **Sort by Age**: Order the filtered patients by their `Birthday` in ascending order to ensure the oldest patient (with the earliest birthday) appears first.\n\n4. **Limit Results**: Retrieve only the first record from the sorted list to get the oldest patient.\n\n5. **Extract Data**: From this record, extract the following information:\n   - The `Date` from the `Laboratory` table (`T1.Date`), which indicates when the patient's medical laboratory work was completed.\n   - The patient's age upon their initial arrival at the hospital, calculated by subtracting the year of their `Birthday` from the year of their `First Date` (using the `STRFTIME` function to extract the year from each date).\n   - The patient's `Birthday` for reference.\n\nThis process ensures that you accurately identify the oldest SJS patient and retrieve the required information about their laboratory work date and age at arrival."
        ]
    },
    "1224": {
        "sql": "SELECT T2.\"T-BIL\", T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;",
        "question": "What is the highest total bilirubin level recorded? List out the patient details with ID, sex and birthday with that index.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.`T-BIL`, T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-BIL` DESC LIMIT 1",
        "explain": "the highest total bilirubin refers to MAX(T-BIL)",
        "solution": [
            "To find the highest total bilirubin level recorded along with the patient details (ID, sex, and birthday), follow these steps:\n\n1. **Join the Patient and Laboratory tables**: Link the records from the `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) using the `ID` field as the common key.\n\n2. **Sort the records by bilirubin level**: Arrange the joined records in descending order based on the `T-BIL` (total bilirubin) column from the `Laboratory` table. This ensures the highest bilirubin level appears first.\n\n3. **Retrieve the top record**: Limit the result to only the first record, which will have the highest bilirubin level due to the sorting.\n\n4. **Select the required fields**: From the top record, extract the `T-BIL` (total bilirubin) value, along with the patient's `ID`, `SEX`, and `Birthday` from the `Patient` table.\n\nThe final output will display the highest total bilirubin level and the corresponding patient details.",
            "To determine the highest total bilirubin level recorded and list the patient details (ID, sex, and birthday) associated with that level, follow these detailed steps:\n\n1. **Join the Patient and Laboratory tables**: Perform an inner join between the `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) using the `ID` field as the common key. This ensures that only records with matching IDs in both tables are included.\n\n2. **Sort the records by bilirubin level in descending order**: Arrange the joined records based on the `T-BIL` (total bilirubin) column from the `Laboratory` table in descending order. This places the record with the highest bilirubin level at the top of the result set.\n\n3. **Limit the result to the top record**: Restrict the output to only the first record in the sorted result set, which corresponds to the highest bilirubin level.\n\n4. **Select the required fields**: From the top record, retrieve the following fields:\n   - `T-BIL` (total bilirubin) from the `Laboratory` table (`T2`).\n   - `ID`, `SEX`, and `Birthday` from the `Patient` table (`T1`).\n\nThe final output will display the highest total bilirubin level along with the associated patient's ID, sex, and birthday."
        ]
    },
    "1342": {
        "sql": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04';",
        "question": "What was the cost for the \"Posters\" on 2019/9/4?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04'",
        "explain": "'Poster' is an event description; on 2019/9/14 refers to event_date = '2019-09-04'",
        "solution": [
            "To find the cost for the \"Posters\" on September 4, 2019, you need to retrieve the \"cost\" value from the \"expense\" table where the \"expense_description\" is \"Posters\" and the \"expense_date\" is \"2019-09-04\"."
        ]
    },
    "149": {
        "sql": "SELECT DISTINCT d.type\nFROM disp d\nJOIN account a ON d.account_id = a.account_id\nJOIN district di ON a.district_id = di.district_id\nWHERE d.type != 'OWNER'\nAND di.A11 > 8000 AND di.A11 <= 9000;",
        "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
        "explain": "A11 represents the average salary; Salary and income share the similar meanings; when the account type = 'OWNER', it's eligible for loans",
        "solution": []
    },
    "932": {
        "sql": "SELECT DISTINCT r.year\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';\n",
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "explain": "",
        "solution": []
    },
    "16": {
        "sql": "SELECT COUNT(DISTINCT T1.CDSCode) \nFROM schools T1 \nJOIN satscores T2 ON T1.CDSCode = T2.cds \nWHERE T1.StatusType = 'Merged' \nAND T1.County = 'Alameda' \nAND T2.NumTstTakr < 100;",
        "question": "How many schools in merged Alameda have number of test takers less than 100?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.CDSCode) FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Merged' AND T2.NumTstTakr < 100 AND T1.County = 'Lake'",
        "explain": "",
        "solution": [
            "To solve the question \"How many schools in merged Alameda have a number of test takers less than 100?\", follow these steps:\n\n1. **Identify the tables involved**: The solution requires data from two tables, `schools` (referred to as T1) and `satscores` (referred to as T2).\n\n2. **Join the tables**: Combine the `schools` table (T1) and the `satscores` table (T2) using the common column `CDSCode` from T1 and `cds` from T2. This ensures that each school's data is matched with its corresponding SAT scores.\n\n3. **Apply the filters**:\n   - Filter the `schools` table (T1) to include only schools where the `StatusType` is 'Merged'.\n   - Filter the `satscores` table (T2) to include only records where the number of test takers (`NumTstTakr`) is less than 100.\n   - Additionally, filter the `schools` table (T1) to include only schools located in the county 'Lake'.\n\n4. **Count the results**: After applying the filters, count the number of unique `CDSCode` entries from the `schools` table (T1) that meet all the specified conditions.\n\nThis process will yield the count of merged schools in Lake county with fewer than 100 test takers.",
            "To solve the question \"How many schools in merged Alameda have a number of test takers less than 100?\", follow these steps:\n\n1. **Identify the tables involved**: The solution requires data from two tables, `schools` (referred to as T1) and `satscores` (referred to as T2).\n\n2. **Join the tables**: Combine the `schools` table (T1) and the `satscores` table (T2) using the common column `CDSCode` from T1 and `cds` from T2. This ensures that each school's data is matched with its corresponding SAT scores.\n\n3. **Apply the filters**:\n   - Filter the `schools` table (T1) to include only schools where the `StatusType` is 'Merged'.\n   - Filter the `satscores` table (T2) to include only records where the number of test takers (`NumTstTakr`) is less than 100.\n   - Additionally, filter the `schools` table (T1) to include only schools located in the county 'Alameda'.\n\n4. **Count the results**: After applying the filters, count the number of unique `CDSCode` entries from the `schools` table (T1) that meet all the specified conditions.\n\nThis process will yield the count of merged schools in Alameda county with fewer than 100 test takers."
        ]
    },
    "1436": {
        "sql": "SELECT DISTINCT a.link_to_event\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nJOIN attendance a ON m.member_id = a.link_to_member\nWHERE e.cost > 50;",
        "question": "Please provide links to events for members who have paid more than 50 dollar.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T1.cost > 50",
        "explain": "have paid more than 50 dollar refers to cost > 50",
        "solution": []
    },
    "313": {
        "sql": "SELECT COUNT(*) FROM atom WHERE molecule_id = 'TR001';",
        "question": "How many atoms belong to molecule id TR001?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR001'",
        "explain": "",
        "solution": []
    },
    "232": {
        "sql": "SELECT DISTINCT m.molecule_id\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE m.label = '-' AND b.bond_type = '-'\nORDER BY m.molecule_id\nLIMIT 3;",
        "question": "Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id LIMIT 3",
        "explain": "label = '-' means molecules are not carcinogenic; single type bond refers to bond_type = '-'; list top three molecules refers to return molecule_id and order by molecule_id;",
        "solution": []
    },
    "1236": {
        "sql": "SELECT DISTINCT T1.ID, T1.Admission\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'\n  AND (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) >= 50\n  AND (T2.RBC <= 3.5 OR T2.RBC >= 6.0);",
        "question": "For all the female patient age 50 and above, who has abnormal red blood cell count. State if they were admitted to hospital.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND (T2.RBC <= 3.5 OR T2.RBC >= 6.0) AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50",
        "explain": "female patient refers to Sex = 'F'; age 50 and above = SUBTRACT(year(current_timestamp), year(Birthday)) > = 50; abnormal red blood cell count refers to RBC < = 3.5 or RBC > = 6.0; Admission = '+' means the patient was admitted to the hospital; Admission = '-' means the patient was not admitted to the hospital;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct Records**: Retrieve distinct patient records to avoid duplicates.\n\n2. **Join Tables**: Combine the `Patient` table (`T1`) and the `Laboratory` table (`T2`) using the patient ID as the common key.\n\n3. **Filter by Gender**: Include only female patients by checking the `SEX` column in the `Patient` table (`T1.SEX = 'F'`).\n\n4. **Filter by Age**: Ensure the patient is 50 years or older by calculating the difference between the current year and the patient's birth year (`STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50`).\n\n5. **Filter by Abnormal Red Blood Cell Count**: Include patients with abnormal red blood cell counts, defined as either less than or equal to 3.5 or greater than or equal to 6.0 (`T2.RBC <= 3.5 OR T2.RBC >= 6.0`).\n\n6. **Retrieve Admission Status**: Return the patient ID and their admission status (`T1.ID, T1.Admission`) from the filtered results."
        ]
    },
    "432": {
        "sql": "SELECT T1.id FROM sets T1 JOIN set_translations T2 ON T1.code = T2.setCode WHERE T2.language = 'Russian' GROUP BY T1.baseSetSize ORDER BY T1.baseSetSize DESC LIMIT 1;",
        "question": "Which Russian set of cards contains the most cards overall?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Russian' GROUP BY T1.baseSetSize ORDER BY T1.baseSetSize DESC LIMIT 1",
        "explain": "Russian refers to language = 'Russian'; contains the most cards overall refers to MAX(baseSetSize)",
        "solution": [
            "To determine which Russian set of cards contains the most cards overall, follow these steps:\n\n1. **Join the Tables**: Combine the `sets` table (referred to as `T1`) with the `set_translations` table (referred to as `T2`) using the `code` column from `T1` and the `setCode` column from `T2`.\n\n2. **Filter for Russian Language**: From the joined tables, filter the records to include only those where the `language` column in `T2` is 'Russian'.\n\n3. **Group by Set Size**: Group the filtered records by the `baseSetSize` column from `T1`.\n\n4. **Order by Set Size**: Sort the grouped records in descending order based on the `baseSetSize` column to prioritize larger sets.\n\n5. **Limit Results**: Retrieve only the top record (the set with the highest number of cards) from the sorted list.\n\n6. **Select the ID**: Finally, select the `id` column from `T1` to identify the set with the most cards in Russian."
        ]
    },
    "605": {
        "sql": "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Announcer';",
        "question": "How many users obtained the \"Announcer\" badge?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE Name = 'Announcer'",
        "explain": "\"Announcer\" is the Name of badge; user refers to UserId",
        "solution": [
            "To determine how many users obtained the \"Announcer\" badge, the database performs the following operations:\n\n1. **Select the relevant table**: The operation starts by accessing the `badges` table, which contains records of all badges awarded to users.\n\n2. **Filter the records**: The database filters the records in the `badges` table to only include those where the `Name` column matches the value \"Announcer\". This ensures only the badges with the name \"Announcer\" are considered.\n\n3. **Count the filtered records**: The database then counts the number of records that meet the filtering condition. This count represents the number of users who have obtained the \"Announcer\" badge.\n\nThe result of this operation is a single number indicating the total count of users with the \"Announcer\" badge.",
            "To determine how many users obtained the \"Announcer\" badge, the database performs the following operations:\n\n1. **Select the relevant table**: The operation begins by accessing the `badges` table, which contains all records of badges awarded to users.\n\n2. **Filter the records**: The database filters the records in the `badges` table to include only those where the `Name` column is exactly \"Announcer\". This ensures that only badges with the name \"Announcer\" are considered.\n\n3. **Count the filtered records**: The database then counts the number of records that meet the filtering condition. This count is derived from the `id` column of the filtered records, representing the number of users who have obtained the \"Announcer\" badge.\n\nThe result of this operation is a single number indicating the total count of users with the \"Announcer\" badge."
        ]
    },
    "365": {
        "sql": "SELECT type FROM cards WHERE name = 'Benalish Knight';",
        "question": "What is the type of card \"Benalish Knight\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "explain": "Benalish Knight' is the name of card;",
        "solution": []
    },
    "240": {
        "sql": "SELECT element FROM atom WHERE molecule_id = 'TR004';",
        "question": "List all the elements of the toxicology of the molecule \"TR004\".",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
        "explain": "TR004 is the molecule id;",
        "solution": []
    },
    "1156": {
        "sql": "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE E.RVVT = '+';",
        "question": "State the ID and age of patient with positive degree of coagulation.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.RVVT = '+'",
        "explain": "age refers to SUBTRACT(year(current_timestamp), year(Birthday)); positive degree of coagulation refers to RVVT = '+';",
        "solution": []
    },
    "792": {
        "sql": "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Abomination';",
        "question": "What is Abomination's superpower?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Abomination'",
        "explain": "Abomination refers to superhero_name = 'Abomination'; superpower refers to power_name;",
        "solution": []
    },
    "1451": {
        "sql": "SELECT m.member_id\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nGROUP BY m.member_id\nHAVING COUNT(DISTINCT ev.event_id) > 1\nORDER BY SUM(e.cost) DESC\nLIMIT 1;",
        "error": "something went wrong, tool did not call.",
        "question": "Among the members who incurred expenses in more than one event, who paid the most amount?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.member_id FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY T2.member_id HAVING COUNT(DISTINCT T4.event_id) > 1 ORDER BY SUM(T1.cost) DESC LIMIT 1",
        "explain": "paid the most amount refers to for expense incurred in more than one event refers to MAX(cost where COUNT(event_id) > 1)",
        "solution": [
            "To solve the question, 'Among the members who incurred expenses in more than one event, who paid the most amount?', the following steps are performed:\n\n1. **Join the Tables**: Combine the `expense`, `member`, `budget`, and `event` tables to gather all necessary information. The joins are as follows:\n   - The `expense` table is linked to the `member` table using the `link_to_member` field in `expense` and the `member_id` field in `member`.\n   - The `expense` table is also linked to the `budget` table using the `link_to_budget` field in `expense` and the `budget_id` field in `budget`.\n   - The `budget` table is linked to the `event` table using the `link_to_event` field in `budget` and the `event_id` field in `event`.\n\n2. **Group by Member**: Group the results by the `member_id` from the `member` table to aggregate expenses for each member.\n\n3. **Filter Members with Expenses in Multiple Events**: Use the `HAVING` clause to filter out members who have expenses in only one event. Specifically, count the distinct `event_id` values for each member and ensure this count is greater than 1.\n\n4. **Calculate Total Expenses**: For each member, sum the `cost` values from the `expense` table to determine the total amount paid.\n\n5. **Order by Total Expenses**: Sort the results in descending order based on the total expenses to identify the member who paid the most.\n\n6. **Limit Results**: Return only the top result (the member with the highest total expenses) using the `LIMIT 1` clause.\n\nThe final output is the `member_id` of the member who meets all the above criteria."
        ]
    },
    "1496": {
        "sql": "SELECT T1.Segment\nFROM customers T1\nJOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;",
        "question": "Which client segment consumed the least in September 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "explain": "September 2013 refers to yearmonth.date = '201309'",
        "solution": [
            "To determine which client segment consumed the least in September 2013, follow these steps:\n\n1. **Join the Tables**: Combine the `customers` table (aliased as `T1`) with the `yearmonth` table (aliased as `T2`) using the `CustomerID` field as the common key.\n\n2. **Filter for September 2013**: From the joined tables, filter the records to include only those where the `Date` field in `T2` matches '201309' (representing September 2013).\n\n3. **Group by Customer**: Group the filtered records by the `CustomerID` field from the `customers` table (`T1`).\n\n4. **Calculate Total Consumption**: For each customer group, calculate the sum of the `Consumption` values from the `yearmonth` table (`T2`).\n\n5. **Order by Consumption**: Sort the grouped results in ascending order based on the calculated total consumption to identify the customer with the least consumption.\n\n6. **Select the Segment**: From the sorted list, select the `Segment` field from the `customers` table (`T1`) for the customer with the lowest total consumption.\n\n7. **Limit to One Result**: Ensure only the top result (the segment with the least consumption) is returned."
        ]
    },
    "411": {
        "sql": "SELECT DISTINCT T1.artist FROM cards T1 JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%Das perfekte Gegenmittel zu einer dichten Formation%';",
        "question": "To which artist does the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\" belong?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
        "explain": "",
        "solution": [
            "To find the artist associated with the card that has the text \"Das perfekte Gegenmittel zu einer dichten Formation,\" follow these steps:\n\n1. **Identify the relevant tables**: The information is stored in two tables, `cards` (referred to as `T1`) and `foreign_data` (referred to as `T2`).\n\n2. **Join the tables**: Link the `cards` table (`T1`) with the `foreign_data` table (`T2`) using the `uuid` column, which serves as a common identifier between the two tables.\n\n3. **Filter the data**: Within the `foreign_data` table (`T2`), look for records where the `flavorText` column contains the exact phrase \"DAS perfekte Gegenmittel zu einer dichten Formation\" (case-insensitive due to the `LIKE` operator with `%` wildcards).\n\n4. **Retrieve the artist**: From the matching records in the `cards` table (`T1`), select the distinct `artist` values to ensure no duplicates are returned.\n\nThis process ensures that the artist associated with the specified card text is accurately identified."
        ]
    },
    "724": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id AND eye_colour.colour = 'Blue'\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id AND hair_colour.colour = 'Blond';\n",
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "explain": "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; blond hair refers to colour = 'Blond' and hair_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'",
        "solution": []
    },
    "460": {
        "sql": "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer';",
        "question": "Which artist designed the card whose promotional name is \"Battra, Dark Destroyer\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer'",
        "explain": "promotional name is \"Battra, Dark Destroyer\" refers to flavorName = 'Battra, Dark Destroyer'",
        "solution": []
    },
    "630": {
        "sql": "SELECT DISTINCT p.Tags\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'John Salvatier';",
        "question": "What is the name of tags used by John Salvatier's?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'John Salvatier'",
        "explain": "DisplayName = 'John Salvatier';",
        "solution": []
    },
    "728": {
        "sql": "SELECT c.colour, COUNT(s.id) AS superhero_count, RANK() OVER (ORDER BY COUNT(s.id) DESC) AS popularity_rank\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'Marvel Comics'\nGROUP BY c.colour\nORDER BY superhero_count DESC;",
        "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
        "explain": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; most common color refers to COUNT(superhero.id) DESC;",
        "solution": [
            "To rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color, follow these steps:\n\n1. **Join the Tables**: Combine the `superhero` table with the `colour` table using the `eye_colour_id` field in the `superhero` table and the `id` field in the `colour` table. Also, join the `publisher` table with the `superhero` table using the `publisher_id` field in the `superhero` table and the `id` field in the `publisher` table.\n\n2. **Filter for Marvel Comics**: Apply a filter to include only superheroes published by 'Marvel Comics' by checking the `publisher_name` field in the `publisher` table.\n\n3. **Group by Eye Color**: Group the results by the `colour` field from the `colour` table to aggregate superheroes with the same eye color.\n\n4. **Count Superheroes per Eye Color**: For each eye color group, count the number of superheroes.\n\n5. **Rank by Popularity**: Assign a rank to each eye color based on the count of superheroes, in descending order. The most common eye color will have the highest rank (1).\n\n6. **Select the Output**: Display the eye color (`colour.colour`), the count of superheroes for that color (`COUNT(superhero.id)`), and the popularity rank (`RANK() OVER (ORDER BY COUNT(superhero.id) DESC)`)."
        ]
    },
    "122": {
        "sql": "SELECT d.A2 AS district, d.A3 AS region\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.loan_id = 4990;",
        "question": "State the district and region for loan ID '4990'.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.loan_id = 4990",
        "explain": "A2, A3 contains the information about district and region respectively.",
        "solution": []
    },
    "667": {
        "sql": "SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY T1.CreationDate LIMIT 1",
        "question": "What is the title of the post with the oldest post link?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY T1.CreaionDate LIMIT 1",
        "explain": "the oldest post link refers to MIN(CreaionDate);",
        "solution": [
            "To find the title of the post with the oldest post link, follow these steps:\n\n1. **Join the tables**: Combine the `posts` table (referred to as `T1`) and the `postLinks` table (referred to as `T2`) using the `PostId` from `postLinks` and the `Id` from `posts` as the joining condition.\n\n2. **Sort the results**: Order the combined results by the `CreationDate` column from the `posts` table in ascending order to ensure the oldest post appears first.\n\n3. **Retrieve the title**: Select the `Title` column from the `posts` table for the first row in the sorted results, which corresponds to the oldest post.\n\n4. **Limit the output**: Ensure only the title of the oldest post is returned by limiting the result set to just one row.",
            "To determine the title of the post with the oldest post link, follow these detailed steps:\n\n1. **Table Selection**: Identify the `posts` table (aliased as `T1`) and the `postLinks` table (aliased as `T2`). These tables contain the necessary data for the query.\n\n2. **Join Operation**: Perform an inner join between the `posts` table (`T1`) and the `postLinks` table (`T2`). The join condition is `T2.PostId = T1.Id`, which links each post in the `posts` table to its corresponding entry in the `postLinks` table.\n\n3. **Sorting**: After joining the tables, sort the resulting dataset by the `CreationDate` column from the `posts` table (`T1`) in ascending order. This ensures that the oldest post (based on the creation date) appears at the top of the result set.\n\n4. **Column Selection**: From the sorted dataset, select the `Title` column from the `posts` table (`T1`). This column contains the title of the post.\n\n5. **Result Limitation**: Limit the output to only the first row of the sorted dataset using `LIMIT 1`. This ensures that only the title of the oldest post is returned.\n\nThe final SQL query for this operation is:\n```sql\nSELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY T1.CreationDate LIMIT 1\n```"
        ]
    },
    "111": {
        "sql": "SELECT COUNT(*) \nFROM account \nJOIN district ON account.district_id = district.district_id \nWHERE district.A2 = 'Litomerice' \nAND strftime('%Y', account.date) = '1996';",
        "question": "How many accounts were opened in Litomerice in 1996?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1996' AND T1.A2 = 'Litomerice'",
        "explain": "A2 refers to district name; Litomerice is one of district names.",
        "solution": []
    },
    "1027": {
        "sql": "SELECT t2.player_name\nFROM Player_Attributes t1\nJOIN Player t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t1.penalties DESC\nLIMIT 10;",
        "question": "Indicate the full names of the top 10 players with the highest number of penalties.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t2.player_name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.id = t2.id ORDER BY t1.penalties DESC LIMIT 10",
        "explain": "full name refers to player_name; players with highest number of penalties refers to MAX(penalties);",
        "solution": [
            "To find the full names of the top 10 players with the highest number of penalties, follow these steps:\n\n1. **Join the Tables**: Combine the `Player_Attributes` table (referred to as `t1`) with the `Player` table (referred to as `t2`) using the `id` column as the common key. This ensures that each player's attributes are matched with their corresponding player details.\n\n2. **Sort by Penalties**: After joining the tables, sort the resulting dataset in descending order based on the `penalties` column from the `Player_Attributes` table (`t1.penalties`). This places the players with the highest number of penalties at the top of the list.\n\n3. **Limit the Results**: Retrieve only the top 10 records from the sorted dataset. This gives you the 10 players with the highest number of penalties.\n\n4. **Select Player Names**: From the filtered and sorted dataset, extract the `player_name` column from the `Player` table (`t2.player_name`), which contains the full names of the players.\n\nThe final output will be a list of the full names of the top 10 players with the highest number of penalties.",
            "To find the full names of the top 10 players with the highest number of penalties, follow these steps:\n\n1. **Join the Tables**: Perform an inner join between the `Player_Attributes` table (aliased as `t1`) and the `Player` table (aliased as `t2`) using the `id` column as the common key. This ensures that each player's attributes are matched with their corresponding player details.\n\n2. **Sort by Penalties**: After joining the tables, sort the resulting dataset in descending order based on the `penalties` column from the `Player_Attributes` table (`t1.penalties`). This places the players with the highest number of penalties at the top of the list.\n\n3. **Limit the Results**: Retrieve only the top 10 records from the sorted dataset. This gives you the 10 players with the highest number of penalties.\n\n4. **Select Player Names**: From the filtered and sorted dataset, extract the `player_name` column from the `Player` table (`t2.player_name`), which contains the full names of the players.\n\nThe final output will be a list of the full names of the top 10 players with the highest number of penalties."
        ]
    },
    "569": {
        "sql": "SELECT COUNT(*) AS total_votes\nFROM votes v\nJOIN posts p ON v.PostId = p.Id\nWHERE p.Title LIKE '%data visualization%';",
        "question": "Give the number of votes for the post about data visualization.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data visualization%'",
        "explain": "About data visualization is the Title that contains 'data visualization';",
        "solution": []
    },
    "565": {
        "sql": "SELECT CASE WHEN p.ClosedDate IS NULL THEN 'NOT well-finished' ELSE 'well-finished' END AS post_status\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE c.UserId = 23853 AND c.CreationDate = '2013-07-12 09:08:18.0';",
        "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'",
        "explain": "user no. 23853 refers to UserId = '23853'; at 9:08:18 on 2013/7/12 refers to CreationDate = '2013-07-12 09:08:18.0'; not well-finished refers to ClosedDate IS NULL and vice versa",
        "solution": [
            "To determine if the post commented by User No. 23853 at 9:08:18 on 2013/7/12 was well-finished, follow these steps:\n\n1. **Join the tables**: Combine the `comments` table (referred to as T1) and the `posts` table (referred to as T2) using the `PostId` from T1 and the `Id` from T2. This links each comment to its corresponding post.\n\n2. **Filter the data**: Narrow down the results to only include the comment made by User No. 23853 at the specific time '2013-07-12 09:08:18.0'.\n\n3. **Check the post status**: For the filtered post, check if the `ClosedDate` field in the `posts` table (T2) is NULL.\n   - If `ClosedDate` is NULL, the post is **NOT well-finished**.\n   - If `ClosedDate` is not NULL, the post is **well-finished**.\n\n4. **Return the result**: Output the result as either 'well-finished' or 'NOT well-finished' based on the check above."
        ]
    },
    "1146": {
        "sql": "SELECT t2.team_long_name \nFROM Match t1\nJOIN Team t2 ON t1.away_team_api_id = t2.team_api_id\nORDER BY t1.away_team_goal DESC\nLIMIT 1;",
        "question": "Please provide the full name of the away team that scored the most goals.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.team_long_name FROM Match AS t1 INNER JOIN Team AS t2 ON t1.away_team_api_id = t2.team_api_id ORDER BY t1.away_team_goal DESC LIMIT 1",
        "explain": "full name refers to team_long_name; away team refers to away_team_api_id; scored the most goals refers to MAX(away_team_goal)",
        "solution": [
            "To find the full name of the away team that scored the most goals, follow these steps:\n\n1. **Join the Match and Team tables**: Link the `Match` table (aliased as `t1`) with the `Team` table (aliased as `t2`) using the `away_team_api_id` from the `Match` table and the `team_api_id` from the `Team` table. This ensures that each match record is associated with the corresponding team.\n\n2. **Sort by away team goals in descending order**: Arrange the joined records based on the `away_team_goal` column from the `Match` table in descending order. This places the match with the highest number of away team goals at the top.\n\n3. **Limit the result to the top record**: Retrieve only the first record from the sorted list, which corresponds to the away team with the highest number of goals.\n\n4. **Select the team's full name**: From the top record, extract the `team_long_name` from the `Team` table, which provides the full name of the away team that scored the most goals."
        ]
    },
    "889": {
        "sql": "SELECT r.date FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE c.name = 'Brands Hatch' AND r.name = 'British Grand Prix' ORDER BY r.year DESC LIMIT 1;",
        "question": "When was the last f1 season whereby Brands Hatch hosted the British Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Brands Hatch' AND T2.name = 'British Grand Prix' ORDER BY T2.year DESC LIMIT 1",
        "explain": "the last refers to max(year);",
        "solution": [
            "To find the date of the last Formula 1 season when Brands Hatch hosted the British Grand Prix, follow these steps:\n\n1. **Identify the circuit**: Locate the circuit named 'Brands Hatch' in the `circuits` table.\n2. **Join with races**: Link the `circuits` table with the `races` table using the `circuitID` field to find all races held at Brands Hatch.\n3. **Filter for British Grand Prix**: From the joined data, filter for races where the name is 'British Grand Prix'.\n4. **Sort by year**: Order the filtered results by the year in descending order to get the most recent race first.\n5. **Retrieve the date**: Select the date of the most recent race (top result after sorting) to answer the question.\n\nThe SQL query accomplishes this by joining the tables, applying the filters, sorting, and limiting the result to the most recent entry."
        ]
    },
    "790": {
        "sql": "SELECT (e.weight_kg - c.weight_kg) AS weight_difference\nFROM superhero e, superhero c\nWHERE e.full_name = 'Emil Blonsky'\nAND c.full_name = 'Charles Chandler';",
        "question": "Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky' ) - ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler' ) AS CALCULATE",
        "explain": "difference = SUBTRACT(SUM(weight_kg WHERE full_name = 'Emil Blonsky'), SUM(weight_kg WHERE full_name = 'Charles Chandler')); Emil Blonsky is the full name of superhero; Charles Chandler is the full name of superhero;",
        "solution": []
    },
    "492": {
        "sql": "SELECT type FROM sets WHERE name = 'From the Vault: Lore';",
        "question": "For the set \"From the Vault: Lore\", what is its expansion type?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT type FROM sets WHERE name LIKE '%FROM the Vault: Lore%'",
        "explain": "set \"From the Vault refers to name which contains 'From the Vault: Lore'; expansion type refers to type",
        "solution": []
    },
    "578": {
        "sql": "SELECT u.DisplayName, u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Understanding what Dassault iSight is doing?';",
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "explain": "\"Understanding what Dassault iSight is doing?\" is the Title of post; user refers to DisplayName;",
        "solution": []
    },
    "1390": {
        "sql": "SELECT \n    (SUM(CASE WHEN e.event_name = 'Yearly Kickoff' THEN ex.cost ELSE 0 END) / SUM(ex.cost)) * 100 AS percentage_cost\nFROM \n    event e\nJOIN \n    budget b ON e.event_id = b.link_to_event\nJOIN \n    expense ex ON b.budget_id = ex.link_to_budget;",
        "question": "Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) AS REAL) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "explain": "percentage = DIVIDE(SUM(cost where event_name = 'Yearly Kickoff'), SUM(cost)) * 100",
        "solution": []
    },
    "95": {
        "sql": "SELECT T1.account_id\nFROM account T1\nJOIN disp T2 ON T1.account_id = T2.account_id\nJOIN client T3 ON T2.client_id = T3.client_id\nJOIN district T4 ON T1.district_id = T4.district_id\nWHERE T3.client_id = (SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1)\nGROUP BY T4.A11, T1.account_id;",
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.A11, T1.account_id",
        "explain": "If the person A's birthdate < B's birthdate, it means that person B is younger than person A; A11 refers to average salary",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join Tables**: The `account` table (aliased as `T1`) is joined with the `disp` table (aliased as `T2`) using the `account_id` field. This links account information with client distribution data.\n\n2. **Join Client Table**: The result from the first join is further joined with the `client` table (aliased as `T3`) using the `client_id` field from the `disp` table. This adds client-specific details like birth date to the dataset.\n\n3. **Join District Table**: The dataset is then joined with the `district` table (aliased as `T4`) using the `district_id` field from the `account` table. This incorporates district-related information.\n\n4. **Subquery for Youngest Client**: A subquery is used to identify the youngest client by selecting the `client_id` from the `client` table, ordered by `birth_date` in descending order (to get the most recent birth date, i.e., the youngest client), and limited to 1 result.\n\n5. **Filter by Youngest Client**: The main query filters the joined dataset to include only records where the `client_id` matches the one identified in the subquery (the youngest client).\n\n6. **Group and Select**: The final dataset is grouped by the `A11` field from the `district` table and the `account_id` from the `account` table. The query then selects the `account_id` from the `account` table as the output.\n\nThis sequence of operations ensures that the account numbers of clients who are the youngest and have the highest average salary are listed."
        ]
    },
    "57": {
        "sql": "SELECT s.Phone, s.Ext\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY sc.AvgScrWrite DESC\nLIMIT 1 OFFSET 332;",
        "question": "What is the phone number and extension number for the school that had the 333rd highest average writing score?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone, T2.Ext FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrWrite DESC LIMIT 332, 1",
        "explain": "",
        "solution": []
    },
    "45": {
        "sql": "SELECT s.School, sc.AvgScrWrite\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE (s.AdmFName1 = 'Ricci' AND s.AdmLName1 = 'Ulrich') \n   OR (s.AdmFName2 = 'Ricci' AND s.AdmLName2 = 'Ulrich') \n   OR (s.AdmFName3 = 'Ricci' AND s.AdmLName3 = 'Ulrich')\nGROUP BY s.School;",
        "question": "What is the average writing score of each of the schools managed by Ricci Ulrich? List the schools and the corresponding average writing scores.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School, T1.AvgScrWrite FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'",
        "explain": "Usually, administrators manage the school stuff.",
        "solution": []
    },
    "1487": {
        "sql": "SELECT T1.CustomerID\nFROM customers T1\nJOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' AND T1.Currency = 'EUR' AND T2.Date = '201310'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
        "question": "Which LAM customer used the Euro as their currency and had the highest consumption in October 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date = '201310' AND T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "explain": "October 2013 refers to 201310 in the yearmonth.date",
        "solution": [
            "To find the LAM customer who used the Euro as their currency and had the highest consumption in October 2013, follow these steps:\n\n1. **Join the Tables**: Combine the `customers` table (referred to as T1) and the `yearmonth` table (referred to as T2) using the `CustomerID` field to link them.\n\n2. **Filter the Data**: Apply the following filters:\n   - From the `customers` table (T1), select only those customers where the `Segment` is 'LAM' and the `Currency` is 'EUR'.\n   - From the `yearmonth` table (T2), select only the records where the `Date` is '201310' (representing October 2013).\n\n3. **Group the Data**: Group the filtered records by `CustomerID` to aggregate the consumption data for each customer.\n\n4. **Calculate Total Consumption**: For each customer, sum the `Consumption` values from the `yearmonth` table (T2).\n\n5. **Sort the Results**: Order the grouped results by the total consumption in descending order to prioritize customers with the highest consumption.\n\n6. **Retrieve the Top Customer**: Limit the results to the top 1 customer to identify the one with the highest consumption.\n\nThe final output will be the `CustomerID` of the LAM customer who meets all the specified criteria and had the highest consumption in October 2013."
        ]
    },
    "821": {
        "sql": "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Ajax';",
        "question": "List down Ajax's superpowers.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Ajax'",
        "explain": "Ajax refers to superhero_name = 'Ajax'; superpowers refers to power_name;",
        "solution": []
    },
    "327": {
        "sql": "SELECT m.molecule_id\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '-'\nGROUP BY m.molecule_id\nHAVING COUNT(a.atom_id) > 5;",
        "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
        "explain": "label = '-' means molecules are non-carcinogenic; molecules consisted more than 5 atoms refers to COUNT(molecule_id) > 5",
        "solution": [
            "To solve the question \"Which non-carcinogenic molecules consist of more than 5 atoms?\", the following steps are performed:\n\n1. **Filter Non-Carcinogenic Molecules**: First, the molecules labeled as non-carcinogenic (denoted by the label '-') are selected from the `molecule` table.\n\n2. **Count Atoms per Molecule**: For each of these non-carcinogenic molecules, the number of atoms is counted by joining the `molecule` table with the `atom` table on the `molecule_id` field.\n\n3. **Group by Molecule**: The results are grouped by `molecule_id` to aggregate the count of atoms for each molecule.\n\n4. **Filter by Atom Count**: Only molecules with more than 5 atoms are retained by applying the condition `HAVING COUNT(T2.atom_id) > 5`.\n\n5. **Output Molecule IDs**: Finally, the `molecule_id` of the qualifying molecules is returned as the result.\n\nThis process ensures that only non-carcinogenic molecules with more than 5 atoms are identified and listed."
        ]
    },
    "795": {
        "sql": "SELECT COUNT(*) FROM superhero WHERE alignment_id = 3;",
        "question": "How many superheroes have a neutral alignment?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "explain": "neutral alignment refers to alignment_id = 3;",
        "solution": []
    },
    "673": {
        "sql": "WITH OldestUsers AS (\n    SELECT Id \n    FROM users \n    WHERE Age = (SELECT MAX(Age) FROM users)\n),\nVotedPosts AS (\n    SELECT COUNT(DISTINCT PostId) AS PostCount \n    FROM votes \n    WHERE UserId IN (SELECT Id FROM OldestUsers)\n)\nSELECT AVG(PostCount) AS AveragePostsVoted \nFROM VotedPosts;",
        "question": "What is the average number of posts voted by the oldest users?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT AVG(PostId) FROM votes WHERE UserId IN ( SELECT Id FROM users WHERE Age = ( SELECT MAX(Age) FROM users ) )",
        "explain": "average number of posts voted refers to AVG(PostId) FROM votes; the oldest users refer to MAX(Age);",
        "solution": [
            "To find the average number of posts voted by the oldest users, follow these steps:\n\n1. **Identify the oldest users**: First, determine the maximum age in the `users` table. This is done by querying the `users` table for the `MAX(Age)`.\n\n2. **Retrieve the IDs of the oldest users**: Using the maximum age identified in the previous step, query the `users` table again to get the `Id` of all users who have this maximum age.\n\n3. **Find the posts voted by these users**: With the list of user IDs from the oldest users, query the `votes` table to retrieve all `PostId` entries where the `UserId` matches any of the IDs from the oldest users.\n\n4. **Calculate the average**: Finally, compute the average of the `PostId` values retrieved in the previous step. This gives the average number of posts voted by the oldest users.\n\nThe SQL query combines these steps into a single operation, but the logical flow is as described above.",
            "To find the average number of posts voted by the oldest users, follow these detailed steps:\n\n1. **Identify the maximum age of users**: Query the `users` table to find the highest age value using the `MAX(Age)` function. This will give the age of the oldest users.\n\n2. **Retrieve the IDs of the oldest users**: Using the maximum age identified in the first step, query the `users` table again to select the `Id` of all users whose `Age` matches this maximum age. This will provide a list of user IDs for the oldest users.\n\n3. **Find all posts voted by these users**: With the list of user IDs from the oldest users, query the `votes` table to retrieve all `PostId` entries where the `UserId` matches any of the IDs from the oldest users. This step identifies all posts that the oldest users have voted on.\n\n4. **Calculate the average number of posts voted**: Finally, compute the average of the `PostId` values retrieved in the previous step using the `AVG(PostId)` function. This average represents the mean number of posts voted by the oldest users.\n\nThe SQL query combines these steps into a single operation, but the logical flow is as described above."
        ]
    },
    "54": {
        "sql": "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian';",
        "question": "Please specify all of the schools and their related mailing zip codes that are under Avetik Atoian's administration.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian'",
        "explain": "",
        "solution": [
            "To solve the question, you need to retrieve all schools and their corresponding mailing zip codes from the 'schools' table where the administrator's first name is 'Avetik' and the last name is 'Atoian'. The solution involves querying the 'schools' table and filtering the records based on the administrator's first and last name. The result will list the schools and their mailing zip codes that meet the specified criteria.",
            "To solve the question, you need to retrieve all schools and their corresponding mailing zip codes from the 'schools' table where the administrator's first name is 'Avetik' and the last name is 'Atoian'. The solution involves the following steps:\n\n1. **Access the 'schools' table**: This table contains information about schools, including their names, mailing zip codes, and administrator details.\n\n2. **Filter the records**: Apply a filter to select only those records where the administrator's first name ('AdmFName1') is 'Avetik' and the last name ('AdmLName1') is 'Atoian'.\n\n3. **Retrieve the required fields**: From the filtered records, extract the 'School' (name of the school) and 'MailZip' (mailing zip code of the school) fields.\n\n4. **Return the results**: The final output will be a list of schools and their mailing zip codes that are under Avetik Atoian's administration.\n\nThe SQL query for this operation is: `SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian'`."
        ]
    },
    "358": {
        "sql": "SELECT borderColor FROM cards WHERE name = 'Ancestor''s Chosen';",
        "question": "What is the border color of card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT borderColor FROM cards WHERE name = 'Ancestor''s Chosen'",
        "explain": "name of card  = 'Ancestor''s Chosen' ;",
        "solution": []
    },
    "560": {
        "sql": "SELECT COUNT(*) FROM badges WHERE Name = 'Revival';",
        "question": "Give the number of \"Revival\" badges.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE Name = 'Revival'",
        "explain": "number refers to Id; 'Revival' is the Name of badge",
        "solution": []
    },
    "373": {
        "sql": "SELECT name FROM cards WHERE artist = 'Aaron Boyd';",
        "question": "Name the cards that were illustrated by Aaron Boyd.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd'",
        "explain": "Aaron Boyd' is artist;",
        "solution": []
    },
    "1490": {
        "sql": "WITH LAM_Customers AS (\n    SELECT DISTINCT T1.CustomerID\n    FROM customers T1\n    JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\n    WHERE T1.Segment = 'LAM'\n),\nHigh_Consumption AS (\n    SELECT COUNT(*) AS High_Count\n    FROM LAM_Customers LC\n    JOIN yearmonth YM ON LC.CustomerID = YM.CustomerID\n    WHERE YM.Consumption > 46.73\n),\nTotal_LAM AS (\n    SELECT COUNT(*) AS Total_Count\n    FROM LAM_Customers\n)\nSELECT (CAST(High_Count AS REAL) / CAST(Total_Count AS REAL)) * 100 AS Percentage\nFROM High_Consumption, Total_LAM;",
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "explain": "Percentage of LAM customer consumed more than 46.73 = (Total no. of LAM customers who consumed more than 46.73 / Total no. of LAM customers) * 100.",
        "solution": [
            "To determine the percentage of LAM customers who consumed more than 46.73, follow these steps:\n\n1. **Join the Tables**: Combine the `customers` table (aliased as T1) with the `yearmonth` table (aliased as T2) using the `CustomerID` field to link the records.\n\n2. **Filter by Segment**: From the joined tables, filter the records to include only those customers where the `Segment` field in the `customers` table is 'LAM'.\n\n3. **Count Total Customers**: Calculate the total number of LAM customers by counting the distinct `CustomerID` values from the filtered records.\n\n4. **Identify High Consumption**: For each customer, check if their `Consumption` value in the `yearmonth` table is greater than 46.73. If it is, assign a value of 1; otherwise, assign 0.\n\n5. **Sum High Consumption Cases**: Sum all the 1s from the previous step to get the total number of LAM customers who consumed more than 46.73.\n\n6. **Calculate Percentage**: Divide the sum of high consumption cases by the total number of LAM customers, then multiply by 100 to convert the result into a percentage.\n\n7. **Cast to Float**: Ensure the division is performed as a floating-point operation to avoid integer division issues.\n\nThe final result is the percentage of LAM customers whose consumption exceeded 46.73."
        ]
    },
    "101": {
        "sql": "SELECT account_id FROM trans WHERE strftime('%Y', date) = '1995' ORDER BY date ASC LIMIT 1;",
        "question": "List out the accounts who have the earliest trading date in 1995 ?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1",
        "explain": "",
        "solution": [
            "To list the accounts with the earliest trading date in 1995, follow these steps:\n1. Filter the transactions to include only those where the year of the trading date is 1995.\n2. Sort the filtered transactions by the trading date in ascending order to find the earliest date.\n3. Select the account ID from the first transaction in the sorted list, which corresponds to the earliest trading date in 1995."
        ]
    },
    "535": {
        "sql": "SELECT COUNT(*) AS UserCount\nFROM users\nWHERE UpVotes > 100 AND DownVotes > 1;",
        "question": "Among the users who have more than 100 upvotes, how many of them have more then 1 downvotes?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Upvotes > 100 AND Downvotes > 1",
        "explain": "more than 100 upvotes refers to Upvotes > 100; more than 1 downvotes refers to Downvotes > 1",
        "solution": []
    },
    "77": {
        "sql": "SELECT T2.School, (T1.\"FRPM Count (Ages 5-17)\" / T1.\"Enrollment (Ages 5-17)\") * 100 AS \"Percent Eligible FRPM (Ages 5-17)\"\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9';",
        "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
        "explain": "Percent (%) Eligible FRPM (Ages 5-17) can be acquired by `FRPM Count (Ages 5-17)` / `Enrollment (Ages 5-17)` * 100",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join Tables**: The `frpm` table (aliased as `T1`) and the `schools` table (aliased as `T2`) are joined using the `CDSCode` column, which is common to both tables.\n\n2. **Filter by County and Grade Span**: The joined data is filtered to include only those records where:\n   - The `County` column in the `schools` table (`T2`) is 'Los Angeles'.\n   - The `GSserved` column in the `schools` table (`T2`) is 'K-9', indicating the grade span from Kindergarten to 9th grade.\n\n3. **Calculate Percentage**: For each qualifying school, the percentage of students eligible for Free or Reduced-Price Meals (FRPM) is calculated by:\n   - Dividing the `FRPM Count (Ages 5-17)` column from the `frpm` table (`T1`) by the `Enrollment (Ages 5-17)` column from the same table.\n   - Multiplying the result by 100 to convert it to a percentage.\n\n4. **Select Output**: The final output includes:\n   - The name of the school (`School` column from `T2`).\n   - The calculated percentage of eligible FRPM students.\n\nThis solution ensures that all schools in Los Angeles County serving grades K-9 are identified, along with their respective FRPM eligibility percentages."
        ]
    },
    "1109": {
        "sql": "SELECT t2.buildUpPlayDribblingClass \nFROM Team t1 \nJOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_short_name = 'LEI' \nAND SUBSTR(t2.date, 1, 10) = '2015-09-10';",
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "explain": "\"LEI\" refers to team_short_name = 'LEI'; on 2015/9/10 refers to\u00a0 date = '2015-09-10 00:00:00'",
        "solution": [
            "To find out the build-up play dribbling class for the team with the short name \"LEI\" on September 10, 2015, follow these steps:\n\n1. **Identify the Team**: Locate the team in the \"Team\" table where the \"team_short_name\" is \"LEI\". This will give you the team's unique identifier (team_api_id).\n\n2. **Join with Team Attributes**: Use the team_api_id obtained from the \"Team\" table to join with the \"Team_Attributes\" table. This will allow you to access the team's attributes, including the build-up play dribbling class.\n\n3. **Filter by Date**: From the joined data, filter the records to only include those where the date (formatted as YYYY-MM-DD) is \"2015-09-10\".\n\n4. **Retrieve the Attribute**: Finally, select the \"buildUpPlayDribblingClass\" attribute from the filtered records to get the desired information.\n\nThis process ensures that you accurately retrieve the build-up play dribbling class for the specified team on the given date.",
            "To determine the build-up play dribbling class for the team with the short name \"LEI\" on September 10, 2015, the following steps are executed in the SQL query:\n\n1. **Team Identification**: The query starts by identifying the team in the \"Team\" table (aliased as `t1`) where the \"team_short_name\" column matches the value \"LEI\". This retrieves the team's unique identifier, \"team_api_id\".\n\n2. **Join with Team Attributes**: The query then performs an inner join between the \"Team\" table (`t1`) and the \"Team_Attributes\" table (aliased as `t2`). The join condition is based on the \"team_api_id\" column, ensuring that only records with matching team identifiers are combined.\n\n3. **Date Filtering**: After the join, the query filters the results to include only those records where the \"date\" column in the \"Team_Attributes\" table (formatted as YYYY-MM-DD) matches the specified date \"2015-09-10\". The `SUBSTR` function is used to extract the first 10 characters of the \"date\" column to ensure the comparison is accurate.\n\n4. **Attribute Retrieval**: Finally, the query selects the \"buildUpPlayDribblingClass\" column from the \"Team_Attributes\" table (`t2`) to return the build-up play dribbling class for the specified team on the given date.\n\nThis sequence of operations ensures that the query accurately retrieves the desired attribute for the team \"LEI\" on September 10, 2015."
        ]
    },
    "820": {
        "sql": "SELECT ha.attribute_value\nFROM hero_attribute ha\nJOIN superhero sh ON ha.hero_id = sh.id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE sh.superhero_name = 'Hulk' AND a.attribute_name = 'Strength';",
        "question": "How strong is the Hulk?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = 'Hulk' AND T3.attribute_name = 'Strength'",
        "explain": "how strong refers to attribute_value WHERE attribute_name = 'Strength'; the Hulk refers to superhero_name = 'Hulk';",
        "solution": []
    },
    "1329": {
        "sql": "SELECT z.county\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Sherri' AND m.last_name = 'Ramsey';",
        "question": "What county did Sherri Ramsey grew up?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey'",
        "explain": "",
        "solution": []
    },
    "106": {
        "sql": "SELECT MAX(t.amount) AS biggest_transaction_amount\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN card cd ON d.disp_id = cd.disp_id\nWHERE cd.issued = '1996-10-21';",
        "question": "What is the biggest amount of transaction that the client whose card was opened in 1996/10/21 made?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.amount FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 on T2.account_id = T3.account_id JOIN trans AS T4 on T3.account_id = T4.account_id WHERE T1.issued = '1996-10-21' ORDER BY T4.amount DESC LIMIT 1",
        "explain": "",
        "solution": []
    },
    "1037": {
        "sql": "WITH FilteredPlayers AS (\n  SELECT \n    t1.player_api_id,\n    t2.preferred_foot\n  FROM \n    Player t1\n  JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\n  WHERE \n    strftime('%Y', t1.birthday) BETWEEN '1987' AND '1992'\n),\nTotalPlayers AS (\n  SELECT \n    COUNT(*) AS total_count\n  FROM \n    FilteredPlayers\n),\nLeftFootedPlayers AS (\n  SELECT \n    COUNT(*) AS left_foot_count\n  FROM \n    FilteredPlayers\n  WHERE \n    preferred_foot = 'left'\n)\nSELECT \n  (left_foot_count * 100.0 / total_count) AS percentage_left_footed\nFROM \n  TotalPlayers, LeftFootedPlayers;",
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "explain": "players who prefer left foot refers to preferred_foot = 'left'; percentage of players who prefer left foot = DIVIDE(MULTIPLY((SUM(preferred_foot = 'left'), 100)), COUNT(player_fifa_api_id)); born between 1987 and 1992 refers to YEAR(birthday) BETWEEN '1987' AND '1992';",
        "solution": [
            "To calculate the percentage of players who prefer their left foot and were born between 1987 and 1992, follow these steps:\n\n1. **Join the Tables**: Combine the `Player` table (aliased as `t1`) with the `Player_Attributes` table (aliased as `t2`) using the `player_api_id` field to link the records.\n\n2. **Filter by Birth Year**: From the joined data, filter out players whose birth year (extracted from the `birthday` field) falls between 1987 and 1992.\n\n3. **Count Total Players**: Count the total number of players who meet the birth year criteria.\n\n4. **Count Left-Footed Players**: From the filtered players, count how many have their `preferred_foot` set to 'left'.\n\n5. **Calculate Percentage**: Divide the count of left-footed players by the total count of players (from step 3) and multiply by 100 to get the percentage.\n\n6. **Output the Result**: Display the calculated percentage as the result.\n\nThis process ensures that the percentage is derived accurately from the specified subset of players."
        ]
    },
    "307": {
        "sql": "SELECT T2.element FROM connected T1 JOIN atom T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3';",
        "question": "Name the atoms' elements that form bond TR000_2_3.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3'",
        "explain": "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "solution": [
            "To find the elements of the atoms that form the bond with the ID 'TR000_2_3', follow these steps:\n\n1. **Join the Tables**: Combine the `connected` table (referred to as T1) with the `atom` table (referred to as T2) using the `atom_id` field. This links each bond connection to its corresponding atom.\n\n2. **Filter by Bond ID**: From the joined tables, filter the records to only include those where the `bond_id` is 'TR000_2_3'. This isolates the specific bond you are interested in.\n\n3. **Select the Element**: From the filtered records, extract the `element` field from the `atom` table (T2). This gives you the names of the elements of the atoms involved in the bond.\n\nThe result will be a list of elements for the atoms that form the bond 'TR000_2_3'."
        ]
    },
    "167": {
        "sql": "SELECT DISTINCT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.type = 'junior' AND strftime('%Y', ca.issued) > '1996';",
        "question": "List all the clients' IDs whose junior credit cards were issued after 1996.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.client_id FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'junior' AND T1.issued >= '1997-01-01'",
        "explain": "After 1996 means date > = '1997-01-01",
        "solution": []
    }
}