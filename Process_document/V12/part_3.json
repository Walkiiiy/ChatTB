{
    "164": {
        "sql": "SELECT c.client_id\nFROM `order` o\nJOIN account a ON o.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE o.order_id = 32423;",
        "question": "Who placed the order with the id 32423?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.client_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T4.account_id = T2.account_id  INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE T1.order_id = 32423",
        "explain": "",
        "solution": [
            "To find out who placed the order with the ID 32423, follow these steps:\n\n1. **Identify the order**: Locate the order in the `order` table (referred to as T1) where the `order_id` is 32423.\n\n2. **Link to the account**: Using the `account_id` from the identified order, find the corresponding account in the `account` table (referred to as T2).\n\n3. **Link to the disp record**: Using the `account_id` from the account table, find the corresponding record in the `disp` table (referred to as T4).\n\n4. **Link to the client**: Using the `client_id` from the disp record, find the corresponding client in the `client` table (referred to as T3).\n\n5. **Retrieve the client ID**: Extract the `client_id` from the client table to identify who placed the order.\n\nThis sequence of operations ensures that you trace the order back to the client who placed it by navigating through the related tables."
        ]
    },
    "130": {
        "sql": "SELECT COUNT(DISTINCT d.account_id) AS account_holders_without_credit_cards\nFROM district t1\nJOIN client t2 ON t1.district_id = t2.district_id\nJOIN disp d ON t2.client_id = d.client_id\nWHERE t1.A3 = 'south Bohemia' AND d.type != 'OWNER';",
        "question": "How many of the account holders in South Bohemia still do not own credit cards?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.account_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.client_id = T3.client_id WHERE T1.A3 = 'south Bohemia' AND T3.type != 'OWNER'",
        "explain": "A3 contains the region names; South Bohemia is one of region names.",
        "solution": [
            "To find out how many account holders in South Bohemia still do not own credit cards, follow these steps:\n\n1. **Join the `district` table (T1) with the `client` table (T2)** using the `district_id` field to link them. This ensures we are only considering clients from the South Bohemia region.\n\n2. **Join the resulting table with the `disp` table (T3)** using the `client_id` field to link them. This connects each client to their account information.\n\n3. **Filter the results** to include only those records where:\n   - The `A3` field in the `district` table (T1) is 'south Bohemia' (indicating the client is from South Bohemia).\n   - The `type` field in the `disp` table (T3) is not 'OWNER' (indicating the account holder does not own a credit card).\n\n4. **Count the number of account IDs** (`account_id`) from the `disp` table (T3) that meet the above criteria. This gives the total number of account holders in South Bohemia who do not own credit cards."
        ]
    },
    "172": {
        "sql": "SELECT \n    SUM(CASE WHEN type = 'OWNER' THEN 1 ELSE 0 END) AS owner_count,\n    SUM(CASE WHEN type = 'DISPONENT' THEN 1 ELSE 0 END) AS disponent_count\nFROM \n    disp\nWHERE \n    account_id BETWEEN 1 AND 10;",
        "question": "How many owner and disponent dispositions are there from account number 1 to account number 10?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT SUM(type = 'OWNER') , SUM(type = 'DISPONENT') FROM disp WHERE account_id BETWEEN 1 AND 10",
        "explain": "",
        "solution": [
            "To solve the question, we need to count the number of 'OWNER' and 'DISPONENT' dispositions for accounts with IDs ranging from 1 to 10. The solution involves the following steps:\n\n1. **Filter the Data**: Select all records from the `disp` table where the `account_id` is between 1 and 10 (inclusive).\n2. **Count 'OWNER' Dispositions**: For the filtered records, count how many entries have the `type` column set to 'OWNER'.\n3. **Count 'DISPONENT' Dispositions**: Similarly, count how many entries have the `type` column set to 'DISPONENT'.\n4. **Return the Results**: The final output will display the total count of 'OWNER' dispositions and the total count of 'DISPONENT' dispositions for the specified account range."
        ]
    },
    "1409": {
        "sql": "SELECT SUM(cost) AS total_expense FROM expense WHERE expense_date = '2019-08-20';",
        "question": "Mention the total expense used on 8/20/2019.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20'",
        "explain": "total expense refers SUM(cost) where expense_date = '2019-08-20'",
        "solution": []
    },
    "1111": {
        "sql": "SELECT ta.chanceCreationPassingClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'PEC Zwolle' \nAND ta.date = '2013-09-20 00:00:00';",
        "question": "State the chance creation passing class for \"PEC Zwolle\" on 2013/9/20.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'PEC Zwolle' AND SUBSTR(t2.`date`, 1, 10) = '2013-09-20'",
        "explain": "\"PEC Zwolle\" refers to team_long_name = 'PEC Zwolle'; on 2013/9/20 refers to date = '2013-09-20 00:00:00'",
        "solution": []
    },
    "738": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Durability' AND ha.attribute_value < 50;",
        "question": "Which superheroes have a durability attribute value of less than 50?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "explain": "durability of less than 50 refers to attribute_name = 'Durability' AND attribute_value < 50",
        "solution": []
    },
    "936": {
        "sql": "SELECT T1.fastestLap\nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nJOIN drivers T3 ON T1.driverId = T3.driverId\nWHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008\nAND T3.forename = 'Lewis' AND T3.surname = 'Hamilton';",
        "question": "Which was the fastest lap for Lewis Hamilton in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008 AND T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "explain": "",
        "solution": [
            "To find the fastest lap for Lewis Hamilton in the 2008 Australian Grand Prix, follow these steps:\n\n1. **Join the tables**: Combine the `results` table (T1), the `races` table (T2), and the `drivers` table (T3) using the following relationships:\n   - Link `results` (T1) and `races` (T2) on the `raceId` column.\n   - Link `results` (T1) and `drivers` (T3) on the `driverId` column.\n\n2. **Filter the data**: Apply the following filters to the joined tables:\n   - From the `races` table (T2), select the race where the `name` is 'Australian Grand Prix' and the `year` is 2008.\n   - From the `drivers` table (T3), select the driver where the `forename` is 'Lewis' and the `surname` is 'Hamilton'.\n\n3. **Retrieve the result**: From the filtered data, extract the `fastestLap` value from the `results` table (T1).\n\nThis will give you the fastest lap time recorded by Lewis Hamilton in the 2008 Australian Grand Prix."
        ]
    },
    "371": {
        "sql": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1;",
        "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1",
        "explain": "Story Spotlight card refers to isStorySpotlight = 1; French is the language; Percentage = Divide(Count(id) where language = 'French' and isStorySpotlight = 1, Count(id) where isStorySpotlight = 1)*100",
        "solution": [
            "To determine the percentage of cards whose language is French among the Story Spotlight cards, follow these steps:\n\n1. **Join the Tables**: Combine the `cards` table (referred to as `T1`) with the `foreign_data` table (referred to as `T2`) using the `uuid` field as the common key.\n\n2. **Filter Story Spotlight Cards**: From the joined tables, select only those cards where the `isStorySpotlight` field in the `cards` table (`T1`) is set to 1 (indicating they are Story Spotlight cards).\n\n3. **Count Total Story Spotlight Cards**: Calculate the total number of Story Spotlight cards by counting the `id` field in the `cards` table (`T1`).\n\n4. **Count French Language Cards**: For each card in the filtered set, check if the `language` field in the `foreign_data` table (`T2`) is 'French'. If it is, count it as 1; otherwise, count it as 0. Sum these values to get the total number of French language cards among the Story Spotlight cards.\n\n5. **Calculate Percentage**: Divide the count of French language cards by the total count of Story Spotlight cards, multiply the result by 100, and cast the result to a real number to get the percentage.\n\nThe final result is the percentage of Story Spotlight cards that are in French.",
            "To determine the percentage of cards whose language is French among the Story Spotlight cards, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `cards` table (referred to as `T1`) and the `foreign_data` table (referred to as `T2`) using the `uuid` field as the common key. This ensures that each card in `T1` is matched with its corresponding language data in `T2`.\n\n2. **Filter Story Spotlight Cards**: From the joined tables, filter the records to include only those cards where the `isStorySpotlight` field in the `cards` table (`T1`) is set to 1. This identifies all Story Spotlight cards.\n\n3. **Count Total Story Spotlight Cards**: Calculate the total number of Story Spotlight cards by counting the `id` field in the `cards` table (`T1`). This gives the denominator for the percentage calculation.\n\n4. **Count French Language Cards**: For each card in the filtered set, check if the `language` field in the `foreign_data` table (`T2`) is 'French'. If it is, count it as 1; otherwise, count it as 0. Sum these values to get the total number of French language cards among the Story Spotlight cards. This gives the numerator for the percentage calculation.\n\n5. **Calculate Percentage**: Divide the count of French language cards (numerator) by the total count of Story Spotlight cards (denominator), multiply the result by 100, and cast the result to a real number to ensure accurate decimal representation. This yields the percentage of Story Spotlight cards that are in French.\n\nThe final result is the percentage of Story Spotlight cards that are in French, derived from the SQL query:\n```sql\nSELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1\n```"
        ]
    },
    "1469": {
        "sql": "SELECT m.first_name, m.last_name, m.position\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE z.city = 'Lincolnton' AND z.state = 'North Carolina' AND m.zip = 28092;",
        "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
        "explain": "full name refers to first_name, last_name, hometown of Lincolnton, North Carolina refers to city = 'Lincolnton' AND state = 'North Carolina'",
        "solution": []
    },
    "188": {
        "sql": "SELECT l.account_id\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nWHERE l.duration > 24\nAND strftime('%Y', a.date) < '1997'\nORDER BY l.amount ASC\nLIMIT 1;",
        "question": "Among the accounts who have loan validity more than 24 months, list out the accounts that have the lowest approved amount and have account opening date before 1997.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.duration > 24 AND STRFTIME('%Y', T2.date) < '1997' ORDER BY T1.amount ASC LIMIT 1",
        "explain": "",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Filter Loans by Duration**: Identify all loan records where the loan duration is greater than 24 months.\n2. **Filter Accounts by Opening Date**: From the filtered loans, join with the account records to find accounts that were opened before the year 1997. This is done by extracting the year from the account opening date and comparing it to '1997'.\n3. **Sort by Approved Amount**: Among the filtered records, sort the loans in ascending order based on the approved amount to find the loan with the lowest approved amount.\n4. **Retrieve the Account ID**: Select the account ID of the loan with the lowest approved amount from the sorted list.\n5. **Limit to One Result**: Ensure only the account with the lowest approved amount is returned by limiting the result to one record.\n\nThe final output is the account ID of the account that meets all the specified criteria."
        ]
    },
    "1434": {
        "sql": "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico';",
        "question": "What are the zip codes that have post office boxes in the country of the country of San Juan Municipio whose state is Puerto Rico?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico'",
        "explain": "zip codes that have post office boxes refers to type = 'PO Box'",
        "solution": []
    },
    "1382": {
        "sql": "SELECT m.first_name, m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE maj.major_name = 'Interior Design' AND e.event_name = 'Community Theater';",
        "question": "Among the students majored in interior design, who have attended the Community Theater event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id WHERE T4.event_name = 'Community Theater' AND T1.major_name = 'Interior Design'",
        "explain": "majored in music refers to major_name = 'Interior Design'; 'Community Theater' is the event name;",
        "solution": []
    },
    "168": {
        "sql": "SELECT (SUM(CASE WHEN c.gender = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.client_id)) AS percentage_female\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE d.A11 > 10000;",
        "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
        "explain": "Female refers to gender = 'F'; Woman and female are closed; Average salary can be found in A11",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join the Tables**: Combine the `district` table (referred to as `T1`) and the `client` table (referred to as `T2`) using the `district_id` field as the common key. This links each client to their respective district.\n\n2. **Filter Districts by Salary**: From the joined tables, filter out only those records where the average salary (`A11` in the `district` table) is greater than 10,000. This ensures we only consider clients from districts with an average salary above this threshold.\n\n3. **Count Total Clients**: Calculate the total number of clients (`COUNT(T2.client_id)`) who opened their accounts in these high-salary districts.\n\n4. **Count Female Clients**: Among these clients, count how many are women (`SUM(T2.gender = 'F')`). This checks if the `gender` field in the `client` table is 'F' (female).\n\n5. **Calculate Percentage**: Convert the count of female clients to a percentage of the total clients. This is done by casting the count of female clients to a real number, multiplying by 100, and then dividing by the total number of clients.\n\nThe final result is the percentage of female clients among those who opened accounts in districts with an average salary over 10,000."
        ]
    },
    "842": {
        "sql": "SELECT AVG(s.height_cm) AS average_height\nFROM superhero s\nJOIN alignment a ON s.alignment_id = a.id\nWHERE a.alignment = 'Neutral' AND s.height_cm IS NOT NULL;",
        "question": "Calculate the average height of all neutral superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "explain": "",
        "solution": []
    },
    "284": {
        "sql": "SELECT DISTINCT T2.bond_type FROM atom T1 JOIN bond T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c';",
        "question": "Determine the bond type that is formed in the chemical compound containing element Carbon.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'",
        "explain": "Carbon refers to element = 'c'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
        "solution": [
            "To determine the bond type formed in the chemical compound containing the element Carbon, follow these steps:\n\n1. **Identify the relevant tables**: The query involves two tables, `atom` (referred to as `T1`) and `bond` (referred to as `T2`).\n\n2. **Filter atoms by element**: From the `atom` table (`T1`), select only those records where the `element` column has the value 'c' (representing Carbon).\n\n3. **Join with the bond table**: Use the `molecule_id` column to join the filtered `atom` records (`T1`) with the `bond` table (`T2`). This ensures that only bonds associated with molecules containing Carbon are considered.\n\n4. **Retrieve distinct bond types**: From the joined result, select the `bond_type` column from the `bond` table (`T2`). The `DISTINCT` keyword ensures that each bond type is listed only once, avoiding duplicates.\n\n5. **Output the result**: The final output is a list of unique bond types found in compounds containing Carbon."
        ]
    },
    "184": {
        "sql": "SELECT COUNT(DISTINCT c.client_id) AS female_junior_card_holders\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE c.gender = 'F' AND ca.type = 'junior';",
        "question": "How many female customers have a junior credit card?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "explain": "Female refers to gender = 'F'",
        "solution": []
    },
    "349": {
        "sql": "WITH TopArtist AS (\n    SELECT artist, COUNT(DISTINCT uuid) AS card_count\n    FROM cards\n    WHERE isPromo = 1\n    GROUP BY artist\n    ORDER BY card_count DESC\n    LIMIT 1\n)\nSELECT T1.name AS card_name, T1.artist, T1.isPromo AS is_promotional_printing\nFROM cards T1\nJOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = (SELECT artist FROM TopArtist) AND T1.isPromo = 1\nLIMIT 1;",
        "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 AND T1.artist = (SELECT artist FROM cards WHERE isPromo = 1 GROUP BY artist HAVING COUNT(DISTINCT uuid) = (SELECT MAX(count_uuid) FROM ( SELECT COUNT(DISTINCT uuid) AS count_uuid FROM cards WHERE isPromo = 1 GROUP BY artist ))) LIMIT 1",
        "explain": "with the most ruling information refers to Max(count(rulings.uuid)); the card is the promotional printing refers to isPromo = 1;",
        "solution": [
            "To solve the question, we need to find the card and artist with the most ruling information, specifically focusing on promotional printings. Here's the step-by-step breakdown of the operations:\n\n1. **Filter Promotional Cards**: First, we filter the `cards` table to include only those cards where `isPromo` is equal to 1 (indicating they are promotional printings).\n\n2. **Group by Artist**: Next, we group these promotional cards by their `artist` and count the distinct `uuid` values for each artist. This helps us determine how many unique cards each artist has in the promotional category.\n\n3. **Find Maximum Count**: We then identify the maximum count of distinct `uuid` values from the previous step. This represents the artist with the highest number of promotional cards.\n\n4. **Retrieve Artist Details**: Using the maximum count, we retrieve the `artist` who has this count of promotional cards.\n\n5. **Join with Rulings**: We join the `cards` table with the `rulings` table on the `uuid` field to ensure we are only considering cards that have ruling information.\n\n6. **Filter by Artist and Promo**: We further filter the results to include only the cards by the identified artist and ensure they are promotional (`isPromo = 1`).\n\n7. **Limit Results**: Finally, we limit the result to the first record to ensure we get a single output, which represents the card and artist with the most ruling information among promotional printings.\n\nThe SQL query accomplishes all these steps in a single query, ensuring accuracy and efficiency.",
            "To solve the question, we need to identify the card and artist with the most ruling information, specifically focusing on promotional printings. Here's the detailed step-by-step breakdown of the operations:\n\n1. **Filter Promotional Cards**: The query starts by filtering the `cards` table to include only those cards where `isPromo` is equal to 1, indicating they are promotional printings.\n\n2. **Subquery to Identify Top Artist**: A subquery is used to find the artist with the highest number of distinct promotional cards. This is done by:\n   - Grouping the filtered promotional cards by `artist`.\n   - Counting the distinct `uuid` values for each artist.\n   - Identifying the maximum count of distinct `uuid` values among all artists.\n   - Selecting the `artist` who has this maximum count.\n\n3. **Join with Rulings Table**: The main query joins the `cards` table (aliased as `T1`) with the `rulings` table (aliased as `T2`) on the `uuid` field. This ensures that only cards with ruling information are considered.\n\n4. **Filter by Top Artist and Promo**: The joined result is further filtered to include only cards by the artist identified in the subquery and ensure they are promotional (`isPromo = 1`).\n\n5. **Limit Results**: The query limits the result to the first record to ensure a single output, representing the card and artist with the most ruling information among promotional printings.\n\nThe SQL query efficiently combines these steps to provide the desired result."
        ]
    },
    "1400": {
        "sql": "SELECT \n    (COUNT(CASE WHEN type = 'Community Service' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_share\nFROM \n    event\nWHERE \n    strftime('%Y', event_date) = '2019';",
        "question": "Among all events hold by the Student_Club in 2019, find the percentage share of events related to 'Community Service'",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(type) FROM event WHERE SUBSTR(event_date, 1, 4) = '2019'",
        "explain": "DIVIDE(SUM(type = 'Community Service'), COUNT(event_id)) * 100 where event_date BETWEEN' 2019-01-01' and '2019-12-31'",
        "solution": []
    },
    "997": {
        "sql": "SELECT nationality, COUNT(driverId) AS driver_count FROM drivers GROUP BY nationality ORDER BY driver_count DESC LIMIT 1;",
        "question": "Which citizenship do the vast majority of the drivers hold?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1",
        "explain": "Citizenship of majority of drivers = MAX(nationality); citizenship and nationality are synonyms\n\n",
        "solution": [
            "To determine which citizenship the vast majority of the drivers hold, follow these steps:\n\n1. **Retrieve the Nationality Data**: Extract the `nationality` column from the `drivers` table.\n\n2. **Group by Nationality**: Group the drivers by their `nationality` to aggregate them into distinct groups.\n\n3. **Count Drivers per Nationality**: For each nationality group, count the number of drivers using the `driverId` column.\n\n4. **Order by Count in Descending Order**: Sort the nationalities based on the count of drivers in descending order to identify the nationality with the highest number of drivers.\n\n5. **Limit to Top Result**: Select only the top result (the first row) from the ordered list to get the nationality with the highest count of drivers.\n\nThe final output will be the nationality that the vast majority of the drivers hold.",
            "To determine which citizenship the vast majority of the drivers hold, follow these detailed steps:\n\n1. **Select the Nationality Column**: Query the `nationality` column from the `drivers` table to retrieve the citizenship information of all drivers.\n\n2. **Group by Nationality**: Group the retrieved data by the `nationality` column. This step ensures that all drivers with the same nationality are aggregated into a single group.\n\n3. **Count Drivers per Nationality**: For each nationality group, count the number of drivers using the `driverId` column. This count represents the total number of drivers for each nationality.\n\n4. **Order by Count in Descending Order**: Sort the grouped data based on the count of drivers in descending order. This arrangement places the nationality with the highest number of drivers at the top of the list.\n\n5. **Limit to the Top Result**: Restrict the output to only the first row of the sorted list. This row contains the nationality with the highest count of drivers, representing the citizenship held by the vast majority of drivers.\n\nThe final result will display the nationality that the majority of drivers hold, as derived from the `drivers` table."
        ]
    },
    "729": {
        "sql": "SELECT AVG(height_cm) AS average_height\nFROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel Comics';",
        "question": "What is the average height of the superheroes from Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "explain": "superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; average height of the superheroes refers to AVG(height_cm)",
        "solution": []
    },
    "298": {
        "sql": "SELECT (COUNT(DISTINCT CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id END) * 100.0 / COUNT(DISTINCT T2.molecule_id)) AS percentage\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id;",
        "question": "Calculate the percentage of molecules containing carcinogenic compounds that element is hydrogen.",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "explain": "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+' and element = 'h'), COUNT(molecule_id)) * 100.0",
        "solution": [
            "To calculate the percentage of molecules containing carcinogenic compounds where the element is hydrogen, follow these steps:\n\n1. **Join the Tables**: Combine the `atom` table (referred to as `T1`) and the `molecule` table (referred to as `T2`) using the `molecule_id` field as the common key. This ensures that each atom is linked to its corresponding molecule.\n\n2. **Filter for Hydrogen and Carcinogenic Compounds**: From the joined tables, filter the records to include only those where the element is hydrogen (`T1.element = 'h'`) and the molecule is labeled as carcinogenic (`T2.label = '+'`).\n\n3. **Count Relevant Molecules**: Count the number of unique `molecule_id` values that meet the above criteria (hydrogen and carcinogenic). This count represents the number of molecules containing hydrogen and labeled as carcinogenic.\n\n4. **Count Total Molecules**: Count the total number of unique `molecule_id` values in the `molecule` table (`T2`). This represents the total number of molecules being considered.\n\n5. **Calculate the Percentage**: Divide the count of relevant molecules (from step 3) by the total count of molecules (from step 4), then multiply by 100 to convert the result into a percentage. This gives the percentage of molecules containing hydrogen and labeled as carcinogenic.\n\n6. **Output the Result**: The final result is the calculated percentage.",
            "To calculate the percentage of molecules containing carcinogenic compounds where the element is hydrogen, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `atom` table (referred to as `T1`) and the `molecule` table (referred to as `T2`) using the `molecule_id` field as the common key. This ensures that each atom is correctly linked to its corresponding molecule.\n\n2. **Filter for Hydrogen and Carcinogenic Compounds**: From the joined tables, filter the records to include only those where the element is hydrogen (`T1.element = 'h'`) and the molecule is labeled as carcinogenic (`T2.label = '+'`).\n\n3. **Count Relevant Molecules**: Count the number of unique `molecule_id` values that meet the above criteria (hydrogen and carcinogenic). This count is obtained using the `COUNT` function with a `CASE` statement that checks for the conditions `T1.element = 'h'` and `T2.label = '+'`. If the conditions are met, the `molecule_id` is counted; otherwise, it is treated as `NULL` and excluded from the count.\n\n4. **Count Total Molecules**: Count the total number of unique `molecule_id` values in the `molecule` table (`T2`). This represents the total number of molecules being considered.\n\n5. **Calculate the Percentage**: Divide the count of relevant molecules (from step 3) by the total count of molecules (from step 4), then multiply by 100 to convert the result into a percentage. The division is performed using `CAST` to ensure the result is a floating-point number for accurate percentage calculation.\n\n6. **Output the Result**: The final result is the calculated percentage, which is the output of the query."
        ]
    },
    "1040": {
        "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height > 180\nGROUP BY p.id\nORDER BY AVG(pa.heading_accuracy) DESC\nLIMIT 10;",
        "question": "List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 GROUP BY t1.id ORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.`player_fifa_api_id`) DESC LIMIT 10",
        "explain": "heights are above 180 refers to Player.height > 180; average heading accuracy = DIVIDE(SUM(heading_accuracy), COUNT(player_fifa_api_id));",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Select the player names**: Retrieve the names of the players from the `Player` table.\n\n2. **Join with Player_Attributes**: Combine the `Player` table with the `Player_Attributes` table using the `player_api_id` as the common key to access additional player attributes.\n\n3. **Filter by height**: Include only those players whose height is greater than 180.\n\n4. **Group by player ID**: Group the results by the player's unique identifier (`id`) to ensure each player is considered only once.\n\n5. **Calculate average heading accuracy**: For each player, compute the average heading accuracy by summing all their heading accuracy values and dividing by the count of their entries in the `Player_Attributes` table.\n\n6. **Order by average heading accuracy**: Sort the players in descending order based on their calculated average heading accuracy.\n\n7. **Limit the results**: Return only the top 10 players from the sorted list.\n\nThe SQL query accomplishes this by selecting the `player_name` from the `Player` table, joining it with the `Player_Attributes` table, filtering for height, grouping by player ID, ordering by the average heading accuracy, and limiting the output to 10 records."
        ]
    },
    "991": {
        "sql": "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND strftime('%Y', dob) BETWEEN '1981' AND '1991';",
        "question": "What is the full name and date of birth of Austrian drivers born between 1981 and 1991?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'",
        "explain": "Full name refers to forname, surname; Date of birth refers to dob; year(dob) BETWEEN '1981' AND '1991'; Austrian is a nationality",
        "solution": [
            "To solve the question, the database performs the following operations:\n\n1. **Selects** the columns `forename`, `surname`, and `dob` from the `drivers` table.\n2. **Filters** the records to include only those where the `nationality` is 'Austrian'.\n3. Further **filters** the records to include only those where the year extracted from the `dob` (date of birth) column falls between 1981 and 1991, inclusive.\n\nThe result will display the full name (forename and surname) and date of birth of all Austrian drivers born between 1981 and 1991."
        ]
    },
    "693": {
        "sql": "WITH LatestUser AS (\n    SELECT Id, CreationDate\n    FROM users\n    ORDER BY CreationDate DESC\n    LIMIT 1\n)\nSELECT \n    COUNT(DISTINCT T2.Id) AS NumberOfPosts,\n    COUNT(DISTINCT T3.Id) AS NumberOfComments\nFROM \n    LatestUser T1\nLEFT JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId\nLEFT JOIN \n    comments T3 ON T2.Id = T3.PostId;",
        "question": "Identify the number of posts and comments left by the user, who has the latest created user account.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T2.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T3.PostId = T2.Id ORDER BY T1.CreationDate DESC LIMIT 1",
        "explain": "the latest created user account refers to MAX(CreationDate);",
        "solution": [
            "To solve the question, we need to identify the number of posts and comments left by the user who has the latest created user account. Here are the steps to achieve this:\n\n1. **Retrieve the Latest User**: First, we need to find the user with the most recent creation date. This is done by ordering the users by their `CreationDate` in descending order and selecting the top record.\n\n2. **Count Posts by the User**: Next, we count all the posts (`T2.Id`) where the `OwnerUserId` of the posts matches the `Id` of the latest user.\n\n3. **Join with Comments**: We also join the posts with the comments table (`T3`) to ensure we are counting comments associated with the posts of the latest user.\n\n4. **Limit the Result**: Finally, we limit the result to just one record to ensure we only get the count for the latest user.\n\nThe SQL query accomplishes this by:\n- Joining the `users` table (`T1`) with the `posts` table (`T2`) on the condition that the user's `Id` matches the `OwnerUserId` of the posts.\n- Further joining the `posts` table with the `comments` table (`T3`) on the condition that the `PostId` in comments matches the `Id` of the posts.\n- Ordering the results by the user's `CreationDate` in descending order to prioritize the latest user.\n- Limiting the result to 1 to get only the count for the latest user.",
            "To solve the question, we need to identify the number of posts and comments left by the user who has the latest created user account. Here are the detailed steps to achieve this:\n\n1. **Retrieve the Latest User**: \n   - Query the `users` table (aliased as `T1`) to find the user with the most recent `CreationDate`. This is done by ordering the users by `CreationDate` in descending order and selecting the top record.\n\n2. **Count Posts by the User**: \n   - Join the `users` table (`T1`) with the `posts` table (aliased as `T2`) on the condition that the `Id` of the user (`T1.Id`) matches the `OwnerUserId` of the posts (`T2.OwnerUserId`). This ensures we are only considering posts created by the latest user.\n   - Count the number of posts (`T2.Id`) where the `OwnerUserId` matches the `Id` of the latest user.\n\n3. **Include Comments in the Count**: \n   - Further join the `posts` table (`T2`) with the `comments` table (aliased as `T3`) on the condition that the `PostId` in the comments (`T3.PostId`) matches the `Id` of the posts (`T2.Id`). This ensures we are counting comments associated with the posts of the latest user.\n\n4. **Limit the Result**: \n   - Order the results by the user's `CreationDate` in descending order to prioritize the latest user.\n   - Limit the result to 1 to ensure we only get the count for the latest user.\n\nThe SQL query accomplishes this by:\n- Joining the `users` table (`T1`) with the `posts` table (`T2`) on the condition that the user's `Id` matches the `OwnerUserId` of the posts.\n- Joining the `posts` table (`T2`) with the `comments` table (`T3`) on the condition that the `PostId` in comments matches the `Id` of the posts.\n- Ordering the results by the user's `CreationDate` in descending order.\n- Limiting the result to 1 to get only the count for the latest user."
        ]
    },
    "1446": {
        "sql": "SELECT (SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) * 100.0 / COUNT(zip_code)) AS percentage_po_boxes FROM zip_code;",
        "question": "Calculate the percentage of zip codes that are PO boxes.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(zip_code) FROM zip_code",
        "explain": "DIVIDE(SUM(type = 'PO Box'), COUNT(zip_code)) * 100",
        "solution": []
    },
    "421": {
        "sql": "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name ASC LIMIT 3;",
        "question": "Please list top three unknown power cards that have promotional types for arena league in alphabetical order.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3",
        "explain": "unknown power cards refers to power is null or power = '*'; promotional types for arena league refers to promoTypes = 'arenaleague'",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter the cards**: Select all cards where the `power` attribute is either `NULL` or contains an asterisk (`*`). This ensures that only unknown power cards are considered.\n\n2. **Further filter by promotional type**: From the filtered cards, only include those where the `promoTypes` attribute is exactly `'arenaleague'`. This narrows down the cards to those specifically for the arena league.\n\n3. **Sort the results**: Arrange the remaining cards in alphabetical order based on their `name` attribute.\n\n4. **Limit the output**: Return only the top three cards from the sorted list.\n\nThe final output is a list of the names of these three cards."
        ]
    },
    "705": {
        "sql": "SELECT u.Reputation, u.UpVotes\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text = 'fine, you win :)';",
        "question": "Give the user's reputation and up vote number of the user that commented \"fine, you win :)\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Reputation, T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'fine, you win :)'",
        "explain": "Text = 'fine, you win :)';",
        "solution": []
    },
    "678": {
        "sql": "SELECT p.Id, p.Title\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'Harvey Motulsky'\nORDER BY p.ViewCount DESC\nLIMIT 1;",
        "question": "Which post by Harvey Motulsky has the most views? Please give the id and title of this post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Harvey Motulsky' ORDER BY T2.ViewCount DESC LIMIT 1",
        "explain": "DisplayName = 'Harvey Motulsky'; the most views refer to MAX(ViewCount);",
        "solution": []
    },
    "509": {
        "sql": "SELECT s.id\nFROM sets s\nJOIN (\n    SELECT setCode, COUNT(*) AS card_count\n    FROM cards\n    GROUP BY setCode\n) c ON s.code = c.setCode\nORDER BY c.card_count DESC\nLIMIT 1;",
        "question": "What is the unique id of the set that has the highest number of cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM sets ORDER BY baseSetSize DESC LIMIT 1",
        "explain": "the highest number of cards refers to MAX(baseSetSize); unique id refers to id",
        "solution": []
    },
    "885": {
        "sql": "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1;",
        "question": "State the name and date of the last round of race in year 1999.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1",
        "explain": "the last round refers to max(round);",
        "solution": []
    },
    "97": {
        "sql": "SELECT DISTINCT d.client_id\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nWHERE a.frequency = 'POPLATEK PO OBRATU'\nAND d.type = 'DISPONENT';",
        "question": "List out the id number of client who choose statement of issuance after transaction are Disponent?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.client_id FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND T2.type = 'DISPONENT'",
        "explain": "'POPLATEK PO OBRATU' stands for issuance after transaction",
        "solution": [
            "To solve the question, we need to list the client IDs of clients who have chosen a statement of issuance after transactions as 'Disponent'. The solution involves the following steps:\n\n1. **Join the `account` and `disp` tables**: The `account` table contains account information, and the `disp` table contains client and account relationships. We join these tables on the `account_id` field to link accounts with their respective clients.\n\n2. **Filter accounts by frequency**: From the joined tables, we filter accounts where the `frequency` field in the `account` table is set to 'POPLATEK PO OBRATU', which indicates the statement of issuance after transactions.\n\n3. **Filter clients by type**: From the filtered accounts, we further filter clients where the `type` field in the `disp` table is 'DISPONENT', indicating the client is a 'Disponent'.\n\n4. **Select the client IDs**: Finally, we select the `client_id` field from the `disp` table to list the IDs of the clients who meet the criteria.\n\nThe SQL query accomplishes this by performing an inner join between the `account` and `disp` tables, applying the necessary filters, and returning the desired client IDs."
        ]
    },
    "671": {
        "sql": "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Autobiographer'\nORDER BY b.Date ASC\nLIMIT 1;",
        "question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "explain": "Autobiographer is the name of the badge; acquired the first refers to MIN(Date);",
        "solution": []
    },
    "613": {
        "sql": "SELECT b.Date\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Location = 'Rochester, NY';\n",
        "question": "List out the dates that users who are located in Rochester, NY obtained their badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Date FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'Rochester, NY'",
        "explain": "\"Rochester, NY\" is the Location of user; user refers to UserId",
        "solution": []
    },
    "1090": {
        "sql": "SELECT pa.long_passing\nFROM Player_Attributes pa\nJOIN (\n    SELECT player_api_id\n    FROM Player\n    ORDER BY birthday ASC\n    LIMIT 1\n) p ON pa.player_api_id = p.player_api_id\nORDER BY pa.date DESC\nLIMIT 1;",
        "question": "What is the long passing score of the oldest player?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.long_passing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday ASC LIMIT 1",
        "explain": "long passing score refers to long_passing; oldest player refers to oldest birthday;",
        "solution": []
    },
    "1180": {
        "sql": "SELECT p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT = 9 AND l.Date = '1992-06-12';",
        "question": "Was the patient a man or a women whose ALT glutamic pylvic transaminase status got 9 on 1992-6-12?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT = 9.0 AND T2.Date = '1992-06-12'",
        "explain": "man refers to SEX = 'M'; women refers to SEX = 'F'; ALT glutamic pylvic transaminase status got 9 GPT = '9'; 1992/6/12 refers to Date = '1992-06-12'",
        "solution": []
    },
    "641": {
        "sql": "SELECT COUNT(DISTINCT UserId) AS NumberOfUsers\nFROM badges\nWHERE Name = 'Commentator' AND strftime('%Y', Date) = '2014';",
        "question": "How many users received commentator badges in 2014?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'",
        "explain": "Commentator is the name of the badge; year(Date) = 2014;",
        "solution": []
    },
    "107": {
        "sql": "WITH highest_salary_district AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A11 DESC\n    LIMIT 1\n),\naccounts_in_district AS (\n    SELECT account_id\n    FROM account\n    WHERE district_id = (SELECT district_id FROM highest_salary_district)\n),\nclient_accounts AS (\n    SELECT client_id\n    FROM disp\n    WHERE account_id IN (SELECT account_id FROM accounts_in_district) AND type = 'OWNER'\n),\noldest_client AS (\n    SELECT client_id, gender\n    FROM client\n    WHERE client_id IN (SELECT client_id FROM client_accounts)\n    ORDER BY birth_date ASC\n    LIMIT 1\n)\nSELECT gender\nFROM oldest_client;",
        "question": "What is the gender of the oldest client who opened his/her account in the highest average salary branch?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.gender FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id ORDER BY T1.A11 DESC, T2.birth_date ASC LIMIT 1",
        "explain": "Earlier birthdate refers to older age; A11 refers to average salary",
        "solution": []
    },
    "1058": {
        "sql": "WITH TallestPlayers AS (\n    SELECT p.player_api_id, p.height\n    FROM Player p\n    WHERE p.height = (SELECT MAX(height) FROM Player)\n),\nShortestPlayers AS (\n    SELECT p.player_api_id, p.height\n    FROM Player p\n    WHERE p.height = (SELECT MIN(height) FROM Player)\n),\nAvgFinishingTallest AS (\n    SELECT 'Max' AS category, AVG(pa.finishing) AS avg_finishing\n    FROM TallestPlayers tp\n    JOIN Player_Attributes pa ON tp.player_api_id = pa.player_api_id\n),\nAvgFinishingShortest AS (\n    SELECT 'Min' AS category, AVG(pa.finishing) AS avg_finishing\n    FROM ShortestPlayers sp\n    JOIN Player_Attributes pa ON sp.player_api_id = pa.player_api_id\n)\nSELECT category, avg_finishing\nFROM (\n    SELECT * FROM AvgFinishingTallest\n    UNION\n    SELECT * FROM AvgFinishingShortest\n)\nORDER BY avg_finishing DESC\nLIMIT 1;",
        "error": "something went wrong, tool did not call.",
        "question": "Who has the highest average finishing rate between the highest and shortest football player?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM Player ) UNION SELECT AVG(finishing) result, 'Min' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM Player ) ) ORDER BY result DESC LIMIT 1",
        "explain": "finishing rate refers to finishing; highest average finishing rate = MAX(AVG(finishing)); highest football player refers to MAX(height); shortest football player refers to MIN(height);",
        "solution": [
            "To determine who has the highest average finishing rate between the tallest and shortest football players, follow these steps:\n\n1. **Identify the tallest player(s):**\n   - Find the maximum height from the `Player` table.\n   - Retrieve all players who have this maximum height.\n\n2. **Calculate the average finishing rate for the tallest players:**\n   - Join the `Player` table with the `Player_Attributes` table using the `player_api_id`.\n   - Filter the joined data to include only the tallest players.\n   - Compute the average of the `finishing` attribute for these players.\n   - Label this result as 'Max'.\n\n3. **Identify the shortest player(s):**\n   - Find the minimum height from the `Player` table.\n   - Retrieve all players who have this minimum height.\n\n4. **Calculate the average finishing rate for the shortest players:**\n   - Join the `Player` table with the `Player_Attributes` table using the `player_api_id`.\n   - Filter the joined data to include only the shortest players.\n   - Compute the average of the `finishing` attribute for these players.\n   - Label this result as 'Min'.\n\n5. **Combine the results:**\n   - Use a `UNION` operation to combine the average finishing rates for the tallest and shortest players.\n\n6. **Determine the highest average finishing rate:**\n   - Order the combined results by the average finishing rate in descending order.\n   - Select the top result to identify whether the tallest ('Max') or shortest ('Min') players have the higher average finishing rate.\n\nThis process ensures that the solution accurately reflects the SQL query and can be converted back to the original SQL without any loss of information.",
            "To determine who has the highest average finishing rate between the tallest and shortest football players, follow these steps:\n\n1. **Identify the tallest player(s):**\n   - Query the `Player` table to find the maximum height value.\n   - Retrieve all players from the `Player` table whose height matches this maximum value.\n\n2. **Calculate the average finishing rate for the tallest players:**\n   - Perform an inner join between the `Player` table and the `Player_Attributes` table using the `player_api_id` as the join key.\n   - Filter the joined dataset to include only the tallest players identified in step 1.\n   - Compute the average of the `finishing` attribute from the `Player_Attributes` table for these players.\n   - Label this result as 'Max'.\n\n3. **Identify the shortest player(s):**\n   - Query the `Player` table to find the minimum height value.\n   - Retrieve all players from the `Player` table whose height matches this minimum value.\n\n4. **Calculate the average finishing rate for the shortest players:**\n   - Perform an inner join between the `Player` table and the `Player_Attributes` table using the `player_api_id` as the join key.\n   - Filter the joined dataset to include only the shortest players identified in step 3.\n   - Compute the average of the `finishing` attribute from the `Player_Attributes` table for these players.\n   - Label this result as 'Min'.\n\n5. **Combine the results:**\n   - Use a `UNION` operation to merge the average finishing rates for the tallest and shortest players into a single dataset.\n\n6. **Determine the highest average finishing rate:**\n   - Sort the combined dataset by the average finishing rate in descending order.\n   - Select the top entry from the sorted dataset to determine whether the tallest ('Max') or shortest ('Min') players have the higher average finishing rate.\n\nThis detailed solution ensures that the operations mirror the SQL query exactly and can be converted back to the original SQL without any loss of information."
        ]
    },
    "1332": {
        "sql": "SELECT SUM(b.spent) AS total_spent_on_food\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'September Meeting' AND b.category = 'Food';",
        "question": "How much did the Student_Club members spend on food in September Meeting?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Food' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "explain": "amount spent refers to spent; spend on food in September Meeting refers to category = 'Food' where event_name = 'September Meeting'",
        "solution": []
    },
    "516": {
        "sql": "SELECT COUNT(DISTINCT c.id) \nFROM cards c \nJOIN foreign_data fd ON c.uuid = fd.uuid \nWHERE c.artist = 'Volkan Ba\u01f5a' AND fd.language = 'French';",
        "question": "How many cards did Volkan Ba\u00c7\u00b5a illustrated whose foreign language is in French?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.id) FROM ( SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Ba\u01f5a' AND T2.language = 'French' GROUP BY T1.id ) AS T3",
        "explain": "Volkan Ba\u00c7\u00b5a refers to artist = 'Volkan Ba\u01f5a'; foreign language is in French refers to language = 'French'",
        "solution": []
    },
    "496": {
        "sql": "SELECT s.baseSetSize\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.translation = 'Rinascita di Alara';",
        "question": "What is the number of cards are there in the set of \"Rinascita di Alara\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Rinascita di Alara'",
        "explain": "number of cards refers to baseSetSize; set of \"Rinascita di Alara\" refers to translation = 'Rinascita di Alara'",
        "solution": []
    },
    "1063": {
        "sql": "SELECT t2.potential FROM Player t1 INNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran';",
        "question": "What is Aaron Doran's potential score?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
        "explain": "potential score refers to potential;",
        "solution": [
            "To find Aaron Doran's potential score, follow these steps:\n1. Access the database tables `Player` and `Player_Attributes`.\n2. Join the two tables using the common field `player_api_id` to link the player's information with their attributes.\n3. Filter the records to only include the player named 'Aaron Doran'.\n4. From the filtered result, retrieve the value in the `potential` column, which represents Aaron Doran's potential score.",
            "To determine Aaron Doran's potential score, execute the following steps:\n1. **Access the database tables**: Identify and access the `Player` table (aliased as `t1`) and the `Player_Attributes` table (aliased as `t2`).\n2. **Join the tables**: Perform an inner join between `Player` (`t1`) and `Player_Attributes` (`t2`) using the common field `player_api_id` to link the player's basic information with their detailed attributes.\n3. **Filter the player**: Apply a filter condition to the joined tables to isolate the record where the `player_name` in the `Player` table (`t1`) matches the name 'Aaron Doran'.\n4. **Retrieve the potential score**: From the filtered result, extract the value in the `potential` column of the `Player_Attributes` table (`t2`), which represents Aaron Doran's potential score.\n\nThis process ensures that the query accurately retrieves the potential score for the specified player without altering any information from the original SQL."
        ]
    },
    "655": {
        "sql": "SELECT p.Title, pl.LinkTypeId\nFROM postLinks pl\nJOIN posts p ON pl.RelatedPostId = p.Id\nWHERE pl.PostId = (SELECT Id FROM posts WHERE Title = 'What are principal component scores?');",
        "question": "Write down the related posts titles and link type IDs of the post \"What are principal component scores?\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Title, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId INNER JOIN posts AS T3 ON T2.RelatedPostId = T3.Id WHERE T1.Title = 'What are principal component scores?'",
        "explain": "Title = 'What are principal component scores?';",
        "solution": []
    },
    "713": {
        "sql": "SELECT u.UpVotes\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text = 'R is also lazy evaluated.';",
        "question": "What is the up vote number of the user that commented \"R is also lazy evaluated.\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'R is also lazy evaluated.'",
        "explain": "commented \"R is also lazy evaluated.\" refers to Text of the comment;",
        "solution": []
    },
    "335": {
        "sql": "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM atom T1 \nINNER JOIN bond T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.bond_type = '=' AND T1.element = 'o';",
        "question": "What is the total number of molecules with double bonded oxygen?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '=' AND T1.element = 'o'",
        "explain": "oxygen refers to element = 'o'; double bond refers to bond_type = ' = ';",
        "solution": [
            "To find the total number of molecules with double-bonded oxygen, follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in the `atom` table (aliased as `T1`) and the `bond` table (aliased as `T2`).\n\n2. **Join the tables**: Combine the `atom` and `bond` tables using the `molecule_id` field to link atoms to their corresponding bonds.\n\n3. **Filter for double bonds and oxygen atoms**: Apply the following conditions:\n   - The bond type must be a double bond (`bond_type = '='`).\n   - The atom must be an oxygen atom (`element = 'o'`).\n\n4. **Count distinct molecules**: Count the unique `molecule_id` values that meet the above conditions to determine the total number of molecules with double-bonded oxygen.\n\nThe result will be the count of distinct molecules where at least one oxygen atom is involved in a double bond.",
            "To determine the total number of molecules that contain at least one oxygen atom involved in a double bond, execute the following steps:\n\n1. **Table Identification**: Identify the tables involved in the query. The `atom` table (aliased as `T1`) contains information about atoms, and the `bond` table (aliased as `T2`) contains information about bonds between atoms.\n\n2. **Table Join**: Perform an inner join between the `atom` table (`T1`) and the `bond` table (`T2`) using the `molecule_id` field. This links each atom to its corresponding bonds within the same molecule.\n\n3. **Filtering Conditions**: Apply the following filters to the joined tables:\n   - **Bond Type**: Ensure the bond is a double bond by checking `T2.bond_type = '='`.\n   - **Atom Element**: Ensure the atom is oxygen by checking `T1.element = 'o'`.\n\n4. **Count Distinct Molecules**: Count the distinct `molecule_id` values from the filtered results. This ensures each molecule is counted only once, regardless of how many double-bonded oxygen atoms it contains.\n\nThe final result is the count of unique molecules that satisfy the conditions of having at least one oxygen atom involved in a double bond."
        ]
    },
    "816": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nWHERE ha.attribute_value BETWEEN 75 AND 80;",
        "question": "Provide the names of superheroes with attribute value between 75 to 80.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T2.attribute_value BETWEEN 75 AND 80",
        "explain": "names of superheroes refers to superhero_name; attribute value between 75 to 80 refers to attribute_value BETWEEN 75 AND 80;",
        "solution": []
    },
    "1122": {
        "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes);",
        "question": "State the name of the most strongest player.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)",
        "explain": "strongest players refers to player has MAX(overall_rating)",
        "solution": []
    },
    "1344": {
        "sql": "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14';",
        "question": "What was the notes of the fundraising on 2019/9/14?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'",
        "explain": "fundraising on 2019/9/14 refers to source = 'Fundraising' where date_received = '2019-09-14'",
        "solution": []
    },
    "770": {
        "sql": "SELECT c.colour \nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.full_name = 'Abraham Sapien';",
        "question": "What is the eyes colour of Abraham Sapien?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Abraham Sapien'",
        "explain": "eye colour refers to colour.colour where eye_colour_id = colour.id; Abraham Sapien is the full name of superhero;",
        "solution": []
    },
    "1158": {
        "sql": "SELECT DISTINCT T1.ID\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE strftime('%Y', T1.Birthday) = '1937' AND T2.\"T-CHO\" >= 250;",
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "explain": "who were born in 1937 refers to year(birthday) = '1937'; total cholesterol was beyond the normal range refers to `T-CHO` > = '250'",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Identify Patients Born in 1937**:\n   - Access the `Patient` table (referred to as `T1` in the SQL).\n   - Filter the records to include only those patients whose birth year is 1937. This is done by extracting the year from the `Birthday` column and comparing it to '1937'.\n\n2. **Check Cholesterol Levels**:\n   - Join the filtered `Patient` table (`T1`) with the `Laboratory` table (referred to as `T2` in the SQL) using the `ID` column as the common key.\n   - From the `Laboratory` table, check the `T-CHO` column (total cholesterol) for each patient.\n   - Include only those patients whose `T-CHO` value is 250 or higher (indicating cholesterol beyond the normal range).\n\n3. **Return Unique Patient IDs**:\n   - Ensure the results are distinct to avoid duplicate entries for the same patient.\n   - Return the `ID` column from the `Patient` table for the final list of patients.\n\nThis process ensures that only patients born in 1937 with elevated cholesterol levels are listed."
        ]
    },
    "321": {
        "sql": "SELECT DISTINCT T1.molecule_id FROM bond T1 JOIN connected T2 ON T1.bond_id = T2.bond_id WHERE (T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4') OR (T2.atom_id = 'TR000_4' AND T2.atom_id2 = 'TR000_2');",
        "question": "What is the molecule of atom id \"TR000_2\" and atom id 2 \"TR000_4\"?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'",
        "explain": "",
        "solution": [
            "To find the molecule that contains both the atom with ID \"TR000_2\" and the atom with ID \"TR000_4\", follow these steps:\n\n1. **Identify the bond records**: Start by examining the `bond` table (referred to as `T1` in the SQL). This table contains information about bonds between atoms.\n\n2. **Join with the connected table**: The `connected` table (referred to as `T2` in the SQL) contains details about which atoms are connected by which bonds. Join the `bond` table (`T1`) with the `connected` table (`T2`) using the `bond_id` field, which is common to both tables.\n\n3. **Filter for the specific atoms**: Within the joined data, filter for records where:\n   - The `atom_id` field in the `connected` table (`T2`) is equal to \"TR000_2\".\n   - The `atom_id2` field in the `connected` table (`T2`) is equal to \"TR000_4\".\n\n4. **Retrieve the molecule ID**: From the filtered records, select the `molecule_id` field from the `bond` table (`T1`). This will give you the ID of the molecule that contains both the specified atoms.\n\nThis process ensures that you are identifying the molecule where the atoms \"TR000_2\" and \"TR000_4\" are connected by a bond."
        ]
    },
    "614": {
        "sql": "SELECT \n    (COUNT(DISTINCT b.UserId) * 100.0 / NULLIF(COUNT(DISTINCT u.Id), 0)) AS percentage_teacher_badge_users\nFROM \n    users u\nLEFT JOIN \n    badges b ON u.Id = b.UserId AND b.Name = 'Teacher';",
        "question": "Among the users who obtained the \"Teacher\" badge, calculate their percentage of users",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) * 100 / (SELECT COUNT(Id) FROM users) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Teacher'",
        "explain": "\"Teacher\" is the Name of badge;  percentage = Divide (Count(UserId where it's \"Teacher\"), Count(UserId)) * 100",
        "solution": []
    },
    "255": {
        "sql": "SELECT \n    ROUND((SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100.0) / COUNT(b.bond_id), 5) AS proportion\nFROM \n    bond b\nJOIN \n    molecule m ON b.molecule_id = m.molecule_id\nWHERE \n    b.bond_type = '-';",
        "question": "What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id),5) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'",
        "explain": "single bond refers to bond_type = '-'; label = '+' mean molecules are carcinogenic; proportion = DIVIDE(SUM(label = '+') * 100, COUNT(bond_id)) where bond_type = '-'",
        "solution": []
    },
    "102": {
        "sql": "SELECT DISTINCT t1.account_id\nFROM trans t1\nJOIN account t2 ON t1.account_id = t2.account_id\nWHERE strftime('%Y', t2.date) < '1997'\nAND t1.amount > 3000;",
        "question": "State different accounts who have account opening date before 1997 and own an amount of money greater than 3000USD",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) < '1997' AND T1.amount > 3000",
        "explain": "",
        "solution": [
            "To solve the question, we need to find distinct account IDs from the database where the account opening date is before the year 1997 and the account has a transaction amount greater than 3000 USD. Here are the steps:\n\n1. **Join the Tables**: Combine the `trans` table (T1) and the `account` table (T2) using the `account_id` field to link them.\n\n2. **Filter by Date**: From the joined data, filter out records where the year part of the `date` field in the `account` table (T2) is before 1997.\n\n3. **Filter by Amount**: Further filter the results to include only those records where the `amount` field in the `trans` table (T1) is greater than 3000.\n\n4. **Select Distinct Account IDs**: Finally, retrieve only the distinct `account_id` values from the filtered results to ensure each account is listed only once.\n\nThis process ensures that we identify all unique accounts that meet both the date and amount criteria specified in the question."
        ]
    },
    "875": {
        "sql": "SELECT s.url\nFROM seasons s\nJOIN races r ON s.year = r.year\nWHERE r.raceId = 901;",
        "question": "Show me the season page of year when the race No. 901 took place.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "explain": "the season page refers to url; race number refers to raceId;",
        "solution": []
    },
    "1320": {
        "sql": "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN member m ON a.link_to_member = m.member_id\nWHERE m.first_name = 'Maya' AND m.last_name = 'Mclean';",
        "question": "Please list the event names of all the events attended by Maya Mclean.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean'",
        "explain": "",
        "solution": []
    },
    "370": {
        "sql": "SELECT COUNT(DISTINCT c.id) \nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.borderColor = 'borderless' AND fd.language = 'Russian';",
        "question": "How many borderless cards are illustrated in Russian?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.borderColor = 'borderless' AND T2.language = 'Russian'",
        "explain": "borderless card refers to borderColor = 'borderless'; 'Russian' is the language;",
        "solution": []
    },
    "142": {
        "sql": "SELECT DISTINCT T2.account_id\nFROM trans T1\nJOIN account T2 ON T1.account_id = T2.account_id\nJOIN district T3 ON T2.district_id = T3.district_id\nWHERE T1.k_symbol = 'SIPO' AND T3.A2 = 'Pisek';",
        "question": "Which accounts placed orders for household payment in Pisek?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.k_symbol = 'SIPO' AND T3.A2 = 'Pisek'",
        "explain": "k_symbol = 'SIPO' refers to household payment",
        "solution": [
            "To find the accounts that placed orders for household payments in Pisek, follow these steps:\n\n1. **Join the tables**: \n   - Start by joining the `trans` table (aliased as `T1`) with the `account` table (aliased as `T2`) using the `account_id` field. This links each transaction to its corresponding account.\n   - Next, join the `account` table (`T2`) with the `district` table (aliased as `T3`) using the `district_id` field. This links each account to its corresponding district.\n\n2. **Filter the data**: \n   - Apply a filter to the `trans` table (`T1`) to only include transactions where the `k_symbol` field is 'SIPO', which represents household payments.\n   - Apply another filter to the `district` table (`T3`) to only include records where the `A2` field is 'Pisek', ensuring the accounts are from the Pisek district.\n\n3. **Retrieve the results**: \n   - Select the distinct `account_id` values from the `account` table (`T2`) to ensure each account is listed only once, even if it has multiple transactions.\n\nThis process will return a list of unique account IDs that placed household payment orders in Pisek."
        ]
    },
    "1228": {
        "sql": "SELECT p.ID, p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TG > 300;",
        "question": "Provide list of patients and their diagnosis with triglyceride (TG) index greater than 100 of the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG > 300",
        "explain": "triglyceride (TG) index greater than 100 of the normal range refers to TG > 300;",
        "solution": []
    },
    "74": {
        "sql": "SELECT frpm.\"Low Grade\"\nFROM schools\nJOIN frpm ON schools.CDSCode = frpm.CDSCode\nWHERE schools.NCESDist = '0613360' AND schools.EdOpsCode = 'SPECON';",
        "question": "What is the lowest grade for the District Special Education Consortia School with National Center for Educational Statistics school district identification number of 0613360?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT MIN(T1.`Low Grade`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.NCESDist = '0613360' AND T2.EdOpsCode = 'SPECON'",
        "explain": "District Special Education Consortia School refers to EdOpsCode = 'SPECON'.",
        "solution": []
    },
    "552": {
        "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'csgillespie';",
        "question": "Please list the names of the badges obtained by csgillespie.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "explain": "\"csgillespie\" is the DisplayName of user",
        "solution": []
    },
    "538": {
        "sql": "SELECT p.Title \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE u.DisplayName = 'csgillespie';",
        "question": "Please list the titles of the posts owned by the user csgillespie?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "explain": "\"csgillespie\" is the DisplayName of user",
        "solution": []
    },
    "118": {
        "sql": "SELECT \n    (COUNT(CASE WHEN l.status = 'C' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    loan l\nJOIN \n    account a ON l.account_id = a.account_id\nWHERE \n    l.amount < 100000;",
        "question": "For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) FROM loan WHERE amount < 100000",
        "explain": "Status = 'C' stands for running contract, ok so far; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100.",
        "solution": []
    },
    "736": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Intelligence'\nORDER BY ha.attribute_value ASC\nLIMIT 1;",
        "question": "Who is the dumbest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' ORDER BY T2.attribute_value LIMIT 1",
        "explain": "the dumbest superhero refers to MIN(attribute_value) where attribute_name = 'Intelligence'",
        "solution": []
    },
    "1325": {
        "sql": "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1;",
        "question": "What is the most expensive item that was spent in support of club events?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1",
        "explain": "item in support of club events refers to expense_description; most expensive refers to MAX(cost)",
        "solution": [
            "To find the most expensive item that was spent in support of club events, you need to retrieve the expense description from the expense table. The steps are as follows:\n\n1. Access the expense table.\n2. Sort all the entries in the table by the cost column in descending order (from highest to lowest).\n3. Select the top entry (the first one in the sorted list) to get the most expensive item.\n4. Retrieve the expense_description of this item.\n\nThis will give you the description of the most expensive item spent on club events."
        ]
    },
    "195": {
        "sql": "SELECT bond_type FROM (SELECT bond_type, COUNT(bond_id) AS count FROM bond GROUP BY bond_type ORDER BY count DESC LIMIT 1);",
        "question": "What is the most common bond type?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_type FROM ( SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1 ) AS T",
        "explain": "most common bond type refers MAX(COUNT(bond_type))",
        "solution": [
            "To determine the most common bond type, follow these steps:\n1. **Group the data**: Group all records in the `bond` table by the `bond_type` column.\n2. **Count occurrences**: For each group (i.e., each unique `bond_type`), count the number of `bond_id` entries.\n3. **Sort by count**: Order the groups in descending order based on the count of `bond_id` entries. This places the bond type with the highest count at the top.\n4. **Limit results**: Retrieve only the top result (the bond type with the highest count).\n5. **Select the bond type**: Extract the `bond_type` from the result.\n\nThis process ensures that the most common bond type is identified and returned.",
            "To determine the most common bond type, follow these detailed steps:\n\n1. **Subquery Execution**: Begin by executing a subquery that processes the `bond` table.\n   - **Grouping**: Group all records in the `bond` table by the `bond_type` column. This creates distinct groups for each unique bond type.\n   - **Counting**: For each group (i.e., each unique `bond_type`), count the number of `bond_id` entries. This count represents the frequency of each bond type.\n   - **Sorting**: Order the groups in descending order based on the count of `bond_id` entries. This ensures the bond type with the highest count appears first.\n   - **Limiting**: Retrieve only the top result (the bond type with the highest count) by applying a `LIMIT 1` clause.\n\n2. **Main Query Execution**: The outer query selects the `bond_type` from the result of the subquery. This extracts the most common bond type identified in the subquery.\n\nThe SQL query ensures that the most common bond type is accurately identified and returned by aggregating, counting, sorting, and limiting the results."
        ]
    },
    "407": {
        "sql": "SELECT DISTINCT T1.subtypes, T1.supertypes\nFROM cards T1\nJOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T2.language = 'German'\nAND T1.subtypes IS NOT NULL\nAND T1.supertypes IS NOT NULL;",
        "question": "Lists all types of cards in German.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.subtypes, T1.supertypes FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.subtypes IS NOT NULL AND T1.supertypes IS NOT NULL",
        "explain": "German refer to language; all types refer to the subtypes, supertypes; subtypes is not null AND supertypes is not null",
        "solution": [
            "To list all types of cards in German, the following operations are performed:\n\n1. **Select Data**: Retrieve the `subtypes` and `supertypes` columns from the `cards` table (aliased as `T1`).\n2. **Join Tables**: Join the `cards` table (`T1`) with the `foreign_data` table (aliased as `T2`) using the `uuid` column as the common key.\n3. **Filter by Language**: Apply a filter to include only records where the `language` column in the `foreign_data` table (`T2`) is set to 'German'.\n4. **Exclude Null Values**: Ensure that the `subtypes` and `supertypes` columns in the `cards` table (`T1`) are not null.\n\nThis sequence of operations ensures that only the relevant card types (subtypes and supertypes) in German are listed."
        ]
    },
    "302": {
        "sql": "SELECT DISTINCT T1.element FROM atom T1 JOIN connected T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_2_4';",
        "question": "Name the elements that comprise the atoms of bond TR001_2_4.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_2_4'",
        "explain": "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "solution": [
            "To solve the question \"Name the elements that comprise the atoms of bond TR001_2_4,\" the following steps are performed:\n\n1. **Select Distinct Elements**: Retrieve only unique elements from the result to avoid duplicates.\n2. **Join Tables**: Combine the `atom` table (aliased as T1) with the `connected` table (aliased as T2) using the `atom_id` field as the joining condition.\n3. **Filter by Bond ID**: Apply a filter to only include records where the `bond_id` in the `connected` table matches 'TR001_2_4'.\n4. **Output the Result**: Display the `element` column from the `atom` table for the filtered records.\n\nThis operation ensures that all elements involved in the bond TR001_2_4 are listed without repetition."
        ]
    },
    "219": {
        "sql": "SELECT (COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id END) * 100.0 / COUNT(DISTINCT T2.molecule_id)) AS percentage_carcinogenic\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nJOIN bond T3 ON T1.molecule_id = T3.molecule_id\nWHERE T3.bond_type = '#';",
        "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
        "explain": "label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(bond_type = '#') * 100, COUNT(bond_id)) as percent where label = '+'",
        "solution": [
            "To determine the percentage of carcinogenic molecules in triple type bonds, follow these steps:\n\n1. **Join the Tables**: Combine the `atom` table (T1), `molecule` table (T2), and `bond` table (T3) by matching the `molecule_id` in each table.\n\n2. **Filter for Triple Bonds**: From the joined tables, filter the records to include only those where the `bond_type` in the `bond` table (T3) is `#` (indicating a triple bond).\n\n3. **Count Carcinogenic Molecules**: Among the filtered records, count the distinct `molecule_id` values from the `molecule` table (T2) where the `label` is `+` (indicating a carcinogenic molecule).\n\n4. **Count Total Molecules**: Count all distinct `molecule_id` values from the `molecule` table (T2) in the filtered records.\n\n5. **Calculate the Percentage**: Divide the count of carcinogenic molecules by the total count of molecules and multiply by 100 to get the percentage.\n\nThe result will be the percentage of carcinogenic molecules among those with triple bonds."
        ]
    },
    "519": {
        "sql": "SELECT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.name = 'Battlebond';",
        "question": "What is the language of the \"Battlebond\" set?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM sets WHERE name = 'Battlebond' )",
        "explain": "\"Battlebond\" set refers to name = 'Battlebond'",
        "solution": [
            "To find the language of the \"Battlebond\" set, follow these steps:\n1. First, locate the set with the name \"Battlebond\" in the `sets` table and retrieve its `id`.\n2. Then, use this `id` to query the `set_translations` table and retrieve the `language` associated with the \"Battlebond\" set.\n\nThe SQL query accomplishes this by:\n- Using a subquery to find the `id` of the \"Battlebond\" set from the `sets` table.\n- Using this `id` to fetch the corresponding `language` from the `set_translations` table.",
            "To determine the language of the \"Battlebond\" set, the following steps are executed:\n\n1. **Identify the Set ID**: The system first queries the `sets` table to locate the record where the `name` column matches the value \"Battlebond\". From this record, the `id` column is retrieved. This `id` uniquely identifies the \"Battlebond\" set in the database.\n\n2. **Retrieve the Language**: Using the `id` obtained from the previous step, the system then queries the `set_translations` table. It searches for the record where the `id` column matches the `id` of the \"Battlebond\" set. From this record, the `language` column is retrieved, which contains the language information for the \"Battlebond\" set.\n\nThe SQL query combines these steps into a single operation:\n- A subquery is used to fetch the `id` of the \"Battlebond\" set from the `sets` table.\n- The main query uses this `id` to fetch the corresponding `language` from the `set_translations` table."
        ]
    },
    "501": {
        "sql": "SELECT c.name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Journey into Nyx Hero''s Path'\nORDER BY c.convertedManaCost DESC\nLIMIT 1;",
        "question": "Which card name in the set 'Journey into Nyx Hero's Path' has the highest converted mana cost.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Journey into Nyx Hero''s Path' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "explain": "set 'Journey into Nyx Hero's Path' refers to name = 'Journey into Nyx Hero''s Path'",
        "solution": []
    },
    "420": {
        "sql": "SELECT COUNT(*) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1;",
        "question": "How many cards are oversized, reprinted, and printed for promotions?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1",
        "explain": "are oversized refers to isOversized = 1; reprinted refers to isReprint = 1; printed for promotions refers to isPromo = 1",
        "solution": []
    },
    "1097": {
        "sql": "SELECT SUM(pa.crossing) AS total_crossing_score\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Aaron Lennox';",
        "question": "What is Aaron Lennox's total crossing score?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.crossing) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Lennox'",
        "explain": "Aaron Lennox's refers to T2.player_name = 'Aaron Lennox'; total crossing score refers to SUM(crossing)",
        "solution": []
    },
    "71": {
        "sql": "SELECT f.`District Code`\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.City = 'Fresno' AND s.Magnet != 1;",
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "explain": "When magent is equal to 0 in the database, it means ths school doesn't offer a magnet program.",
        "solution": []
    },
    "1405": {
        "sql": "SELECT b.category, b.amount\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'April Speaker'\nORDER BY b.amount ASC;",
        "question": "Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category, SUM(T2.amount) FROM event AS T1 JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'April Speaker' GROUP BY T2.category ORDER BY SUM(T2.amount) ASC",
        "explain": "'April Speaker' is an event name; amount budgeted refers to SUM(amount); budget categories refers to category",
        "solution": []
    },
    "899": {
        "sql": "SELECT c.name\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nWHERE strftime('%Y', r.date) BETWEEN '1990' AND '2000'\nGROUP BY c.name\nHAVING COUNT(r.raceId) = 4;",
        "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
        "explain": "from year 1990 to 2000 refers to year(date) between 1990 and 2000;",
        "solution": [
            "To solve the question of listing circuits that hosted exactly 4 Formula 1 races between the years 1990 and 2000, the following steps are performed:\n\n1. **Select Distinct Circuit Names**: The query starts by selecting distinct names from the `circuits` table to ensure each circuit is listed only once.\n\n2. **Join with Races Table**: The `circuits` table is joined with the `races` table using the `circuitID` field to link circuits to their respective races.\n\n3. **Filter Races by Year**: The query filters the races to include only those that occurred between the years 1990 and 2000. This is done by extracting the year from the `date` field in the `races` table and checking if it falls within the specified range.\n\n4. **Group by Circuit Name**: The results are grouped by the circuit name to aggregate the data for each circuit.\n\n5. **Count Races per Circuit**: The query counts the number of races (`raceId`) for each circuit and checks if the count is exactly 4.\n\n6. **Return Matching Circuits**: Only circuits that meet the condition of hosting exactly 4 races within the specified years are included in the final result.\n\nThis process ensures that the output is a list of circuits that hosted exactly 4 Formula 1 races between 1990 and 2000."
        ]
    },
    "436": {
        "sql": "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id;",
        "question": "How many cards have frame effect as extendedart? List out the id of those cards.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id",
        "explain": "\nframe effect as extendedart refers to frameEffects = 'extendedart'\n",
        "solution": [
            "To find out how many cards have the frame effect 'extendedart' and list their IDs, follow these steps:\n\n1. **Access the 'cards' table**: This table contains information about all the cards.\n2. **Filter the records**: Select only those cards where the 'frameEffects' column has the value 'extendedart'.\n3. **Group the results by ID**: Ensure that each card ID is listed only once, even if there are multiple entries for the same card.\n4. **Retrieve the IDs**: Extract the 'id' column from the filtered and grouped records.\n\nThe result will be a list of unique card IDs that have the 'extendedart' frame effect."
        ]
    },
    "98": {
        "sql": "SELECT T1.account_id\nFROM loan T1\nJOIN account T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1997'\nAND T2.frequency = 'POPLATEK TYDNE'\nORDER BY T1.amount ASC\nLIMIT 1;",
        "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
        "explain": "'POPLATEK TYDNE' stands for weekly issuance",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Join the Tables**: Combine the `loan` table (referred to as `T1`) and the `account` table (referred to as `T2`) using the `account_id` field. This ensures that we have both loan and account information for each account.\n\n2. **Filter by Year**: From the joined data, filter out only those records where the loan's approval date (`T1.date`) falls in the year 1997. This is done using the `STRFTIME` function to extract the year from the date and compare it to '1997'.\n\n3. **Filter by Frequency**: Further filter the results to include only those accounts where the issuance frequency (`T2.frequency`) is 'POPLATEK TYDNE', which translates to 'weekly issuance statement'.\n\n4. **Sort by Amount**: Sort the remaining records by the loan amount (`T1.amount`) in ascending order. This ensures that the account with the lowest approved loan amount appears first.\n\n5. **Select the Top Record**: Use the `LIMIT 1` clause to select only the first record from the sorted list, which corresponds to the account with the lowest approved loan amount in 1997 and a weekly issuance statement.\n\n6. **Output the Result**: Finally, retrieve the `account_id` from the selected record to answer the question."
        ]
    },
    "158": {
        "sql": "SELECT a.district_id\nFROM account a\nJOIN `order` o ON a.account_id = o.account_id\nWHERE o.order_id = 33333;",
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "explain": "",
        "solution": []
    },
    "1472": {
        "sql": "SELECT T1.CustomerID\nFROM customers T1\nJOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;",
        "question": "In 2012, who had the least consumption in LAM?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "explain": "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year.",
        "solution": [
            "To find out who had the least consumption in the LAM segment in 2012, follow these steps:\n\n1. **Join the Tables**: Combine the `customers` table (aliased as `T1`) with the `yearmonth` table (aliased as `T2`) using the `CustomerID` field to link them.\n\n2. **Filter by Segment and Year**: From the joined tables, filter the records to include only those where:\n   - The `Segment` field in the `customers` table is 'LAM'.\n   - The first four characters of the `Date` field in the `yearmonth` table (representing the year) are '2012'.\n\n3. **Group by Customer**: Group the filtered records by the `CustomerID` field to aggregate the data for each customer.\n\n4. **Calculate Total Consumption**: For each customer, calculate the sum of the `Consumption` values from the `yearmonth` table.\n\n5. **Order by Consumption**: Sort the grouped results in ascending order based on the total consumption calculated in the previous step. This ensures the customer with the least consumption appears first.\n\n6. **Limit Results**: Return only the top result (the customer with the least consumption) by applying a limit of 1.\n\nThe final output will be the `CustomerID` of the customer in the LAM segment with the least consumption in 2012."
        ]
    },
    "216": {
        "sql": "SELECT T2.atom_id, T2.atom_id2 FROM bond T1 JOIN connected T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#';",
        "question": "Identify all connected atoms with a triple bond.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "explain": "triple bond refers to bond_type = '#';",
        "solution": [
            "To identify all connected atoms with a triple bond, perform the following steps:\n\n1. **Filter Bonds by Type**: First, filter the `bond` table to include only those bonds where the `bond_type` is a triple bond (represented by the symbol '#'). This ensures we only consider triple bonds in the subsequent steps.\n\n2. **Join with Connected Atoms**: Next, join the filtered `bond` table (referred to as `T1`) with the `connected` table (referred to as `T2`) using the `bond_id` column as the common key. This join operation links each triple bond to the pairs of atoms it connects.\n\n3. **Select Atom Pairs**: Finally, retrieve the `atom_id` and `atom_id2` columns from the `connected` table (`T2`). These columns represent the identifiers of the atoms connected by the triple bonds identified in the previous steps.\n\nThe result of these operations will be a list of all pairs of atoms connected by triple bonds."
        ]
    },
    "468": {
        "sql": "SELECT st.translation\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.name = 'Eighth Edition' AND st.language = 'Chinese Simplified';",
        "question": "What is the Simplified Chinese translation of the name of the set \"Eighth Edition\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Eighth Edition' AND T2.language = 'Chinese Simplified'",
        "explain": "Eighth Edition is the name of card set which refers to name = 'Eighth Edition'; Simplified Chinese refers to language = 'Chinese Simplified'; translation of the name refers to translation",
        "solution": []
    },
    "1066": {
        "sql": "SELECT DISTINCT t_a.buildUpPlayPassingClass\nFROM Team t\nJOIN Team_Attributes t_a ON t.team_api_id = t_a.team_api_id\nWHERE t.team_short_name = 'CLB';",
        "question": "What is the passing class of CLB team?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'CLB'",
        "explain": "passing class refers to buildUpPlayPassingClass; CLB refers to team_short_name = 'CLB';",
        "solution": [
            "To find the passing class of the CLB team, follow these steps:\n\n1. **Identify the Team**: Locate the team with the short name 'CLB' in the `Team` table.\n\n2. **Join with Team Attributes**: Use the `team_api_id` from the identified team to join with the `Team_Attributes` table. This will link the team to its attributes.\n\n3. **Retrieve the Passing Class**: From the joined data, select the distinct values of the `buildUpPlayPassingClass` column, which represents the passing class of the team.\n\n4. **Return the Result**: The result will be the passing class(es) associated with the CLB team."
        ]
    },
    "290": {
        "sql": "SELECT DISTINCT element FROM atom WHERE molecule_id = 'TR151';",
        "question": "Which toxic element can be found in the molecule TR151?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR151'",
        "explain": "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "solution": [
            "To find out which toxic elements are present in the molecule TR151, the database is queried to retrieve all distinct elements from the 'atom' table where the 'molecule_id' is 'TR151'. This ensures that each element is listed only once, even if it appears multiple times in the molecule."
        ]
    },
    "1099": {
        "sql": "SELECT pa.preferred_foot \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Abdou Diallo';",
        "question": "Which foot is preferred by Abdou Diallo?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "explain": "Abdou Diallo refers to player_name = 'Abdou Diallo'; foot is preferred refers to preferred_foot",
        "solution": []
    },
    "387": {
        "sql": "SELECT id, colors FROM cards WHERE id IN (SELECT id FROM set_translations WHERE setCode = 'OGW');",
        "question": "What are the cards for set OGW? State the colour for these cards.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id, colors FROM cards WHERE id IN ( SELECT id FROM set_translations WHERE setCode = 'OGW' )",
        "explain": "set OGW refers to setCode = 'OGW';",
        "solution": [
            "To find the cards for the set 'OGW' and their colors, follow these steps:\n\n1. **Identify the set**: First, locate all card IDs that belong to the set with the code 'OGW' from the `set_translations` table.\n2. **Retrieve card details**: Using the IDs obtained from the previous step, query the `cards` table to fetch the `id` and `colors` of these cards.\n\nThis process ensures that you get the list of cards specifically from the 'OGW' set along with their respective colors.",
            "To retrieve the cards for the set 'OGW' and their colors, follow these detailed steps:\n\n1. **Query the set_translations table**: Execute a subquery to select all `id` values from the `set_translations` table where the `setCode` is 'OGW'. This identifies all card IDs that belong to the 'OGW' set.\n\n2. **Query the cards table**: Using the list of `id` values obtained from the subquery, query the `cards` table to fetch the `id` and `colors` columns for these cards. This provides the card IDs and their corresponding colors for the 'OGW' set.\n\nThe SQL query combines these steps into a single operation: `SELECT id, colors FROM cards WHERE id IN (SELECT id FROM set_translations WHERE setCode = 'OGW')`."
        ]
    },
    "964": {
        "sql": "SELECT code FROM drivers WHERE nationality = 'American';",
        "question": "List out the code for drivers who have nationality in America.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT code FROM drivers WHERE Nationality = 'American'",
        "explain": "nationality = 'America'",
        "solution": [
            "To list out the code for drivers who have nationality in America, you need to perform the following steps:\n\n1. Access the 'drivers' table in the database.\n2. Filter the records in the 'drivers' table to only include those where the 'Nationality' column has the value 'American'.\n3. From the filtered records, extract and display the values in the 'code' column.\n\nThis operation will return all the codes of drivers whose nationality is specified as 'American'."
        ]
    },
    "53": {
        "sql": "SELECT T1.NumTstTakr FROM satscores T1 INNER JOIN schools T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno';",
        "question": "How many test takers are there at the school/s whose mailing city address is in Fresno?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'",
        "explain": "",
        "solution": [
            "To find the number of test takers at schools whose mailing city address is in Fresno, follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables, `satscores` (referred to as T1) and `schools` (referred to as T2).\n\n2. **Join the tables**: Link the `satscores` table (T1) with the `schools` table (T2) using the common field `cds` from T1 and `CDSCode` from T2. This ensures that the data from both tables is combined based on matching school identifiers.\n\n3. **Filter the data**: From the joined tables, filter the records to include only those where the `MailCity` field in the `schools` table (T2) is equal to 'Fresno'. This narrows down the data to schools located in Fresno.\n\n4. **Retrieve the result**: Finally, select the `NumTstTakr` field from the `satscores` table (T1) for the filtered records. This field contains the number of test takers for each school.\n\nThe result will be a count of test takers from all schools in Fresno.",
            "To determine the number of test takers at schools whose mailing city address is in Fresno, execute the following steps:\n\n1. **Identify the tables involved**: The data is stored in the `satscores` table (aliased as T1) and the `schools` table (aliased as T2).\n\n2. **Join the tables**: Perform an inner join between the `satscores` table (T1) and the `schools` table (T2) using the common fields `cds` from T1 and `CDSCode` from T2. This ensures that only records with matching school identifiers are included in the result.\n\n3. **Apply the filter**: From the joined tables, filter the records to include only those where the `MailCity` field in the `schools` table (T2) is exactly 'Fresno'. This isolates the data to schools located in Fresno.\n\n4. **Retrieve the desired data**: Select the `NumTstTakr` field from the `satscores` table (T1) for the filtered records. This field represents the number of test takers for each school.\n\nThe final output will list the number of test takers for all schools in Fresno."
        ]
    },
    "5": {
        "sql": "SELECT COUNT(*) \nFROM satscores \nJOIN schools ON satscores.cds = schools.CDSCode \nWHERE schools.Virtual = 'F' AND satscores.AvgScrMath > 400;",
        "question": "How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.School) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' AND T1.AvgScrMath > 400",
        "explain": "Exclusively virtual refers to Virtual = 'F'",
        "solution": []
    },
    "508": {
        "sql": "SELECT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1;",
        "question": "What are the available printing types of the cards that doesn't have a text box created by Aleksi Briclot?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1",
        "explain": "created by Aleksi Briclot refers to artist = 'Aleksi Briclot'; doesn't have a text box refers to isTextless = 1; available printing types refers to availability",
        "solution": []
    },
    "1042": {
        "sql": "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2009/2010'\nGROUP BY l.name\nHAVING AVG(m.home_team_goal) > AVG(m.away_team_goal);",
        "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0",
        "explain": "name of league refers to League.name; average goals by the home team is higher than the away team = AVG(home_team_goal) > AVG(away_team_goal); AVG(xx_goal) = SUM(xx_goal) / COUNT(DISTINCT Match.id); 2009/2010 season refers to season = '2009/2010'",
        "solution": []
    },
    "1044": {
        "sql": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10';",
        "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
        "explain": "players with a birthyear of 1970 and a birthmonth of October refers to substr(birthday,1,7) AS 'year-month',WHERE year = '1970' AND month = '10';",
        "solution": [
            "To list the football players with a birth year of 1970 and a birth month of October, the database performs the following operations:\n\n1. **Select the player names**: The query retrieves the `player_name` column from the `Player` table.\n\n2. **Filter by birth year and month**: The query filters the records to include only those players whose birthday starts with '1970-10'. This is done using the `SUBSTR` function, which extracts the first 7 characters of the `birthday` column (representing the year and month in the format 'YYYY-MM'). The condition ensures that the year is 1970 and the month is October (the 10th month).\n\nThe result is a list of all football players born in October 1970."
        ]
    },
    "464": {
        "sql": "SELECT c.name\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE st.translation = 'Hauptset Zehnte Edition';",
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "explain": "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'",
        "solution": []
    },
    "731": {
        "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'DC Comics');",
        "question": "How many superheroes did DC Comics publish?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics'",
        "explain": "superheroes that DC Comics published refers to publisher_name = 'DC Comics'",
        "solution": []
    },
    "778": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Adaptation';",
        "question": "Provide superheroes' names who have the adaptation power.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Adaptation'",
        "explain": "adaptation power refers to power_name = 'Adaptation';",
        "solution": []
    },
    "527": {
        "sql": "SELECT r.text FROM cards c JOIN rulings r ON c.uuid = r.uuid WHERE c.artist = 'Kev Walker' ORDER BY r.date DESC;",
        "question": "What are the rulings for the card named and designed by Kev Walker? List them in descending order of dates.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Kev Walker' ORDER BY T2.date DESC",
        "explain": "rulings refers to text; card named and designed by Kev Walker refers to artist = 'Kev Walker'; descending order of dates refers to MAX(date);",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the tables**: The `cards` table (referred to as T1) is joined with the `rulings` table (referred to as T2) using the `uuid` column as the common key. This ensures that each card is matched with its corresponding rulings.\n\n2. **Filter the data**: Only the rows where the `artist` column in the `cards` table (T1) is equal to 'Kev Walker' are selected. This filters out all cards not designed by Kev Walker.\n\n3. **Select the rulings text**: From the filtered and joined data, the `text` column from the `rulings` table (T2) is selected. This provides the actual rulings for the cards.\n\n4. **Order the results**: The selected rulings are ordered by the `date` column from the `rulings` table (T2) in descending order. This ensures the most recent rulings appear first in the results.\n\nThe final output is a list of rulings for cards designed by Kev Walker, sorted from the most recent to the oldest."
        ]
    },
    "103": {
        "sql": "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.disp_id = ca.disp_id\nWHERE ca.issued = '1994-03-03';",
        "question": "Which client issued his/her card in 1994/3/3, give his/her client id.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.issued = '1994-03-03'",
        "explain": "",
        "solution": []
    },
    "832": {
        "sql": "SELECT superhero_name\nFROM superhero\nWHERE height_cm = (SELECT MAX(height_cm) FROM superhero)\nLIMIT 1;",
        "question": "Name the tallest superhero.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "explain": "tallest superhero refers to MAX(height_cm);",
        "solution": []
    },
    "475": {
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') \nAND borderColor = 'black';",
        "question": "How many cards in the set Coldsnap have a black border color?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "explain": "card set Coldsnap refers to name = 'Coldsnap'; black border color refers to borderColor = 'black'",
        "solution": []
    },
    "1412": {
        "sql": "SELECT DISTINCT e.expense_description\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE m.t_shirt_size = 'X-Large';",
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "explain": "kind of expenses refers to expense_description; t_shirt_size = 'X-Large'",
        "solution": []
    },
    "136": {
        "sql": "SELECT COUNT(DISTINCT T1.account_id) \nFROM account T1 \nJOIN loan T2 ON T1.account_id = T2.account_id \nWHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' \nAND T1.frequency = 'POPLATEK MESICNE' \nAND T2.amount >= 250000;",
        "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
        "explain": "Frequency = 'POPLATEK MESICNE' stands for monthly issurance",
        "solution": [
            "To solve the question, follow these steps:\n1. **Join the `account` and `loan` tables** using the `account_id` field to link them.\n2. **Filter the loans** to include only those approved between January 1, 1995, and December 31, 1997, by checking the `date` field in the `loan` table.\n3. **Filter the accounts** to include only those that chose monthly statement issuance, indicated by the `frequency` field in the `account` table being 'POPLATEK MESICNE'.\n4. **Filter the loans** to include only those with an amount of at least 250,000, by checking the `amount` field in the `loan` table.\n5. **Count the number of unique account IDs** from the filtered results to determine how many such loans were approved.",
            "To solve the question, follow these detailed steps:\n1. **Join the `account` table (aliased as T1) and the `loan` table (aliased as T2)** using the `account_id` field to link them. This ensures that each loan is associated with its corresponding account.\n2. **Filter the loans (T2)** to include only those approved between January 1, 1995, and December 31, 1997, by checking the `date` field in the `loan` table (T2.date BETWEEN '1995-01-01' AND '1997-12-31').\n3. **Filter the accounts (T1)** to include only those that chose monthly statement issuance, indicated by the `frequency` field in the `account` table being 'POPLATEK MESICNE' (T1.frequency = 'POPLATEK MESICNE').\n4. **Filter the loans (T2)** to include only those with an amount of at least 250,000, by checking the `amount` field in the `loan` table (T2.amount >= 250000).\n5. **Count the number of unique account IDs (T1.account_id)** from the filtered results to determine how many such loans were approved (SELECT COUNT(T1.account_id))."
        ]
    },
    "133": {
        "sql": "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1;",
        "question": "In 1996, which districts have the highest unemployment rate? List their branch location and district name.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1",
        "explain": "A2 refers to district names; A13 refers to unemploymant rate in 1996",
        "solution": [
            "To find the district with the highest unemployment rate in 1996, follow these steps:\n\n1. **Retrieve Data**: Access the `district` table which contains information about districts, including their unemployment rates and branch locations.\n\n2. **Sort by Unemployment Rate**: The column `A13` in the `district` table represents the unemployment rate. Sort the districts in descending order based on the values in `A13` to prioritize the highest unemployment rate.\n\n3. **Limit Results**: Since we are interested only in the district with the highest unemployment rate, limit the results to the top entry after sorting.\n\n4. **Select Columns**: Display the `district_id` and `A2` (which represents the district name) for the identified district.\n\nThe SQL query `SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1` accomplishes this by selecting the `district_id` and `A2` columns from the `district` table, ordering the results by `A13` in descending order, and returning only the top result."
        ]
    },
    "629": {
        "sql": "SELECT \n    (SELECT COUNT(*) FROM votes WHERE strftime('%Y', CreationDate) = '2010') * 1.0 / \n    (SELECT COUNT(*) FROM votes WHERE strftime('%Y', CreationDate) = '2011') AS ratio_2010_to_2011;",
        "question": "Calculate the ratio of votes in 2010 and 2011.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
        "explain": "DIVIDE(COUNT(Id where YEAR(CreationDate) = 2010), COUNT(Id where YEAR(CreationDate) = 2011)) FROM votes;",
        "solution": []
    },
    "160": {
        "sql": "SELECT COUNT(DISTINCT a.account_id) AS weekly_accounts_with_loan_under_200000\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND l.amount < 200000;",
        "question": "Among the weekly issuance accounts, how many have a loan of under 200000?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.amount < 200000",
        "explain": "frequency = 'POPLATEK TYDNE' stands for weekly issuance",
        "solution": []
    },
    "686": {
        "sql": "SELECT COUNT(*) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "question": "Identify the total number of posts with views above average.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "explain": "views above average refer to ViewCount > AVG(ViewCount);",
        "solution": [
            "To identify the total number of posts with views above the average, follow these steps:\n\n1. **Calculate the average view count**: First, compute the average number of views across all posts in the database. This is done by taking the sum of all view counts and dividing it by the total number of posts.\n\n2. **Filter posts with views above the average**: Next, retrieve all posts where the view count is greater than the calculated average view count.\n\n3. **Count the qualifying posts**: Finally, count the number of posts that meet the criteria (views above the average).\n\nThe SQL query accomplishes this by:\n- Using a subquery to calculate the average view count (`SELECT AVG(ViewCount) FROM posts`).\n- Comparing each post's view count to this average in the main query (`WHERE ViewCount > (subquery)`).\n- Selecting the IDs of the qualifying posts (`SELECT Id FROM posts`).",
            "To identify the total number of posts with views above the average, follow these detailed steps:\n\n1. **Calculate the average view count**: \n   - Compute the average number of views across all posts in the database. This involves summing all the view counts (`ViewCount`) from the `posts` table and dividing this sum by the total number of posts. The SQL subquery `SELECT AVG(ViewCount) FROM posts` performs this calculation.\n\n2. **Filter posts with views above the average**: \n   - Retrieve all posts where the `ViewCount` is greater than the average view count calculated in the previous step. The main query uses the condition `WHERE ViewCount > (subquery)` to filter these posts.\n\n3. **Select the qualifying posts**: \n   - The main query `SELECT Id FROM posts` selects the IDs of all posts that meet the criteria (i.e., their `ViewCount` is above the average).\n\nThis SQL query ensures that only posts with views above the average are counted, providing the exact solution to the question."
        ]
    },
    "857": {
        "sql": "SELECT c.lat, c.lng \nFROM circuits c \nJOIN races r ON c.circuitId = r.circuitId \nWHERE r.name = 'Abu Dhabi Grand Prix';",
        "question": "Give the coordinate position for Abu Dhabi Grand Prix.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Abu Dhabi Grand Prix'",
        "explain": "coordinate position/location refers to lat, lng; Abu Dhabi Grand Prix refers to races.name = 'Abu Dhabi Grand Prix'",
        "solution": []
    },
    "1455": {
        "sql": "SELECT T2.budget_id\nFROM expense T1\nJOIN budget T2 ON T1.link_to_budget = T2.budget_id\nWHERE T1.expense_description = 'Water, chips, cookies'\nORDER BY T1.cost DESC\nLIMIT 1;",
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "explain": "budget allowed refers to expense_description; expense_description = 'Water, chips, cookies'; most money refers to MAX(cost)",
        "solution": [
            "To determine which budget allowed the most money for water, chips, and cookies, follow these steps:\n\n1. **Join the Tables**: Combine the `expense` table (referred to as `T1`) with the `budget` table (referred to as `T2`) using the `link_to_budget` field in `T1` and the `budget_id` field in `T2`. This links each expense to its corresponding budget.\n\n2. **Filter for Specific Expenses**: From the joined tables, filter the records to include only those where the `expense_description` in `T1` is exactly 'Water, chips, cookies'. This ensures we are only considering expenses related to these items.\n\n3. **Sort by Cost**: Order the filtered results by the `cost` field in `T1` in descending order. This arranges the expenses from the highest cost to the lowest.\n\n4. **Select the Top Budget**: Retrieve the `budget_id` from `T2` for the first record in the sorted list. This corresponds to the budget that allocated the most money for water, chips, and cookies.\n\nThe final output is the `budget_id` of the budget with the highest expenditure on these items."
        ]
    },
    "1389": {
        "sql": "SELECT T1.event_name\nFROM event T1\nJOIN budget T2 ON T1.event_id = T2.link_to_event\nJOIN expense T3 ON T2.budget_id = T3.link_to_budget\nORDER BY T3.cost ASC\nLIMIT 1;",
        "question": "Which event has the lowest cost?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
        "explain": "event refers to event_name; lowest cost means MIN(cost)",
        "solution": [
            "To find the event with the lowest cost, follow these steps:\n\n1. **Join the tables**: \n   - Start by joining the `event` table (aliased as `T1`) with the `budget` table (aliased as `T2`) using the condition `T1.event_id = T2.link_to_event`. This links each event to its corresponding budget.\n   - Next, join the result with the `expense` table (aliased as `T3`) using the condition `T2.budget_id = T3.link_to_budget`. This links each budget to its associated expenses.\n\n2. **Sort the expenses**: \n   - After joining the tables, sort the results by the `cost` column from the `expense` table (`T3.cost`) in ascending order. This ensures that the lowest cost appears first.\n\n3. **Retrieve the event name**: \n   - Finally, select the `event_name` from the `event` table (`T1.event_name`) for the first row in the sorted result, which corresponds to the event with the lowest cost.\n\nThis process ensures that you accurately identify the event with the lowest cost by leveraging the relationships between the `event`, `budget`, and `expense` tables."
        ]
    },
    "625": {
        "sql": "SELECT COUNT(Id) AS NumberOfUsersFromNewYork FROM users WHERE Location = 'New York';",
        "question": "How many users were from New York?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "explain": "New York refers to Location;",
        "solution": [
            "To determine how many users were from New York, the database performs the following operations:\n\n1. **Filtering Data**: The database filters the `users` table to include only those records where the `Location` column has the value 'New York'.\n2. **Counting Records**: After filtering, the database counts the number of records (users) that meet the criteria. This count is based on the `Id` column, ensuring each user is uniquely counted.\n\nThe result of this operation is the total number of users from New York."
        ]
    },
    "863": {
        "sql": "SELECT s.url \nFROM seasons s \nJOIN races r ON s.year = r.year \nWHERE r.raceId = 901;",
        "question": "Show me the season page of year when the race No. 901 took place.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "explain": "race number refers to raceId;",
        "solution": []
    },
    "190": {
        "sql": "SELECT COUNT(*) \nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE strftime('%Y', c.birth_date) = '1920' \nAND d.A3 = 'east Bohemia';",
        "question": "How many clients who were born in 1920 stay in east Bohemia?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.birth_date) = '1920' AND T2.A3 = 'east Bohemia'",
        "explain": "East Bohemia appears in the column A3, which refers to the region.",
        "solution": []
    },
    "123": {
        "sql": "SELECT a.account_id, d.A2 AS district, d.A3 AS region\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.amount > 300000;",
        "question": "Provide the account ID, district and region for loan amount greater than USD300,000.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.amount > 300000",
        "explain": "A2 contains district names and A3 contains region names.",
        "solution": []
    },
    "999": {
        "sql": "SELECT r.name AS race_name\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nWHERE res.fastestLapTime IS NOT NULL\nORDER BY res.fastestLapTime ASC\nLIMIT 1;",
        "question": "In terms of the fastest lap time, what is the name of the race which recorded the fastest lap speed by a racer?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "explain": "Fastest lap speed refers to MIN(fastestLapTime)\n\n",
        "solution": []
    },
    "556": {
        "sql": "SELECT AVG(badge_count) AS average_badges\nFROM (\n    SELECT u.Id, COUNT(b.Id) AS badge_count\n    FROM users u\n    LEFT JOIN badges b ON u.Id = b.UserId\n    WHERE u.Views > 200\n    GROUP BY u.Id\n) AS user_badges;",
        "question": "What is the average number of badges obtained by a user with over 200 views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Views > 200",
        "explain": "user with over 200 views refers to Views > 200; average number of badges = Divide (Count(Id), Count(DisplayName))",
        "solution": []
    },
    "1171": {
        "sql": "SELECT COUNT(DISTINCT P.ID) AS UnderagePatientsExamined\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE E.`Examination Date` BETWEEN '1990-01-01' AND '1993-12-31'\nAND (strftime('%Y', E.`Examination Date`) - strftime('%Y', P.Birthday) - \n    (strftime('%m-%d', E.`Examination Date`) < strftime('%m-%d', P.Birthday))) < 18;",
        "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.Birthday) < 18",
        "explain": "underage patients refers to year(Birthday) < 18; three-year period from 1990 to 1993 refers to year(`Examination Date`) between '1990' and '1993'",
        "solution": []
    },
    "1248": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T1.Birthday > '1980-01-01' \nAND (T2.FG <= 150 OR T2.FG >= 450)",
        "question": "How many patients born after 1980/1/1 have an abnormal fibrinogen level?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T1.Birthday > '1980-01-01'",
        "explain": "born after 1980/1/1 refers to Birthday > '1980-01-01'; normal fibrinogen level refers to FG between 150 and 450; Should return the number of distinct patients.",
        "solution": [
            "To solve the question \"How many patients born after 1980/1/1 have an abnormal fibrinogen level?\", follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables, `Patient` (referred to as `T1`) and `Laboratory` (referred to as `T2`).\n\n2. **Join the tables**: Combine the `Patient` and `Laboratory` tables using an inner join on the `ID` column, which is common to both tables. This ensures that only records with matching `ID` values in both tables are considered.\n\n3. **Filter patients by birth date**: From the joined data, filter out patients whose `Birthday` is after January 1, 1980 (`T1.Birthday > '1980-01-01'`).\n\n4. **Filter for abnormal fibrinogen levels**: Further filter the results to include only patients with abnormal fibrinogen levels. A fibrinogen level (`FG`) is considered abnormal if it is less than or equal to 150 (`T2.FG <= 150`) or greater than or equal to 450 (`T2.FG >= 450`).\n\n5. **Count distinct patients**: Finally, count the number of distinct `ID` values from the filtered results to determine how many unique patients meet the criteria.\n\nThe SQL query accomplishes this by performing these operations in sequence, ensuring accurate and efficient retrieval of the desired information.",
            "To solve the question \"How many patients born after 1980/1/1 have an abnormal fibrinogen level?\", follow these detailed steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables, `Patient` (referred to as `T1`) and `Laboratory` (referred to as `T2`).\n\n2. **Join the tables**: Perform an inner join between the `Patient` (`T1`) and `Laboratory` (`T2`) tables using the `ID` column as the join condition. This ensures that only records with matching `ID` values in both tables are included in the result set.\n\n3. **Filter patients by birth date**: From the joined data, apply a filter to include only those patients whose `Birthday` is after January 1, 1980 (`T1.Birthday > '1980-01-01'`).\n\n4. **Filter for abnormal fibrinogen levels**: Further refine the results by including only patients with abnormal fibrinogen levels. A fibrinogen level (`FG`) is considered abnormal if it is either less than or equal to 150 (`T2.FG <= 150`) or greater than or equal to 450 (`T2.FG >= 450`).\n\n5. **Count distinct patients**: Finally, count the number of distinct `ID` values from the filtered results to determine the total number of unique patients who meet both criteria (born after 1980/1/1 and have abnormal fibrinogen levels).\n\nThe SQL query provided performs these operations in sequence, ensuring accurate and efficient retrieval of the desired information."
        ]
    },
    "1292": {
        "sql": "SELECT e.\"aCL IgG\", e.\"aCL IgM\", e.\"aCL IgA\"\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE p.SEX = 'F' AND l.UA > 6.5\nORDER BY l.UA DESC\nLIMIT 1;",
        "question": "What is the anti Cardiolipin antibody concentration of the female patient with the highest uric acid level in the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T1.SEX = 'F' AND T2.UA > 6.5 ORDER BY T2.UA DESC LIMIT 1",
        "explain": "anti Cardiolipin antibody concentration refers to `aCL IgG`, `aCL IgM`, `aCL IgA`; female patient refers to Sex = F'; highest uric acid level in the normal range refers to MAX(UA > 6.50);",
        "solution": [
            "To find the anti-Cardiolipin antibody concentration (aCL IgG, aCL IgM, aCL IgA) of the female patient with the highest uric acid (UA) level in the normal range, follow these steps:\n\n1. **Identify Female Patients**: Filter the `Patient` table to include only female patients (where `SEX = 'F'`).\n\n2. **Filter by Uric Acid Level**: From the `Laboratory` table, select patients whose uric acid (UA) levels are above 6.5 (indicating the normal range).\n\n3. **Join Tables**: Combine the `Patient`, `Laboratory`, and `Examination` tables using the patient ID (`ID`) as the common key to link the records.\n\n4. **Sort by Uric Acid Level**: Order the results by the uric acid (UA) levels in descending order to prioritize the highest values.\n\n5. **Retrieve Top Result**: Limit the results to the top record (the patient with the highest UA level).\n\n6. **Extract Anti-Cardiolipin Antibody Data**: From the `Examination` table, retrieve the anti-Cardiolipin antibody concentrations (`aCL IgG`, `aCL IgM`, `aCL IgA`) for the identified patient.\n\nThe final output will display the anti-Cardiolipin antibody concentrations for the female patient with the highest uric acid level in the normal range."
        ]
    },
    "1315": {
        "sql": "SELECT COUNT(link_to_member) AS student_count\nFROM attendance\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = \"Women's Soccer\");",
        "question": "How many students of the Student_Club have attended the event \"Women's Soccer\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
        "explain": "Women's Soccer is an event name",
        "solution": []
    },
    "1026": {
        "sql": "SELECT t.team_long_name\nFROM Match m\nJOIN Team t ON m.home_team_api_id = t.team_api_id\nWHERE m.season = '2015/2016' AND m.home_team_goal < m.away_team_goal\nGROUP BY m.home_team_api_id\nORDER BY COUNT(*) ASC\nLIMIT 1;",
        "question": "Which home team had lost the fewest matches in the 2016 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT teamDetails.team_long_name FROM Match AS matchData INNER JOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id WHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0 GROUP BY matchData.home_team_api_id ORDER BY COUNT(*) ASC LIMIT 1",
        "explain": "home team lost the matches refers to SUBTRACT(home_team_goal, away_team_goal) < 0; 2016 season refers to season = '2015/2016';",
        "solution": [
            "To find the home team that lost the fewest matches in the 2016 season, follow these steps:\n\n1. **Filter Matches for the 2016 Season**: Select all matches from the `Match` table where the `season` is '2015/2016' (representing the 2016 season).\n\n2. **Identify Lost Matches**: From these matches, identify those where the home team lost. A loss occurs when the `home_team_goal` is less than the `away_team_goal` (i.e., `home_team_goal - away_team_goal < 0`).\n\n3. **Group by Home Team**: Group the filtered matches by the `home_team_api_id` to aggregate the data for each home team.\n\n4. **Count Losses per Team**: For each home team, count the number of matches they lost.\n\n5. **Order by Loss Count**: Sort the teams in ascending order based on the count of their losses. This will place the team with the fewest losses at the top.\n\n6. **Select the Top Team**: Limit the result to the first row to get the home team with the fewest losses.\n\n7. **Retrieve Team Name**: Join the result with the `Team` table using the `team_api_id` to fetch the `team_long_name` of the identified team.\n\nThe final output will be the name of the home team that lost the fewest matches in the 2016 season."
        ]
    },
    "8": {
        "sql": "SELECT s.NumTstTakr\nFROM satscores s\nJOIN frpm f ON s.cds = f.CDSCode\nWHERE f.\"FRPM Count (K-12)\" = (SELECT MAX(\"FRPM Count (K-12)\") FROM frpm);",
        "question": "What is the number of SAT test takers of the schools with the highest FRPM count for K-12 students?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT NumTstTakr FROM satscores WHERE cds = ( SELECT CDSCode FROM frpm ORDER BY `FRPM Count (K-12)` DESC LIMIT 1 )",
        "explain": "",
        "solution": []
    },
    "82": {
        "sql": "SELECT GSoffered FROM schools ORDER BY ABS(Longitude) DESC LIMIT 1;",
        "question": "What is the grade span offered in the school with the highest longitude?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
        "explain": "the highest longitude refers to the school with the maximum absolute longitude value.",
        "solution": [
            "To determine the grade span offered in the school with the highest longitude, follow these steps:\n\n1. **Retrieve the Data**: Access the \"schools\" table which contains information about various schools, including their longitude and the grade spans they offer.\n\n2. **Sort by Longitude**: Order the schools based on the absolute value of their longitude in descending order. This ensures that the school with the highest longitude (farthest east or west) appears at the top of the list.\n\n3. **Limit Results**: Select only the first record from the sorted list, which corresponds to the school with the highest longitude.\n\n4. **Extract Grade Span**: From this record, retrieve the value in the \"GSoffered\" column, which represents the grade span offered by the school.\n\nThis process ensures that you accurately identify the grade span of the school located at the highest longitude."
        ]
    },
    "15": {
        "sql": "SELECT T1.District\nFROM schools T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nWHERE T1.StatusType = 'Active'\nORDER BY T2.AvgScrRead DESC\nLIMIT 1;",
        "question": "Which active district has the highest average score in Reading?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1",
        "explain": "",
        "solution": [
            "1. **Joining the schools and SAT scores data:**  \n   The query uses an `INNER JOIN` between two tables: `schools` (aliased as T1) and `satscores` (aliased as T2). These two tables are linked together using a common key, the `CDSCode` (from `schools`) and `cds` (from `satscores`). This ensures that each school record is matched with its corresponding SAT score data.\n\n2. **Filtering for active districts:**  \n   The query includes a filter condition (`T1.StatusType = 'Active'`) to only consider schools that are currently active. This aligns with the question's requirement to focus on active districts.\n\n3. **Selecting the district identifier:**  \n   From the `schools` table (T1), the query specifically selects the column `District`. This is the identifier for the district associated with each school, which the question explicitly requests.\n\n4. **Ordering by average reading score:**  \n   The results are ordered based on the column `AvgScrRead` from the `satscores` table. The sorting is in descending order (`DESC`), so that the district with the highest average reading score appears at the top.\n\n5. **Limiting to the top result:**  \n   Finally, the query applies a `LIMIT 1`, which restricts the output to only the first record. This ensures that only the active district with the highest average reading score is returned."
        ]
    },
    "975": {
        "sql": "SELECT r.year\nFROM lapTimes lt\nJOIN races r ON lt.raceId = r.raceId\nGROUP BY r.year\nORDER BY MAX(lt.time) DESC\nLIMIT 1;",
        "question": "Which year has the lowest speed of lap time?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId ORDER BY T1.time DESC LIMIT 1",
        "explain": "lowest speed of lap time refers to Max(time);",
        "solution": []
    },
    "1098": {
        "sql": "SELECT MAX(ta.chanceCreationPassing) AS highest_chance_creation_passing, ta.chanceCreationPassingClass\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE t.team_long_name = 'Ajax';",
        "question": "What is Ajax's highest chance creation passing score and what is it classified as?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Ajax' ORDER BY t2.chanceCreationPassing DESC LIMIT 1",
        "explain": "Ajax's refers to team_long_name = 'Ajax'; chance creation passing score refers to MAX(chanceCreationPassing); classified refer to chanceCreationPassingClass",
        "solution": []
    },
    "636": {
        "sql": "SELECT COUNT(*) AS NegativeCommentCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'Neil McGuigan' AND c.Score < 60;",
        "question": "How many negative comments did Neil McGuigan get in his posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T1.DisplayName = 'Neil McGuigan' AND T3.Score < 60",
        "explain": "Negative comment refers to score < 60; DisplayName = 'Neil McGuigan';",
        "solution": []
    },
    "49": {
        "sql": "WITH CountyClosedCount AS (\n    SELECT \n        County,\n        COUNT(School) AS ClosedSchoolCount\n    FROM \n        schools\n    WHERE \n        StatusType = 'Closed'\n    GROUP BY \n        County\n    ORDER BY \n        ClosedSchoolCount DESC\n    LIMIT 1\n)\nSELECT \n    s.County,\n    s.School,\n    s.ClosedDate\nFROM \n    schools s\nJOIN \n    CountyClosedCount c ON s.County = c.County\nWHERE \n    s.StatusType = 'Closed'\n    AND s.School IS NOT NULL\nORDER BY \n    s.ClosedDate;",
        "question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Closed' AND school IS NOT NULL",
        "explain": "Closure date and closed date are synonyms; 'Closed' was mentioned in schools.StatusType.",
        "solution": [
            "To solve the question, 'Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date,' the following steps are performed:\n\n1. **Identify the County with the Most Closed Schools**:\n   - Filter the `schools` table to include only records where the `StatusType` is 'Closed'.\n   - Group these records by `County`.\n   - Count the number of schools (`School`) in each county.\n   - Order the counties in descending order based on the count of closed schools.\n   - Select the top county (the one with the highest count of closed schools).\n\n2. **Retrieve Details of Closed Schools in the Identified County**:\n   - Filter the `schools` table again to include only records where:\n     - The `County` matches the county identified in the first step.\n     - The `StatusType` is 'Closed'.\n     - The `School` field is not null.\n   - Select the distinct values of `County`, `School`, and `ClosedDate` for these records.\n\nThis ensures that the result includes the name of each closed school and its closure date for the county with the most closed schools."
        ]
    },
    "854": {
        "sql": "SELECT c.lat, c.lng\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Australian Grand Prix';",
        "question": "What is the coordinates location of the circuits for Australian grand prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Australian Grand Prix'",
        "explain": "coordinate position/location refers to lat, lng; circuits for Australian grand prix refers to races.name = 'Australian Grand Prix'",
        "solution": []
    },
    "884": {
        "sql": "SELECT name FROM races\nWHERE year = (SELECT MIN(year) FROM races)\nAND strftime('%m', date) = (SELECT strftime('%m', date) FROM races WHERE year = (SELECT MIN(year) FROM races) ORDER BY date LIMIT 1);",
        "question": "List the names of all races that occurred in the earliest recorded year and month.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE STRFTIME('%Y', date) = ( SELECT STRFTIME('%Y', date) FROM races ORDER BY date ASC LIMIT 1 ) AND STRFTIME('%m', date) = ( SELECT STRFTIME('%m', date) FROM races ORDER BY date ASC LIMIT 1 )",
        "explain": "earliest recorded year and month refers to year = year(min(date)) and month = month(min(date));",
        "solution": []
    },
    "1301": {
        "sql": "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nJOIN Laboratory l ON p.ID = l.ID\nWHERE e.Thrombosis = 0 AND l.CPK < 250;",
        "question": "Please list the IDs of the patients with no thrombosis and an abnormal level of creatinine phosphokinase.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 0 AND T1.CPK < 250",
        "explain": "no thrombosis refers to Thrombosis = 0 ; abnormal level of creatinine phosphokinase refers to CPK < 250;",
        "solution": []
    },
    "1065": {
        "sql": "SELECT t.team_long_name \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE ta.buildUpPlaySpeedClass = 'Fast';",
        "question": "Please list all team names which the speed class is fast.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "explain": "team names refers to team_long_name; speed class refers to buildUpPlaySpeedClass; buildUpPlaySpeedClass = 'Fast';",
        "solution": []
    },
    "937": {
        "sql": "SELECT T1.time FROM results T1 JOIN races T2 ON T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008;",
        "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
        "explain": "finish time refers to time; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
        "solution": [
            "To find the finish time for the driver who ranked second in the 2008 Chinese Grand Prix, follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables, `results` (referred to as `T1`) and `races` (referred to as `T2`).\n\n2. **Join the tables**: Link the `results` table (`T1`) with the `races` table (`T2`) using the `raceId` field, which is common to both tables. This ensures that the results correspond to the correct race.\n\n3. **Filter the data**: Apply the following filters to narrow down the results:\n   - The `rank` field in the `results` table (`T1`) must be equal to `2`, indicating the driver who finished in second place.\n   - The `name` field in the `races` table (`T2`) must be `'Chinese Grand Prix'`, specifying the race.\n   - The `year` field in the `races` table (`T2`) must be `2008`, specifying the year of the race.\n\n4. **Retrieve the finish time**: After applying the filters, select the `time` field from the `results` table (`T1`), which contains the finish time of the driver who met all the specified conditions."
        ]
    },
    "1369": {
        "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.amount = (SELECT MAX(amount) FROM budget);",
        "question": "Which event has the highest budget amount?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id ORDER BY T1.amount DESC LIMIT 1",
        "explain": "event refers to event_name; highest budget amount refers to MAX(amount)",
        "solution": []
    },
    "583": {
        "sql": "SELECT SUM(p.Score) AS TotalScore, u.WebsiteUrl\nFROM posts p\nJOIN users u ON p.LastEditorUserId = u.Id\nWHERE u.DisplayName = 'Yevgeny';\n",
        "question": "What is the total score of the posts edited by Yevgeny and include the user's website URL.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.Score), T2.WebsiteUrl FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Yevgeny' GROUP BY T2.WebsiteUrl",
        "explain": "\"Yevgeny\" is the DisplayName; edited refers to LastEditorUserId",
        "solution": []
    },
    "987": {
        "sql": "SELECT AVG(fastestLapTime) AS average_fastest_lap_time\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE year = 2006 AND name = 'United States Grand Prix')\nAND position <= 10\nAND fastestLapTime IS NOT NULL;",
        "question": "What is the average fastest lap time of the top 10 drivers in the 2006 United States Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.fastestLapTime) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank < 11 AND T2.year = 2006 AND T2.name = 'United States Grand Prix'",
        "explain": "top 10 refers to rank <11; AVG(fastestLapTime);",
        "solution": []
    },
    "117": {
        "sql": "SELECT (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0 / SUM(amount)) AS percentage_paid_no_issue\nFROM loan;",
        "question": "What is the percentage of loan amount that has been fully paid with no issue.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
        "explain": "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%",
        "solution": []
    },
    "656": {
        "sql": "SELECT u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.ParentId IS NOT NULL\nORDER BY p.Score DESC\nLIMIT 1;",
        "question": "Describe the display name of the parent ID for child post with the highest score.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts WHERE ParentId IS NOT NULL ORDER BY Score DESC LIMIT 1 )",
        "explain": "If the parent id is not null, the post is the child post; the highest score refers to MAX(Score);",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Identify the child post with the highest score**:\n   - From the `posts` table, filter out records where `ParentId` is not NULL (indicating it is a child post).\n   - Order these child posts by their `Score` in descending order to prioritize the highest score.\n   - Limit the result to the top 1 record to get the child post with the highest score.\n\n2. **Retrieve the owner of this child post**:\n   - From the selected child post, extract the `OwnerUserId` field, which identifies the user who owns the post.\n\n3. **Find the display name of the owner**:\n   - Using the `OwnerUserId` obtained in the previous step, query the `users` table to find the corresponding user.\n   - Retrieve the `DisplayName` of this user.\n\nThe final result is the display name of the user who owns the child post with the highest score."
        ]
    },
    "1437": {
        "sql": "SELECT DISTINCT T3.link_to_member, T3.link_to_event\nFROM expense T1\nJOIN member T2 ON T1.link_to_member = T2.member_id\nJOIN attendance T3 ON T2.member_id = T3.link_to_member\nWHERE substr(T1.expense_date, 1, 10) BETWEEN '2019-01-10' AND '2019-11-19'\nAND T1.approved = 'true';",
        "question": "Which members who were approved from 1/10/2019 to 11/19/2019? Please identify the member who attended the event and the link to their event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.link_to_member, T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true'",
        "explain": "approved from 1/10/2019 to 11/19/2019 refers to approved = 'true' and expense_date BETWEEN '2019-01-10' and '2019-11-19'",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Select Distinct Links**: Retrieve distinct pairs of `link_to_member` and `link_to_event` from the database.\n\n2. **Join Tables**:\n   - Join the `expense` table (aliased as `T1`) with the `member` table (aliased as `T2`) using the condition `T1.link_to_member = T2.member_id`.\n   - Further join the result with the `attendance` table (aliased as `T3`) using the condition `T2.member_id = T3.link_to_member`.\n\n3. **Filter by Date and Approval**:\n   - Filter the records where the date part (first 10 characters) of `T1.expense_date` falls between '2019-01-10' and '2019-11-19'.\n   - Additionally, ensure that the `approved` field in the `expense` table is set to 'true'.\n\n4. **Output**: The final output will list the distinct members who attended events during the specified date range and were approved, along with the links to their respective events.",
            "To solve the question, the following detailed operations are performed:\n\n1. **Select Distinct Links**: Retrieve distinct pairs of `link_to_member` and `link_to_event` from the database to ensure no duplicates are included in the results.\n\n2. **Join Tables**:\n   - **First Join**: Join the `expense` table (aliased as `T1`) with the `member` table (aliased as `T2`) using the condition `T1.link_to_member = T2.member_id`. This links each expense record to its corresponding member.\n   - **Second Join**: Further join the result with the `attendance` table (aliased as `T3`) using the condition `T2.member_id = T3.link_to_member`. This links each member to their attendance records.\n\n3. **Filter by Date and Approval**:\n   - **Date Filter**: Extract the first 10 characters of the `expense_date` field in the `expense` table (aliased as `T1`) to isolate the date part. Then, filter the records where this date falls between '2019-01-10' and '2019-11-19'.\n   - **Approval Filter**: Ensure that the `approved` field in the `expense` table (aliased as `T1`) is set to 'true' to only include approved expenses.\n\n4. **Output**: The final output will list the distinct members (identified by `link_to_member`) who attended events (identified by `link_to_event`) during the specified date range and were approved."
        ]
    },
    "733": {
        "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE eye_colour_id = (SELECT id FROM colour WHERE colour = 'Gold') \nAND publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');",
        "question": "How many gold-eyed superheroes did Marvel Comics publish?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.colour = 'Gold'",
        "explain": "gold-eyed refers to colour = 'Gold' where eye_colour_id = colour.id; superheroes that Marvel Comics published refers to publisher_name = 'Marvel Comics'",
        "solution": []
    },
    "498": {
        "sql": "SELECT st.translation AS french_set_name\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nJOIN set_translations st ON s.code = st.setCode\nWHERE c.name = 'Tendo Ice Bridge' AND st.language = 'French';",
        "question": "What's the French name of the set of cards with \"Tendo Ice Bridge\" is in?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Tendo Ice Bridge' AND T2.language = 'French' AND T2.translation IS NOT NULL",
        "explain": "French refers to language = 'French'; \"Tendo Ice Bridge\" is a translated name of a card; translated name refers to translation",
        "solution": []
    },
    "772": {
        "sql": "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id\nFROM superhero T1\nJOIN publisher T2 ON T2.id = T1.publisher_id\nJOIN gender T3 ON T3.id = T1.gender_id\nWHERE T2.publisher_name = 'Dark Horse Comics'\nAND T3.gender = 'Female';",
        "question": "List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'",
        "explain": "eyes refers to eye_colour_id; hair refers to hair_colour_id; skin colour refers to skin_colour_id; female superheroes refers to gender = 'Female'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Data**: Retrieve the columns `eye_colour_id`, `hair_colour_id`, and `skin_colour_id` from the `superhero` table (referred to as `T1`).\n\n2. **Join Tables**:\n   - Join the `superhero` table (`T1`) with the `publisher` table (`T2`) using the condition `T2.id = T1.publisher_id`.\n   - Join the `superhero` table (`T1`) with the `gender` table (`T3`) using the condition `T3.id = T1.gender_id`.\n\n3. **Filter Data**:\n   - Filter the results to include only records where the `publisher_name` in the `publisher` table (`T2`) is 'Dark Horse Comics'.\n   - Further filter the results to include only records where the `gender` in the `gender` table (`T3`) is 'Female'.\n\n4. **Output**: The final output will list the `eye_colour_id`, `hair_colour_id`, and `skin_colour_id` of all female superheroes published by Dark Horse Comics."
        ]
    },
    "1417": {
        "sql": "SELECT DISTINCT e.type\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.remaining > 30;",
        "question": "List out the type of events which have remaining budget more than 30 USD.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 30",
        "explain": "remaining budget more than 30 USD refers to remaining > 30",
        "solution": []
    },
    "1485": {
        "sql": "SELECT \n    (SELECT Consumption FROM yearmonth WHERE CustomerID = 7 AND Date = '201304') - \n    (SELECT Consumption FROM yearmonth WHERE CustomerID = 5 AND Date = '201304') AS ConsumptionDifference;",
        "question": "How much more was customer 7 consuming in April 2013 than customer 5?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0)) FROM yearmonth WHERE Date = '201304'",
        "explain": "April 2013 refers to 201304 in the yearmonth.date",
        "solution": []
    },
    "604": {
        "sql": "SELECT AVG(u.UpVotes) AS average_up_votes, AVG(u.Age) AS average_user_age\nFROM users u\nJOIN (\n    SELECT OwnerUserId, COUNT(*) AS post_count\n    FROM posts\n    GROUP BY OwnerUserId\n    HAVING COUNT(*) > 10\n) p ON u.Id = p.OwnerUserId;",
        "question": "What is the average of the up votes and the average user age for users creating more than 10 posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.UpVotes), AVG(T1.Age) FROM users AS T1 INNER JOIN ( SELECT OwnerUserId, COUNT(*) AS post_count FROM posts GROUP BY OwnerUserId HAVING post_count > 10) AS T2 ON T1.Id = T2.OwnerUserId",
        "explain": "creating more than 10 post refers to Count (UserId) > 10; average of the up votes = Divide (Sum(UpVotes), Count (UserId)); average age = Divide (Sum(Age), Count(UserId))",
        "solution": []
    },
    "1149": {
        "sql": "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS in_patient_count,\n    SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS outpatient_count,\n    (CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / \n     SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)) AS percentage_deviation\nFROM Patient\nWHERE SEX = 'M';",
        "question": "Are there more in-patient or outpatient who were male? What is the deviation in percentage?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE SEX = 'M'",
        "explain": "male refers to SEX = 'M'; in-patient refers to Admission = '+'; outpatient refers to Admission = '-'; percentage = DIVIDE(COUNT(ID) where SEX = 'M' and Admission = '+', COUNT(ID) where SEX\u00a0 = 'M' and Admission = '-')",
        "solution": [
            "To determine whether there are more in-patient or outpatient males and calculate the deviation in percentage, follow these steps:\n\n1. **Filter Patients by Gender**: Select all patients where the gender is male (SEX = 'M').\n\n2. **Count In-Patients**: For each male patient, check if their admission type is in-patient (Admission = '+'). Sum the count of such patients.\n\n3. **Count Outpatients**: Similarly, for each male patient, check if their admission type is outpatient (Admission = '-'). Sum the count of such patients.\n\n4. **Calculate the Percentage Deviation**: Divide the count of in-patients by the count of outpatients and multiply by 100 to get the percentage deviation. This will show how many in-patients there are relative to outpatients in percentage terms.\n\nThe result will indicate whether there are more in-patients or outpatients among males and the deviation in percentage.",
            "To determine whether there are more in-patient or outpatient males and calculate the deviation in percentage, follow these steps:\n\n1. **Filter Patients by Gender**: Select all patients from the `Patient` table where the gender is male (`SEX = 'M'`).\n\n2. **Count In-Patients**: For each male patient, check if their admission type is in-patient (`Admission = '+'`). Sum the count of such patients using `SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)`.\n\n3. **Count Outpatients**: Similarly, for each male patient, check if their admission type is outpatient (`Admission = '-'`). Sum the count of such patients using `SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)`.\n\n4. **Calculate the Percentage Deviation**: Divide the count of in-patients by the count of outpatients and multiply by 100 to get the percentage deviation. This is done using `CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)`.\n\nThe result will indicate the percentage deviation of in-patients relative to outpatients among male patients."
        ]
    },
    "557": {
        "sql": "SELECT \n    (COUNT(CASE WHEN u.Age > 65 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nWHERE \n    p.Score > 5;",
        "question": "Among the posts with a score of over 5, what is the percentage of them being owned by an elder user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age > 65, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score > 5",
        "explain": "score of over 5 refers to Score > 5; elder user refers to Age > 65; percentage = Divide (Count(Id where Age>65), Count(Id)) * 100",
        "solution": []
    },
    "957": {
        "sql": "SELECT COUNT(DISTINCT T1.driverId) AS unfinished_italian_drivers\nFROM results T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'Italian' AND T1.time IS NULL;",
        "question": "How many Italian drivers haven't finished the race?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Italian' AND T1.time IS NULL",
        "explain": "haven't finished the race refers to time is null;",
        "solution": [
            "To solve the question \"How many Italian drivers haven't finished the race?\", follow these steps:\n\n1. **Join the Tables**: Combine the `results` table (referred to as `T1`) with the `drivers` table (referred to as `T2`) using the `driverId` column as the common key. This ensures that each result record is linked to its corresponding driver.\n\n2. **Filter by Nationality**: From the joined tables, filter the records to include only those where the driver's nationality is 'Italian'. This is done by checking the `nationality` column in the `drivers` table (`T2.nationality = 'Italian'`).\n\n3. **Identify Unfinished Races**: Further filter the results to include only those records where the `time` column in the `results` table (`T1.time`) is `NULL`. A `NULL` value in the `time` column indicates that the driver did not finish the race.\n\n4. **Count the Drivers**: Finally, count the number of distinct `driverId` values from the filtered records. This count represents the number of Italian drivers who haven't finished the race.\n\nThe SQL query achieves this by performing an inner join between the `results` and `drivers` tables, applying the nationality and time filters, and then counting the relevant driver IDs.",
            "To solve the question \"How many Italian drivers haven't finished the race?\", follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `results` table (aliased as `T1`) and the `drivers` table (aliased as `T2`) using the `driverId` column as the common key. This ensures that each record in the `results` table is matched with the corresponding driver's details in the `drivers` table.\n\n2. **Filter by Nationality**: From the joined tables, filter the records to include only those where the driver's nationality is 'Italian'. This is done by applying the condition `T2.nationality = 'Italian'`.\n\n3. **Identify Unfinished Races**: Further filter the results to include only those records where the `time` column in the `results` table (`T1.time`) is `NULL`. A `NULL` value in this column indicates that the driver did not finish the race.\n\n4. **Count the Drivers**: Finally, count the number of distinct `driverId` values from the filtered records. This count represents the number of Italian drivers who haven't finished the race.\n\nThe SQL query achieves this by performing an inner join between the `results` and `drivers` tables, applying the nationality and time filters, and then counting the relevant driver IDs."
        ]
    },
    "220": {
        "sql": "SELECT DISTINCT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element ASC LIMIT 3;",
        "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
        "explain": "TR000 is the molecule id;",
        "solution": [
            "To solve the question, the database performs the following operations:\n\n1. **Select Distinct Elements**: It retrieves distinct elements from the `atom` table where the `molecule_id` is 'TR000'. This ensures that each element is listed only once, even if it appears multiple times in the molecule.\n\n2. **Order Alphabetically**: The retrieved elements are then sorted in alphabetical order based on the `element` column.\n\n3. **Limit Results**: Finally, the operation limits the output to the top three elements from the sorted list.\n\nThe result is a list of the top three distinct elements of the molecule TR000, presented in alphabetical order."
        ]
    },
    "735": {
        "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE hair_colour_id = (SELECT id FROM colour WHERE colour = 'Blond');",
        "question": "How many superheroes with blonde hair are there?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id WHERE T2.colour = 'Blond'",
        "explain": "superheroes with blonde hair refers to colour = 'Blond' where hair_colour_id = colour.id",
        "solution": []
    },
    "263": {
        "sql": "SELECT \n    (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS chlorine_percentage\nFROM \n    atom a\nJOIN \n    molecule m ON a.molecule_id = m.molecule_id\nJOIN \n    bond b ON m.molecule_id = b.molecule_id\nWHERE \n    b.bond_type = '-';",
        "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "explain": "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'",
        "solution": []
    },
    "1132": {
        "sql": "SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name ASC LIMIT 3;",
        "question": "Please provide the names of top three football players who are over 180 cm tall in alphabetical order.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name LIMIT 3",
        "explain": "over 180 cm tall refers to height > 180; name of football player refers to player_name",
        "solution": []
    },
    "1148": {
        "sql": "WITH players_under_180 AS (\n    SELECT COUNT(*) AS total_players\n    FROM Player AS t1\n    JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\n    WHERE t1.height < 180\n),\nplayers_high_strength AS (\n    SELECT COUNT(*) AS strong_players\n    FROM Player AS t1\n    JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\n    WHERE t1.height < 180 AND t2.overall_rating > 70\n)\nSELECT (strong_players * 100.0 / total_players) AS percentage\nFROM players_under_180, players_high_strength;",
        "question": "What is the percentage of players that are under 180 cm who have an overall strength of more than 70?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height < 180",
        "explain": "percentage refers to DIVIDE(COUNT(height < 180 AND overall_rating > 70),COUNT(id)) * 100",
        "solution": [
            "To solve the question, we need to calculate the percentage of players who are under 180 cm tall and have an overall strength rating of more than 70. Here are the steps:\n\n1. **Join the Tables**: Combine the `Player` table (aliased as `t1`) and the `Player_Attributes` table (aliased as `t2`) using the `player_api_id` field to link the records.\n\n2. **Filter by Height**: From the joined tables, filter out only those players whose height is less than 180 cm.\n\n3. **Count Eligible Players**: Count the total number of players who meet the height criteria (i.e., height < 180 cm).\n\n4. **Count Players with High Overall Strength**: From the filtered players, count those who also have an overall strength rating (`overall_rating`) greater than 70.\n\n5. **Calculate Percentage**: Divide the count of players with high overall strength by the total count of players under 180 cm, then multiply by 100 to get the percentage.\n\n6. **Output the Result**: The result is presented as a percentage value."
        ]
    },
    "709": {
        "sql": "SELECT COUNT(DISTINCT p.Id) AS PostCount\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE c.Score = 0 AND p.ViewCount < 5;",
        "question": "In comments with 0 score, how many of the posts have view count lower than 5?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.Id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ViewCount < 5 AND T2.Score = 0",
        "explain": "view count lower than 5 refers to ViewCount < 5;",
        "solution": [
            "To solve the question, we need to count the number of posts that have a view count lower than 5 and a score of 0, where these posts are associated with comments. Here's the step-by-step solution:\n\n1. **Join the Tables**: Combine the `comments` table (referred to as T1) with the `posts` table (referred to as T2) using the `PostId` from the comments table and the `Id` from the posts table. This ensures we link each comment to its corresponding post.\n\n2. **Filter the Posts**: From the joined tables, filter out only those posts where the `ViewCount` is less than 5 and the `Score` is 0. This narrows down the posts to those that meet the specified criteria.\n\n3. **Count the Posts**: Finally, count the number of unique post IDs (from the filtered results) to determine how many posts satisfy the conditions.\n\nThe result will be the count of such posts.",
            "To solve the question, we need to count the number of posts that have a view count lower than 5 and a score of 0, where these posts are associated with comments. Here's the detailed step-by-step solution:\n\n1. **Join the Tables**: Combine the `comments` table (referred to as T1) with the `posts` table (referred to as T2) using the `PostId` from the comments table and the `Id` from the posts table. This ensures we link each comment to its corresponding post.\n\n2. **Filter the Posts**: From the joined tables, filter out only those posts where the `ViewCount` is less than 5 and the `Score` is 0. This narrows down the posts to those that meet the specified criteria.\n\n3. **Count the Posts**: Finally, count the number of unique post IDs (from the filtered results) to determine how many posts satisfy the conditions.\n\nThe result will be the count of such posts."
        ]
    },
    "1049": {
        "sql": "SELECT COUNT(*) \nFROM \"Match\" \nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Scotland Premier League') \nAND season = '2015/2016';",
        "question": "How many matches in the 2015/2016 season were held in Scotland Premier League\n?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' AND t1.name = 'Scotland Premier League'",
        "explain": "Scotland Premier League refers to League.name = 'Scotland Premier League';",
        "solution": []
    },
    "126": {
        "sql": "WITH decin_accounts AS (\n    SELECT COUNT(*) AS decin_count\n    FROM account\n    JOIN district ON account.district_id = district.district_id\n    WHERE district.A2 = 'Decin'\n    AND strftime('%Y', account.date) = '1993'\n),\ntotal_1993_accounts AS (\n    SELECT COUNT(*) AS total_count\n    FROM account\n    WHERE strftime('%Y', account.date) = '1993'\n)\nSELECT (decin_count * 100.0 / total_count) AS percentage\nFROM decin_accounts, total_1993_accounts;",
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "explain": "A2 contains the information about district.",
        "solution": []
    },
    "888": {
        "sql": "SELECT T1.country, T1.name AS circuit, T1.location\nFROM circuits T1\nJOIN races T2 ON T1.circuitId = T2.circuitId\nWHERE T2.name = 'European Grand Prix'\nORDER BY T2.year ASC\nLIMIT 1;",
        "question": "In which country was the first European Grand Prix hosted? Name the circuit and location.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.country, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix' ORDER BY T2.year ASC LIMIT 1",
        "explain": "the first refers to min(year);",
        "solution": [
            "To find the country where the first European Grand Prix was hosted, along with the circuit and location, follow these steps:\n\n1. **Join the tables**: Combine the `circuits` table (aliased as `T1`) with the `races` table (aliased as `T2`) using the `circuitID` from `T1` and `circuitId` from `T2` to match records.\n\n2. **Filter the races**: Select only the races where the name is 'European Grand Prix'.\n\n3. **Sort the results**: Order the filtered races by their year in ascending order to find the earliest race.\n\n4. **Limit the results**: Retrieve only the first record from the sorted list to get the earliest European Grand Prix.\n\n5. **Select the required fields**: From the resulting record, extract the `country` and `location` fields from the `circuits` table (`T1`).\n\nThis will give you the country, circuit, and location of the first European Grand Prix.",
            "To determine the country where the first European Grand Prix was hosted, along with the circuit and location, follow these detailed steps:\n\n1. **Table Selection**: Identify the tables involved:\n   - The `circuits` table (aliased as `T1`) contains information about the circuits, including their country and location.\n   - The `races` table (aliased as `T2`) contains details about the races, including the race name and year.\n\n2. **Join Operation**: Perform an inner join between the `circuits` table (`T1`) and the `races` table (`T2`). The join condition is based on matching the `circuitID` field from `T1` with the `circuitId` field from `T2`. This ensures that only records with matching circuit IDs are combined.\n\n3. **Filtering**: Apply a filter to the joined data to select only those races where the `name` field in the `races` table (`T2`) is exactly 'European Grand Prix'. This narrows down the dataset to only include European Grand Prix races.\n\n4. **Sorting**: Sort the filtered results by the `year` field from the `races` table (`T2`) in ascending order. This arranges the races chronologically, with the earliest race appearing first.\n\n5. **Limiting Results**: Retrieve only the first record from the sorted list. This ensures that you get the earliest European Grand Prix race.\n\n6. **Field Selection**: From the resulting record, extract the `country` and `location` fields from the `circuits` table (`T1`). These fields provide the required information about the country, circuit, and location of the first European Grand Prix.\n\nThis process will accurately identify the country, circuit, and location of the first European Grand Prix."
        ]
    },
    "595": {
        "sql": "SELECT T2.UserId\nFROM users T1\nJOIN postHistory T2 ON T1.Id = T2.UserId\nJOIN posts T3 ON T2.PostId = T3.Id\nWHERE T3.ViewCount >= 1000\nGROUP BY T2.UserId\nHAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1;",
        "question": "Which user have only one post history per post and having at least 1000 views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
        "explain": "having at least 1000 view refers to Views > = 1000; user refers to UserId",
        "solution": [
            "To solve the question, \"Which user has only one post history per post and has at least 1000 views?\", the following steps are performed:\n\n1. **Join the Tables**: Combine the `users` table (`T1`), the `postHistory` table (`T2`), and the `posts` table (`T3`) using inner joins. The joins are based on the following conditions:\n   - `T1.Id` (user ID) matches `T2.UserId` (user ID in post history).\n   - `T2.PostId` (post ID in post history) matches `T3.Id` (post ID in posts).\n\n2. **Filter by View Count**: From the joined tables, filter the records to include only those posts where the `ViewCount` in the `posts` table (`T3.ViewCount`) is at least 1000.\n\n3. **Group by User**: Group the filtered records by the `UserId` from the `postHistory` table (`T2.UserId`).\n\n4. **Check Post History Uniqueness**: For each user, ensure that they have only one distinct `PostHistoryTypeId` per post by using the `HAVING` clause with the condition `COUNT(DISTINCT T2.PostHistoryTypeId) = 1`.\n\n5. **Select the Result**: Finally, select the `UserId` from the `postHistory` table (`T2.UserId`) for the users who meet all the above criteria.\n\nThis process ensures that the result includes only those users who have exactly one type of post history per post and whose posts have at least 1000 views."
        ]
    },
    "621": {
        "sql": "SELECT DISTINCT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.Reputation = (SELECT MIN(Reputation) FROM users);",
        "question": "What are the name of badges that users who have the lowest reputation obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
        "explain": "lowest reputation refers to Min(Reputation); user refers to UserId",
        "solution": []
    },
    "938": {
        "sql": "SELECT d.forename, d.surname, d.url\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE rc.year = 2008 AND rc.name = 'Australian Grand Prix' AND r.positionOrder = 1;",
        "question": "Who was the champion of 2008's Australian Grand Prix and where can I know more about him?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname, T1.url FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T2.time LIKE '_:%:__.___' AND T3.year = 2008",
        "explain": "only champion's finished time is represented by 'HH:MM:SS.mmm'; where can I know more refers to url",
        "solution": []
    },
    "215": {
        "sql": "SELECT \n    COUNT(DISTINCT CASE WHEN a.element = 'i' THEN a.atom_id END) AS iodine_nums,\n    COUNT(DISTINCT CASE WHEN a.element = 's' THEN a.atom_id END) AS sulfur_nums\nFROM \n    atom a\nJOIN \n    connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN \n    bond b ON c.bond_id = b.bond_id\nWHERE \n    b.bond_type = '-'",
        "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
        "explain": "with iodine element refer to element = 'i'; with sulfur element refers to element = 's'; single type bond refers to bond_type = '-'; Should consider the distinct atoms when counting;",
        "solution": [
            "To solve the question, \"How many atoms with iodine and with sulfur type elements are there in single bond molecules?\", the following operations are performed:\n\n1. **Filtering Single Bond Molecules**: The database is queried to identify all bonds of type single (denoted by '-').\n\n2. **Joining Tables**: The `atom` table (T1) is joined with the `connected` table (T2) using the `atom_id` field to link atoms to their connections. The `connected` table is then joined with the `bond` table (T3) using the `bond_id` field to access the bond type.\n\n3. **Counting Iodine Atoms**: For each atom, if the element is iodine ('i'), the `atom_id` is counted. Only distinct `atom_id` values are considered to avoid duplicates.\n\n4. **Counting Sulfur Atoms**: Similarly, for each atom, if the element is sulfur ('s'), the `atom_id` is counted. Again, only distinct `atom_id` values are considered.\n\n5. **Result Aggregation**: The results are aggregated to produce two counts:\n   - `iodine_nums`: The total number of distinct iodine atoms in single bond molecules.\n   - `sulfur_nums`: The total number of distinct sulfur atoms in single bond molecules.\n\nThis process ensures that the counts are accurate and only include atoms involved in single bonds."
        ]
    },
    "430": {
        "sql": "SELECT T1.name, T1.id\nFROM sets T1\nJOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.block = 'Shadowmoor' AND T2.language = 'Italian'\nORDER BY T1.id ASC\nLIMIT 2;",
        "question": "Please list top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block in alphabetical order.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Shadowmoor' AND T2.language = 'Italian' ORDER BY T1.id LIMIT 2",
        "explain": "",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the tables**: The `sets` table (aliased as `T1`) is joined with the `set_translations` table (aliased as `T2`) using the condition `T1.code = T2.setCode`. This links each set to its translations.\n\n2. **Filter the data**: The joined data is filtered to include only those sets where the `block` column in the `sets` table equals 'Shadowmoor' and the `language` column in the `set_translations` table equals 'Italian'. This ensures only Italian-language cards from the Shadowmoor block are considered.\n\n3. **Order the results**: The filtered results are ordered alphabetically by the `id` column of the `sets` table (`T1.id`).\n\n4. **Limit the output**: Only the top two sets (based on the alphabetical order of their IDs) are selected for the final output.\n\n5. **Select the columns**: The `name` and `id` columns from the `sets` table (`T1.name` and `T1.id`) are included in the output to list the names and IDs of the qualifying sets."
        ]
    },
    "1212": {
        "sql": "SELECT T1.Admission\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP < 300;",
        "question": "For patients with alkaliphophatase (ALP) within normal range, were they treated as inpatient or outpatient?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300",
        "explain": "alkaliphophatase (ALP) within normal range refers to ALP < 300; inpatient refers to admission = '+'; outpatient refers to admission = '-'",
        "solution": [
            "To answer the question about whether patients with alkaline phosphatase (ALP) within the normal range were treated as inpatients or outpatients, the following steps are performed:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (aliased as `T1`), which contains patient information including their admission type.\n   - `Laboratory` (aliased as `T2`), which contains laboratory test results, including the ALP values.\n\n2. **Join the Tables**: The tables are joined using the `ID` column, which links each patient to their corresponding laboratory results.\n\n3. **Filter the Data**: The query filters the results to include only those patients whose ALP values are below 300, which is considered the normal range for ALP.\n\n4. **Select the Admission Type**: Finally, the query retrieves the `Admission` column from the `Patient` table, which indicates whether the patient was treated as an inpatient or outpatient.\n\nThis process ensures that only patients with ALP within the normal range are considered, and their admission type is reported."
        ]
    },
    "81": {
        "sql": "SELECT T2.City, T1.\"Low Grade\", T1.\"School Name\"\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.State = 'CA'\nORDER BY T2.Latitude ASC\nLIMIT 1;",
        "question": "In which city can you find the school in the state of California with the lowest latitude coordinates and what is its lowest grade? Indicate the school name.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.City, T1.`Low Grade`, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.State = 'CA' ORDER BY T2.Latitude ASC LIMIT 1",
        "explain": "State of California refers to state = 'CA'",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Join the Tables**: Combine the `frpm` table (referred to as `T1`) and the `schools` table (referred to as `T2`) using the `CDSCode` field as the common key.\n\n2. **Filter by State**: From the joined tables, filter the records to include only those where the `State` field in the `schools` table (`T2`) is 'CA' (California).\n\n3. **Sort by Latitude**: Order the filtered records by the `Latitude` field in ascending order. This ensures the school with the lowest latitude (southernmost) appears first.\n\n4. **Select the Top Record**: Limit the result to the first record in the sorted list, which corresponds to the school with the lowest latitude in California.\n\n5. **Retrieve Required Information**: From this record, extract the `City` (from `T2`), the `Low Grade` (from `T1`), and the `School Name` (from `T1`).\n\nThis process will give you the city where the school is located, its lowest grade, and the school name for the school in California with the lowest latitude."
        ]
    },
    "836": {
        "sql": "SELECT COUNT(*) FROM superhero WHERE full_name LIKE 'John%';",
        "question": "What is the total number of superheroes that have John as their first name?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name LIKE 'John%'",
        "explain": "have John as their first name refers to full_name LIKE 'John%';",
        "solution": []
    },
    "482": {
        "sql": "SELECT DISTINCT T1.type FROM cards T1 INNER JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor\\'s Chosen' AND T2.language = 'German';",
        "question": "What's the German type of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German'",
        "explain": "German refers to language = 'German'; \"Ancestor's Chosen\" refers to name = 'Ancestor''s Chosen'",
        "solution": [
            "To find the German type of the card \"Ancestor's Chosen\", follow these steps:\n1. **Join the tables**: Combine the `cards` table (referred to as T1) with the `foreign_data` table (referred to as T2) using the `uuid` field as the common key.\n2. **Filter the data**: From the joined tables, select only the rows where:\n   - The `name` field in the `cards` table (T1) matches the card name \"Ancestor's Chosen\".\n   - The `language` field in the `foreign_data` table (T2) is set to \"German\".\n3. **Retrieve the result**: From the filtered data, extract the distinct values of the `type` field from the `cards` table (T1).\n\nThis process ensures that you get the unique type of the card \"Ancestor's Chosen\" as specified in the German language data.",
            "To determine the German type of the card \"Ancestor's Chosen\", execute the following steps:\n\n1. **Join the tables**: Perform an inner join between the `cards` table (aliased as T1) and the `foreign_data` table (aliased as T2) using the `uuid` field as the joining condition. This ensures that only rows with matching `uuid` values in both tables are included.\n\n2. **Apply filters**: Narrow down the joined dataset by applying the following conditions:\n   - The `name` column in the `cards` table (T1) must exactly match the string \"Ancestor's Chosen\".\n   - The `language` column in the `foreign_data` table (T2) must be set to \"German\".\n\n3. **Retrieve the result**: From the filtered dataset, select the distinct values of the `type` column from the `cards` table (T1). This ensures that only unique card types are returned, avoiding any duplicates.\n\nThis method guarantees that you obtain the correct and unique type of the card \"Ancestor's Chosen\" as recorded in the German language data."
        ]
    },
    "1086": {
        "sql": "SELECT pa.heading_accuracy FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE p.player_name = 'Ariel Borysiuk';",
        "question": "What's the heading accuracy of Ariel Borysiuk?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.heading_accuracy FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ariel Borysiuk'",
        "explain": "",
        "solution": [
            "To find the heading accuracy of Ariel Borysiuk, perform the following steps:\n1. Access the \"Player\" table to retrieve the player's details.\n2. Join the \"Player\" table with the \"Player_Attributes\" table using the \"player_api_id\" field to link the player's general information with their attributes.\n3. Filter the results to only include the record where the \"player_name\" is 'Ariel Borysiuk'.\n4. From the filtered result, select the \"heading_accuracy\" attribute from the \"Player_Attributes\" table to get the desired value."
        ]
    },
    "978": {
        "sql": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
        "question": "How many times the circuits were held in Austria? Please give their location and coordinates.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
        "explain": "location coordinates refers to (lat,lng); Austria refers to country = 'Austria';",
        "solution": [
            "To find out how many times the circuits were held in Austria along with their location and coordinates, the following steps are performed:\n\n1. **Filter the circuits**: The database is queried to select only those circuits where the country is 'Austria'.\n2. **Retrieve specific fields**: For each of these circuits, the location, latitude (lat), and longitude (lng) are retrieved.\n3. **Ensure uniqueness**: The results are filtered to ensure that each location and its coordinates are listed only once, even if they appear multiple times in the database.\n\nThis operation directly translates to the SQL query: `SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'`."
        ]
    },
    "470": {
        "sql": "SELECT DISTINCT T2.releaseDate FROM cards T1 INNER JOIN sets T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor\\'s Chosen';",
        "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "explain": "card set \"Ancestor's Chosen\" refers to name = 'Ancestor''s Chosen'; when released refers to releaseDate",
        "solution": [
            "To find out when the set of cards containing \"Ancestor's Chosen\" was released, follow these steps:\n\n1. **Identify the card**: Locate the card named \"Ancestor's Chosen\" in the `cards` table.\n2. **Join with the sets table**: Connect the `cards` table with the `sets` table using the `setCode` from the `cards` table and the `code` from the `sets` table.\n3. **Retrieve the release date**: From the joined tables, extract the `releaseDate` of the set that includes the card \"Ancestor's Chosen\".\n4. **Ensure uniqueness**: Use `DISTINCT` to avoid duplicate entries in the result.\n\nThe final output will be the release date of the set containing the card \"Ancestor's Chosen\".",
            "To determine the release date of the set containing the card \"Ancestor's Chosen\", follow these detailed steps:\n\n1. **Select the card**: Query the `cards` table (referred to as `T1`) to find the card with the name \"Ancestor's Chosen\".\n2. **Join with the sets table**: Perform an inner join between the `cards` table (`T1`) and the `sets` table (`T2`) using the `setCode` column from `T1` and the `code` column from `T2`. This links the card to its corresponding set.\n3. **Retrieve the release date**: From the joined result, extract the `releaseDate` column from the `sets` table (`T2`).\n4. **Ensure uniqueness**: Apply the `DISTINCT` keyword to the `releaseDate` to avoid duplicate entries in the output.\n\nThe final result will be the unique release date of the set that includes the card \"Ancestor's Chosen\"."
        ]
    },
    "760": {
        "sql": "SELECT \n    (COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_marvel\nFROM \n    superhero s\nLEFT JOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    s.height_cm BETWEEN 150 AND 180;",
        "question": "In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180",
        "explain": "height between 150 to 180 refers to height_cm BETWEEN 150 AND 180; heroes published by Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = MULTIPLY(DIVIDE(SUM(publisher.id = 13)), COUNT(publisher.id), 100)",
        "solution": []
    },
    "404": {
        "sql": "SELECT DISTINCT st.language\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.totalSetSize = 309;",
        "question": "Indicates the name of all the languages into which the set whose number of cards is 309 is translated.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.baseSetSize = 309",
        "explain": "set refer to setCode; number of cards refers to baseSetSize; baseSetsize = 309\n\n",
        "solution": []
    },
    "92": {
        "sql": "SELECT COUNT(DISTINCT d.district_id) AS number_of_districts\nFROM district d\nJOIN client c ON d.district_id = c.district_id\nWHERE c.gender = 'F' AND d.A11 > 6000 AND d.A11 < 10000;",
        "question": "List out the no. of districts that have female average salary is more than 6000 but less than 10000?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.district_id)  FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A11 BETWEEN 6000 AND 10000",
        "explain": "A11 refers to average salary; Female mapps to gender = 'F'",
        "solution": []
    },
    "828": {
        "sql": "SELECT COUNT(DISTINCT hero_id) AS fastest_superheroes_count\nFROM hero_attribute\nJOIN attribute ON hero_attribute.attribute_id = attribute.id\nWHERE attribute.attribute_name = 'Speed' AND hero_attribute.attribute_value = 100;",
        "question": "Count the fastest superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' AND T1.attribute_value = 100",
        "explain": "fastest refers to attribute_value = 100 WHERE attribute_name = 'Speed';",
        "solution": []
    },
    "381": {
        "sql": "SELECT DISTINCT c.artist\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Chinese Simplified';",
        "question": "List down the name of artists for cards in Chinese Simplified.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
        "explain": "Chinese Simplified' is the language;",
        "solution": []
    },
    "861": {
        "sql": "SELECT d.number FROM qualifying q JOIN drivers d ON q.driverId = d.driverId WHERE q.raceId = 903 AND q.q3 LIKE '1:54%';",
        "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'",
        "explain": "race number refers to raceId; finished 0:0M:SS in the Q3 refers to q3 LIKE 'M:SS%'",
        "solution": [
            "To find the driver's number who finished with a time of 0:01:54 in the Q3 of qualifying race No. 903, follow these steps:\n\n1. **Join the Tables**: Combine the `qualifying` table (referred to as T1) with the `drivers` table (referred to as T2) using the `driverId` field as the common key.\n\n2. **Filter by Race ID**: From the joined tables, filter the records to only include those where the `raceId` in the `qualifying` table is 903.\n\n3. **Filter by Q3 Time**: Further filter the records to include only those where the `q3` time in the `qualifying` table starts with '1:54' (indicating a time of 0:01:54).\n\n4. **Select the Driver's Number**: From the filtered results, retrieve the `number` field from the `drivers` table (T2), which represents the driver's number.\n\nThe final result will be the driver's number who met the specified criteria."
        ]
    },
    "818": {
        "sql": "SELECT (COUNT(CASE WHEN s.gender_id = 2 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female_bad_superheroes\nFROM superhero s\nWHERE s.alignment_id = 2;",
        "question": "Among the bad superheroes, what is the percentage of female superheroes?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Bad'",
        "explain": "bad superheroes refers to alignment.id = 2; percentage = MULTIPLY(DIVIDE(SUM(gender.id = 2 WHERE alignment.id = 2), COUNT(alignment.id = 2)), 100.0); female refers to gender.id = 2;",
        "solution": []
    },
    "276": {
        "sql": "SELECT c.atom_id, c.atom_id2\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '#';",
        "question": "Write down the atom IDs of the first and second atoms of triple bond type molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "explain": "first atom refers to atom_id; second atom refers to atom_id2; triple bond refers to bond_type = '#';",
        "solution": []
    },
    "531": {
        "sql": "SELECT DisplayName, Reputation FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = (SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon'))",
        "question": "Which user has a higher reputation, Harlan or Jarrod Dixon?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = ( SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') )",
        "explain": "\"Harlan\" and \"Jarrod Dixon\" are both DisplayName; highest reputation refers to Max(Reputation)",
        "solution": [
            "To determine which user has a higher reputation between Harlan and Jarrod Dixon, follow these steps:\n\n1. **Identify the Users**: First, locate the users with the display names 'Harlan' and 'Jarrod Dixon' in the database.\n\n2. **Retrieve Reputation Values**: For these two users, retrieve their reputation values from the database.\n\n3. **Find the Maximum Reputation**: Compare the reputation values of Harlan and Jarrod Dixon to determine the highest reputation among them.\n\n4. **Display the Result**: Finally, display the name of the user who has the highest reputation. If both have the same reputation, both names will be displayed.\n\nThis process ensures that the user with the higher reputation is identified accurately, mirroring the logic of the provided SQL query.",
            "To determine which user has a higher reputation between Harlan and Jarrod Dixon, follow these detailed steps:\n\n1. **Filter Users by Display Names**: Query the database to retrieve all records from the `users` table where the `DisplayName` is either 'Harlan' or 'Jarrod Dixon'.\n\n2. **Calculate Maximum Reputation**: Within the filtered subset of users, compute the maximum value of the `Reputation` attribute. This identifies the highest reputation score among the two users.\n\n3. **Identify Users with Maximum Reputation**: From the filtered users, select only those records where the `Reputation` matches the maximum reputation value calculated in the previous step. This ensures that only the user(s) with the highest reputation are included in the result.\n\n4. **Retrieve Display Names**: Extract and return the `DisplayName` of the user(s) identified in the previous step. If both users have the same reputation, both names will be returned.\n\nThis process mirrors the SQL query's logic by first narrowing down the users to Harlan and Jarrod Dixon, determining the highest reputation among them, and then displaying the name(s) of the user(s) with that reputation."
        ]
    },
    "657": {
        "sql": "SELECT u.DisplayName, u.WebsiteUrl\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE v.VoteTypeId = 8\nAND v.BountyAmount = (SELECT MAX(BountyAmount) FROM votes WHERE VoteTypeId = 8);",
        "question": "Under the vote type of 8, provide the display names and websites URLs of the user who got the highest bounty amount.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName, WebsiteUrl FROM users WHERE Id = ( SELECT UserId FROM votes WHERE VoteTypeId = 8 ORDER BY BountyAmount DESC LIMIT 1 )",
        "explain": "vote type of 8 refers to VoteTypeId = 8; the highest bounty amount refers to MAX(BountyAmount);",
        "solution": []
    },
    "996": {
        "sql": "SELECT COUNT(*) / 10.0 AS annual_average_races\nFROM races\nWHERE year BETWEEN 2000 AND 2010;",
        "question": "What is the annual average number of races held during the first 10 years of the 21st century?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 FROM races WHERE date BETWEEN '2000-01-01' AND '2010-12-31'",
        "explain": "races in date between '2000-01-01' and '2010-12-31'",
        "solution": [
            "To find the annual average number of races held during the first 10 years of the 21st century (from 2000 to 2010), follow these steps:\n\n1. **Filter the Races**: Identify all races that occurred between January 1, 2000, and December 31, 2010, by checking the `date` column in the `races` table.\n\n2. **Count the Races**: For each race, determine if its `year` falls within the range of 2000 to 2010. If it does, count it as 1; otherwise, count it as 0.\n\n3. **Sum the Counts**: Add up all the counts (1s and 0s) to get the total number of races held during this period.\n\n4. **Calculate the Average**: Divide the total number of races by 10 (the number of years in the period) to find the annual average. Ensure the division is done as a real number to get a precise decimal result.\n\nThe final result will be the annual average number of races held during the first 10 years of the 21st century."
        ]
    },
    "1085": {
        "sql": "SELECT p.player_name, pa.crossing\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone')\nORDER BY pa.crossing DESC\nLIMIT 1;",
        "question": "Which of these players performs the best in crossing actions, Alexis, Ariel Borysiuk or Arouna Kone?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name, t2.crossing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY t2.crossing DESC LIMIT 1",
        "explain": "player who perform best in crossing actions refers to MAX(crossing);",
        "solution": []
    },
    "1482": {
        "sql": "WITH segment_consumption AS (\n    SELECT \n        c.Segment,\n        SUM(CASE WHEN y.Date LIKE '2012%' THEN y.Consumption ELSE 0 END) AS consumption_2012,\n        SUM(CASE WHEN y.Date LIKE '2013%' THEN y.Consumption ELSE 0 END) AS consumption_2013\n    FROM \n        customers c\n    JOIN \n        yearmonth y ON c.CustomerID = y.CustomerID\n    WHERE \n        c.Segment IN ('SME', 'LAM', 'KAM')\n    GROUP BY \n        c.Segment\n),\npercentage_increase AS (\n    SELECT \n        Segment,\n        (consumption_2013 - consumption_2012) / consumption_2012 * 100 AS percentage_increase\n    FROM \n        segment_consumption\n    WHERE \n        consumption_2012 > 0\n)\nSELECT \n    Segment,\n    percentage_increase\nFROM \n    percentage_increase\nORDER BY \n    percentage_increase DESC\nLIMIT 1;\n\nSELECT \n    Segment,\n    percentage_increase\nFROM \n    percentage_increase\nORDER BY \n    percentage_increase ASC\nLIMIT 1;",
        "error": "something went wrong, tool did not call.",
        "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
        "explain": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
        "solution": [
            "To determine which of the three segments\u2014SME, LAM, and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013, follow these steps:\n\n1. **Calculate the total consumption for each segment in 2012 and 2013:**\n   - For the SME segment:\n     - Sum the consumption for SME in 2012 (where the date starts with '2012').\n     - Sum the consumption for SME in 2013 (where the date starts with '2013').\n   - For the LAM segment:\n     - Sum the consumption for LAM in 2012 (where the date starts with '2012').\n     - Sum the consumption for LAM in 2013 (where the date starts with '2013').\n   - For the KAM segment:\n     - Sum the consumption for KAM in 2012 (where the date starts with '2012').\n     - Sum the consumption for KAM in 2013 (where the date starts with '2013').\n\n2. **Compute the percentage increase for each segment:**\n   - For SME: Subtract the 2012 total from the 2013 total, divide by the 2012 total, and multiply by 100 to get the percentage increase.\n   - For LAM: Subtract the 2012 total from the 2013 total, divide by the 2012 total, and multiply by 100 to get the percentage increase.\n   - For KAM: Subtract the 2012 total from the 2013 total, divide by the 2012 total, and multiply by 100 to get the percentage increase.\n\n3. **Compare the percentage increases:**\n   - Identify the segment with the highest percentage increase (biggest increase).\n   - Identify the segment with the lowest percentage increase (lowest increase).\n\nThe SQL query performs these calculations by joining the `customers` table (T1) with the `yearmonth` table (T2) on the `CustomerID` field, filtering the data by segment and year, and then computing the percentage changes for each segment."
        ]
    },
    "309": {
        "sql": "SELECT a.atom_id, COUNT(DISTINCT b.bond_type) AS bond_type_count\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.molecule_id = 'TR346'\nGROUP BY a.atom_id;",
        "question": "List out the atom id that belongs to the TR346 molecule and how many bond type can be created by this molecule?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type),T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR000' GROUP BY T1.atom_id, T2.bond_type",
        "explain": "",
        "solution": [
            "To solve the question, we need to perform the following operations:\n\n1. **Select Data from the Atom Table**: Retrieve the `atom_id` and `molecule_id` from the `atom` table (referred to as `T1`).\n\n2. **Join with the Bond Table**: Join the `atom` table (`T1`) with the `bond` table (referred to as `T2`) using the `molecule_id` as the common key. This ensures we only consider bonds that belong to the same molecule as the atoms.\n\n3. **Filter for the Specific Molecule**: Apply a filter to only include records where the `molecule_id` is 'TR000'.\n\n4. **Group the Results**: Group the results by `atom_id` and `bond_type` to ensure each combination of atom and bond type is considered separately.\n\n5. **Count Distinct Bond Types**: For each group (i.e., each `atom_id` and `bond_type` combination), count the distinct `bond_type` values. This gives the number of unique bond types that can be created by the molecule for each atom.\n\n6. **Output the Results**: The final output will include the `atom_id`, the count of distinct `bond_type` values, and the `molecule_id` for each record.\n\nThis sequence of operations ensures that we list all atom IDs belonging to the 'TR000' molecule and count the distinct bond types associated with each atom in that molecule.",
            "To solve the question, we need to perform the following operations:\n\n1. **Select Data from the Atom Table**: Retrieve the `atom_id` and `molecule_id` from the `atom` table (referred to as `T1`).\n\n2. **Join with the Bond Table**: Join the `atom` table (`T1`) with the `bond` table (referred to as `T2`) using the `molecule_id` as the common key. This ensures we only consider bonds that belong to the same molecule as the atoms.\n\n3. **Filter for the Specific Molecule**: Apply a filter to only include records where the `molecule_id` is 'TR346' (as specified in the question).\n\n4. **Group the Results**: Group the results by `atom_id` and `bond_type` to ensure each combination of atom and bond type is considered separately.\n\n5. **Count Distinct Bond Types**: For each group (i.e., each `atom_id` and `bond_type` combination), count the distinct `bond_type` values. This gives the number of unique bond types that can be created by the molecule for each atom.\n\n6. **Output the Results**: The final output will include the `atom_id`, the count of distinct `bond_type` values, and the `molecule_id` for each record.\n\nThis sequence of operations ensures that we list all atom IDs belonging to the 'TR346' molecule and count the distinct bond types associated with each atom in that molecule."
        ]
    },
    "1188": {
        "sql": "SELECT ID FROM Patient WHERE SEX = 'F' AND strftime('%Y', Birthday) = '1964' AND Admission = '+';",
        "question": "How many female patients born in 1964 were admitted to the hospital? List them by ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT ID FROM Patient WHERE STRFTIME('%Y', Birthday) = '1964' AND SEX = 'F' AND Admission = '+'",
        "explain": "female refers to SEX = 'F'; born in 1964 refers to YEAR(Birthday) = 1964; admitted to the hospital refers to Admission = '+'",
        "solution": []
    },
    "522": {
        "sql": "SELECT c.name AS card_name, l.format AS banned_format\nFROM cards c\nLEFT JOIN legalities l ON c.uuid = l.uuid\nWHERE c.edhrecRank = 1 AND l.status = 'Banned';\n",
        "question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
        "explain": "ranked 1st on EDHRec refers to edhrecRank = 1; banned refers to status = 'Banned'; play format refers to format; cards name refers to name",
        "solution": []
    },
    "943": {
        "sql": "SELECT \n    (SUM(CASE WHEN T1.time IS NOT NULL THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS completion_rate\nFROM \n    results T1\nJOIN \n    races T2 ON T1.raceId = T2.raceId\nWHERE \n    T2.name = 'Australian Grand Prix' AND T2.year = 2008;",
        "question": "What is the rate of drivers completing all the laps in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.resultId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008",
        "explain": "completing all the laps refers to time is not null; rate = divide(COUNT(raceID where time is not null), COUNT(raceID))",
        "solution": [
            "To determine the rate of drivers who completed all the laps in the 2008 Australian Grand Prix, follow these steps:\n\n1. **Join the Tables**: Combine the `results` table (referred to as `T1`) with the `races` table (referred to as `T2`) using the `raceId` field to link them.\n\n2. **Filter the Data**: Narrow down the data to only include records where:\n   - The race name is 'Australian Grand Prix' (from the `races` table).\n   - The year of the race is 2008 (from the `races` table).\n\n3. **Calculate Completion Status**: For each driver in the filtered results:\n   - Check if the `time` field in the `results` table (`T1.time`) is not `NULL`. A non-`NULL` value indicates that the driver completed all the laps.\n   - Assign a value of 1 if the driver completed all the laps (i.e., `T1.time` is not `NULL`), otherwise assign 0.\n\n4. **Compute the Rate**:\n   - Sum the values assigned in the previous step (1 for completed laps, 0 otherwise) to get the total number of drivers who completed all the laps.\n   - Count the total number of drivers (using the `resultId` field in the `results` table).\n   - Divide the sum of completed laps by the total number of drivers and multiply by 100 to convert the result into a percentage.\n\n5. **Output the Result**: The final output is the percentage of drivers who completed all the laps in the 2008 Australian Grand Prix."
        ]
    },
    "864": {
        "sql": "SELECT COUNT(DISTINCT driverId) AS drivers_finished\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE date = '2015-11-29') AND time IS NOT NULL;",
        "question": "For the race happened on 2015/11/29, how many drivers finished the game?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "explain": "game and race are synonyms; drivers who finished the race should have record in time;",
        "solution": []
    },
    "986": {
        "sql": "SELECT T2.name AS race_name, T1.milliseconds AS fastest_first_lap_time\nFROM lapTimes T1\nJOIN races T2 ON T1.raceId = T2.raceId\nWHERE T1.lap = 1\nORDER BY T1.milliseconds ASC\nLIMIT 1;",
        "question": "In which race did the fastest 1st lap time was recorded? Please indicate the time in milliseconds.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.milliseconds FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.lap = 1 ORDER BY T1.time LIMIT 1",
        "explain": "fastest refers to Min(time);",
        "solution": [
            "To find the race where the fastest 1st lap time was recorded and indicate the time in milliseconds, follow these steps:\n\n1. **Join the Tables**: Combine the `lapTimes` table (referred to as `T1`) with the `races` table (referred to as `T2`) using the `raceId` field to link them.\n\n2. **Filter for 1st Lap**: From the joined tables, filter the records to include only those where the lap number (`T1.lap`) is equal to 1.\n\n3. **Sort by Lap Time**: Order the filtered records by the lap time (`T1.time`) in ascending order to find the fastest lap time at the top.\n\n4. **Retrieve the Fastest Time**: Select the top record from the sorted list to get the fastest 1st lap time.\n\n5. **Output the Time**: Display the time in milliseconds (`T1.milliseconds`) from the selected record.\n\nThis process ensures that you identify the race with the fastest 1st lap time and provide the corresponding time in milliseconds.",
            "To determine the race where the fastest 1st lap time was recorded and indicate the time in milliseconds, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `lapTimes` table (aliased as `T1`) and the `races` table (aliased as `T2`). The join condition is based on the `raceId` field, which links the two tables.\n\n2. **Filter for 1st Lap**: Apply a filter to the joined dataset to include only those records where the lap number (`T1.lap`) is exactly 1. This ensures that only the first lap times are considered.\n\n3. **Sort by Lap Time**: Sort the filtered records by the lap time (`T1.time`) in ascending order. This arrangement places the fastest lap time at the top of the list.\n\n4. **Retrieve the Fastest Time**: Select the topmost record from the sorted list to obtain the fastest 1st lap time.\n\n5. **Output the Time**: Extract and display the time in milliseconds (`T1.milliseconds`) from the selected record.\n\nThis method guarantees that you accurately identify the race with the fastest 1st lap time and provide the corresponding time in milliseconds."
        ]
    },
    "1438": {
        "sql": "SELECT m.college\nFROM member AS mem\nJOIN major AS m ON mem.link_to_major = m.major_id\nWHERE mem.first_name = 'Katy' AND mem.link_to_major = 'rec1N0upiVLy5esTO';",
        "question": "Please indicate the college of the person whose first name is Katy with the link to the major \"rec1N0upiVLy5esTO\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.link_to_major = 'rec1N0upiVLy5esTO' AND T1.first_name = 'Katy'",
        "explain": "",
        "solution": []
    },
    "248": {
        "sql": "SELECT c.atom_id, c.atom_id2\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE m.molecule_id = 'TR041' AND b.bond_type = '#';",
        "question": "What are the atoms of the triple bond with the molecule \"TR041\"?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'",
        "explain": "TR041 is the molecule id; triple bond refers to bond_type = '#';",
        "solution": [
            "To find the atoms involved in the triple bond for the molecule \"TR041\", follow these steps:\n\n1. **Identify the molecule**: Start by focusing on the molecule with the ID \"TR041\".\n\n2. **Locate the triple bonds**: Filter the bonds associated with this molecule to only include those of type \"#\" (which represents a triple bond).\n\n3. **Retrieve the connected atoms**: For each triple bond found, retrieve the pairs of atoms that are connected by these bonds. This involves:\n   - Joining the `atom` table with the `connected` table to link atoms to their connections.\n   - Further joining the `bond` table to filter for triple bonds and the specific molecule.\n\n4. **Extract the atom IDs**: From the connected pairs, extract the IDs of the atoms involved in each triple bond.\n\nThe result will be a list of atom pairs (atom_id and atom_id2) that form the triple bonds in the molecule \"TR041\"."
        ]
    },
    "100": {
        "sql": "SELECT COUNT(DISTINCT a.account_id) AS female_customers_before_1950_Sokolov\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nJOIN district di ON c.district_id = di.district_id\nWHERE c.gender = 'F'\nAND c.birth_date < '1950-01-01'\nAND di.A2 = 'Sokolov';",
        "question": "Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND STRFTIME('%Y', T2.birth_date) < '1950' AND T1.A2 = 'Sokolov'",
        "explain": "Customers refer to clients; Female refers to gender = 'F'; Names of districts appear in column A2",
        "solution": []
    },
    "1092": {
        "sql": "SELECT t1.name \nFROM League AS t1 \nJOIN Match AS t2 ON t1.id = t2.league_id \nWHERE t2.season = '2008/2009' \nGROUP BY t1.name \nHAVING COUNT(t2.id) = (\n    SELECT COUNT(t2.id) AS match_count \n    FROM League AS t1 \n    JOIN Match AS t2 ON t1.id = t2.league_id \n    WHERE t2.season = '2008/2009' \n    GROUP BY t1.name \n    ORDER BY match_count DESC \n    LIMIT 1\n);",
        "question": "Give the name of the league had the most matches in the 2008/2009 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
        "explain": "league that had the most matches in the 2008/2009 season refers to MAX(league_name WHERE season = '2008/2009');",
        "solution": [
            "To find the name of the league that had the most matches in the 2008/2009 season, follow these steps:\n\n1. **Join the League and Match tables**: Link the `League` table (aliased as `t1`) with the `Match` table (aliased as `t2`) using the `id` field from the `League` table and the `league_id` field from the `Match` table.\n\n2. **Filter for the 2008/2009 season**: Only include matches where the `season` field in the `Match` table is equal to '2008/2009'.\n\n3. **Group by league name**: Group the results by the `name` field from the `League` table to aggregate the data for each league.\n\n4. **Count matches per league**: For each league, count the number of matches (using the `id` field from the `Match` table).\n\n5. **Find the maximum match count**: Determine the highest number of matches any league had in the 2008/2009 season. This is done by:\n   - Counting matches per league (using the `league_id` field in the `Match` table).\n   - Finding the maximum value from these counts.\n\n6. **Filter for leagues with the maximum match count**: Only include leagues where the count of matches equals the maximum count identified in the previous step.\n\n7. **Return the league name**: The final result is the `name` of the league(s) that had the most matches in the 2008/2009 season."
        ]
    },
    "1404": {
        "sql": "SELECT T3.expense_description AS type, SUM(T3.cost) AS total_value\nFROM event T1\nJOIN budget T2 ON T1.event_id = T2.link_to_event\nJOIN expense T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'October Meeting' AND T3.approved = 'Yes'\nGROUP BY T3.expense_description;",
        "question": "Identify the type of expenses and their total value approved for 'October Meeting' event.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'",
        "explain": "total value refers to SUM(cost); 'October Meeting' is an event name;",
        "solution": [
            "To identify the type of expenses and their total value approved for the 'October Meeting' event, follow these steps:\n\n1. **Access the Event Table**: Start by retrieving the event details from the `event` table (referred to as `T1` in the SQL).\n\n2. **Filter for 'October Meeting'**: Narrow down the records to only include the event where the `event_name` is 'October Meeting'.\n\n3. **Join with Budget Table**: Link the filtered event records to the `budget` table (referred to as `T2` in the SQL) using the `event_id` from the event table and the `link_to_event` field in the budget table.\n\n4. **Join with Expense Table**: Further link the resulting records to the `expense` table (referred to as `T3` in the SQL) using the `budget_id` from the budget table and the `link_to_budget` field in the expense table.\n\n5. **Group by Expense Type**: Group the combined records by the `type` field from the expense table to categorize the expenses.\n\n6. **Calculate Total Cost**: For each expense type, sum the `cost` values from the expense table to determine the total value approved for that type.\n\n7. **Return Results**: The final output will display each expense type alongside the total cost for the 'October Meeting' event.",
            "To identify the type of expenses and their total value approved for the 'October Meeting' event, follow these detailed steps:\n\n1. **Access the Event Table**: Retrieve all records from the `event` table, which is referred to as `T1` in the SQL query.\n\n2. **Filter for 'October Meeting'**: Apply a filter to the `event` table to include only the record where the `event_name` is 'October Meeting'. This is done using the condition `T1.event_name = 'October Meeting'`.\n\n3. **Join with Budget Table**: Perform an inner join between the filtered `event` table (`T1`) and the `budget` table (`T2`). The join condition is `T1.event_id = T2.link_to_event`, which links the event to its associated budget records.\n\n4. **Join with Expense Table**: Perform another inner join between the resulting table (from the previous join) and the `expense` table (`T3`). The join condition is `T2.budget_id = T3.link_to_budget`, which links the budget to its associated expense records.\n\n5. **Group by Expense Type**: Group the combined records by the `type` field from the `expense` table (`T3.type`). This categorizes the expenses by their type.\n\n6. **Calculate Total Cost**: For each group (expense type), calculate the sum of the `cost` values from the `expense` table (`SUM(T3.cost)`). This gives the total value approved for each expense type.\n\n7. **Return Results**: The final output will display each expense type (`T1.type`) alongside the total cost (`SUM(T3.cost)`) for the 'October Meeting' event."
        ]
    },
    "225": {
        "sql": "SELECT DISTINCT b.molecule_id\nFROM bond b\nWHERE b.bond_type = '='\nORDER BY b.molecule_id ASC\nLIMIT 5;",
        "question": "Please list top five molecules that have double bonds in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id LIMIT 5",
        "explain": "double bond refers to bond_type = ' = ';",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter Bonds**: The database is queried to select all bonds where the bond type is a double bond (represented by '=').\n\n2. **Select Distinct Molecules**: From the filtered bonds, only distinct molecule IDs are selected to ensure each molecule is listed only once.\n\n3. **Order Alphabetically**: The distinct molecule IDs are then sorted in alphabetical order.\n\n4. **Limit Results**: Finally, the top five molecules from the sorted list are selected to provide the answer.\n\nThis process ensures that the result is a list of the top five molecules with double bonds, ordered alphabetically by their IDs."
        ]
    },
    "1115": {
        "sql": "WITH player_ratings AS (\n  SELECT \n    p.player_name,\n    pa.overall_rating\n  FROM \n    Player p\n  JOIN \n    Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id\n  WHERE \n    pa.date = '2013-07-12'\n    AND (p.player_name = 'Landon Donovan' OR p.player_name = 'Jordan Bowery')\n)\nSELECT \n  ((SUM(CASE WHEN player_name = 'Landon Donovan' THEN overall_rating ELSE 0 END) - \n    SUM(CASE WHEN player_name = 'Jordan Bowery' THEN overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN player_name = 'Landon Donovan' THEN overall_rating ELSE 0 END)) AS LvsJ_percent\nFROM \n  player_ratings;",
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "explain": "Landon Donovan's refers to player_name = 'Landon Donovan'; Jordan Bowery refers to player_name = 'Jordan Bowery'; percentage refers to DIVIDE(SUBTRACT(player_name = 'Landon Donovan' overall_rating; player_name = 'Jordan Bowery' overall_rating), player_name = 'Landon Donovan' overall_rating)*100",
        "solution": [
            "To determine what percentage Landon Donovan's overall rating is higher than Jordan Bowery's on July 12, 2013, follow these steps:\n\n1. **Retrieve Player Data**: Access the `Player` table to get the names of the players, Landon Donovan and Jordan Bowery.\n\n2. **Join with Player Attributes**: Link the `Player` table with the `Player_Attributes` table using the `player_fifa_api_id` to fetch the overall ratings of the players.\n\n3. **Filter by Date**: Narrow down the data to only include records from July 12, 2013, by checking the `date` field in the `Player_Attributes` table.\n\n4. **Calculate Ratings**:\n   - Sum the overall rating for Landon Donovan.\n   - Sum the overall rating for Jordan Bowery.\n\n5. **Compute Percentage Difference**:\n   - Subtract Jordan Bowery's total rating from Landon Donovan's total rating.\n   - Divide the result by Landon Donovan's total rating.\n   - Multiply by 100 to convert the result into a percentage.\n\n6. **Output the Result**: Display the calculated percentage as `LvsJ_percent`.",
            "To determine what percentage Landon Donovan's overall rating is higher than Jordan Bowery's on July 12, 2013, follow these detailed steps:\n\n1. **Retrieve Player Data**: Query the `Player` table to obtain the names of the players, specifically Landon Donovan and Jordan Bowery.\n\n2. **Join with Player Attributes**: Perform an inner join between the `Player` table and the `Player_Attributes` table using the `player_fifa_api_id` as the joining key. This ensures that the overall ratings of the players are linked to their respective names.\n\n3. **Filter by Date**: Apply a filter to the `Player_Attributes` table to include only records where the `date` field matches '2013-07-12'. This ensures the analysis is specific to the given date.\n\n4. **Calculate Ratings**: \n   - Use a `CASE` statement to sum the `overall_rating` for Landon Donovan. If the `player_name` is 'Landon Donovan', include the `overall_rating`; otherwise, include 0.\n   - Similarly, use another `CASE` statement to sum the `overall_rating` for Jordan Bowery. If the `player_name` is 'Jordan Bowery', include the `overall_rating`; otherwise, include 0.\n\n5. **Compute Percentage Difference**: \n   - Subtract the sum of Jordan Bowery's `overall_rating` from the sum of Landon Donovan's `overall_rating`.\n   - Divide the result by the sum of Landon Donovan's `overall_rating`.\n   - Multiply the quotient by 100 to convert it into a percentage.\n\n6. **Output the Result**: The final result is labeled as `LvsJ_percent` and represents the percentage by which Landon Donovan's overall rating is higher than Jordan Bowery's on the specified date.\n\nThe SQL query accomplishes this by combining these steps into a single query, ensuring accuracy and efficiency."
        ]
    },
    "1476": {
        "sql": "SELECT \n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'CZK' AND ym.Date LIKE '2012%') -\n    (SELECT SUM(ym.Consumption) \n     FROM yearmonth ym \n     JOIN customers c ON ym.CustomerID = c.CustomerID \n     WHERE c.Currency = 'EUR' AND ym.Date LIKE '2012%') AS ConsumptionDifference;",
        "question": "What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(T1.Currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.Currency = 'EUR', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2012'",
        "explain": "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year; Difference in Consumption = CZK customers consumption in 2012 - EUR customers consumption in 2012",
        "solution": []
    },
    "1006": {
        "sql": "SELECT time FROM lapTimes ORDER BY \n    CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS INTEGER) * 3600 + \n    CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS INTEGER) * 60 + \n    CAST(SUBSTR(time, INSTR(time, ':', INSTR(time, ':') + 1) + 1) AS REAL) \nLIMIT 1;",
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "explain": "",
        "solution": [
            "To find the time for the fastest lap record among all circuits, the following steps are performed:\n\n1. **Extract and Convert Time Components**: The SQL query processes the `time` field, which is in a string format, to convert it into a numerical value representing the total time in seconds. This involves:\n   - Extracting the hours, minutes, seconds, and milliseconds from the `time` string.\n   - Converting each extracted component into a numerical value.\n   - Calculating the total time in seconds by summing the converted values (hours * 3600 + minutes * 60 + seconds + milliseconds / 1000).\n\n2. **Order by Total Time**: The query orders the lap times in ascending order based on the calculated total time in seconds. This ensures that the fastest lap (smallest time) appears first.\n\n3. **Limit to Fastest Lap**: The query limits the result to the first row, which corresponds to the fastest lap time after ordering.\n\nThe final output is the `time` value of the fastest lap record.",
            "To determine the time for the fastest lap record among all circuits, the SQL query performs the following operations:\n\n1. **Parse and Convert Time String**: The `time` field, stored as a string, is parsed and converted into a numerical value representing the total time in seconds. This involves:\n   - **Extracting Hours**: If the time string contains two colons (indicating hours), the substring before the first colon is extracted and converted to a numerical value. This value is then multiplied by 3600 to convert hours to seconds.\n   - **Extracting Minutes**: The substring between the first and second colons (or the entire string if only one colon is present) is extracted and converted to a numerical value. This value is multiplied by 60 to convert minutes to seconds.\n   - **Extracting Seconds**: The substring after the last colon (or the entire string if no colon is present) is split at the decimal point. The part before the decimal is converted to a numerical value representing seconds.\n   - **Extracting Milliseconds**: The part after the decimal point is converted to a numerical value and divided by 1000 to convert milliseconds to seconds.\n\n2. **Sum Time Components**: The extracted hours, minutes, seconds, and milliseconds are summed to produce the total time in seconds.\n\n3. **Order by Total Time**: The lap times are ordered in ascending order based on the calculated total time in seconds, ensuring the fastest lap (smallest time) appears first.\n\n4. **Limit to Fastest Lap**: The query limits the result to the first row, which corresponds to the fastest lap time after ordering.\n\nThe final output is the `time` value of the fastest lap record."
        ]
    },
    "896": {
        "sql": "WITH hamilton_races AS (\n    SELECT ds.raceId, ds.position\n    FROM driverStandings ds\n    JOIN drivers d ON ds.driverId = d.driverId\n    JOIN races r ON ds.raceId = r.raceId\n    WHERE d.surname = 'Hamilton' AND r.year >= 2010\n),\ntotal_races AS (\n    SELECT COUNT(*) AS total\n    FROM hamilton_races\n),\nnon_first_races AS (\n    SELECT COUNT(*) AS non_first\n    FROM hamilton_races\n    WHERE position != 1\n)\nSELECT (non_first * 100.0 / total) AS percentage_not_first\nFROM non_first_races, total_races;",
        "question": "Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.surname = 'Hamilton' AND T1.year >= 2010",
        "explain": "percentage = DIVIDE(COUNT(raceId) where surname = 'Hamilton' and position>1), (COUNT(raceId) where surname = 'Hamilton'); since 2010 refers to year >= 2010",
        "solution": [
            "To calculate the percentage of times Hamilton was not in the 1st position at the first track of the F1 circuit since 2010, follow these steps:\n\n1. **Filter Races and Driver Data**:\n   - Select all races from the `races` table where the year is 2010 or later.\n   - Join these races with the `driverStandings` table using the `raceId` to get the standings for each race.\n   - Further join with the `drivers` table using the `driverId` to filter for the driver with the surname 'Hamilton'.\n\n2. **Count Total Races**:\n   - Count the total number of races Hamilton participated in since 2010 using the `driverStandingsId` from the `driverStandings` table.\n\n3. **Count Non-1st Position Races**:\n   - For each race, check if Hamilton's position (`position` in `driverStandings`) was not 1. Count these occurrences.\n\n4. **Calculate Percentage**:\n   - Divide the count of non-1st position races by the total number of races Hamilton participated in.\n   - Multiply the result by 100 to convert it to a percentage.\n   - Use `CAST` to ensure the division is performed as a floating-point operation for accuracy.\n\nThe final result is the percentage of races since 2010 where Hamilton was not in the 1st position at the first track of the F1 circuit."
        ]
    },
    "402": {
        "sql": "SELECT \n    (SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_no_text_box\nFROM \n    cards\nWHERE \n    isStorySpotlight = 1;",
        "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
        "explain": "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 0; Percentage = DIVIDE(SUM(count(id) where isStorylight = 1 AND isTextless = 0 ), SUM(count(id))) * 100",
        "solution": [
            "To solve the question, we need to calculate the percentage of Story Spotlight cards that do not have a text box. Here are the steps:\n\n1. **Filter the Data**: First, we filter the `cards` table to include only those cards where `isStorySpotlight` is equal to 1 (i.e., the cards are Story Spotlight cards).\n\n2. **Count the Total Cards**: We count the total number of these Story Spotlight cards by counting the `id` field.\n\n3. **Count the Cards Without Text Boxes**: Among these Story Spotlight cards, we count how many do not have a text box. This is done by summing the cases where `isTextless` is 0 (i.e., the card does not have a text box).\n\n4. **Calculate the Percentage**: We then calculate the percentage by dividing the count of cards without text boxes by the total count of Story Spotlight cards and multiplying by 100. The result is cast to a real number to ensure accurate division.\n\nThe final result is the percentage of Story Spotlight cards that do not have a text box."
        ]
    },
    "1183": {
        "sql": "SELECT p.Diagnosis\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE e.Diagnosis = 'SLE' AND e.`Examination Date` = '1997-01-27' AND p.`First Date` IS NOT NULL;",
        "question": "For the patient who was diagnosed SLE on 1997/1/27, what was his/her original diagnose when he/she came to the hospital for the first time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = ( SELECT ID FROM Examination WHERE `Examination Date` = '1997-01-27' AND Diagnosis = 'SLE' ) AND T2.`Examination Date` = T1.`First Date`",
        "explain": "'SLE' AND original diagnose refers to diagnosis; 1997/1/27 refer to `Examination Date` = '1997-01-27'; first came to the hospital refers to patient.`First Date`",
        "solution": []
    },
    "652": {
        "sql": "SELECT T1.PostId, T2.Name\nFROM postHistory T1\nINNER JOIN badges T2 ON T1.UserId = T2.UserId\nWHERE T1.UserDisplayName = 'Samuel'\nAND strftime('%Y', T1.CreationDate) = '2013'\nAND strftime('%Y', T2.Date) = '2013';",
        "question": "List the post IDs and badge names of the user Samuel in 2013.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.PostId, T2.Name FROM postHistory AS T1 INNER JOIN badges AS T2 ON T1.UserId = T2.UserId WHERE T1.UserDisplayName = 'Samuel' AND STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'",
        "explain": "Samuel refers to UserDisplayName; YEAR(CreationDate) = 2013 relates to PostId; YEAR(Date) = 2013 relates to the badge;",
        "solution": [
            "To list the post IDs and badge names of the user Samuel in 2013, follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables, `postHistory` (referred to as T1) and `badges` (referred to as T2).\n\n2. **Join the tables**: Perform an inner join between `postHistory` (T1) and `badges` (T2) using the `UserId` column as the common key. This ensures that only records with matching user IDs in both tables are included.\n\n3. **Filter by user name**: Apply a filter to include only records where the `UserDisplayName` in the `postHistory` table (T1) is 'Samuel'.\n\n4. **Filter by year for post history**: Further filter the records in the `postHistory` table (T1) to include only those where the year part of the `CreationDate` is '2013'.\n\n5. **Filter by year for badges**: Similarly, filter the records in the `badges` table (T2) to include only those where the year part of the `Date` field is '2013'.\n\n6. **Select the required columns**: Finally, retrieve the `PostId` from the `postHistory` table (T1) and the `Name` from the `badges` table (T2) for the filtered records.\n\nThis process ensures that only the post IDs and badge names of the user Samuel from the year 2013 are listed."
        ]
    },
    "822": {
        "sql": "SELECT COUNT(*) AS green_skinned_villains\nFROM superhero\nJOIN alignment ON superhero.alignment_id = alignment.id\nJOIN colour ON superhero.skin_colour_id = colour.id\nWHERE alignment.alignment = 'Bad' AND colour.colour = 'Green';",
        "question": "How many green-skinned villains are there in the superhero universe?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "explain": "green-skinned refers to colour.colour = 'Green' WHERE skin_colour_id = colour.id; villains refers to alignment = 'Bad';",
        "solution": []
    },
    "567": {
        "sql": "SELECT COUNT(*) AS post_count\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Tiago Pasqualini');",
        "question": "For the user with the display name of \"Tiago Pasqualini\", how many posts did he/she own?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Tiago Pasqualini'",
        "explain": "\"Tiago Pasqualini\" is the DisplayName;",
        "solution": []
    },
    "360": {
        "sql": "SELECT DISTINCT st.language FROM set_translations st JOIN cards c ON st.setCode = c.setCode WHERE c.name = 'Angel of Mercy';",
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "explain": "Angel of Mercy' is the name of card;",
        "solution": [
            "To find the languages available for the set that the card 'Angel of Mercy' belongs to, follow these steps:\n\n1. **Identify the set of the card**: First, locate the card named 'Angel of Mercy' in the 'cards' table and retrieve its associated 'id' (which corresponds to the set it belongs to).\n\n2. **Retrieve the languages for the set**: Using the 'id' obtained from the previous step, query the 'set_translations' table to find all the languages associated with that set.\n\n3. **Return the languages**: The result will be a list of languages available for the set containing the card 'Angel of Mercy'.",
            "To find the languages available for the set that the card 'Angel of Mercy' belongs to, follow these steps:\n\n1. **Query the 'cards' table**: Search for the card with the name 'Angel of Mercy' in the 'cards' table to retrieve its 'id', which corresponds to the set it belongs to.\n\n2. **Query the 'set_translations' table**: Use the 'id' obtained from the 'cards' table to query the 'set_translations' table. This will retrieve all the languages associated with the set identified by the 'id'.\n\n3. **Return the languages**: The result of the query will be a list of languages available for the set that contains the card 'Angel of Mercy'.\n\nThe SQL query for this operation is: `SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )`."
        ]
    },
    "1281": {
        "sql": "SELECT MAX(p.Birthday) AS YoungestBirthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GOT >= 60;",
        "question": "Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60 ORDER BY T1.Birthday DESC LIMIT 1",
        "explain": "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; The larger the birthday value, the younger the person is, and vice versa;",
        "solution": []
    },
    "1520": {
        "sql": "WITH TargetCustomer AS (\n    SELECT CustomerID\n    FROM transactions_1k\n    WHERE Price = 124.05 AND Date = '2012-08-24'\n)\nSELECT y.CustomerID, y.Date, y.Consumption AS Expenses\nFROM yearmonth y\nJOIN TargetCustomer t ON y.CustomerID = t.CustomerID\nWHERE y.Date LIKE '201201%';",
        "question": "For the customer who paid 124.05 in 2012/8/24, how much did he/she spend during the January of 2012? And what is the date and expenses exactly?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID, T2.Date, T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Price = 124.05 AND T2.Date = '201201'",
        "explain": "'2012/8/24' can be represented by '2012-08-24'; expense and the consumption has the similar meaning.",
        "solution": [
            "To solve the question, we need to find the customer who paid 124.05 on August 24, 2012, and then determine how much they spent during January 2012, along with the exact date and expenses for that month. Here are the steps:\n\n1. **Identify the Customer**: First, locate the customer in the `transactions_1k` table who made a payment of 124.05 on the date '2012-08-24'. This will give us the `CustomerID` of the target customer.\n\n2. **Retrieve January 2012 Data**: Using the `CustomerID` obtained from the first step, join the `yearmonth` table to find all transactions made by this customer in January 2012 (denoted by the date '201201').\n\n3. **Extract Relevant Information**: From the joined tables, select the `CustomerID`, the exact `Date`, and the `Consumption` (expenses) for the transactions in January 2012.\n\n4. **Filter and Display**: Ensure the results are filtered to only include the customer who paid 124.05 on August 24, 2012, and their transactions in January 2012.\n\nThe SQL query accomplishes this by joining the `transactions_1k` and `yearmonth` tables on the `CustomerID`, filtering for the specific payment on August 24, 2012, and the transactions in January 2012."
        ]
    },
    "815": {
        "sql": "SELECT COUNT(*) AS good_female_superheroes_count\nFROM superhero\nWHERE alignment_id = 1 AND gender_id = 2;",
        "question": "Count the good female superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Good' AND T3.gender = 'Female'",
        "explain": "good refers to alignment.id = 1; female refers to gender.id = 2;",
        "solution": []
    },
    "710": {
        "sql": "SELECT COUNT(T1.Id) AS ZeroScoreCommentsCount\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.CommentCount = 1 AND T1.Score = 0;",
        "question": "In posts with 1 comment, how many of the comments have 0 score?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
        "explain": "in posts with 1 comment refers to CommentCount = 1;",
        "solution": [
            "To solve the question, 'In posts with 1 comment, how many of the comments have 0 score?', follow these steps:\n\n1. **Join the tables**: Combine the `comments` table (aliased as `T1`) with the `posts` table (aliased as `T2`) using the `PostId` from `comments` and the `Id` from `posts`.\n\n2. **Filter posts with 1 comment**: From the joined tables, filter the rows where the `CommentCount` in the `posts` table (`T2`) is exactly 1.\n\n3. **Filter comments with 0 score**: Further filter the rows where the `Score` in the `posts` table (`T2`) is 0.\n\n4. **Count the comments**: Count the number of `id` values from the `comments` table (`T1`) that meet the above conditions.\n\nThe result will be the count of comments in posts that have exactly 1 comment and a score of 0.",
            "To solve the question, 'In posts with 1 comment, how many of the comments have 0 score?', follow these detailed steps:\n\n1. **Join the tables**: Perform an inner join between the `comments` table (aliased as `T1`) and the `posts` table (aliased as `T2`). The join condition is that the `PostId` column in the `comments` table (`T1`) must match the `Id` column in the `posts` table (`T2`). This ensures that each comment is linked to its corresponding post.\n\n2. **Filter posts with exactly 1 comment**: From the joined result, filter the rows where the `CommentCount` column in the `posts` table (`T2`) equals 1. This ensures that only posts with exactly one comment are considered.\n\n3. **Filter comments with a score of 0**: Further filter the rows where the `Score` column in the `posts` table (`T2`) equals 0. This ensures that only comments with a score of 0 are included in the count.\n\n4. **Count the qualifying comments**: Count the number of `id` values from the `comments` table (`T1`) that meet the above conditions. This count represents the number of comments in posts with exactly one comment and a score of 0.\n\nThe final result is the count of such comments."
        ]
    },
    "256": {
        "sql": "SELECT COUNT(atom_id) AS total_atoms FROM atom WHERE element IN ('c', 'h');",
        "question": "Calculate the total atoms consisting of the element carbon and hydrogen.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.element = 'c' OR T.element = 'h'",
        "explain": "consisting of element carbon and hydrogen refers to element in('c', 'h')",
        "solution": [
            "To calculate the total number of atoms consisting of the elements carbon ('c') and hydrogen ('h'), perform the following steps:\n\n1. Access the table named 'atom' and refer to it as 'T' for simplicity.\n2. Filter the rows in the 'atom' table where the 'element' column has the value 'c' (carbon) or 'h' (hydrogen).\n3. Count the number of 'atom_id' entries in the filtered rows to get the total number of atoms for these elements.\n\nThe result will be the total count of atoms that are either carbon or hydrogen."
        ]
    },
    "1353": {
        "sql": "SELECT z.type \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE m.first_name = 'Christof' AND m.last_name = 'Nielson';",
        "question": "What's Christof Nielson's zip code type?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.type FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Christof' AND T1.last_name = 'Nielson'",
        "explain": "",
        "solution": []
    },
    "1298": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nJOIN Examination E ON P.ID = E.ID \nWHERE L.`T-CHO` < 250 \nAND E.`ANA Pattern` = 'P';",
        "question": "Among the patients whose total cholesterol is within the normal range, how many of them have a P pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T3.`ANA Pattern` = 'P' AND T2.`T-CHO` < 250",
        "explain": "total cholesterol is within the normal range refers to `T-CHO` < 250; P pattern observed in the sheet of ANA examination refers to ANA Pattern = 'P';",
        "solution": [
            "To solve the question, we need to perform the following operations:\n\n1. **Identify Patients with Normal Cholesterol Levels**: Filter the patients whose total cholesterol (T-CHO) is below 250, as this is considered the normal range.\n\n2. **Check for ANA Examination Pattern**: Among these patients, further filter those who have a 'P' pattern observed in their ANA examination results.\n\n3. **Count the Matching Patients**: Finally, count the number of patients who meet both criteria.\n\nThese steps correspond to the SQL query, which joins the `Patient`, `Laboratory`, and `Examination` tables, applies the filters for normal cholesterol and 'P' pattern, and then counts the matching patient IDs.",
            "To solve the question, we need to perform the following detailed operations:\n\n1. **Join the Patient, Laboratory, and Examination Tables**: Combine the data from the `Patient`, `Laboratory`, and `Examination` tables using the patient ID (`ID`) as the common key. This ensures we have all relevant information for each patient in one dataset.\n\n2. **Filter Patients with Normal Cholesterol Levels**: From the joined dataset, filter out patients whose total cholesterol (`T-CHO`) is below 250, as this value is considered the upper limit of the normal range.\n\n3. **Filter Patients with 'P' Pattern in ANA Examination**: Among the patients with normal cholesterol levels, further filter those who have a 'P' pattern recorded in their ANA examination results (`ANA Pattern` = 'P').\n\n4. **Count the Matching Patients**: Finally, count the number of unique patient IDs (`ID`) that satisfy both conditions (normal cholesterol and 'P' pattern in ANA examination).\n\nThese steps directly correspond to the SQL query, which performs the joins, applies the filters, and counts the matching patient IDs."
        ]
    },
    "277": {
        "sql": "SELECT T1.element FROM atom T1 JOIN connected T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR000_1_2'",
        "question": "What are the toxicology elements associated with bond ID TR000_1_2?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR000_1_2'",
        "explain": "TR000_1_2 is the bond id;",
        "solution": [
            "To find the toxicology elements associated with bond ID 'TR000_1_2', perform the following steps:\n\n1. **Join the Tables**: Combine the 'atom' table (referred to as T1) with the 'connected' table (referred to as T2) using the 'atom_id' field as the common key.\n\n2. **Filter by Bond ID**: From the joined tables, filter the records to only include those where the 'bond_id' in the 'connected' table (T2) matches 'TR000_1_2'.\n\n3. **Select the Elements**: From the filtered records, extract the 'element' column from the 'atom' table (T1).\n\nThis will give you the list of toxicology elements associated with the specified bond ID."
        ]
    },
    "1300": {
        "sql": "SELECT e.Diagnosis\nFROM Laboratory l\nJOIN Examination e ON l.ID = e.ID\nWHERE l.TG < 200\nORDER BY l.TG DESC\nLIMIT 1;",
        "question": "What is the disease name of the patient who has the highest level of triglyceride within the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 ORDER BY T2.TG DESC LIMIT 1",
        "explain": "disease name referse to Diagnosis; highest level of triglyceride within the normal range refers to MAX(TG < 200);",
        "solution": []
    },
    "554": {
        "sql": "SELECT u.DisplayName\nFROM users u\nJOIN (\n    SELECT UserId, COUNT(*) AS badge_count\n    FROM badges\n    GROUP BY UserId\n) b ON u.Id = b.UserId\nORDER BY b.badge_count DESC\nLIMIT 1;",
        "question": "What is the display name of the user who has obtained the most number of badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id GROUP BY T2.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
        "explain": "who obtained the most number of badges refers to UserID with Max(Count(Id))",
        "solution": []
    },
    "548": {
        "sql": "SELECT u.Location\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Title = 'Eliciting priors from experts';",
        "question": "What is the location of the owner of the post \"Eliciting priors from experts\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'",
        "explain": "Owner refers to OwnerUserId; 'Eliciting priors from experts' is the Title of post",
        "solution": []
    },
    "617": {
        "sql": "SELECT T1.Text\nFROM comments T1\nJOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.CreationDate = '2010-07-19 19:37:33.0';",
        "question": "What is the detailed content of the comment of the post which was created on 7/19/2010 7:37:33 PM?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:37:33.0'",
        "explain": "detailed content of the comment refers to Text; created on 7/19/2010 7:37:33 PM CreationDate = 2010-07-19 19:37:33.0'",
        "solution": [
            "To find the detailed content of the comment for the post created on 7/19/2010 at 7:37:33 PM, follow these steps:\n\n1. **Join the tables**: Combine the `comments` table (referred to as `T1`) and the `posts` table (referred to as `T2`) using the `PostId` from the `comments` table and the `Id` from the `posts` table. This ensures that each comment is linked to its corresponding post.\n\n2. **Filter by creation date**: From the joined tables, filter the records to only include the comment where the `CreationDate` in the `comments` table matches the exact timestamp '2010-07-19 19:37:33.0'.\n\n3. **Retrieve the comment text**: Finally, extract the `Text` column from the filtered comment record in the `comments` table (`T1`). This will give you the detailed content of the comment for the specified post.",
            "To retrieve the detailed content of the comment for the post created on July 19, 2010, at 7:37:33 PM, follow these steps:\n\n1. **Join the tables**: Perform an inner join between the `comments` table (aliased as `T1`) and the `posts` table (aliased as `T2`). The join condition is `T1.PostId = T2.Id`, which links each comment to its corresponding post based on the post's unique identifier.\n\n2. **Filter by creation date**: Apply a filter to the joined tables to select only the comment where the `CreationDate` in the `comments` table (`T1`) exactly matches the timestamp '2010-07-19 19:37:33.0'.\n\n3. **Retrieve the comment text**: From the filtered result, extract the value of the `Text` column from the `comments` table (`T1`). This will provide the detailed content of the comment associated with the specified post creation date and time."
        ]
    },
    "354": {
        "sql": "SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "explain": "Aaron Boyd' is artist;",
        "solution": [
            "To determine how many types of cards the artist Aaron Boyd illustrated about card art, you need to count the distinct types of cards associated with the artist 'Aaron Boyd' in the 'cards' table. The SQL query retrieves this count by selecting the number of entries in the 'type' column where the 'artist' column matches 'Aaron Boyd'.",
            "To determine how many types of cards the artist Aaron Boyd illustrated about card art, follow these steps:\n\n1. **Identify the Table**: The data is stored in the 'cards' table.\n2. **Filter by Artist**: Narrow down the records to only those where the 'artist' column matches 'Aaron Boyd'.\n3. **Count Distinct Types**: For the filtered records, count the number of distinct entries in the 'type' column. This gives the total number of unique card types illustrated by Aaron Boyd.\n\nThe SQL query `SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'` directly translates to these operations."
        ]
    },
    "32": {
        "sql": "SELECT T1.`School Name`, (T1.`FRPM Count (K-12)` / T1.`Enrollment (K-12)`) AS `Eligible Rate`\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.SOC = '66'\nORDER BY T1.`FRPM Count (K-12)` DESC\nLIMIT 5;",
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "explain": "grades 1-12 means K-12; Eligible free or reduced price meal rate for K-12 = `FRPM Count (K-12)` / `Enrollment (K-12)`",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join Tables**: The `frpm` table (aliased as `T1`) is joined with the `schools` table (aliased as `T2`) using the `CDSCode` column as the common key.\n\n2. **Filter by Ownership Code**: Only records where the `SOC` (ownership code) in the `schools` table (`T2`) is equal to 66 are selected.\n\n3. **Calculate the Rate**: For each selected record, the eligible free or reduced price meal rate is calculated by dividing the `FRPM Count (K-12)` (cast as a real number) by the `Enrollment (K-12)` from the `frpm` table (`T1`).\n\n4. **Order by FRPM Count**: The results are ordered in descending order based on the `FRPM Count (K-12)` to prioritize schools with the highest counts.\n\n5. **Limit Results**: Only the top 5 records (schools) with the highest `FRPM Count (K-12)` are returned.\n\nThe final output is the calculated rate for these top 5 schools.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Table Join**: The `frpm` table (aliased as `T1`) is joined with the `schools` table (aliased as `T2`) using the `CDSCode` column as the common key. This ensures that data from both tables are combined based on matching school codes.\n\n2. **Filter by Ownership Code**: Only records where the `SOC` (ownership code) in the `schools` table (`T2`) is equal to 66 are selected. This filters the data to include only schools with the specified ownership code.\n\n3. **Calculate the Eligible Rate**: For each selected record, the eligible free or reduced price meal rate is calculated by dividing the `FRPM Count (K-12)` (cast as a real number to ensure accurate division) by the `Enrollment (K-12)` from the `frpm` table (`T1`). This rate represents the proportion of students eligible for free or reduced-price meals.\n\n4. **Order by FRPM Count**: The results are ordered in descending order based on the `FRPM Count (K-12)` column. This ensures that schools with the highest counts of free or reduced-price meal students appear first in the results.\n\n5. **Limit Results**: Only the top 5 records (schools) with the highest `FRPM Count (K-12)` are returned. This narrows down the output to the top 5 schools as requested.\n\nThe final output is the calculated eligible free or reduced price meal rate for these top 5 schools, providing the answer to the question."
        ]
    },
    "1466": {
        "sql": "SELECT T1.first_name || ' ' || T1.last_name AS full_name, T2.college\nFROM member T1\nINNER JOIN major T2 ON T2.major_id = T1.link_to_major\nWHERE T1.position = 'Secretary';",
        "question": "Write the full name of the club member with the position of 'Secretary' and list which college the club member belongs to.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T1.first_name, T1.last_name, college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Secretary'",
        "explain": "full name refers to first_name, last name",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Data**: Retrieve the `first_name`, `last_name`, and `college` columns from the database.\n2. **Join Tables**: Combine the `member` table (aliased as `T1`) with the `major` table (aliased as `T2`) using the condition `T2.major_id = T1.link_to_major`. This ensures that each member is linked to their respective major.\n3. **Filter Data**: Apply a filter to only include members where the `position` column in the `member` table is equal to 'Secretary'.\n\nThis sequence of operations will return the full name (first and last name) of the club member who holds the position of 'Secretary' and the college they belong to.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Select Data**: Retrieve the `first_name`, `last_name`, and `college` columns from the database. These columns are selected to provide the full name of the club member and the college they belong to.\n\n2. **Join Tables**: Perform an inner join between the `member` table (aliased as `T1`) and the `major` table (aliased as `T2`). The join condition is `T2.major_id = T1.link_to_major`, which links each member to their respective major based on the `link_to_major` field in the `member` table.\n\n3. **Filter Data**: Apply a filter to the `member` table (`T1`) to only include rows where the `position` column is equal to 'Secretary'. This ensures that only members holding the position of 'Secretary' are included in the results.\n\nThe result of these operations will be a list of records containing the full name (first and last name) of the club member(s) with the position 'Secretary' and the college they are associated with."
        ]
    },
    "1025": {
        "sql": "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2015/2016'\nGROUP BY l.name\nORDER BY SUM(m.home_team_goal + m.away_team_goal) DESC\nLIMIT 1;",
        "question": "Give the name of the league had the most goals in the 2016 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' GROUP BY t2.name ORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC LIMIT 1",
        "explain": "league that had the most goals refers to MAX(SUM(home_team_goal, away_team_goal)); 2016 season refers to season = '2015/2016';",
        "solution": [
            "To find the name of the league that had the most goals in the 2016 season, follow these steps:\n\n1. **Filter Matches for the 2016 Season**:\n   - Select all matches from the `Match` table where the `season` column is '2015/2016'.\n\n2. **Join with the League Table**:\n   - Join the filtered matches with the `League` table using the `league_id` from the `Match` table and the `id` from the `League` table. This links each match to its corresponding league.\n\n3. **Calculate Total Goals per League**:\n   - For each league, sum the total goals scored in all its matches. This is done by adding the `home_team_goal` and `away_team_goal` for each match and then summing these values for all matches in the league.\n\n4. **Group by League Name**:\n   - Group the results by the `name` column of the `League` table to aggregate the total goals for each league.\n\n5. **Order by Total Goals in Descending Order**:\n   - Sort the leagues in descending order based on the total goals calculated in the previous step. This places the league with the highest total goals at the top.\n\n6. **Select the Top League**:\n   - Limit the result to the first row to get the league with the most goals.\n\nThe final output will be the name of the league that had the most goals in the 2016 season."
        ]
    },
    "696": {
        "sql": "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers';",
        "question": "Count the number of posts with a tag specified as 'careers'.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers'",
        "explain": "tag specified as 'careers' refers to TagName = 'careers';",
        "solution": [
            "To count the number of posts with a tag specified as 'careers', you need to perform the following operations:\n\n1. **Access the table**: Use the table named `tags` which contains information about tags.\n2. **Filter the data**: Filter the records in the `tags` table to only include those where the `TagName` column has the value 'careers'.\n3. **Count the records**: Count the number of records that meet the filtering condition. This is done by counting the values in the `Id` column of the filtered records.\n\nThe result will be the total number of posts tagged with 'careers'."
        ]
    },
    "1407": {
        "sql": "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3",
        "question": "Among the budgets for Advertising, list out top three which have the most budgeted amount?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3",
        "explain": "MAX(amount) where category = 'Advertisement'",
        "solution": [
            "To solve the question, 'Among the budgets for Advertising, list out the top three which have the most budgeted amount?', the following steps are performed:\n\n1. **Filter the Budgets**: First, filter the budgets to only include those where the category is 'Advertisement'.\n2. **Sort by Amount**: Next, sort the filtered budgets in descending order based on the 'amount' field. This ensures that the budgets with the highest amounts appear first.\n3. **Limit the Results**: Finally, limit the results to the top three entries to get the three budgets with the highest amounts.\n\nThe SQL query accomplishes this by selecting the 'budget_id' from the 'budget' table where the category is 'Advertisement', ordering the results by 'amount' in descending order, and limiting the output to three records.",
            "To solve the question, 'Among the budgets for Advertising, list out the top three which have the most budgeted amount?', the following detailed steps are performed:\n\n1. **Filter by Category**: The database is queried to select only those records from the 'budget' table where the 'category' column matches the value 'Advertisement'. This ensures that only budgets related to advertising are considered.\n\n2. **Sort by Budgeted Amount**: The filtered records are then sorted in descending order based on the 'amount' column. This step arranges the advertising budgets from the highest to the lowest budgeted amount.\n\n3. **Limit to Top Three**: After sorting, the results are limited to the top three records. This provides the three advertising budgets with the highest amounts, as requested.\n\nThe SQL query that accomplishes this is: `SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3`."
        ]
    },
    "192": {
        "sql": "SELECT AVG(T2.amount) AS average_loan_amount\nFROM account T1\nJOIN loan T2 ON T1.account_id = T2.account_id\nWHERE T2.status IN ('C', 'D')\nAND T1.frequency = 'POPLATEK PO OBRATU';",
        "question": "What is the average amount of loan which are still on running contract with statement issuance after each transaction?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'",
        "explain": "status = 'C' stands for running contract, OK so far; status = 'D' stands for running contract, client in debt. 'POPLATEK PO OBRATU' stands for issuance after transaction",
        "solution": [
            "To find the average amount of loans that are still active (with status 'C' or 'D') and have accounts with a frequency of 'POPLATEK PO OBRATU', follow these steps:\n\n1. **Identify the relevant tables**: The data is spread across two tables, `account` (referred to as T1) and `loan` (referred to as T2).\n\n2. **Join the tables**: Combine the `account` and `loan` tables using the `account_id` field to link them. This ensures that each loan is matched with its corresponding account.\n\n3. **Filter the data**:\n   - From the `loan` table (T2), include only those loans where the `status` is either 'C' or 'D', indicating that the loan is still active.\n   - From the `account` table (T1), include only those accounts where the `frequency` is 'POPLATEK PO OBRATU', indicating the issuance of statements after each transaction.\n\n4. **Calculate the average**: Compute the average of the `amount` field from the filtered loans in the `loan` table (T2).\n\nThis process will yield the average loan amount for the specified conditions."
        ]
    },
    "734": {
        "sql": "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Blue Beetle II';",
        "question": "What is the publisher's name of Blue Beetle II?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Blue Beetle II'",
        "explain": "Blue Beetle II refers to superhero_name = 'Blue Beetle II'",
        "solution": []
    },
    "1277": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.DNA < 8 AND P.Description IS NULL;",
        "question": "How many patients have a normal anti-DNA level, yet their data are not recorded.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA < 8 AND T1.Description IS NULL",
        "explain": "normal anti-DNA level refers to DNA < 8; data are not recorded refers to Description IS NULL; Should compute the number of unique ones",
        "solution": []
    },
    "518": {
        "sql": "WITH MaxBanned AS (\n    SELECT format, COUNT(*) AS banned_count\n    FROM legalities\n    WHERE status = 'Banned'\n    GROUP BY format\n    ORDER BY banned_count DESC\n    LIMIT 1\n)\nSELECT T2.format, T1.name\nFROM cards T1\nJOIN legalities T2 ON T1.uuid = T2.uuid\nJOIN MaxBanned MB ON T2.format = MB.format\nWHERE T2.status = 'Banned';",
        "question": "Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
        "explain": "play format refers to format; banned status refers to status = 'Banned'; the highest number of banned status refers to MAX(COUNT(status = 'Banned'))",
        "solution": [
            "1. First, create a temporary table called `MaxBanned` that calculates the count of banned statuses for each play format. Group the results by the `format` column, order them in descending order based on the count, and limit the result to only the top row (the format with the highest number of banned statuses).\n\n2. Next, join the `cards` table (aliased as `T1`) with the `legalities` table (aliased as `T2`) using the `uuid` column as the join condition.\n\n3. Also, join the result with the `MaxBanned` temporary table (aliased as `MB`) on the `format` column to ensure only the format with the highest number of banned statuses is considered.\n\n4. Filter the results to include only rows where the `status` in the `legalities` table is 'Banned'.\n\n5. Finally, select the `format` from the `legalities` table and the `name` of the cards from the `cards` table that meet the above conditions."
        ]
    },
    "998": {
        "sql": "SELECT SUM(wins) AS total_victories FROM driverStandings WHERE points = 91;",
        "question": "In terms of number of points acquired, how many victories did the driver who ranked 91st acquired?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) FROM driverStandings",
        "explain": "victories refer to wins; 91st refers to points\n\n",
        "solution": [
            "To determine how many victories the driver who ranked 91st in terms of points acquired, follow these steps:\n\n1. **Identify the Driver with 91 Points**: Locate the driver(s) in the `driverStandings` table who have exactly 91 points.\n2. **Sum Their Wins**: For each driver found in the previous step, sum their total number of wins (`wins` column). If a driver does not have 91 points, their wins are not included in the sum (treated as 0).\n\nThe result will be the total number of victories achieved by the driver(s) who ranked 91st in terms of points."
        ]
    },
    "38": {
        "sql": "SELECT s.Website\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE s.County = 'Los Angeles'\nAND sc.NumTstTakr BETWEEN 2000 AND 3000;",
        "question": "What are the webpages for the Los Angeles County school that has between 2,000 and 3,000 test takers?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Website FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumTstTakr BETWEEN 2000 AND 3000 AND T2.County = 'Los Angeles'",
        "explain": "",
        "solution": []
    },
    "1074": {
        "sql": "SELECT t.team_short_name \nFROM Match m \nJOIN Team t ON m.home_team_api_id = t.team_api_id \nWHERE m.home_team_goal = 10;",
        "question": "List all the short name of the football team that had a home team goal of 10?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.team_short_name FROM Team AS t1 INNER JOIN Match AS t2 ON t1.team_api_id = t2.home_team_api_id WHERE t2.home_team_goal = 10",
        "explain": "short name of the football team refers to team_short_name; home team goal refers to home_team_goal; home_team_goal = 10;",
        "solution": []
    },
    "1304": {
        "sql": "SELECT COUNT(T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nJOIN Examination T3 ON T1.ID = T3.ID \nWHERE T2.GLU < 180 AND T3.Thrombosis = 0;",
        "question": "Among the patients with a normal blood glucose, how many of them don't have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.GLU < 180 AND T3.Thrombosis = 0",
        "explain": "normal blood glucose refers to GLU < 180; don't have thrombosis refers to Thrombosis = 0;",
        "solution": [
            "To solve the question, 'Among the patients with a normal blood glucose, how many of them don't have thrombosis?', the following steps are performed:\n\n1. **Join the Tables**: Combine the `Patient` table (`T1`), `Laboratory` table (`T2`), and `Examination` table (`T3`) using the patient ID (`ID`) as the common key.\n\n2. **Filter for Normal Blood Glucose**: From the joined data, filter out patients whose blood glucose level (`GLU`) is less than 180, indicating normal blood glucose.\n\n3. **Filter for No Thrombosis**: Further filter the results to include only those patients who do not have thrombosis (`Thrombosis = 0`).\n\n4. **Count the Patients**: Finally, count the number of patients who meet both criteria (normal blood glucose and no thrombosis).\n\nThe SQL query achieves this by joining the tables, applying the filters, and then counting the relevant patients.",
            "To solve the question, 'Among the patients with a normal blood glucose, how many of them don't have thrombosis?', the following detailed steps are performed:\n\n1. **Join the Tables**: \n   - Combine the `Patient` table (`T1`), `Laboratory` table (`T2`), and `Examination` table (`T3`) using the patient ID (`ID`) as the common key. This ensures all relevant data for each patient is linked together.\n\n2. **Filter for Normal Blood Glucose**: \n   - From the joined data, filter out patients whose blood glucose level (`GLU`) is less than 180. This condition (`T2.GLU < 180`) identifies patients with normal blood glucose levels.\n\n3. **Filter for No Thrombosis**: \n   - Further filter the results to include only those patients who do not have thrombosis. This is done by checking the `Thrombosis` column in the `Examination` table (`T3.Thrombosis = 0`).\n\n4. **Count the Patients**: \n   - Finally, count the number of patients who meet both criteria (normal blood glucose and no thrombosis) using the `COUNT(T1.ID)` function. This provides the total number of patients satisfying the conditions.\n\nThe SQL query achieves this by joining the tables, applying the filters, and then counting the relevant patients."
        ]
    },
    "1199": {
        "sql": "SELECT COUNT(DISTINCT ID) \nFROM Laboratory \nWHERE STRFTIME('%Y', Date) = '1997' \nAND (ALB <= 6.0 OR ALB >= 8.5);",
        "question": "How many patients who underwent testing in 1997 had protein levels outside the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(ID) FROM Laboratory WHERE (ALB <= 6.0 OR ALB >= 8.5) AND STRFTIME('%Y', Date) = '1997'",
        "explain": "underwent testing in 1997 refers to YEAR(DATE) = '1997'; protein levels within the normal range refers to tp > 6 and tp < 8.5",
        "solution": [
            "To solve the question, \"How many patients who underwent testing in 1997 had protein levels outside the normal range?\", the following steps are performed:\n\n1. **Filter by Year**: Identify all laboratory records from the year 1997. This is done by extracting the year from the \"Date\" column and checking if it matches \"1997\".\n\n2. **Check Protein Levels**: For each record from 1997, check if the albumin (ALB) levels are outside the normal range. The normal range for albumin is between 6.0 and 8.5. Records where ALB is less than or equal to 6.0 or greater than or equal to 8.5 are considered outside the normal range.\n\n3. **Count Patients**: Count the number of unique patient IDs (ID) that meet both criteria (year 1997 and abnormal ALB levels).\n\nThe final result is the count of such patients.",
            "To solve the question, \"How many patients who underwent testing in 1997 had protein levels outside the normal range?\", the following detailed steps are performed:\n\n1. **Filter by Year**: Extract the year from the \"Date\" column in the \"Laboratory\" table and filter records where the year is \"1997\". This is achieved using the `STRFTIME('%Y', Date)` function to format the date and compare it to the string \"1997\".\n\n2. **Check Protein Levels**: For each record filtered by the year 1997, evaluate the albumin (ALB) levels. The normal range for albumin is defined as between 6.0 and 8.5. Records where the ALB value is less than or equal to 6.0 (`ALB <= 6.0`) or greater than or equal to 8.5 (`ALB >= 8.5`) are identified as having protein levels outside the normal range.\n\n3. **Count Unique Patients**: Count the number of distinct patient IDs (ID) from the filtered records that meet both conditions (year 1997 and abnormal ALB levels). The `COUNT(ID)` function is used to aggregate this count.\n\nThe final result is the total count of unique patients who underwent testing in 1997 and had albumin levels outside the normal range."
        ]
    },
    "214": {
        "sql": "SELECT DISTINCT m.label\nFROM molecule m\nWHERE m.molecule_id NOT IN (\n  SELECT a.molecule_id\n  FROM atom a\n  WHERE a.element = 'tin'\n);",
        "question": "What type of label is not on molecules with atoms with tin?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "explain": "tin refers to element ! = 'sn'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "350": {
        "sql": "SELECT DISTINCT fd.language\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.name = 'Annul' AND c.number = '29';",
        "question": "State the alternative languages available for card named Annul numbered 29.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Annul' AND T1.number = 29",
        "explain": "annul refers to name = 'annul'; numbered 29 refers to number = '29';",
        "solution": []
    },
    "388": {
        "sql": "SELECT st.id, st.language FROM set_translations st WHERE st.setCode = '10E' AND st.id IN (SELECT c.id FROM cards c WHERE c.convertedManaCost = 5);",
        "question": "What are the cards in set 10E with converted mana of 5 have translation and what are the languages?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id, language FROM set_translations WHERE id = ( SELECT id FROM cards WHERE convertedManaCost = 5 ) AND setCode = '10E'",
        "explain": "set 10E refers to setCode = '10E'; converted mana of 5 refers to convertedManaCost = 5;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Subquery Execution**: First, the database retrieves the `id` of all cards from the `cards` table where the `convertedManaCost` is equal to 5.\n\n2. **Main Query Execution**: Using the `id` values obtained from the subquery, the database then queries the `set_translations` table to find all entries where the `id` matches any of the `id` values from the subquery and the `setCode` is '10E'.\n\n3. **Result Retrieval**: The final result includes the `id` and `language` columns from the `set_translations` table for the matching entries.\n\nThis ensures that only cards from the set '10E' with a converted mana cost of 5 and available translations are included in the result, along with the languages of those translations."
        ]
    },
    "1219": {
        "sql": "SELECT AVG(T2.UA) AS Average_UA_Index\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T1.SEX = 'F' AND T2.UA < 6.5) OR (T1.SEX = 'M' AND T2.UA < 8.0)\nAND T2.Date = (SELECT MAX(Date) FROM Laboratory WHERE ID = T1.ID);",
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "explain": "uric acid (UA) with normal range refers to UA < 8.0 and SEX = 'M' or UA < 6.5 and SEX = 'F'; average UA index refers to AVG(UA)",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Identify Patients with Normal Uric Acid (UA)**:\n   - For female patients (where `T1.SEX = 'F'`), normal UA is defined as less than 6.5 (`T2.UA < 6.5`).\n   - For male patients (where `T1.SEX = 'M'`), normal UA is defined as less than 8.0 (`T2.UA < 8.0`).\n\n2. **Retrieve Latest Laboratory Examination**:\n   - For each patient, only the most recent laboratory result is considered. This is determined by selecting the record with the maximum date (`T2.Date = (SELECT MAX(Date) FROM Laboratory)`).\n\n3. **Calculate the Average UA Index**:\n   - The average UA value (`AVG(T2.UA)`) is computed from the filtered results of the latest laboratory examinations for patients with normal UA levels.\n\n4. **Join Tables**:\n   - The `Patient` table (`T1`) is joined with the `Laboratory` table (`T2`) using the patient ID (`T1.ID = T2.ID`) to combine patient information with their laboratory results.\n\nThis process ensures that the average UA index is calculated only for patients with normal UA levels based on their most recent laboratory examination.",
            "To solve the question, the following detailed steps are performed:\n\n1. **Identify Patients with Normal Uric Acid (UA)**:\n   - Filter patients based on their sex and UA levels:\n     - For female patients (`T1.SEX = 'F'`), normal UA is defined as less than 6.5 (`T2.UA < 6.5`).\n     - For male patients (`T1.SEX = 'M'`), normal UA is defined as less than 8.0 (`T2.UA < 8.0`).\n\n2. **Retrieve Latest Laboratory Examination**:\n   - For each patient, only the most recent laboratory result is considered. This is determined by selecting the record where the date (`T2.Date`) matches the maximum date in the `Laboratory` table (`SELECT MAX(Date) FROM Laboratory`).\n\n3. **Calculate the Average UA Index**:\n   - Compute the average UA value (`AVG(T2.UA)`) from the filtered results of the latest laboratory examinations for patients with normal UA levels.\n\n4. **Join Tables**:\n   - The `Patient` table (`T1`) is joined with the `Laboratory` table (`T2`) using the patient ID (`T1.ID = T2.ID`) to combine patient information with their laboratory results.\n\nThis process ensures that the average UA index is calculated only for patients with normal UA levels based on their most recent laboratory examination."
        ]
    },
    "208": {
        "sql": "SELECT T2.label\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'h'\nGROUP BY T2.label\nORDER BY COUNT(DISTINCT T1.molecule_id) DESC\nLIMIT 1;",
        "question": "Which type of label is the most numerous in atoms with hydrogen?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t",
        "explain": "with hydrogen refers to element = 'h'; label most numerous in atoms refers to MAX(COUNT(label)); ",
        "solution": [
            "To determine which type of label is the most numerous in atoms with hydrogen, follow these steps:\n\n1. **Filter Atoms by Hydrogen**: First, identify all atoms where the element is hydrogen ('h').\n\n2. **Join with Molecules**: For each hydrogen atom, find the corresponding molecule by joining the atom table with the molecule table using the `molecule_id` field.\n\n3. **Group by Label**: Group the resulting molecules by their `label` attribute.\n\n4. **Count Molecules per Label**: For each label, count how many molecules contain hydrogen atoms.\n\n5. **Order by Count**: Sort the labels in descending order based on the count of molecules.\n\n6. **Select the Top Label**: Retrieve the label with the highest count of molecules containing hydrogen atoms.\n\nThe final result will be the label that appears most frequently among molecules with hydrogen atoms.",
            "To determine which type of label is the most numerous in atoms with hydrogen, follow these detailed steps:\n\n1. **Filter Atoms by Hydrogen**: Begin by selecting all atoms from the `atom` table where the `element` column is 'h' (hydrogen). This isolates all hydrogen atoms.\n\n2. **Join with Molecules**: For each hydrogen atom identified, join the `atom` table (`T1`) with the `molecule` table (`T2`) using the `molecule_id` field. This links each hydrogen atom to its corresponding molecule.\n\n3. **Group by Label**: After the join, group the resulting dataset by the `label` column from the `molecule` table (`T2`). This groups all molecules containing hydrogen atoms by their labels.\n\n4. **Count Molecules per Label**: For each label group, count the number of distinct `molecule_id` values. This gives the count of molecules with hydrogen atoms for each label.\n\n5. **Order by Count**: Sort the grouped labels in descending order based on the count of molecules. This places the label with the highest count at the top.\n\n6. **Select the Top Label**: Retrieve the label with the highest count by limiting the result to the first row. This ensures only the most numerous label is returned.\n\nThe final result is the label that appears most frequently among molecules containing hydrogen atoms."
        ]
    },
    "431": {
        "sql": "SELECT T1.name, T1.id FROM sets T1 JOIN set_translations T2 ON T1.code = T2.setCode WHERE T2.language = 'Japanese' AND T1.isFoilOnly = 1 AND T1.isForeignOnly = 0;",
        "question": "Which set is not available outside of the United States and has foil cards with Japanese writing on them? Please include the set ID in your response.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Japanese' AND T1.isFoilOnly = 1 AND T1.isForeignOnly = 0",
        "explain": "available outside of the United States refers to isForeignOnly = 1; has foil cards refers to isFoilOnly = 1; with Japanese writing on them refers to language = 'Japanese'",
        "solution": [
            "To solve the question, the database performs the following operations:\n\n1. **Join Tables**: It joins the `sets` table (aliased as `T1`) with the `set_translations` table (aliased as `T2`) using the condition `T1.code = T2.setCode`. This links each set with its translations.\n\n2. **Filter by Language**: It filters the results to include only those sets where the translation language is 'Japanese' (`T2.language = 'Japanese'`).\n\n3. **Filter by Foil Only**: It further filters the results to include only sets that are exclusively foil (`T1.isFoilOnly = 1`).\n\n4. **Filter by Availability**: It ensures the sets are not available outside the United States by checking `T1.isForeignOnly = 0`.\n\n5. **Select Columns**: Finally, it selects the `name` and `id` columns from the `sets` table (`T1.name, T1.id`) to display the set name and its ID.\n\nThe result will list all sets that meet these criteria: they have Japanese translations, are foil-only, and are not available outside the United States."
        ]
    },
    "1036": {
        "sql": "SELECT t.team_long_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE strftime('%Y', ta.date) = '2012'\nAND ta.buildUpPlayPassing > (\n    SELECT AVG(buildUpPlayPassing)\n    FROM Team_Attributes\n    WHERE strftime('%Y', date) = '2012'\n);",
        "question": "List the long name of teams with above-average build-up play passing in 2012.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t4.team_long_name FROM Team_Attributes AS t3 INNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTR(t3.`date`, 1, 4) = '2012' AND t3.buildUpPlayPassing > ( SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE STRFTIME('%Y',t2.`date`) = '2012')",
        "explain": "long name of teams refers to team_long_name; build-up play passing refers to buildUpPlayPassing; above-average build-up play passing = buildUpPlayPassing > DIVIDE(SUM(buildUpPlayPassing), COUNT(team_long_name) WHERE buildUpPlayPassing IS NOT NULL); in 2012 refers to strftime('%Y', date) = '2012'; ",
        "solution": []
    },
    "628": {
        "sql": "SELECT Id, DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users);",
        "question": "Which users have the highest number of views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id, DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "explain": "users have the highest number of views refer to DisplayName where MAX(Views);",
        "solution": [
            "To find the users with the highest number of views, follow these steps:\n\n1. **Identify the maximum number of views**: First, determine the highest number of views any user has by querying the maximum value in the `Views` column of the `users` table.\n\n2. **Retrieve the users with this maximum view count**: Using the identified maximum view count, select all users from the `users` table whose `Views` column matches this maximum value. For each matching user, retrieve their `Id` and `DisplayName`.\n\nThis ensures that only users with the highest number of views are included in the result."
        ]
    },
    "19": {
        "sql": "SELECT T1.Phone\nFROM schools T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nORDER BY T2.AvgScrMath DESC\nLIMIT 1;",
        "question": "What is the phone number of the school that has the highest average score in Math?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY T2.AvgScrMath DESC LIMIT 1",
        "explain": "",
        "solution": [
            "1. **Joining the schools and SAT scores data:**  \n   The query uses an `INNER JOIN` between two tables: `schools` (aliased as T1) and `satscores` (aliased as T2). These two tables are linked together using a common key, the `CDSCode` from the `schools` table and `cds` from the `satscores` table. This ensures that each school record is matched with its corresponding SAT score data.\n\n2. **Selecting the phone number:**  \n   From the `schools` table (T1), the query specifically selects the column `Phone`. This is the phone number of the school, which the question explicitly requests.\n\n3. **Ordering by average Math score:**  \n   The results are ordered based on the column `AvgScrMath` from the `satscores` table. The sorting is in descending order (`DESC`), so that the school with the highest average Math score appears at the top.\n\n4. **Limiting to the top result:**  \n   Finally, the query applies a `LIMIT 1`, which restricts the output to only the first record. This will be the school with the highest average Math score, and its phone number is returned."
        ]
    },
    "1413": {
        "sql": "SELECT DISTINCT m.zip\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost < 50;",
        "question": "Mention the zip code of member who incurred less than 50USD.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.zip FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.cost < 50",
        "explain": "incurred less than 50USD refers to cost < 50",
        "solution": []
    },
    "568": {
        "sql": "SELECT u.DisplayName\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE v.Id = 6347;",
        "question": "Provide the display name of the user who made the vote No.6347.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T2.Id = 6347",
        "explain": "vote no. 6347 refers to Id = '6347'",
        "solution": []
    },
    "1470": {
        "sql": "SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium';",
        "question": "How many gas stations in CZE has Premium gas?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium'",
        "explain": "",
        "solution": []
    },
    "1276": {
        "sql": "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.DNA >= 8;",
        "question": "For the patients who have an abnormal level of anti-DNA, please list the diseases they are diagnosed with.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT(T1.Diagnosis) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA >= 8",
        "explain": "abnormal level of anti-DNA refers to DNA > = 8; diseases refers to Diagnosis;",
        "solution": []
    },
    "788": {
        "sql": "SELECT (COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Female';",
        "question": "How many percent of female heroes were published by Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T3.gender = 'Female'",
        "explain": "percent = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100); female heroes refers to gender = 'Female'; Marvel Comics refers to publisher_name = 'Marvel Comics';",
        "solution": [
            "To determine the percentage of female heroes published by Marvel Comics, follow these steps:\n\n1. **Join the Tables**: Combine the `superhero` table (T1) with the `publisher` table (T2) using the `publisher_id` field in T1 and the `id` field in T2. Also, join the `superhero` table (T1) with the `gender` table (T3) using the `gender_id` field in T1 and the `id` field in T3.\n\n2. **Filter Female Heroes**: Apply a filter to include only those records where the `gender` field in the `gender` table (T3) is 'Female'.\n\n3. **Count Total Female Heroes**: Calculate the total number of female heroes by counting the `id` field in the `superhero` table (T1) for the filtered records.\n\n4. **Count Female Heroes Published by Marvel Comics**: Within the filtered records, count the number of heroes where the `publisher_name` field in the `publisher` table (T2) is 'Marvel Comics'. If the publisher is not 'Marvel Comics', the record is excluded from this count.\n\n5. **Calculate the Percentage**: Divide the count of female heroes published by Marvel Comics by the total count of female heroes. Multiply the result by 100 to convert it into a percentage.\n\n6. **Return the Result**: The final result is the calculated percentage of female heroes published by Marvel Comics."
        ]
    },
    "1257": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.CRE >= 1.5 \nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) < 70;",
        "question": "Among the patients whose creatinine level is abnormal, how many of them aren't 70 yet?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70",
        "explain": "creatinine level is abnormal refers to CRE >= 1.5; aren't 70 yet refers to SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) < 70; ",
        "solution": []
    },
    "969": {
        "sql": "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) = '1980';",
        "question": "How many British drivers who were born in 1980?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) = '1980'",
        "explain": "born in 1980 refers to year(dob) = 1980;",
        "solution": []
    },
    "804": {
        "sql": "SELECT superhero_name FROM superhero WHERE id = 294;",
        "question": "Provide the name of superhero with superhero ID 294.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero WHERE id = 294",
        "explain": "name of superhero refers to superhero_name; superhero ID 294 refers to superhero.id = 294;",
        "solution": []
    },
    "563": {
        "sql": "SELECT p.FavoriteCount\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE c.CreationDate = '2014-04-23 20:29:39.0'\nAND c.UserId = 3025;",
        "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.CreationDate = '2014-04-23 20:29:39.0' AND T2.UserId = 3025",
        "explain": "user no. 3025 refers to UserId = '3025'; comment at 20:29:39 on 2014/4/23 refers to CreationDate = '2014/4/23 20:29:39.0'",
        "solution": [
            "To find out how many favorite counts the post received that User No. 3025 commented on at 20:29:39 on 2014/4/23, follow these steps:\n\n1. **Join the tables**: Combine the `posts` table (referred to as T1) and the `comments` table (referred to as T2) using the `Id` column from the `posts` table and the `PostId` column from the `comments` table. This ensures that each comment is linked to its corresponding post.\n\n2. **Filter the comments**: From the joined tables, filter the records to only include comments where:\n   - The `CreationDate` of the comment is exactly '2014-04-23 20:29:39.0'.\n   - The `UserId` of the commenter is 3025.\n\n3. **Retrieve the favorite count**: For the filtered record(s), select the `FavoriteCount` column from the `posts` table (T1), which represents the number of favorite counts the post received.\n\nThis process ensures that you accurately retrieve the favorite count of the post associated with the specified comment."
        ]
    },
    "591": {
        "sql": "SELECT COUNT(DISTINCT UserId) AS NumberOfUsers\nFROM badges\nWHERE Name = 'Supporter' AND strftime('%Y', Date) = '2011';",
        "question": "How many users are awarded with supporter badge during year 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE STRFTIME('%Y', Date) = '2011' AND Name = 'Supporter'",
        "explain": "\"Supporter\" is the Name of badge; in year 2011 refers to year(Date) = 2011",
        "solution": []
    },
    "1499": {
        "sql": "SELECT MAX(monthly_consumption) AS biggest_monthly_consumption\nFROM (\n    SELECT T1.CustomerID, SUM(T2.Consumption) / 12 AS monthly_consumption\n    FROM customers T1\n    JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\n    WHERE T1.Currency = 'EUR'\n    GROUP BY T1.CustomerID\n) AS customer_consumption;",
        "question": "What is the biggest monthly consumption of the customers who use euro as their currency?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.Consumption) / 12 AS MonthlyConsumption FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY MonthlyConsumption DESC LIMIT 1",
        "explain": "Monthly consumption = SUM(consumption) / 12",
        "solution": [
            "To find the biggest monthly consumption of customers who use the euro (EUR) as their currency, follow these steps:\n\n1. **Join Tables**: Combine the `customers` table (referred to as T1) with the `yearmonth` table (referred to as T2) using the `CustomerID` field to link them.\n\n2. **Filter by Currency**: From the joined data, filter out only those customers whose currency is 'EUR'.\n\n3. **Calculate Monthly Consumption**: For each customer, calculate their average monthly consumption by summing up their total consumption from the `yearmonth` table and dividing it by 12 (to convert yearly consumption to monthly).\n\n4. **Group by Customer**: Group the results by `CustomerID` to ensure each customer's data is aggregated correctly.\n\n5. **Sort and Limit**: Sort the results in descending order of the calculated monthly consumption to find the highest value, and limit the output to just the top result (the biggest monthly consumption).\n\nThe final result will display the largest monthly consumption value among all customers who use the euro as their currency."
        ]
    },
    "416": {
        "sql": "SELECT (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM cards T1\nLEFT JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.power IS NULL OR T1.power = '*';",
        "question": "What percentage of cards without power are in French?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power = '*'",
        "explain": "in French refers to language = 'French'; cards without power refers to power IS NULL OR power = '*'; percentage = DIVIDE(COUNT(language = 'French' and power is NULL or power = '*'), COUNT( power is NULL or power = '*'))*100",
        "solution": [
            "To determine the percentage of cards without power that are in French, follow these steps:\n\n1. **Identify the tables involved**: The query uses two tables, `cards` (aliased as `T1`) and `foreign_data` (aliased as `T2`).\n\n2. **Join the tables**: The tables are joined using the `uuid` column, which is common to both tables. This ensures that each card in the `cards` table is matched with its corresponding entry in the `foreign_data` table.\n\n3. **Filter the cards**: Only cards where the `power` field is either `NULL` or `'*'` are considered. These are the cards \"without power.\"\n\n4. **Count the total cards**: The total number of cards without power is counted using `COUNT(T1.id)`.\n\n5. **Count the French cards**: Among the cards without power, count how many have their `language` field set to `'French'` in the `foreign_data` table. This is done using a `CASE` statement that returns `1` for French cards and `0` otherwise, and then summing these values.\n\n6. **Calculate the percentage**: Divide the count of French cards by the total count of cards without power, multiply by 100, and cast the result to a `REAL` number to ensure the division is floating-point.\n\nThe final result is the percentage of cards without power that are in French.",
            "To determine the percentage of cards without power that are in French, follow these detailed steps:\n\n1. **Identify the tables involved**: The query uses the `cards` table (aliased as `T1`) and the `foreign_data` table (aliased as `T2`).\n\n2. **Join the tables**: The tables are joined using the `uuid` column, which is common to both tables. This ensures that each card in the `cards` table is matched with its corresponding entry in the `foreign_data` table.\n\n3. **Filter the cards**: Only cards where the `power` field is either `NULL` or `'*'` are considered. These are the cards \"without power.\"\n\n4. **Count the total cards**: The total number of cards without power is counted using `COUNT(T1.id)`.\n\n5. **Count the French cards**: Among the cards without power, count how many have their `language` field set to `'French'` in the `foreign_data` table. This is done using a `CASE` statement that returns `1` for French cards and `0` otherwise, and then summing these values with `SUM`.\n\n6. **Calculate the percentage**: Divide the count of French cards by the total count of cards without power, multiply by 100, and cast the result to a `REAL` number to ensure the division is floating-point.\n\nThe final result is the percentage of cards without power that are in French."
        ]
    },
    "844": {
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.superhero_name = 'Blackwulf';",
        "question": "Give the eye colour of Blackwulf.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf'",
        "explain": "eye colour refers to colour.colour where eye_colour_id = colour.id; Blackwulf refers to superhero_name = 'Blackwulf';",
        "solution": []
    },
    "357": {
        "sql": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL;",
        "question": "What type of promotion is of card 'Duress'?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL",
        "explain": "card Duress refers to name = 'Duress'; type of promotion refers to promoTypes;",
        "solution": [
            "To find out what type of promotion is associated with the card named 'Duress', you need to retrieve the 'promoTypes' column from the 'cards' table where the 'name' column matches 'Duress' and the 'promoTypes' column is not null. This ensures that only valid promotion types for the card 'Duress' are returned."
        ]
    },
    "1411": {
        "sql": "SELECT e.expense_description\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison';",
        "question": "State what kind of expenses that Sacha Harrison incurred?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
        "explain": "kind of expenses refers to expense_description; Sacha Harrison is the full name; full name refers to first_name, last_name;",
        "solution": []
    },
    "1002": {
        "sql": "SELECT T1.forename || ' ' || T1.surname AS full_name, T1.nationality, T3.name AS first_race_name\nFROM drivers T1\nJOIN driverStandings T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nORDER BY JULIANDAY(T1.dob) DESC\nLIMIT 1;",
        "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
        "explain": "full name refers to forename+surname; Youngest racer = MAX(dob)",
        "solution": [
            "To find the full name of the youngest racer, along with her nationality and the name of the race she first joined, follow these steps:\n\n1. **Retrieve Driver Information**: Access the `drivers` table (aliased as `T1`) to get the racer's forename, surname, nationality, and date of birth (dob).\n\n2. **Join with Driver Standings**: Link the `drivers` table with the `driverStandings` table (aliased as `T2`) using the `driverId` field to connect the racer's details with their standings.\n\n3. **Join with Races**: Further join the result with the `races` table (aliased as `T3`) using the `raceId` field from the `driverStandings` table to get the name of the race the racer first joined.\n\n4. **Sort by Date of Birth**: Order the results by the racer's date of birth in descending order (using `JULIANDAY(T1.dob) DESC`) to ensure the youngest racer appears first.\n\n5. **Limit Results**: Restrict the output to only the first record (`LIMIT 1`) to get the youngest racer.\n\nThe final output will include the racer's forename, surname, nationality, and the name of the race she first joined.",
            "To determine the full name of the youngest racer, along with her nationality and the name of the race she first joined, the following steps are executed in the SQL query:\n\n1. **Select Data from Drivers Table**: The query retrieves the `forename`, `surname`, and `nationality` of the racer from the `drivers` table (aliased as `T1`).\n\n2. **Join with Driver Standings Table**: The `drivers` table is joined with the `driverStandings` table (aliased as `T2`) using the `driverId` field. This links the racer's personal details with their standings information.\n\n3. **Join with Races Table**: The result from the previous join is further joined with the `races` table (aliased as `T3`) using the `raceId` field from the `driverStandings` table. This provides the name of the race the racer first participated in.\n\n4. **Sort by Date of Birth**: The results are ordered by the racer's date of birth (`dob`) in descending order, calculated using `JULIANDAY(T1.dob) DESC`. This ensures the youngest racer (with the most recent date of birth) appears at the top.\n\n5. **Limit Results**: The query limits the output to the first record (`LIMIT 1`) to return only the youngest racer.\n\nThe final output includes the racer's full name (combining `forename` and `surname`), nationality, and the name of the race she first joined."
        ]
    },
    "61": {
        "sql": "SELECT COUNT(*) AS NumberOfCharteredSchools\nFROM schools\nWHERE City = 'Hickman' AND Charter = 1 AND DOC = '52';",
        "question": "How many chartered schools located in the city of Hickman are owned by the Elementary School District?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE DOC = 52 AND Charter = 1 AND City = 'Hickman'",
        "explain": "Elementary School District refers to DOC = 52; Chartered schools refer to Charter = 1 in the table schools",
        "solution": []
    },
    "364": {
        "sql": "SELECT l.status FROM legalities l JOIN cards c ON l.uuid = c.uuid WHERE c.name = 'Cloudchaser Eagle';",
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "explain": "Cloudchaser Eagle is the name of card;",
        "solution": []
    },
    "179": {
        "sql": "SELECT SUM(t.amount) AS total_payment\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN trans t ON d.account_id = t.account_id\nWHERE c.client_id = 617\nAND strftime('%Y', t.date) = '1998';",
        "question": "How much, in total, did client number 617 pay for all of the transactions in 1998?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT SUM(T3.amount) FROM client AS T1 INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date)= '1998' AND T1.client_id = 617",
        "explain": "",
        "solution": []
    },
    "862": {
        "sql": "SELECT COUNT(*) AS drivers_not_finished\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE name = 'Bahrain Grand Prix' AND year = 2007)\nAND time IS NULL;",
        "question": "For the Bahrain Grand Prix in 2007, how many drivers not finished the game?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2007 AND T1.name = 'Bahrain Grand Prix' AND T2.time IS NULL",
        "explain": "Bahrain Grand Prix refers to races.name = 'Bahrain Grand Prix'; drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL);",
        "solution": []
    },
    "649": {
        "sql": "SELECT T1.Id, T2.LastEditDate FROM postHistory T1 JOIN posts T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'",
        "question": "Describe the post history counts and last edit date of the post title \"What is the best introductory Bayesian statistics textbook?\"",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Id, T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'",
        "explain": "",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join Tables**: The `postHistory` table (aliased as `T1`) is joined with the `posts` table (aliased as `T2`) using the condition `T1.PostId = T2.Id`. This ensures that only records where the `PostId` in `postHistory` matches the `Id` in `posts` are considered.\n\n2. **Filter by Title**: The joined records are filtered to include only those where the `Title` in the `posts` table (aliased as `T2`) is exactly \"What is the best introductory Bayesian statistics textbook?\".\n\n3. **Select Columns**: From the filtered and joined records, the `Id` column from the `postHistory` table (aliased as `T1`) and the `LastEditDate` column from the `posts` table (aliased as `T2`) are selected for the final output.\n\nThis sequence of operations ensures that the result includes the post history IDs and the last edit dates for the specified post title."
        ]
    },
    "209": {
        "sql": "SELECT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'cl'\nGROUP BY b.bond_type;",
        "question": "Chlorine is in what type of bond?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T3.element = 'cl'",
        "explain": "type of bond refers to bond_type; chlorine refers to element = 'cl'",
        "solution": []
    },
    "1293": {
        "sql": "SELECT MAX(e.ANA) AS Highest_ANA\nFROM Examination e\nJOIN Laboratory l ON e.ID = l.ID\nWHERE l.CRE < 1.5;",
        "question": "What is the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.ANA FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 ORDER BY T2.ANA DESC LIMIT 1",
        "explain": "highest anti-nucleus antibody concentration level refers to MAX(ANA); normal creatinine level refers to CRE < 1.5;",
        "solution": []
    },
    "325": {
        "sql": "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '+' AND a.element = 'n';",
        "question": "How many carcinogenic molecules that consisted of Nitrogen?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'n' AND T1.label = '+'",
        "explain": "nitrogen refers to element = 'n'; label = '+' mean molecules are carcinogenic;",
        "solution": []
    },
    "1161": {
        "sql": "SELECT AVG(e.\"aCL IgG\") AS \"Average aCL IgG Concentration\"\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Admission = '+' AND (strftime('%Y', 'now') - strftime('%Y', p.Birthday)) >= 50;",
        "question": "For in-patient age 50 and above, what is their average anti-cardiolipin antibody (IgG) concentration?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.`aCL IgG`) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 AND T1.Admission = '+'",
        "explain": "in-patient refers to Admission = '+'; age 50 and above refers to SUBTRACT(year(current_timestamp), year(Birthday)) >= '50'; average anti-cardiolipin antibody (IgG) concentration refers to AVG(aCL IgG)",
        "solution": []
    },
    "1067": {
        "sql": "SELECT t.team_short_name\nFROM Team t\nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id\nWHERE ta.buildUpPlayPassing > 70;",
        "question": "Which teams have build up play passing more than 70? Please list their short names.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayPassing > 70",
        "explain": "build up play passing refers to buildUpPlayPassing; buildUpPlayPassing > 70; short names refers to team_short_name;",
        "solution": []
    },
    "1010": {
        "sql": "SELECT T1.time\nFROM lapTimes T1\nJOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton';",
        "question": "What is the lap record set by Lewis Hamilton in a Formula_1 race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.time FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'",
        "explain": "lap recod means the fastest time recorded which refers to time",
        "solution": [
            "To find the lap record set by Lewis Hamilton in a Formula 1 race, follow these steps:\n\n1. **Join the Tables**: Combine the `lapTimes` table (referred to as `T1`) with the `drivers` table (referred to as `T2`) using the `driverId` field. This ensures that the lap times are linked to the correct driver.\n\n2. **Filter for Lewis Hamilton**: From the joined tables, filter the records to only include those where the driver's first name (`forename`) is 'Lewis' and the last name (`surname`) is 'Hamilton'.\n\n3. **Retrieve the Lap Time**: From the filtered records, select the `time` field from the `lapTimes` table (`T1`), which represents the lap record set by Lewis Hamilton.\n\nThis process ensures that you accurately retrieve the lap record for Lewis Hamilton from the database."
        ]
    },
    "1356": {
        "sql": "SELECT m.department\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'President';",
        "question": "Which department was the President of the club in?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'President'",
        "explain": "'President' is a position of Student Club",
        "solution": []
    },
    "1173": {
        "sql": "SELECT T2.Diagnosis, COUNT(T2.Diagnosis) AS DiagnosisCount\nFROM Examination T1\nJOIN Patient T2 ON T1.ID = T2.ID\nWHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.Diagnosis\nORDER BY DiagnosisCount DESC\nLIMIT 1;",
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "explain": "the most common illness refers to MAX(COUNT(Diagnosis)); lab work between 1/1/1985 and 12/31/1995 refers to `Examination Date` between '1985-01-01' and '1995-12-31 '",
        "solution": [
            "To find the most common illness that doctors identified among the patients whose lab work was done between January 1, 1985, and December 31, 1995, follow these steps:\n\n1. **Join the Examination and Patient tables**: Link the records from the Examination table with the corresponding records in the Patient table using the patient ID as the common key.\n\n2. **Filter the examination dates**: Select only those records where the examination date falls within the specified range (from January 1, 1985, to December 31, 1995).\n\n3. **Group the results by diagnosis**: Organize the filtered records into groups based on the diagnosis listed in the Patient table.\n\n4. **Count the occurrences of each diagnosis**: For each diagnosis group, count how many times it appears in the filtered records.\n\n5. **Order the results by count in descending order**: Arrange the diagnosis groups from the most frequently occurring to the least.\n\n6. **Select the top result**: Retrieve the diagnosis that appears most frequently among the filtered records.\n\nThe final result will be the most common illness identified during the specified time period.",
            "To determine the most common illness that doctors identified among patients whose lab work was done between January 1, 1985, and December 31, 1995, follow these detailed steps:\n\n1. **Join the Examination and Patient tables**: Combine the records from the `Examination` table (aliased as `T1`) with the records from the `Patient` table (aliased as `T2`) using the `ID` field as the common key. This ensures that each examination record is linked to its corresponding patient record.\n\n2. **Filter the examination dates**: From the joined tables, select only those records where the `Examination Date` (from the `Examination` table) falls within the specified date range of January 1, 1985, to December 31, 1995. This is done using the `BETWEEN` clause to include all dates within this range.\n\n3. **Group the results by diagnosis**: Organize the filtered records into groups based on the `Diagnosis` field from the `Patient` table. Each group will represent a unique illness identified by the doctors.\n\n4. **Count the occurrences of each diagnosis**: For each diagnosis group, count the number of records (i.e., the frequency of each diagnosis) using the `COUNT` function applied to the `Diagnosis` field.\n\n5. **Order the results by count in descending order**: Arrange the diagnosis groups in descending order based on their count values. This ensures that the most frequently occurring diagnosis appears at the top of the list.\n\n6. **Select the top result**: Retrieve the diagnosis with the highest count by limiting the result set to the first row using the `LIMIT 1` clause.\n\nThe final output will be the most common illness identified among patients whose lab work was conducted during the specified time period."
        ]
    },
    "1134": {
        "sql": "SELECT \n    (SELECT COALESCE(SUM(jumping), 0) FROM Player_Attributes WHERE id = 6) - \n    (SELECT COALESCE(SUM(jumping), 0) FROM Player_Attributes WHERE id = 23) AS jumping_difference;",
        "question": "What is the difference between players 6 and 23's jumping scores?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) FROM Player_Attributes AS t1",
        "explain": "difference between players 6 and 23's jumping scores refers to SUBTRACT(jumping AND id = 6,jumping AND id = 23)",
        "solution": [
            "To find the difference between the jumping scores of players with IDs 6 and 23, follow these steps:\n\n1. **Retrieve the jumping scores**: Access the `Player_Attributes` table to get the jumping scores for the players.\n\n2. **Filter for player 6**: Sum the jumping score for the player with ID 6. If the player's ID is not 6, treat the jumping score as 0.\n\n3. **Filter for player 23**: Sum the jumping score for the player with ID 23. If the player's ID is not 23, treat the jumping score as 0.\n\n4. **Calculate the difference**: Subtract the summed jumping score of player 23 from the summed jumping score of player 6 to get the difference.\n\nThe result will be the difference in jumping scores between players 6 and 23.",
            "To determine the difference between the jumping scores of players with IDs 6 and 23, execute the following steps:\n\n1. **Access the Player_Attributes table**: This table contains the jumping scores for all players.\n\n2. **Identify the jumping score for player 6**:\n   - Scan the table for the row where the `id` column equals 6.\n   - Extract the `jumping` score from this row. If no such row exists, treat the jumping score as 0.\n   - Sum all such jumping scores for player 6.\n\n3. **Identify the jumping score for player 23**:\n   - Scan the table for the row where the `id` column equals 23.\n   - Extract the `jumping` score from this row. If no such row exists, treat the jumping score as 0.\n   - Sum all such jumping scores for player 23.\n\n4. **Calculate the difference**:\n   - Subtract the summed jumping score of player 23 from the summed jumping score of player 6.\n\nThis calculation yields the difference in jumping scores between players 6 and 23."
        ]
    },
    "246": {
        "sql": "SELECT b.bond_type, b.bond_id\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE SUBSTR(a.atom_id, 7, 2) + 0 = 45;",
        "question": "List the bond type and the bond ID of the atom 45.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type, T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE SUBSTR(T2.atom_id, 7, 2) = '45'",
        "explain": "bond ID of atom 45 refers to SUBSTR(atom_id, 7, 2) + 0 = 45; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
        "solution": []
    },
    "114": {
        "sql": "SELECT T1.account_id\nFROM account T1\nJOIN district T2 ON T1.district_id = T2.district_id\nWHERE T2.A3 = 'Prague'\nORDER BY T1.date ASC\nLIMIT 1;",
        "question": "For the first client who opened his/her account in Prague, what is his/her account ID?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'Prague' ORDER BY T1.date ASC LIMIT 1",
        "explain": "A3 stands for region names",
        "solution": [
            "To find the account ID of the first client who opened an account in Prague, follow these steps:\n\n1. **Join the Tables**: Combine the `account` table (referred to as `T1`) with the `district` table (referred to as `T2`) using the `district_id` field as the common key.\n\n2. **Filter by Location**: From the joined tables, filter the records to include only those where the `A3` column in the `district` table (`T2`) has the value 'Prague'.\n\n3. **Sort by Date**: Order the filtered records by the `date` column in the `account` table (`T1`) in ascending order to ensure the earliest account opening date comes first.\n\n4. **Retrieve the First Record**: Limit the result to the first record in the sorted list to get the account with the earliest opening date in Prague.\n\n5. **Select the Account ID**: Finally, extract the `account_id` from the selected record.\n\nThis process ensures you retrieve the account ID of the first client who opened an account in Prague."
        ]
    },
    "985": {
        "sql": "SELECT T1.driverId\nFROM lapTimes T1\nJOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.name = 'French Grand Prix' AND T1.lap = 3\nORDER BY T1.time DESC\nLIMIT 1;",
        "question": "Among the drivers who participated in the French Grand Prix, who has the slowest time in the 3rd lap.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.driverId FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'French Grand Prix' AND T1.lap = 3 ORDER BY T1.time DESC LIMIT 1",
        "explain": "slowest time refers to Max(time);",
        "solution": [
            "To find the driver with the slowest time in the 3rd lap among those who participated in the French Grand Prix, follow these steps:\n\n1. **Join the Tables**: Combine the `lapTimes` table (aliased as `T1`) with the `races` table (aliased as `T2`) using the `raceId` field to link them. This ensures we only consider lap times from the French Grand Prix.\n\n2. **Filter for the French Grand Prix**: From the joined tables, filter the records to include only those where the race name is 'French Grand Prix'.\n\n3. **Filter for the 3rd Lap**: Further narrow down the records to include only lap times from the 3rd lap.\n\n4. **Sort by Time in Descending Order**: Arrange the filtered lap times in descending order based on the `time` field. This places the slowest time at the top of the list.\n\n5. **Select the Top Result**: Retrieve the `driverId` of the first record in the sorted list, which corresponds to the driver with the slowest time in the 3rd lap of the French Grand Prix."
        ]
    },
    "1416": {
        "sql": "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Business' AND member.t_shirt_size = 'Medium';",
        "question": "How many members of Business have the Medium size of tee shirt?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business' AND T2.t_shirt_size = 'Medium'",
        "explain": "members of Economics refers to major_name = 'Business'; t_shirt_size = 'Medium'",
        "solution": []
    },
    "109": {
        "sql": "SELECT COUNT(DISTINCT T1.client_id) AS female_clients_count\nFROM client T1\nJOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F' AND T2.A2 = 'Jesenik';",
        "question": "How many clients opened their accounts in Jesenik branch were women?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'",
        "explain": "A2 has region names; Woman and female share the same meaning; female refers to gender = 'F'",
        "solution": [
            "To determine how many clients who opened their accounts in the Jesenik branch are women, follow these steps:\n\n1. **Join the Tables**: Combine the `client` table (referred to as `T1`) with the `district` table (referred to as `T2`) using the `district_id` field. This links each client to their respective district.\n\n2. **Filter by Gender and District**: From the joined tables, filter the records to include only those where:\n   - The client's gender is 'F' (female), as specified by `T1.gender = 'F'`.\n   - The district name is 'Jesenik', as specified by `T2.A2 = 'Jesenik'`.\n\n3. **Count the Clients**: Count the number of `client_id` entries in the filtered results to get the total number of female clients in the Jesenik branch.\n\nThe final result will be the count of female clients who opened their accounts in the Jesenik branch."
        ]
    },
    "56": {
        "sql": "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND City = 'San Joaquin' AND StatusType = 'Active';",
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin city?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "explain": "",
        "solution": [
            "To solve the question, we need to count the number of schools that meet the following criteria:\n1. The school's mailing state address is in California (MailState = 'CA').\n2. The school is located in the city of San Joaquin (City = 'San Joaquin').\n3. The school is currently active (StatusType = 'Active').\n\nThe solution involves querying the 'schools' table to count the number of entries (using CDSCode as the identifier) that satisfy all these conditions."
        ]
    },
    "438": {
        "sql": "SELECT language FROM set_translations WHERE id = 174;",
        "question": "Point out the language of set id \"174\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT language FROM set_translations WHERE id = 174",
        "explain": "",
        "solution": [
            "To find the language of the set with ID \"174\", retrieve the \"language\" field from the \"set_translations\" table where the \"id\" column matches the value 174."
        ]
    },
    "1260": {
        "sql": "SELECT DISTINCT T1.ID\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE CAST(T2.RF AS INTEGER) < 20\nAND (STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday)) > 60;",
        "question": "Please list the ID of the patient whose RF is normal and who is older than 60.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60",
        "explain": "RF is normal refers to RF < 20; older than 60 = SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) > 60;",
        "solution": [
            "To solve the question, we need to list the IDs of patients who meet two conditions: their RF (Rheumatoid Factor) is normal (less than 20) and they are older than 60 years. The solution involves the following steps:\n\n1. **Join Tables**: Combine the `Patient` table (referred to as T1) and the `Laboratory` table (referred to as T2) using the patient ID as the common key.\n\n2. **Filter by RF**: From the joined tables, filter out records where the RF value in the `Laboratory` table (T2.RF) is less than 20, indicating a normal RF level.\n\n3. **Filter by Age**: Further filter the records to include only those patients whose age is greater than 60. The age is calculated by subtracting the birth year (from the `Patient` table, T1.Birthday) from the current year.\n\n4. **Select ID**: Finally, extract and list the IDs of the patients who meet both conditions from the `Patient` table (T1.ID).\n\nThe SQL query performs these operations in a single step, ensuring efficiency and accuracy.",
            "To solve the question, we need to list the IDs of patients who meet two conditions: their RF (Rheumatoid Factor) is normal (less than 20) and they are older than 60 years. The solution involves the following detailed steps:\n\n1. **Join Tables**: Combine the `Patient` table (referred to as T1) and the `Laboratory` table (referred to as T2) using the patient ID (`T1.ID = T2.ID`) as the common key. This ensures that each patient's laboratory results are linked to their personal data.\n\n2. **Filter by RF**: From the joined tables, filter out records where the RF value in the `Laboratory` table (`T2.RF`) is less than 20. This condition ensures that only patients with a normal RF level are considered.\n\n3. **Filter by Age**: Further filter the records to include only those patients whose age is greater than 60. The age is calculated by subtracting the birth year (extracted from `T1.Birthday` using `STRFTIME('%Y', T1.Birthday)`) from the current year (extracted using `STRFTIME('%Y', DATE('now'))`). This ensures that only patients older than 60 are included.\n\n4. **Select ID**: Finally, extract and list the IDs of the patients (`T1.ID`) who meet both conditions (normal RF and age > 60) from the `Patient` table.\n\nThe SQL query performs these operations in a single step, ensuring efficiency and accuracy."
        ]
    },
    "1217": {
        "sql": "SELECT \n    T1.ID,\n    CASE \n        WHEN T2.ALB BETWEEN 3.5 AND 5.5 THEN 'normal'\n        ELSE 'abnormal'\n    END AS AlbuminStatus\nFROM \n    Patient T1\nJOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    STRFTIME('%Y', T1.Birthday) = '1982';",
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "explain": "Year(Birthday) = '1982'; albumin is within normal range refers to ALB between 3.5 and 5.5",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join the Patient and Laboratory tables**: The tables are joined using the `ID` field to link patient records with their laboratory results.\n\n2. **Filter patients born in 1982**: The `WHERE` clause filters the records to include only those patients whose birth year is 1982. This is done by extracting the year from the `Birthday` field using the `STRFTIME` function.\n\n3. **Check albumin levels**: For each patient, the albumin level (`ALB`) from the Laboratory table is checked to see if it falls within the normal range (3.5 to 5.5).\n\n4. **Categorize the result**: A `CASE` statement is used to label the albumin level as 'normal' if it is within the range, and 'abnormal' otherwise.\n\n5. **Output the result**: The final output is a list of labels ('normal' or 'abnormal') for each patient born in 1982, based on their albumin levels.",
            "To solve the question, the following detailed operations are performed:\n\n1. **Join the Patient and Laboratory tables**: The `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) are joined using the `ID` field. This ensures that each patient record is linked to their corresponding laboratory results.\n\n2. **Filter patients born in 1982**: The `WHERE` clause is applied to filter the records. It uses the `STRFTIME` function to extract the year from the `Birthday` field in the `Patient` table (`T1.Birthday`). Only records where the extracted year is '1982' are retained.\n\n3. **Check albumin levels**: For each patient, the albumin level (`ALB`) from the `Laboratory` table (`T2.ALB`) is evaluated. The albumin level is checked to see if it falls within the normal range of 3.5 to 5.5 (inclusive).\n\n4. **Categorize the result**: A `CASE` statement is used to categorize the albumin level. If the `ALB` value is between 3.5 and 5.5, the result is labeled as 'normal'. Otherwise, it is labeled as 'abnormal'.\n\n5. **Output the result**: The final output is a list of labels ('normal' or 'abnormal') for each patient born in 1982, based on their albumin levels. This output is generated by the `SELECT` statement, which includes the `CASE` expression."
        ]
    },
    "1381": {
        "sql": "SELECT m.first_name, m.last_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nGROUP BY m.member_id, m.first_name, m.last_name\nHAVING COUNT(a.link_to_event) > 7;",
        "question": "List the name of students that have attended more than 7 events.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "explain": "name of students means the full name; full name refers to first_name, last_name; attended more than 7 events refers to COUNT(link_to_event) > 7",
        "solution": []
    },
    "503": {
        "sql": "SELECT s.type \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Samite Pilgrim';",
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "explain": "expansion type refers to type; card \"Samite Pilgrim\" refers to name = 'Samite Pilgrim'",
        "solution": []
    },
    "934": {
        "sql": "SELECT d.forename, d.surname\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 1989 AND rc.name = 'Australian Grand Prix' AND r.grid = 4;",
        "question": "Which driver was in the no. 4 grid formation when starting the race in 1989's Australian Grand Prix? Please give his forename and surname.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T2.grid = 4 AND T1.name = 'Australian Grand Prix' AND T1.year = 1989",
        "explain": "the no. 4 grid formation refers to grid = 4",
        "solution": []
    },
    "226": {
        "sql": "SELECT ROUND((COUNT(CASE WHEN bond_type = '=' THEN 1 END) * 100.0 / COUNT(*)), 5) AS percentage_double_bonds\nFROM bond\nWHERE molecule_id = 'TR008';",
        "question": "What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) FROM bond AS T WHERE T.molecule_id = 'TR008'",
        "explain": "double bond refers to bond_type = '='; TR008 is the molecule id; percentage = DIVIDE(SUM(bond_type = '='), COUNT(bond_id)) as percent where molecule_id = 'TR008'",
        "solution": [
            "To determine the percentage of double bonds in the molecule TR008, follow these steps:\n\n1. **Filter the bonds**: Select all bonds from the bond table where the molecule_id is 'TR008'.\n2. **Count total bonds**: Calculate the total number of bonds in the molecule TR008.\n3. **Count double bonds**: From the filtered bonds, count only those bonds where the bond_type is '=' (indicating a double bond).\n4. **Calculate the percentage**: Divide the count of double bonds by the total number of bonds, multiply by 100 to convert it to a percentage, and round the result to five decimal places.\n\nThe final result will be the percentage of double bonds in the molecule TR008, presented with five decimal places."
        ]
    },
    "970": {
        "sql": "SELECT T2.driverId\nFROM pitStops T1\nJOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German'\nAND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990'\nORDER BY T1.time ASC\nLIMIT 3;",
        "question": "List out top 3 German drivers who were born from 1980-1990 and have the earliest lap time.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990' ORDER BY T1.time LIMIT 3",
        "explain": "born from 1980-1990 refers to year(dob) between 1980 and 1990; earliest lap time refers to Min(time);",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Join Tables**: Combine the `pitStops` table (referred to as `T1`) and the `drivers` table (referred to as `T2`) using the `driverId` field as the common key.\n\n2. **Filter by Nationality**: From the joined data, filter out only those drivers whose nationality is 'German'.\n\n3. **Filter by Birth Year**: Further filter the results to include only drivers born between the years 1980 and 1990. This is done by extracting the year from the `dob` (date of birth) field in the `drivers` table and checking if it falls within the specified range.\n\n4. **Sort by Lap Time**: Order the filtered results by the `time` field in the `pitStops` table in ascending order to find the drivers with the earliest lap times.\n\n5. **Limit Results**: Finally, limit the output to the top 3 drivers who meet all the above criteria.\n\nThe SQL query achieves this by selecting the `driverId` from the `drivers` table after performing these operations.",
            "To solve the question, the following detailed steps are performed:\n\n1. **Join Tables**: The `pitStops` table (referred to as `T1`) and the `drivers` table (referred to as `T2`) are joined together using the `driverId` field as the common key. This ensures that each pit stop record is linked to its corresponding driver.\n\n2. **Filter by Nationality**: From the joined dataset, only those records where the driver's nationality is 'German' are retained. This is done by applying the condition `T2.nationality = 'German'`.\n\n3. **Filter by Birth Year**: The dataset is further refined to include only drivers born between the years 1980 and 1990. This is achieved by extracting the year from the `dob` (date of birth) field in the `drivers` table using the `STRFTIME('%Y', T2.dob)` function and checking if it falls within the range `BETWEEN '1980' AND '1990'`.\n\n4. **Sort by Lap Time**: The filtered results are then sorted in ascending order based on the `time` field from the `pitStops` table (`T1.time`). This ensures that drivers with the earliest lap times appear first in the results.\n\n5. **Limit Results**: Finally, the output is restricted to the top 3 drivers who meet all the specified criteria by applying the `LIMIT 3` clause.\n\nThe SQL query selects the `driverId` from the `drivers` table (`T2.driverId`) after performing these operations, providing the list of top 3 German drivers born between 1980 and 1990 with the earliest lap times."
        ]
    },
    "669": {
        "sql": "SELECT MIN(v.CreationDate) AS FirstVoteDate\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE u.DisplayName = 'chl';",
        "question": "When did 'chl' cast its first vote in a post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.CreationDate FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl' ORDER BY T2.CreationDate LIMIT 1",
        "explain": "DisplayName = 'chl'; cast its first vote refers to MIN(CreationDate);",
        "solution": []
    },
    "453": {
        "sql": "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
        "question": "What's the unconverted mana cost of the card \"Ancestor's Chosen\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
        "explain": "card \"Ancestor's Chosen\" refers to name = 'Ancestor`s Chosen'",
        "solution": [
            "To find the unconverted mana cost of the card \"Ancestor's Chosen\", perform the following steps:\n1. Query the \"cards\" table.\n2. Filter the records to only include the card with the name \"Ancestor's Chosen\".\n3. Retrieve the distinct value of the \"manaCost\" column for this card.\n4. The result will be the unconverted mana cost of \"Ancestor's Chosen\".",
            "To determine the unconverted mana cost of the card \"Ancestor's Chosen\", follow these detailed steps:\n\n1. **Access the Database Table**: Begin by accessing the \"cards\" table in the database, which contains information about various cards, including their mana costs.\n\n2. **Filter the Card by Name**: Apply a filter to the \"cards\" table to isolate the record(s) where the \"name\" column exactly matches the string \"Ancestor's Chosen\". This ensures that only the data for the specified card is considered.\n\n3. **Retrieve the Mana Cost**: From the filtered record(s), extract the value stored in the \"manaCost\" column. Since the query uses the DISTINCT keyword, it ensures that only unique values of the mana cost are returned, avoiding any duplicates.\n\n4. **Return the Result**: The result of this operation will be the unconverted mana cost of the card \"Ancestor's Chosen\", as stored in the \"manaCost\" column of the \"cards\" table.\n\nThis process directly translates to the SQL query: `SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'`."
        ]
    },
    "1135": {
        "sql": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential ASC LIMIT 5",
        "question": "Please provide top five football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential DESC LIMIT 5",
        "explain": "lowest potential players refers to MIN(potential); prefer to use the right foot when attacking refers to preferred_foot = 'right'",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter Players by Preferred Foot**: Select all players from the `Player_Attributes` table who prefer to use their right foot when attacking. This is done by filtering rows where the `preferred_foot` column equals 'right'.\n\n2. **Sort by Potential**: Order the filtered players by their potential in descending order. This ensures that players with the lowest potential appear first in the list.\n\n3. **Limit the Results**: Retrieve only the top five players from the sorted list. This is achieved by limiting the result set to 5 rows.\n\n4. **Select Player IDs**: Finally, extract the `id` column from the result set to provide the IDs of the top five players who meet the criteria.\n\nThe SQL query for this operation is: `SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential DESC LIMIT 5`.",
            "To solve the question, the following detailed steps are performed:\n\n1. **Filter Players by Preferred Foot**: The database is queried to select all players from the `Player_Attributes` table where the `preferred_foot` column is equal to 'right'. This ensures only players who prefer to use their right foot when attacking are considered.\n\n2. **Sort by Potential**: The filtered players are then sorted by their `potential` in descending order. This step ensures that players with the lowest potential (since the question asks for the lowest potential players) appear at the top of the list.\n\n3. **Limit the Results**: The sorted list is truncated to include only the top five players. This is done by applying a `LIMIT 5` clause to the query.\n\n4. **Select Player IDs**: Finally, the `id` column is selected from the result set to provide the IDs of the top five players who meet the specified criteria.\n\nThe SQL query for this operation is: `SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential DESC LIMIT 5`."
        ]
    },
    "1242": {
        "sql": "SELECT DISTINCT T1.ID\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.PLT BETWEEN 100 AND 400\nAND (strftime('%Y', T2.Date) = '1984')\nAND (strftime('%Y', T2.Date) - strftime('%Y', T1.Birthday) < 50;",
        "question": "For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 AND STRFTIME('%Y', T2.Date) = '1984'",
        "explain": "laboratory examinations take in 1984 refers to YEAR(Date) = '1984'; below 50 years old = SUBTRACT(year(current_timestamp), year(Birthday)) < 50; normal platelet level refers to PLT between 100 and 400; ",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct Patient IDs**: Retrieve unique patient IDs to ensure no duplicates are included in the results.\n\n2. **Join Tables**: Combine the `Patient` table (referred to as `T1`) and the `Laboratory` table (referred to as `T2`) using the patient ID as the joining key. This ensures that we can access both patient and laboratory data for each patient.\n\n3. **Filter by Platelet Level**: From the joined data, filter records where the platelet level (`PLT`) is within the normal range (between 100 and 400).\n\n4. **Filter by Age**: Calculate the age of each patient at the time of the laboratory examination by subtracting the year of birth (from `T1.Birthday`) from the year of the laboratory examination (from `T2.Date`). Only include patients whose calculated age is less than 50 years.\n\n5. **Filter by Year of Examination**: Further filter the records to include only those laboratory examinations that took place in the year 1984.\n\n6. **Return Results**: The final result is a list of distinct patient IDs who meet all the specified criteria: normal platelet levels, age below 50, and laboratory examinations in 1984.",
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct Patient IDs**: Retrieve unique patient IDs from the `Patient` table (referred to as `T1`) to ensure no duplicates are included in the results.\n\n2. **Join Tables**: Combine the `Patient` table (`T1`) and the `Laboratory` table (referred to as `T2`) using the patient ID (`T1.ID = T2.ID`) as the joining key. This ensures that we can access both patient and laboratory data for each patient.\n\n3. **Filter by Platelet Level**: From the joined data, filter records where the platelet level (`T2.PLT`) is within the normal range (between 100 and 400).\n\n4. **Filter by Age**: Calculate the age of each patient at the time of the laboratory examination by subtracting the year of birth (extracted from `T1.Birthday`) from the year of the laboratory examination (extracted from `T2.Date`). Only include patients whose calculated age is less than 50 years.\n\n5. **Filter by Year of Examination**: Further filter the records to include only those laboratory examinations where the year of the examination (extracted from `T2.Date`) is exactly 1984.\n\n6. **Return Results**: The final result is a list of distinct patient IDs (`T1.ID`) who meet all the specified criteria: normal platelet levels (100 \u2264 `T2.PLT` \u2264 400), age below 50, and laboratory examinations in the year 1984."
        ]
    },
    "785": {
        "sql": "SELECT superhero_name FROM superhero WHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'Neutral');",
        "question": "Describe the names of neutral alignment superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "explain": "names of superheroes refers to superhero_name; neutral alignment refers to alignment = 'Neutral';",
        "solution": []
    },
    "750": {
        "sql": "SELECT AVG(s.weight_kg) AS average_weight\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Female';",
        "question": "What is the average weight of all female superheroes?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'",
        "explain": "female refers to gender = 'Female'; average weight refers to AVG(weight_kg)",
        "solution": []
    },
    "330": {
        "sql": "WITH carcinogenic_molecules AS (\n  SELECT molecule_id\n  FROM molecule\n  WHERE label = '+'\n),\nhydrogen_atoms AS (\n  SELECT a.molecule_id\n  FROM atom a\n  JOIN carcinogenic_molecules cm ON a.molecule_id = cm.molecule_id\n  WHERE a.element = 'h'\n),\ntriple_bonded_hydrogen AS (\n  SELECT DISTINCT b.molecule_id\n  FROM bond b\n  JOIN hydrogen_atoms ha ON b.molecule_id = ha.molecule_id\n  WHERE b.bond_type = '#'\n)\nSELECT \n  (COUNT(DISTINCT tbh.molecule_id) * 100.0 / COUNT(DISTINCT cm.molecule_id)) AS percentage\nFROM carcinogenic_molecules cm\nLEFT JOIN triple_bonded_hydrogen tbh ON cm.molecule_id = tbh.molecule_id;",
        "question": "Calculate the percentage of carcinogenic molecules with triple bonded Hidrogen atoms.",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T2.element = 'h'",
        "explain": "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) * 100.0 where element = 'h' AND bond_type = '#';",
        "solution": [
            "To calculate the percentage of carcinogenic molecules with triple-bonded Hydrogen atoms, follow these steps:\n\n1. **Identify Carcinogenic Molecules**: From the `molecule` table (aliased as T1), filter molecules where the `label` is '+', indicating they are carcinogenic.\n\n2. **Join with Atom Table**: Join the filtered molecules with the `atom` table (aliased as T2) using the `molecule_id` to ensure the molecules contain Hydrogen atoms. Specifically, check for atoms where the `element` is 'h' (Hydrogen).\n\n3. **Join with Bond Table**: Further join the result with the `bond` table (aliased as T3) using the `molecule_id` to identify bonds involving the Hydrogen atoms. Filter for bonds where the `bond_type` is '#', indicating a triple bond.\n\n4. **Count Carcinogenic Molecules with Triple-Bonded Hydrogen**: Count the distinct `molecule_id` values from the `molecule` table (T1) that meet all the above criteria (carcinogenic, contain Hydrogen, and have a triple bond involving Hydrogen).\n\n5. **Calculate Percentage**: Divide the count of carcinogenic molecules with triple-bonded Hydrogen atoms by the total count of distinct molecules (from T1) that meet the criteria, then multiply by 100 to get the percentage.\n\nThe SQL query performs these operations to return the desired percentage.",
            "To calculate the percentage of carcinogenic molecules with triple-bonded Hydrogen atoms, follow these steps:\n\n1. **Filter Carcinogenic Molecules**: From the `molecule` table (aliased as T1), select molecules where the `label` is '+', indicating they are carcinogenic.\n\n2. **Join with Atom Table**: Join the filtered molecules with the `atom` table (aliased as T2) using the `molecule_id` to ensure the molecules contain Hydrogen atoms. Specifically, check for atoms where the `element` is 'h' (Hydrogen).\n\n3. **Join with Bond Table**: Further join the result with the `bond` table (aliased as T3) using the `molecule_id` to identify bonds involving the Hydrogen atoms. Filter for bonds where the `bond_type` is '#', indicating a triple bond.\n\n4. **Count Carcinogenic Molecules with Triple-Bonded Hydrogen**: Count the number of distinct `molecule_id` values from the `molecule` table (T1) that meet all the above criteria (carcinogenic, contain Hydrogen, and have a triple bond involving Hydrogen).\n\n5. **Calculate Percentage**: Divide the count of carcinogenic molecules with triple-bonded Hydrogen atoms by the total count of distinct molecules (from T1) that meet the criteria, then multiply by 100 to get the percentage.\n\nThe SQL query performs these operations to return the desired percentage."
        ]
    },
    "1232": {
        "sql": "SELECT P.ID, P.SEX, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.GLU >= 180 AND L.`T-CHO` < 250;",
        "question": "Provide ID, sex and age of patient who has blood glucose (GLU) not within normal range but with total cholesterol(T-CHO) within normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX , STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU >= 180 AND T2.`T-CHO` < 250",
        "explain": "age = SUBTRACT(year(current_timestamp), year(Birthday)); blood glucose (GLU) not within normal range refers to GLU > = 180; total cholesterol(T-CHO) within normal range refers to `T-CHO` < 250; ",
        "solution": []
    },
    "859": {
        "sql": "SELECT q.q1\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE d.forename = 'Bruno' AND d.surname = 'Senna' AND q.raceId = 354;",
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "explain": "race number refers to raceId; Bruno Senna refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "solution": []
    },
    "805": {
        "sql": "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0);",
        "question": "List the full names of superheroes with missing weight.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0)",
        "explain": "missing weight refers to weight_kg = 0 OR weight_kg = NULL;",
        "solution": [
            "To list the full names of superheroes with missing weight, follow these steps:\n\n1. **Select Distinct Full Names**: Retrieve the unique full names from the `superhero` table.\n2. **Filter Non-Null Full Names**: Ensure that the full names are not null.\n3. **Check for Missing Weight**: Include only those superheroes where the `weight_kg` is either null or equal to 0.\n\nThe result will be a list of distinct full names of superheroes who have missing or zero weight values."
        ]
    },
    "958": {
        "sql": "SELECT d.forename, d.surname, r.fastestLapTime \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nWHERE r.fastestLapTime IS NOT NULL \nORDER BY r.fastestLapTime ASC \nLIMIT 1;",
        "question": "Which driver has the fastest lap time? Please give their forenames and surnames.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.forename, T2.surname, T1.fastestLapTime FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T1.fastestLapTime IS NOT NULL ORDER BY T1.fastestLapTime ASC LIMIT 1",
        "explain": "",
        "solution": [
            "To find the driver with the fastest lap time, follow these steps:\n\n1. **Join the tables**: Combine the `results` table (referred to as `T1`) with the `drivers` table (referred to as `T2`) using the `driverId` field as the common key. This ensures that each result record is linked to its corresponding driver record.\n\n2. **Filter out null values**: Exclude any records where the `fastestLapTime` in the `results` table is `NULL`. This ensures we only consider valid lap times.\n\n3. **Sort the results**: Arrange the remaining records in ascending order based on the `fastestLapTime` field. This places the fastest lap time at the top of the list.\n\n4. **Limit the output**: Retrieve only the first record from the sorted list, which corresponds to the driver with the fastest lap time.\n\n5. **Select the required fields**: Display the `forename` and `surname` of the driver (from the `drivers` table) along with their `fastestLapTime` (from the `results` table)."
        ]
    },
    "1406": {
        "sql": "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food');",
        "question": "Among the budgets for Food, which one has the highest budgeted amount?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget )",
        "explain": "MAX(amount) where category = 'Food'",
        "solution": [
            "To find the budget with the highest budgeted amount in the 'Food' category, follow these steps:\n\n1. **Filter by Category**: First, identify all budgets that belong to the 'Food' category. This is done by checking the `category` column for the value 'Food'.\n\n2. **Find Maximum Amount**: Next, determine the highest budgeted amount across all budgets in the database. This is achieved by calculating the maximum value in the `amount` column.\n\n3. **Match the Maximum Amount**: Finally, retrieve the `budget_id` of the budget(s) in the 'Food' category where the `amount` matches the maximum amount found in the previous step.\n\nThe result will be the `budget_id` of the budget in the 'Food' category with the highest budgeted amount."
        ]
    },
    "11": {
        "sql": "SELECT CDSCode FROM frpm WHERE (\"Enrollment (K-12)\" + \"Enrollment (Ages 5-17)\") > 500;",
        "question": "Please list the codes of the schools with a total enrollment of over 500.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.CDSCode FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` + T2.`Enrollment (Ages 5-17)` > 500",
        "explain": "Total enrollment can be represented by `Enrollment (K-12)` + `Enrollment (Ages 5-17)`",
        "solution": []
    },
    "717": {
        "sql": "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = '3-D Man';",
        "question": "Please list all the superpowers of 3-D Man.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = '3-D Man'",
        "explain": "3-D Man refers to superhero_name = '3-D Man'; superpowers refers to power_name",
        "solution": []
    },
    "1197": {
        "sql": "SELECT p.`First Date`, e.Diagnosis FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE p.ID = 48473 ORDER BY p.`First Date` LIMIT 1;",
        "question": "When was the medical information on patient number 48473 first documented, and what disease did she have?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT `First Date`, Diagnosis FROM Patient WHERE ID = 48473",
        "explain": "medical information first documented refers to Description; disease refers to diagnosis; patient number refers to id",
        "solution": []
    },
    "1034": {
        "sql": "SELECT player_api_id FROM Player_Attributes WHERE SUBSTR(date, 1, 4) = '2010' ORDER BY overall_rating DESC LIMIT 1;",
        "question": "List the players' api id who had the highest above average overall ratings in 2010.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_api_id FROM Player_Attributes WHERE SUBSTR(`date`, 1, 4) = '2010' ORDER BY overall_rating DESC LIMIT 1",
        "explain": "highest above average overall ratings refers to MAX(overall_rating); in 2010 refers to substr(date,1,4) = '2010';",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter the Data**: Select all records from the `Player_Attributes` table where the year part of the `date` column is '2010'. This is done using the `SUBSTR` function to extract the first 4 characters of the `date` column, which represent the year.\n\n2. **Sort the Data**: Order the filtered records by the `overall_rating` column in descending order. This ensures that the player with the highest overall rating appears at the top of the result set.\n\n3. **Limit the Result**: Retrieve only the top record from the sorted list, which corresponds to the player with the highest overall rating in 2010. This is achieved using the `LIMIT 1` clause.\n\n4. **Select the Desired Column**: Finally, extract the `player_api_id` of the player identified in the previous step."
        ]
    },
    "670": {
        "sql": "SELECT MIN(p.CreaionDate) AS FirstPostDate\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.Age = (SELECT MIN(Age) FROM users WHERE Age IS NOT NULL);",
        "question": "What is the date when the youngest user made his or her first post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "explain": "the youngest user refers to MIN(Age); first post refers to MIN(CreaionDate);",
        "solution": []
    },
    "494": {
        "sql": "SELECT T2.text AS ruling_text, \n       CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END AS has_missing_or_degraded_properties\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Jim Pavelec';",
        "question": "For all cards illustrated by Jim Pavelec. and describe the text of the ruling of these cards. Do these cards have missing or degraded properties and values.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text , CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec'",
        "explain": "all cards illustrated by Jim Pavelec refers to artist = 'Jim Pavelec'; the text of the ruling refers to text; cards have missing or degraded properties and values if hasContentWarning = 1 else it doesn't have;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select the relevant tables**: The query involves two tables, `cards` (referred to as `T1`) and `rulings` (referred to as `T2`).\n\n2. **Filter the cards**: The query filters the `cards` table to include only those records where the `artist` column matches the value 'Jim Pavelec'.\n\n3. **Join the tables**: The query performs an inner join between the `cards` table (`T1`) and the `rulings` table (`T2`) using the `uuid` column as the join condition. This ensures that only cards with corresponding rulings are included in the result.\n\n4. **Retrieve the ruling text**: For each matching card, the query retrieves the `text` column from the `rulings` table (`T2`), which contains the text of the ruling for that card.\n\n5. **Check for content warnings**: The query also checks the `hasContentWarning` column in the `cards` table (`T1`). If the value is `1`, it returns 'YES' to indicate that the card has missing or degraded properties or values; otherwise, it returns 'NO'.\n\n6. **Output the results**: The final output includes the ruling text and the content warning status for each card illustrated by Jim Pavelec."
        ]
    },
    "858": {
        "sql": "SELECT c.nationality \nFROM constructors c \nJOIN constructorResults cr ON c.constructorId = cr.constructorId \nWHERE cr.raceId = 24 AND cr.points = 1;",
        "question": "Which country is the constructor which got 1 point in the race No. 24 from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 24 AND T1.points = 1",
        "explain": "race number refers to raceId;",
        "solution": []
    },
    "608": {
        "sql": "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:25:47';",
        "question": "State the detailed content of the comment which was created on 7/19/2010 7:25:47 PM.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:16:14.0'",
        "explain": "detailed content of the comment refers to Text; created on 7/19/2010 7:16:14 PM refers to CreationDate = '2010-07-19 19:16:14.0'",
        "solution": [
            "To retrieve the detailed content of the comment created on July 19, 2010, at 7:25:47 PM, the database performs the following operations:\n\n1. **Query Execution**: The database executes a query to search the `comments` table.\n2. **Filtering**: It filters the records in the `comments` table to find the comment where the `CreationDate` matches the exact timestamp '2010-07-19 19:16:14.0'.\n3. **Result Extraction**: From the filtered record, it extracts the value in the `Text` column, which contains the detailed content of the comment.\n\nThe SQL query ensures that only the comment created at the specified timestamp is retrieved, and no other comments are included in the result.",
            "To retrieve the detailed content of the comment created on July 19, 2010, at 7:25:47 PM, the database performs the following operations:\n\n1. **Query Execution**: The database executes a SQL query to search the `comments` table.\n2. **Filtering**: It filters the records in the `comments` table to find the comment where the `CreationDate` column exactly matches the timestamp '2010-07-19 19:16:14.0'.\n3. **Result Extraction**: From the filtered record, it extracts the value in the `Text` column, which contains the detailed content of the comment.\n\nThe SQL query ensures that only the comment created at the specified timestamp is retrieved, and no other comments are included in the result."
        ]
    },
    "1468": {
        "sql": "SELECT z.city AS hometown\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Garrett' AND m.last_name = 'Gerke';",
        "question": "Where is the hometown of Garrett Gerke?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.city FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'",
        "explain": "hometown refers to city",
        "solution": []
    },
    "751": {
        "sql": "SELECT DISTINCT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nJOIN gender g ON sh.gender_id = g.id\nWHERE g.gender = 'Male'\nLIMIT 5;",
        "question": "List down at least five superpowers of male superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
        "explain": "male refers to gender = 'Male'; superpowers refers to power_name;",
        "solution": []
    },
    "1423": {
        "sql": "SELECT COUNT(*) FROM income WHERE amount = 50;",
        "question": "How many income are received with an amount of 50?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(income_id) FROM income WHERE amount = 50",
        "explain": "amount of 50 refers to amount = 50",
        "solution": []
    },
    "546": {
        "sql": "SELECT DISTINCT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ClosedDate IS NOT NULL;",
        "question": "Please list the display names of all the users who owns a post that is well-finished.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.ClosedDate IS NOT NULL",
        "explain": "the post that is well-finished refers to ClosedDate IS NOT Null",
        "solution": []
    },
    "910": {
        "sql": "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit';",
        "question": "What's the location coordinates of Silverstone Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit'",
        "explain": "location coordinates refers to (lat, lng); Silverstone Circuit refers to circuits.name = 'Silverstone Circuit'",
        "solution": []
    },
    "203": {
        "sql": "SELECT COUNT(*) FROM atom WHERE element != 'br';",
        "question": "In how many atoms is there no bromine?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.atom_id) FROM atom AS T WHERE T.element <> 'br'",
        "explain": "atoms with no bromine refers to element ! = 'br'",
        "solution": []
    },
    "1021": {
        "sql": "SELECT player_name, height FROM Player ORDER BY height DESC LIMIT 1;",
        "question": "What is the height of the tallest player? Indicate his name.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "explain": "tallest player refers to MAX(height);",
        "solution": [
            "To find the height of the tallest player and indicate their name, the database performs the following operations:\n\n1. **Retrieve Data**: The database accesses the `Player` table to gather all player records.\n2. **Sort by Height**: The records are sorted in descending order based on the `height` column. This ensures the tallest player appears at the top of the list.\n3. **Limit Results**: Only the first record (the tallest player) is selected from the sorted list.\n4. **Display Name**: The `player_name` of the tallest player is returned as the result.\n\nThis process ensures that the query accurately identifies and returns the name of the tallest player.",
            "To determine the height of the tallest player and indicate their name, the database executes the following steps:\n\n1. **Query Execution**: The database initiates a query on the `Player` table to retrieve the required information.\n2. **Sorting**: The retrieved records are sorted in descending order based on the `height` column. This ensures the tallest player is positioned at the top of the result set.\n3. **Limitation**: The query applies a limit of 1 to the sorted result set, selecting only the topmost record, which corresponds to the tallest player.\n4. **Projection**: The `player_name` column is projected from the selected record to display the name of the tallest player.\n\nThis sequence of operations ensures the correct identification and display of the tallest player's name, as specified in the SQL query: `SELECT player_name FROM Player ORDER BY height DESC LIMIT 1`."
        ]
    },
    "486": {
        "sql": "SELECT \n    (COUNT(CASE WHEN c.convertedManaCost = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    cards c\nJOIN \n    sets s ON c.setCode = s.code\nWHERE \n    s.code = 'CSP';",
        "question": "What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "explain": "converted mana cost of 7 refers to convertedManaCost = 7; card set Coldsnap refers to name = 'Coldsnap'; percentage = DIVIDE(SUM(convertedManaCost = 7), SUM(convertedManaCost))*100",
        "solution": []
    },
    "794": {
        "sql": "SELECT T1.superhero_name\nFROM superhero T1\nJOIN hero_attribute T2 ON T1.id = T2.hero_id\nJOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Speed'\nORDER BY T2.attribute_value DESC\nLIMIT 1;",
        "question": "Which hero was the fastest?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
        "explain": "which hero refers to superhero_name; fastest refers to MAX(attribute_value) WHERE attribute_name = 'Speed';",
        "solution": [
            "To determine which hero was the fastest, follow these steps:\n\n1. **Identify the relevant tables**: The query involves three tables:\n   - `superhero` (aliased as `T1`), which contains information about superheroes.\n   - `hero_attribute` (aliased as `T2`), which links superheroes to their attributes.\n   - `attribute` (aliased as `T3`), which defines the types of attributes (e.g., Speed).\n\n2. **Join the tables**:\n   - Join `superhero` (`T1`) with `hero_attribute` (`T2`) using the `id` column from `superhero` and the `hero_id` column from `hero_attribute`.\n   - Join the result with the `attribute` table (`T3`) using the `attribute_id` column from `hero_attribute` and the `id` column from `attribute`.\n\n3. **Filter for the 'Speed' attribute**:\n   - Use the `WHERE` clause to filter rows where the `attribute_name` in the `attribute` table (`T3`) is 'Speed'.\n\n4. **Order by attribute value**:\n   - Sort the results by the `attribute_value` column from `hero_attribute` (`T2`) in descending order (`DESC`) to prioritize the highest values (indicating the fastest speed).\n\n5. **Limit the result**:\n   - Use `LIMIT 1` to return only the top result, which will be the hero with the highest speed value.\n\n6. **Select the superhero name**:\n   - The final output is the `superhero_name` from the `superhero` table (`T1`).\n\nThis process ensures that the query retrieves the name of the superhero with the highest speed attribute value."
        ]
    },
    "413": {
        "sql": "SELECT COUNT(DISTINCT c.id) \nFROM cards c \nJOIN rulings r ON c.uuid = r.uuid \nWHERE c.rarity = 'rare' AND r.date = '2007-02-01';",
        "question": "How many cards with print rarity have ruling text printed on 01/02/2007?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'rare' AND T2.date = '2007-02-01'",
        "explain": "with print rarity refers to rarity = 'rare'; on 01/02/2007 refers to date = '2007-02-01'",
        "solution": []
    },
    "1527": {
        "sql": "SELECT GasStationID, SUM(Price) AS TotalRevenue FROM transactions_1k GROUP BY GasStationID ORDER BY TotalRevenue DESC LIMIT 1;",
        "question": "Which gas station has the highest amount of revenue?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT GasStationID FROM transactions_1k GROUP BY GasStationID ORDER BY SUM(Price) DESC LIMIT 1",
        "explain": "",
        "solution": [
            "To determine which gas station has the highest amount of revenue, follow these steps:\n\n1. **Group the transactions by GasStationID**: This will aggregate all transactions for each gas station.\n2. **Calculate the total revenue for each gas station**: Sum the 'Price' column for each group to get the total revenue per gas station.\n3. **Order the results by total revenue in descending order**: This will arrange the gas stations from the highest to the lowest revenue.\n4. **Select the top result**: Limit the output to the first row, which will be the gas station with the highest revenue.\n\nThe final output will be the GasStationID of the gas station with the highest revenue.",
            "To determine which gas station has the highest amount of revenue, follow these detailed steps:\n\n1. **Retrieve all transactions**: Start by accessing the `transactions_1k` table, which contains records of all transactions.\n\n2. **Group transactions by GasStationID**: Aggregate the transactions based on the `GasStationID` column. This groups all transactions belonging to the same gas station together.\n\n3. **Calculate total revenue per gas station**: For each group (i.e., each gas station), sum the values in the `Price` column. This sum represents the total revenue generated by that gas station.\n\n4. **Order gas stations by total revenue**: Sort the grouped results in descending order based on the calculated total revenue. This ensures the gas station with the highest revenue appears first.\n\n5. **Select the top gas station**: Limit the output to only the first row of the sorted results, which corresponds to the gas station with the highest revenue.\n\nThe final output will be the `GasStationID` of the gas station that has the highest revenue, as derived from the summed `Price` values in the `transactions_1k` table."
        ]
    },
    "612": {
        "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'Pierre';",
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "explain": "",
        "solution": []
    },
    "564": {
        "sql": "SELECT c.Text FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.ParentId = 107829 LIMIT 1;",
        "question": "Give the only one comment text of the post with parent id 107829.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "explain": "one comment refers to CommentCount = '1'",
        "solution": []
    },
    "891": {
        "sql": "SELECT d.forename, d.surname\nFROM races r\nJOIN driverStandings ds ON r.raceId = ds.raceId\nJOIN drivers d ON ds.driverId = d.driverId\nWHERE r.name = 'Singapore Grand Prix' AND r.year = 2010\nORDER BY ds.position;",
        "question": "Name all drivers in the 2010 Singapore Grand Prix order by their position stands.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010 ORDER BY T2.position ASC",
        "explain": "",
        "solution": [
            "To solve the question \"Name all drivers in the 2010 Singapore Grand Prix ordered by their position standings,\" the following steps are performed:\n\n1. **Identify the race**: Locate the race record for the \"Singapore Grand Prix\" in the year 2010 from the \"races\" table (referred to as T1).\n\n2. **Join driver standings**: Connect the identified race to the \"driverStandings\" table (T2) using the \"raceId\" field to retrieve the standings of drivers in that race.\n\n3. **Join drivers**: Link the \"driverStandings\" table (T2) to the \"drivers\" table (T3) using the \"driverId\" field to obtain the names of the drivers.\n\n4. **Filter and select**: From the joined tables, select the forename and surname of the drivers who participated in the 2010 Singapore Grand Prix.\n\n5. **Order results**: Arrange the results in ascending order based on the drivers' position standings (T2.position).\n\nThe final output is a list of drivers' names ordered by their finishing positions in the 2010 Singapore Grand Prix."
        ]
    },
    "1073": {
        "sql": "SELECT COUNT(*) AS match_count\nFROM Match\nWHERE league_id = (SELECT id FROM League WHERE name = 'Germany 1. Bundesliga')\nAND strftime('%Y-%m', date) BETWEEN '2008-08' AND '2008-10';",
        "question": "How many matches were held in the league Germany 1. Bundesliga\nfrom August to October 2008?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Germany 1. Bundesliga' AND SUBSTR(t2.`date`, 1, 7) BETWEEN '2008-08' AND '2008-10'",
        "explain": "Germany 1. Bundesliga refers to League.name = 'Germany 1. Bundesliga'; from August to October 2008 refers to strftime('%Y-%m', date) BETWEEN '2008-08' AND '2008-10';",
        "solution": []
    },
    "716": {
        "sql": "SELECT (SUM(CASE WHEN T1.UpVotes = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(T2.Id)) AS percentage_zero_upvotes\nFROM users T1\nJOIN comments T2 ON T1.Id = T2.UserId\nWHERE T2.Score BETWEEN 5 AND 10;",
        "question": "Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10",
        "explain": "percentage = DIVIDE(COUNT(UserId where UpVotes = 0 and Score BETWEEN 5 and 10))*100, (COUNT(UserId where Score BETWEEN 5 and 10));",
        "solution": [
            "To solve the question, we need to determine the percentage of users with 0 up votes among the comments that have scores between 5 and 10. Here are the steps to achieve this:\n\n1. **Join the Tables**: Combine the `users` table (referred to as `T1`) and the `comments` table (referred to as `T2`) using the `Id` column from the `users` table and the `UserId` column from the `comments` table. This ensures we link each comment to its respective user.\n\n2. **Filter Comments by Score**: From the joined tables, filter out only those comments where the `Score` column in the `comments` table (`T2.Score`) is between 5 and 10 (inclusive).\n\n3. **Count Total Comments**: Calculate the total number of comments that meet the score criteria (i.e., comments with scores between 5 and 10). This is done by counting the `Id` values in the `comments` table (`T2.Id`).\n\n4. **Count Users with 0 Up Votes**: Among the filtered comments, count how many users have 0 up votes. This is done by summing the instances where the `UpVotes` column in the `users` table (`T1.UpVotes`) equals 0. Each such instance is counted as 1, and others as 0.\n\n5. **Calculate Percentage**: Divide the count of users with 0 up votes by the total number of comments (from step 3) and multiply by 100 to get the percentage. The result is cast to a real number to ensure accurate division.\n\nThe final result is the percentage of users with 0 up votes among the comments with scores between 5 and 10."
        ]
    },
    "727": {
        "sql": "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Sauron';",
        "question": "Who is the publisher of Sauron?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Sauron'",
        "explain": "the publisher refers to publisher_name; Sauron refers to superhero_name = 'Sauron'",
        "solution": []
    },
    "1391": {
        "sql": "SELECT \n    (SELECT COUNT(*) FROM member WHERE link_to_major IN (SELECT major_id FROM major WHERE major_name = 'Finance')) AS finance_count,\n    (SELECT COUNT(*) FROM member WHERE link_to_major IN (SELECT major_id FROM major WHERE major_name = 'Physics')) AS physics_count,\n    (SELECT CAST(finance_count AS REAL) / physics_count) AS ratio\nFROM (SELECT 1);",
        "question": "What is the ratio between students majored in finance and physics?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) / SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END) AS ratio FROM major",
        "explain": "DIVDE(SUM(major_name = 'Finance'), SUM(major_name = 'Physics'))",
        "solution": [
            "To find the ratio between students majoring in finance and physics, follow these steps:\n\n1. **Count the number of students majoring in Finance**:\n   - Scan the `major` table and count each record where the `major_name` is 'Finance'.\n\n2. **Count the number of students majoring in Physics**:\n   - Similarly, scan the `major` table and count each record where the `major_name` is 'Physics'.\n\n3. **Calculate the ratio**:\n   - Divide the count of Finance majors by the count of Physics majors to get the ratio.\n\nThis process ensures that the ratio is computed accurately by comparing the two distinct counts.",
            "To determine the ratio between students majoring in finance and physics, execute the following steps:\n\n1. **Aggregate the counts for Finance majors**:\n   - Traverse the `major` table and sum the occurrences where the `major_name` field equals 'Finance'. Each matching record contributes a value of 1 to the sum, while non-matching records contribute 0.\n\n2. **Aggregate the counts for Physics majors**:\n   - Similarly, traverse the `major` table and sum the occurrences where the `major_name` field equals 'Physics'. Each matching record contributes a value of 1 to the sum, while non-matching records contribute 0.\n\n3. **Compute the ratio**:\n   - Divide the sum of Finance majors by the sum of Physics majors to obtain the desired ratio.\n\nThis method ensures the ratio is calculated precisely by leveraging conditional aggregation to count the relevant records."
        ]
    },
    "441": {
        "sql": "SELECT T2.setCode FROM set_translations T2 JOIN sets T1 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13';",
        "question": "State the set code of the set with release date of 07/13/2007?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'",
        "explain": "",
        "solution": [
            "To find the set code of the set with a release date of 07/13/2007, follow these steps:\n\n1. **Identify the tables involved**: The query uses two tables, `sets` (referred to as `T1`) and `set_translations` (referred to as `T2`).\n\n2. **Understand the join condition**: The query joins these two tables on the condition that the `setCode` column in `T2` matches the `code` column in `T1`.\n\n3. **Apply the filter condition**: The query filters the results to only include rows where the `releaseDate` column in `T1` is equal to '2007-07-13'.\n\n4. **Select the desired column**: The query retrieves the `setCode` column from the `T2` table for the matching rows.\n\nIn summary, the query retrieves the set code from the `set_translations` table for the set that was released on July 13, 2007, by joining it with the `sets` table and filtering for the specific release date."
        ]
    },
    "752": {
        "sql": "SELECT superhero.superhero_name\nFROM superhero\nJOIN race ON superhero.race_id = race.id\nWHERE race.race = 'Alien';",
        "question": "Give the name of the alien superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "explain": "alien superheroes refers to race = 'Alien'; name of superhero refers to superhero_name;",
        "solution": []
    },
    "379": {
        "sql": "SELECT id FROM cards WHERE duelDeck = 'a';",
        "question": "What are the cards belong to duel deck a? List the ID.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE duelDeck = 'a'",
        "explain": "duel deck a refers to duelDeck = a;",
        "solution": []
    },
    "50": {
        "sql": "SELECT T2.MailStreet, T2.School\nFROM satscores T1\nJOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 6, 1;",
        "question": "What is the postal street address for the school with the 7th highest Math average? Indicate the school's name.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 6, 1",
        "explain": "Postal street and mailing street are synonyms.",
        "solution": [
            "To find the postal street address for the school with the 7th highest Math average, follow these steps:\n\n1. **Join the Tables**: Combine the `satscores` table (aliased as `T1`) and the `schools` table (aliased as `T2`) using the common field `T1.cds` (from `satscores`) and `T2.CDSCode` (from `schools`). This ensures that the data from both tables is linked correctly.\n\n2. **Sort by Math Average**: Order the combined dataset by the `AvgScrMath` column from the `satscores` table in descending order (`DESC`). This arranges the schools from the highest to the lowest Math average.\n\n3. **Select the 7th Highest**: Use the `LIMIT` clause to skip the first 6 rows (`LIMIT 6, 1`), which effectively selects the 7th row in the sorted list. This row corresponds to the school with the 7th highest Math average.\n\n4. **Retrieve Required Information**: From the selected row, extract the `MailStreet` (postal street address) and `School` (school name) columns from the `schools` table (`T2`).\n\nThe final output will display the postal street address and the name of the school with the 7th highest Math average."
        ]
    },
    "193": {
        "sql": "SELECT d.client_id, t2.district_id, t2.A2\nFROM disp d\nJOIN account t1 ON d.account_id = t1.account_id\nJOIN district t2 ON t1.district_id = t2.district_id\nWHERE d.type = 'OWNER';",
        "question": "List all ID and district for clients that can only have the right to issue permanent orders or apply for loans.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.client_id, T2.district_id, T2.A2 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id WHERE T3.type = 'OWNER'",
        "explain": "Only the owner accounts have the right to issue permanent orders or apply for loans",
        "solution": [
            "To list all client IDs and districts for clients who have the right to issue permanent orders or apply for loans, follow these steps:\n\n1. **Join the `account` table (T1) with the `district` table (T2)** using the `district_id` field. This links each account to its corresponding district.\n\n2. **Join the resulting table with the `disp` table (T3)** using the `account_id` field. This connects each account to its associated client.\n\n3. **Filter the results** to include only those records where the `type` field in the `disp` table (T3) is 'OWNER'. This ensures that only clients with ownership rights (who can issue permanent orders or apply for loans) are included.\n\n4. **Select the required fields**: `client_id` from the `disp` table (T3), and `district_id` and `A2` (district name) from the `district` table (T2).\n\nThe final output will be a list of client IDs along with their district IDs and names, filtered to include only owner clients."
        ]
    },
    "275": {
        "sql": "SELECT DISTINCT molecule_id FROM bond WHERE bond_type = '=';",
        "question": "Give me the molecule ID of the double bond type.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '='",
        "explain": "double bond refers to bond_type = ' = ';",
        "solution": [
            "To find the molecule IDs of the double bond type, perform the following steps:\n1. Access the 'bond' table in the database.\n2. Filter the records in the 'bond' table to only include those where the 'bond_type' column has the value '=' (indicating a double bond).\n3. From the filtered records, retrieve the distinct values in the 'molecule_id' column to ensure each molecule ID is listed only once, even if it has multiple double bonds.\n4. Return the list of distinct molecule IDs as the result."
        ]
    },
    "59": {
        "sql": "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName2 = 'Mike' AND AdmLName2 = 'Larson') OR (AdmFName3 = 'Mike' AND AdmLName3 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez') OR (AdmFName2 = 'Dante' AND AdmLName2 = 'Alvarez') OR (AdmFName3 = 'Dante' AND AdmLName3 = 'Alvarez');",
        "question": "What is the website for the schools under the administrations of Mike Larson and Dante Alvarez?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez')",
        "explain": "",
        "solution": []
    },
    "1091": {
        "sql": "SELECT COUNT(*) AS number_of_matches\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Belgium Jupiler League')\nAND date LIKE '2009-04-%';",
        "question": "How many matches were held in the Belgium Jupiler League in April, 2009?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND SUBSTR(t2.`date`, 1, 7) = '2009-04'",
        "explain": "Belgium Jupiler League refers to League.name = 'Belgium Jupiler League'; in April, 2009 refers to SUBSTR(`date`, 1, 7);",
        "solution": []
    },
    "1247": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' \nAND T2.WBC > 3.5 AND T2.WBC < 9.0 \nAND (T2.FG <= 150 OR T2.FG >= 450);",
        "question": "Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'",
        "explain": "male patients refers to Sex = 'M'; normal level of white blood cells refers to WBC > 3.5 and WBC <9.0; abnormal fibrinogen level refers to FG < = 150 or FG > = 450; Don't compute repetitive ones.",
        "solution": [
            "To solve the question, we need to count the number of distinct male patients who have a normal white blood cell (WBC) level but an abnormal fibrinogen (FG) level. Here are the steps:\n\n1. **Identify Male Patients**: Filter the `Patient` table to include only male patients (where `SEX = 'M'`).\n\n2. **Check Normal WBC Levels**: From the `Laboratory` table, ensure the patients have a normal WBC level, which is between 3.5 and 9.0 (where `WBC > 3.5 AND WBC < 9.0`).\n\n3. **Check Abnormal FG Levels**: From the same `Laboratory` table, ensure the patients have an abnormal FG level, which is either less than or equal to 150 or greater than or equal to 450 (where `FG <= 150 OR FG >= 450`).\n\n4. **Count Distinct Patients**: Count the distinct patient IDs that meet all the above criteria to avoid duplicates.\n\nThe SQL query combines these steps by joining the `Patient` and `Laboratory` tables on the patient ID, applying the filters, and then counting the distinct patient IDs.",
            "To solve the question, we need to count the number of distinct male patients who have a normal white blood cell (WBC) level but an abnormal fibrinogen (FG) level. Here are the detailed steps:\n\n1. **Identify Male Patients**: Filter the `Patient` table (referred to as `T1` in the SQL) to include only male patients by checking the condition `T1.SEX = 'M'`.\n\n2. **Join with Laboratory Data**: Join the filtered `Patient` table (`T1`) with the `Laboratory` table (referred to as `T2` in the SQL) using the patient ID (`T1.ID = T2.ID`). This ensures we have both patient and laboratory data for analysis.\n\n3. **Check Normal WBC Levels**: From the joined data, ensure the patients have a normal WBC level by applying the condition `T2.WBC > 3.5 AND T2.WBC < 9.0`. This filters out patients with WBC levels outside the normal range.\n\n4. **Check Abnormal FG Levels**: From the same joined data, ensure the patients have an abnormal FG level by applying the condition `T2.FG <= 150 OR T2.FG >= 450`. This filters out patients with FG levels within the normal range.\n\n5. **Count Distinct Patients**: Finally, count the distinct patient IDs (`T1.ID`) from the filtered and joined data to avoid counting duplicates. This is done using `COUNT(DISTINCT T1.ID)`.\n\nThe SQL query combines these steps by joining the `Patient` and `Laboratory` tables, applying the necessary filters, and then counting the distinct patient IDs that meet all the criteria."
        ]
    },
    "1272": {
        "sql": "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.SSA NOT IN ('negative', '0')\nORDER BY p.`First Date` ASC\nLIMIT 1;",
        "question": "Which patient is the first patient with an abnormal anti-SSA to come to the hospital? Please give his or her ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` IS NOT NULL AND T2.SSA NOT IN ('negative', '0') ORDER BY T1.`First Date` ASC LIMIT 1",
        "explain": "first patient refers to ID with MIN(`First Date`); abnormal anti-SSA refers to SSA NOT IN('negative', '0');",
        "solution": []
    },
    "434": {
        "sql": "SELECT COUNT(DISTINCT s.code) \nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Japanese'\nAND s.mtgoCode IS NULL;",
        "question": "How many sets are available just in Japanese and not in Magic: The Gathering Online?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.language = 'Japanese'  AND (T1.mtgoCode IS NULL OR T1.mtgoCode = '')",
        "explain": "Japanese refers to language = 'Japanese'; not in Magic: The Gathering Online refers to mtgoCode is null or mtgoCode = ''",
        "solution": []
    },
    "977": {
        "sql": "SELECT COUNT(*) AS disqualified_finishers\nFROM results\nWHERE raceId > 50 AND raceId < 100\n  AND time IS NOT NULL\n  AND statusId = 2;",
        "question": "From race no. 50 to 100, how many finishers have been disqualified?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(time IS NOT NULL, 1, 0)) FROM results WHERE statusId = 2 AND raceID < 100 AND raceId > 50",
        "explain": "disqualified refers to statusID = 2, finisher refers to time! = null; race no. refers to raceId; raceId > 50 and raceId < 100;",
        "solution": []
    },
    "424": {
        "sql": "SELECT (COUNT(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 END) * 100.0 / COUNT(*)) AS proportion\nFROM cards;",
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "explain": "do not have a text box refers to isTextless = 1; proportion refers to DIVIDE(COUNT(Textless = 1 and layout = 'normal'),COUNT(Textless))*100",
        "solution": [
            "To determine the proportion of cards that do not have a text box with a normal layout, follow these steps:\n\n1. **Identify the relevant columns**: The query uses the `isTextless` and `layout` columns from the `cards` table.\n2. **Filter the cards**: For each card, check if it meets the condition where `isTextless` is 1 (indicating the card does not have a text box) and the `layout` is 'normal'.\n3. **Count the matching cards**: Sum the number of cards that satisfy the above condition.\n4. **Calculate the total number of cards**: Count all the cards in the `cards` table.\n5. **Compute the proportion**: Divide the count of matching cards by the total number of cards, then multiply by 100 to get the percentage.\n\nThe result is the percentage of cards that do not have a text box with a normal layout."
        ]
    },
    "1488": {
        "sql": "SELECT c.CustomerID, SUM(ym.Consumption) AS TotalConsumption\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE c.Segment = 'KAM'\nGROUP BY c.CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1;",
        "question": "Who among KAM's customers consumed the most? How much did it consume?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.CustomerID, SUM(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' GROUP BY T2.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "explain": "",
        "solution": []
    },
    "135": {
        "sql": "SELECT COUNT(DISTINCT T1.account_id) \nFROM trans T1 \nJOIN account T2 ON T1.account_id = T2.account_id \nWHERE T1.balance < 0 \nAND T1.operation = 'VYBER KARTOU' \nAND T2.frequency = 'POPLATEK MESICNE';",
        "question": "After making a credit card withdrawal, how many account/s with monthly issuance has a negative balance?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.balance < 0 AND T1.operation = 'VYBER KARTOU' AND T2.frequency = 'POPLATEK MESICNE'",
        "explain": "Negative balance means balance < 0; Operation = 'VYBER KARTOU' stands for credit card withdraw. Frequency = 'POPLATEK MESICNE' stands for monthly issurance",
        "solution": [
            "To solve the question, we need to count the number of accounts that meet the following conditions:\n1. The account has a transaction with a negative balance.\n2. The transaction operation is a credit card withdrawal (denoted as 'VYBER KARTOU').\n3. The account has a monthly issuance frequency (denoted as 'POPLATEK MESICNE').\n\nThe steps to achieve this are:\n1. Join the 'trans' table (aliased as T1) with the 'account' table (aliased as T2) using the 'account_id' field.\n2. Filter the joined data to include only transactions where the balance is negative (T1.balance < 0).\n3. Further filter to include only transactions where the operation is a credit card withdrawal (T1.operation = 'VYBER KARTOU').\n4. Filter the accounts to include only those with a monthly issuance frequency (T2.frequency = 'POPLATEK MESICNE').\n5. Count the number of distinct account IDs that meet all the above conditions.\n\nThe result will be the count of such accounts.",
            "To solve the question, we need to count the number of accounts that meet the following conditions:\n1. The account has a transaction with a negative balance (T1.balance < 0).\n2. The transaction operation is a credit card withdrawal (T1.operation = 'VYBER KARTOU').\n3. The account has a monthly issuance frequency (T2.frequency = 'POPLATEK MESICNE').\n\nThe steps to achieve this are:\n1. Join the 'trans' table (aliased as T1) with the 'account' table (aliased as T2) using the 'account_id' field (T1.account_id = T2.account_id).\n2. Filter the joined data to include only transactions where the balance is negative (T1.balance < 0).\n3. Further filter to include only transactions where the operation is a credit card withdrawal (T1.operation = 'VYBER KARTOU').\n4. Filter the accounts to include only those with a monthly issuance frequency (T2.frequency = 'POPLATEK MESICNE').\n5. Count the number of distinct account IDs (COUNT(T1.account_id)) that meet all the above conditions.\n\nThe result will be the count of such accounts."
        ]
    },
    "374": {
        "sql": "SELECT COUNT(*) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo';",
        "question": "How many black border cards are only available on mtgo?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE availability = 'mtgo' AND borderColor = 'black'",
        "explain": "black border card refers to borderColor = black; available on mtgo refers to availability = mtgo;\n\nadd quotes for string = 'black' and = 'mtgo'",
        "solution": []
    },
    "442": {
        "sql": "SELECT DISTINCT T1.baseSetSize, T2.setCode\nFROM sets T1\nJOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T1.block IN ('Masques', 'Mirage');",
        "question": "Mention the base set size and set code of the set that was in block named \"Masques\" and \"Mirage\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.baseSetSize, T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block IN ('Masques', 'Mirage')",
        "explain": "",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct Values**: Retrieve unique combinations of `baseSetSize` and `setCode` from the database.\n\n2. **Join Tables**: Combine the `sets` table (aliased as `T1`) with the `set_translations` table (aliased as `T2`) using the condition that the `setCode` in `T2` matches the `code` in `T1`.\n\n3. **Filter by Block**: Only include rows where the `block` field in the `sets` table (`T1`) is either \"Masques\" or \"Mirage\".\n\n4. **Output Columns**: The final output will display the `baseSetSize` from the `sets` table (`T1`) and the `setCode` from the `set_translations` table (`T2`).\n\nThis ensures that the result includes the base set size and set code for sets that belong to either the \"Masques\" or \"Mirage\" block."
        ]
    },
    "258": {
        "sql": "SELECT DISTINCT b.bond_type\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'sn';",
        "question": "What are the bond type for atoms with element Tin?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "explain": "element Tin refers to element = 'sn'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#'",
        "solution": []
    },
    "1107": {
        "sql": "WITH HighestCrossing AS (\n    SELECT t2.date, t2.crossing\n    FROM Player t1\n    JOIN Player_Attributes t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\n    WHERE t1.player_name = 'Kevin Constant'\n    ORDER BY t2.crossing DESC, t2.date ASC\n    LIMIT 1\n)\nSELECT date\nFROM HighestCrossing;",
        "question": "When was the first time did Kevin Constant have his highest crossing score? Give the date.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT `date` FROM ( SELECT t2.crossing, t2.`date` FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Kevin Constant' ORDER BY t2.crossing DESC) ORDER BY date DESC LIMIT 1",
        "explain": "Kevin Constant refers to player_name = 'Kevin Constant'; highest crossing score refers to MAX(crossing)",
        "solution": [
            "To find the date when Kevin Constant first achieved his highest crossing score, follow these steps:\n\n1. **Identify the Player**: Locate the player named 'Kevin Constant' in the `Player` table.\n\n2. **Retrieve Attributes**: Join the `Player` table with the `Player_Attributes` table using the `player_fifa_api_id` to access Kevin Constant's crossing scores and the corresponding dates.\n\n3. **Sort by Crossing Score**: Order the results by the `crossing` score in descending order to prioritize the highest scores.\n\n4. **Sort by Date**: From the sorted list of crossing scores, order the results by `date` in descending order to find the earliest occurrence of the highest score.\n\n5. **Limit Results**: Select the top result to get the earliest date when the highest crossing score was achieved.\n\nThe final output will be the date when Kevin Constant first had his highest crossing score.",
            "To determine the date when Kevin Constant first achieved his highest crossing score, the following steps are executed in the SQL query:\n\n1. **Player Identification**: The query starts by identifying the player named 'Kevin Constant' in the `Player` table (aliased as `t1`).\n\n2. **Table Join**: The `Player` table (`t1`) is joined with the `Player_Attributes` table (aliased as `t2`) using the `player_fifa_api_id` column. This join ensures that all attributes (including crossing scores and dates) for Kevin Constant are retrieved.\n\n3. **Filtering**: The query filters the results to only include records where the player's name is 'Kevin Constant'.\n\n4. **Sorting by Crossing Score**: The results are then sorted in descending order based on the `crossing` score from the `Player_Attributes` table (`t2`). This ensures that the highest crossing score appears first.\n\n5. **Subquery for Sorting by Date**: The sorted results (by crossing score) are then passed into a subquery. Within this subquery, the results are further sorted by the `date` column in descending order. This step ensures that the earliest date (when the highest crossing score was achieved) is prioritized.\n\n6. **Limiting Results**: Finally, the query limits the output to the first row of the sorted subquery, which corresponds to the earliest date when Kevin Constant had his highest crossing score.\n\nThe output of this query is the `date` from the `Player_Attributes` table, representing the first occurrence of Kevin Constant's highest crossing score."
        ]
    },
    "1227": {
        "sql": "SELECT AVG(strftime('%Y', 'now') - strftime('%Y', Birthday)) AS average_age\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.SEX = 'M' AND Laboratory.\"T-CHO\" >= 250;",
        "question": "What is the average age of the male patient with high cholesterol?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-CHO` >= 250 AND T1.SEX = 'M'",
        "explain": "average age = DIVIDE(SUM(SUBTRACT(YEAR(NOW()), YEAR(birthday))), COUNT(ID)); male patient refers to sex = 'M'; high cholesterol refers to `T-CHO` > = 250;",
        "solution": []
    },
    "1095": {
        "sql": "SELECT AVG(buildUpPlaySpeed) AS average_build_up_play_speed\nFROM Team_Attributes\nJOIN Team ON Team_Attributes.team_api_id = Team.team_api_id\nWHERE Team.team_long_name = 'Heart of Midlothian';",
        "question": "How much is the average build up play speed of the Heart of Midlothian team?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Heart of Midlothian'",
        "explain": "Heart of Midlothian refers to team_long_name = 'Heart of Midlothian'; average build up play speed refers to\u00a0 AVG(buildUpPlaySpeed)",
        "solution": []
    },
    "247": {
        "sql": "SELECT DISTINCT a.element FROM atom a WHERE a.element NOT IN (SELECT DISTINCT a1.element FROM atom a1 JOIN connected c ON a1.atom_id = c.atom_id OR a1.atom_id = c.atom_id2);",
        "question": "List all the elements of atoms that can not bond with any other atoms.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.element NOT IN ( SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id )",
        "explain": " atoms cannot bond with other atoms means atom_id NOT in connected table;",
        "solution": [
            "To list all the elements of atoms that cannot bond with any other atoms, follow these steps:\n\n1. **Identify all elements in the `atom` table**: Retrieve all distinct elements from the `atom` table.\n\n2. **Exclude elements that can bond with other atoms**: From the list of all elements, exclude those elements that appear in the `connected` table (indicating they can bond with other atoms). This is done by checking the `element` column in the `atom` table against the `element` column of atoms that have entries in the `connected` table.\n\n3. **Return the result**: The final result is a list of distinct elements from the `atom` table that do not appear in the subset of elements that can bond with other atoms.\n\nThis process ensures that only elements with no bonding capability are listed."
        ]
    },
    "491": {
        "sql": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';",
        "question": "What's the magic card market name for the set which was released on 2017/6/9?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "explain": "magic card market name refers to mcmName",
        "solution": []
    },
    "1273": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE';",
        "question": "How many patients have a normal anti-SSB and are diagnosed with SLE in the examination?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Diagnosis = 'SLE'",
        "explain": "normal anti-SSB refers to SSB IN('-', '+-'); '-' is expressed as 'negative' and '+-' is expressed as '0' in the database ; diagnosed with SLE refers to Diagnosis = 'SLE'; Should compute the number of distinct ones",
        "solution": [
            "To solve the question, \"How many patients have a normal anti-SSB and are diagnosed with SLE in the examination?\", the following steps are performed:\n\n1. **Identify the Tables**: The query involves two tables, `Patient` (referred to as `T1`) and `Laboratory` (referred to as `T2`).\n\n2. **Join the Tables**: The tables are joined using the `ID` column, which is common to both tables. This ensures that each patient's laboratory results are linked to their diagnosis.\n\n3. **Filter Conditions**:\n   - The `Laboratory` table (`T2`) is filtered to include only records where the `SSB` value is either 'negative' or '0'. This indicates a normal anti-SSB result.\n   - The `Patient` table (`T1`) is filtered to include only records where the `Diagnosis` is 'SLE' (Systemic Lupus Erythematosus).\n\n4. **Count Distinct Patients**: The query counts the distinct `ID` values from the `Patient` table (`T1`) that meet the above conditions. This ensures that each patient is counted only once, even if they have multiple laboratory results.\n\nThe final result is the count of unique patients who have a normal anti-SSB result and are diagnosed with SLE.",
            "To solve the question, \"How many patients have a normal anti-SSB and are diagnosed with SLE in the examination?\", the following detailed steps are performed:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (referred to as `T1`): Contains patient information, including their diagnosis.\n   - `Laboratory` (referred to as `T2`): Contains laboratory test results, including the anti-SSB values.\n\n2. **Join the Tables**: The tables are joined using the `ID` column, which is common to both tables. This ensures that each patient's laboratory results are correctly linked to their diagnosis.\n\n3. **Filter Conditions**:\n   - The `Laboratory` table (`T2`) is filtered to include only records where the `SSB` value is either 'negative' or '0'. This indicates a normal anti-SSB result.\n   - The `Patient` table (`T1`) is filtered to include only records where the `Diagnosis` is 'SLE' (Systemic Lupus Erythematosus).\n\n4. **Count Distinct Patients**: The query counts the distinct `ID` values from the `Patient` table (`T1`) that meet the above conditions. This ensures that each patient is counted only once, even if they have multiple laboratory results.\n\nThe final result is the count of unique patients who have a normal anti-SSB result and are diagnosed with SLE."
        ]
    },
    "1462": {
        "sql": "SELECT b.category, b.amount\nFROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_name = 'January Speaker';",
        "question": "What category was budgeted for the 'January Speaker' event and how much was the amount budgeted for that category?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category, T2.amount FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'January Speaker'",
        "explain": "amount budgeted refers to amount, 'January Speaker' is the event name;",
        "solution": []
    },
    "545": {
        "sql": "SELECT COUNT(*) \nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie' AND p.ParentId IS NULL;",
        "question": "Among the posts owned by csgillespie, how many of them are root posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' AND T1.ParentId IS NULL",
        "explain": "\"csgillespie\" is the DisplayName of user; root post refers to ParentId IS Null",
        "solution": []
    },
    "1181": {
        "sql": "SELECT \n    strftime('%Y', '1991-10-21') - strftime('%Y', p.Birthday) - \n    (CASE \n        WHEN strftime('%m-%d', '1991-10-21') < strftime('%m-%d', p.Birthday) THEN 1 \n        ELSE 0 \n    END) AS Age\nFROM \n    Patient p\nJOIN \n    Laboratory l ON p.ID = l.ID\nWHERE \n    l.UA = 8.4 AND l.Date = '1991-10-21';",
        "question": "For the patient who got the laboratory test of uric acid level as 8.4 on 1991-10-21, how old was he/she at that time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UA = 8.4 AND T2.Date = '1991-10-21'",
        "explain": "how old at that time refers to SUBTRACT(year(test date), year(Birthday)); uric acid level as 8.4 refers to UA = '8.4'; 1991/10/21 refers to Date = '1991-10-21'",
        "solution": []
    },
    "1440": {
        "sql": "SELECT m.email\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost > 20\nAND e.expense_date BETWEEN '2019-09-10' AND '2019-11-19';",
        "question": "List emails of people who paid more than 20 dollars from 9/10/2019 to 11/19/2019.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.email FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE date(SUBSTR(T2.expense_date, 1, 10)) BETWEEN '2019-09-10' AND '2019-11-19' AND T2.cost > 20",
        "explain": "expense_date BETWEEN '2019-09-10' and '2019-11-19'; cost > 20",
        "solution": []
    },
    "303": {
        "sql": "SELECT COUNT(T1.bond_id) AS double_bond_count, T2.label AS is_carcinogenic\nFROM bond T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.molecule_id = 'TR006' AND T1.bond_type = '='\nGROUP BY T2.label;",
        "question": "How many double bonds does TR006 have and is it carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.bond_id), T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' AND T2.molecule_id = 'TR006' GROUP BY T2.label",
        "explain": "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; double bond refers to bond_type = ' = ';",
        "solution": [
            "To answer the question \"How many double bonds does TR006 have and is it carcinogenic?\", the following steps are performed:\n\n1. **Join the Tables**: The `bond` table (aliased as `T1`) is joined with the `molecule` table (aliased as `T2`) using the `molecule_id` field. This links each bond to its corresponding molecule.\n\n2. **Filter for TR006**: The query filters the results to only include records where the `molecule_id` in the `molecule` table (`T2`) is 'TR006'.\n\n3. **Filter for Double Bonds**: The query further filters the bonds to only include those where the `bond_type` is '=', indicating a double bond.\n\n4. **Count Double Bonds**: The query counts the number of double bonds (`bond_id`) for the molecule TR006.\n\n5. **Retrieve Carcinogenic Label**: The query also retrieves the `label` from the `molecule` table (`T2`) for TR006, which indicates whether the molecule is carcinogenic.\n\n6. **Group Results**: The results are grouped by the `label` from the `molecule` table to ensure the count and label are correctly paired.\n\nThe final output will show the count of double bonds in TR006 and its carcinogenic status (as indicated by the `label`)."
        ]
    },
    "963": {
        "sql": "SELECT COUNT(DISTINCT T1.driverId) AS french_drivers_with_low_laptime\nFROM drivers T1\nJOIN lapTimes T2 ON T1.driverId = T2.driverId\nWHERE T1.nationality = 'French'\nAND (\n  CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + \n  CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + \n  (CAST(SUBSTR(T2.time, 7) AS REAL) / 1000 < 120\n);",
        "question": "How many French drivers who obtain the laptime less than 02:00.00?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 on T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120",
        "explain": "lap time less than 02:00.00 refers to seconds < 120;",
        "solution": [
            "To solve the question \"How many French drivers who obtain the laptime less than 02:00.00?\", follow these steps:\n\n1. **Join the Tables**: Combine the `drivers` table (aliased as T1) and the `lapTimes` table (aliased as T2) using the `driverId` field to link them.\n\n2. **Filter by Nationality**: From the joined tables, filter the records to include only those where the `nationality` field in the `drivers` table (T1) is 'French'.\n\n3. **Convert and Compare Laptime**: For each record, convert the `time` field from the `lapTimes` table (T2) into a numerical value representing the total time in seconds. This is done by:\n   - Extracting the hours (first 2 characters), converting them to an integer, and multiplying by 60 to get minutes.\n   - Extracting the minutes (characters 4 and 5), converting them to an integer, and adding to the previous result.\n   - Extracting the seconds and milliseconds (characters 7 onwards), converting them to a real number, dividing by 1000, and adding to the total.\n   - Compare this total time to 120 seconds (equivalent to 02:00.00).\n\n4. **Count the Records**: Count the number of records that meet both the nationality and laptime conditions.\n\nThe final count represents the number of French drivers with a laptime less than 02:00.00.",
            "To solve the question \"How many French drivers who obtain the laptime less than 02:00.00?\", follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `drivers` table (aliased as T1) and the `lapTimes` table (aliased as T2) using the `driverId` field as the common key. This ensures that only records with matching `driverId` values in both tables are included.\n\n2. **Filter by Nationality**: From the joined result, filter the records to retain only those where the `nationality` field in the `drivers` table (T1) is exactly 'French'. This isolates the data to French drivers only.\n\n3. **Convert and Compare Laptime**: For each record, convert the `time` field from the `lapTimes` table (T2) into a numerical value representing the total time in seconds. This involves:\n   - Extracting the hours (first 2 characters of the `time` string), converting them to an integer, and multiplying by 60 to convert hours to minutes.\n   - Extracting the minutes (characters 4 and 5 of the `time` string), converting them to an integer, and adding this to the previous result to get total minutes.\n   - Extracting the seconds and milliseconds (characters 7 onwards of the `time` string), converting them to a real number, dividing by 1000 to convert milliseconds to seconds, and adding this to the total time in seconds.\n   - Compare this total time to 120 seconds (which is equivalent to 02:00.00). Only records where the total time is less than 120 seconds are retained.\n\n4. **Count the Records**: Count the number of records that satisfy both the nationality condition (French) and the laptime condition (less than 02:00.00). This count is the final answer to the question.\n\nThe SQL query provided accurately reflects these operations, ensuring the correct count of French drivers with laptimes under 02:00.00."
        ]
    },
    "1221": {
        "sql": "SELECT P.ID, P.SEX, P.Birthday\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'RA' AND L.UN < 30;",
        "question": "Provide the ID, sex, birthday of all patients diagnosed with 'RA' that are within the UN normal index.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN < 30 AND T1.Diagnosis = 'RA'",
        "explain": "within the UN normal index refers to UN < 30; Diagnosis = 'RA'",
        "solution": []
    },
    "704": {
        "sql": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample';",
        "question": "What is the excerpt post ID and wiki post ID of the tag named sample?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'",
        "explain": "tag named sample refers to TagName = 'sample';",
        "solution": []
    },
    "685": {
        "sql": "SELECT T2.ViewCount, T3.DisplayName\nFROM postHistory T1\nJOIN posts T2 ON T1.PostId = T2.Id\nJOIN users T3 ON T2.LastEditorUserId = T3.Id\nWHERE T1.Text = 'Computer Game Datasets'",
        "question": "Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.ViewCount, T3.DisplayName FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id WHERE T1.Text = 'Computer Game Datasets'",
        "explain": "total views refer to ViewCount; Name the user refers to DisplayName; post 'Computer Game Datasets' refers to Text = 'Computer Game Datasets';",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join the `postHistory` table (T1) with the `posts` table (T2)**: The join is performed using the condition `T1.PostId = T2.Id`. This links the post history records to their corresponding posts.\n\n2. **Join the result with the `users` table (T3)**: The join is performed using the condition `T2.LastEditorUserId = T3.Id`. This links the posts to the users who last edited them.\n\n3. **Filter the records**: The filter condition `T1.Text = 'Computer Game Datasets'` is applied to select only the records where the post history text matches 'Computer Game Datasets'.\n\n4. **Select the required fields**: The fields `T2.ViewCount` (total views on the post) and `T3.DisplayName` (name of the user who posted it last) are retrieved from the joined tables.\n\nThis sequence of operations ensures that the query identifies the total views on the post titled 'Computer Game Datasets' and the name of the user who last edited it."
        ]
    },
    "412": {
        "sql": "SELECT fd.name\nFROM foreign_data fd\nWHERE fd.language = 'French'\nAND fd.uuid IN (\n    SELECT c.uuid\n    FROM cards c\n    WHERE c.types LIKE '%Creature%'\n    AND c.layout = 'normal'\n    AND c.borderColor = 'black'\n    AND c.artist = 'Matthew D. Wilson'\n)",
        "question": "What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'",
        "explain": "in French refers to language = 'French'; black border color refers to borderColor = 'black'",
        "solution": [
            "To find the foreign name of the card in French that meets the specified criteria, follow these steps:\n\n1. **Identify the card(s)**: First, locate the card(s) in the `cards` table that have the following attributes:\n   - Type is 'Creature'.\n   - Layout is 'normal'.\n   - Border color is 'black'.\n   - Artist is 'Matthew D. Wilson'.\n   The `uuid` of these cards will be used to match them with their foreign names.\n\n2. **Retrieve the foreign name**: Using the `uuid` values obtained from the first step, query the `foreign_data` table to find the corresponding foreign names where the language is 'French'.\n\n3. **Return the result**: The result will be the name(s) from the `foreign_data` table that match the criteria, specifically the French names of the identified cards.",
            "To find the foreign name of the card in French that meets the specified criteria, follow these detailed steps:\n\n1. **Query the `cards` table**: \n   - Filter the `cards` table to retrieve the `uuid` of all cards that satisfy the following conditions:\n     - The `types` column must be 'Creature'.\n     - The `layout` column must be 'normal'.\n     - The `borderColor` column must be 'black'.\n     - The `artist` column must be 'Matthew D. Wilson'.\n   - This subquery will return the `uuid` values of the cards that match all these criteria.\n\n2. **Query the `foreign_data` table**: \n   - Using the `uuid` values obtained from the subquery, filter the `foreign_data` table to find the corresponding foreign names.\n   - The `language` column must be 'French' to ensure the names are in French.\n   - The `name` column from this table will contain the foreign names of the cards.\n\n3. **Return the result**: \n   - The final output will be the `name` values from the `foreign_data` table that correspond to the cards identified in the first step and are in French."
        ]
    },
    "924": {
        "sql": "SELECT r.date FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE c.name = 'Circuit de Barcelona-Catalunya';",
        "question": "Please list the exact dates on which a Formula_1 race took place on the Barcelona-Catalunya circuit.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "explain": "",
        "solution": [
            "To list the exact dates on which a Formula 1 race took place on the Barcelona-Catalunya circuit, follow these steps:\n\n1. **Identify the circuit**: Locate the circuit named 'Circuit de Barcelona-Catalunya' in the `circuits` table.\n2. **Retrieve the circuit ID**: Extract the `circuitId` of the identified circuit.\n3. **Find matching races**: In the `races` table, find all entries where the `circuitID` matches the `circuitId` obtained in the previous step.\n4. **Extract the dates**: From the matching race entries, select the `date` field to list the exact dates of the races.\n\nThis process ensures that only the dates of races held at the Barcelona-Catalunya circuit are listed."
        ]
    },
    "682": {
        "sql": "SELECT T2.Id, T1.DisplayName\nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE STRFTIME('%Y', T2.CreationDate) = '2010'\nORDER BY T2.FavoriteCount DESC\nLIMIT 1;",
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "explain": "the most valuable post in 2015 refers to MAX(FavoriteCount) where year(CreationDate) = 2010;",
        "solution": [
            "To find the most valuable post in 2010, follow these steps:\n\n1. **Join the tables**: Combine the `users` table (referred to as `T1`) and the `posts` table (referred to as `T2`) by matching the `Id` column in the `users` table with the `OwnerUserId` column in the `posts` table.\n\n2. **Filter by year**: From the joined data, filter the records to include only those where the year part of the `CreationDate` in the `users` table is '2010'.\n\n3. **Sort by value**: Order the filtered results by the `FavoriteCount` column in the `posts` table in descending order to prioritize posts with the highest value.\n\n4. **Select the top result**: Limit the output to the first record in the sorted list, which represents the most valuable post in 2010.\n\n5. **Retrieve the required fields**: From this top record, extract the `OwnerUserId` from the `posts` table and the `DisplayName` from the `users` table.\n\nThis process ensures that the most valuable post in 2010 is identified and its owner's display name and post ID are returned.",
            "To determine the most valuable post in 2010 and retrieve its ID along with the owner's display name, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `users` table (aliased as `T1`) and the `posts` table (aliased as `T2`). The join condition is that the `Id` column in the `users` table (`T1.Id`) must match the `OwnerUserId` column in the `posts` table (`T2.OwnerUserId`). This ensures that each post is linked to its respective owner.\n\n2. **Filter by Year**: Apply a filter to the joined data to include only those records where the year extracted from the `CreationDate` column in the `users` table (`T1.CreationDate`) is '2010'. This is done using the `STRFTIME('%Y', T1.CreationDate)` function to extract the year.\n\n3. **Sort by Favorite Count**: Sort the filtered results in descending order based on the `FavoriteCount` column in the `posts` table (`T2.FavoriteCount`). This ensures that the post with the highest value (highest `FavoriteCount`) appears at the top of the list.\n\n4. **Limit Results**: Restrict the output to only the first record from the sorted list using the `LIMIT 1` clause. This record represents the most valuable post in 2010.\n\n5. **Select Required Fields**: From the top record, select the `OwnerUserId` from the `posts` table (`T2.OwnerUserId`) and the `DisplayName` from the `users` table (`T1.DisplayName`). These fields provide the post's owner ID and their display name.\n\nThis method ensures that the query accurately identifies the most valuable post in 2010 and returns the requested details."
        ]
    },
    "1359": {
        "sql": "WITH filtered_budget AS (\n    SELECT * FROM budget WHERE category = 'Advertisement'\n),\nfiltered_event AS (\n    SELECT * FROM event WHERE type = 'Meeting'\n),\nyearly_kickoff_sum AS (\n    SELECT SUM(T1.amount) AS sum_amount\n    FROM filtered_budget T1\n    JOIN filtered_event T2 ON T1.link_to_event = T2.event_id\n    WHERE T2.event_name = 'Yearly Kickoff'\n),\noctober_meeting_sum AS (\n    SELECT SUM(T1.amount) AS sum_amount\n    FROM filtered_budget T1\n    JOIN filtered_event T2 ON T1.link_to_event = T2.event_id\n    WHERE T2.event_name = 'October Meeting'\n)\nSELECT CAST((SELECT sum_amount FROM yearly_kickoff_sum) AS REAL) / \n       CAST((SELECT sum_amount FROM october_meeting_sum) AS REAL) AS budget_ratio;",
        "question": "How many times was the budget in Advertisement for \"Yearly Kickoff\" meeting more than \"October Meeting\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting'",
        "explain": "budget in Advertisement refer to category = 'Advertisement' in the budget table; DIVIDE(SUM(amount when event_name = 'Yearly Kickoff'), SUM(amount when event_name = 'October Meeting'))",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Filtering Data**: \n   - From the `budget` table (referred to as `T1`), filter records where the `category` is 'Advertisement'.\n   - From the `event` table (referred to as `T2`), filter records where the `type` is 'Meeting'.\n\n2. **Joining Tables**: \n   - Join the filtered `budget` table (`T1`) with the filtered `event` table (`T2`) using the condition `T1.link_to_event = T2.event_id`.\n\n3. **Calculating Sums**: \n   - For the joined records, calculate the sum of the `amount` field from `T1` where the `event_name` in `T2` is 'Yearly Kickoff'.\n   - Similarly, calculate the sum of the `amount` field from `T1` where the `event_name` in `T2` is 'October Meeting'.\n\n4. **Computing the Ratio**: \n   - Divide the sum calculated for 'Yearly Kickoff' by the sum calculated for 'October Meeting'.\n   - Cast the result of the division to a `REAL` data type to ensure it is a floating-point number.\n\nThis sequence of operations answers the question by determining how many times the budget for 'Yearly Kickoff' meetings in the 'Advertisement' category exceeds the budget for 'October Meeting' meetings in the same category."
        ]
    },
    "1399": {
        "sql": "SELECT CASE WHEN EXISTS (SELECT 1 FROM member T1 JOIN attendance T2 ON T1.member_id = T2.link_to_member JOIN event T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean' AND T3.event_name = 'Women''s Soccer') THEN 'YES' ELSE 'NO' END AS attendance_status;",
        "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
        "explain": "Maya Mclean is the full name; full name refers to first_name, last_name; 'Women's Soccer' is an event_name",
        "solution": [
            "To determine if Maya Mclean attended the 'Women's Soccer' event, the following steps are performed:\n\n1. **Identify Maya Mclean's Record**:\n   - Search the `member` table (referred to as `T1`) for a record where the `first_name` is 'Maya' and the `last_name` is 'Mclean'.\n   - Retrieve the `member_id` of this record.\n\n2. **Check Attendance Records**:\n   - Join the `attendance` table (referred to as `T2`) with the `member` table using the `member_id` (`T1.member_id = T2.link_to_member`) to find all events attended by Maya Mclean.\n\n3. **Identify the 'Women's Soccer' Event**:\n   - Join the `event` table (referred to as `T3`) with the `attendance` table using the `event_id` (`T2.link_to_event = T3.event_id`) to get the details of the events Maya attended.\n   - Check if any of these events have the `event_name` 'Women's Soccer'.\n\n4. **Return the Result**:\n   - If the event name matches 'Women's Soccer', return 'YES' as the result.\n   - If no such event is found, the result will be `NULL` (implicitly indicating 'NO').",
            "To determine if Maya Mclean attended the 'Women's Soccer' event, the following detailed steps are performed:\n\n1. **Identify Maya Mclean's Record**:\n   - Query the `member` table (referred to as `T1`) to locate the record where the `first_name` is 'Maya' and the `last_name` is 'Mclean'.\n   - Extract the `member_id` from this record, which uniquely identifies Maya Mclean in the database.\n\n2. **Retrieve Attendance Records for Maya Mclean**:\n   - Perform an inner join between the `attendance` table (referred to as `T2`) and the `member` table (`T1`) using the `member_id` (`T1.member_id = T2.link_to_member`). This join ensures that only attendance records linked to Maya Mclean are considered.\n\n3. **Identify the 'Women's Soccer' Event**:\n   - Perform another inner join between the `event` table (referred to as `T3`) and the `attendance` table (`T2`) using the `event_id` (`T2.link_to_event = T3.event_id`). This join links the attendance records to their corresponding event details.\n   - Filter the results to check if any of the events attended by Maya Mclean have the `event_name` 'Women's Soccer'.\n\n4. **Return the Result**:\n   - Use a `CASE` statement to evaluate the `event_name` in the `event` table (`T3`). If the `event_name` matches 'Women's Soccer', the query returns 'YES' as the result.\n   - If no matching event is found, the result will be `NULL`, which implicitly indicates that Maya Mclean did not attend the 'Women's Soccer' event.\n\nThe SQL query encapsulates these steps concisely, ensuring accuracy and efficiency in determining the attendance status."
        ]
    },
    "1258": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nJOIN Laboratory L ON P.ID = L.ID\nWHERE E.KCT = '+' AND L.RA IN ('-', '+-');",
        "question": "How many patients with a normal Rhuematoid Factor has a positive measure of degree of coagulation?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T3.KCT = '+'",
        "explain": "normal Rhuematoid Factor refers TO RA IN('-', '+-'); positive measure of degree of coagulation refers to KCT = '+'; Should compute the number of distinct ones",
        "solution": []
    },
    "789": {
        "sql": "SELECT AVG(s.weight_kg) AS average_weight\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE r.race = 'Alien';",
        "question": "Find the average weight of the heroes who are aliens.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "explain": "average = AVG(weight_kg); aliens refers to race = 'Alien';",
        "solution": []
    },
    "1075": {
        "sql": "SELECT t1.player_name\nFROM Player t1\nJOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.potential = 61\nORDER BY t2.balance DESC\nLIMIT 1;",
        "question": "List all the football player with the highest balance score and potential score of 61.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = '61' ORDER BY t2.balance DESC LIMIT 1",
        "explain": "balance score refers to balance; highest balance score refers to MAX(balance); potential score refers to potential; potential = 61;",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Join the Tables**: Combine the `Player` table (aliased as `t1`) with the `Player_Attributes` table (aliased as `t2`) using the `player_api_id` field as the common key.\n\n2. **Filter by Potential**: From the joined tables, filter the records to include only those players whose `potential` score is exactly '61'.\n\n3. **Sort by Balance**: Sort the filtered records in descending order based on the `balance` score to prioritize players with the highest balance.\n\n4. **Limit Results**: Select only the top record (the player with the highest balance score) from the sorted list.\n\n5. **Output the Result**: Display the `player_name` of the selected player.\n\nThis process ensures that the player with the highest balance score and a potential score of 61 is listed."
        ]
    },
    "448": {
        "sql": "SELECT DISTINCT T2.name, T1.type\nFROM cards T1\nJOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.watermark = 'abzan';",
        "question": "Name the foreign name of the card that has abzan watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'abzan'",
        "explain": "",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct Entries**: Retrieve distinct entries to avoid duplicates in the result.\n\n2. **Join Tables**: Combine the `cards` table (aliased as `T1`) with the `foreign_data` table (aliased as `T2`) using the `uuid` field as the common key. This ensures that the foreign name and type of the card are linked correctly.\n\n3. **Filter by Watermark**: Apply a filter to only include cards where the `watermark` field in the `cards` table is set to 'abzan'.\n\n4. **Retrieve Specific Fields**: From the filtered and joined data, extract the `name` and `type` fields from the `cards` table (`T1`).\n\nThe result will list the foreign name and type of the card(s) that have the 'abzan' watermark.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Select Distinct Entries**: The query begins by ensuring that only distinct (unique) entries are retrieved. This is done using the `SELECT DISTINCT` clause to avoid duplicate results in the output.\n\n2. **Join Tables**: The `cards` table (aliased as `T1`) is joined with the `foreign_data` table (aliased as `T2`) using the `uuid` field as the common key. This join operation links the card's primary data with its foreign data, ensuring that the foreign name and type of the card are correctly associated.\n\n3. **Filter by Watermark**: A filter is applied to the `cards` table (`T1`) to include only those cards where the `watermark` field is set to 'abzan'. This is specified in the `WHERE` clause (`WHERE T1.watermark = 'abzan'`).\n\n4. **Retrieve Specific Fields**: From the filtered and joined data, the query extracts the `name` and `type` fields from the `cards` table (`T1`). These fields represent the foreign name and type of the card(s) that meet the specified criteria.\n\nThe result of this query will list the distinct foreign names and types of all cards that have the 'abzan' watermark."
        ]
    },
    "995": {
        "sql": "SELECT AVG(T2.points) AS average_score\nFROM drivers T1\nJOIN driverStandings T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'\nAND T3.name = 'Turkish Grand Prix';",
        "question": "What is the average score of Lewis Hamilton among all the Turkish Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T3.name = 'Turkish Grand Prix'",
        "explain": "Average score = AVG(points)",
        "solution": [
            "To find the average score of Lewis Hamilton among all the Turkish Grand Prix, follow these steps:\n\n1. **Identify the relevant tables**: The data is spread across three tables:\n   - `drivers` (aliased as `T1`): Contains driver information, including names.\n   - `driverStandings` (aliased as `T2`): Contains the points scored by drivers in races.\n   - `races` (aliased as `T3`): Contains information about the races, including their names.\n\n2. **Filter drivers**: From the `drivers` table (`T1`), filter for the driver with the forename 'Lewis' and surname 'Hamilton'.\n\n3. **Join tables**:\n   - Join the `drivers` table (`T1`) with the `driverStandings` table (`T2`) using the `driverId` field to link the driver to their standings.\n   - Join the `driverStandings` table (`T2`) with the `races` table (`T3`) using the `raceId` field to link the standings to the specific races.\n\n4. **Filter races**: From the `races` table (`T3`), filter for races where the name is 'Turkish Grand Prix'.\n\n5. **Calculate the average**: Compute the average of the `points` column from the `driverStandings` table (`T2`) for the filtered records.\n\nThe result will be the average score of Lewis Hamilton in all Turkish Grand Prix races."
        ]
    },
    "194": {
        "sql": "SELECT T1.client_id, (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T3.birth_date)) AS age\nFROM disp T1\nJOIN card T2 ON T2.disp_id = T1.disp_id\nJOIN client T3 ON T1.client_id = T3.client_id\nWHERE T2.type = 'gold' AND T1.type = 'OWNER';",
        "question": "Provide the IDs and age of the client with high level credit card, which is eligible for loans.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'",
        "explain": "the credit card is high-level refers to card.type = 'gold'; eligible for loans refers to disp.type = 'OWNER'",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join the `disp` table (aliased as T1) with the `card` table (aliased as T2)** using the condition `T2.disp_id = T1.disp_id`. This links each client's disposition record to their credit card details.\n\n2. **Join the result with the `client` table (aliased as T3)** using the condition `T1.client_id = T3.client_id`. This adds the client's personal details, such as birth date, to the query results.\n\n3. **Filter the records** to include only those where the credit card type is 'gold' (`T2.type = 'gold'`) and the disposition type is 'OWNER' (`T1.type = 'OWNER'`). This ensures we only consider clients who own a high-level (gold) credit card.\n\n4. **Select the client ID (`T1.client_id`)** and **calculate the client's age** by subtracting the birth year (extracted from `T3.birth_date`) from the current year (extracted from `CURRENT_TIMESTAMP`).\n\nThe final output provides the IDs and ages of clients who meet the specified criteria."
        ]
    },
    "972": {
        "sql": "SELECT d.driverId, d.code\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE strftime('%Y', d.dob) = '1971'\nAND r.fastestLapTime IS NOT NULL;",
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "explain": "born in 1971 refers to year(dob) = 1971; has the fastest lap time refers to fastestLapTime has values",
        "solution": []
    },
    "1237": {
        "sql": "SELECT DISTINCT p.ID, p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Admission = '-' AND l.HGB < 10;",
        "question": "Among all outpatients, list out those have low hemoglobin level. State the different IDs and their sex.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HGB < 10 AND T1.Admission = '-'",
        "explain": "outpatients refers to Admission = '-'; low hemoglobin level refers to HBG < 10;",
        "solution": []
    },
    "1274": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Symptoms IS NOT NULL",
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "explain": "anti-SSB are normal refers to SSB IN ('negative', '0'); have other symptoms refers to Symptoms IS NOT NULL; Should compute the number of distinct ones",
        "solution": [
            "To solve the question, we need to count the number of distinct patients who have normal anti-SSB results (either 'negative' or '0') and also have other symptoms recorded in their examination. The steps are as follows:\n\n1. **Join the Examination and Laboratory tables** on the patient ID to combine examination and laboratory data for each patient.\n2. **Filter the records** to include only those patients whose anti-SSB results are either 'negative' or '0'.\n3. **Further filter the records** to ensure that the patients have non-null symptoms recorded in their examination.\n4. **Count the distinct patient IDs** from the filtered records to get the total number of such patients.",
            "To solve the question, we need to count the number of distinct patients who have normal anti-SSB results (either 'negative' or '0') and also have other symptoms recorded in their examination. The steps are as follows:\n\n1. **Join the Examination and Laboratory tables** on the patient ID to combine examination and laboratory data for each patient.\n2. **Filter the records** to include only those patients whose anti-SSB results are either 'negative' or '0'.\n3. **Further filter the records** to ensure that the patients have non-null symptoms recorded in their examination.\n4. **Count the distinct patient IDs** from the filtered records to get the total number of such patients.\n\nThe SQL query for this operation is:\n```sql\nSELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL\n```"
        ]
    },
    "962": {
        "sql": "SELECT (SUM(IIF(strftime('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) * 100.0 / COUNT(*)) AS percentage\nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nJOIN drivers T3 ON T1.driverId = T3.driverId\nWHERE T2.year BETWEEN 2000 AND 2005;",
        "error": "something went wrong, tool did not call.",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "explain": "born before 1985 refers to year(dob)<1985; in 2000 to 2005 refers to year between 2000 and 2005; percentage = Divide(COUNT(driverId where year (dob) <1985 and laps >50),COUNT(DriverID where year between 2000 and 2005) *100;",
        "solution": [
            "To solve the question, we need to calculate the percentage of drivers who were born before 1985 and had lap numbers over 50 during the years 2000 to 2005. Here are the steps:\n\n1. **Join the Tables**: Combine the `results`, `races`, and `drivers` tables. The `results` table is linked to the `races` table using the `raceId` column, and the `results` table is linked to the `drivers` table using the `driverId` column.\n\n2. **Filter the Data**: Narrow down the data to only include records where the race year is between 2000 and 2005.\n\n3. **Check Conditions**: For each driver in the filtered data, check if they were born before 1985 (by extracting the year from their date of birth) and if their lap count is greater than 50.\n\n4. **Count Eligible Drivers**: Count how many drivers meet both conditions (born before 1985 and laps > 50).\n\n5. **Calculate Percentage**: Divide the count of eligible drivers by the total number of drivers in the filtered data and multiply by 100 to get the percentage.\n\n6. **Output the Result**: The final result is the calculated percentage.",
            "To solve the question, we need to calculate the percentage of drivers who were born before 1985 and had lap numbers over 50 during the years 2000 to 2005. Here are the detailed steps:\n\n1. **Join the Tables**: Combine the `results` table (aliased as `T1`), the `races` table (aliased as `T2`), and the `drivers` table (aliased as `T3`). The `results` table is linked to the `races` table using the `raceId` column, and the `results` table is linked to the `drivers` table using the `driverId` column.\n\n2. **Filter the Data**: Narrow down the data to only include records where the race year (from the `races` table) is between 2000 and 2005.\n\n3. **Check Conditions**: For each driver in the filtered data, check if they were born before 1985 (by extracting the year from their date of birth in the `drivers` table) and if their lap count (from the `results` table) is greater than 50.\n\n4. **Count Eligible Drivers**: Use the `IIF` function to assign a value of 1 to drivers who meet both conditions (born before 1985 and laps > 50) and 0 otherwise. Sum these values to get the count of eligible drivers.\n\n5. **Calculate Percentage**: Divide the count of eligible drivers (from the previous step) by the total number of drivers in the filtered data (using `COUNT(*)`) and multiply by 100 to get the percentage. The result is cast to a `REAL` type to ensure accurate division.\n\n6. **Output the Result**: The final result is the calculated percentage of drivers who meet the specified conditions."
        ]
    },
    "801": {
        "sql": "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Male')) * 1.0 /\n    (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female')) AS male_to_female_ratio;",
        "question": "Find the ratio between male superheroes and female superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id",
        "explain": "ratio = DIVIDE(SUM(gender_id = 1) / SUM(gender_id = 2)); male superheroes refers to gender = 'Female'; female superheroes refers to gender = 'Male';",
        "solution": []
    },
    "1118": {
        "sql": "SELECT player_name FROM Player WHERE (JULIANDAY('now') - JULIANDAY(birthday)) / 365.0 >= 35;",
        "question": "List down the name of players who are 35 years old and above.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE CAST((JULIANDAY('now') - JULIANDAY(birthday)) AS REAL) / 365 >= 35",
        "explain": "35 years old and above refers to datetime(CURRENT_TIMESTAMP,'localtime') - datetime(birthday) > 34",
        "solution": [
            "To list the names of players who are 35 years old and above, the database performs the following operations:\n\n1. **Retrieve Data from the Player Table**: The query starts by accessing the `Player` table to gather information about all players.\n\n2. **Calculate Age**: For each player, the database calculates their age by:\n   - Converting the current date (`'now'`) and the player's `birthday` into Julian Day numbers using the `JULIANDAY` function.\n   - Subtracting the Julian Day number of the `birthday` from the Julian Day number of the current date to get the number of days the player has been alive.\n   - Converting this number of days into years by dividing by 365 (days in a year) and casting the result to a `REAL` number for precision.\n\n3. **Filter Players by Age**: The database then filters the players to include only those whose calculated age is 35 years or older.\n\n4. **Select Player Names**: Finally, the query selects and returns the `player_name` column for the filtered players.\n\nThis process ensures that only the names of players aged 35 or above are listed."
        ]
    },
    "1477": {
        "sql": "SELECT SUBSTR(T2.Date, 1, 4) AS Year, SUM(T2.Consumption) AS TotalConsumption\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY Year\nORDER BY TotalConsumption DESC\nLIMIT 1;",
        "question": "Which year recorded the most gas use paid in EUR?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT SUBSTRING(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY SUBSTRING(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "explain": "",
        "solution": [
            "To determine which year recorded the most gas use paid in EUR, follow these steps:\n\n1. **Join the Tables**: Combine the `customers` table (referred to as `T1`) and the `yearmonth` table (referred to as `T2`) using the `CustomerID` field as the common key.\n\n2. **Filter by Currency**: From the joined tables, filter the records to include only those where the `Currency` field in the `customers` table (`T1`) is 'EUR'.\n\n3. **Extract the Year**: For each record, extract the year from the `Date` field in the `yearmonth` table (`T2`). This is done using the `SUBSTRING` function to take the first 4 characters of the `Date` field.\n\n4. **Group by Year**: Group the filtered records by the extracted year.\n\n5. **Calculate Total Consumption**: For each year, calculate the sum of the `Consumption` values from the `yearmonth` table (`T2`).\n\n6. **Order by Consumption**: Sort the grouped results in descending order based on the total consumption calculated in the previous step.\n\n7. **Select the Top Year**: Retrieve only the top record (the year with the highest total gas consumption) from the sorted list.\n\nThe final output will be the year that recorded the most gas use paid in EUR.",
            "To determine which year recorded the most gas use paid in EUR, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `customers` table (aliased as `T1`) and the `yearmonth` table (aliased as `T2`) using the `CustomerID` field as the common key. This ensures that only records with matching `CustomerID` values in both tables are included.\n\n2. **Filter by Currency**: From the joined result, filter the records to include only those where the `Currency` field in the `customers` table (`T1`) is 'EUR'. This ensures that only transactions paid in EUR are considered.\n\n3. **Extract the Year**: For each record, extract the year from the `Date` field in the `yearmonth` table (`T2`). This is achieved by using the `SUBSTRING` function to take the first 4 characters of the `Date` field, which represents the year.\n\n4. **Group by Year**: Group the filtered records by the extracted year. This step aggregates all records for each year into a single group.\n\n5. **Calculate Total Consumption**: For each year group, calculate the sum of the `Consumption` values from the `yearmonth` table (`T2`). This gives the total gas consumption for each year.\n\n6. **Order by Consumption**: Sort the grouped results in descending order based on the total consumption calculated in the previous step. This ensures that the year with the highest consumption appears first.\n\n7. **Select the Top Year**: Retrieve only the top record from the sorted list, which corresponds to the year with the highest total gas consumption paid in EUR.\n\nThe final output will be the year that recorded the most gas use paid in EUR, as determined by the above steps."
        ]
    },
    "622": {
        "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'Sharpie';",
        "question": "State the name of badge that the user whose display name is \"Sharpie\" obtained.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Sharpie'",
        "explain": "\"Sharpie\" is the DisplayName of user; user refers to UserId",
        "solution": []
    },
    "1415": {
        "sql": "SELECT m.position\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business';",
        "question": "List out the position of members who joined major of Business.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.position FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business'",
        "explain": "'Business' is the major name",
        "solution": []
    },
    "579": {
        "sql": "SELECT c.Text \nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.Title = 'How does gentle boosting differ from AdaBoost?';",
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'",
        "explain": "\"How does gentle boosting differ from AdaBoost?\" is the Title of post; comments refers to Text",
        "solution": []
    },
    "894": {
        "sql": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name AS race_name\nFROM drivers AS T1\nJOIN lapTimes AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T2.raceId = T3.raceId\nORDER BY T2.milliseconds ASC\nLIMIT 1;",
        "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY T2.milliseconds ASC LIMIT 1",
        "explain": "the best lap time refers to min(milliseconds); List the driver refers to drivers.forename and drivers.surname; List the race refers to races.name",
        "solution": [
            "To find the best lap time recorded along with the driver and race details, follow these steps:\n\n1. **Join the Tables**: Combine the `drivers` table (aliased as T1), the `lapTimes` table (aliased as T2), and the `races` table (aliased as T3).\n   - Link `drivers` and `lapTimes` using the `driverId` field.\n   - Link `lapTimes` and `races` using the `raceId` field.\n\n2. **Sort the Lap Times**: Order the results by the `milliseconds` column from the `lapTimes` table in ascending order to ensure the fastest lap time appears first.\n\n3. **Retrieve the Top Result**: Limit the results to the first row to get the best lap time recorded.\n\n4. **Select the Required Fields**: Display the `milliseconds` (lap time), the driver's `forename` and `surname` from the `drivers` table, and the `name` of the race from the `races` table.\n\nThis process ensures you retrieve the fastest lap time along with the associated driver and race details."
        ]
    },
    "10": {
        "sql": "SELECT T2.\"FRPM Count (Ages 5-17)\"\nFROM satscores T1\nINNER JOIN frpm T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrRead DESC\nLIMIT 1;",
        "question": "For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1",
        "explain": "",
        "solution": [
            "1. **Joining the SAT scores and FRPM data:**  \n   The query uses an `INNER JOIN` between two tables: `satscores` (aliased as T1) and `frpm` (aliased as T2). These tables are linked using the `cds` column from `satscores` and the `CDSCode` column from `frpm`. This ensures that each school's SAT score data is matched with its corresponding FRPM (Free or Reduced-Price Meal) data.\n\n2. **Selecting the FRPM count for students aged 5-17:**  \n   From the `frpm` table (T2), the query selects the column `FRPM Count (Ages 5-17)`. This represents the count of students aged 5-17 who qualify for free or reduced-price meals at the school.\n\n3. **Ordering by average Reading score:**  \n   The results are ordered based on the `AvgScrRead` column from the `satscores` table. The sorting is in descending order (`DESC`), so that the school with the highest average Reading score appears at the top.\n\n4. **Limiting to the top result:**  \n   The query applies a `LIMIT 1`, which restricts the output to only the first record. This ensures that only the school with the highest average Reading score is included in the result, along with its corresponding FRPM count for students aged 5-17."
        ]
    },
    "146": {
        "sql": "SELECT DISTINCT T1.client_id\nFROM client T1\nJOIN disp T2 ON T1.client_id = T2.client_id\nJOIN account T5 ON T2.account_id = T5.account_id\nJOIN loan T3 ON T5.account_id = T3.account_id\nJOIN card T4 ON T2.disp_id = T4.disp_id\nWHERE T1.gender = 'F' AND T4.type = 'credit';",
        "question": "Who are the female account holders who own credit cards and also have loans?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T5 ON T2.account_id = T5.account_id INNER JOIN loan AS T3 ON T5.account_id = T3.account_id INNER JOIN card AS T4 ON T2.disp_id = T4.disp_id WHERE T1.gender = 'F'",
        "explain": "Female refers to gender = 'F'",
        "solution": [
            "To solve the question \"Who are the female account holders who own credit cards and also have loans?\", the following steps are performed:\n\n1. **Select the client IDs** from the `client` table (aliased as `T1`) where the gender is female (`T1.gender = 'F'`).\n\n2. **Join the `disp` table** (aliased as `T2`) with the `client` table using the `client_id` field to link account holders to their accounts.\n\n3. **Join the `account` table** (aliased as `T5`) with the `disp` table using the `account_id` field to access the account details of the clients.\n\n4. **Join the `loan` table** (aliased as `T3`) with the `account` table using the `account_id` field to identify clients who have loans.\n\n5. **Join the `card` table** (aliased as `T4`) with the `disp` table using the `disp_id` field to identify clients who own credit cards.\n\n6. The final result is a list of `client_id` values for female clients who meet all the specified conditions (own credit cards and have loans).",
            "To solve the question \"Who are the female account holders who own credit cards and also have loans?\", the following detailed steps are performed:\n\n1. **Select the client IDs** from the `client` table (aliased as `T1`) where the gender is female (`T1.gender = 'F'`). This ensures we only consider female clients.\n\n2. **Join the `disp` table** (aliased as `T2`) with the `client` table using the `client_id` field. This links each client to their associated accounts in the `disp` table.\n\n3. **Join the `account` table** (aliased as `T5`) with the `disp` table using the `account_id` field. This provides access to the account details for each client.\n\n4. **Join the `loan` table** (aliased as `T3`) with the `account` table using the `account_id` field. This identifies clients who have loans associated with their accounts.\n\n5. **Join the `card` table** (aliased as `T4`) with the `disp` table using the `disp_id` field. This identifies clients who own credit cards.\n\n6. The final result is a list of `client_id` values for female clients who meet all the specified conditions (own credit cards and have loans). This ensures the query returns only the relevant female account holders."
        ]
    },
    "1435": {
        "sql": "SELECT event_name FROM event WHERE type = 'Game' AND status = 'Closed' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';",
        "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "explain": "name of events refers event_name; game event that was closed refers to type = 'Game' where status = 'Closed'; event_date BETWEEN '2019-03-15' and '2020-03-20'; ",
        "solution": []
    },
    "390": {
        "sql": "SELECT T1.colors, T2.format FROM cards T1 JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20;",
        "question": "What are the colors of cards from ID 1-20? What are the format of these cards?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.colors, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20",
        "explain": "ID 1-20 refers to id BETWEEN 1 and 20;",
        "solution": [
            "To solve the question, the database performs the following operations:\n\n1. **Selecting Data**: The query retrieves the `colors` of the cards from the `cards` table (aliased as `T1`) and the `format` of these cards from the `legalities` table (aliased as `T2`).\n\n2. **Joining Tables**: The query joins the `cards` table (`T1`) with the `legalities` table (`T2`) using the `uuid` column as the common key. This ensures that the data from both tables is combined where the `uuid` values match.\n\n3. **Filtering Records**: The query filters the records to only include cards where the `id` in the `cards` table (`T1.id`) is between 1 and 20 (inclusive).\n\n4. **Output**: The final result is a list of card colors and their corresponding formats for cards with IDs ranging from 1 to 20."
        ]
    },
    "478": {
        "sql": "SELECT c.name FROM cards c JOIN sets s ON c.setCode = s.code WHERE s.name = 'Coldsnap' AND c.number = '4';",
        "question": "What is card number 4 in the set Coldsnap?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.number = 4",
        "explain": "card set Coldsnap refers to name = 'Coldsnap'; card number 4 refers to number = 4",
        "solution": [
            "To find the name of card number 4 in the set 'Coldsnap', follow these steps:\n1. Join the 'cards' table (referred to as T1) with the 'sets' table (referred to as T2) using the condition that the 'code' column in T2 matches the 'setCode' column in T1.\n2. Filter the joined tables to include only rows where the 'name' column in T2 is 'Coldsnap' and the 'number' column in T1 is 4.\n3. Select the 'name' column from the 'cards' table (T1) for the filtered rows."
        ]
    },
    "198": {
        "sql": "SELECT AVG(bond_count) AS average_single_bonds\nFROM (\n    SELECT T3.molecule_id, COUNT(T1.bond_id) AS bond_count\n    FROM bond T1\n    JOIN atom T2 ON T1.molecule_id = T2.molecule_id\n    JOIN molecule T3 ON T1.molecule_id = T3.molecule_id\n    WHERE T1.bond_type = '-' AND T3.label = '+'\n    GROUP BY T3.molecule_id\n) AS subquery;",
        "question": "On average how many carcinogenic molecules are single bonded?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
        "explain": "carcinogenic molecules refers to label = '+'; single-bonded refers to bond_type = '-'; average = DIVIDE(SUM(bond_type = '-'), COUNT(atom_id))",
        "solution": [
            "To determine the average number of single bonds in carcinogenic molecules, follow these steps:\n\n1. **Filter carcinogenic molecules**: Identify molecules labeled as carcinogenic (denoted by `+` in the `molecule` table).\n\n2. **Count single bonds**: For each carcinogenic molecule, count the number of single bonds (denoted by `-` in the `bond` table).\n\n3. **Calculate the average**: Compute the average of these single bond counts across all carcinogenic molecules.\n\nHere\u2019s the breakdown of the operations:\n\n- **Join tables**:\n  - Link the `bond` table (`T1`) with the `atom` table (`T2`) using the `molecule_id` field.\n  - Further link the result with the `molecule` table (`T3`) using the `molecule_id` field.\n\n- **Filter conditions**:\n  - Only include bonds where the `bond_type` is `-` (single bond).\n  - Only include molecules where the `label` is `+` (carcinogenic).\n\n- **Group and count**:\n  - Group the results by `molecule_id` from the `molecule` table (`T3`).\n  - For each group, count the number of single bonds.\n\n- **Compute the average**:\n  - Calculate the average of the single bond counts obtained from the grouped results.",
            "To determine the average number of single bonds in carcinogenic molecules, follow these detailed steps:\n\n1. **Filter carcinogenic molecules**: Identify molecules labeled as carcinogenic by checking the `label` column in the `molecule` table (denoted by `+`).\n\n2. **Join tables**:\n   - Link the `bond` table (`T1`) with the `atom` table (`T2`) using the `molecule_id` field to associate bonds with their respective atoms.\n   - Further link the result with the `molecule` table (`T3`) using the `molecule_id` field to include molecule labels.\n\n3. **Filter conditions**:\n   - Only include bonds where the `bond_type` is `-` (single bond) in the `bond` table (`T1`).\n   - Only include molecules where the `label` is `+` (carcinogenic) in the `molecule` table (`T3`).\n\n4. **Group and count**:\n   - Group the results by `molecule_id` from the `molecule` table (`T3`).\n   - For each group, count the number of single bonds (`bond_type = '-'`) using the `COUNT` function.\n\n5. **Compute the average**:\n   - Calculate the average of the single bond counts obtained from the grouped results using the `AVG` function.\n\nThe SQL query performs these operations in the following order:\n- Joins the `bond`, `atom`, and `molecule` tables.\n- Applies the filtering conditions for single bonds and carcinogenic molecules.\n- Groups the data by `molecule_id` and counts the single bonds for each molecule.\n- Finally, computes the average of these counts."
        ]
    },
    "1387": {
        "sql": "SELECT m.first_name, m.last_name\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event ev ON b.link_to_event = ev.event_id\nWHERE ev.event_name = 'Yearly Kickoff';",
        "question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
        "explain": "name of students means the full name; full name refers to first_name, last_name;'Yearly Kickoff' is an event name;",
        "solution": []
    },
    "13": {
        "sql": "SELECT s.Phone\nFROM satscores sc\nJOIN schools s ON sc.cds = s.CDSCode\nORDER BY (sc.NumGE1500 * 1.0 / sc.NumTstTakr) DESC\nLIMIT 3;",
        "question": "Please list the phone numbers of the schools with the top 3 SAT excellence rate.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr DESC LIMIT 3",
        "explain": "Excellence rate = NumGE1500 / NumTstTakr",
        "solution": []
    }
}