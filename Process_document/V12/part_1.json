{
    "561": {
        "sql": "SELECT p.Title\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nORDER BY c.Score DESC\nLIMIT 1;",
        "question": "What is the title for the post which got the highest score comment?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Title FROM posts WHERE Id = ( SELECT PostId FROM comments ORDER BY Score DESC LIMIT 1 )",
        "explain": "highest score comment refers to Max(comments.Score)",
        "solution": []
    },
    "954": {
        "sql": "SELECT \n    (COUNT(CASE WHEN r.time IS NOT NULL THEN 1 END) * 100.0 / COUNT(*)) AS race_completion_percentage\nFROM \n    results r\nJOIN \n    drivers d ON r.driverId = d.driverId\nJOIN \n    races rc ON r.raceId = rc.raceId\nWHERE \n    d.nationality = 'Japanese'\n    AND rc.year BETWEEN 2007 AND 2009;",
        "question": "Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.raceId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009",
        "explain": "from 2007 to 2009 refers to year between 2007 and 2009; race completion refers to time is not null; percentage = Divide(COUNT(DriverID where time is not null and year between 2007 and 2009),Count (DriverID where year between 2007 and 2009))*100; ",
        "solution": []
    },
    "1245": {
        "sql": "SELECT COUNT(*) \nFROM Laboratory \nWHERE Date > '1997-01-01' AND APTT >= 45;",
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "explain": "examinations done after 1997/1/1 refers to `Examination Date` > '1997-01-01'; normal activated partial prothrom bin time refesr to APTT < 45;",
        "solution": [
            "To solve the question, we need to count the number of examinations performed after January 1, 1997, where the result of the inactivated partial prothrombin time (APTT) is 45 or higher. The steps are as follows:\n\n1. **Identify the relevant tables**: The data is stored in two tables, `Patient` (referred to as T1) and `Laboratory` (referred to as T2).\n2. **Join the tables**: The `Patient` table is joined with the `Laboratory` table using the `ID` column to link patient records with their laboratory results.\n3. **Filter by date**: Only include records where the examination date (`T2.Date`) is after January 1, 1997.\n4. **Filter by APTT result**: Further filter the records to include only those where the APTT result (`T2.APTT`) is 45 or higher.\n5. **Count the records**: Finally, count the number of records that meet these criteria.\n\nThe SQL query accomplishes this by selecting the count of `ID` values from the joined and filtered tables."
        ]
    },
    "562": {
        "sql": "SELECT COUNT(*) AS comment_count\nFROM comments\nWHERE PostId IN (SELECT Id FROM posts WHERE ViewCount = 1910);",
        "question": "For the post which got 1910 view counts, how many comments does it get?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ViewCount = 1910",
        "explain": "",
        "solution": []
    },
    "422": {
        "sql": "SELECT language FROM foreign_data WHERE multiverseid = 149934;",
        "question": "What is the language of the card with the multiverse number 149934?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT language FROM foreign_data WHERE multiverseid = 149934",
        "explain": "multiverse number 149934 refers to multiverseid = 149934;",
        "solution": []
    },
    "1259": {
        "sql": "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Birthday >= '1985-01-01'\nAND l.RA IN('-', '+-');",
        "question": "Please list the diseases of the patients born after 1985-1-1 and have a normal Rhuematoid Factor.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > '1985-01-01'",
        "explain": "diseases refers to Diagnosis; born after 1985/1/1 refers to YEAR(Birthday) > = 1985; normal Rhuematoid Factor refers to RA IN('-', '+-');",
        "solution": []
    },
    "1505": {
        "sql": "SELECT COUNT(DISTINCT T1.CustomerID) \nFROM yearmonth T1 \nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID \nWHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00;",
        "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
        "explain": "Pays in euro = Currency = 'EUR'.",
        "solution": [
            "To solve the question, 'Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?', follow these steps:\n\n1. **Join the Tables**: Combine the `yearmonth` table (referred to as T1) and the `customers` table (referred to as T2) using the `CustomerID` field. This ensures that each customer's monthly consumption data is linked to their currency information.\n\n2. **Filter by Currency**: From the joined tables, filter the records to include only those customers who paid in euros. This is done by checking the `Currency` field in the `customers` table (T2) for the value 'EUR'.\n\n3. **Filter by Consumption**: Further filter the records to include only those customers whose monthly consumption is greater than 1000.00. This is done by checking the `Consumption` field in the `yearmonth` table (T1).\n\n4. **Count the Results**: Finally, count the number of records that meet both criteria (currency in euros and consumption over 1000.00). This count represents the number of customers who paid in euros and have a monthly consumption exceeding 1000.\n\nThe SQL query provided performs these operations efficiently to arrive at the correct answer.",
            "To solve the question, 'Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?', follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `yearmonth` table (referred to as T1) and the `customers` table (referred to as T2) using the `CustomerID` field. This ensures that each customer's monthly consumption data is linked to their currency information.\n\n2. **Filter by Currency**: From the joined tables, filter the records to include only those customers who paid in euros. This is done by checking the `Currency` field in the `customers` table (T2) for the exact value 'EUR'.\n\n3. **Filter by Consumption**: Further filter the records to include only those customers whose monthly consumption is strictly greater than 1000.00. This is done by checking the `Consumption` field in the `yearmonth` table (T1).\n\n4. **Count the Results**: Finally, count the number of records that meet both criteria (currency in euros and consumption over 1000.00). This count represents the number of customers who paid in euros and have a monthly consumption exceeding 1000.\n\nThe SQL query provided performs these operations efficiently to arrive at the correct answer."
        ]
    },
    "1349": {
        "sql": "SELECT SUM(amount) AS total_budget_amount\nFROM budget\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'September Speaker');",
        "question": "Provide the total number of the budget amount for \"September Speaker\" event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'September Speaker'",
        "explain": "'September Speaker' is an event name; total number of budget amount refers to SUM(amount)",
        "solution": []
    },
    "1144": {
        "sql": "SELECT pa.finishing, pa.curve\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nORDER BY p.weight DESC\nLIMIT 1;",
        "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
        "explain": "finishing rate refer to finishing; curve score refer to curve; heaviest weight refers to MAX(weight)",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Identify the heaviest player**: First, the database is queried to find the player with the heaviest weight. This is done by selecting the `player_api_id` from the `Player` table, ordering the players by their weight in descending order, and limiting the result to just the top record (the heaviest player).\n\n2. **Retrieve player attributes**: Using the `player_api_id` obtained from the first step, the database then queries the `Player_Attributes` table to retrieve the `id`, `finishing` rate, and `curve` score of this player. The result is limited to one record to ensure only the relevant data is returned.\n\nThis process ensures that the finishing rate and curve score of the heaviest player are accurately retrieved.",
            "To solve the question, the following detailed steps are performed:\n\n1. **Identify the heaviest player**: The database is queried to find the player with the heaviest weight. This involves:\n   - Selecting the `player_api_id` from the `Player` table.\n   - Ordering the players by their `weight` in descending order to ensure the heaviest player is at the top.\n   - Limiting the result to just the top record (using `LIMIT 1`) to retrieve only the heaviest player's `player_api_id`.\n\n2. **Retrieve the player's attributes**: Using the `player_api_id` obtained from the first step, the database then queries the `Player_Attributes` table to retrieve the following details for this player:\n   - The `id` of the player.\n   - The `finishing` rate, which represents the player's ability to finish scoring opportunities.\n   - The `curve` score, which represents the player's ability to curve the ball.\n   - The result is limited to one record (using `LIMIT 1`) to ensure only the relevant data for the heaviest player is returned.\n\nThis process ensures that the finishing rate and curve score of the heaviest player are accurately retrieved without altering any information from the original SQL query."
        ]
    },
    "532": {
        "sql": "SELECT DisplayName FROM users WHERE strftime('%Y', CreationDate) = '2011';",
        "question": "Please list the display names of all the users whose accounts were created in the year 2011.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE STRFTIME('%Y', CreationDate) = '2011'",
        "explain": "account created in the year 2011 refers to year(CreationDate) = 2011",
        "solution": []
    },
    "1223": {
        "sql": "SELECT \n    (SELECT COUNT(*) \n     FROM Patient T1 \n     JOIN Laboratory T2 ON T1.ID = T2.ID \n     WHERE T2.CRE >= 1.5 AND T1.SEX = 'M') > \n    (SELECT COUNT(*) \n     FROM Patient T1 \n     JOIN Laboratory T2 ON T1.ID = T2.ID \n     WHERE T2.CRE >= 1.5 AND T1.SEX = 'F') AS result;",
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "explain": "creatinine (CRE) not within the normal range refers to CRE > = 1.5; male refers to Sex = 'M'; female refers to Sex = 'F'; calculation = (SUM(SEX = 'M') > SUM(SEX = 'F')) where CRE > = 1.5",
        "solution": [
            "To determine whether there are more male patients with creatinine levels not within the normal range than female patients, follow these steps:\n\n1. **Identify the Data Sources**: The data is sourced from two tables:\n   - The `Patient` table (referred to as `T1`) contains patient information, including their sex (`SEX`).\n   - The `Laboratory` table (referred to as `T2`) contains laboratory test results, including creatinine levels (`CRE`).\n\n2. **Filter Patients with Abnormal Creatinine Levels**:\n   - Join the `Patient` and `Laboratory` tables using the patient ID (`ID`) to link the records.\n   - Filter the results to include only patients whose creatinine levels (`CRE`) are 1.5 or higher, indicating levels not within the normal range.\n\n3. **Count Male and Female Patients**:\n   - For each patient in the filtered dataset, check their sex (`SEX`).\n   - Count the number of male patients (`SEX = 'M'`) and the number of female patients (`SEX = 'F'`).\n\n4. **Compare the Counts**:\n   - If the count of male patients is greater than the count of female patients, the answer is `True`.\n   - Otherwise, the answer is `False`.\n\n5. **Output the Result**:\n   - The final result is a single value (`True` or `False`) indicating whether there are more male patients with abnormal creatinine levels than female patients.",
            "To determine whether there are more male patients with creatinine levels not within the normal range than female patients, follow these detailed steps:\n\n1. **Data Source Identification**:\n   - The data is sourced from two tables:\n     - The `Patient` table (referred to as `T1`) contains patient information, including their sex (`SEX`).\n     - The `Laboratory` table (referred to as `T2`) contains laboratory test results, including creatinine levels (`CRE`).\n\n2. **Table Join and Filtering**:\n   - Perform an inner join between the `Patient` table (`T1`) and the `Laboratory` table (`T2`) using the patient ID (`ID`) as the joining key.\n   - Filter the joined dataset to include only those records where the creatinine level (`CRE`) is 1.5 or higher, indicating levels not within the normal range.\n\n3. **Counting Patients by Sex**:\n   - For each record in the filtered dataset, evaluate the patient's sex (`SEX`).\n   - Count the number of male patients (`SEX = 'M'`) by summing 1 for each male patient and 0 otherwise.\n   - Similarly, count the number of female patients (`SEX = 'F'`) by summing 1 for each female patient and 0 otherwise.\n\n4. **Comparison of Counts**:\n   - Compare the total count of male patients with abnormal creatinine levels to the total count of female patients with abnormal creatinine levels.\n   - If the count of male patients is greater than the count of female patients, the result is `True`.\n   - Otherwise, the result is `False`.\n\n5. **Result Output**:\n   - The final output is a single value (`True` or `False`) derived from the comparison, answering the question directly."
        ]
    },
    "725": {
        "sql": "SELECT COUNT(*) \nFROM superhero \nWHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics');",
        "question": "How many superheroes are published by Marvel Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "explain": "published by Marvel Comics refers to publisher_name = 'Marvel Comics'",
        "solution": []
    },
    "1164": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Examination E ON P.ID = E.ID \nWHERE E.Thrombosis = 1 \nAND strftime('%Y', E.`Examination Date`) = '1997' \nAND P.SEX = 'F';",
        "question": "How many of the patients with the most serious thrombosis cases examined in 1997 are women?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT  COUNT(*) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND STRFTIME('%Y', T2.`Examination Date`) = '1997' AND T2.Thrombosis = 1",
        "explain": "the most serious thrombosis refers to Thrombosis = '1' (the most severe one); women refers to sex = 'F'",
        "solution": []
    },
    "984": {
        "sql": "SELECT T1.url FROM constructors T1 JOIN constructorStandings T2 ON T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1;",
        "question": "What is the website of the constructor who tallied the most total wins.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1",
        "explain": "introduction website refers to url;",
        "solution": [
            "To find the website of the constructor with the most total wins, follow these steps:\n\n1. **Join the tables**: Combine the `constructors` table (referred to as `T1`) with the `constructorStandings` table (referred to as `T2`) using the `constructorId` field as the common key. This ensures that each constructor's details are matched with their respective standings.\n\n2. **Sort by wins**: Arrange the joined records in descending order based on the `wins` column from the `constructorStandings` table (`T2.wins`). This places the constructor with the highest number of wins at the top of the list.\n\n3. **Limit the results**: Retrieve only the top record from the sorted list to get the constructor with the most wins.\n\n4. **Select the website**: From the top record, extract the `url` field from the `constructors` table (`T1.url`), which contains the website of the winning constructor.\n\nThe final result is the website URL of the constructor who has the highest number of wins."
        ]
    },
    "1070": {
        "sql": "SELECT c.name AS country_name\nFROM League l\nJOIN Country c ON l.country_id = c.id\nWHERE l.name = 'Italy Serie A';",
        "question": "Which country is the league Italy Serie A from?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Italy Serie A'",
        "explain": "Italy Serie A from refers to League.name = 'Italy Serie A';",
        "solution": []
    },
    "1309": {
        "sql": "SELECT L.PLT\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Diagnosis = 'MCTD' AND L.PLT BETWEEN 100 AND 400;",
        "question": "Please list a patient's platelet level if it is within the normal range and if he or she is diagnosed with MCTD.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.PLT FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'MCTD' AND T2.PLT BETWEEN 100 AND 400",
        "explain": "PLT > 100 and PLT < 400 means platelet level is within the normal range; PLT < 100 and PLT > 400 means platelet level is not within the normal range; diagnosed with MCTD refers to Diagnosis = 'MCTD';",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Join the Patient and Laboratory tables**: The tables are joined using the common column `ID` to link patient records with their laboratory results.\n\n2. **Filter patients diagnosed with MCTD**: From the joined data, only those patients whose `Diagnosis` is 'MCTD' are selected.\n\n3. **Filter platelet levels within the normal range**: From the filtered patients, only those whose platelet levels (`PLT`) are between 100 and 400 (inclusive) are selected.\n\n4. **Retrieve the platelet levels**: Finally, the platelet levels (`PLT`) of the qualifying patients are listed.\n\nThis ensures that only patients with MCTD and platelet levels within the normal range are included in the results."
        ]
    },
    "279": {
        "sql": "SELECT m.label\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_id = 'TR001_10_11';",
        "question": "What is the label for bond ID TR001_10_11?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_10_11'",
        "explain": "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "1285": {
        "sql": "SELECT p.\"First Date\"\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.LDH >= 500\nORDER BY p.\"First Date\" DESC\nLIMIT 1;",
        "question": "When is the latest patient's medical data recorded? This patient should have an abnormal level of lactate dehydrogenase.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH >= 500 ORDER BY T1.`First Date` DESC LIMIT 1",
        "explain": "latest patient refers to ID with MAX('First Date'); abnormal level of lactate dehydrogenase refers to LDH > = 500;",
        "solution": [
            "To find the latest recorded medical data of a patient with an abnormal level of lactate dehydrogenase (LDH), follow these steps:\n\n1. **Identify Patients with Abnormal LDH Levels**: Filter the `Laboratory` table to include only those records where the lactate dehydrogenase (LDH) level is 500 or higher. This ensures we focus on patients with abnormal LDH levels.\n\n2. **Join with Patient Data**: Link the filtered laboratory records with the corresponding patient records in the `Patient` table using the patient ID as the common key. This allows us to access the patient's details, including the date of their first medical record.\n\n3. **Sort by Date in Descending Order**: Arrange the resulting records by the `First Date` of the patient in descending order. This places the most recent records at the top of the list.\n\n4. **Retrieve the Latest Record**: Select the top record from the sorted list, which represents the patient with the most recent medical data among those with abnormal LDH levels.\n\nThe final output will be the `First Date` of the latest patient meeting the criteria."
        ]
    },
    "974": {
        "sql": "SELECT T2.year FROM results T1 JOIN races T2 ON T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL;",
        "question": "State the racing year which has the fastest lap time?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "explain": "'has the fastest lap time?' refers to fastestLapTime has values",
        "solution": [
            "To determine the racing year with the fastest lap time, follow these steps:\n\n1. **Join the tables**: Combine the `results` table (referred to as `T1`) with the `races` table (referred to as `T2`) using the `raceId` field as the common key. This ensures that each result is linked to its corresponding race.\n\n2. **Filter for valid lap times**: From the joined data, filter out any records where the `fastestLapTime` in the `results` table (`T1.fastestLapTime`) is `NULL`. This ensures only races with recorded lap times are considered.\n\n3. **Retrieve the year**: From the filtered data, select the `year` field from the `races` table (`T2.year`). This will give you the year of each race that has a valid fastest lap time.\n\n4. **Final output**: The result will be a list of years where races had recorded fastest lap times. To find the year with the absolute fastest lap time, you would typically further process this data (e.g., by ordering and limiting), but the provided SQL does not include this step."
        ]
    },
    "1351": {
        "sql": "SELECT m.major_name \nFROM member mb \nJOIN major m ON mb.link_to_major = m.major_id \nWHERE mb.first_name = 'Brent' AND mb.last_name = 'Thomason';",
        "question": "What was Brent Thomason's major?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'",
        "explain": "Brent Thomason is the full name; full name refers to first_name, last_name; major refers to major_name",
        "solution": []
    },
    "1430": {
        "sql": "SELECT m.last_name, m.position\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.expense_description = 'Pizza' AND e.expense_date = '2019-09-10';",
        "question": "What is the last name and position of the student that bought pizza on 09/10/2019?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.last_name, T1.position FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.expense_date = '2019-09-10' AND T2.expense_description = 'Pizza'",
        "explain": "bought pizza on 09/10/2019 refers to expense_description = 'Pizza' where expense_date = '2019-09-10'",
        "solution": []
    },
    "1310": {
        "sql": "SELECT AVG(L.PT) AS AverageProthrombinTime\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.PT < 14;",
        "question": "For the male patients that have a normal prothrombin time, what is their average prothrombin time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.PT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PT < 14 AND T1.SEX = 'M'",
        "explain": "male refers to Sex = 'M'; normal prothrombin time refer to PT < 14; average prothrombin time = AVG(PT);",
        "solution": []
    },
    "939": {
        "sql": "SELECT COUNT(DISTINCT d.driverId) AS numberOfBritishDrivers\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN drivers d ON res.driverId = d.driverId\nWHERE r.year = 2008 AND r.name = 'Australian Grand Prix' AND d.nationality = 'British';",
        "question": "How many drivers from the UN participated in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T1.nationality = 'British' AND T3.year = 2008",
        "explain": "from the UN refers to nationality = 'British'",
        "solution": []
    },
    "1145": {
        "sql": "SELECT t1.name, COUNT(t2.id) AS match_count\nFROM League t1\nJOIN Match t2 ON t1.id = t2.league_id\nWHERE t2.season = '2015/2016'\nGROUP BY t1.name\nORDER BY match_count DESC\nLIMIT 4;",
        "question": "Which top 4 leagues had the most games in the 2015-2016 season?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' GROUP BY t1.name ORDER BY COUNT(t2.id) DESC LIMIT 4",
        "explain": "in the 2015-2016 season refers to season = '2015/2016'; league with most games refers to League.name where MAX(COUNT(id))",
        "solution": [
            "To find the top 4 leagues with the most games in the 2015-2016 season, follow these steps:\n\n1. **Join the Tables**: Combine the `League` table (aliased as `t1`) with the `Match` table (aliased as `t2`) using the `id` column from the `League` table and the `league_id` column from the `Match` table. This ensures that each match is linked to its corresponding league.\n\n2. **Filter by Season**: From the joined data, filter out only those matches that occurred in the '2015/2016' season by checking the `season` column in the `Match` table.\n\n3. **Group by League Name**: Group the filtered matches by the `name` column of the `League` table. This groups all matches belonging to the same league together.\n\n4. **Count Matches per League**: For each league, count the number of matches (using the `id` column from the `Match` table) to determine how many games each league had in the specified season.\n\n5. **Order by Match Count**: Sort the leagues in descending order based on the count of matches. This places the leagues with the most games at the top.\n\n6. **Limit Results**: Finally, limit the results to the top 4 leagues to answer the question about the top 4 leagues with the most games in the 2015-2016 season.\n\nThe result will be a list of the names of these top 4 leagues.",
            "To determine the top 4 leagues with the most games in the 2015-2016 season, the following steps are executed in the SQL query:\n\n1. **Table Join**: The `League` table (aliased as `t1`) is joined with the `Match` table (aliased as `t2`) using the condition `t1.id = t2.league_id`. This links each match to its respective league.\n\n2. **Season Filtering**: The query filters the matches to include only those from the '2015/2016' season by applying the condition `t2.season = '2015/2016'`.\n\n3. **Grouping by League Name**: The filtered matches are grouped by the `name` column of the `League` table (`t1.name`). This aggregates all matches belonging to the same league.\n\n4. **Counting Matches**: For each league, the number of matches is counted using `COUNT(t2.id)`, which tallies the matches per league.\n\n5. **Ordering by Match Count**: The leagues are sorted in descending order based on the count of matches, ensuring leagues with the most games appear first.\n\n6. **Limiting Results**: The query returns only the top 4 leagues by applying `LIMIT 4`.\n\nThe final output is a list of the names of the top 4 leagues with the highest number of games during the 2015-2016 season."
        ]
    },
    "695": {
        "sql": "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Citizen Patrol';",
        "question": "How many users were awarded with 'Citizen Patrol' badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE `Name` = 'Citizen Patrol'",
        "explain": "Citizen Patrol' is the name of the badge;",
        "solution": []
    },
    "1198": {
        "sql": "SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS';",
        "question": "How many female patients were given an APS diagnosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS'",
        "explain": "female refers to SEX = 'F'; APS diagnosis refers to Diagnosis='APS'",
        "solution": [
            "To determine how many female patients were given an APS diagnosis, the following steps are performed:\n\n1. **Filter the Patient table**: Select only those records where the `SEX` column is 'F' (indicating female patients) and the `Diagnosis` column is 'APS' (indicating an APS diagnosis).\n2. **Count the records**: Calculate the total number of records that meet the above criteria by counting the `ID` column.\n\nThe result will be the count of female patients diagnosed with APS."
        ]
    },
    "1170": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Examination T2 ON T1.ID = T2.ID \nWHERE T1.Admission = '+' \nAND (STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.`First Date`) >= 1);",
        "question": "How many patients hadn't undergone a medical examination until at least a year following their initial hospital visit?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '+' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.`First Date`) >= 1",
        "explain": "hadn't undergone a medical examination until at least a year refers to SUBTRACT(year(`Examination Date`), year(`First Date`)) > = 1",
        "solution": [
            "To solve the question, \"How many patients hadn't undergone a medical examination until at least a year following their initial hospital visit?\", the following steps are performed:\n\n1. **Identify Patients with Admissions**: Filter the `Patient` table to include only those patients who have an admission record (indicated by `Admission = '+'`).\n\n2. **Join with Examination Records**: For each of these patients, join their records with the `Examination` table using the patient ID (`ID`) as the key.\n\n3. **Calculate Time Difference**: For each examination record, calculate the difference in years between the examination date (`Examination Date`) and the patient's first visit date (`First Date`).\n\n4. **Filter Examinations After a Year**: Include only those examination records where the time difference is at least 1 year (i.e., `STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.`First Date`) >= 1`).\n\n5. **Count Distinct Patients**: Count the number of distinct patients (`ID`) who meet the above criteria.\n\nThe final result is the count of such patients."
        ]
    },
    "336": {
        "sql": "SELECT COUNT(DISTINCT b.molecule_id) \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.bond_type = '#' AND m.label = '-';",
        "question": "in molecules with triple bonds, how many of them are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND T1.label = '-'",
        "explain": "triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "90": {
        "sql": "SELECT COUNT(DISTINCT a.account_id) AS eligible_accounts\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE d.A3 = 'Prague';",
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "explain": "A3 contains the data of region",
        "solution": []
    },
    "1284": {
        "sql": "SELECT T1.\"First Date\"\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH < 500\nORDER BY T2.LDH DESC\nLIMIT 1;",
        "question": "For the patient with the highest lactate dehydrogenase in the normal range, when was his or her data first recorded?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH < 500 ORDER BY T2.LDH ASC LIMIT 1",
        "explain": "highest lactate dehydrogenase in the normal range refers to MAX(LDH < 500); when the data first recorded refers to MIN(First Date);",
        "solution": [
            "To find the first recorded date of the patient with the highest lactate dehydrogenase (LDH) level within the normal range (LDH < 500), follow these steps:\n\n1. **Join the Patient and Laboratory tables**: Link the records in the `Patient` table with the corresponding records in the `Laboratory` table using the patient ID (`ID`).\n\n2. **Filter for normal LDH levels**: Include only those records where the LDH value (`LDH`) is less than 500, as this represents the normal range.\n\n3. **Sort the LDH values in ascending order**: Arrange the filtered records by their LDH values in ascending order. This will place the highest LDH value within the normal range at the top of the list.\n\n4. **Select the top record**: Retrieve the first record from the sorted list, which corresponds to the patient with the highest LDH level within the normal range.\n\n5. **Extract the first recorded date**: From the selected record, obtain the value in the `First Date` column, which indicates when the patient's data was first recorded.\n\nThe SQL query accomplishes this by joining the tables, filtering, sorting, and limiting the results to the top record.",
            "To determine the first recorded date of the patient with the highest lactate dehydrogenase (LDH) level within the normal range (LDH < 500), follow these detailed steps:\n\n1. **Join the Patient and Laboratory tables**: Combine the records from the `Patient` table (aliased as `T1`) with the records from the `Laboratory` table (aliased as `T2`) using the patient ID (`ID`) as the joining key. This ensures that each patient's data is linked to their corresponding laboratory results.\n\n2. **Filter for normal LDH levels**: Apply a condition to include only those records where the LDH value (`T2.LDH`) is less than 500. This filters out any abnormal or elevated LDH levels, focusing solely on the normal range.\n\n3. **Sort the LDH values in ascending order**: Arrange the filtered records by the LDH values (`T2.LDH`) in ascending order. This sorting places the highest LDH value within the normal range at the top of the list, as the query will later limit the results to the first record.\n\n4. **Limit the results to the top record**: Restrict the output to only the first record from the sorted list. This record corresponds to the patient with the highest LDH level within the normal range.\n\n5. **Retrieve the first recorded date**: From the selected record, extract the value in the `First Date` column (`T1.First Date`), which indicates the earliest date when the patient's data was recorded.\n\nThe SQL query achieves this by performing an inner join between the `Patient` and `Laboratory` tables, filtering for normal LDH levels, sorting the results, and limiting the output to the top record to obtain the desired date."
        ]
    },
    "180": {
        "sql": "SELECT T1.client_id, T3.account_id\nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nINNER JOIN disp T4 ON T1.client_id = T4.client_id\nINNER JOIN account T3 ON T4.account_id = T3.account_id AND T3.district_id = T2.district_id\nWHERE T2.A3 = 'east Bohemia'\nAND strftime('%Y', T1.birth_date) BETWEEN '1983' AND '1987';",
        "question": "Please provide a list of clients who were born between 1983 and 1987 and whose account branch is in East Bohemia, along with their IDs.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.client_id, T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id and T4.account_id = T3.account_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'",
        "explain": "",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Select the required fields**: Retrieve the `client_id` from the `client` table (aliased as `T1`) and the `account_id` from the `account` table (aliased as `T3`).\n\n2. **Join the `client` table with the `district` table**: Use an inner join to connect the `client` table (`T1`) with the `district` table (`T2`) on the `district_id` field. This ensures that only clients associated with a district are included.\n\n3. **Join the `client` table with the `disp` table**: Use an inner join to connect the `client` table (`T1`) with the `disp` table (`T4`) on the `client_id` field. This ensures that only clients with a disposition record are included.\n\n4. **Join the `account` table with the `district` and `disp` tables**: Use an inner join to connect the `account` table (`T3`) with the `district` table (`T2`) on the `district_id` field and with the `disp` table (`T4`) on the `account_id` field. This ensures that only accounts associated with the correct district and disposition are included.\n\n5. **Filter the results**: Apply the following filters:\n   - The district's `A3` field must be 'east Bohemia'.\n   - The client's birth year (extracted from the `birth_date` field) must be between 1983 and 1987 (inclusive).\n\n6. **Return the results**: The final output is a list of clients who meet all the specified criteria, along with their IDs."
        ]
    },
    "1444": {
        "sql": "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50;",
        "question": "List the expenses that spend more than fifty dollars on average.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50",
        "explain": "expense refers to expense_description; spend more than fifty dollars on average refers to DIVIDE( SUM(cost), COUNT(expense_id) ) > 50",
        "solution": [
            "To solve the question, which asks to list the expenses that spend more than fifty dollars on average, the following steps are performed:\n\n1. **Group the Data**: The expenses are grouped by their descriptions (`expense_description`). This means all entries with the same description are considered together.\n\n2. **Calculate the Average**: For each group of expenses with the same description, the average cost (`AVG(cost)`) is calculated.\n\n3. **Filter the Results**: Only those groups where the calculated average cost is greater than 50 dollars (`AVG(cost) > 50`) are retained.\n\n4. **Display the Descriptions**: Finally, the descriptions of the expenses (`expense_description`) that meet the above criteria are listed.\n\nThis process ensures that only expenses with an average spending of more than fifty dollars are included in the result."
        ]
    },
    "813": {
        "sql": "SELECT AVG(ha.attribute_value) AS average_attribute_value\nFROM superhero sh\nJOIN hero_attribute ha ON sh.id = ha.hero_id\nWHERE sh.alignment_id = 3;",
        "question": "Calculate the average attribute value of all neutral superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.attribute_value) FROM hero_attribute AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id INNER JOIN alignment AS T3 ON T2.alignment_id = T3.id WHERE T3.alignment = 'Neutral'",
        "explain": "average = AVG(attribute_value); neutral superheroes refers to alignment_id = 3;",
        "solution": []
    },
    "637": {
        "sql": "SELECT DISTINCT p.Tags\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE u.DisplayName = 'Mark Meckes'\nAND p.CommentCount = 0;",
        "error": "something went wrong, tool did not call.",
        "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
        "explain": "used by Mark Meckes refers to DisplayName = 'Mark Meckes'; Doen't have comments refers to CommentCount = 0;",
        "solution": [
            "To find all the tags used by Mark Meckes in his posts that do not have comments, follow these steps:\n\n1. **Identify the User**: Locate the user with the display name \"Mark Meckes\" in the `users` table.\n2. **Retrieve Post History**: Using the user's ID, retrieve all entries from the `postHistory` table where the `UserId` matches the ID of \"Mark Meckes\".\n3. **Filter Posts Without Comments**: For each post identified in the previous step, check the `posts` table to find posts where the `CommentCount` is 0 (indicating no comments).\n4. **Extract Tags**: From the filtered posts, extract the `Tags` field to list all the tags used in these posts.\n\nThis process ensures that only tags from posts by \"Mark Meckes\" with no comments are included in the result."
        ]
    },
    "1384": {
        "sql": "SELECT SUM(amount) AS total_income FROM income WHERE link_to_member = (SELECT member_id FROM member WHERE first_name = 'Grant' AND last_name = 'Gilmour');",
        "question": "How many income generated by Grant Gilmour?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'",
        "explain": "income generated refers to income.amount",
        "solution": []
    },
    "1211": {
        "sql": "SELECT DISTINCT T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) AS Age\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH > 600 AND T2.LDH < 800;",
        "question": "Provide the ID and age of patient with lactate dehydrogenase (LDH) between 100-300 index above the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 600 AND T2.LDH < 800",
        "explain": "age refers to SUBTRACT(year(current_timestamp), year(Birthday)); lactate dehydrogenase (LDH) between 100-300 index above the normal range refers to LDH between 600 and 800;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct Patient IDs and Calculate Age**: Retrieve the distinct IDs of patients and calculate their current age by subtracting their birth year from the current year.\n\n2. **Join Patient and Laboratory Tables**: Combine the `Patient` table (aliased as `T1`) with the `Laboratory` table (aliased as `T2`) using the patient ID as the joining condition.\n\n3. **Filter by LDH Range**: Include only those records where the lactate dehydrogenase (LDH) level in the `Laboratory` table is between 600 and 800. This range corresponds to 100-300 index above the normal range, as specified in the question.\n\nThe final result will display the unique patient IDs along with their calculated ages for patients meeting the LDH criteria.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Select Distinct Patient IDs and Calculate Age**: Retrieve the distinct IDs of patients and calculate their current age by subtracting their birth year (extracted from the `Birthday` column in the `Patient` table) from the current year (obtained using `STRFTIME('%Y', CURRENT_TIMESTAMP)`).\n\n2. **Join Patient and Laboratory Tables**: Perform an inner join between the `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) using the patient ID (`T1.ID = T2.ID`) as the joining condition. This ensures that only records with matching patient IDs in both tables are included.\n\n3. **Filter by LDH Range**: Apply a filter to include only those records where the lactate dehydrogenase (LDH) level in the `Laboratory` table (`T2.LDH`) is greater than 600 and less than 800. This range corresponds to 100-300 index above the normal range, as specified in the question.\n\nThe final result will display the unique patient IDs (`T1.ID`) along with their calculated ages for patients meeting the specified LDH criteria."
        ]
    },
    "541": {
        "sql": "SELECT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Score = (SELECT MAX(Score) FROM posts);",
        "question": "What is the display name of the user who is the owner of the most valuable post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.FavoriteCount DESC LIMIT 1",
        "explain": "most valuable post refers to Max(FavoriteCount)",
        "solution": []
    },
    "1269": {
        "sql": "SELECT DISTINCT T1.ID\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.SC170 = 'negative' OR T2.SC170 = '0') AND T2.Date > '1997-01-01'",
        "question": "Please list the IDs of the patients who had the examination done after 1997/1/1 and had a normal anti-scl70.",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SC170 IN ('negative','0') AND T2.Date > 1997-01-01",
        "explain": "examination done after 1997/1/1 refers to `Examination Date` >  1997-01-01; normal anti-scl70 refers to SC170 IN('negative','0');",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Select the Patient IDs**: The query retrieves the `ID` column from the `Patient` table (aliased as `T1`).\n\n2. **Join with the Laboratory Table**: The `Patient` table is joined with the `Laboratory` table (aliased as `T2`) using the `ID` column as the join condition. This ensures that only records where the patient IDs match in both tables are considered.\n\n3. **Filter for Normal Anti-Scl70 Results**: The query filters the records in the `Laboratory` table to include only those where the `SC170` column has values 'negative' or '0', indicating a normal anti-scl70 result.\n\n4. **Filter for Examination Dates After 1997/1/1**: The query further filters the records to include only those where the `Date` column in the `Laboratory` table is after January 1, 1997.\n\n5. **Return the Result**: The final result is a list of patient IDs who meet both criteria: having a normal anti-scl70 result and an examination date after January 1, 1997.",
            "To solve the question, the following detailed steps are performed:\n\n1. **Select the Patient IDs**: The query retrieves the `ID` column from the `Patient` table, which is aliased as `T1`. This column contains the unique identifiers of the patients.\n\n2. **Join with the Laboratory Table**: The `Patient` table (`T1`) is joined with the `Laboratory` table (aliased as `T2`) using the `ID` column as the join condition. This ensures that only records where the patient IDs match in both tables are included in the result set.\n\n3. **Filter for Normal Anti-Scl70 Results**: The query filters the records in the `Laboratory` table (`T2`) to include only those where the `SC170` column has values 'negative' or '0'. These values indicate a normal anti-scl70 result.\n\n4. **Filter for Examination Dates After 1997/1/1**: The query further filters the records to include only those where the `Date` column in the `Laboratory` table (`T2`) is after January 1, 1997. This ensures that only examinations conducted after this date are considered.\n\n5. **Return the Result**: The final result is a list of patient IDs (`T1.ID`) who meet both criteria: having a normal anti-scl70 result (as indicated by the `SC170` column) and an examination date after January 1, 1997 (as indicated by the `Date` column)."
        ]
    },
    "1282": {
        "sql": "SELECT p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.GPT < 60\nORDER BY l.GPT DESC\nLIMIT 3;",
        "question": "Please list the top three patients' birthdays with the highest glutamic pylvic transaminase in the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT < 60 ORDER BY T2.GPT DESC LIMIT 3",
        "explain": "highest glutamic pylvic transaminase in the normal range refers to MAX(GPT < 60);",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Join the Patient and Laboratory tables**: The tables are joined using the common column `ID` to link patient information with their laboratory results.\n\n2. **Filter for normal GPT levels**: Only records where the glutamic pyruvic transaminase (GPT) level is below 60 (the upper limit of the normal range) are included.\n\n3. **Sort by GPT levels in descending order**: The filtered records are sorted so that the highest GPT levels within the normal range appear first.\n\n4. **Limit the results to the top three**: Only the first three records from the sorted list are selected, which correspond to the patients with the highest GPT levels in the normal range.\n\n5. **Retrieve the birthdays**: The birthdays of these top three patients are extracted from the result set."
        ]
    },
    "838": {
        "sql": "SELECT full_name FROM superhero WHERE superhero_name = 'Alien';",
        "question": "Provide the full name of the superhero named Alien.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT full_name FROM superhero WHERE superhero_name = 'Alien'",
        "explain": "",
        "solution": []
    },
    "1009": {
        "sql": "SELECT T1.duration\nFROM pitStops T1\nJOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix';",
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "explain": "time spent at pit stop refers to duration",
        "solution": [
            "To list the time each driver spent at the pit stop during the 2011 Australian Grand Prix, follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables:\n   - `pitStops` (referred to as `T1` in the SQL) contains information about pit stops, including the duration each driver spent.\n   - `races` (referred to as `T2` in the SQL) contains information about the races, including the year and name of the Grand Prix.\n\n2. **Join the tables**: Combine the `pitStops` table (`T1`) with the `races` table (`T2`) using the `raceId` field. This links each pit stop record to its corresponding race.\n\n3. **Filter the data**: Narrow down the results to only include records where:\n   - The year of the race is `2011` (from the `races` table).\n   - The name of the Grand Prix is `'Australian Grand Prix'` (from the `races` table).\n\n4. **Select the required field**: Retrieve the `duration` field from the `pitStops` table (`T1`), which represents the time each driver spent at the pit stop.\n\nThis process ensures that you get a list of all pit stop durations for the specified race."
        ]
    },
    "950": {
        "sql": "SELECT T2.name FROM constructorStandings T1 JOIN constructors T2 ON T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291;",
        "question": "Please list the constructor names with 0 points at race 291.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291",
        "explain": "race at 291 refers to raceID = 291;",
        "solution": [
            "To solve the question, 'Please list the constructor names with 0 points at race 291,' the following steps are performed:\n\n1. **Join Tables**: The `constructorStandings` table (referred to as `T1`) is joined with the `constructors` table (referred to as `T2`) using the `constructorId` field. This links the standings data with the constructor details.\n\n2. **Filter by Points and Race**: From the joined tables, filter the records where the `points` field in `T1` equals `0` and the `raceId` field in `T1` equals `291`. This ensures only constructors with zero points in race 291 are considered.\n\n3. **Select Constructor Names**: Finally, select the `name` field from the `T2` table (the `constructors` table) to retrieve the names of the constructors that meet the criteria.\n\nThe SQL query accomplishes this by combining these steps into a single query."
        ]
    },
    "161": {
        "sql": "SELECT c.type \nFROM card c \nJOIN disp d ON c.disp_id = d.disp_id \nWHERE d.client_id = 13539;",
        "question": "What type of credit card does the client with the id 13539 own?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.type FROM disp AS T1 INNER JOIN client AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T1.disp_id = T3.disp_id WHERE T2.client_id = 13539",
        "explain": "",
        "solution": []
    },
    "659": {
        "sql": "SELECT COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000;",
        "question": "How many tags have post count between 5,000 to 7,000?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM tags WHERE Count BETWEEN 5000 AND 7000",
        "explain": "post count between 5,000 to 7,000 refers to Count BETWEEN 5000 and 7000;",
        "solution": []
    },
    "1150": {
        "sql": "SELECT (SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_female_born_after_1930\nFROM Patient\nWHERE SEX = 'F';",
        "question": "What is the percentage of female patient were born after 1930?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'",
        "explain": "female refers to Sex = 'F'; patient who were born after 1930 refers to year(Birthday) > '1930'; calculation = DIVIDE(COUNT(ID) where year(Birthday) > '1930' and SEX = 'F'), (COUNT(ID) where SEX = 'F')",
        "solution": [
            "To determine the percentage of female patients born after 1930, follow these steps:\n\n1. **Filter Female Patients**: First, select all records from the `Patient` table where the `SEX` column is 'F' (female).\n\n2. **Check Birth Year**: For each female patient, extract the year from their `Birthday` column using the `STRFTIME` function with the format '%Y' to get the year.\n\n3. **Count Eligible Patients**: Count how many of these female patients have a birth year greater than 1930. This is done using a `CASE` statement that assigns 1 if the birth year is after 1930 and 0 otherwise, then summing these values.\n\n4. **Calculate Percentage**: Divide the count of eligible patients (those born after 1930) by the total number of female patients. Multiply the result by 100 to convert it to a percentage.\n\n5. **Cast to Real**: Ensure the division result is treated as a real number to avoid integer division issues.\n\nThe final result is the percentage of female patients born after 1930."
        ]
    },
    "1011": {
        "sql": "WITH ConvertedLapTimes AS (\n    SELECT \n        driverId,\n        lap,\n        (CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n        CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 AS total_seconds\n    FROM lapTimes\n    WHERE time IS NOT NULL\n),\nMinLapTimes AS (\n    SELECT \n        driverId,\n        MIN(total_seconds) AS min_lap_time\n    FROM ConvertedLapTimes\n    GROUP BY driverId\n)\nSELECT \n    d.driverId,\n    d.forename || ' ' || d.surname AS full_name,\n    m.min_lap_time\nFROM MinLapTimes m\nJOIN drivers d ON m.driverId = d.driverId\nORDER BY m.min_lap_time ASC\nLIMIT 20;",
        "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
        "explain": "shortest lap time refers to MIN(time); the time format for the shortest lap time is 'MM:SS.mmm' or 'M:SS.mmm'; full name of the driver refers to forename, surname",
        "solution": [
            "To solve the question, \"Which top 20 drivers created the shortest lap time ever recorded in a Formula 1 race? Please give them full names,\" the following steps are performed:\n\n1. **Convert Lap Times to Seconds**:\n   - The lap times are stored in a format like `MM:SS.mmm`. This step converts each lap time into total seconds for easier comparison.\n   - For each lap time:\n     - Extract the minutes part (before the colon) and convert it to seconds by multiplying by 60.\n     - Extract the seconds part (between the colon and the dot) and add it directly.\n     - Extract the milliseconds part (after the dot) and convert it to seconds by dividing by 1000.\n     - Sum these three values to get the total time in seconds.\n\n2. **Find Minimum Lap Time for Each Driver**:\n   - Group the converted lap times by `driverId`.\n   - For each driver, find the minimum lap time (in seconds) they have ever recorded.\n\n3. **Retrieve Driver Names**:\n   - Join the results from the previous step with the `drivers` table to get the full names (`forename` and `surname`) of the drivers.\n\n4. **Sort and Limit Results**:\n   - Sort the drivers by their minimum lap time in ascending order (shortest time first).\n   - Limit the results to the top 20 drivers with the shortest lap times.\n\nThe final output will list the full names of the top 20 drivers who have recorded the shortest lap times in Formula 1 history, along with their `driverId`."
        ]
    },
    "458": {
        "sql": "SELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena,mtgo%';",
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards",
        "explain": "available in both \"arena\" and \"mtgo\" refers to availability like '%arena,mtgo%'",
        "solution": [
            "To solve the question, the database performs the following operations:\n\n1. **Filtering the Data**: The database scans the `cards` table to identify records where the `borderColor` is 'black' and the `availability` field contains both 'arena' and 'mtgo' (indicated by the substring '%arena,mtgo%').\n\n2. **Counting Matching Records**: For each record that meets the criteria, it assigns a value of 1. Records that do not meet the criteria are assigned NULL. The `COUNT` function then counts the number of non-NULL values (i.e., the number of records that meet the criteria).\n\n3. **Returning the Result**: The final result is the count of artists who have designed a card with a black border color and is available in both 'arena' and 'mtgo' printing types.",
            "To solve the question, the database performs the following operations:\n\n1. **Filtering the Data**: The database scans the `cards` table to identify records where the `borderColor` is 'black' and the `availability` field contains both 'arena' and 'mtgo' (indicated by the substring '%arena,mtgo%').\n\n2. **Counting Matching Records**: For each record that meets the criteria, it assigns a value of 1. Records that do not meet the criteria are assigned NULL. The `COUNT` function then counts the number of non-NULL values (i.e., the number of records that meet the criteria).\n\n3. **Returning the Result**: The final result is the count of artists who have designed a card with a black border color and is available in both 'arena' and 'mtgo' printing types."
        ]
    },
    "1060": {
        "sql": "SELECT COUNT(*) FROM Player WHERE strftime('%Y', birthday) > '1990';",
        "question": "How many players were born after 1990?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990'",
        "explain": "born after 1990 refers to strftime('%Y', birthday) = '1990';",
        "solution": []
    },
    "1068": {
        "sql": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_overall_rating\nFROM Player t1\nJOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 170\nAND STRFTIME('%Y', t2.date) >= '2010'\nAND STRFTIME('%Y', t2.date) <= '2015';",
        "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
        "explain": "from 2010 to 2015 refers to strftime('%Y', date) >= '2010' AND <= '2015'; average overall rating = SUM(t2.overall_rating)/ COUNT(t2.id); higher than 170 refers to Player.height > 170;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: Combine the `Player` table (aliased as `t1`) and the `Player_Attributes` table (aliased as `t2`) using the `player_api_id` field to link them.\n\n2. **Filter by Height**: From the joined tables, filter out players whose height is greater than 170 cm.\n\n3. **Filter by Date Range**: Further filter the results to include only records where the year part of the `date` field in the `Player_Attributes` table falls between 2010 and 2015 (inclusive).\n\n4. **Calculate the Average Rating**: For the remaining records, compute the average `overall_rating` by summing all the `overall_rating` values and dividing by the count of players (using their `id` for counting). The result is cast to a real number to ensure precision.\n\nThis sequence of operations ensures that the query returns the average overall rating of players taller than 170 cm from the years 2010 to 2015.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Join the Tables**: The `Player` table (aliased as `t1`) and the `Player_Attributes` table (aliased as `t2`) are joined using the `player_api_id` field to link them. This ensures that each player's attributes are matched with their corresponding player record.\n\n2. **Filter by Height**: From the joined tables, only players whose height is greater than 170 cm are selected. This is done by applying the condition `t1.height > 170`.\n\n3. **Filter by Date Range**: The results are further filtered to include only records where the year part of the `date` field in the `Player_Attributes` table falls between 2010 and 2015 (inclusive). This is achieved using the conditions `STRFTIME('%Y', t2.date) >= '2010'` and `STRFTIME('%Y', t2.date) <= '2015'`.\n\n4. **Calculate the Average Rating**: For the remaining records, the average `overall_rating` is computed. This involves summing all the `overall_rating` values (`SUM(t2.overall_rating)`) and dividing by the count of players (`COUNT(t2.id)`). The result is cast to a real number (`CAST(... AS REAL)`) to ensure precision in the calculation.\n\nThis sequence of operations ensures that the query accurately returns the average overall rating of players taller than 170 cm from the years 2010 to 2015."
        ]
    },
    "871": {
        "sql": "SELECT DISTINCT d.nationality FROM qualifying q JOIN drivers d ON q.driverId = d.driverId WHERE q.raceId = 347 AND q.q2 LIKE '1:15%';",
        "question": "For the driver who had the Q2 time as 0:01:15 in race No. 347, where is he from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 347 AND T1.q2 LIKE '1:15%'",
        "explain": "race number refers to raceId;",
        "solution": [
            "To find the nationality of the driver who had a Q2 time of 0:01:15 in race No. 347, follow these steps:\n\n1. **Join the Tables**: Combine the `qualifying` table (referred to as T1) with the `drivers` table (referred to as T2) using the `driverId` field. This links the qualifying results to the driver details.\n\n2. **Filter by Race ID**: From the joined tables, filter the records to only include those where the `raceId` is 347. This narrows down the data to the specific race in question.\n\n3. **Filter by Q2 Time**: Further filter the records to include only those where the `q2` time starts with '1:15'. This ensures we are looking at the driver who had a Q2 time of 0:01:15.\n\n4. **Select Nationality**: From the filtered records, select the `nationality` field from the `drivers` table (T2). This gives the nationality of the driver who met the specified conditions.\n\n5. **Ensure Distinct Results**: Use `DISTINCT` to ensure that if there are multiple entries for the same driver, only one result is returned for their nationality."
        ]
    },
    "1492": {
        "sql": "SELECT \n    (COUNT(CASE WHEN c.Currency = 'EUR' THEN 1 END) * 100.0 / COUNT(*)) AS Percentage_KAM_EUR\nFROM \n    customers c\nWHERE \n    c.Segment = 'KAM';",
        "question": "What percentage of KAM customers pay in euros?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(Currency = 'EUR') AS FLOAT) * 100 / COUNT(CustomerID) FROM customers WHERE Segment = 'KAM'",
        "explain": "Percentage of KAM uses Euro = (Total of KAM uses Euro / Total of KAM) * 100%.",
        "solution": []
    },
    "800": {
        "sql": "SELECT (COUNT(CASE WHEN eye_colour_id = 7 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_blue_eyes\nFROM superhero;",
        "question": "Calculate the percentage of superheroes with blue eyes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id",
        "explain": "percentage = MULTIPLY(DIVIDE(SUM(superhero_name WHERE color = 'Blue'), COUNT(superhero_name)), 100.0); blue eyes refers to color = 'Blue' and color.id =  eye_colour_id = 7;",
        "solution": []
    },
    "297": {
        "sql": "SELECT a.atom_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'c' AND m.label = '-';",
        "question": "Among the atoms that contain element carbon, which one does not contain compound carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
        "explain": "label = '-' means molecules are non-carcinogenic; carbon refers to element = 'c'",
        "solution": []
    },
    "730": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE p.publisher_name = 'Marvel Comics'\nAND sp.power_name = 'Super Strength';",
        "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
        "explain": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; super power of \"Super Strength\" refers to power_name = 'Super Strength';",
        "solution": []
    },
    "767": {
        "sql": "SELECT COUNT(*) * 1.0 / SUM(CASE WHEN skin_colour_id = 1 THEN 1 ELSE 0 END) AS average_no_skin_colour\nFROM superhero;",
        "question": "What is the average of superheroes with no skin colour?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id",
        "explain": "average = DIVIDE(COUNT(superhero.id), SUM(skin_colour_id = 1)); no skin colour refers to skin_colour_id WHERE colour.id = 1;",
        "solution": []
    },
    "1461": {
        "sql": "SELECT m.last_name, m.phone\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Elementary Education';",
        "question": "List the last names of students under the Elementary Education major and include their phone numbers.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.last_name, T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T2.major_name = 'Elementary Education'",
        "explain": "'Elementary Education' is the major name; phone numbers refers to phone",
        "solution": []
    },
    "12": {
        "sql": "SELECT MAX(f.`Free Meal Count (Ages 5-17)` / f.`Enrollment (Ages 5-17)`) AS highest_eligible_free_rate\nFROM satscores s\nJOIN frpm f ON s.cds = f.CDSCode\nWHERE (s.NumGE1500 * 1.0 / s.NumTstTakr) > 0.3;",
        "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT MAX(CAST(T1.`Free Meal Count (Ages 5-17)` AS REAL) / T1.`Enrollment (Ages 5-17)`) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3",
        "explain": "Excellence rate = NumGE1500 / NumTstTakr; Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
        "solution": []
    },
    "773": {
        "sql": "SELECT s.superhero_name, p.publisher_name\nFROM superhero s\nJOIN colour eye ON s.eye_colour_id = eye.id\nJOIN colour hair ON s.hair_colour_id = hair.id\nJOIN colour skin ON s.skin_colour_id = skin.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE eye.id = hair.id AND hair.id = skin.id\nGROUP BY s.superhero_name, p.publisher_name;",
        "question": "Which superhero has the same eyes, hair and skin colour? Indicate the publisher of the superhero.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name, T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id",
        "explain": "which superhero refers to superhero_name; the same eyes, hair and skin colour refers to hair_colour_id = skin_colour_id AND hair_colour_id = eye_colour_id; publisher refers to publisher_name;",
        "solution": []
    },
    "239": {
        "sql": "SELECT COUNT(DISTINCT bond_id) AS connection_count FROM connected WHERE atom_id LIKE 'TR%_19' OR atom_id2 LIKE 'TR%_19';",
        "question": "How many connections does the atom 19 have?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
        "explain": "connections refers to bond_id; atom 19 refers to atom_id like 'TR%_19';",
        "solution": []
    },
    "514": {
        "sql": "SELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 10;",
        "question": "In duels, what are the top 10 cards with the highest uncoverted mana cost?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 0, 10",
        "explain": "duels refer to format = 'duel'; the highest uncoverted mana cost refers to MAX(manaCost)",
        "solution": [
            "To find the top 10 cards with the highest unconverted mana cost in duels, follow these steps:\n\n1. **Identify Eligible Cards**: First, determine which cards are legal in the 'duel' format. This is done by selecting the unique identifiers (`uuid`) of cards from the `legalities` table where the `format` is 'duel'.\n\n2. **Retrieve Card Details**: Using the list of `uuid`s obtained in the previous step, retrieve the names (`name`) of these cards from the `cards` table.\n\n3. **Sort by Mana Cost**: Order the retrieved cards by their `manaCost` in descending order to prioritize cards with the highest mana cost.\n\n4. **Limit Results**: Finally, limit the results to the top 10 cards to answer the question about the top 10 cards with the highest unconverted mana cost in duels.",
            "To find the top 10 cards with the highest unconverted mana cost in duels, follow these detailed steps:\n\n1. **Filter Cards by Duel Legality**: Begin by querying the `legalities` table to identify all cards that are legal in the 'duel' format. This involves selecting the `uuid` (unique identifier) of each card where the `format` column equals 'duel'.\n\n2. **Retrieve Card Names and Mana Costs**: Using the list of `uuid`s obtained from the first step, query the `cards` table to retrieve the `name` and `manaCost` of each card. This ensures you have both the card names and their associated mana costs.\n\n3. **Sort by Mana Cost in Descending Order**: Once you have the card names and mana costs, sort the results by the `manaCost` column in descending order. This places the cards with the highest mana costs at the top of the list.\n\n4. **Limit to Top 10 Results**: Apply a limit to the sorted results to return only the top 10 cards. This directly answers the question by providing the 10 cards with the highest unconverted mana costs in the 'duel' format.\n\nThe SQL query for this operation is:\n```sql\nSELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 0, 10\n```"
        ]
    },
    "212": {
        "sql": "SELECT element FROM (SELECT a.element, COUNT(DISTINCT a.molecule_id) AS molecule_count FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.label = '-' GROUP BY a.element ORDER BY molecule_count ASC LIMIT 1);",
        "question": "Which element is the least numerous in non-carcinogenic molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
        "explain": "label = '-' means molecules are non-carcinogenic; least numerous refers to MIN(COUNT(element));",
        "solution": [
            "To determine which element is the least numerous in non-carcinogenic molecules, follow these steps:\n\n1. **Filter Non-Carcinogenic Molecules**: Identify molecules labeled as non-carcinogenic (denoted by the label '-').\n2. **Join Tables**: Combine the `atom` and `molecule` tables using the `molecule_id` field to link atoms to their respective molecules.\n3. **Group by Element**: For each element, count the distinct molecules it appears in within the non-carcinogenic set.\n4. **Order by Count**: Arrange the elements in ascending order based on their molecule counts to find the least numerous.\n5. **Select the Least Numerous Element**: Retrieve the element with the smallest count, which appears in the fewest non-carcinogenic molecules.\n\nThe SQL query accomplishes this by:\n- Selecting the `element` from a subquery.\n- The subquery joins the `atom` and `molecule` tables, filters for non-carcinogenic molecules, groups by element, counts distinct molecules per element, orders by count in ascending order, and limits to the first result (the least numerous)."
        ]
    },
    "346": {
        "sql": "SELECT c.id, c.artist\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE (c.power = '*' OR c.power IS NULL)\nAND l.format = 'commander'\nAND l.status = 'Legal';",
        "question": "List all the card id and artist with unknown power which are legal for commander play format.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Legal' AND T2.format = 'commander' AND (T1.power IS NULL OR T1.power = '*')",
        "explain": "unknown power refers to power = '*' or POWER IS NULL; commander play format refers to format = 'commander'; legal for commander play format refers to format = 'commander' where status = 'Legal'",
        "solution": []
    },
    "445": {
        "sql": "SELECT DISTINCT T2.language, T2.flavorText, T1.type\nFROM cards T1\nJOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.watermark = 'colorpie';",
        "question": "What is the language and flavor text of the card that has colorpie watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T2.language, T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'colorpie'",
        "explain": "",
        "solution": [
            "To solve the question, we need to find the language and flavor text of the card that has the 'colorpie' watermark, along with listing the type of this card. The SQL query performs the following operations:\n\n1. **Select Distinct Values**: The query retrieves distinct values of `language` and `flavorText` from the `foreign_data` table (aliased as `T2`).\n\n2. **Join Tables**: It joins the `cards` table (aliased as `T1`) with the `foreign_data` table (aliased as `T2`) using the `uuid` column as the common key.\n\n3. **Filter by Watermark**: The query filters the results to only include cards where the `watermark` column in the `cards` table (T1) is equal to 'colorpie'.\n\nThis ensures that the output will list the unique combinations of language and flavor text for cards with the specified watermark.",
            "To solve the question, we need to find the language and flavor text of the card that has the 'colorpie' watermark, along with listing the type of this card. The SQL query performs the following operations:\n\n1. **Select Distinct Values**: The query retrieves distinct values of `language` and `flavorText` from the `foreign_data` table (aliased as `T2`). This ensures that each combination of language and flavor text is unique in the result set.\n\n2. **Join Tables**: It joins the `cards` table (aliased as `T1`) with the `foreign_data` table (aliased as `T2`) using the `uuid` column as the common key. This links the card data with its corresponding foreign language and flavor text data.\n\n3. **Filter by Watermark**: The query filters the results to only include cards where the `watermark` column in the `cards` table (T1) is equal to 'colorpie'. This ensures that only cards with the specified watermark are considered.\n\nThe output will list the unique combinations of language and flavor text for cards with the 'colorpie' watermark, as well as the type of these cards."
        ]
    },
    "259": {
        "sql": "SELECT COUNT(DISTINCT T1.element) AS distinct_elements_count\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nJOIN bond T3 ON T2.molecule_id = T3.molecule_id\nWHERE T3.bond_type = '-';",
        "question": "How many elements are there for single bond molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "explain": "single bond refers to bond_type = '-';",
        "solution": [
            "To determine how many distinct elements are present in single bond molecules, follow these steps:\n\n1. **Identify the relevant tables**: The query involves three tables: `atom` (referred to as `T1`), `molecule` (referred to as `T2`), and `bond` (referred to as `T3`).\n\n2. **Join the tables**:\n   - Join the `atom` table (`T1`) with the `molecule` table (`T2`) using the `molecule_id` field to link atoms to their respective molecules.\n   - Join the result with the `bond` table (`T3`) using the `molecule_id` field to include bond information for the molecules.\n\n3. **Filter for single bonds**: Apply a filter to only include rows where the `bond_type` in the `bond` table (`T3`) is '-', which represents single bonds.\n\n4. **Select distinct elements**: From the filtered results, select the distinct `element` values from the `atom` table (`T1`).\n\n5. **Count the distinct elements**: Finally, count the number of distinct elements obtained in the previous step to determine how many unique elements are present in single bond molecules.\n\nThe SQL query accomplishes this by:\n- Joining the tables to link atoms, molecules, and bonds.\n- Filtering for single bonds.\n- Selecting and counting distinct elements from the filtered results."
        ]
    },
    "585": {
        "sql": "SELECT SUM(v.BountyAmount) AS TotalBountyAmount\nFROM posts p\nJOIN votes v ON p.Id = v.PostId\nWHERE p.Title LIKE '%data%';",
        "question": "How much is the total bounty amount of the post titled about 'data'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.BountyAmount) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data%'",
        "explain": "About data means the title contains 'data'; total bounty Amount refers to Sum(BountyAmount)",
        "solution": []
    },
    "465": {
        "sql": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') AS has_korean_version\nFROM cards T1\nINNER JOIN set_translations T2 ON T1.setCode = T2.setCode\nWHERE T1.name = 'Ancestor\\'s Chosen';",
        "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "explain": "set of cards with \"Ancestor''s Chosen\" in it refers to name = 'Ancestor''s Chosen'; Korean version refers to language = 'Korean'",
        "solution": [
            "To determine if there is a Korean version of the card \"Ancestor's Chosen\" in its set, follow these steps:\n\n1. **Identify the Card**: Locate the card named \"Ancestor's Chosen\" in the `cards` table.\n2. **Join with Translations**: Join the `cards` table with the `set_translations` table using the `setCode` field to find all translations associated with the set of the card.\n3. **Filter for Korean Translations**: From the joined data, filter for entries where the `language` is \"Korean\" and the `translation` field is not null.\n4. **Check Existence**: Count the number of such entries. If the count is greater than 0, it means there is at least one Korean version of the card, so the answer is \"YES\". Otherwise, the answer is \"NO\".\n\nThe SQL query performs these operations and returns the result as \"YES\" or \"NO\".",
            "To determine if there is a Korean version of the card \"Ancestor's Chosen\" in its set, follow these detailed steps:\n\n1. **Identify the Card**: Query the `cards` table (aliased as `T1`) to locate the card with the name \"Ancestor's Chosen\". This ensures we are working with the correct card.\n\n2. **Join with Set Translations**: Perform an inner join between the `cards` table (`T1`) and the `set_translations` table (aliased as `T2`) using the `setCode` field. This links the card to all translations associated with its set.\n\n3. **Filter for Korean Translations**: From the joined data, filter the results to include only entries where the `language` field in `T2` is \"Korean\" and the `translation` field in `T2` is not null. This ensures we are only considering valid Korean translations.\n\n4. **Count Valid Translations**: Use a `SUM` function combined with a `CASE` statement to count how many entries meet the criteria (i.e., `language` is \"Korean\" and `translation` is not null). The `CASE` statement assigns a value of 1 for each valid entry and 0 otherwise.\n\n5. **Determine Existence**: Apply the `IIF` function to the count result. If the count is greater than 0, the `IIF` function returns \"YES\", indicating that at least one Korean version exists. Otherwise, it returns \"NO\".\n\n6. **Return the Result**: The final output of the query is either \"YES\" or \"NO\", answering the question directly.\n\nThis process ensures that the SQL query accurately checks for the existence of a Korean version of the card \"Ancestor's Chosen\" in its set and provides a clear answer."
        ]
    },
    "507": {
        "sql": "SELECT \n    (SUM(CASE WHEN s.isOnlineOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(s.id)) AS percentage_online_only\nFROM \n    sets s\nJOIN \n    set_translations st ON s.code = st.setCode\nWHERE \n    st.language = 'Portuguese (Brazil)';",
        "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
        "explain": "Brazil Portuguese translation refers to language = 'Portuguese (Brazil)'; only available online refers to isOnlineOnly = 1; percentage of online only Brazil Portuguese in all Brazil Portuguese cards refers to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)))*100",
        "solution": [
            "To solve the question, we need to determine the percentage of card sets that have a Brazilian Portuguese translation and are only available online. The solution involves the following steps:\n\n1. **Identify Sets with Brazilian Portuguese Translation**: First, find all the sets that have a translation in Brazilian Portuguese. This is done by querying the `set_translations` table for entries where the `language` is 'Portuguese (Brazil)' and extracting the `setCode` values.\n\n2. **Filter Sets by Online Availability**: From the identified sets, count how many of them are marked as online-only. This is done by checking the `isOnlineOnly` field in the `sets` table. If `isOnlineOnly` is 1, the set is online-only.\n\n3. **Calculate the Percentage**: Divide the count of online-only sets by the total number of sets with Brazilian Portuguese translation and multiply by 100 to get the percentage.\n\nThe SQL query combines these steps by:\n- Using a subquery to get the `setCode` values from `set_translations` where the language is 'Portuguese (Brazil)'.\n- Counting the total number of sets (`COUNT(id)`) and the number of online-only sets (`SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END)`).\n- Calculating the percentage by dividing the count of online-only sets by the total count and multiplying by 100."
        ]
    },
    "689": {
        "sql": "SELECT T2.DisplayName, T2.Location FROM posts T1 INNER JOIN users T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Id = 183 ORDER BY T1.LastEditDate DESC LIMIT 1;",
        "question": "Identify the display name and location of the user, who was the last to edit the post with ID 183.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T2.DisplayName, T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 183 ORDER BY T1.LastEditDate DESC LIMIT 1",
        "explain": "last to edit refers to MAX(LastEditDate);",
        "solution": [
            "To identify the display name and location of the user who was the last to edit the post with ID 183, follow these steps:\n\n1. **Join the tables**: Combine the `posts` table (referred to as `T1`) with the `users` table (referred to as `T2`) using the `OwnerUserId` from the `posts` table and the `Id` from the `users` table. This ensures that each post is linked to its respective user.\n\n2. **Filter the post**: From the joined tables, filter the records to only include the post with the ID `183`.\n\n3. **Sort by edit date**: Order the filtered results by the `LastEditDate` column in descending order (most recent edit first).\n\n4. **Retrieve the latest editor**: Limit the results to the first record, which will be the most recent edit of the post with ID 183.\n\n5. **Select the required fields**: From this record, extract the `DisplayName` and `Location` of the user who made the last edit.\n\nThis process ensures you get the display name and location of the user who last edited the specified post.",
            "To identify the display name and location of the user who was the last to edit the post with ID 183, follow these detailed steps:\n\n1. **Join the tables**: Perform an inner join between the `posts` table (aliased as `T1`) and the `users` table (aliased as `T2`). The join condition is `T1.OwnerUserId = T2.Id`, which links each post to its respective user based on the user's ID.\n\n2. **Filter the post**: Apply a filter to the joined tables to select only the post with the specific ID `183` using the condition `T1.Id = 183`.\n\n3. **Sort by edit date**: Sort the filtered results by the `LastEditDate` column in descending order (`DESC`) to ensure the most recent edit appears first.\n\n4. **Retrieve the latest editor**: Limit the results to the first record (`LIMIT 1`) to obtain the most recent edit of the post with ID 183.\n\n5. **Select the required fields**: From the resulting record, extract the `DisplayName` and `Location` fields from the `users` table (aliased as `T2`).\n\nThis sequence of operations ensures that you accurately retrieve the display name and location of the user who last edited the specified post."
        ]
    },
    "1189": {
        "sql": "WITH FilteredPatients AS (\n    SELECT ID, `aCL IgM`\n    FROM Examination\n    WHERE Thrombosis = 2 AND `ANA Pattern` = 'S'\n),\nAverageACLIgM AS (\n    SELECT AVG(`aCL IgM`) AS AvgValue\n    FROM FilteredPatients\n)\nSELECT COUNT(*) AS PatientCount\nFROM FilteredPatients, AverageACLIgM\nWHERE `aCL IgM` > (AvgValue * 1.2);",
        "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')",
        "explain": "thrombosis level 2 refers to Thrombosis = 2; ANA pattern of only S refers to ANA = 'S'; average anti-Cardiolip in antibody (IgM) refers to AVG(`aCL IgM`); calculation = MULTIPLY(AVG + AVG, 0.2)",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter the Data**: Identify all patients in the `Examination` table who meet the following criteria:\n   - Their `Thrombosis` level is 2.\n   - Their `ANA Pattern` is 'S'.\n\n2. **Calculate the Average**: Compute the average value of the `aCL IgM` column for the filtered patients (those with `Thrombosis` level 2 and `ANA Pattern` 'S').\n\n3. **Adjust the Average**: Multiply the computed average by 1.2 to determine the threshold value (20% higher than the average).\n\n4. **Apply the Threshold**: Further filter the patients to include only those whose `aCL IgM` value is greater than the adjusted threshold.\n\n5. **Count the Patients**: Count the number of patients who meet all the above criteria.\n\nThe final result is the count of such patients."
        ]
    },
    "1225": {
        "sql": "SELECT T1.ID, T1.SEX\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.\"T-BIL\" >= 2.0\nGROUP BY T1.SEX, T1.ID;",
        "question": "List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID,T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 GROUP BY T1.SEX,T1.ID",
        "explain": "List refers to GROUP_CONCAT(DISTINCT ID); total bilirubin (T-BIL) not within normal range refers to T-BIL > = 2.0",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Select Data**: Retrieve the patient ID (`ID`) and sex (`SEX`) from the `Patient` table (aliased as `T1`).\n\n2. **Join Tables**: Perform an inner join with the `Laboratory` table (aliased as `T2`) using the patient `ID` as the joining condition. This ensures that only patients with laboratory records are considered.\n\n3. **Filter Records**: Apply a filter to include only those records where the total bilirubin (`T-BIL`) level is 2.0 or higher. This identifies patients whose bilirubin levels are not within the normal range.\n\n4. **Group Results**: Group the results by both the patient's sex (`SEX`) and ID (`ID`). This grouping ensures that the output is organized by sex while retaining individual patient records.\n\nThe final output will list all patients grouped by their sex, showing only those with abnormal bilirubin levels."
        ]
    },
    "1129": {
        "sql": "SELECT t.team_long_name \nFROM Team t \nJOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id \nWHERE ta.buildUpPlaySpeedClass = 'Slow';",
        "question": "List down the long name for slow speed class team.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Slow'",
        "explain": "slow speed class refers to buildUpPlaySpeedClass = 'Slow'; long name refers to team_long_name",
        "solution": []
    },
    "523": {
        "sql": "WITH filtered_sets AS (\n    SELECT id, releaseDate\n    FROM sets\n    WHERE releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\n),\nannual_average AS (\n    SELECT \n        strftime('%Y', releaseDate) AS year,\n        COUNT(id) AS set_count\n    FROM filtered_sets\n    GROUP BY strftime('%Y', releaseDate)\n),\ncommon_language AS (\n    SELECT \n        st.language,\n        COUNT(*) AS language_count\n    FROM set_translations st\n    JOIN filtered_sets fs ON st.setCode = fs.id\n    GROUP BY st.language\n    ORDER BY language_count DESC\n    LIMIT 1\n)\nSELECT \n    (SELECT AVG(set_count) FROM annual_average) AS annual_average_sets,\n    (SELECT language FROM common_language) AS common_language;",
        "error": "something went wrong, tool did not call.",
        "question": "What is the annual average number of sets that were released between 1/1/2012 to 12/31/2015? Indicate the common langugage of the card.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4, T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.id = T2.id WHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY T1.releaseDate ORDER BY COUNT(T2.language) DESC LIMIT 1",
        "explain": "AVG(id); releaseDate BETWEEN 1/1/2012 AND 12/31/2015; the common language refers to MAX(COUNT(language))",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Filtering Sets by Release Date**: The database filters the `sets` table (referred to as `T1`) to include only those sets whose `releaseDate` falls between January 1, 2012, and December 31, 2015.\n\n2. **Joining with Set Translations**: The filtered sets are then joined with the `set_translations` table (referred to as `T2`) using the `id` column to link each set with its translations.\n\n3. **Calculating the Annual Average**: For each set, the sum of the `id` values is calculated and cast to a real number. This sum is then divided by the count of `id` values to get an average per set. The result is further divided by 4 to compute the annual average over the 4-year period.\n\n4. **Grouping by Release Date**: The results are grouped by the `releaseDate` to organize the data by the date of release.\n\n5. **Determining the Common Language**: For each group, the count of languages (`language` column in `T2`) is calculated. The results are ordered in descending order based on this count to identify the most common language.\n\n6. **Limiting the Result**: The query returns only the top result, which includes the annual average number of sets and the most common language of the cards for the specified period.",
            "To solve the question, the following operations are performed on the database:\n\n1. **Filtering Sets by Release Date**: The database filters the `sets` table (referred to as `T1`) to include only those sets whose `releaseDate` falls between January 1, 2012, and December 31, 2015.\n\n2. **Joining with Set Translations**: The filtered sets are then joined with the `set_translations` table (referred to as `T2`) using the `id` column to link each set with its translations.\n\n3. **Calculating the Annual Average**: For each set, the sum of the `id` values is calculated and cast to a real number. This sum is then divided by the count of `id` values to get an average per set. The result is further divided by 4 to compute the annual average over the 4-year period.\n\n4. **Grouping by Release Date**: The results are grouped by the `releaseDate` to organize the data by the date of release.\n\n5. **Determining the Common Language**: For each group, the count of languages (`language` column in `T2`) is calculated. The results are ordered in descending order based on this count to identify the most common language.\n\n6. **Limiting the Result**: The query returns only the top result, which includes the annual average number of sets and the most common language of the cards for the specified period."
        ]
    },
    "1453": {
        "sql": "SELECT T1.event_name\nFROM event T1\nJOIN budget T2 ON T1.event_id = T2.link_to_event\nJOIN expense T3 ON T2.budget_id = T3.link_to_budget\nWHERE T2.category = 'Parking'\nAND T3.cost < (SELECT AVG(cost) FROM expense);",
        "question": "List the name of events with less than average parking cost.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T2.category = 'Parking' AND T3.cost < (SELECT AVG(cost) FROM expense)",
        "explain": "name of events refers to event_name; less than average parking cost refers to cost < DIVIDE(SUM(cost), COUNT(event_id)) where category = 'Parking'",
        "solution": [
            "To solve the question \"List the name of events with less than average parking cost,\" the following steps are performed:\n\n1. **Join the Tables**: Combine the `event`, `budget`, and `expense` tables. The `event` table is linked to the `budget` table using the `event_id` and `link_to_event` fields. The `budget` table is then linked to the `expense` table using the `budget_id` and `link_to_budget` fields.\n\n2. **Filter for Parking Expenses**: From the joined tables, filter the records where the `category` in the `budget` table is 'Parking'.\n\n3. **Calculate the Average Parking Cost**: Compute the average cost of all parking expenses from the `expense` table.\n\n4. **Compare Costs**: Select only those records where the `cost` in the `expense` table is less than the calculated average parking cost.\n\n5. **Retrieve Event Names**: Finally, extract the `event_name` from the filtered records to list the names of events with parking costs below the average.\n\nThis process ensures that only events with parking costs less than the average are listed, as specified in the question.",
            "To solve the question \"List the name of events with less than average parking cost,\" the following detailed steps are performed:\n\n1. **Join the Tables**: The `event` table (aliased as `T1`) is joined with the `budget` table (aliased as `T2`) using the condition `T1.event_id = T2.link_to_event`. This links each event to its corresponding budget entries.\n\n2. **Further Join with Expense Table**: The result from the first join is then joined with the `expense` table (aliased as `T3`) using the condition `T2.budget_id = T3.link_to_budget`. This links each budget entry to its corresponding expenses.\n\n3. **Filter for Parking Expenses**: From the joined tables, filter the records where the `category` field in the `budget` table (`T2.category`) is 'Parking'. This ensures only parking-related expenses are considered.\n\n4. **Calculate the Average Parking Cost**: Compute the average cost of all parking expenses by executing a subquery: `(SELECT AVG(cost) FROM expense)`. This subquery calculates the average cost across all entries in the `expense` table.\n\n5. **Compare Costs**: Select only those records where the `cost` field in the `expense` table (`T3.cost`) is less than the calculated average parking cost from the subquery.\n\n6. **Retrieve Event Names**: Finally, extract the `event_name` field from the `event` table (`T1.event_name`) for the filtered records. This provides the names of events where the parking cost is below the average.\n\nThis process ensures that the output is a list of event names with parking costs less than the average, as specified in the question."
        ]
    },
    "1506": {
        "sql": "SELECT p.Description\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nJOIN products p ON t.ProductID = p.ProductID\nWHERE g.Country = 'CZE';",
        "question": "Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.Description FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Country = 'CZE'",
        "explain": "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; ",
        "solution": []
    },
    "295": {
        "sql": "SELECT COUNT(*) \nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'h' AND m.label = '+';",
        "question": "How many atoms belong to the molecule that element is hydrogen and labeled with carcinogenic compound?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.atom_id) AS atomnums_h FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'h'",
        "explain": "label = '+' mean molecules are carcinogenic; hydrogen refers to element = h'",
        "solution": []
    },
    "1153": {
        "sql": "SELECT p.Diagnosis AS Disease, l.Date AS LaboratoryTestDate\nFROM Patient p\nLEFT JOIN Laboratory l ON p.ID = l.ID\nWHERE p.ID = 30609\nUNION\nSELECT e.Diagnosis AS Disease, l.Date AS LaboratoryTestDate\nFROM Examination e\nLEFT JOIN Laboratory l ON e.ID = l.ID\nWHERE e.ID = 30609;",
        "question": "What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis, T2.Date FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 30609",
        "explain": "'30609' is the Patient ID; disease means Diagnosis",
        "solution": []
    },
    "472": {
        "sql": "SELECT COUNT(DISTINCT s.code) AS italian_translated_sets_count\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE s.block = 'Ice Age' AND st.language = 'Italian' AND st.translation IS NOT NULL;",
        "question": "Among the sets in the block \"Ice Age\", how many of them have an Italian translation?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block = 'Ice Age' AND T2.language = 'Italian' AND T2.translation IS NOT NULL",
        "explain": "sets in the block \"Ice Age\" refers to block = 'Ice Age'; Italian translation refers to language = 'Italian' and translation is not null",
        "solution": []
    },
    "537": {
        "sql": "SELECT COUNT(*) AS post_count\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');",
        "question": "How many posts does the user csgillespie own?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "explain": "\"csgillespie\" is the DisplayName of user",
        "solution": []
    },
    "952": {
        "sql": "SELECT DISTINCT T2.name FROM results T1 JOIN constructors T2 ON T1.constructorId = T2.constructorId WHERE T1.rank = 1;",
        "question": "Which constructors have been ranked 1?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.rank = 1",
        "explain": "",
        "solution": [
            "To find out which constructors have been ranked 1, follow these steps:\n\n1. **Identify the tables involved**: The query uses two tables, `results` (referred to as `T1`) and `constructors` (referred to as `T2`).\n\n2. **Join the tables**: The query joins the `results` table (`T1`) with the `constructors` table (`T2`) using the `constructorId` field. This links each result to its corresponding constructor.\n\n3. **Filter the results**: The query filters the joined data to only include rows where the `rank` field in the `results` table (`T1`) is equal to 1. This ensures only results with a rank of 1 are considered.\n\n4. **Select distinct constructor names**: The query then selects the `name` field from the `constructors` table (`T2`), ensuring that each constructor name is listed only once (using `DISTINCT`), even if they have multiple results ranked 1.\n\n5. **Output the result**: The final output is a list of unique constructor names that have achieved a rank of 1 in the results."
        ]
    },
    "1512": {
        "sql": "SELECT CustomerID, SUM(Price) AS TotalPayment FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY TotalPayment DESC LIMIT 1;",
        "question": "Which customer paid the most in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "explain": "'2012/8/25' can be represented by '2012-08-25'",
        "solution": [
            "To determine which customer paid the most on August 25, 2012, follow these steps:\n\n1. **Filter Transactions by Date**: Select all transactions from the `transactions_1k` table where the `Date` is exactly '2012-08-25'.\n\n2. **Group by Customer**: Group these filtered transactions by the `CustomerID` to aggregate the data for each customer.\n\n3. **Calculate Total Payment**: For each customer, calculate the sum of the `Price` column to determine the total amount paid by that customer on the specified date.\n\n4. **Sort by Total Payment**: Sort the grouped results in descending order based on the total payment (sum of `Price`) to identify the customer who paid the highest amount.\n\n5. **Retrieve the Top Customer**: Limit the results to only the top customer (the one with the highest total payment) by using `LIMIT 1`.\n\n6. **Return the CustomerID**: Finally, return the `CustomerID` of this top-paying customer.\n\nThis process ensures that the customer who paid the most on August 25, 2012, is accurately identified.",
            "To determine which customer paid the most on August 25, 2012, follow these detailed steps:\n\n1. **Filter Transactions by Date**: Query the `transactions_1k` table to select all records where the `Date` column matches the exact date '2012-08-25'.\n\n2. **Group by Customer**: Group the filtered transactions by the `CustomerID` column to organize the data by each unique customer.\n\n3. **Calculate Total Payment**: For each group of transactions belonging to a customer, compute the sum of the `Price` column to determine the total amount paid by that customer on the specified date.\n\n4. **Sort by Total Payment**: Arrange the grouped results in descending order based on the calculated total payment (sum of `Price`) to prioritize customers who paid the highest amounts.\n\n5. **Retrieve the Top Customer**: Use the `LIMIT 1` clause to select only the top record from the sorted list, which corresponds to the customer with the highest total payment.\n\n6. **Return the CustomerID**: Output the `CustomerID` of the top-paying customer identified in the previous step.\n\nThis method ensures that the customer who paid the most on August 25, 2012, is accurately and efficiently identified."
        ]
    },
    "1105": {
        "sql": "SELECT t2.attacking_work_rate\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Francesco Migliore'\nAND t2.date LIKE '2015-05-01%';",
        "question": "How was Francesco Migliore's attacking work rate on 2015/5/1?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.`date` LIKE '2015-05-01%' AND t1.player_name = 'Francesco Migliore'",
        "explain": "Francesco Migliore refers to player_name = 'Francesco Migliore'; on 2015/5/1 refers to date LIKE '2015-05-01%';",
        "solution": [
            "To determine Francesco Migliore's attacking work rate on May 1, 2015, follow these steps:\n\n1. **Identify the Player**: Locate the player named \"Francesco Migliore\" in the `Player` table.\n2. **Retrieve Player Attributes**: Use the `player_api_id` from the `Player` table to find the corresponding entry in the `Player_Attributes` table.\n3. **Filter by Date**: Narrow down the search in the `Player_Attributes` table to only include records where the `date` field matches \"2015-05-01\".\n4. **Extract Attacking Work Rate**: From the filtered records, select the value in the `attacking_work_rate` column.\n\nThis process ensures you retrieve the exact attacking work rate of Francesco Migliore on the specified date.",
            "To determine Francesco Migliore's attacking work rate on May 1, 2015, follow these detailed steps:\n\n1. **Join Tables**: Combine the `Player` table (aliased as `t1`) and the `Player_Attributes` table (aliased as `t2`) using an inner join. The join condition is that the `player_api_id` in the `Player` table matches the `player_api_id` in the `Player_Attributes` table.\n\n2. **Filter by Player Name**: From the joined tables, filter the records to include only those where the `player_name` in the `Player` table is exactly \"Francesco Migliore\".\n\n3. **Filter by Date**: Further narrow down the records to only those where the `date` field in the `Player_Attributes` table starts with \"2015-05-01\". This ensures the date is May 1, 2015.\n\n4. **Select the Required Attribute**: From the filtered records, select the value in the `attacking_work_rate` column from the `Player_Attributes` table.\n\nThis process ensures you accurately retrieve Francesco Migliore's attacking work rate on the specified date."
        ]
    },
    "1522": {
        "sql": "SELECT c.Currency\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201306' AND ym.Consumption = 214582.17;",
        "question": "There's one customer spent 214582.17 in the June of 2013, which currency did he/she use?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Currency FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '201306' AND T1.Consumption = 214582.17",
        "explain": "June of 2013 means Date contains '201306' in the yearmonth.date of the database",
        "solution": []
    },
    "233": {
        "sql": "SELECT DISTINCT T2.bond_id\nFROM atom T1\nJOIN connected T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2\nWHERE T1.molecule_id = 'TR006'\nORDER BY T2.bond_id ASC\nLIMIT 2;",
        "question": "Please list top two bonds that happened with the molecule TR006 in alphabetical order.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.molecule_id = 'TR006' ORDER BY T2.bond_id LIMIT 2",
        "explain": "TR006 is the molecule id",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter Atoms**: Identify all atoms in the molecule with the ID 'TR006' from the `atom` table (referred to as T1).\n\n2. **Join with Connections**: Join the filtered atoms with the `connected` table (referred to as T2) using the `atom_id` field to find all bonds associated with these atoms.\n\n3. **Select Distinct Bonds**: Retrieve only the unique bond IDs from the joined result to avoid duplicates.\n\n4. **Order Alphabetically**: Sort the distinct bond IDs in alphabetical order.\n\n5. **Limit Results**: Return only the top two bond IDs from the sorted list.\n\nThe final output is a list of the top two bond IDs associated with the molecule 'TR006', ordered alphabetically."
        ]
    },
    "1514": {
        "sql": "SELECT c.Currency\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-24' AND t.Time = '16:25:00';",
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "explain": "'2012/8/24' can be represented by '2012-08-24'; ",
        "solution": []
    },
    "831": {
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.superhero_name = 'Abomination';",
        "question": "What is Abomination's eye colour?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Abomination'",
        "explain": "Abomination refers to superhero_name = 'Abomination'; eye colour refers to colour.colour where eye_colour_id = colour.id;",
        "solution": []
    },
    "913": {
        "sql": "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1;",
        "question": "In which country can I find the circuit with the highest altitude?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1",
        "explain": "highest altitude refers to max(alt)",
        "solution": []
    },
    "315": {
        "sql": "SELECT DISTINCT m.molecule_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'cl' AND m.label = '+';",
        "question": "Among the molecules which contain \"cl\" element, which of them are carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'cl' AND T2.label = '+'",
        "explain": "label = '+' mean molecules are carcinogenic;",
        "solution": [
            "To solve the question, we need to identify molecules that contain the element \"cl\" (chlorine) and are also labeled as carcinogenic (indicated by the label '+'). The solution involves the following steps:\n\n1. **Filter atoms by element**: First, select all atoms where the element is \"cl\". This ensures we only consider molecules containing chlorine.\n\n2. **Join with molecules**: Next, join these atoms with the molecules table using the molecule_id to get additional information about the molecules, such as their labels.\n\n3. **Filter carcinogenic molecules**: From the joined result, filter out molecules that have the label '+', which indicates they are carcinogenic.\n\n4. **Remove duplicates**: Finally, ensure that each molecule is listed only once by using DISTINCT on the molecule_id.\n\nThe SQL query accomplishes this by combining these steps into a single query that retrieves the distinct molecule_ids of carcinogenic molecules containing chlorine."
        ]
    },
    "1343": {
        "sql": "SELECT remaining FROM budget WHERE category = 'Food' ORDER BY amount DESC LIMIT 1;",
        "question": "With the biggest budget for the \"Food\", what was the remaining of it?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT remaining FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget WHERE category = 'Food' )",
        "explain": "remaining of budget refers to remaining, biggest budget for 'Food' refers to MAX(budget.amount) where category = 'Food'",
        "solution": []
    },
    "128": {
        "sql": "SELECT d.A2 AS district_name, COUNT(c.client_id) AS female_account_holders\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.gender = 'F'\nGROUP BY d.district_id, d.A2\nORDER BY female_account_holders DESC\nLIMIT 9;",
        "question": "List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 9",
        "explain": "A2 refers to districts; Female refers to gender = 'F'",
        "solution": [
            "To solve the question of listing the top nine districts with the highest number of female account holders in descending order, follow these steps:\n\n1. **Join the Tables**: Combine the `client` table (referred to as `T1`) with the `district` table (referred to as `T2`) using the `district_id` field. This links each client to their respective district.\n\n2. **Filter Female Clients**: From the joined data, filter out only those records where the `gender` field in the `client` table is 'F' (female).\n\n3. **Group by District**: Group the filtered records by the `district_id` and `A2` fields from the `district` table. This ensures that the count of female clients is calculated for each unique district.\n\n4. **Count Female Clients**: For each district, count the number of female clients (using the `client_id` field from the `client` table).\n\n5. **Order by Count**: Sort the results in descending order based on the count of female clients, so the districts with the highest numbers appear first.\n\n6. **Limit Results**: Return only the top nine districts from the sorted list.\n\nThe final output will display the district name (`A2` from the `district` table) and the corresponding count of female clients for each of the top nine districts."
        ]
    },
    "1439": {
        "sql": "SELECT m.phone\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' AND maj.college = 'College of Agriculture and Applied Sciences';",
        "question": "Please list the phone numbers of the members who majored in business at the College of Agriculture and Applied Sciences.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T2.major_name = 'Business' AND T2.college = 'College of Agriculture and Applied Sciences'",
        "explain": "'College of Agriculture and Applied Sciences' is the college; majored in business refers to major_name = 'Business'; phone numbers refers to phone",
        "solution": []
    },
    "1071": {
        "sql": "SELECT t.team_short_name \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE ta.buildUpPlaySpeed = 31 \nAND ta.buildUpPlayDribbling = 53 \nAND ta.buildUpPlayPassing = 32;",
        "question": "List the football team that has a build up play speed of 31, build up plan dribbling of 53, and build up play passing of 32. Only indicate the short name of the team.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeed = 31 AND t2.buildUpPlayDribbling = 53 AND t2.buildUpPlayPassing = 32",
        "explain": "build up play speed refers to buildUpPlaySpeed; buildUpPlaySpeed = 31; build up play dribbling refers to buildUpPlayDribbling; buildUpPlayDribbling = 53; build up play passing refers to buildUpPlayPassing; buildUpPlayPassing = 32; short name of the team refers to team_short_name;",
        "solution": []
    },
    "1231": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' \nAND strftime('%Y', P.Birthday) BETWEEN '1936' AND '1956'\nAND L.CPK >= 250;",
        "question": "For patient born between 1936-1956, how many male patients have creatinine phosphokinase beyond the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' AND T1.SEX = 'M' AND T2.CPK >= 250",
        "explain": "born between 1936-1956 refers to year(Birthday) BETWEEN '1936' AND '1956'; male patients refers to sex = 'M'; creatinine phosphokinase beyond the normal range refers to CPK > = 250; Should consider DISTINCT in the final result;",
        "solution": []
    },
    "971": {
        "sql": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY dob ASC LIMIT 1;",
        "question": "Please state the reference name of the oldest German driver.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1",
        "explain": "oldest refers to MIN(year(dob)); reference names appear in drverRef.",
        "solution": []
    },
    "558": {
        "sql": "SELECT COUNT(*) AS vote_count FROM votes WHERE UserId = 58 AND DATE(CreationDate) = '2010-07-19';",
        "question": "How many votes did the user No.58 take on 2010/7/19?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19'",
        "explain": "user no. 58 refers to UserId = 58; on 2010/7/19 refers to CreationDate = '2010-07-19'",
        "solution": []
    },
    "1165": {
        "sql": "SELECT MAX(strftime('%Y', Birthday)) - MIN(strftime('%Y', Birthday)) AS age_gap\nFROM Patient\nWHERE ID IN (SELECT DISTINCT ID FROM Laboratory WHERE TG >= 200);",
        "question": "What is the age gap between the youngest and oldest patient with a normal triglyceride recorded?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', MAX(T1.Birthday)) - STRFTIME('%Y', MIN(T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200",
        "explain": "age gap refers to SUBTRACT(MAX(year(Birthday)) - MIN(year(Birthday))); normal triglyceride refers to tg > = 200",
        "solution": []
    },
    "756": {
        "sql": "SELECT COUNT(*) AS bad_superheroes_count\nFROM superhero\nWHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'Bad');",
        "question": "How many bad superheroes are there?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Bad'",
        "explain": "bad superheroes refers to alignment_id = Bad",
        "solution": []
    },
    "903": {
        "sql": "SELECT SUM(ds.wins) AS total_wins\nFROM drivers d\nJOIN driverStandings ds ON d.driverId = ds.driverId\nJOIN races r ON ds.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher'\nAND c.name = 'Sepang International Circuit';",
        "question": "How many times did Michael Schumacher won from races hosted in Sepang International Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.wins) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId INNER JOIN circuits AS T4 ON T4.circuitId = T3.circuitId WHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher' AND T4.name = 'Sepang International Circuit'",
        "explain": "win from races refers to max(points)",
        "solution": [
            "To determine how many times Michael Schumacher won races hosted at the Sepang International Circuit, follow these steps:\n\n1. **Identify Michael Schumacher in the drivers table**: Locate the record for Michael Schumacher by filtering the `drivers` table where the `forename` is 'Michael' and the `surname` is 'Schumacher'.\n\n2. **Join with the driver standings table**: Link the identified driver record with the `driverStandings` table using the `driverId` to find all races where Michael Schumacher participated.\n\n3. **Join with the races table**: Further join the results with the `races` table using the `raceId` to get details about each race, including the circuit where it was hosted.\n\n4. **Filter races hosted at Sepang International Circuit**: From the joined data, filter the races to include only those hosted at the 'Sepang International Circuit' by checking the `name` field in the `circuits` table.\n\n5. **Sum the wins**: Finally, sum the `wins` column from the `driverStandings` table for the filtered races to get the total number of wins Michael Schumacher achieved at the Sepang International Circuit."
        ]
    },
    "282": {
        "sql": "SELECT \n    (SUM(CASE WHEN a.element = 'h' THEN 1 ELSE 0 END) * 1.0 / COUNT(a.element)) AS ratio,\n    m.label\nFROM \n    atom a\nJOIN \n    molecule m ON a.molecule_id = m.molecule_id\nWHERE \n    a.molecule_id = 'TR006'\nGROUP BY \n    m.label;",
        "question": "What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label",
        "explain": "hydrogen refers to element = 'h'; ratio = DIVIDE(SUM(element = 'h'), count(element)) where molecule_id = 'TR006' ; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "698": {
        "sql": "WITH target_post AS (\n    SELECT Id FROM posts WHERE Title = 'Clustering 1D data'\n)\nSELECT \n    (SELECT COUNT(*) FROM comments WHERE PostId = (SELECT Id FROM target_post)) AS comment_count,\n    (SELECT COUNT(*) FROM posts WHERE ParentId = (SELECT Id FROM target_post)) AS answer_count;",
        "question": "How many comments and answers were left by the users on the post with the title 'Clustering 1D data'?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CommentCount, AnswerCount FROM posts WHERE Title = 'Clustering 1D data'",
        "explain": "",
        "solution": []
    },
    "26": {
        "sql": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Monterey'\nAND T1.`School Type` = 'High Schools (Public)'\nAND T1.`Free Meal Count (Ages 5-17)` > 800;",
        "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
        "explain": "Full communication address should include Street, City, State and zip code if any.",
        "solution": [
            "1. **Joining the enrollment and school data:**  \n   The query uses an `INNER JOIN` between two tables: `frpm` (aliased as T1) and `schools` (aliased as T2). These tables are linked using the `CDSCode` column, ensuring that each record in the enrollment data is matched with its corresponding school record.\n\n2. **Selecting the school name and communication address:**  \n   From the `schools` table (T2), the query selects the columns `Street`, `City`, `State`, and `Zip` to provide the full communication address. From the `frpm` table (T1), it selects the `School Name` column to identify the high schools.\n\n3. **Filtering for Monterey County and high schools:**  \n   The query includes a `WHERE` clause to filter records where the `County` column in the `schools` table (T2) is 'Monterey'. Additionally, it filters for schools where the `School Type` column in the `frpm` table (T1) is 'High Schools (Public)'.\n\n4. **Filtering for high enrollment in free or reduced-price meals:**  \n   The query further filters the results to include only schools where the `Free Meal Count (Ages 5-17)` column in the `frpm` table (T1) exceeds 800. This ensures that only high schools with a significant number of students receiving free or reduced-price meals are included.\n\n5. **Outputting the results:**  \n   The final output includes the names of the high schools and their full communication addresses (street, city, state, and ZIP code) for the filtered records."
        ]
    },
    "1112": {
        "sql": "SELECT ta.chanceCreationCrossingClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'Hull City' \nAND ta.date = '2010-02-22 00:00:00';",
        "question": "What was the chance creation crossing class for \"Hull City\" on 2010/2/22?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.chanceCreationCrossingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hull City' AND SUBSTR(t2.`date`, 1, 10) = '2010-02-22'",
        "explain": "\"Hull City\" refers to team_long_name = 'Hull City'; on 2010/2/22 refers to date = '2010-02-22 00:00:00'",
        "solution": []
    },
    "392": {
        "sql": "SELECT DISTINCT c.name\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nWHERE c.rarity = 'uncommon'\nORDER BY r.date ASC\nLIMIT 3;",
        "question": "Pick 3 cards with rarity of uncommon, list down name these cards according to ascending order of it's ruling date.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3",
        "explain": "uncommon refers to rarity = 'uncommon';",
        "solution": [
            "To solve the question, follow these steps:\n1. **Select distinct card names**: Retrieve the names of the cards from the `cards` table, ensuring there are no duplicates.\n2. **Join with the `rulings` table**: Link the `cards` table with the `rulings` table using the `uuid` field to access the ruling dates for each card.\n3. **Filter by rarity**: Only include cards where the `rarity` field in the `cards` table is set to 'uncommon'.\n4. **Order by ruling date**: Sort the resulting cards in ascending order based on the `date` field from the `rulings` table.\n5. **Limit the results**: Return only the first 3 cards from the sorted list.\n\nThe final output will be a list of 3 distinct card names with 'uncommon' rarity, ordered by their ruling dates from oldest to newest."
        ]
    },
    "515": {
        "sql": "SELECT c.originalReleaseDate, l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic' AND c.originalReleaseDate IS NOT NULL AND l.status = 'Legal'\nORDER BY c.originalReleaseDate ASC\nLIMIT 1;",
        "question": "When was the oldest mythic card released and what are its legal play formats?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate LIMIT 1",
        "explain": "the oldest card refers to MIN(originalReleaseDate); mythic card refers to rarity = 'mythic'; legal play refers to status = 'legal'; play format refers to format",
        "solution": [
            "To find the oldest mythic card's release date and its legal play formats, follow these steps:\n\n1. **Filter the cards**: Select all cards from the `cards` table where the rarity is 'mythic' and the `originalReleaseDate` is not null.\n2. **Join with legalities**: Join the filtered cards with the `legalities` table using the `uuid` field to get the legal play formats for each card.\n3. **Filter legal formats**: Ensure only the legal formats (where `status` is 'Legal') are included.\n4. **Sort by release date**: Order the results by the `originalReleaseDate` in ascending order to find the oldest card.\n5. **Limit results**: Retrieve only the first result (the oldest card) from the sorted list.\n\nThe final output will include the `originalReleaseDate` of the oldest mythic card and its corresponding `format` where it is legally playable."
        ]
    },
    "1194": {
        "sql": "SELECT p.SEX\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nJOIN Laboratory l ON p.ID = l.ID\nWHERE e.Diagnosis = 'PSS'\nAND l.CRP = '2+'\nAND l.CRE = 1\nAND l.LDH = 123;",
        "question": "What sex is the patient who in a medical examination was diagnosed with PSS and in a laboratory examination had a blood level of C-reactive protein de 2+, createnine 1 and LDH 123?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T3.ID = T2.ID WHERE T2.Diagnosis = 'PSS' AND T3.CRP = '2+' AND T3.CRE = 1.0 AND T3.LDH = 123",
        "explain": "PSS' refers to diagnosis; blood level of C-reactive protein de 2+refers to CRP > 2; createnine 1 refers to CRE = 1; LDH 123 refers to LDH = 123",
        "solution": []
    },
    "1471": {
        "sql": "SELECT \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'EUR') * 1.0 / \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'CZK') AS ratio_EUR_to_CZK;",
        "question": "What is the ratio of customers who pay in EUR against customers who pay in CZK?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) AS ratio FROM customers",
        "explain": "ratio of customers who pay in EUR against customers who pay in CZK = count(Currency = 'EUR') / count(Currency = 'CZK').",
        "solution": []
    },
    "1494": {
        "sql": "SELECT (SUM(IIF(Segment = 'Premium', 1, 0)) * 100.0 / COUNT(GasStationID)) AS PercentagePremium\nFROM gasstations\nWHERE Country = 'SVK';",
        "question": "What percentage of Slovakian gas stations are premium?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / COUNT(GasStationID) FROM gasstations WHERE Country = 'SVK'",
        "explain": "Percentage of premium gas station = (Total of premium gas station in Slovakia / Total of gas station in Slovakia) * 100%.",
        "solution": [
            "To determine the percentage of Slovakian gas stations that are premium, follow these steps:\n\n1. **Filter the Data**: Select all gas stations located in Slovakia (Country = 'SVK').\n2. **Count Total Gas Stations**: Calculate the total number of gas stations in Slovakia.\n3. **Count Premium Gas Stations**: Count how many of these gas stations are classified as 'Premium'.\n4. **Calculate Percentage**: Divide the number of premium gas stations by the total number of gas stations and multiply by 100 to get the percentage.\n\nThe SQL query performs these operations by:\n- Using the `WHERE` clause to filter gas stations in Slovakia.\n- Using `COUNT(GasStationID)` to get the total number of gas stations.\n- Using `SUM(IIF(Segment = 'Premium', 1, 0))` to count premium gas stations (each 'Premium' segment adds 1, others add 0).\n- Casting the sum to a float and multiplying by 100 before dividing by the total count to compute the percentage."
        ]
    },
    "323": {
        "sql": "-- The schema does not provide any information about carcinogenicity, so the query cannot determine if molecule TR000 is carcinogenic.\n-- The following query retrieves the label of molecule TR000, but it does not confirm carcinogenicity.\nSELECT label FROM molecule WHERE molecule_id = 'TR000';",
        "question": "Is molecule TR000 is carcinogenic or not?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT label FROM molecule AS T WHERE T.molecule_id = 'TR000'",
        "explain": "label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "947": {
        "sql": "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) > '1980';",
        "question": "How many British drivers were born after 1980?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) > '1980'",
        "explain": "born after 1980 refers to year (dob) >1980;",
        "solution": []
    },
    "1110": {
        "sql": "SELECT ta.buildUpPlayPassingClass \nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE t.team_long_name = 'FC Lorient' AND ta.date LIKE '2010-02-22%';",
        "question": "Tell the build Up play passing class for \"FC Lorient\" on 2010/2/22.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'FC Lorient' AND t2.`date` LIKE '2010-02-22%'",
        "explain": "\"FC Lorient\" refers to team_long_name = 'FC Lorient'; on 2010/2/22 refers to date LIKE '2010-02-22%';",
        "solution": []
    },
    "1033": {
        "sql": "SELECT AVG(height) AS average_height\nFROM Player\nWHERE strftime('%Y', birthday) BETWEEN '1990' AND '1995';",
        "question": "What is the average height of players born between 1990 and 1995?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(height) / COUNT(id) FROM Player WHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'",
        "explain": "average height = DIVIDE(SUM(height), COUNT(id)); players born between 1990 and 1995 refers to birthday > = '1990-01-01 00:00:00' AND birthday < '1996-01-01 00:00:00';",
        "solution": []
    },
    "243": {
        "sql": "SELECT DISTINCT T2.bond_id\nFROM atom T1\nJOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'n'\nINTERSECT\nSELECT DISTINCT T3.bond_id\nFROM connected T3\nJOIN atom T4 ON T3.atom_id = T4.atom_id\nWHERE T4.element = 'p';",
        "question": "What are the bonds that have phosphorus and nitrogen as their atom elements?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id IN ( SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p' ) AND T1.element = 'n'",
        "explain": "have phosphorus as atom elements refers to element = 'p'; have nitrogen as atom elements refers to element = 'n'",
        "solution": [
            "To find the bonds that have both phosphorus (P) and nitrogen (N) as their atom elements, follow these steps:\n\n1. **Identify bonds with nitrogen (N) atoms**:\n   - Join the `atom` table (aliased as T1) with the `connected` table (aliased as T2) on the `atom_id` field.\n   - Filter the results to include only those rows where the element in the `atom` table (T1) is nitrogen (N).\n   - This gives a list of bond IDs (T2.bond_id) that are connected to nitrogen atoms.\n\n2. **Identify bonds with phosphorus (P) atoms**:\n   - Use a subquery to join the `connected` table (aliased as T3) with the `atom` table (aliased as T4) on the `atom_id` field.\n   - Filter the results to include only those rows where the element in the `atom` table (T4) is phosphorus (P).\n   - This gives a list of bond IDs (T3.bond_id) that are connected to phosphorus atoms.\n\n3. **Find bonds common to both lists**:\n   - Filter the list of bond IDs from step 1 (nitrogen-connected bonds) to include only those bond IDs that also appear in the list from step 2 (phosphorus-connected bonds).\n   - This ensures the bonds contain both nitrogen and phosphorus atoms.\n\n4. **Return the final list of bond IDs**:\n   - The result is a list of bond IDs that are connected to both nitrogen and phosphorus atoms.",
            "To find the bonds that have both phosphorus (P) and nitrogen (N) as their atom elements, follow these detailed steps:\n\n1. **Identify bonds connected to nitrogen (N) atoms**:\n   - Perform an inner join between the `atom` table (aliased as T1) and the `connected` table (aliased as T2) using the `atom_id` field as the join condition.\n   - Filter the results to include only rows where the `element` column in the `atom` table (T1) is 'n' (nitrogen).\n   - This operation yields a list of `bond_id` values (from T2) that are connected to nitrogen atoms.\n\n2. **Identify bonds connected to phosphorus (P) atoms**:\n   - Use a subquery to perform an inner join between the `connected` table (aliased as T3) and the `atom` table (aliased as T4) using the `atom_id` field as the join condition.\n   - Filter the results to include only rows where the `element` column in the `atom` table (T4) is 'p' (phosphorus).\n   - This operation yields a list of `bond_id` values (from T3) that are connected to phosphorus atoms.\n\n3. **Find bonds common to both nitrogen and phosphorus lists**:\n   - Filter the list of `bond_id` values obtained from step 1 (nitrogen-connected bonds) to include only those `bond_id` values that also appear in the list obtained from step 2 (phosphorus-connected bonds).\n   - This ensures that the bonds contain both nitrogen and phosphorus atoms.\n\n4. **Return the final list of bond IDs**:\n   - The result is a list of `bond_id` values from the `connected` table (T2) that are connected to both nitrogen and phosphorus atoms, as specified by the conditions in the SQL query."
        ]
    },
    "320": {
        "sql": "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR000_1' AND c.atom_id2 = 'TR000_2') OR (c.atom_id = 'TR000_2' AND c.atom_id2 = 'TR000_1');",
        "question": "What is the type of the bond which is presenting the connection between two atoms TR000_1 and TR000_2?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'",
        "explain": "type of bond refers to bond_type; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
        "solution": []
    },
    "207": {
        "sql": "SELECT DISTINCT T1.element FROM atom T1 JOIN bond T2 ON T1.molecule_id = T2.molecule_id JOIN connected T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '=';",
        "question": "What elements are in a double type bond?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
        "explain": "double type bond refers to bond_type = '=';",
        "solution": [
            "To find the elements involved in a double type bond, follow these steps:\n\n1. **Select distinct elements**: Retrieve unique elements from the `atom` table.\n\n2. **Join tables**:\n   - Join the `atom` table (aliased as T1) with the `bond` table (aliased as T2) using the `molecule_id` field to link atoms to their respective bonds.\n   - Further join the result with the `connected` table (aliased as T3) using the `atom_id` field to ensure the atoms are part of a bond.\n\n3. **Filter for double bonds**: Apply a condition to only include bonds where the `bond_type` is '=' (indicating a double bond).\n\n4. **Output the result**: The final output will be a list of distinct elements that participate in double bonds.",
            "To determine the elements involved in a double type bond, execute the following steps:\n\n1. **Identify the tables involved**: The query uses the `atom` table (aliased as T1), the `bond` table (aliased as T2), and the `connected` table (aliased as T3).\n\n2. **Join the tables**:\n   - First, join the `atom` table (T1) with the `bond` table (T2) using the `molecule_id` field. This links each atom to its corresponding bond in the same molecule.\n   - Next, join the result with the `connected` table (T3) using the `atom_id` field. This ensures that the atoms are part of a bond as recorded in the `connected` table.\n\n3. **Filter for double bonds**: Apply a condition to the `bond` table (T2) to only include rows where the `bond_type` is '=', which signifies a double bond.\n\n4. **Retrieve distinct elements**: From the filtered results, select the `element` column from the `atom` table (T1) and ensure the results are distinct to avoid duplicates.\n\n5. **Output the result**: The final output is a list of unique elements that participate in double bonds, derived from the `atom` table."
        ]
    },
    "615": {
        "sql": "SELECT \n    (COUNT(CASE WHEN u.Age BETWEEN 13 AND 19 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_teenagers\nFROM \n    badges b\nJOIN \n    users u ON b.UserId = u.Id\nWHERE \n    b.Name = 'Organizer';",
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "explain": "\"Organizer\" is the Name of badge; teenager refers to Age BETWEEN 13 AND 18; percentage = Divide (Count(UserId where Age BETWEEN 13 AND 18), Count(UserId)) *100",
        "solution": []
    },
    "1360": {
        "sql": "SELECT \n    (b1.amount * 100.0 / SUM(b2.amount)) AS percentage\nFROM \n    event e\nJOIN \n    budget b1 ON e.event_id = b1.link_to_event\nJOIN \n    budget b2 ON e.event_id = b2.link_to_event\nWHERE \n    e.event_name = 'November Speaker' AND b1.category = 'Parking'\nGROUP BY \n    b1.amount;",
        "question": "What percentage was the budget for Parking to the total budget for the \"November Speaker\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Speaker'",
        "explain": "DIVDE(SUM( amount where category = 'Parking' and event_name = 'November Speaker'), COUNT(event_name = 'November Speaker)) * 100",
        "solution": []
    },
    "1481": {
        "sql": "WITH CZK_Customers AS (\n    SELECT CustomerID, Segment\n    FROM customers\n    WHERE Currency = 'CZK'\n),\nMin_Consumption AS (\n    SELECT MIN(Consumption) AS MinConsumption\n    FROM yearmonth\n    WHERE Date BETWEEN '201301' AND '201312'\n),\nFiltered_YearMonth AS (\n    SELECT y.CustomerID, y.Consumption, c.Segment\n    FROM yearmonth y\n    JOIN CZK_Customers c ON y.CustomerID = c.CustomerID\n    WHERE y.Date BETWEEN '201301' AND '201312'\n    AND y.Consumption = (SELECT MinConsumption FROM Min_Consumption)\n),\nSegment_Averages AS (\n    SELECT Segment, AVG(Consumption) AS AvgConsumption\n    FROM Filtered_YearMonth\n    GROUP BY Segment\n)\nSELECT \n    (SELECT AvgConsumption FROM Segment_Averages WHERE Segment = 'SME') - \n    (SELECT AvgConsumption FROM Segment_Averages WHERE Segment = 'LAM') AS SME_LAM_Difference,\n    (SELECT AvgConsumption FROM Segment_Averages WHERE Segment = 'LAM') - \n    (SELECT AvgConsumption FROM Segment_Averages WHERE Segment = 'KAM') AS LAM_KAM_Difference,\n    (SELECT AvgConsumption FROM Segment_Averages WHERE Segment = 'KAM') - \n    (SELECT AvgConsumption FROM Segment_Averages WHERE Segment = 'SME') AS KAM_SME_Difference;",
        "error": "something went wrong, tool did not call.",
        "question": "What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(Consumption) FROM yearmonth ) AND T2.Date BETWEEN 201301 AND 201312",
        "explain": "annual average consumption of customer with the lowest consumption in each segment = total consumption per year / the number of customer with lowest consumption in each segment; Difference in annual average = SME's annual average - LAM's annual average; Difference in annual average = LAM's annual average - KAM's annual average; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year.",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Filtering Data**: \n   - Select customers whose currency is 'CZK'.\n   - Filter the year-month data for the year 2013 (dates between 201301 and 201312).\n   - Further filter to include only records where the consumption is the minimum consumption value in the dataset.\n\n2. **Joining Tables**: \n   - Join the `customers` table (T1) with the `yearmonth` table (T2) using the `CustomerID` field.\n\n3. **Calculating Averages**: \n   - For each segment (SME, LAM, KAM), calculate the average consumption by summing the consumption values for the segment and dividing by the total number of customers.\n\n4. **Computing Differences**: \n   - Calculate the difference in average consumption between SME and LAM.\n   - Calculate the difference in average consumption between LAM and KAM.\n   - Calculate the difference in average consumption between KAM and SME.\n\nThe final result will display these three differences as the answer to the question.",
            "To solve the question, the following operations are performed:\n\n1. **Filtering Data**: \n   - Select customers from the `customers` table (T1) where the currency is 'CZK'.\n   - Filter records from the `yearmonth` table (T2) for the year 2013 (dates between 201301 and 201312).\n   - Further filter to include only records where the consumption is the minimum consumption value in the `yearmonth` table.\n\n2. **Joining Tables**: \n   - Join the `customers` table (T1) with the `yearmonth` table (T2) using the `CustomerID` field.\n\n3. **Calculating Averages**: \n   - For each segment (SME, LAM, KAM), calculate the average consumption by summing the consumption values for the segment and dividing by the total number of customers in the filtered dataset.\n\n4. **Computing Differences**: \n   - Calculate the difference in average consumption between SME and LAM by subtracting the average consumption of LAM from the average consumption of SME.\n   - Calculate the difference in average consumption between LAM and KAM by subtracting the average consumption of KAM from the average consumption of LAM.\n   - Calculate the difference in average consumption between KAM and SME by subtracting the average consumption of SME from the average consumption of KAM.\n\nThe final result will display these three differences as the answer to the question."
        ]
    },
    "409": {
        "sql": "SELECT COUNT(DISTINCT c.id) \nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nJOIN rulings r ON c.uuid = r.uuid\nWHERE l.format = 'premodern' \nAND r.text = 'This is a triggered mana ability.' \nAND c.side IS NULL;",
        "question": "Indicates the number of cards with pre-modern format, ruling text \"This is a triggered mana ability.\" that do not have multiple faces.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN rulings AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'premodern' AND T3.text = 'This is a triggered mana ability.' AND T1.Side IS NULL",
        "explain": "pre-modern format refers to format = 'premodern' ;do not have multiple faces refers to side IS NULL",
        "solution": []
    },
    "272": {
        "sql": "SELECT DISTINCT m.molecule_id\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '-'\nAND b.bond_type = '#'\nAND a.element = 'c'\nLIMIT 2;",
        "question": "List down two molecule id of triple bond non carcinogenic molecules with element carbon.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element = 'c' AND T2.label = '-'",
        "explain": "carbon refers to element = 'c'; triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "1459": {
        "sql": "SELECT m.major_name, m.department\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Garrett' AND mb.last_name = 'Gerke';",
        "question": "What is the major of Garrett Gerke and which department does it belong to?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name, T2.department FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'",
        "explain": "major refers to major name;",
        "solution": []
    },
    "400": {
        "sql": "SELECT DISTINCT setCode \nFROM set_translations \nWHERE language = 'Spanish';",
        "question": "Lists the set code of all cards translated into Spanish.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT setCode FROM set_translations WHERE language = 'Spanish'",
        "explain": "Spanish refer to language; set code refers to setCode",
        "solution": []
    },
    "635": {
        "sql": "SELECT COUNT(DISTINCT T3.Id) \nFROM users T1 \nJOIN postHistory T2 ON T1.Id = T2.UserId \nJOIN posts T3 ON T2.PostId = T3.Id \nJOIN votes T4 ON T3.Id = T4.PostId \nWHERE T1.DisplayName = 'Matt Parker' \nGROUP BY T3.Id, T4.VoteTypeId \nHAVING COUNT(T4.Id) > 4",
        "question": "How many posts by Matt Parker have more than 4 votes?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id INNER JOIN votes AS T4 ON T4.PostId = T3.Id WHERE T1.DisplayName = 'Matt Parker' GROUP BY T2.PostId, T4.Id HAVING COUNT(T4.Id) > 4",
        "explain": "more than 4 votes refer to PostId > 4; DisplayName = 'Matt Parker';",
        "solution": [
            "To solve the question \"How many posts by Matt Parker have more than 4 votes?\", follow these steps:\n\n1. **Identify the User**: Locate the user with the display name \"Matt Parker\" in the `users` table.\n2. **Join User to Post History**: Link the user's ID to the `postHistory` table to find all posts associated with Matt Parker.\n3. **Link to Posts**: Connect the `postHistory` entries to the `posts` table to retrieve the details of the posts.\n4. **Join to Votes**: Link the posts to the `votes` table to gather all votes associated with each post.\n5. **Filter by Vote Count**: Group the results by the post ID and vote ID, then filter to include only those posts where the count of votes exceeds 4.\n6. **Count the Posts**: Finally, count the number of posts that meet the criteria (more than 4 votes).\n\nThe SQL query accomplishes this by:\n- Selecting the count of post IDs (`T1.Id`).\n- Joining the `users` table (`T1`) with `postHistory` (`T2`) on the user ID.\n- Joining `postHistory` (`T2`) with `posts` (`T3`) on the post ID.\n- Joining `posts` (`T3`) with `votes` (`T4`) on the post ID.\n- Filtering for the user \"Matt Parker\" and grouping by post and vote IDs.\n- Applying a `HAVING` clause to ensure the vote count is greater than 4."
        ]
    },
    "1218": {
        "sql": "SELECT (SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.ID)) AS percentage\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F';",
        "question": "What is the percentage of the female patient whose uric acid (UA) beyond the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F'",
        "explain": "uric acid (UA) beyond the normal range refers to UA > 8.0 and SEX = 'M' or UA > 6.5 and SEX = 'F'; female refers to Sex = 'F'",
        "solution": [
            "To solve the question \"What is the percentage of the female patient whose uric acid (UA) beyond the normal range?\", follow these steps:\n\n1. **Identify Female Patients**: Filter the `Patient` table to include only female patients (where `SEX = 'F'`).\n\n2. **Join with Laboratory Data**: Combine the filtered `Patient` table with the `Laboratory` table using the patient ID (`ID`) to access the uric acid (UA) values for each female patient.\n\n3. **Check UA Values**: For each female patient, check if their uric acid (UA) value exceeds the normal range (UA > 6.5).\n\n4. **Count Patients with High UA**: Count how many female patients have UA values beyond the normal range.\n\n5. **Calculate Percentage**: Divide the count of female patients with high UA by the total number of female patients, then multiply by 100 to get the percentage.\n\nThe SQL query performs these operations by:\n- Joining the `Patient` and `Laboratory` tables on the patient ID.\n- Filtering for female patients.\n- Counting the number of female patients with UA > 6.5.\n- Dividing this count by the total number of female patients and converting it to a percentage.",
            "To solve the question \"What is the percentage of the female patient whose uric acid (UA) beyond the normal range?\", follow these detailed steps:\n\n1. **Filter Female Patients**: Retrieve all records from the `Patient` table where the `SEX` column is 'F' (female).\n\n2. **Join with Laboratory Data**: Perform an inner join between the filtered `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) using the patient ID (`ID`) as the join key. This ensures that only patients with corresponding laboratory data are included.\n\n3. **Check UA Values**: For each female patient in the joined dataset, evaluate whether their uric acid (UA) value (from the `Laboratory` table) exceeds the normal range (UA > 6.5).\n\n4. **Count High UA Cases**: Use a `CASE` statement to count how many female patients have UA values greater than 6.5. The `CASE` statement assigns a value of 1 for each patient meeting this condition and 0 otherwise. The `SUM` function then aggregates these values.\n\n5. **Calculate Total Female Patients**: Count the total number of female patients in the joined dataset using the `COUNT` function on the `ID` column from the `Patient` table.\n\n6. **Compute Percentage**: Divide the count of female patients with high UA (from step 4) by the total number of female patients (from step 5). Multiply the result by 100 to convert it into a percentage. The `CAST` function ensures the division is performed as a real number to avoid integer division issues.\n\nThe SQL query encapsulates these steps by:\n- Joining the `Patient` and `Laboratory` tables on the patient ID.\n- Filtering for female patients.\n- Using a `CASE` statement to count high UA cases.\n- Calculating the percentage by dividing the count of high UA cases by the total female patients and scaling by 100."
        ]
    },
    "542": {
        "sql": "SELECT SUM(p.CommentCount) AS TotalComments\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';",
        "question": "What is the total number of comments of all the posts owned by csgillespie?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.CommentCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "explain": "\"csgillespie\" is the DisplayName of user; total number of comments refers to Sum(CommentCount)",
        "solution": []
    },
    "1124": {
        "sql": "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.attacking_work_rate = 'high';",
        "error": "something went wrong, tool did not call.",
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "explain": "tend to be attacking when their mates were doing attack moves refers to attacking_work_rate = 'high';",
        "solution": []
    },
    "466": {
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT setCode FROM set_translations WHERE translation = 'Hauptset Zehnte Edition') \nAND artist = 'Adam Rex';",
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "explain": "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; designed by Adam refers to artist = 'Adam Rex'",
        "solution": []
    },
    "644": {
        "sql": "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images';",
        "question": "Provide the last edit date and last edit user ID for the post \"Detecting a given face in a database of facial images\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images'",
        "explain": "Title = 'Detecting a given face in a database of facial images';",
        "solution": []
    },
    "439": {
        "sql": "SELECT name FROM sets WHERE code = 'ALL';",
        "question": "List out the set name of the set code \"ALL\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM sets WHERE code = 'ALL'",
        "explain": "",
        "solution": []
    },
    "1393": {
        "sql": "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary';",
        "question": "Provide the full name and email address of the Student_Club's Secretary.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'",
        "explain": "full name refers to first_name, last_name; 'Secretary' is a position of Student Club",
        "solution": [
            "To solve the question, retrieve the first name, last name, and email address of the member whose position is 'Secretary' in the Student_Club. This involves querying the 'member' table and filtering for records where the 'position' column equals 'Secretary'. The result will display the 'first_name', 'last_name', and 'email' fields for the identified member."
        ]
    },
    "980": {
        "sql": "SELECT d.driverRef, d.nationality, d.dob\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 23 AND q.q2 IS NOT NULL;",
        "question": "List the reference name of the drivers who passed the second qualifying lap during race no. 23. Indicate their nationality and birthday.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverRef, T2.nationality, T2.dob FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T1.raceId = 23 AND T1.q2 IS NOT NULL",
        "explain": "passed the second qualifying lap refers to q2 is not null; birthday refers to dob; reference name of drivers refers to driverRef; race no. refers to raceId;",
        "solution": []
    },
    "918": {
        "sql": "SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton';",
        "question": "What's Lewis Hamilton's reference name?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'",
        "explain": "reference name refers to driverRef",
        "solution": []
    },
    "780": {
        "sql": "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.full_name = 'Hunter Zolomon';",
        "question": "List the powers of Hunter Zolomon.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.full_name = 'Hunter Zolomon'",
        "explain": "Hunter Zolomon is the full name of superhero; list the powers refers to power_name;",
        "solution": []
    },
    "679": {
        "sql": "SELECT T1.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1",
        "question": "Which post has the highest score? Please give its id and title's name.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1",
        "explain": "the highest score refers to MAX(Score); owner's name refers to DisplayName;",
        "solution": [
            "To find the post with the highest score, follow these steps:\n1. **Join the tables**: Combine the `users` table (aliased as `T1`) and the `posts` table (aliased as `T2`) using an inner join. The join condition is that the `Id` column in the `users` table matches the `OwnerUserId` column in the `posts` table.\n2. **Sort the results**: Order the combined results by the `Score` column in the `posts` table in descending order to ensure the highest score appears first.\n3. **Limit the results**: Retrieve only the top result (the post with the highest score) by applying a limit of 1.\n4. **Select the columns**: From the result, select the `Id` column from the `users` table and the `Title` column from the `posts` table to display the post's ID and title.",
            "To find the post with the highest score, follow these detailed steps:\n\n1. **Join the tables**: Perform an inner join between the `users` table (aliased as `T1`) and the `posts` table (aliased as `T2`). The join condition is that the `Id` column in the `users` table (`T1.Id`) must match the `OwnerUserId` column in the `posts` table (`T2.OwnerUserId`). This ensures that only posts with valid user associations are considered.\n\n2. **Sort the results**: After joining the tables, sort the combined dataset by the `Score` column in the `posts` table (`T2.Score`) in descending order (`DESC`). This places the post with the highest score at the top of the result set.\n\n3. **Limit the results**: Apply a limit of 1 to the sorted results to retrieve only the top row, which corresponds to the post with the highest score.\n\n4. **Select the columns**: From the limited result set, select the `Id` column from the `users` table (`T1.Id`) and the `Title` column from the `posts` table (`T2.Title`). This provides the ID of the user who owns the post and the title of the post with the highest score.\n\nThe SQL query for this operation is:\n```sql\nSELECT T1.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1\n```"
        ]
    },
    "197": {
        "sql": "SELECT AVG(oxygen_count) AS average_oxygen_count\nFROM (\n    SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count\n    FROM atom T1\n    JOIN bond T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T1.element = 'o' AND T2.bond_type = '-'\n    GROUP BY T1.molecule_id\n) AS subquery;",
        "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
        "explain": "single-bonded molecules refers to bond_type = '-' ; average number of oxygen atom = AVG(element = 'o')",
        "solution": [
            "To calculate the average number of oxygen atoms in single-bonded molecules, follow these steps:\n\n1. **Filter Atoms and Bonds**: Identify all atoms and bonds in the database. Focus on atoms where the element is oxygen ('o') and bonds where the bond type is a single bond ('-').\n\n2. **Join Tables**: Combine the `atom` and `bond` tables using the `molecule_id` field to ensure that the atoms and bonds belong to the same molecule.\n\n3. **Count Oxygen Atoms per Molecule**: For each molecule, count the number of oxygen atoms that are part of single bonds. This is done by grouping the results by `molecule_id` and counting the occurrences of oxygen atoms in the filtered dataset.\n\n4. **Calculate the Average**: Finally, compute the average of the oxygen counts obtained in the previous step to determine the average number of oxygen atoms in single-bonded molecules.\n\nThe SQL query achieves this by:\n- Selecting the average of the oxygen counts from a subquery.\n- The subquery joins the `atom` and `bond` tables, filters for single-bonded oxygen atoms, groups by molecule, and counts the oxygen atoms per molecule.",
            "To calculate the average number of oxygen atoms in single-bonded molecules, the following detailed steps are performed:\n\n1. **Identify Relevant Tables**: The `atom` table (aliased as `T1`) and the `bond` table (aliased as `T2`) are used. These tables contain information about atoms and bonds in molecules, respectively.\n\n2. **Filter for Oxygen Atoms and Single Bonds**: The query filters the `atom` table to include only atoms where the element is oxygen (`T1.element = 'o'`). Simultaneously, the `bond` table is filtered to include only single bonds (`T2.bond_type = '-'`).\n\n3. **Join Tables on Molecule ID**: The `atom` and `bond` tables are joined using the `molecule_id` field (`T1.molecule_id = T2.molecule_id`). This ensures that the atoms and bonds being analyzed belong to the same molecule.\n\n4. **Group by Molecule and Count Oxygen Atoms**: The results are grouped by `molecule_id` (`GROUP BY T1.molecule_id`). For each molecule, the number of oxygen atoms that are part of single bonds is counted (`COUNT(T1.element) AS oxygen_count`).\n\n5. **Calculate the Average**: The outer query computes the average of the oxygen counts obtained from the subquery (`AVG(oxygen_count)`). This gives the average number of oxygen atoms in single-bonded molecules.\n\nThe SQL query achieves this by:\n- Using a subquery to join the `atom` and `bond` tables, filter for single-bonded oxygen atoms, group by molecule, and count the oxygen atoms per molecule.\n- The outer query then calculates the average of these counts."
        ]
    },
    "1187": {
        "sql": "SELECT DISTINCT ID\nFROM Laboratory\nWHERE Date BETWEEN '1987-07-06' AND '1996-01-31'\n  AND GPT > 30\n  AND ALB < 4;",
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "explain": "examined between 1987/7/6 and 1996/1/31 refers to Date BETWEEN '1987-07-06' AND '1996-01-31'; GPT level greater than 30 refers to GPT > 30; ALB level less than 4 ALB < 4",
        "solution": []
    },
    "746": {
        "sql": "SELECT AVG(attribute_value) AS average_attribute_value FROM hero_attribute;",
        "question": "Calculate the average attribute value of all superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(attribute_value) FROM hero_attribute",
        "explain": "average attribute value of all superheroes refers to AVG(attribute_value)",
        "solution": []
    },
    "1024": {
        "sql": "SELECT player_api_id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5",
        "question": "Who are the top 5 players who perform better in crossing actions? Indicate their player id.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5",
        "explain": "perform better in crossing actions refers to MAX(crossing)",
        "solution": [
            "To find the top 5 players who perform better in crossing actions and indicate their player IDs, follow these steps:\n\n1. **Access the Player_Attributes table**: This table contains the attributes of players, including their crossing performance.\n\n2. **Sort the players by crossing performance**: Arrange the players in descending order based on their crossing attribute. This ensures that the players with the highest crossing values appear first.\n\n3. **Limit the results to the top 5 players**: After sorting, select only the first 5 players from the list to get the top performers.\n\n4. **Retrieve the player IDs**: Extract the player IDs of these top 5 players to identify them.\n\nThe final output will be a list of 5 player IDs corresponding to the players with the best crossing performance.",
            "To determine the top 5 players who excel in crossing actions and identify their player IDs, execute the following steps:\n\n1. **Query the Player_Attributes Table**: This table stores detailed attributes of players, including their crossing performance metrics.\n\n2. **Sort Players by Crossing Attribute**: Arrange all players in descending order based on their crossing attribute values. This ensures that players with the highest crossing scores are listed first.\n\n3. **Select the Top 5 Players**: From the sorted list, extract only the top 5 players to focus on those with the best crossing performance.\n\n4. **Retrieve Player IDs**: For these top 5 players, specifically fetch their unique player IDs to clearly identify them.\n\nThe SQL query `SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5` precisely performs these operations, returning the player IDs of the top 5 performers in crossing actions."
        ]
    },
    "493": {
        "sql": "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized';",
        "question": "For the set \"Commander 2014 Oversized\" , give its parent code.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized'",
        "explain": "the set \"Commander 2014 Oversized\" refers to name = 'Commander 2014 Oversized';",
        "solution": []
    },
    "1030": {
        "sql": "SELECT l.name AS league_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nWHERE m.season = '2015/2016' AND m.home_team_goal = m.away_team_goal\nGROUP BY m.league_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
        "question": "Give the name of the league had the most matches end as draw in the 2016 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal GROUP BY t2.name ORDER BY COUNT(t1.id) DESC LIMIT 1",
        "explain": "most matches end as draw refers to MAX(SUM(home_team_goal = away_team_goal)); 2016 season refers to season = '2015/2016';",
        "solution": []
    },
    "200": {
        "sql": "SELECT DISTINCT T2.molecule_id\nFROM bond T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#' AND T2.label = '+';",
        "question": "Find the triple-bonded molecules which are carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'",
        "explain": "triple-bonded molecules refers to bond_type = '#'; carcinogenic refers to label = '+'",
        "solution": [
            "To find the triple-bonded molecules which are carcinogenic, follow these steps:\n\n1. **Join the Tables**: Combine the `bond` table (referred to as `T1`) and the `molecule` table (referred to as `T2`) by matching the `molecule_id` in both tables. This ensures that we are looking at the bonds associated with each molecule.\n\n2. **Filter for Triple Bonds**: From the joined tables, filter the records to include only those where the `bond_type` in the `bond` table (`T1`) is `'#'`, which represents a triple bond.\n\n3. **Filter for Carcinogenic Molecules**: Further filter the results to include only those molecules where the `label` in the `molecule` table (`T2`) is `'+'`, indicating that the molecule is carcinogenic.\n\n4. **Select Distinct Molecule IDs**: Finally, retrieve the distinct `molecule_id` values from the `molecule` table (`T2`) to ensure each molecule is listed only once in the results.\n\nThis process ensures that we identify all unique molecules that have at least one triple bond and are marked as carcinogenic."
        ]
    },
    "1531": {
        "sql": "SELECT T1.CustomerID, SUM(T2.Price / T2.Amount) AS AveragePricePerItem, T1.Currency\nFROM customers T1\nJOIN transactions_1k T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.CustomerID = (SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1)\nGROUP BY T1.CustomerID, T1.Currency;",
        "question": "Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.CustomerID, SUM(T2.Price / T2.Amount), T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.CustomerID = ( SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1 ) GROUP BY T2.CustomerID, T1.Currency",
        "explain": "average price per single item = Total(price) / Total(amount)",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Identify the top spending customer**:\n   - The subquery `(SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1)` retrieves the `CustomerID` of the customer with the highest consumption from the `yearmonth` table.\n\n2. **Retrieve customer details and transactions**:\n   - The main query joins the `customers` table (`T1`) with the `transactions_1k` table (`T2`) using the `CustomerID` as the join condition.\n   - It filters the transactions to only include those of the top spending customer identified in the subquery.\n\n3. **Calculate the average price per item**:\n   - For each transaction of the top spending customer, the query calculates the average price per item by dividing the `Price` by the `Amount` for each transaction.\n   - The `SUM` function aggregates these values to get the total average price per item across all transactions of the customer.\n\n4. **Group and display results**:\n   - The results are grouped by `CustomerID` and `Currency` to ensure the output is organized by these fields.\n   - The final output includes the `CustomerID`, the calculated average price per item, and the `Currency` used by the customer.\n\nThis solution ensures that the top spending customer is identified, their average price per item is calculated, and the currency used is displayed, all while maintaining the integrity of the original SQL query."
        ]
    },
    "1186": {
        "sql": "SELECT DISTINCT ID FROM Examination WHERE `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31' AND Diagnosis = 'Behcet';",
        "question": "Lists all patients by ID who were diagnosed with Behcet's and had their exams between 01/01/197 and 12/31/1997.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT ID FROM Examination WHERE `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31' AND Diagnosis = 'Behcet'",
        "explain": "'Behcet' refers to diagnosis; exam between 01/01/1997 and 12/31/1997 refers to YEAR(Description) > = '1997-1-1' AND YEAR(Description) < '1998-1-1'",
        "solution": [
            "To solve the question, the database performs the following operations:\n\n1. **Selects** the `ID` column from the `Examination` table.\n2. **Filters** the records to include only those where the `Examination Date` falls between January 1, 1997, and December 31, 1997.\n3. **Further filters** the records to include only those where the `Diagnosis` is 'Behcet'.\n4. **Returns** the list of patient IDs that meet both criteria."
        ]
    },
    "112": {
        "sql": "SELECT d.A2 AS district_name\nFROM client c\nJOIN disp dp ON c.client_id = dp.client_id\nJOIN account a ON dp.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE c.gender = 'F' AND c.birth_date = '1976-01-29';",
        "question": "For the female client who was born in 1976/1/29, which district did she opened her account?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.A2 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.birth_date = '1976-01-29' AND T2.gender = 'F'",
        "explain": "Female refers to gender = 'F'; A2 refers to district names",
        "solution": []
    },
    "1339": {
        "sql": "SELECT AVG(e.cost) AS average_cost\nFROM expense e\nJOIN member m ON e.link_to_member = m.member_id\nWHERE m.first_name = 'Elijah' AND m.last_name = 'Allen'\nAND (strftime('%m', e.expense_date) = '09' OR strftime('%m', e.expense_date) = '10');",
        "question": "Calculate the total average cost that Elijah Allen spent in the events on September and October.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.last_name = 'Allen' AND T1.first_name = 'Elijah' AND (SUBSTR(T2.expense_date, 6, 2) = '09' OR SUBSTR(T2.expense_date, 6, 2) = '10')",
        "explain": "Elijah Allen is the full name; full name refers to first_name, last_name; The 5th and 6th string of the expense_date in the expense table can refer to month; events in September and October refers to month(expense_date) = 9 OR month(expense_date) = 10",
        "solution": [
            "To calculate the total average cost that Elijah Allen spent in the events during September and October, follow these steps:\n\n1. **Identify the member**: Locate the member with the first name 'Elijah' and last name 'Allen' in the 'member' table.\n2. **Link to expenses**: Using the member's ID, find all expenses linked to this member in the 'expense' table.\n3. **Filter by date**: From these expenses, filter out only those that occurred in September (month '09') or October (month '10'). This is done by checking the month part of the 'expense_date' field.\n4. **Calculate the average**: Compute the average cost of the filtered expenses.\n\nThe result will be the average cost of all expenses made by Elijah Allen during September and October."
        ]
    },
    "183": {
        "sql": "SELECT COUNT(*) AS account_count\nFROM account\nJOIN district ON account.district_id = district.district_id\nWHERE district.A2 = 'Beroun' AND strftime('%Y', account.date) > '1996';",
        "question": "How many accounts in Beroun were opened after 1996?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) > '1996' AND T2.A2 = 'Beroun'",
        "explain": "",
        "solution": []
    },
    "1041": {
        "sql": "WITH NormalTeams2014 AS (\n    SELECT t4.team_api_id, t4.chanceCreationPassing\n    FROM Team_Attributes t4\n    JOIN Team t3 ON t4.team_api_id = t3.team_api_id\n    WHERE t4.buildUpPlayDribblingClass = 'Normal'\n    AND SUBSTR(t4.date, 1, 4) = '2014'\n),\nAverageChanceCreation AS (\n    SELECT AVG(chanceCreationPassing) AS avg_chance_creation\n    FROM Team_Attributes t2\n    JOIN Team t1 ON t2.team_api_id = t1.team_api_id\n    WHERE t2.buildUpPlayDribblingClass = 'Normal'\n    AND SUBSTR(t2.date, 1, 4) = '2014'\n)\nSELECT t3.team_long_name\nFROM NormalTeams2014 nt\nJOIN Team t3 ON nt.team_api_id = t3.team_api_id\nJOIN AverageChanceCreation acc ON 1=1\nWHERE nt.chanceCreationPassing < acc.avg_chance_creation\nORDER BY nt.chanceCreationPassing DESC;",
        "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
        "explain": "normal build-up play dribbling class refers to buildUpPlayDribblingClass = 'Normal'; in 2014 refers to date > = '2014-01-01 00:00:00' AND date < = '2014-01-31 00:00:00'; names of the teams refers to team_long_name; less than average chance creation passing = DIVIDE(SUM(chanceCreationPassing), COUNT(id)) > chanceCreationPassing;",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Identify Teams with Normal Build-Up Play Dribbling Class in 2014**:\n   - Filter the `Team_Attributes` table to include only records where `buildUpPlayDribblingClass` is 'Normal' and the year part of the `date` field is '2014'.\n\n2. **Calculate the Average Chance Creation Passing for These Teams**:\n   - Compute the average value of the `chanceCreationPassing` attribute for all teams identified in step 1.\n\n3. **Filter Teams with Less Than Average Chance Creation Passing**:\n   - From the filtered teams in step 1, further filter to include only those teams where `chanceCreationPassing` is less than the average calculated in step 2.\n\n4. **Retrieve Team Names**:\n   - For the remaining teams, retrieve their long names (`team_long_name`) from the `Team` table.\n\n5. **Sort the Results**:\n   - Order the resulting team names in descending order based on their `chanceCreationPassing` values.\n\nThe SQL query accomplishes this by joining the `Team` and `Team_Attributes` tables, applying the filters, calculating the average, and sorting the results as described.",
            "To solve the question, follow these detailed steps:\n\n1. **Identify Teams with Normal Build-Up Play Dribbling Class in 2014**:\n   - Join the `Team` table (`t3`) with the `Team_Attributes` table (`t4`) using the `team_api_id` field.\n   - Filter the records to include only those where `t4.buildUpPlayDribblingClass` is 'Normal'.\n   - Ensure the year part of the `date` field in `t4` is '2014' by using the `SUBSTR` function to extract the first 4 characters of the `date` field.\n\n2. **Calculate the Average Chance Creation Passing for These Teams**:\n   - In a subquery, join the `Team` table (`t1`) with the `Team_Attributes` table (`t2`) using the `team_api_id` field.\n   - Filter the records to include only those where `t2.buildUpPlayDribblingClass` is 'Normal' and the year part of the `date` field is '2014'.\n   - Compute the average of the `chanceCreationPassing` values by summing them up and dividing by the count of records, casting the sum to a `REAL` to ensure accurate division.\n\n3. **Filter Teams with Less Than Average Chance Creation Passing**:\n   - From the filtered teams in step 1, further filter to include only those where `t4.chanceCreationPassing` is less than the average calculated in the subquery from step 2.\n\n4. **Retrieve Team Names**:\n   - For the remaining teams, retrieve their long names (`team_long_name`) from the `Team` table (`t3`).\n\n5. **Sort the Results**:\n   - Order the resulting team names in descending order based on their `chanceCreationPassing` values from the `Team_Attributes` table (`t4`).\n\nThe SQL query accomplishes this by joining the tables, applying the filters, calculating the average, and sorting the results as described."
        ]
    },
    "1511": {
        "sql": "SELECT AVG(T1.Price) AS AveragePrice\nFROM transactions_1k T1\nJOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nJOIN customers T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Currency = 'EUR';",
        "question": "For the customers who paid in the euro, what is their average total price of the transactions?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Currency = 'EUR'",
        "explain": "",
        "solution": [
            "To find the average total price of transactions for customers who paid in euros, follow these steps:\n\n1. **Join the tables**: Combine the `transactions_1k` table (aliased as `T1`), the `gasstations` table (aliased as `T2`), and the `customers` table (aliased as `T3`). The joins are performed as follows:\n   - Join `T1` with `T2` on the `GasStationID` column.\n   - Join `T1` with `T3` on the `CustomerID` column.\n\n2. **Filter the data**: From the joined tables, filter the records to include only those where the `Currency` column in the `customers` table (`T3`) is 'EUR' (euros).\n\n3. **Calculate the average**: Compute the average of the `Price` column from the `transactions_1k` table (`T1`) for the filtered records.\n\nThe result will be the average total price of transactions for customers who paid in euros."
        ]
    },
    "1507": {
        "sql": "SELECT DISTINCT Time\nFROM transactions_1k\nJOIN gasstations ON transactions_1k.GasStationID = gasstations.GasStationID\nWHERE gasstations.ChainID = 11\nORDER BY Time;",
        "question": "Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.Time FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11",
        "explain": "",
        "solution": []
    },
    "1354": {
        "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'Vice President';",
        "question": "State the major name for the Vice President of the club.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Vice President'",
        "explain": "'Vice President' is a position of Student Club",
        "solution": []
    },
    "925": {
        "sql": "SELECT c.url \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE r.name = 'Spanish Grand Prix' AND r.year = 2009;",
        "question": "Please give the link of the website that shows more information about the circuits the Spanish Grand Prix used in 2009.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "explain": "link of the website refers to url",
        "solution": []
    },
    "104": {
        "sql": "SELECT a.date AS account_opening_date\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nWHERE t.amount = 840 AND t.date = '1998-10-14';",
        "question": "The transaction of 840 USD happened in 1998/10/14, when was this account opened?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.date FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.amount = 840 AND T2.date = '1998-10-14'",
        "explain": "",
        "solution": []
    },
    "922": {
        "sql": "SELECT r.date, r.time FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2010 AND r.name = 'Abu Dhabi Grand Prix';",
        "question": "What time did the the 2010's Formula_1 race took place on the Abu Dhabi Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.date, T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2010 AND T2.name = 'Abu Dhabi Grand Prix'",
        "explain": "",
        "solution": [
            "To find the time when the 2010 Formula 1 race took place on the Abu Dhabi Circuit, follow these steps:\n\n1. **Identify the circuits table (T1) and the races table (T2)**: The query involves joining these two tables to get the required information.\n\n2. **Join the tables**: Use the `circuitID` from the races table (T2) to match with the `circuitId` in the circuits table (T1). This ensures we are looking at races held on the Abu Dhabi Circuit.\n\n3. **Filter the data**: Apply the following filters to narrow down the results:\n   - The year of the race must be 2010 (`T2.year = 2010`).\n   - The name of the race must be 'Abu Dhabi Grand Prix' (`T2.name = 'Abu Dhabi Grand Prix'`).\n\n4. **Select the required fields**: Retrieve the `date` and `time` fields from the races table (T2) to get the specific time the race took place.\n\nThis process will return the date and time of the 2010 Formula 1 race held on the Abu Dhabi Circuit."
        ]
    },
    "1177": {
        "sql": "SELECT \n    CASE \n        WHEN `T-CHO` BETWEEN 125 AND 200 THEN 'Normal'\n        ELSE 'Abnormal'\n    END AS Cholesterol_Status\nFROM Laboratory\nWHERE ID = 2927464 AND Date = '1995-09-04';",
        "question": "Was the total cholesterol status for the patient id 2927464 on 1995-9-4 at the normal level?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CASE WHEN `T-CHO` < 250 THEN 'Normal' ELSE 'Abnormal' END FROM Laboratory WHERE ID = 2927464 AND Date = '1995-09-04'",
        "explain": "total cholesterol normal level refers to N < 250",
        "solution": []
    },
    "754": {
        "sql": "SELECT sp.power_name \nFROM superhero sh \nJOIN hero_power hp ON sh.id = hp.hero_id \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE sh.id = 56;",
        "question": "What is the superpower of hero ID 56?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 56",
        "explain": "superpower refers to hero_power",
        "solution": []
    },
    "1331": {
        "sql": "SELECT SUM(i.amount) AS total_funds_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.position = 'Vice President';",
        "question": "What is the amount of the funds that the Vice President received?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "explain": "'Vice President' is a position of Student Club; funds received refers to amount.",
        "solution": []
    },
    "807": {
        "sql": "SELECT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.full_name = 'Helen Parr';",
        "question": "What is the superpowers of the superhero has Helen Parr as their full name?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.full_name = 'Helen Parr'",
        "explain": "superpowers refers to power_name; Helen Parr is the full name of superhero;",
        "solution": []
    },
    "1348": {
        "sql": "SELECT COUNT(*) \nFROM budget \nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'November Meeting') \nAND spent > amount;",
        "question": "For all the budgets for \"November Meeting\", how many of them had exceeded the budget?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.event_id) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Meeting' AND T1.remaining < 0",
        "explain": "'November Meeting' is an event name; remaining < 0 means the cost had exceeded the budget",
        "solution": []
    },
    "425": {
        "sql": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL;",
        "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
        "explain": "don't have multiple faces on a single card side is null",
        "solution": [
            "To find the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard, follow these steps:\n\n1. **Filter by Subtypes**: Select cards where the `subtypes` column exactly matches 'Angel,Wizard'. This ensures the card has both Angel and Wizard subtypes.\n\n2. **Exclude Multiple Faces**: Ensure the `side` column is `NULL`, indicating the card does not have multiple faces (i.e., it is a single-faced card).\n\n3. **Retrieve Card IDs**: Finally, retrieve the `id` column from the filtered results to get the card numbers that meet the criteria."
        ]
    },
    "624": {
        "sql": "SELECT DisplayName FROM users WHERE Id = 30;",
        "question": "What is the name of user with the ID of 30?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = 30",
        "explain": "name of user refers to DisplayName;",
        "solution": []
    },
    "945": {
        "sql": "SELECT COUNT(*) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia';",
        "question": "How many circuits are there in Adelaide, Australia?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia'",
        "explain": "Australia is the country; Melbourne is the location of circuit;",
        "solution": []
    },
    "79": {
        "sql": "SELECT County, COUNT(*) AS NumberOfVirtualSchools\nFROM schools\nWHERE Virtual = 'F' AND County IN ('San Diego', 'Santa Barbara')\nGROUP BY County\nORDER BY NumberOfVirtualSchools DESC\nLIMIT 1;",
        "question": "Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT County, COUNT(Virtual) FROM schools WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F' GROUP BY County ORDER BY COUNT(Virtual) DESC LIMIT 1",
        "explain": "'Does not offer physical building' means Virtual = F in the database.",
        "solution": []
    },
    "796": {
        "sql": "SELECT a.attribute_name, ha.attribute_value\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE s.superhero_name = '3-D Man';",
        "question": "State all of 3-D Man's attributes along with their values.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.attribute_name, T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = '3-D Man'",
        "explain": "3-D Man is the superhero_name. attributes refers to attribute_name; values refers to attribute_value;",
        "solution": []
    },
    "85": {
        "sql": "SELECT T1.\"Percent (%) Eligible Free (K-12)\", T1.\"District Code\"\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.AdmFName1 = 'Alusine';",
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "explain": "Percent (%) Eligible Free (K-12) = `Free Meal Count (K-12)` / `Enrollment (K-12)` * 100%",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Join the Tables**: Combine the `frpm` table (T1) and the `schools` table (T2) using the `CDSCode` field as the common key. This ensures that the data from both tables is linked correctly.\n\n2. **Filter by Administrator's First Name**: From the joined tables, filter the records to include only those where the administrator's first name (`AdmFName1` in the `schools` table) is 'Alusine'.\n\n3. **Calculate the Percentage**: For each matching record, calculate the percentage of eligible students for free meals (K-12) by dividing the `Free Meal Count (K-12)` by the `Enrollment (K-12)` and then multiplying the result by 100.\n\n4. **Select the Required Fields**: Retrieve the calculated percentage and the `District Code` from the `frpm` table (T1) for the filtered records.\n\nThis process ensures that you get the percentage of eligible students for free meals (K-12) and the district code for schools administered by an administrator named 'Alusine'.",
            "To solve the question, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `frpm` table (aliased as T1) and the `schools` table (aliased as T2) using the `CDSCode` field as the common key. This ensures that the data from both tables is linked correctly based on the school's unique identifier.\n\n2. **Filter by Administrator's First Name**: From the joined tables, filter the records to include only those where the administrator's first name (`AdmFName1` in the `schools` table) is exactly 'Alusine'. This narrows down the results to schools administered by an administrator with the specified first name.\n\n3. **Calculate the Percentage**: For each matching record, compute the percentage of eligible students for free meals (K-12) by dividing the `Free Meal Count (K-12)` field from the `frpm` table by the `Enrollment (K-12)` field from the same table, then multiplying the result by 100. This gives the percentage value directly.\n\n4. **Select the Required Fields**: Retrieve the calculated percentage (as described in step 3) and the `District Code` field from the `frpm` table (T1) for the filtered records. This ensures the output includes both the percentage of eligible students and the district code for each qualifying school.\n\nThis process ensures that the query accurately returns the percentage of eligible students for free meals (K-12) and the district code for schools administered by an administrator named 'Alusine'."
        ]
    },
    "1175": {
        "sql": "SELECT \n    (strftime('%Y', l.Date) - strftime('%Y', p.Birthday)) AS Age,\n    p.Diagnosis\nFROM \n    Patient p\nJOIN \n    Laboratory l ON p.ID = l.ID\nORDER BY \n    l.HGB DESC\nLIMIT 1;",
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "explain": "How old the patient refers to SUBTRACT(year(`Examination Date`), year(Birthday)); the highest hemoglobin count refers to MAX(HGB)",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join the Patient and Laboratory tables**: The tables are joined using the `ID` column to link patient records with their laboratory results.\n\n2. **Calculate the patient's age**: The age is calculated by subtracting the year of the patient's birth (from the `Birthday` column in the Patient table) from the year of the laboratory examination date (from the `Date` column in the Laboratory table).\n\n3. **Sort by hemoglobin count**: The results are sorted in descending order based on the `HGB` (hemoglobin) column to prioritize the highest hemoglobin count.\n\n4. **Retrieve the top record**: The first record from the sorted list is selected, which corresponds to the patient with the highest hemoglobin count.\n\n5. **Extract the age and diagnosis**: The calculated age and the `Diagnosis` from the Patient table are returned for the selected patient."
        ]
    },
    "549": {
        "sql": "SELECT p.Body \nFROM tags t \nJOIN posts p ON t.ExcerptPostId = p.Id \nWHERE t.TagName = 'bayesian';",
        "question": "From which post is the tag \"bayesian\" excerpted from? Please give the body of the post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Body FROM tags AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.ExcerptPostId WHERE T1.TagName = 'bayesian'",
        "explain": "\"bayesian\" is the TagName; excerpt from refers to ExcerptPostId",
        "solution": []
    },
    "139": {
        "sql": "SELECT COUNT(*) AS high_level_owner_cards\nFROM card\nJOIN disp ON card.disp_id = disp.disp_id\nWHERE card.type = 'gold' AND disp.type = 'OWNER';",
        "question": "How many high-level credit cards have \"OWNER\" type of disposition?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'OWNER'",
        "explain": "High-level credit cards refers to the cards with the gold type.",
        "solution": []
    },
    "611": {
        "sql": "SELECT T1.Reputation FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'",
        "question": "Mention the reputation of users who had obtained the badge on 7/19/2010 7:39:08 PM.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'",
        "explain": "on 7/19/2010 7:39:08 PM refers to Date = '2010-07-19 19:39:08.0'",
        "solution": [
            "To solve the question, we need to find the reputation of users who obtained a badge on the specific date and time, July 19, 2010, at 7:39:08 PM. The solution involves the following steps:\n\n1. **Identify the Tables**: The data is stored in two tables: `users` (referred to as T1) and `badges` (referred to as T2).\n\n2. **Join the Tables**: The `users` table is joined with the `badges` table using the common field `Id` from the `users` table and `UserId` from the `badges` table. This ensures we only consider users who have badges.\n\n3. **Filter by Date**: The query filters the badges to only include those that were obtained on the exact date and time specified, which is '2010-07-19 19:39:08.0'.\n\n4. **Select the Reputation**: Finally, the query selects the `Reputation` column from the `users` table for the users who meet the criteria.\n\nThe SQL query accomplishes this by combining these steps into a single operation, ensuring accuracy and efficiency.",
            "To solve the question, we need to find the reputation of users who obtained a badge on the specific date and time, July 19, 2010, at 7:39:08 PM. The solution involves the following detailed steps:\n\n1. **Identify the Tables**: The data is stored in two tables:\n   - `users` (referred to as T1 in the SQL query), which contains user information including their reputation.\n   - `badges` (referred to as T2 in the SQL query), which contains information about badges awarded to users, including the date and time of award.\n\n2. **Join the Tables**: The `users` table is joined with the `badges` table using the common field `Id` from the `users` table and `UserId` from the `badges` table. This join ensures that we only consider users who have been awarded badges.\n\n3. **Filter by Exact Date and Time**: The query filters the `badges` table to include only those records where the `Date` column matches the exact timestamp '2010-07-19 19:39:08.0'. This ensures that only badges awarded at the specified date and time are considered.\n\n4. **Select the Reputation**: The query then selects the `Reputation` column from the `users` table for the users who meet the criteria (i.e., users who received a badge at the specified date and time).\n\nThe SQL query combines these steps into a single operation, ensuring that the result is accurate and efficient. The query is as follows:\n\n```sql\nSELECT T1.Reputation FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'\n```"
        ]
    },
    "1347": {
        "sql": "SELECT z.county\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Adela' AND m.last_name = 'O''Gallagher';",
        "question": "Tell the hometown county for \"Adela O'Gallagher\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'",
        "explain": "hometown county refers to county",
        "solution": []
    },
    "1452": {
        "sql": "SELECT AVG(T1.cost) AS average_amount_paid\nFROM expense T1\nJOIN member T2 ON T1.link_to_member = T2.member_id\nWHERE T2.position != 'Member';",
        "question": "What is the average amount paid by students in a position other than a member?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN member as T2 ON T1.link_to_member = T2.member_id WHERE T2.position != 'Member'",
        "explain": "position other than a member refers to position ! = 'Member'; average amount paid = DIVIDE( SUM(cost), COUNT(event_id))",
        "solution": [
            "To find the average amount paid by students who are not in the 'Member' position, follow these steps:\n\n1. **Join the Tables**: Combine the `expense` table (referred to as `T1`) with the `member` table (referred to as `T2`) using the common field `link_to_member` from `T1` and `member_id` from `T2`.\n\n2. **Filter the Records**: From the joined tables, filter out only those records where the `position` field in the `member` table (`T2`) is not equal to 'Member'.\n\n3. **Calculate the Average**: Compute the average of the `cost` field from the `expense` table (`T1`) for the filtered records.\n\nThe result will be the average amount paid by students in positions other than 'Member'."
        ]
    },
    "395": {
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'UDON' \nAND availability LIKE '%mtgo%' \nAND hand = '-1';",
        "question": "How many cards designed by UDON and available in mtgo print type has a starting maximum hand size of -1?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE hAND = '-1' AND artist = 'UDON' AND Availability = 'mtgo' ",
        "explain": "UDON refer to artist; availabe in mtgo refers to availability = 'mtgo'; starting maximum hand size of -1 refers to hand = -1",
        "solution": []
    },
    "171": {
        "sql": "SELECT \n    SUM(CASE WHEN A3 = 'east Bohemia' THEN A16 ELSE 0 END) - \n    SUM(CASE WHEN A3 = 'north Bohemia' THEN A16 ELSE 0 END) AS crime_difference\nFROM district;",
        "question": "What was the difference in the number of crimes committed in East and North Bohemia in 1996?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district",
        "explain": "Difference in no. of committed crimes between 2 regions = Total no. of committed crimes in 1996 in north Bohemia - Total no. of committed crimes in 1996 in e ast Bohemia. A3 refers to region. Data about no. of committed crimes 1996 appears in A16",
        "solution": [
            "To find the difference in the number of crimes committed in East and North Bohemia in 1996, follow these steps:\n\n1. **Identify the relevant data**: The data is stored in the `district` table, where:\n   - `A3` represents the region (either 'east Bohemia' or 'north Bohemia').\n   - `A16` represents the number of crimes committed.\n\n2. **Filter the data for East Bohemia**: Calculate the sum of crimes (`A16`) where the region (`A3`) is 'east Bohemia'.\n\n3. **Filter the data for North Bohemia**: Calculate the sum of crimes (`A16`) where the region (`A3`) is 'north Bohemia'.\n\n4. **Compute the difference**: Subtract the sum of crimes in North Bohemia from the sum of crimes in East Bohemia to get the final result.\n\nThe SQL query achieves this by using the `SUM` function combined with `IIF` (immediate if) to conditionally sum the crimes for each region and then subtracts the two sums."
        ]
    },
    "749": {
        "sql": "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Deathlok';",
        "question": "Provide the superpowers of the superhero called Deathlok.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Deathlok'",
        "explain": "superpowers refers to power_name; Deathlok refers to superhero_name = 'Deathlok'",
        "solution": []
    },
    "1362": {
        "sql": "SELECT COUNT(DISTINCT city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia';",
        "question": "How many cities are there in Orange County, Virginia?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia'",
        "explain": "Orange County is the county name, Virginia is the state name",
        "solution": []
    },
    "268": {
        "sql": "SELECT T2.element FROM connected T1 JOIN atom T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11';",
        "question": "What are the elements for bond id TR001_10_11?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
        "explain": "TR001_10_11 is the bond id;",
        "solution": [
            "To find the elements for the bond with ID 'TR001_10_11', perform the following steps:\n\n1. **Join the Tables**: Combine the 'connected' table (referred to as T1) with the 'atom' table (referred to as T2) using the 'atom_id' field as the common key. This ensures that each record in the 'connected' table is matched with the corresponding record in the 'atom' table.\n\n2. **Filter by Bond ID**: From the joined result, filter the records to only include those where the 'bond_id' in the 'connected' table (T1) is equal to 'TR001_10_11'.\n\n3. **Select the Elements**: From the filtered records, extract the 'element' column from the 'atom' table (T2).\n\nThis process will return all elements associated with the bond ID 'TR001_10_11'."
        ]
    },
    "372": {
        "sql": "SELECT COUNT(*) FROM cards WHERE toughness = '99';",
        "question": "How many cards are there with toughness of 99?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE toughness = 99",
        "explain": "",
        "solution": []
    },
    "182": {
        "sql": "SELECT COUNT(DISTINCT T1.account_id) AS male_customers_count\nFROM trans T1\nJOIN account T2 ON T1.account_id = T2.account_id\nJOIN disp T4 ON T2.account_id = T4.account_id\nJOIN client T3 ON T4.client_id = T3.client_id\nWHERE STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976'\n  AND T3.gender = 'M'\n  AND T1.amount > 4000\n  AND T1.k_symbol = 'SIPO';",
        "question": "How many male customers who were born between 1974 and 1976 have made a payment on their home in excess of $4000?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T2.account_id = T4.account_id INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976' AND T3.gender = 'M' AND T1.amount > 4000 AND T1.k_symbol = 'SIPO'",
        "explain": "Man and male refers to gender = 'M'; 'SIPO' stands for household payment",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Join the Tables**: Combine the `trans`, `account`, `disp`, and `client` tables to gather all necessary data. The joins are as follows:\n   - Join `trans` (T1) with `account` (T2) on `T1.account_id = T2.account_id`.\n   - Join `account` (T2) with `disp` (T4) on `T2.account_id = T4.account_id`.\n   - Join `disp` (T4) with `client` (T3) on `T4.client_id = T3.client_id`.\n\n2. **Filter the Data**: Apply the following filters to the joined data:\n   - Extract the year from the `birth_date` column in the `client` table (T3) and ensure it falls between 1974 and 1976.\n   - Ensure the `gender` column in the `client` table (T3) is 'M' (male).\n   - Filter the `amount` column in the `trans` table (T1) to include only transactions where the amount exceeds $4000.\n   - Ensure the `k_symbol` column in the `trans` table (T1) is 'SIPO' (indicating a payment on their home).\n\n3. **Count the Results**: Count the number of unique `account_id` values from the `trans` table (T1) that meet all the above criteria.\n\nThe final result will be the count of male customers born between 1974 and 1976 who made a home payment exceeding $4000.",
            "To solve the question, follow these detailed steps:\n\n1. **Join the Tables**: Combine the `trans`, `account`, `disp`, and `client` tables to gather all necessary data. The joins are as follows:\n   - Join the `trans` table (T1) with the `account` table (T2) using the condition `T1.account_id = T2.account_id`.\n   - Join the `account` table (T2) with the `disp` table (T4) using the condition `T2.account_id = T4.account_id`.\n   - Join the `disp` table (T4) with the `client` table (T3) using the condition `T4.client_id = T3.client_id`.\n\n2. **Filter the Data**: Apply the following filters to the joined data:\n   - Extract the year from the `birth_date` column in the `client` table (T3) and ensure it falls between 1974 and 1976 using the condition `STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976'`.\n   - Ensure the `gender` column in the `client` table (T3) is 'M' (male) using the condition `T3.gender = 'M'`.\n   - Filter the `amount` column in the `trans` table (T1) to include only transactions where the amount exceeds $4000 using the condition `T1.amount > 4000`.\n   - Ensure the `k_symbol` column in the `trans` table (T1) is 'SIPO' (indicating a payment on their home) using the condition `T1.k_symbol = 'SIPO'`.\n\n3. **Count the Results**: Count the number of unique `account_id` values from the `trans` table (T1) that meet all the above criteria using the function `COUNT(T1.account_id)`.\n\nThe final result will be the count of male customers born between 1974 and 1976 who made a home payment exceeding $4000."
        ]
    },
    "840": {
        "sql": "SELECT T2.attribute_value FROM superhero T1 JOIN hero_attribute T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Aquababy';",
        "question": "List the attribute value of the superhero named Aquababy.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Aquababy'",
        "explain": "",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: The `superhero` table (referred to as `T1`) is joined with the `hero_attribute` table (referred to as `T2`) using the condition that the `id` column in `T1` matches the `hero_id` column in `T2`.\n\n2. **Filter by Superhero Name**: The joined tables are filtered to include only the row where the `superhero_name` column in `T1` is equal to 'Aquababy'.\n\n3. **Select the Attribute Value**: From the filtered result, the `attribute_value` column from `T2` is selected to be displayed in the output.\n\nThis sequence of operations ensures that the attribute value of the superhero named 'Aquababy' is retrieved from the database."
        ]
    },
    "1222": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) AS MalePatientsWithHighCreatinine\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.CRE >= 1.5;",
        "question": "How many male patients are are with creatinine index out of the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND T1.SEX = 'M'",
        "explain": "creatinine (CRE) out of the normal range refers to CRE > = 1.5; Male refers to Sex = 'M'",
        "solution": [
            "To solve the question \"How many male patients have a creatinine index out of the normal range?\", the following steps are performed:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (aliased as `T1`), which contains patient information including their sex.\n   - `Laboratory` (aliased as `T2`), which contains laboratory test results, including the creatinine index (`CRE`).\n\n2. **Join the Tables**: The tables are joined using the `ID` column, which links each patient to their laboratory results.\n\n3. **Filter Conditions**:\n   - The query filters for male patients by checking `T1.SEX = 'M'`.\n   - It also filters for patients with a creatinine index (`CRE`) greater than or equal to 1.5, which is considered out of the normal range.\n\n4. **Count the Results**: The query counts the number of patient IDs (`T1.ID`) that meet both conditions.\n\nThe final result is the count of male patients whose creatinine index is 1.5 or higher.",
            "To solve the question \"How many male patients have a creatinine index out of the normal range?\", the following detailed steps are performed:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (aliased as `T1`), which contains patient information including their sex (`SEX`).\n   - `Laboratory` (aliased as `T2`), which contains laboratory test results, including the creatinine index (`CRE`).\n\n2. **Join the Tables**: The tables are joined using the `ID` column, which links each patient to their laboratory results. This ensures that each patient's laboratory data is correctly associated with their demographic information.\n\n3. **Filter Conditions**:\n   - The query filters for male patients by checking `T1.SEX = 'M'`, ensuring only male patients are considered.\n   - It also filters for patients with a creatinine index (`CRE`) greater than or equal to 1.5 (`T2.CRE >= 1.5`), which is the threshold for the creatinine index being out of the normal range.\n\n4. **Count the Results**: The query counts the number of distinct patient IDs (`T1.ID`) that meet both conditions. This count represents the number of male patients with a creatinine index out of the normal range.\n\nThe final result is the count of male patients whose creatinine index is 1.5 or higher, as specified in the query."
        ]
    },
    "810": {
        "sql": "SELECT r.race\nFROM race r\nJOIN superhero s ON r.id = s.race_id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nWHERE ha.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute)\nLIMIT 1;",
        "question": "What is the race of the superhero with maximum attribute value?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN race AS T3 ON T1.race_id = T3.id ORDER BY T2.attribute_value DESC LIMIT 1",
        "explain": "maximum attribute value refers to MAX(attribute_value);",
        "solution": []
    },
    "367": {
        "sql": "SELECT DISTINCT c.artist FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Phyrexian';",
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "explain": "Phyrexian' is the language; name of artists refers to artist;",
        "solution": []
    },
    "1265": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "explain": "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;",
        "solution": [
            "To solve the question, we need to count the number of distinct patients who meet two conditions: \n1. Their anti-ribonuclear protein (RNP) level is either 'negative' or '0' (indicating a normal level).\n2. They have been admitted to the hospital (indicated by the 'Admission' field being '+').\n\nThe solution involves the following steps:\n1. Join the 'Patient' table (T1) with the 'Laboratory' table (T2) using the patient ID to link the records.\n2. Filter the joined records to include only those where the RNP level is either 'negative' or '0'.\n3. Further filter these records to include only patients who have been admitted (Admission = '+').\n4. Count the distinct patient IDs from the filtered records to get the final result.",
            "To solve the question, we need to count the number of distinct patients who meet two conditions:\n1. Their anti-ribonuclear protein (RNP) level is either 'negative' or '0' (indicating a normal level).\n2. They have been admitted to the hospital (indicated by the 'Admission' field being '+').\n\nThe solution involves the following steps:\n1. Join the 'Patient' table (T1) with the 'Laboratory' table (T2) using the patient ID to link the records.\n2. Filter the joined records to include only those where the RNP level is either 'negative' or '0'.\n3. Further filter these records to include only patients who have been admitted (Admission = '+').\n4. Count the distinct patient IDs from the filtered records to get the final result.\n\nThe SQL query for this operation is:\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'"
        ]
    },
    "274": {
        "sql": "SELECT DISTINCT element FROM atom WHERE molecule_id = 'TR001';",
        "question": "List the toxicology elements associated with molecule TR001.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR001'",
        "explain": "TR001 is the molecule id",
        "solution": []
    },
    "1495": {
        "sql": "SELECT T1.CustomerID\nFROM customers T1\nJOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
        "question": "Which client ID consumed the most in September 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "explain": "September 2013 refers to yearmonth.date = '201309'",
        "solution": [
            "To determine which client ID consumed the most in September 2013, follow these steps:\n\n1. **Join Tables**: Combine the `customers` table (aliased as `T1`) with the `yearmonth` table (aliased as `T2`) using the `CustomerID` field as the common key.\n\n2. **Filter by Date**: From the joined tables, filter the records to include only those where the `Date` field in the `yearmonth` table is '201309' (representing September 2013).\n\n3. **Group by CustomerID**: Group the filtered records by the `CustomerID` field from the `customers` table.\n\n4. **Calculate Total Consumption**: For each group (i.e., each customer), calculate the sum of the `Consumption` values from the `yearmonth` table.\n\n5. **Sort by Consumption**: Sort the grouped results in descending order based on the total consumption calculated in the previous step.\n\n6. **Select Top Customer**: Retrieve the `CustomerID` of the customer with the highest total consumption by limiting the result to the first record.\n\nThe final output will be the `CustomerID` of the client who consumed the most in September 2013."
        ]
    },
    "1530": {
        "sql": "SELECT T2.Description\nFROM transactions_1k T1\nJOIN products T2 ON T1.ProductID = T2.ProductID\nORDER BY T1.Amount DESC\nLIMIT 5;",
        "question": "Which are the top five best selling products? Please state the full name of them.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.Amount DESC LIMIT 5",
        "explain": "Description of products contains full name",
        "solution": [
            "To find the top five best-selling products, follow these steps:\n\n1. **Join the tables**: Combine the `transactions_1k` table (referred to as `T1`) with the `products` table (referred to as `T2`) using the `ProductID` field as the common key. This ensures that each transaction record is linked to its corresponding product details.\n\n2. **Sort the transactions**: Arrange the joined records in descending order based on the `Amount` field from the `transactions_1k` table (`T1.Amount`). This places the highest-selling products at the top of the list.\n\n3. **Limit the results**: Retrieve only the top five records from the sorted list to identify the five best-selling products.\n\n4. **Select the product names**: From the filtered results, extract the `Description` field from the `products` table (`T2.Description`), which contains the full names of the products.\n\nThe final output will be a list of the full names of the top five best-selling products."
        ]
    },
    "202": {
        "sql": "SELECT COUNT(*) FROM bond WHERE bond_type = '#';",
        "question": "How many triple type bonds are there?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '#'",
        "explain": "triple type bonds refers to bond_type = '#'",
        "solution": []
    },
    "965": {
        "sql": "SELECT raceId FROM races WHERE year = 2009;",
        "question": "List out the Id number of races which were hold in 2009.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT raceId FROM races WHERE year = 2009",
        "explain": "",
        "solution": []
    },
    "21": {
        "sql": "SELECT COUNT(*) \nFROM frpm \nJOIN schools ON frpm.CDSCode = schools.CDSCode \nWHERE schools.County = 'Los Angeles' \nAND frpm.\"Free Meal Count (K-12)\" > 500 \nAND frpm.\"FRPM Count (K-12)\" < 700;",
        "question": "In Los Angeles how many schools have more than 500 free meals but less than 700 free or reduced price meals for K-12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(CDSCode) FROM frpm WHERE `County Name` = 'Los Angeles' AND `Free Meal Count (K-12)` > 500 AND `FRPM Count (K-12)`< 700",
        "explain": "",
        "solution": []
    },
    "1533": {
        "sql": "SELECT T2.Consumption\nFROM transactions_1k T1\nJOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE (T1.Price / T1.Amount) > 29.00 AND T1.ProductID = 5 AND T2.Date = '201208';",
        "question": "For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price / T1.Amount > 29.00 AND T1.ProductID = 5 AND T2.Date = '201208'",
        "explain": "August of 2012 refers to the Date value = '201208' ; Price per unit of product = Price / Amount;",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Filter Transactions**: From the `transactions_1k` table (aliased as `T1`), filter out records where the price per unit (calculated as `Price / Amount`) is greater than 29.00 and the `ProductID` is 5.\n\n2. **Join with YearMonth Data**: Join the filtered transactions with the `yearmonth` table (aliased as `T2`) using the `CustomerID` as the join key. This links each transaction to the corresponding customer's consumption status.\n\n3. **Filter by Date**: From the joined result, further filter records where the `Date` in the `yearmonth` table is '201208' (August 2012).\n\n4. **Select Consumption Status**: Finally, retrieve the `Consumption` field from the `yearmonth` table for the filtered and joined records.\n\nThis sequence of operations ensures that only the consumption status of customers who paid more than 29.00 per unit for product ID 5 in August 2012 is returned."
        ]
    },
    "690": {
        "sql": "SELECT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.DisplayName = 'Emmett'\nORDER BY b.Date DESC\nLIMIT 1;",
        "question": "Identify the latest badge awarded to the user with the display name Emmett.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Emmett' ORDER BY T1.Date DESC LIMIT 1",
        "explain": "the latest badge refers to Name FROM badges where MAX(Date);",
        "solution": []
    },
    "55": {
        "sql": "SELECT \n    (SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND County = 'Colusa') * 1.0 /\n    (SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND County = 'Humboldt') AS ratio_colusa_to_humboldt;",
        "question": "Of the schools with a mailing state address in California, what is the ratio of the schools located in the county of Colusa against the school located in the county of Humboldt?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END) FROM schools WHERE MailState = 'CA'",
        "explain": "Ratio = count(schools in Colusa) / count(schools in Humboldt)",
        "solution": []
    },
    "0": {
        "sql": "SELECT MAX(`Percent (%) Eligible Free (K-12)`) AS HighestEligibleFreeRate\nFROM frpm\nWHERE `County Name` = 'Alameda';",
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "explain": "Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`",
        "solution": []
    },
    "285": {
        "sql": "SELECT DISTINCT a.element FROM atom a INNER JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 INNER JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_id = 'TR001_10_11';",
        "question": "Name chemical elements that form a bond TR001_10_11.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_id = 'TR001_10_11'",
        "explain": "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium; TR001_10_11 is the bond id; molecule id refers to SUBSTR(bond_id, 1, 5); atom 1 refers to SUBSTR(bond_id, 7, 2); atom 2 refers to SUBSTR(bond_id, 10, 2)",
        "solution": [
            "To find the chemical elements that form the bond with the ID 'TR001_10_11', follow these steps:\n\n1. **Access the 'atom' table (T1)**: This table contains information about chemical elements, including their unique identifiers (atom_id) and the elements themselves.\n\n2. **Access the 'connected' table (T2)**: This table serves as a junction table that links atoms to bonds. It contains pairs of atom_id and bond_id to indicate which atoms are connected by which bonds.\n\n3. **Access the 'bond' table (T3)**: This table contains details about bonds, including their unique identifiers (bond_id).\n\n4. **Perform an inner join between 'atom' (T1) and 'connected' (T2)**: This join connects the atom records to the bond records via the atom_id field, ensuring that only atoms involved in bonds are considered.\n\n5. **Perform an inner join between the result and the 'bond' table (T3)**: This join connects the bond records to the connected records via the bond_id field, ensuring that only bonds matching the specified bond_id are considered.\n\n6. **Filter the results to include only the bond with the ID 'TR001_10_11'**: This is done by applying a WHERE clause to the bond_id field in the 'bond' table (T3).\n\n7. **Select the 'element' field from the 'atom' table (T1)**: This retrieves the names of the chemical elements that form the specified bond.\n\nThe final output will be a list of chemical elements that participate in the bond identified by 'TR001_10_11'.",
            "To find the chemical elements that form the bond with the ID 'TR001_10_11', follow these detailed steps:\n\n1. **Access the 'atom' table (T1)**: This table contains records of chemical elements, each identified by a unique `atom_id` and associated with an `element` name.\n\n2. **Access the 'connected' table (T2)**: This table acts as a bridge between atoms and bonds, storing pairs of `atom_id` and `bond_id` to indicate which atoms are connected by which bonds.\n\n3. **Access the 'bond' table (T3)**: This table holds information about bonds, including their unique identifiers (`bond_id`).\n\n4. **Perform an inner join between 'atom' (T1) and 'connected' (T2)**: This join links the `atom_id` field in T1 to the `atom_id` field in T2, ensuring that only atoms involved in bonds are included in the result set.\n\n5. **Perform an inner join between the intermediate result and the 'bond' table (T3)**: This join connects the `bond_id` field in T2 to the `bond_id` field in T3, ensuring that only bonds matching the specified `bond_id` are considered.\n\n6. **Apply a filter to the results**: Use a WHERE clause to restrict the results to only those records where the `bond_id` in T3 is equal to 'TR001_10_11'.\n\n7. **Retrieve the 'element' field from the 'atom' table (T1)**: This step extracts the names of the chemical elements that participate in the bond identified by 'TR001_10_11'.\n\nThe final output will be a list of chemical elements that form the bond with the ID 'TR001_10_11'."
        ]
    },
    "711": {
        "sql": "SELECT COUNT(DISTINCT T2.Id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40;",
        "question": "Among products comments with 0 score, what is the total number of users ages 40 years old?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40",
        "explain": "",
        "solution": [
            "To solve the question, we need to find the total number of distinct users who are 40 years old and have left comments with a score of 0. The solution involves the following steps:\n\n1. **Filter Comments with Score 0**: First, identify all comments in the `comments` table where the `Score` column is equal to 0.\n\n2. **Join with Users Table**: Next, join these filtered comments with the `users` table using the `UserId` column from the `comments` table and the `Id` column from the `users` table. This ensures we only consider comments made by valid users.\n\n3. **Filter Users Aged 40**: From the joined result, filter out only those users where the `Age` column in the `users` table is equal to 40.\n\n4. **Count Distinct Users**: Finally, count the number of distinct user IDs (`id` column in the `users` table) from the filtered results to get the total number of unique users who meet the criteria.\n\nThe SQL query provided accomplishes this by performing an inner join between the `comments` and `users` tables, applying the necessary filters, and then counting the distinct user IDs.",
            "To solve the question, we need to find the total number of distinct users who are 40 years old and have left comments with a score of 0. The solution involves the following detailed steps:\n\n1. **Filter Comments with Score 0**: Query the `comments` table (aliased as `T1`) to retrieve all records where the `Score` column is equal to 0. This ensures we only consider comments that have received a score of 0.\n\n2. **Join with Users Table**: Perform an inner join between the filtered `comments` table (`T1`) and the `users` table (aliased as `T2`). The join condition is `T1.UserId = T2.Id`, which links each comment to its corresponding user in the `users` table.\n\n3. **Filter Users Aged 40**: From the joined result, apply a filter to include only those records where the `Age` column in the `users` table (`T2`) is equal to 40. This narrows down the results to users who are exactly 40 years old.\n\n4. **Count Distinct Users**: Finally, count the number of distinct user IDs (`id` column in the `users` table, `T2.Id`) from the filtered and joined results. This count represents the total number of unique users who meet both criteria: having left a comment with a score of 0 and being 40 years old.\n\nThe SQL query provided (`SELECT COUNT(DISTINCT T1.id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40`) precisely executes these steps to arrive at the correct answer."
        ]
    },
    "787": {
        "sql": "SELECT r.race, a.alignment\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nJOIN alignment a ON s.alignment_id = a.id\nWHERE s.superhero_name = 'Cameron Hicks';",
        "question": "What are the race and alignment of Cameron Hicks?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race, T3.alignment FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T1.superhero_name = 'Cameron Hicks'",
        "explain": "Cameron Hicks refers to superhero_name = 'Cameron Hicks';",
        "solution": []
    },
    "308": {
        "sql": "SELECT COUNT(DISTINCT c.bond_id) AS bond_count\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE a1.element = 'cl' OR a2.element = 'cl';",
        "question": "How many bonds are created by bonding atoms with chlorine element?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.bond_id) FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T2.element = 'cl'",
        "explain": "chlorine refers to element = 'cl'",
        "solution": []
    },
    "1005": {
        "sql": "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1;",
        "question": "What was the longest time a driver had ever spent at a pit stop?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT duration FROM pitStops ORDER BY duration DESC LIMIT 1",
        "explain": "longest time spent at pitstop refers to MAX(duration)",
        "solution": [
            "To find the longest time a driver had ever spent at a pit stop, the database performs the following operations:\n\n1. **Retrieve Data**: The database accesses the `pitStops` table, which contains records of all pit stops made by drivers.\n\n2. **Sort Data**: The records are sorted in descending order based on the `duration` column. This ensures that the longest pit stop duration appears at the top of the list.\n\n3. **Limit Results**: Only the top record (the one with the longest duration) is selected from the sorted list.\n\n4. **Output Result**: The `duration` value of this top record is returned as the result, representing the longest time a driver had ever spent at a pit stop."
        ]
    },
    "144": {
        "sql": "SELECT AVG(T4.amount) AS average_amount\nFROM card T1\nJOIN disp T2 ON T1.disp_id = T2.disp_id\nJOIN account T3 ON T2.account_id = T3.account_id\nJOIN trans T4 ON T3.account_id = T4.account_id\nWHERE strftime('%Y', T4.date) = '1998'\nAND T4.operation = 'VYBER KARTOU';",
        "question": "How much is the average amount in credit card made by account holders in a month, in year 2021?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT AVG(T4.amount) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE STRFTIME('%Y', T4.date) = '1998' AND T4.operation = 'VYBER KARTOU'",
        "explain": "Operation = 'VYBER KARTOU' refers to credit card withdrawn",
        "solution": [
            "To find the average amount in credit card transactions made by account holders in a month for the year 2021, follow these steps:\n\n1. **Join the Tables**:\n   - Start by joining the `card` table (T1) with the `disp` table (T2) using the `disp_id` field.\n   - Next, join the result with the `account` table (T3) using the `account_id` field.\n   - Finally, join this result with the `trans` table (T4) using the `account_id` field.\n\n2. **Filter the Data**:\n   - Filter the transactions in the `trans` table (T4) to include only those from the year 2021. This is done by checking the `date` field in T4 and ensuring it matches the year '2021'.\n   - Further filter the transactions to include only those with the operation type 'VYBER KARTOU' (credit card withdrawal).\n\n3. **Calculate the Average**:\n   - Compute the average of the `amount` field from the filtered transactions in the `trans` table (T4).\n\nThe result will be the average amount of credit card transactions made by account holders in a month during the year 2021.",
            "To find the average amount in credit card transactions made by account holders in a month for the year 1998, follow these steps:\n\n1. **Join the Tables**:\n   - Begin by joining the `card` table (T1) with the `disp` table (T2) using the `disp_id` field.\n   - Next, join the result with the `account` table (T3) using the `account_id` field.\n   - Finally, join this result with the `trans` table (T4) using the `account_id` field.\n\n2. **Filter the Data**:\n   - Filter the transactions in the `trans` table (T4) to include only those from the year 1998. This is done by checking the `date` field in T4 and ensuring it matches the year '1998'.\n   - Further filter the transactions to include only those with the operation type 'VYBER KARTOU' (credit card withdrawal).\n\n3. **Calculate the Average**:\n   - Compute the average of the `amount` field from the filtered transactions in the `trans` table (T4).\n\nThe result will be the average amount of credit card transactions made by account holders in a month during the year 1998."
        ]
    },
    "533": {
        "sql": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
        "question": "How many users last accessed the website after 2014/9/1?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
        "explain": "last accessed after 2014/9/1 refers to LastAccessDate > '2014-09-01'",
        "solution": [
            "To determine how many users last accessed the website after September 1, 2014, follow these steps:\n\n1. **Identify the Table**: The data is stored in the \"users\" table.\n2. **Filter the Records**: From the \"users\" table, filter out only those records where the \"LastAccessDate\" (converted to a date format) is later than '2014-09-01'.\n3. **Count the Records**: Count the number of user IDs (\"Id\") that meet the above condition.\n\nThe result will be the total number of users who accessed the website after September 1, 2014.",
            "To determine how many users last accessed the website after September 1, 2014, follow these detailed steps:\n\n1. **Identify the Table**: The data is stored in the \"users\" table, which contains user information including their last access dates.\n\n2. **Filter the Records**: From the \"users\" table, filter out only those records where the \"LastAccessDate\" column (converted to a date format using the `date` function) is later than the date '2014-09-01'.\n\n3. **Count the Records**: Count the number of unique user IDs (\"Id\") that meet the above condition. This count will represent the total number of users who accessed the website after September 1, 2014.\n\nThe SQL query `SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'` precisely performs these operations to provide the desired result."
        ]
    },
    "1155": {
        "sql": "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.LDH > 500;",
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "explain": "LDH beyond normal range refers to LDH > '500';",
        "solution": []
    },
    "782": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id\nWHERE eye_colour.colour = 'Black' AND hair_colour.colour = 'Black';",
        "question": "List the heroes' names whose eyes and hair colours are both black.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id WHERE T2.colour = 'Black'",
        "explain": "heroes' names refers to superhero_name; eyes and hair colours are both black refers to eye_colour_id AND hair_colour_id WHERE colour.colour = 'Black';",
        "solution": []
    },
    "639": {
        "sql": "SELECT (CAST(SUM(CASE WHEN T3.TagName = 'r' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)) AS Percentage\nFROM users T1\nJOIN postHistory T2 ON T1.Id = T2.UserId\nLEFT JOIN tags T3 ON T3.ExcerptPostId = T2.PostId\nWHERE T1.DisplayName = 'Community';",
        "question": "Based on posts posted by Community, calculate the percentage of posts that use the R language.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId WHERE T1.DisplayName = 'Community'",
        "explain": "DIVIDE(COUNT(PostId WHERE TagName = 'r')), (COUNT(PostId WHERE DisplayName = 'Community')) as percentage; R language refers to tagname = 'r'",
        "solution": [
            "To calculate the percentage of posts that use the R language and are posted by the user 'Community', follow these steps:\n\n1. **Identify the User**: Locate the user with the display name 'Community' in the `users` table.\n2. **Retrieve Post History**: For this user, retrieve all posts from the `postHistory` table where the user ID matches the user ID in the `users` table.\n3. **Check for R Language Tags**: For each post in the post history, check if it is associated with the tag 'r' in the `tags` table. This is done by matching the `ExcerptPostId` in the `tags` table with the `PostId` in the `postHistory` table.\n4. **Count Total Posts**: Count the total number of posts by the 'Community' user.\n5. **Count R Language Posts**: Count how many of these posts are tagged with 'r'.\n6. **Calculate Percentage**: Divide the count of R language posts by the total number of posts, multiply by 100 to get the percentage, and cast the result to a real number for precision.\n\nThe final result is the percentage of posts by 'Community' that use the R language.",
            "To calculate the percentage of posts that use the R language and are posted by the user 'Community', follow these steps:\n\n1. **Identify the User**: Locate the user with the display name 'Community' in the `users` table (referred to as `T1` in the SQL).\n2. **Retrieve Post History**: For this user, retrieve all posts from the `postHistory` table (referred to as `T2` in the SQL) where the user ID matches the user ID in the `users` table (`T1.Id = T2.UserId`).\n3. **Check for R Language Tags**: For each post in the post history, check if it is associated with the tag 'r' in the `tags` table (referred to as `T3` in the SQL). This is done by matching the `ExcerptPostId` in the `tags` table with the `PostId` in the `postHistory` table (`T3.ExcerptPostId = T2.PostId`).\n4. **Count Total Posts**: Count the total number of posts by the 'Community' user (`COUNT(T1.Id)`).\n5. **Count R Language Posts**: Count how many of these posts are tagged with 'r' (`SUM(IIF(T3.TagName = 'r', 1, 0))`).\n6. **Calculate Percentage**: Divide the count of R language posts by the total number of posts, multiply by 100 to get the percentage, and cast the result to a real number for precision (`CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) * 100 / COUNT(T1.Id)`).\n\nThe final result is the percentage of posts by 'Community' that use the R language."
        ]
    },
    "418": {
        "sql": "SELECT availability FROM cards WHERE artist = 'Daren Bader';",
        "question": "What kind of printing is on the card that Daren Bader created?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT availability FROM cards WHERE artist = 'Daren Bader'",
        "explain": "kind of printing refers to availability; Daren Bader created refers to artist = 'Daren Bader'",
        "solution": []
    },
    "447": {
        "sql": "SELECT T2.setCode FROM sets T1 JOIN set_translations T2 ON T1.code = T2.setCode WHERE T1.type = 'commander';",
        "question": "Give the code of sets have expansion commander type?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
        "explain": "code of sets refers to setCode",
        "solution": [
            "To find the set codes of sets that have the expansion type 'commander', follow these steps:\n\n1. **Join the tables**: Combine the `sets` table (referred to as T1) with the `set_translations` table (referred to as T2) using the `setCode` column from T2 and the `code` column from T1. This ensures that only matching records between the two tables are considered.\n\n2. **Filter the records**: From the joined tables, filter the records to include only those where the `type` column in the `sets` table (T1) is equal to 'commander'.\n\n3. **Select the desired column**: Finally, retrieve the `setCode` column from the `set_translations` table (T2) for the filtered records. This column contains the codes of the sets that meet the criteria.\n\nThe result will be a list of set codes for sets that are of the 'commander' type."
        ]
    },
    "1333": {
        "sql": "SELECT z.city, z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.position = 'President';",
        "question": "What city and state did the President of the Student_Club grow up?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.city, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.position = 'President'",
        "explain": "'President' is a position of Student Club;",
        "solution": []
    },
    "763": {
        "sql": "SELECT T2.attribute_value\nFROM superhero T1\nJOIN hero_attribute T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Abomination';",
        "question": "Indicate the attribute value of superhero Abomination.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Abomination'",
        "explain": "Abomination refers to superhero_name = 'Abomination';",
        "solution": [
            "To find the attribute value of the superhero named 'Abomination', follow these steps:\n1. Start with the `superhero` table (referred to as T1) and the `hero_attribute` table (referred to as T2).\n2. Join these two tables using the condition that the `id` column in the `superhero` table (T1) matches the `hero_id` column in the `hero_attribute` table (T2).\n3. Filter the joined data to only include rows where the `superhero_name` in the `superhero` table (T1) is 'Abomination'.\n4. From the filtered result, select the `attribute_value` column from the `hero_attribute` table (T2).\n\nThis process will retrieve the attribute value associated with the superhero 'Abomination'."
        ]
    },
    "1169": {
        "sql": "WITH MaleAbnormalUA AS (\n    SELECT COUNT(DISTINCT P.ID) AS MaleCount\n    FROM Patient P\n    JOIN Laboratory L ON P.ID = L.ID\n    WHERE P.SEX = 'M' AND L.UA <= 8.0\n),\nFemaleAbnormalUA AS (\n    SELECT COUNT(DISTINCT P.ID) AS FemaleCount\n    FROM Patient P\n    JOIN Laboratory L ON P.ID = L.ID\n    WHERE P.SEX = 'F' AND L.UA <= 6.5\n)\nSELECT MaleCount, FemaleCount, \n       CASE \n           WHEN FemaleCount = 0 THEN NULL\n           ELSE CAST(MaleCount AS REAL) / FemaleCount\n       END AS MaleToFemaleRatio\nFROM MaleAbnormalUA, FemaleAbnormalUA;",
        "question": "What is the ratio of male to female patients among all those with abnormal uric acid counts?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "explain": "male refers to SEX = 'M'; female refers to SEX = 'F'; abnormal uric acid refers to UA < = '8.0' where SEX = 'M', UA < = '6.5' where SEX = 'F'; calculation = DIVIDE(SUM(UA <= '8.0' and SEX = 'M'), SUM(UA <= '6.5 and SEX = 'F'))",
        "solution": [
            "To determine the ratio of male to female patients among all those with abnormal uric acid counts, follow these steps:\n\n1. **Identify Patients with Abnormal Uric Acid Levels**:\n   - For males, abnormal uric acid levels are defined as values less than or equal to 8.0.\n   - For females, abnormal uric acid levels are defined as values less than or equal to 6.5.\n\n2. **Count Male Patients with Abnormal Uric Acid**:\n   - From the `Patient` table (T1), filter records where the `SEX` is 'M' (male).\n   - Join these records with the `Laboratory` table (T2) on the `ID` field to access uric acid (UA) values.\n   - Count the number of male patients where the uric acid (UA) is less than or equal to 8.0.\n\n3. **Count Female Patients with Abnormal Uric Acid**:\n   - From the `Patient` table (T1), filter records where the `SEX` is 'F' (female).\n   - Join these records with the `Laboratory` table (T2) on the `ID` field to access uric acid (UA) values.\n   - Count the number of female patients where the uric acid (UA) is less than or equal to 6.5.\n\n4. **Calculate the Ratio**:\n   - Divide the count of male patients with abnormal uric acid by the count of female patients with abnormal uric acid to get the ratio.\n\nThis process ensures that the ratio is calculated accurately based on the specified criteria for abnormal uric acid levels for each gender.",
            "To determine the ratio of male to female patients among all those with abnormal uric acid counts, follow these steps:\n\n1. **Identify Patients with Abnormal Uric Acid Levels**:\n   - For males, abnormal uric acid levels are defined as values less than or equal to 8.0.\n   - For females, abnormal uric acid levels are defined as values less than or equal to 6.5.\n\n2. **Count Male Patients with Abnormal Uric Acid**:\n   - From the `Patient` table (T1), filter records where the `SEX` is 'M' (male).\n   - Join these records with the `Laboratory` table (T2) on the `ID` field to access uric acid (UA) values.\n   - Count the number of male patients where the uric acid (UA) is less than or equal to 8.0.\n\n3. **Count Female Patients with Abnormal Uric Acid**:\n   - From the `Patient` table (T1), filter records where the `SEX` is 'F' (female).\n   - Join these records with the `Laboratory` table (T2) on the `ID` field to access uric acid (UA) values.\n   - Count the number of female patients where the uric acid (UA) is less than or equal to 6.5.\n\n4. **Calculate the Ratio**:\n   - Divide the count of male patients with abnormal uric acid by the count of female patients with abnormal uric acid to get the ratio.\n\nThis process ensures that the ratio is calculated accurately based on the specified criteria for abnormal uric acid levels for each gender."
        ]
    },
    "992": {
        "sql": "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND strftime('%Y', dob) BETWEEN '1971' AND '1985' ORDER BY dob DESC;",
        "question": "Find the full name, Wiki Pedia page link, and date of birth of German drivers born between 1971 and 1985. List it in descending order of date of birth.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND STRFTIME('%Y', dob) BETWEEN '1971' AND '1985' ORDER BY dob DESC",
        "explain": "FFull name refers to forname+surname; Nationality refers to German; Date of birth refers to dob; year(dob) BETWEEN '1971' AND '1985'",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Select the required fields**: Retrieve the `forename`, `surname`, `url`, and `dob` (date of birth) from the `drivers` table.\n\n2. **Filter by nationality**: Include only those drivers whose `nationality` is 'German'.\n\n3. **Filter by date of birth**: Further narrow down the results to include only drivers born between the years 1971 and 1985. This is done by extracting the year from the `dob` field and checking if it falls within the specified range.\n\n4. **Order the results**: Sort the final list in descending order based on the `dob` (date of birth) field to display the most recent births first.\n\nThis sequence of operations ensures that the output matches the requirements of the question."
        ]
    },
    "1266": {
        "sql": "SELECT p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.RNP IS NOT NULL AND l.RNP != ''\nORDER BY p.Birthday DESC\nLIMIT 1;",
        "question": "Which is the youngest patient with an abnormal anti-ribonuclear protein level? Please list his or her date of birth.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP != '-' OR '+-' ORDER BY T1.Birthday DESC LIMIT 1",
        "explain": "youngest patient refers to MAX(Birthday); abnormal anti-ribonuclear protein level refers to RNP NOT IN('-', '+-'); date of birth refers to Birthday;",
        "solution": []
    },
    "623": {
        "sql": "SELECT COUNT(DISTINCT u.Id) AS ElderSupporters\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE u.Age > 65 AND b.Name = 'Supporter';",
        "question": "How many elders obtained the \"Supporter\" badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Age > 65 AND T2.Name = 'Supporter'",
        "explain": "\"Supporter\" is the Name of badge;\u00a0 elders refers to Age > 65",
        "solution": []
    },
    "96": {
        "sql": "SELECT COUNT(DISTINCT c.client_id) AS customer_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'OWNER';",
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK TYDNE'",
        "explain": "'POPLATEK TYDNE' stands for weekly issuance",
        "solution": []
    },
    "281": {
        "sql": "SELECT DISTINCT a.element \nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+' \nAND SUBSTR(a.atom_id, -1) = '4' \nAND LENGTH(a.atom_id) = 7;",
        "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
        "explain": "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; ",
        "solution": [
            "To solve the question, we need to tally the toxicology element of the 4th atom of each molecule that was carcinogenic. Here are the detailed steps:\n\n1. **Identify Carcinogenic Molecules**: First, filter the molecules that are labeled as carcinogenic (denoted by the label '+').\n\n2. **Locate the 4th Atom**: For each of these carcinogenic molecules, identify the atom where the last character of the `atom_id` is '4' and the length of the `atom_id` is 7. This ensures we are looking at the 4th atom.\n\n3. **Retrieve the Element**: Extract the `element` from these identified atoms.\n\n4. **Ensure Uniqueness**: Finally, ensure that the elements retrieved are distinct to avoid duplicates in the tally.\n\nThis process translates directly to the SQL query provided, which joins the `atom` and `molecule` tables, filters for carcinogenic molecules, and checks for the 4th atom based on the `atom_id` criteria before selecting the distinct elements."
        ]
    },
    "366": {
        "sql": "SELECT T2.format FROM cards T1 JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight';",
        "question": "What is the rule of playing card \"Benalish Knight\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "explain": "Benalish Knight' is the name of card; rule of playing card refers to format;",
        "solution": [
            "To find the rule of the playing card \"Benalish Knight,\" the database performs the following operations:\n\n1. It starts by accessing the \"cards\" table (aliased as T1) to locate the card with the name \"Benalish Knight.\"\n2. It then joins this result with the \"legalities\" table (aliased as T2) using the \"uuid\" field as the common key between the two tables.\n3. From the joined tables, it selects the \"format\" column from the \"legalities\" table (T2), which contains the rule or legality information for the card \"Benalish Knight.\"\n\nThis operation ensures that the rule for the specific card is retrieved accurately by matching the card's unique identifier (uuid) across both tables."
        ]
    },
    "1069": {
        "sql": "SELECT player_name FROM Player ORDER BY height ASC LIMIT 1;",
        "question": "Which football player has the shortest height?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM player ORDER BY height ASC LIMIT 1",
        "explain": "shortest height refers to MIN(height);",
        "solution": [
            "To find the football player with the shortest height, the database performs the following operations:\n\n1. **Retrieve Data**: The database accesses the `player` table to gather information about all football players.\n\n2. **Sort by Height**: The players are then sorted in ascending order based on their height. This means the player with the smallest height will appear at the top of the list.\n\n3. **Limit Results**: Only the top result (the first player in the sorted list) is selected, as this will be the player with the shortest height.\n\n4. **Return Player Name**: Finally, the name of this player is returned as the result of the query."
        ]
    },
    "339": {
        "sql": "SELECT a.atom_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+' AND a.element = 'o';",
        "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
        "explain": "label = '+' mean molecules are carcinogenic; oxygen refers to element = 'o'",
        "solution": []
    },
    "1028": {
        "sql": "SELECT t.team_long_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nWHERE l.name = 'Scotland Premier League'\n  AND m.season = '2009/2010'\n  AND m.away_team_goal > m.home_team_goal\nGROUP BY m.away_team_api_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "explain": "Final result should return the Team.team_long_name; Scotland Premier League refers to League.name = 'Scotland Premier League'; away team refers to away_team_api_id; away team that won the most refers to MAX(SUBTRACT(away_team_goal, home_team_goal) > 0); 2010 season refers to season = '2009/2010'; won the most refers to MAX(COUNT(*));",
        "solution": []
    },
    "745": {
        "sql": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek';",
        "question": "Give the publisher ID of Star Trek.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
        "explain": "Star Trek is the publisher_name;",
        "solution": []
    },
    "230": {
        "sql": "SELECT a.element, m.label FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR060';",
        "question": "What are the elements of the toxicology and label of molecule TR060?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'",
        "explain": "TR060 is the molecule id; ",
        "solution": []
    },
    "653": {
        "sql": "SELECT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ViewCount = (SELECT MAX(ViewCount) FROM posts);",
        "question": "What is the owner's display name of the most popular post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "explain": "Higher view count means the post has higher popularity; the most popular post refers to MAX(ViewCount);",
        "solution": []
    },
    "127": {
        "sql": "SELECT account_id FROM account WHERE frequency = 'POPLATEK MESICNE';",
        "question": "List the account IDs with monthly issuance of statements.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT account_id FROM account WHERE Frequency = 'POPLATEK MESICNE'",
        "explain": "'POPLATEK MESICNE' stands for monthly issuance",
        "solution": []
    },
    "329": {
        "sql": "SELECT a.molecule_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+'\nGROUP BY a.molecule_id\nORDER BY COUNT(a.atom_id) DESC\nLIMIT 1;",
        "question": "Which carcinogenic molecule have the highest number of atoms consisted in it?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T2.molecule_id, COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T2.molecule_id ORDER BY COUNT(T1.atom_id) DESC LIMIT 1 ) t",
        "explain": "label = '+' mean molecules are carcinogenic; molecule that have the highest number of atoms consisted in in refers to MAX(COUNT(atom.molecule_id))",
        "solution": []
    },
    "300": {
        "sql": "SELECT atom_id FROM atom WHERE molecule_id = 'TR186';",
        "question": "What atoms comprise TR186?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id = 'TR186'",
        "explain": "TR186 is a molecule id",
        "solution": [
            "To find out which atoms comprise the molecule with the ID 'TR186', you need to retrieve the atom IDs from the 'atom' table where the molecule ID matches 'TR186'. The operation involves querying the 'atom' table and filtering the records to only include those where the 'molecule_id' column equals 'TR186'. The result will be a list of all atom IDs that belong to this molecule."
        ]
    },
    "597": {
        "sql": "SELECT COUNT(DISTINCT u.Id) \nFROM users u \nJOIN badges b ON u.Id = b.UserId \nWHERE u.Location = 'India' AND b.Name = 'Teacher';",
        "question": "How many users from India have the teacher badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Location = 'India' AND T1.Name = 'Teacher'",
        "explain": "\"India\" is the Location; \"Teacher\" is the Name of badge",
        "solution": []
    },
    "1447": {
        "sql": "SELECT e.event_name, e.location FROM event e JOIN budget b ON e.event_id = b.link_to_event WHERE b.spent < b.amount;",
        "question": "List the name and location of events that underspend its budget.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.event_name, T1.location FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 0",
        "explain": "name of event refers to event_name; underspend its budget refers to remaining > 0",
        "solution": []
    },
    "1079": {
        "sql": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "question": "Which player is the tallest?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "explain": "tallest player refers to MAX(height);",
        "solution": [
            "To find the tallest player, retrieve the player names from the 'Player' table, order them by their height in descending order, and then select the top result (the player with the maximum height).",
            "To determine the tallest player, execute the following steps:\n1. Access the 'Player' table in the database.\n2. Retrieve the 'player_name' column, which contains the names of the players.\n3. Sort the players in descending order based on their 'height' column to arrange them from tallest to shortest.\n4. Limit the result to only the first row, which will be the tallest player due to the descending order.\n\nThe SQL query `SELECT player_name FROM Player ORDER BY height DESC LIMIT 1` precisely performs these operations to identify the tallest player."
        ]
    },
    "572": {
        "sql": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';",
        "question": "How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'",
        "explain": "\"Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer\" is the Title of post; views refers to ViewCount",
        "solution": []
    },
    "798": {
        "sql": "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');",
        "question": "What is the publisher for Hawkman, Karate Kid and Speedy?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')",
        "explain": "publisher refers to publisher_name; Hawkman refers to superhero_name = 'Hawkman'; Karate Kid refers to superhero_name = 'Karate Kid'; Speedy refers to superhero_name = 'Speedy';",
        "solution": [
            "To find the publisher for the superheroes Hawkman, Karate Kid, and Speedy, follow these steps:\n\n1. **Identify the relevant tables**: The information is stored in two tables:\n   - `superhero` (referred to as T1 in the SQL), which contains details about superheroes, including their names and publisher IDs.\n   - `publisher` (referred to as T2 in the SQL), which contains details about publishers, including their names and IDs.\n\n2. **Join the tables**: Link the `superhero` table (T1) with the `publisher` table (T2) using the `publisher_id` field from the `superhero` table and the `id` field from the `publisher` table. This ensures that each superhero is matched with their respective publisher.\n\n3. **Filter the superheroes**: From the joined tables, filter the records to include only those superheroes whose names are 'Hawkman', 'Karate Kid', or 'Speedy'.\n\n4. **Retrieve the publisher names**: Finally, extract the `publisher_name` from the `publisher` table (T2) for the filtered superheroes.\n\nThe result will be a list of publisher names corresponding to the specified superheroes."
        ]
    },
    "454": {
        "sql": "SELECT COUNT(*) AS count_unknown_power\nFROM cards\nWHERE borderColor = 'white' AND (power = '*' OR power IS NULL);",
        "question": "Among the cards with a white border color, how many of them have unknown power?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE borderColor = 'white'",
        "explain": "unknown power refers to power = '*' or power is null",
        "solution": [
            "To solve the question, 'Among the cards with a white border color, how many of them have unknown power?', the following steps are performed:\n\n1. **Filter the cards**: First, select all cards from the database where the `borderColor` is 'white'.\n\n2. **Check for unknown power**: For each of these cards, determine if the `power` field contains an asterisk ('*') or is `NULL`. These conditions indicate that the power is unknown.\n\n3. **Count the matches**: Sum up the number of cards that meet the above condition. This gives the total count of cards with a white border color and unknown power.\n\nThe SQL query accomplishes this by using a `CASE` statement within a `SUM` function to count the relevant cards.",
            "To solve the question, 'Among the cards with a white border color, how many of them have unknown power?', the following detailed steps are performed:\n\n1. **Filter the cards by border color**: The database is queried to retrieve all cards where the `borderColor` field is exactly 'white'. This isolates the subset of cards that meet the initial condition.\n\n2. **Identify unknown power**: For each card in the filtered subset, the `power` field is examined. A card is considered to have unknown power if either of the following is true:\n   - The `power` field contains an asterisk ('*'), which is a common placeholder for unknown values.\n   - The `power` field is `NULL`, indicating the absence of a recorded value.\n\n3. **Count the qualifying cards**: A conditional count is performed. For each card, if the `power` field meets either of the unknown power conditions (contains '*' or is `NULL`), it is counted as 1; otherwise, it is counted as 0. The `SUM` function aggregates these counts to produce the total number of cards with a white border color and unknown power.\n\nThe SQL query effectively combines these steps into a single operation, using a `CASE` statement within the `SUM` function to evaluate and count the cards dynamically."
        ]
    },
    "273": {
        "sql": "SELECT (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS percentage\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+';",
        "question": "What is the percentage of element chlorine in carcinogenic molecules?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT( CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "explain": "chlorine refers to element = 'cl'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(element = 'pb'); COUNT(molecule_id)) as percentage where label = '+'",
        "solution": []
    },
    "1357": {
        "sql": "SELECT i.date_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.first_name = 'Connor' AND m.last_name = 'Hilton';",
        "question": "State the date Connor Hilton paid his/her dues.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Connor' AND T1.last_name = 'Hilton' AND T2.source = 'Dues'",
        "explain": "Connor Hilton is the full name; full name refers to first_name, last_name; date the dues was paid refers to date_received where source = 'Dues';",
        "solution": []
    },
    "1104": {
        "sql": "SELECT pa.potential \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Francesco Parravicini' \nAND pa.date = '2010-08-30 00:00:00';",
        "question": "What was the potiential for Francesco Parravicini on 2010/8/30?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2010-08-30' AND t1.player_name = 'Francesco Parravicini'",
        "explain": "Francesco Parravicini refers to player_name = 'Francesco Parravicini'; on 2010/8/30 refers to date = '2010-08-30 00:00:00'",
        "solution": []
    },
    "1184": {
        "sql": "SELECT e.Symptoms\nFROM Patient p\nJOIN Examination e ON p.ID = e.ID\nWHERE p.Birthday = '1959-03-01'\nAND e.`Examination Date` = '1993-09-27';",
        "question": "For the patient whose birthday was 1959/3/1, what symptoms did he/she have during the examination on 1993/9/27?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-03-01' AND T2.`Examination Date` = '1993-09-27'",
        "explain": "",
        "solution": []
    },
    "426": {
        "sql": "SELECT name FROM sets WHERE mtgoCode IS NULL OR mtgoCode = '' ORDER BY name ASC LIMIT 3;",
        "question": "Please provide top three sets that don't appear in Magic: The Gathering Online, along with their names in in alphabetical order.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3",
        "explain": "don't appear in Magic: The Gathering Online refers to mtgoCode is NULL or mtgoCode = ''",
        "solution": []
    },
    "740": {
        "sql": "SELECT COUNT(DISTINCT s.id) AS female_heroes_with_strength_100\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE g.gender = 'Female'\nAND a.attribute_name = 'Strength'\nAND ha.attribute_value = 100;",
        "question": "How many female superheroes have a strength value of 100?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.attribute_name = 'Strength' AND T2.attribute_value = 100 AND T4.gender = 'Female'",
        "explain": "female refers to gender = 'Female'; strength value of 100 refers to attribute_name = 'Strength' AND attribute_value = 100",
        "solution": []
    },
    "662": {
        "sql": "SELECT COUNT(DISTINCT p.Id) \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE strftime('%Y', v.CreationDate) = '2011' \nAND v.BountyAmount = 50;",
        "question": "How many posts with votes that were created in 2011 have a bounty of 50?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.BountyAmount = 50 AND STRFTIME('%Y', T2.CreationDate) = '2011'",
        "explain": "created in 2012 refers YEAR(CreationDate) = 2011; BountyAmount = 50;",
        "solution": []
    },
    "141": {
        "sql": "SELECT a.district_id\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE strftime('%Y', t.date) = '1997'\nGROUP BY a.district_id\nHAVING SUM(t.amount) > 10000;",
        "question": "Which districts have transactions greater than USS$10,000 in 1997?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date) = '1997' GROUP BY T1.district_id HAVING SUM(T3.amount) > 10000",
        "explain": "",
        "solution": [
            "To find the districts with transactions greater than US$10,000 in 1997, follow these steps:\n\n1. **Join the Tables**: Combine the `account`, `district`, and `trans` tables. Link the `account` table to the `district` table using the `district_id` field, and link the `account` table to the `trans` table using the `account_id` field.\n\n2. **Filter by Year**: From the `trans` table, filter the transactions to include only those where the year extracted from the `date` field is '1997'.\n\n3. **Group by District**: Group the filtered transactions by the `district_id` from the `account` table.\n\n4. **Calculate Total Transactions**: For each district, calculate the sum of the `amount` field from the `trans` table.\n\n5. **Filter by Amount**: Only include districts where the total sum of transactions exceeds $10,000.\n\n6. **Return Results**: Return the `district_id` of the districts that meet the criteria.\n\nThis process ensures that only districts with transactions totaling more than US$10,000 in 1997 are identified."
        ]
    },
    "547": {
        "sql": "SELECT COUNT(*) AS NumberOfPosts\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.Age > 65 AND p.Score >= 20;",
        "question": "Among the posts owned by an elder user, how many of them have a score of over 19?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score >= 20 AND T2.Age > 65",
        "explain": "elder users refers to Age > 65; Score of over 19 refers to Score > = 20",
        "solution": []
    },
    "1291": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' \nAND T2.ALB > 3.5 AND T2.ALB < 5.5 \nAND T2.TP >= 6.0 AND T2.TP <= 8.5;",
        "question": "How many male patients have a normal level of both albumin and total protein?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M'  AND T2.ALB > 3.5 AND T2.ALB < 5.5 AND T2.TP BETWEEN 6.0 AND 8.5",
        "explain": "male refers to Sex = 'M'; normal level of both albumin and total protein refers to ALB > 3.5 and ALB < 5.5 AND TP between 6.0 and 8.5;",
        "solution": [
            "To solve the question \"How many male patients have a normal level of both albumin and total protein?\", the following steps are performed:\n\n1. **Identify the Tables**: The query involves two tables, `Patient` (referred to as `T1`) and `Laboratory` (referred to as `T2`).\n\n2. **Join the Tables**: The `Patient` table is joined with the `Laboratory` table using the common column `ID` to link patient records with their laboratory results.\n\n3. **Filter by Gender**: Only male patients are considered, so the query filters records where the `SEX` column in the `Patient` table is 'M'.\n\n4. **Filter by Albumin Levels**: The query checks for normal albumin levels, which are defined as greater than 3.5 and less than 5.5. This is done by filtering the `ALB` column in the `Laboratory` table.\n\n5. **Filter by Total Protein Levels**: The query also checks for normal total protein levels, which are defined as between 6.0 and 8.5. This is done by filtering the `TP` column in the `Laboratory` table.\n\n6. **Count the Results**: Finally, the query counts the number of patient IDs (`ID` column in the `Patient` table) that meet all the above criteria.\n\nThe result of this query is the count of male patients who have both albumin and total protein levels within the specified normal ranges.",
            "To solve the question \"How many male patients have a normal level of both albumin and total protein?\", the following detailed steps are performed:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (referred to as `T1`): Contains patient information, including gender.\n   - `Laboratory` (referred to as `T2`): Contains laboratory test results, including albumin (`ALB`) and total protein (`TP`) levels.\n\n2. **Join the Tables**: The `Patient` table (`T1`) is joined with the `Laboratory` table (`T2`) using the common column `ID`. This links each patient's demographic information with their laboratory results.\n\n3. **Filter by Gender**: The query filters records to include only male patients by checking the `SEX` column in the `Patient` table (`T1`) for the value 'M'.\n\n4. **Filter by Albumin Levels**: The query checks for normal albumin levels by filtering the `ALB` column in the `Laboratory` table (`T2`). Normal albumin levels are defined as greater than 3.5 and less than 5.5.\n\n5. **Filter by Total Protein Levels**: The query checks for normal total protein levels by filtering the `TP` column in the `Laboratory` table (`T2`). Normal total protein levels are defined as between 6.0 and 8.5 (inclusive).\n\n6. **Count the Results**: The query counts the number of distinct patient IDs (`ID` column in the `Patient` table) that satisfy all the above conditions. This count represents the number of male patients with both albumin and total protein levels within the specified normal ranges.\n\nThe final result of the query is the count of such male patients."
        ]
    },
    "244": {
        "sql": "WITH double_bond_counts AS (\n  SELECT molecule_id, COUNT(*) AS double_bond_count\n  FROM bond\n  WHERE bond_type = '='\n  GROUP BY molecule_id\n  ORDER BY double_bond_count DESC\n  LIMIT 1\n)\nSELECT m.label\nFROM double_bond_counts dbc\nJOIN molecule m ON dbc.molecule_id = m.molecule_id;",
        "question": "Is the molecule with the most double bonds carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
        "explain": "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic",
        "solution": [
            "To determine if the molecule with the most double bonds is carcinogenic, follow these steps:\n\n1. **Identify the molecule with the most double bonds**:\n   - From the `bond` table, filter records where the `bond_type` is '=' (indicating a double bond).\n   - Group these records by `molecule_id` and count the number of double bonds for each molecule.\n   - Order the results by the count of double bonds in descending order.\n   - Select the molecule with the highest count (using `LIMIT 1`).\n\n2. **Retrieve the label of the identified molecule**:\n   - Join the result from the previous step with the `molecule` table using the `molecule_id`.\n   - Select the `label` from the `molecule` table for the identified molecule.\n\nThis process ensures you find the molecule with the most double bonds and then check its label to determine if it is carcinogenic."
        ]
    },
    "1296": {
        "sql": "SELECT T3.ANA\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nJOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" < 2.0\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;",
        "question": "What is the anti-nucleus antibody concentration of the patient whose total bilirubin is the highest in the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T3.ANA FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` < 2.0 ORDER BY T2.`T-BIL` DESC LIMIT 1",
        "explain": "anti-nucleus antibody concentration refers to ANA; total bilirubin is the highest in the normal range refers to MAX(`T-BIL` < 2.0);",
        "solution": [
            "To find the anti-nucleus antibody (ANA) concentration of the patient whose total bilirubin (T-BIL) is the highest within the normal range, follow these steps:\n\n1. **Identify the Normal Range for Total Bilirubin**: The normal range for total bilirubin is defined as values less than 2.0.\n\n2. **Filter Patients by Normal Total Bilirubin**: From the `Patient` table, join it with the `Laboratory` table using the patient ID to filter only those patients whose total bilirubin (T-BIL) is within the normal range (i.e., less than 2.0).\n\n3. **Sort Patients by Total Bilirubin**: Sort these patients in descending order of their total bilirubin values to find the patient with the highest total bilirubin within the normal range.\n\n4. **Retrieve the Top Patient**: Select the top patient from this sorted list (the one with the highest total bilirubin).\n\n5. **Join with Examination Table**: Join the result with the `Examination` table using the patient ID to access the anti-nucleus antibody (ANA) concentration for this patient.\n\n6. **Return the ANA Concentration**: Finally, retrieve the ANA concentration of this patient as the answer to the question.",
            "To determine the anti-nucleus antibody (ANA) concentration of the patient whose total bilirubin (T-BIL) is the highest within the normal range, the following steps are executed:\n\n1. **Join Tables**: The `Patient` table (`T1`) is joined with the `Laboratory` table (`T2`) using the patient ID (`T1.ID = T2.ID`). This ensures that each patient's laboratory results are linked to their personal data.\n\n2. **Filter by Normal Total Bilirubin**: From the joined tables, only patients whose total bilirubin (`T2.\"T-BIL\"`) is less than 2.0 (the upper limit of the normal range) are selected (`T2.\"T-BIL\" < 2.0`).\n\n3. **Sort by Total Bilirubin**: The filtered patients are then sorted in descending order of their total bilirubin values (`ORDER BY T2.\"T-BIL\" DESC`). This places the patient with the highest total bilirubin within the normal range at the top of the list.\n\n4. **Limit to Top Patient**: The query limits the result to only the top patient (`LIMIT 1`), ensuring only the patient with the highest total bilirubin is considered.\n\n5. **Join with Examination Table**: The result is further joined with the `Examination` table (`T3`) using the patient ID (`T1.ID = T3.ID`). This links the patient's examination data, including the anti-nucleus antibody (ANA) concentration.\n\n6. **Retrieve ANA Concentration**: Finally, the query selects the ANA concentration (`T3.ANA`) from the `Examination` table for the identified patient, providing the answer to the question."
        ]
    },
    "1143": {
        "sql": "SELECT MAX(home_team_goal) AS highest_home_score\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Netherlands Eredivisie');",
        "question": "What was the highest score of the home team in the Netherlands Eredivisie league?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT MAX(t2.home_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Netherlands Eredivisie'",
        "explain": "highest score of the home team refers to MAX(home_team_goal)",
        "solution": []
    },
    "1195": {
        "sql": "SELECT AVG(l.ALB) AS average_albumin_level\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.SEX = 'F'\nAND (p.Diagnosis = 'SLE' OR EXISTS (SELECT 1 FROM Examination e WHERE e.ID = p.ID AND e.Diagnosis = 'SLE'))\nAND l.PLT > 400;",
        "question": "What is the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.ALB) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 400 AND T1.Diagnosis = 'SLE' AND T1.SEX = 'F'",
        "explain": "average blood albumin level refers to AVG(ALB); female refers to SEX = 'F'; PLT greater than 400 refers to PLT > 400; diagnosed with SLE refers to Diagnosis= 'SLE'",
        "solution": []
    },
    "1240": {
        "sql": "SELECT AVG(HCT) AS average_hematocrit_below_normal \nFROM Laboratory \nWHERE Date LIKE '1991%' AND HCT < 29;",
        "question": "From laboratory examinations in 1991, what is the average hematoclit level that is lower than the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.HCT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HCT < 29 AND STRFTIME('%Y', T2.Date) = '1991'",
        "explain": "laboratory examinations in 1991 refers to Date like '1991%'; average hematoclit level = AVG(HCT); hematoclit level that is lower than the normal range refers to HCT < 29;",
        "solution": []
    },
    "170": {
        "sql": "SELECT COUNT(*) AS credit_card_withdrawals_after_1995\nFROM trans\nWHERE operation = 'VYBER KARTOU' AND date > '1995-12-31';",
        "question": "How many credit card withdrawals were recorded after 1995?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
        "explain": "Operation = 'VYBER KARTOU' means credit card withdrawals",
        "solution": []
    },
    "278": {
        "sql": "SELECT COUNT(DISTINCT b.molecule_id) \nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '-' AND m.label = '-';",
        "question": "How many of the single bond type molecules are non-carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
        "explain": "label = '-' means molecules are non-carcinogenic; single bond refers to bond_type = '-';",
        "solution": []
    },
    "901": {
        "sql": "SELECT races.name AS race_name, circuits.name AS circuit_name, circuits.location\nFROM races\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE races.date BETWEEN '2005-09-01' AND '2005-09-30'",
        "question": "Name the races along with its circuit name and location for f1 races hosted in September 2005.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name, T1.name, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2005 AND STRFTIME('%m', T2.date) = '09'",
        "explain": "in September 2005 refers to MONTH(date) = 9 and YEAR(date) = 2005",
        "solution": []
    },
    "87": {
        "sql": "SELECT DISTINCT T2.AdmEmail1, T2.AdmEmail2\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'San Bernardino'\n  AND T2.City = 'San Bernardino'\n  AND T2.DOC = '54'\n  AND T2.OpenDate BETWEEN '2009-01-01' AND '2010-12-31'\n  AND T2.SOC = '62'\n  AND (T2.AdmEmail1 IS NOT NULL OR T2.AdmEmail2 IS NOT NULL);",
        "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
        "explain": "Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; years between 2009 and 2010 can refer to 'between 1/1/2009 to 12/31/2010'",
        "solution": [
            "To find the valid email addresses of the administrators for the specified schools, follow these steps:\n\n1. **Join the Tables**: Combine the data from the `frpm` table (referred to as `T1`) and the `schools` table (referred to as `T2`) using the `CDSCode` field as the common key.\n\n2. **Filter by Location**: Narrow down the results to schools located in San Bernardino County and the city of San Bernardino by checking the `County` and `City` fields in the `schools` table (`T2`).\n\n3. **Filter by District**: Ensure the schools belong to the San Bernardino City Unified district by checking the `DOC` field in the `schools` table (`T2`) for the value `54`.\n\n4. **Filter by Opening Date**: Select schools that opened between January 1, 2009, and December 31, 2010, by checking the `OpenDate` field in the `schools` table (`T2`). The year part of the date should be between `2009` and `2010`.\n\n5. **Filter by School Type**: Include only schools of the types \"Public Intermediate/Middle Schools\" and \"Unified Schools\" by checking the `SOC` field in the `schools` table (`T2`) for the value `62`.\n\n6. **Retrieve Email Addresses**: Finally, extract the administrator's email addresses from the `AdmEmail1` and `AdmEmail2` fields in the `schools` table (`T2`).\n\nThe result will be a list of valid email addresses for the administrators of the schools meeting all the specified criteria."
        ]
    },
    "1402": {
        "sql": "SELECT t_shirt_size, COUNT(*) AS size_count FROM member GROUP BY t_shirt_size ORDER BY size_count DESC LIMIT 1;",
        "question": "What is the most popular size of t-shirt ordered by the club members?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT t_shirt_size FROM member GROUP BY t_shirt_size ORDER BY COUNT(t_shirt_size) DESC LIMIT 1",
        "explain": "most popular size of t-shirt ordered refers to MAX(COUNT(t_shirt_size))",
        "solution": [
            "To determine the most popular size of t-shirt ordered by the club members, follow these steps:\n\n1. **Group the Data**: Group all the records in the `member` table by the `t_shirt_size` column. This will organize the data into distinct groups based on each unique t-shirt size.\n\n2. **Count Occurrences**: For each group (i.e., each unique t-shirt size), count the number of occurrences (i.e., how many members have ordered that size).\n\n3. **Order by Popularity**: Sort the groups in descending order based on the count of each t-shirt size. This will place the most frequently ordered size at the top of the list.\n\n4. **Select the Top Result**: Retrieve only the first result from the sorted list, which represents the most popular t-shirt size.\n\nThe final output will be the t-shirt size that appears most frequently in the `member` table.",
            "To determine the most popular size of t-shirt ordered by the club members, follow these detailed steps:\n\n1. **Data Selection**: Identify the relevant data in the `member` table, specifically focusing on the `t_shirt_size` column, which contains the sizes of t-shirts ordered by the members.\n\n2. **Grouping by Size**: Group the records in the `member` table by the `t_shirt_size` column. This creates distinct groups for each unique t-shirt size present in the data.\n\n3. **Counting Occurrences**: For each group (i.e., each unique t-shirt size), calculate the number of records (members) associated with that size. This count represents how many members have ordered each specific t-shirt size.\n\n4. **Sorting by Popularity**: Arrange the groups in descending order based on the count of members for each t-shirt size. This ensures that the size with the highest count (most popular) appears first in the list.\n\n5. **Retrieving the Result**: Extract the first record from the sorted list, which corresponds to the t-shirt size with the highest number of orders. This is the most popular size.\n\nThe final output will be the single most frequently ordered t-shirt size from the `member` table."
        ]
    },
    "566": {
        "sql": "SELECT u.Reputation\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.Id = 65041;",
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "explain": "post no. 65041 refers to Id = '65041'; reputation point refers to Reputation",
        "solution": []
    },
    "481": {
        "sql": "SELECT DISTINCT fd.language\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.name = 'Ancestor''s Chosen' AND fd.flavorText IS NOT NULL;",
        "question": "Please list all the foreign languages in which the card \"Ancestor's Chosen\" has a flavor text.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.flavorText IS NOT NULL",
        "explain": "\"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'; has a flavor text refers to flavorText is not null",
        "solution": []
    },
    "1244": {
        "sql": "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE STRFTIME('%Y', P.\"First Date\") > '1992'\nAND L.PT < 14;",
        "question": "List all patients who first came to the hospital after year 1992 with prothrombin time (PT) level that are normal.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) > '1992' AND T2.PT < 14",
        "explain": "first came to the hospital after year 1992 refers to year(`First Date`) > 1992; prothrombin time (PT) level that are normal refers to PT < 14;",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Select Patient IDs**: The query retrieves the IDs of patients from the `Patient` table.\n\n2. **Join with Laboratory Data**: The query joins the `Patient` table with the `Laboratory` table using the patient ID as the common key. This ensures that only patients with laboratory records are considered.\n\n3. **Filter by First Visit Date**: The query filters patients based on their first visit date. Only patients whose first visit year (extracted using `STRFTIME('%Y', T1.\"First Date\")`) is after 1992 are included.\n\n4. **Filter by Prothrombin Time (PT) Level**: The query further filters the results to include only patients whose PT level (from the `Laboratory` table) is less than 14, indicating a normal PT level.\n\nThe final result is a list of patient IDs who meet all the specified criteria."
        ]
    },
    "462": {
        "sql": "SELECT st.translation AS italian_set_name\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE c.name = 'Ancestor''s Chosen' AND st.language = 'Italian';",
        "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
        "explain": "Italian is a language which refers to language = 'Italian'; with \"Ancestor's Chosen\" in the card set refers to name = 'Ancestor''s Chosen'",
        "solution": []
    },
    "218": {
        "sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) AS percentage\nFROM molecule AS T2\nINNER JOIN atom AS T1 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+';",
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "explain": "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;",
        "solution": [
            "To solve the question \"What percentage of carcinogenic-type molecules does not contain fluorine?\", the following steps are performed:\n\n1. **Filter carcinogenic-type molecules**: The query starts by filtering molecules from the `molecule` table where the `label` is '+', indicating they are of carcinogenic type.\n\n2. **Join with atom data**: The filtered molecules are then joined with the `atom` table to access the elemental composition of each molecule.\n\n3. **Count molecules without fluorine**: For each molecule, the query checks if it contains any atoms of fluorine ('f'). If a molecule does not contain fluorine, its `molecule_id` is counted. The `DISTINCT` keyword ensures each molecule is counted only once.\n\n4. **Calculate the percentage**: The count of molecules without fluorine is divided by the total count of carcinogenic-type molecules (also distinct). This ratio is then multiplied by 100 to convert it into a percentage.\n\n5. **Output the result**: The final result is the percentage of carcinogenic-type molecules that do not contain fluorine.",
            "To solve the question \"What percentage of carcinogenic-type molecules does not contain fluorine?\", the following detailed steps are performed:\n\n1. **Filter carcinogenic-type molecules**: The query starts by filtering molecules from the `molecule` table where the `label` is '+', indicating they are of carcinogenic type. This is done using the condition `WHERE T2.label = '+'`.\n\n2. **Join with atom data**: The filtered molecules are then joined with the `atom` table using the `molecule_id` field to access the elemental composition of each molecule. This is achieved with the `INNER JOIN` clause: `INNER JOIN atom AS T1 ON T1.molecule_id = T2.molecule_id`.\n\n3. **Count molecules without fluorine**: For each molecule, the query checks if it contains any atoms of fluorine ('f'). If a molecule does not contain fluorine (i.e., `T1.element <> 'f'`), its `molecule_id` is counted. The `DISTINCT` keyword ensures each molecule is counted only once. This is done using the expression `COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END)`.\n\n4. **Calculate the percentage**: The count of molecules without fluorine is divided by the total count of carcinogenic-type molecules (also distinct). This ratio is then multiplied by 100 to convert it into a percentage. The calculation is performed as `CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id)`.\n\n5. **Output the result**: The final result is the percentage of carcinogenic-type molecules that do not contain fluorine, which is directly returned by the query."
        ]
    },
    "753": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.height_cm BETWEEN 170 AND 190\nAND c.colour = 'No Colour';",
        "question": "Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'",
        "explain": "height from 170 to 190 refers to height_cm BETWEEN 170 AND 190; no eye color refers to colour = 'No Colour'",
        "solution": []
    },
    "1254": {
        "sql": "SELECT COUNT(T1.ID) AS PatientCount\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.IGA BETWEEN 80 AND 500\nAND strftime('%Y', T1.\"First Date\") > '1990';",
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND  strftime('%Y',  T1.`First Date`) > '1990'",
        "explain": "normal Ig A level refers to IGA > 80 AND IGA < 500; came to the hospital after 1990/1/1 refers to YEAR(`First Date`) > = 1990;",
        "solution": [
            "To solve the question, \"How many patients with a normal Ig A level came to the hospital after 1990/1/1?\", the following steps are performed:\n\n1. **Join the Patient and Laboratory tables**: The tables are joined using the patient ID (`ID`) to link patient records with their laboratory results.\n\n2. **Filter for normal Ig A levels**: From the joined data, only records where the Ig A level (`IGA`) is between 80 and 500 (inclusive) are selected. This range represents normal Ig A levels.\n\n3. **Filter for patients who came after 1990/1/1**: The `First Date` field from the Patient table is checked to ensure the year part is greater than 1990. This ensures only patients who first visited the hospital after January 1, 1990, are included.\n\n4. **Count the qualifying patients**: Finally, the number of patients who meet both criteria (normal Ig A level and first visit after 1990/1/1) is counted and returned as the result.",
            "To solve the question, \"How many patients with a normal Ig A level came to the hospital after 1990/1/1?\", the following detailed steps are performed:\n\n1. **Join the Patient and Laboratory tables**: The `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) are joined using the patient ID (`ID`) to link patient records with their laboratory results.\n\n2. **Filter for normal Ig A levels**: From the joined data, only records where the Ig A level (`IGA` in the `Laboratory` table) is between 80 and 500 (inclusive) are selected. This range represents normal Ig A levels.\n\n3. **Filter for patients who came after 1990/1/1**: The `First Date` field from the `Patient` table is checked to ensure the year part (extracted using `strftime('%Y', T1.\"First Date\")`) is greater than '1990'. This ensures only patients who first visited the hospital after January 1, 1990, are included.\n\n4. **Count the qualifying patients**: Finally, the number of patients (counted using `COUNT(T1.ID)`) who meet both criteria (normal Ig A level and first visit after 1990/1/1) is returned as the result."
        ]
    },
    "459": {
        "sql": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1;",
        "question": "Which card costs more converted mana, \"Serra Angel\" or \"Shrine Keeper\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1",
        "explain": "\"Serra Angel\" refers to name = 'Serra Angel'; \"Shrine Keeper\" refers to name = 'Shrine Keeper'; card costs more converted mana when the value of convertedManaCost is greater",
        "solution": [
            "To determine which card costs more in terms of converted mana between \"Serra Angel\" and \"Shrine Keeper,\" the following steps are performed:\n\n1. **Filter the Cards**: The database is queried to retrieve only the cards with the names \"Serra Angel\" and \"Shrine Keeper.\"\n2. **Sort by Converted Mana Cost**: The retrieved cards are then sorted in descending order based on their `convertedManaCost` attribute. This ensures the card with the higher mana cost appears first.\n3. **Select the Top Result**: The first card from the sorted list is selected, which will be the one with the higher converted mana cost.\n\nThe result will display the name of the card that costs more in terms of converted mana.",
            "To determine which card costs more in terms of converted mana between \"Serra Angel\" and \"Shrine Keeper,\" the following detailed steps are performed:\n\n1. **Query the Database**: The database is queried to retrieve all records from the `cards` table where the `name` column matches either \"Serra Angel\" or \"Shrine Keeper.\" This is done using the `WHERE name IN ('Serra Angel', 'Shrine Keeper')` clause.\n\n2. **Sort the Results**: The retrieved records are then sorted in descending order based on the `convertedManaCost` column. This ensures that the card with the higher converted mana cost appears at the top of the list. The sorting is performed using the `ORDER BY convertedManaCost DESC` clause.\n\n3. **Limit the Output**: Only the first record from the sorted list is selected, which corresponds to the card with the highest converted mana cost. This is achieved using the `LIMIT 1` clause.\n\n4. **Display the Result**: The `name` column of the selected record is displayed as the output, showing the name of the card that costs more in terms of converted mana.\n\nThe SQL query `SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1` precisely follows these steps to provide the correct answer."
        ]
    },
    "326": {
        "sql": "SELECT DISTINCT T1.molecule_id FROM atom T1 JOIN bond T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '=';",
        "question": "Which molecule consisted of Sulphur atom with double bond?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='",
        "explain": "sulphur refers to element - 's'; double bond refers to bond_type = ' = ';",
        "solution": [
            "To find the molecule that consists of a Sulphur atom with a double bond, follow these steps:\n\n1. **Identify Sulphur Atoms**: First, locate all atoms in the database where the element is Sulphur (denoted by 's').\n\n2. **Filter by Double Bonds**: Next, filter these Sulphur atoms to only include those that are part of a double bond. A double bond is represented by the bond type '=' in the database.\n\n3. **Retrieve Unique Molecules**: Ensure that each molecule is listed only once by applying a distinct operation on the molecule IDs.\n\n4. **Combine Results**: The final result is a list of unique molecule IDs that contain at least one Sulphur atom involved in a double bond.",
            "To find the molecule that consists of a Sulphur atom with a double bond, follow these detailed steps:\n\n1. **Select the Molecule ID**: Start by selecting the unique molecule IDs from the database to ensure no duplicates are included in the results.\n\n2. **Join Tables**: Combine the `atom` table (aliased as `T1`) and the `bond` table (aliased as `T2`) using the `molecule_id` field. This join ensures that we can examine both the atoms and their bonds in the same context.\n\n3. **Filter for Sulphur Atoms**: Within the joined data, filter the atoms to only include those where the element is Sulphur, denoted by `'s'` in the `element` column of the `atom` table (`T1.element = 's'`).\n\n4. **Filter for Double Bonds**: Further filter the bonds to only include those where the bond type is a double bond, represented by `'='` in the `bond_type` column of the `bond` table (`T2.bond_type = '='`).\n\n5. **Apply Distinct Operation**: Ensure the final result contains only unique molecule IDs by applying the `DISTINCT` keyword to the `molecule_id` column in the `atom` table (`T1.molecule_id`).\n\n6. **Output the Result**: The result is a list of unique molecule IDs that contain at least one Sulphur atom involved in a double bond."
        ]
    },
    "134": {
        "sql": "WITH max_crime_district AS (\n    SELECT district_id\n    FROM district\n    ORDER BY A16 DESC\n    LIMIT 1\n)\nSELECT COUNT(*) AS accounts_opened\nFROM account\nWHERE district_id = (SELECT district_id FROM max_crime_district);",
        "question": "In the branch where the largest number of crimes were committed in 1996, how many accounts were opened?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY T1.A16 ORDER BY T1.A16 DESC LIMIT 1",
        "explain": "A16 stands for no. of committed crimes 1996",
        "solution": []
    },
    "1528": {
        "sql": "SELECT (SUM(IIF(Segment = 'Premium', 1, 0)) * 100.0 / SUM(IIF(Country = 'SVK', 1, 0))) AS PremiumPercentage\nFROM gasstations\nWHERE Country = 'SVK';",
        "question": "What is the percentage of \"premium\" against the overall segment in Country = \"SVK\"?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations",
        "explain": "",
        "solution": [
            "To solve the question \"What is the percentage of 'premium' against the overall segment in Country = 'SVK'?\", the following steps are performed:\n\n1. **Filter Data for Country 'SVK'**: The dataset is filtered to include only records where the \"Country\" column has the value \"SVK\".\n\n2. **Count Premium Segments**: Within the filtered data, count the number of records where the \"Segment\" column has the value \"Premium\". This is done using a conditional check (IIF function) that returns 1 for \"Premium\" segments and 0 otherwise, then summing these values.\n\n3. **Count Total Segments**: Count the total number of records in the filtered data (i.e., all segments in \"SVK\"). This is done using another conditional check (IIF function) that returns 1 for all records in \"SVK\" and 0 otherwise, then summing these values.\n\n4. **Calculate Percentage**: Divide the count of \"Premium\" segments by the total count of segments in \"SVK\", then multiply by 100 to convert the result into a percentage. The result is cast to a float to ensure accurate division.\n\nThe final result is the percentage of \"Premium\" segments out of all segments in the country \"SVK\"."
        ]
    },
    "553": {
        "sql": "SELECT COUNT(*) AS BadgeCount\nFROM badges\nJOIN users ON badges.UserId = users.Id\nWHERE users.DisplayName = 'csgillespie'\nAND strftime('%Y', badges.Date) = '2011';",
        "question": "Among the badges obtained by csgillespie, how many of them were obtained in the year 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE STRFTIME('%Y', T1.Date) = '2011' AND T2.DisplayName = 'csgillespie'",
        "explain": "\"csgillespie\" is the DisplayName of user; obtained in 2011 refers to YEAR (Date) = 2011",
        "solution": []
    },
    "718": {
        "sql": "SELECT COUNT(DISTINCT hero_id) \nFROM hero_power \nWHERE power_id = (SELECT id FROM superpower WHERE power_name = 'Super Strength');",
        "question": "How many superheroes have the super power of \"Super Strength\"?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Super Strength'",
        "explain": "super power of \"Super Strength\" refers to power_name = 'Super Strength'",
        "solution": []
    },
    "477": {
        "sql": "SELECT DISTINCT c.artist\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Coldsnap'\nAND c.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy');",
        "question": "Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (T2.name = 'Coldsnap' AND T1.artist = 'Chippy') OR (T2.name = 'Coldsnap' AND T1.artist = 'Aaron Miller') OR (T2.name = 'Coldsnap' AND T1.artist = 'Jeremy Jarvis') GROUP BY T1.artist",
        "explain": "card set Coldsnap refers to name = 'Coldsnap'; Jeremy Jarvis, Aaron Miller or Chippy are the name of artists which refers to artist IN ('Jeremy Jarvis', 'Aaron Miller','Chippy');",
        "solution": []
    },
    "781": {
        "sql": "SELECT superhero.height_cm FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'Amber';",
        "question": "Provide the heights of the heroes whose eye colours are amber.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'",
        "explain": "heights of the heroes refers to height_cm; eye colours are amber refers to colour.colour = 'Amber' WHERE eye_colour_id = colour.id;",
        "solution": []
    },
    "376": {
        "sql": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "question": "What are the card layout of cards with keyword of flying?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "explain": "",
        "solution": [
            "To find the card layouts of cards that have the keyword 'Flying', you need to query the 'cards' table. Specifically, you should select the 'layout' column from this table where the 'keywords' column matches the value 'Flying'.",
            "To retrieve the card layouts of cards that have the keyword 'Flying', you must perform the following steps:\n\n1. **Access the 'cards' table**: This table contains the data about all the cards, including their layouts and keywords.\n\n2. **Filter the records**: Apply a condition to select only those records where the 'keywords' column exactly matches the string 'Flying'. This ensures that only cards with the keyword 'Flying' are considered.\n\n3. **Extract the 'layout' information**: From the filtered records, retrieve the values in the 'layout' column. This column contains the layout information for each card.\n\n4. **Return the results**: The final output will be a list of all card layouts that meet the specified condition (i.e., cards with the keyword 'Flying').\n\nThe SQL query `SELECT layout FROM cards WHERE keywords = 'Flying'` precisely executes these steps to answer the question."
        ]
    },
    "211": {
        "sql": "SELECT DISTINCT T1.atom_id\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nJOIN connected T3 ON T1.atom_id = T3.atom_id\nWHERE T2.label = '-'",
        "question": "Indicate which atoms are connected in non-carcinogenic type molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.label = '-'",
        "explain": "label = '-' means molecules are non-carcinogenic",
        "solution": [
            "To solve the question \"Indicate which atoms are connected in non-carcinogenic type molecules,\" the following steps are performed:\n\n1. **Select Distinct Atom IDs**: The query retrieves unique atom IDs from the `atom` table (aliased as `T1`).\n\n2. **Join with Molecule Table**: The `atom` table is joined with the `molecule` table (aliased as `T2`) using the `molecule_id` field to link atoms to their respective molecules.\n\n3. **Filter Non-Carcinogenic Molecules**: The query filters molecules where the `label` field in the `molecule` table is \"-\", indicating non-carcinogenic type molecules.\n\n4. **Join with Connected Table**: The `atom` table is further joined with the `connected` table (aliased as `T3`) using the `atom_id` field to identify which atoms are connected.\n\n5. **Final Result**: The result is a list of distinct atom IDs that are part of connected atoms in non-carcinogenic molecules."
        ]
    },
    "580": {
        "sql": "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Necromancer'\nLIMIT 10;",
        "question": "Name 10 users with the badge name 'Necromancer.'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Necromancer' LIMIT 10",
        "explain": "\"Necromancer\" is the Name of badge; users refers to DisplayName",
        "solution": []
    },
    "185": {
        "sql": "SELECT (COUNT(CASE WHEN c.gender = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS female_proportion\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE d.A3 = 'Prague';",
        "question": "What proportion of customers who have accounts at the Prague branch are female?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id) * 100 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'Prague'",
        "explain": "Female refers to gender = 'F'; Percentage of female clients in Prague branch = count[female clients with accounts in Prague branch / count(clients with accounts in Prague branch)] * 100%; A3 may contain information about Prague",
        "solution": [
            "To determine the proportion of female customers who have accounts at the Prague branch, follow these steps:\n\n1. **Join the Tables**: Combine the `district` table (referred to as T1) with the `client` table (referred to as T2) using the `district_id` field. This links each client to their respective district.\n\n2. **Filter for Prague**: From the joined tables, filter the records to include only those where the `A3` field in the `district` table (T1) is 'Prague'. This ensures we are only considering customers from the Prague branch.\n\n3. **Count Total Customers**: Calculate the total number of customers by counting the `client_id` values in the filtered results.\n\n4. **Count Female Customers**: Among the filtered customers, count how many have a `gender` field equal to 'F' (female).\n\n5. **Calculate Proportion**: Divide the number of female customers by the total number of customers, convert the result to a real number, and multiply by 100 to get the percentage.\n\nThe final result is the percentage of female customers among all customers at the Prague branch."
        ]
    },
    "176": {
        "sql": "SELECT l.amount AS debt_amount, l.status AS payment_status\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.client_id = 992;",
        "question": "What is the amount of debt that client number 992 has, and how is this client doing with payments?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.amount, T4.status FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 on T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 992",
        "explain": "",
        "solution": []
    },
    "1117": {
        "sql": "SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10;",
        "question": "What are the player api id of 10 heaviest players?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10",
        "explain": "heaviest refers to MAX(weight)",
        "solution": []
    },
    "897": {
        "sql": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) AS max_points\nFROM drivers T1\nJOIN driverStandings T2 ON T1.driverId = T2.driverId\nWHERE T2.wins >= 1\nGROUP BY T1.forename, T1.surname, T1.nationality\nORDER BY COUNT(T2.wins) DESC\nLIMIT 1;",
        "question": "Name the driver with the most winning. Mention his nationality and what is his maximum point scores.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE T2.wins >= 1 GROUP BY T1.forename, T1.surname, T1.nationality ORDER BY COUNT(T2.wins) DESC LIMIT 1",
        "explain": "Full name of the driver refers to drivers.forename and drivers.surname; the most winning refers to MAX(COUNT(wins)); average point scores refers to MAX(points);",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Join the Tables**: Combine the `drivers` table (aliased as `T1`) with the `driverStandings` table (aliased as `T2`) using the `driverId` field as the common key. This ensures that each driver's information is linked to their standings data.\n\n2. **Filter for Winners**: Only include records where the driver has at least one win (`T2.wins >= 1`). This filters out drivers who have never won.\n\n3. **Group the Data**: Group the results by the driver's first name (`T1.forename`), last name (`T1.surname`), and nationality (`T1.nationality`). This ensures that each driver's data is aggregated correctly.\n\n4. **Calculate Maximum Points**: For each driver, compute the maximum points they have ever scored (`MAX(T2.points)`).\n\n5. **Order by Win Count**: Sort the grouped results in descending order based on the count of wins (`COUNT(T2.wins)`). This ensures the driver with the most wins appears first.\n\n6. **Limit the Results**: Return only the top result (`LIMIT 1`), which will be the driver with the most wins.\n\nThe final output will include the driver's first name, last name, nationality, and their maximum points scored."
        ]
    },
    "1493": {
        "sql": "SELECT (SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT CustomerID)) AS Percentage\nFROM yearmonth\nWHERE Date = '201202';",
        "question": "In February 2012, what percentage of customers consumed more than 528.3?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'",
        "explain": "February 2012 refers to '201202' in yearmonth.date; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Filter the Data**: Select all records from the table `yearmonth` where the `Date` column is equal to '201202' (February 2012).\n\n2. **Count Total Customers**: Calculate the total number of unique customers in the filtered data by counting the `CustomerID` values.\n\n3. **Identify High Consumers**: For each customer in the filtered data, check if their `Consumption` value is greater than 528.3. If it is, assign a value of 1; otherwise, assign 0.\n\n4. **Sum High Consumers**: Sum all the 1s from the previous step to get the total number of customers who consumed more than 528.3.\n\n5. **Calculate Percentage**: Convert the sum of high consumers to a float, multiply by 100, and then divide by the total number of customers to get the percentage.\n\n6. **Return Result**: The final result is the percentage of customers who consumed more than 528.3 in February 2012."
        ]
    },
    "748": {
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.id = 75;",
        "question": "What is the eye colour of superhero with superhero ID 75?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.id = 75",
        "explain": "eye colour refers to colour where eye_colour_id = colour.id;",
        "solution": []
    },
    "1529": {
        "sql": "SELECT \n    SUM(t.Price) AS TotalAmountSpent,\n    SUM(CASE WHEN y.Date = '201201' THEN t.Price ELSE 0 END) AS AmountSpentInJanuary2012\nFROM \n    transactions_1k t\nJOIN \n    gasstations g ON t.GasStationID = g.GasStationID\nJOIN \n    yearmonth y ON t.CustomerID = y.CustomerID\nWHERE \n    t.CustomerID = 38508;",
        "question": "What is the amount spent by customer \"38508\" at the gas stations? How much had the customer spent in January 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.Price) , SUM(IIF(T3.Date = '201201', T1.Price, 0)) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.CustomerID = '38508'",
        "explain": "January 2012 refers to the Date value = '201201'",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Filter Transactions for Customer '38508':** The database filters the `transactions_1k` table to include only records where the `CustomerID` is '38508'.\n\n2. **Join with Gas Stations:** The filtered transactions are then joined with the `gasstations` table using the `GasStationID` field to ensure only transactions at gas stations are considered.\n\n3. **Join with Year-Month Data:** The transactions are further joined with the `yearmonth` table using the `CustomerID` field to access the date information for each transaction.\n\n4. **Calculate Total Amount Spent:** The database calculates the sum of the `Price` field from the `transactions_1k` table to determine the total amount spent by the customer at gas stations.\n\n5. **Calculate Amount Spent in January 2012:** The database also calculates the sum of the `Price` field, but only for transactions where the date in the `yearmonth` table is '201201' (January 2012). This is done using a conditional sum (IIF function) that includes the price only if the date matches '201201'.\n\nThe final result provides two values:\n- The total amount spent by customer '38508' at gas stations.\n- The amount spent by the same customer in January 2012."
        ]
    },
    "598": {
        "sql": "WITH student_badges AS (\n    SELECT \n        Id,\n        strftime('%Y', Date) AS Year\n    FROM \n        badges\n    WHERE \n        Name = 'Student'\n),\nbadge_counts AS (\n    SELECT \n        COUNT(*) AS TotalBadges,\n        SUM(CASE WHEN Year = '2010' THEN 1 ELSE 0 END) AS Badges2010,\n        SUM(CASE WHEN Year = '2011' THEN 1 ELSE 0 END) AS Badges2011\n    FROM \n        student_badges\n)\nSELECT \n    ((Badges2010 * 100.0 / TotalBadges) - (Badges2011 * 100.0 / TotalBadges)) AS PercentageDifference\nFROM \n    badge_counts;",
        "question": "What is the percentage difference of student badges given during 2010 and 2011?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) AS REAL) * 100 / COUNT(Id) - CAST(SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) AS REAL) * 100 / COUNT(Id) FROM badges WHERE Name = 'Student'",
        "explain": "student badges refers to badge's name = 'Student'; during 2010 refers to Year(Date) = 2010; during 2011 refers to Year(Date) = 2011; percentage difference = Subtract (Divide(Count(Name where Year(Date) = 2010), Count (Name)) *100, Divide(Count(Name where Year(Date) = 2011), Count(Name)) * 100)",
        "solution": [
            "To solve the question, \"What is the percentage difference of student badges given during 2010 and 2011?\", the following operations are performed on the database:\n\n1. **Filter the Data**: Select all records from the \"badges\" table where the \"Name\" column is equal to \"Student\".\n\n2. **Count Total Badges**: Calculate the total number of student badges by counting the \"Id\" column in the filtered data.\n\n3. **Count Badges for 2010**: For each record, check if the year extracted from the \"Date\" column is \"2010\". If it is, count it as 1; otherwise, count it as 0. Sum these values to get the total number of student badges given in 2010.\n\n4. **Calculate Percentage for 2010**: Divide the count of badges for 2010 by the total number of student badges and multiply by 100 to get the percentage of badges given in 2010.\n\n5. **Count Badges for 2011**: Similarly, for each record, check if the year extracted from the \"Date\" column is \"2011\". If it is, count it as 1; otherwise, count it as 0. Sum these values to get the total number of student badges given in 2011.\n\n6. **Calculate Percentage for 2011**: Divide the count of badges for 2011 by the total number of student badges and multiply by 100 to get the percentage of badges given in 2011.\n\n7. **Compute Percentage Difference**: Subtract the percentage of badges given in 2011 from the percentage of badges given in 2010 to find the percentage difference between the two years.\n\nThe result of these operations will give the percentage difference of student badges given during 2010 and 2011."
        ]
    },
    "513": {
        "sql": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1;",
        "question": "Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1",
        "explain": "expansion type refers to type where type = 'commander'; totalSetSize: The total number of cards in the set, including promotional and related supplemental products but excluding Alchemy modifications; highest total number of cards refers to MAX(totalSetSize)",
        "solution": []
    },
    "602": {
        "sql": "SELECT PostId, UserId FROM postHistory WHERE PostId IN (SELECT Id FROM posts WHERE Score > 60)",
        "question": "List out all post ID with score more than 60 and list out all the user ID that created these post.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT PostId, UserId FROM postHistory WHERE PostId IN ( SELECT Id FROM posts WHERE Score > 60 )",
        "explain": "score more than 60 refers to Score > 60",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter Posts by Score**: First, identify all posts in the `posts` table where the `Score` is greater than 60. This is done by executing the subquery `SELECT Id FROM posts WHERE Score > 60`.\n\n2. **Retrieve Post and User Information**: Using the list of post IDs obtained from the first step, retrieve the corresponding `PostId` and `UserId` from the `postHistory` table. This is achieved by the main query `SELECT PostId, UserId FROM postHistory WHERE PostId IN (subquery)`.\n\n3. **Combine Results**: The final result is a list of all post IDs with a score greater than 60, along with the user IDs of the users who created these posts."
        ]
    },
    "343": {
        "sql": "SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = '2015';",
        "question": "Name all cards with 2015 frame style ranking below 100 on EDHRec.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = 2015",
        "explain": "below 100 on EDHRec refers to EDHRec <100; with 2015 frame style refers to frameVersion = 2015;",
        "solution": [
            "To solve the question, 'Name all cards with 2015 frame style ranking below 100 on EDHRec,' the following steps are performed:\n\n1. **Filter the cards**: From the database table named 'cards,' select only those cards that meet two specific conditions:\n   - The card's EDHRec rank (`edhrecRank`) must be less than 100.\n   - The card's frame version (`frameVersion`) must be exactly 2015.\n\n2. **Retrieve the IDs**: For the cards that satisfy both conditions, retrieve their unique identifiers (`id`).\n\nThis operation ensures that only the relevant cards are listed, adhering strictly to the criteria provided in the question.",
            "To solve the question, 'Name all cards with 2015 frame style ranking below 100 on EDHRec,' the following detailed steps are performed:\n\n1. **Query the database**: Execute a query on the 'cards' table to retrieve specific data.\n\n2. **Apply filtering conditions**: The query includes two filtering conditions to narrow down the results:\n   - The `edhrecRank` of the card must be less than 100, ensuring the card ranks below 100 on EDHRec.\n   - The `frameVersion` of the card must be exactly 2015, ensuring the card uses the 2015 frame style.\n\n3. **Select the output**: The query selects the `id` column, which contains the unique identifiers of the cards that meet both conditions.\n\nThis process ensures that only the IDs of cards with the 2015 frame style and an EDHRec rank below 100 are returned, matching the criteria specified in the question."
        ]
    },
    "575": {
        "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.DisplayName = 'SilentGhost';",
        "question": "What is the badge name that user 'SilentGhost' obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'SilentGhost'",
        "explain": "\"SilentGhost\" is the DisplayName of user;",
        "solution": []
    },
    "873": {
        "sql": "SELECT r.time\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 743 AND d.forename = 'Bruce' AND d.surname = 'McLaren';",
        "question": "What is the actual finish time for Bruce McLaren in the race No.743?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.time FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 743 AND T1.forename = 'Bruce' AND T1.surname = 'McLaren'",
        "explain": "race number refers to raceId;",
        "solution": []
    },
    "397": {
        "sql": "SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability LIKE '%paper%' AND availability LIKE '%mtgo%';",
        "question": "What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT manaCost FROM cards WHERE availability = 'mtgo,paper' AND borderColor = 'black' AND frameVersion = 2003 AND layout = 'normal'",
        "explain": "available in paper and mtgo refers to availability = 'mtgo,paper'; frameVersion = 2003;borderColor = 'black'",
        "solution": []
    },
    "849": {
        "sql": "SELECT url FROM circuits WHERE name = 'Circuit de Barcelona-Catalunya';",
        "question": "Where can the introduction of the races held on Circuit de Barcelona-Catalunya be found?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "explain": "introduction of races refers to url; Circuit de Barcelona-Catalunya is a name of circuit;",
        "solution": []
    },
    "1008": {
        "sql": "SELECT p.lap\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nJOIN races r ON p.raceId = r.raceId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nAND r.year = 2011 AND r.name = 'Australian Grand Prix';",
        "question": "During which lap did Lewis Hamilton take a pit stop during the 2011 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.lap FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' AND T3.year = 2011 AND T3.name = 'Australian Grand Prix'",
        "explain": "",
        "solution": []
    },
    "994": {
        "sql": "SELECT SUM(T1.points) AS total_points, T2.name, T2.nationality\nFROM constructorResults AS T1\nJOIN constructors AS T2 ON T1.constructorId = T2.constructorId\nJOIN races AS T3 ON T1.raceId = T3.raceId\nWHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010\nGROUP BY T2.name\nORDER BY total_points DESC\nLIMIT 1;",
        "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
        "explain": "Monaco Grand Priz refers to the race; race in year between 1980 and 2010",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join Tables**: Combine the `constructorResults` table (aliased as `T1`), the `constructors` table (aliased as `T2`), and the `races` table (aliased as `T3`). The join conditions are:\n   - `T1.constructorId` matches `T2.constructorId`.\n   - `T3.raceid` matches `T1.raceid`.\n\n2. **Filter Rows**: Select only those rows where:\n   - The race name is 'Monaco Grand Prix' (`T3.name = 'Monaco Grand Prix'`).\n   - The race year is between 1980 and 2010 (`T3.year BETWEEN 1980 AND 2010`).\n\n3. **Group Data**: Group the filtered rows by the constructor's name (`T2.name`).\n\n4. **Calculate Sum**: For each group, calculate the sum of points (`SUM(T1.points)`).\n\n5. **Sort Results**: Order the groups in descending order based on the sum of points (`ORDER BY SUM(T1.points) DESC`).\n\n6. **Limit Output**: Return only the top result (`LIMIT 1`), which will be the constructor with the highest total points in the specified criteria.\n\nThe final output includes:\n- The total points scored (`SUM(T1.points)`).\n- The constructor's name (`T2.name`).\n- The constructor's nationality (`T2.nationality`)."
        ]
    },
    "450": {
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE artist = 'Aaron Miller' \nAND cardKingdomFoilId IS NOT NULL \nAND cardKingdomId IS NOT NULL;",
        "question": "Of all the cards that are designed by Aaron Miller, how many of them are incredibly powerful?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) FROM cards",
        "explain": "designed by Aaron Miller refers to artist = 'Aaron Miller'; are icredibily powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
        "solution": []
    },
    "758": {
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nJOIN colour c ON s.hair_colour_id = c.id\nWHERE r.race = 'Human' AND s.height_cm = 185;",
        "question": "Provide the hair colour of the human superhero who is 185 cm tall.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
        "explain": "185 cm tall refers to height_cm = 185; human superhero refers to race = 'human'; hair colour refers to colour where hair_colour_id = colour.id;",
        "solution": []
    },
    "66": {
        "sql": "SELECT COUNT(*) AS NumberOfSchools FROM schools WHERE strftime('%Y', OpenDate) BETWEEN '2000' AND '2005' AND County = 'Stanislaus' AND FundingType = 'Directly funded';",
        "question": "Between 1/1/2000 to 12/31/2005, how many directly funded schools opened in the county of Stanislaus?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', OpenDate) BETWEEN '2000' AND '2005' AND County = 'Stanislaus' AND FundingType = 'Directly funded'",
        "explain": "Directly funded schools refers to FundingType = 'Directly Funded'",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Filter by Date Range**: Select schools where the year part of the `OpenDate` falls between the years 2000 and 2005 (inclusive). This is done by extracting the year from the `OpenDate` field and comparing it to the range.\n\n2. **Filter by County**: Further narrow down the results to only include schools located in the county of 'Stanislaus' by checking the `County` field.\n\n3. **Filter by Funding Type**: Ensure that only schools with a `FundingType` of 'Directly funded' are included in the count.\n\n4. **Count the Schools**: Finally, count the number of schools that meet all the above criteria.\n\nThe SQL query translates to counting the number of schools in the `schools` table that were opened between January 1, 2000, and December 31, 2005, are located in Stanislaus County, and are directly funded."
        ]
    },
    "1467": {
        "sql": "SELECT SUM(T1.spent) AS total_spent, T2.event_name\nFROM budget T1\nJOIN event T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Speaker Gifts'\nGROUP BY T2.event_name;",
        "question": "Calculate the total amount spent on speaker gifts and list the name of the event they were spent on.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(T1.spent), T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Speaker Gifts' GROUP BY T2.event_name",
        "explain": "total amount spent = SUM(spent) where category = 'Speaker Gifts'",
        "solution": [
            "To calculate the total amount spent on speaker gifts and list the name of the event they were spent on, follow these steps:\n\n1. **Join the Tables**: Combine the `budget` table (referred to as `T1`) with the `event` table (referred to as `T2`) using the condition that the `link_to_event` column in `T1` matches the `event_id` column in `T2`.\n\n2. **Filter the Data**: From the joined tables, filter the records to include only those where the `category` column in `T1` is 'Speaker Gifts'.\n\n3. **Group the Data**: Group the filtered records by the `event_name` column from `T2`.\n\n4. **Calculate the Sum**: For each group (i.e., each event), calculate the sum of the `spent` column from `T1`.\n\n5. **Display the Results**: The final output will display two columns:\n   - The total amount spent on speaker gifts for each event (sum of `T1.spent`).\n   - The name of the event (`T2.event_name`)."
        ]
    },
    "1084": {
        "sql": "SELECT COUNT(DISTINCT p.player_api_id) \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE strftime('%Y', p.birthday) < '1986' \nAND pa.defensive_work_rate = 'high';",
        "question": "Among the players born before the year 1986, how many of them would remain in his position and defense while the team attacked?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.birthday) < '1986' AND t2.defensive_work_rate = 'high'",
        "explain": "players born before the year 1986 refers to strftime('%Y', birthday)<'1986'; players who would remain in his position and defense while the team attacked refers to defensive_work_rate = 'high'; Should consider DISTINCT in the final result;",
        "solution": []
    },
    "234": {
        "sql": "SELECT COUNT(*) AS bond_count\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.molecule_id = 'TR009'\nAND (c.atom_id = 'TR009_1' OR c.atom_id2 = 'TR009_1' OR c.atom_id = 'TR009_2' OR c.atom_id2 = 'TR009_2');",
        "question": "How many bonds which involved atom 12 does molecule TR009 have?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2'",
        "explain": "TR009 is the molecule id;  involved atom 12 refers to atom_id = 'TR009_12' or atom_id2 = 'TR009_12'",
        "solution": [
            "To determine how many bonds involving atom 12 the molecule TR009 has, follow these steps:\n\n1. **Identify the bonds in molecule TR009**: Focus on the bonds listed in the `bond` table where the `molecule_id` is 'TR009'.\n\n2. **Filter bonds involving atom 12**: From the identified bonds, check the `connected` table to find bonds where either `atom_id` or `atom_id2` corresponds to atom 12. In this case, the SQL checks for bonds where `atom_id` is 'TR009_1' and `atom_id2` is 'TR009_2'.\n\n3. **Count the qualifying bonds**: Count the number of bonds that meet the above criteria to get the final result.\n\nThe SQL query performs these operations by joining the `bond` and `connected` tables, filtering for the specific molecule and atom, and then counting the relevant bonds.",
            "To determine how many bonds involving atom 12 the molecule TR009 has, follow these detailed steps:\n\n1. **Identify the bonds in molecule TR009**: Query the `bond` table to retrieve all bonds where the `molecule_id` is 'TR009'. This ensures we only consider bonds within the specified molecule.\n\n2. **Join with the `connected` table**: For each bond identified in step 1, join it with the `connected` table using the `bond_id` as the common key. This allows us to access the atoms involved in each bond.\n\n3. **Filter bonds involving atom 12**: From the joined tables, filter the bonds where either `atom_id` or `atom_id2` corresponds to atom 12. In this SQL query, the condition checks for bonds where `atom_id` is constructed as 'TR009_1' and `atom_id2` is constructed as 'TR009_2'. This implies that atom 12 is represented by 'TR009_1' and 'TR009_2' in the `connected` table.\n\n4. **Count the qualifying bonds**: Finally, count the number of bonds that meet the above criteria to determine how many bonds involve atom 12 in molecule TR009.\n\nThe SQL query accomplishes this by:\n- Joining the `bond` and `connected` tables on `bond_id`.\n- Filtering for bonds where `molecule_id` is 'TR009'.\n- Further filtering for bonds where the atoms involved are 'TR009_1' and 'TR009_2' (representing atom 12).\n- Counting the resulting bonds to provide the answer."
        ]
    },
    "905": {
        "sql": "SELECT AVG(T2.points) AS average_points\nFROM drivers T1\nJOIN driverStandings T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nWHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine' AND T3.year = 2000;",
        "question": "What is Eddie Irvine's average points scored in year 2000?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine' AND T3.year = 2000",
        "explain": "average points = AVG(points where year = 2000)",
        "solution": [
            "To find Eddie Irvine's average points scored in the year 2000, follow these steps:\n\n1. **Identify the driver**: Locate the driver named 'Eddie Irvine' in the `drivers` table (referred to as T1).\n\n2. **Join with driver standings**: Connect the `drivers` table (T1) with the `driverStandings` table (referred to as T2) using the `driverId` field. This ensures we have the points data for Eddie Irvine.\n\n3. **Join with races**: Further connect the `driverStandings` table (T2) with the `races` table (referred to as T3) using the `raceId` field. This allows us to filter races by the year 2000.\n\n4. **Apply filters**:\n   - Filter the `drivers` table (T1) to only include records where the `forename` is 'Eddie' and the `surname` is 'Irvine'.\n   - Filter the `races` table (T3) to only include records where the `year` is 2000.\n\n5. **Calculate the average**: Compute the average of the `points` column from the `driverStandings` table (T2) for the filtered records.\n\nThe result will be Eddie Irvine's average points scored in the year 2000."
        ]
    },
    "668": {
        "sql": "SELECT u.DisplayName\nFROM users u\nJOIN (\n    SELECT UserId, COUNT(*) AS badge_count\n    FROM badges\n    GROUP BY UserId\n) b ON u.Id = b.UserId\nORDER BY b.badge_count DESC\nLIMIT 1;",
        "question": "What is the display name of the user who acquired the highest amount of badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T1.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
        "explain": "highest amount of badges refers to MAX(COUNT(Name));",
        "solution": []
    },
    "1464": {
        "sql": "SELECT DISTINCT m.first_name, m.last_name, i.amount\nFROM member m\nJOIN income i ON m.member_id = i.link_to_member\nWHERE i.date_received = '2019-09-09';",
        "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
        "explain": "full name refers to first_name, last_name, amount of funds received refers to amount, received funds on date refers to date_received",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct Records**: Retrieve unique combinations of first names, last names, and amounts to avoid duplicates.\n\n2. **Join Tables**:\n   - The `event` table (T1) is joined with the `attendance` table (T2) using the `event_id` from T1 and the `link_to_event` from T2.\n   - The result is then joined with the `member` table (T3) using the `member_id` from T3 and the `link_to_member` from T2.\n   - Finally, the result is joined with the `income` table (T4) using the `member_id` from T3 and the `link_to_member` from T4.\n\n3. **Filter by Date**: Only include records where the `date_received` in the `income` table (T4) is '2019-09-09'.\n\n4. **Retrieve Specific Columns**: Extract the `first_name` and `last_name` from the `member` table (T3) and the `amount` from the `income` table (T4).\n\nThis sequence of operations ensures that the full names of students who received funds on 9/9/2019, along with the amount received, are accurately retrieved."
        ]
    },
    "616": {
        "sql": "SELECT T1.Score FROM comments T1 INNER JOIN posts T2 ON T1.PostId = T2.Id WHERE T2.CreaionDate = '2010-07-19 19:19:56.0';",
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "explain": "created on 7/19/2010 7:19:56 PM refers to CreationDate = '2010-07-19 19:19:56.0'",
        "solution": [
            "To find the comment's rating score of the post created on 7/19/2010 7:19:56 PM, follow these steps:\n\n1. **Join the tables**: Combine the `comments` table (referred to as `T1`) and the `posts` table (referred to as `T2`) using the `PostId` from `comments` and the `Id` from `posts` to link them.\n\n2. **Filter by creation date**: From the joined tables, filter the records to only include those where the `CreationDate` in the `comments` table matches the exact timestamp '2010-07-19 19:19:56.0'.\n\n3. **Select the score**: From the filtered records, retrieve the `Score` column from the `comments` table (`T1`).\n\nThis process ensures you get the rating score of the comment associated with the post created at the specified date and time.",
            "To determine the comment's rating score for the post created on 7/19/2010 7:19:56 PM, execute the following steps:\n\n1. **Table Join**: Perform an inner join between the `comments` table (aliased as `T1`) and the `posts` table (aliased as `T2`). The join condition is based on the `PostId` column in `T1` matching the `Id` column in `T2`. This links each comment to its corresponding post.\n\n2. **Date Filtering**: Apply a filter to the joined dataset to isolate only those records where the `CreationDate` in the `comments` table (`T1`) exactly matches the timestamp '2010-07-19 19:19:56.0'. This ensures you are focusing on the specific post created at the given date and time.\n\n3. **Score Retrieval**: From the filtered dataset, extract the value of the `Score` column from the `comments` table (`T1`). This value represents the rating score of the comment associated with the post created on the specified date and time.\n\nThis method guarantees that you accurately retrieve the desired comment's rating score without altering any information from the original SQL query."
        ]
    },
    "406": {
        "sql": "SELECT T1.id FROM cards T1 JOIN rulings T2 ON T1.uuid = T2.uuid JOIN legalities T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature';",
        "question": "Lists by ID all Creature-type cards with legal status.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
        "explain": "legal status refer to status = 'legal'; Goblin-type cards refer to types = 'Creature';",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select the ID of cards**: The operation starts by selecting the `id` column from the `cards` table, which is referred to as `T1`.\n\n2. **Join with the rulings table**: The `cards` table (`T1`) is joined with the `rulings` table (`T2`) using the `uuid` column as the common key. This ensures that only cards with corresponding entries in the `rulings` table are considered.\n\n3. **Join with the legalities table**: The result from the previous join is further joined with the `legalities` table (`T3`) again using the `uuid` column. This ensures that only cards with corresponding entries in the `legalities` table are included.\n\n4. **Filter for legal status**: The operation filters the results to include only those cards where the `status` column in the `legalities` table (`T3`) is set to 'Legal'.\n\n5. **Filter for Creature-type cards**: Additionally, the operation filters the results to include only those cards where the `types` column in the `cards` table (`T1`) is set to 'Creature'.\n\n6. **Final output**: The final output is a list of `id` values from the `cards` table that meet all the specified conditions."
        ]
    },
    "1327": {
        "sql": "SELECT m.first_name, m.last_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Laugh Out Loud';",
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "explain": "full name of members refers to first_name, last_name; 'Laugh Out Loud' is an event name;",
        "solution": [
            "To list the full names of all members of the Student_Club who attended the \"Laugh Out Loud\" event, follow these steps:\n\n1. **Retrieve Member and Attendance Data**: Join the `member` table (aliased as T1) with the `attendance` table (aliased as T2) using the `member_id` from the `member` table and the `link_to_member` from the `attendance` table. This ensures that each member is linked to their attendance records.\n\n2. **Link Attendance to Event**: Join the result from the previous step with the `event` table (aliased as T3) using the `link_to_event` from the `attendance` table and the `event_id` from the `event` table. This connects each attendance record to the corresponding event.\n\n3. **Filter for the Specific Event**: Apply a filter to only include records where the `event_name` in the `event` table is \"Laugh Out Loud\". This narrows down the results to only those members who attended this specific event.\n\n4. **Select Member Names**: From the filtered results, select the `first_name` and `last_name` columns from the `member` table to display the full names of the qualifying members.\n\nThe final output will be a list of full names (first and last names) of all Student_Club members who attended the \"Laugh Out Loud\" event."
        ]
    },
    "1460": {
        "sql": "SELECT T2.first_name || ' ' || T2.last_name AS full_name, T1.cost\nFROM expense T1\nJOIN member T2 ON T1.link_to_member = T2.member_id\nWHERE T1.expense_description = 'Water, Veggie tray, supplies'",
        "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T2.first_name, T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
        "explain": "full name refers to first_name, last name; spent money for refers expense description; expense_description = 'Water, Veggie tray, supplies'",
        "solution": [
            "To solve the question, we need to retrieve the full name of the member who spent money on 'Water, Veggie tray, supplies' along with the cost of the expense. The solution involves the following steps:\n\n1. **Join the Tables**: Combine the `expense` table (referred to as `T1`) and the `member` table (referred to as `T2`) using the `link_to_member` field in `T1` and the `member_id` field in `T2`. This ensures we can access both the expense details and the member's information.\n\n2. **Filter the Expenses**: From the joined tables, filter the records to only include those where the `expense_description` in `T1` matches the exact string 'Water, Veggie tray, supplies'.\n\n3. **Select the Required Fields**: From the filtered records, select the `first_name` and `last_name` from `T2` (to get the member's full name) and the `cost` from `T1` (to get the expense amount).\n\nThe final result will display the full name of the member and the cost associated with the specified expense.",
            "To solve the question, we need to retrieve the full name of the member who spent money on 'Water, Veggie tray, supplies' along with the cost of the expense. The solution involves the following detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `expense` table (aliased as `T1`) and the `member` table (aliased as `T2`). The join condition is `T1.link_to_member = T2.member_id`, which links each expense record to its corresponding member record.\n\n2. **Filter the Expenses**: Apply a filter to the joined tables to include only those records where the `expense_description` field in `T1` exactly matches the string 'Water, Veggie tray, supplies'. This ensures we only consider the specific expense mentioned in the question.\n\n3. **Select the Required Fields**: From the filtered records, extract the following fields:\n   - `first_name` from `T2` to get the member's first name.\n   - `last_name` from `T2` to get the member's last name.\n   - `cost` from `T1` to get the amount spent on the expense.\n\n4. **Output the Result**: The final output will display the concatenated full name (first name and last name) of the member and the cost associated with the specified expense.\n\nThis solution ensures that the SQL query is accurately translated into a step-by-step text operation, preserving all the original logic and information."
        ]
    },
    "712": {
        "sql": "SELECT p.Id AS PostId, c.Text AS CommentText\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE p.Title = 'Group differences on a five point Likert item';",
        "question": "What is the post ID and the comments commented in the post titled by \"Group differences on a five point Likert item\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Id, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'Group differences on a five point Likert item'",
        "explain": "Title = 'Group differences on a five point Likert item';",
        "solution": []
    },
    "94": {
        "sql": "WITH OldestFemaleClient AS (\n    SELECT district_id \n    FROM client \n    WHERE gender = 'F' \n    ORDER BY birth_date ASC \n    LIMIT 1\n),\nLowestAvgSalary AS (\n    SELECT account.account_id, district.A11 AS avg_salary\n    FROM account\n    JOIN district ON account.district_id = district.district_id\n    JOIN disp ON account.account_id = disp.account_id\n    JOIN client ON disp.client_id = client.client_id\n    WHERE client.gender = 'F' AND account.district_id = (SELECT district_id FROM OldestFemaleClient)\n    ORDER BY district.A11 ASC\n    LIMIT 1\n)\nSELECT \n    LowestAvgSalary.account_id,\n    (SELECT MAX(A11) - MIN(A11) FROM district) AS salary_gap\nFROM LowestAvgSalary;",
        "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id , ( SELECT MAX(A11) - MIN(A11) FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "explain": "Female means gender = 'F'; A11 refers to average salary; Gap = highest average salary - lowest average salary; If the person A's birthdate > B's birthdate, it means that person B is order than person A.",
        "solution": [
            "1. **Identify the target clients**: The query focuses on female clients who are the oldest (based on birth date) and have the lowest average salary.\n\n2. **Join the necessary tables**: The query joins the `account`, `district`, `disp`, and `client` tables to gather all required information.\n   - The `account` table is linked to the `district` table via `district_id`.\n   - The `account` table is linked to the `disp` table via `account_id`.\n   - The `disp` table is linked to the `client` table via `client_id`.\n\n3. **Filter for female clients**: The query filters clients to only include those with `gender = 'F'`.\n\n4. **Find the oldest female client**: The subquery `(SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1)` identifies the `district_id` of the oldest female client.\n\n5. **Filter accounts by the identified district**: The main query filters accounts to only include those from the district identified in the previous step.\n\n6. **Calculate the salary gap**: The query calculates the gap between the highest and lowest average salary in the `district` table using `(SELECT MAX(A11) - MIN(A11) FROM district)`.\n\n7. **Order and limit results**: The results are ordered by the average salary (`T2.A11`) in descending order and limited to the first record to ensure the lowest average salary is selected.\n\n8. **Output the account number and salary gap**: The final output includes the `account_id` of the identified client and the calculated salary gap."
        ]
    },
    "1396": {
        "sql": "WITH luisa_info AS (\n    SELECT member_id, link_to_major\n    FROM member\n    WHERE first_name = 'Luisa' AND last_name = 'Guidi'\n)\nSELECT \n    COUNT(a.link_to_event) AS number_of_events_attended,\n    m.major_name\nFROM \n    luisa_info li\nLEFT JOIN \n    attendance a ON li.member_id = a.link_to_member\nLEFT JOIN \n    major m ON li.link_to_major = m.major_id\nGROUP BY \n    m.major_name;",
        "question": "Provide the number of events attended by Luisa Guidi. What is her major?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T3.link_to_event), T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'",
        "explain": "major refers to major_name;",
        "solution": []
    },
    "886": {
        "sql": "SELECT year, COUNT(round) AS race_count FROM races GROUP BY year ORDER BY race_count DESC LIMIT 1;",
        "question": "Which year has the most number of races?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
        "explain": "the most number of races refers to max(round);",
        "solution": [
            "To determine which year has the most number of races, follow these steps:\n\n1. **Group the data by year**: This will organize all the race records into groups where each group contains all the races that occurred in the same year.\n\n2. **Count the number of races in each year**: For each year group, count the number of races (represented by the `round` column) to determine how many races took place in that year.\n\n3. **Order the years by the count of races in descending order**: This will arrange the years from the one with the highest number of races to the one with the lowest.\n\n4. **Select the top year**: The first entry in the ordered list will be the year with the most races.\n\n5. **Return the result**: The final output will be the year that has the highest count of races.",
            "To determine which year has the most number of races, follow these detailed steps:\n\n1. **Extract the year from the races table**: The `year` column in the `races` table contains the year information for each race.\n\n2. **Group the races by year**: Use the `GROUP BY` clause to group all the race records by the `year` column. This creates distinct groups for each year in the dataset.\n\n3. **Count the number of races per year**: For each year group, count the number of races using the `COUNT(round)` function. The `round` column represents individual races, so counting it gives the total number of races for each year.\n\n4. **Order the results by the count of races in descending order**: Use the `ORDER BY` clause with `COUNT(round) DESC` to sort the years from the highest number of races to the lowest.\n\n5. **Limit the result to the top year**: The `LIMIT 1` clause ensures that only the year with the highest number of races is returned in the result.\n\n6. **Return the year with the most races**: The final output of the query is the single year that has the highest count of races, as determined by the previous steps."
        ]
    },
    "1016": {
        "sql": "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId, \n        r.driverId, \n        r.fastestLapTime,\n        (CAST(SUBSTR(r.fastestLapTime, 1, INSTR(r.fastestLapTime, ':') - 1) AS INTEGER) * 60) +\n        CAST(SUBSTR(r.fastestLapTime, INSTR(r.fastestLapTime, ':') + 1, INSTR(r.fastestLapTime, '.') - INSTR(r.fastestLapTime, ':') - 1) AS INTEGER) +\n        (CAST(SUBSTR(r.fastestLapTime, INSTR(r.fastestLapTime, '.') + 1) AS REAL) / 1000) AS lap_time_seconds\n    FROM results r\n    WHERE r.fastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        r.raceId, \n        r.driverId\n    FROM fastest_lap_times flt\n    JOIN results r ON flt.raceId = r.raceId AND flt.driverId = r.driverId\n    JOIN races rc ON r.raceId = rc.raceId\n    JOIN circuits c ON rc.circuitId = c.circuitId\n    WHERE c.name = 'Austrian Grand Prix'\n    AND flt.lap_time_seconds = (SELECT MIN(lap_time_seconds) FROM fastest_lap_times flt2\n                               JOIN results r2 ON flt2.raceId = r2.raceId AND flt2.driverId = r2.driverId\n                               JOIN races rc2 ON r2.raceId = rc2.raceId\n                               JOIN circuits c2 ON rc2.circuitId = c2.circuitId\n                               WHERE c2.name = 'Austrian Grand Prix')\n)\nSELECT ps.duration\nFROM lap_record_race lrr\nJOIN pitStops ps ON lrr.raceId = ps.raceId AND lrr.driverId = ps.driverId;",
        "question": "In the race a driver set the lap record for the Austrian Grand Prix Circuit, how long did he spent at the pit stop at that same race?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.driverId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL), lap_record_race AS ( SELECT T1.raceId, T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix') SELECT T4.duration FROM lap_record_race INNER JOIN pitStops AS T4 on lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId",
        "explain": "lap record means the fastest time recorded which refers to time, how long spent at pitstop refers to duration",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Identify the fastest lap times**:\n   - Extract the `raceId`, `driverId`, and `FastestLapTime` from the `results` table where `FastestLapTime` is not null.\n   - Convert the `FastestLapTime` into seconds for easier comparison. This involves:\n     - Extracting the minutes part (before the colon), converting it to seconds.\n     - Extracting the seconds part (between the colon and the dot), converting it to seconds.\n     - Extracting the milliseconds part (after the dot), converting it to seconds.\n   - Store this data in a temporary table called `fastest_lap_times`.\n\n2. **Find the race and driver with the lap record**:\n   - Join the `results`, `races`, and `circuits` tables to filter races named 'Austrian Grand Prix'.\n   - From the `fastest_lap_times` table, find the minimum lap time in seconds for the 'Austrian Grand Prix'.\n   - Match this minimum time with the converted `FastestLapTime` in the `results` table to identify the `raceId` and `driverId` of the driver who set the lap record.\n   - Store this data in a temporary table called `lap_record_race`.\n\n3. **Retrieve the pit stop duration**:\n   - Join the `lap_record_race` table with the `pitStops` table using the `raceId` and `driverId` to find the duration of the pit stop for the driver who set the lap record in the same race.\n   - The result is the duration of the pit stop.",
            "To solve the question, the following detailed steps are performed:\n\n1. **Extract and Convert Fastest Lap Times**: \n   - Query the `results` table to retrieve `raceId`, `driverId`, and `FastestLapTime` where `FastestLapTime` is not null.\n   - Convert the `FastestLapTime` into seconds for comparison:\n     - Extract the minutes part (before the colon), convert it to seconds by multiplying by 60.\n     - Extract the seconds part (between the colon and the dot), convert it to seconds.\n     - Extract the milliseconds part (after the dot), convert it to seconds by dividing by 1000.\n   - Sum these values to get the total time in seconds and store the results in a temporary table called `fastest_lap_times`.\n\n2. **Identify the Lap Record for the Austrian Grand Prix**: \n   - Join the `results`, `races`, and `circuits` tables to filter races named 'Austrian Grand Prix'.\n   - From the `fastest_lap_times` table, find the minimum lap time in seconds for the 'Austrian Grand Prix'.\n   - Match this minimum time with the converted `FastestLapTime` in the `results` table to identify the `raceId` and `driverId` of the driver who set the lap record.\n   - Store this data in a temporary table called `lap_record_race`.\n\n3. **Retrieve the Pit Stop Duration**: \n   - Join the `lap_record_race` table with the `pitStops` table using the `raceId` and `driverId` to find the duration of the pit stop for the driver who set the lap record in the same race.\n   - The result is the duration of the pit stop, which answers the question."
        ]
    },
    "457": {
        "sql": "SELECT purchaseUrls FROM cards WHERE promoTypes LIKE '%bundle%';",
        "question": "Please list the websites where I can purchase the cards that have the promotional type of \"bundle\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
        "explain": "promotional type of \"bundle\" refers to promoTypes = 'bundle'; websites refers to purchaseUrls",
        "solution": []
    },
    "76": {
        "sql": "SELECT T2.City\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"NSLP Provision Status\" = 'Lunch Provision 2'\nAND T2.County = 'Merced'\nAND T1.\"Low Grade\" = '9'\nAND T1.\"High Grade\" = '12'\nAND T2.EILCode = 'HS';",
        "question": "What is the city location of the high school level school with Lunch Provision 2 whose lowest grade is 9 and the highest grade is 12 in the county of Merced?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Lunch Provision 2' AND T2.County = 'Merced' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12 AND T2.EILCode = 'HS'",
        "explain": "High school can be represented as EILCode = 'HS'",
        "solution": [
            "To find the city location of the high school level school with Lunch Provision 2, where the lowest grade is 9 and the highest grade is 12 in the county of Merced, follow these steps:\n\n1. **Join the tables**: Combine the `frpm` table (referred to as T1) and the `schools` table (referred to as T2) using the `CDSCode` field as the common key.\n\n2. **Filter the data**: Apply the following filters to the joined tables:\n   - From the `frpm` table (T1), select records where the `NSLP Provision Status` is 'Lunch Provision 2'.\n   - From the `schools` table (T2), select records where the `County` is 'Merced'.\n   - From the `frpm` table (T1), select records where the `Low Grade` is 9 and the `High Grade` is 12.\n   - From the `schools` table (T2), select records where the `EILCode` is 'HS' (indicating a high school level).\n\n3. **Retrieve the result**: After applying all the filters, extract the `City` field from the `schools` table (T2) as the final result.\n\nThis process ensures that you retrieve the city location of the specific high school meeting all the given criteria."
        ]
    },
    "586": {
        "sql": "SELECT T3.DisplayName, T1.Title\nFROM posts T1\nJOIN votes T2 ON T1.Id = T2.PostId\nJOIN users T3 ON T2.UserId = T3.Id\nWHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "explain": "bounty amount of 50 refers to BountyAmount = 50; user refers to DisplayName; title mentioning variance refers to Title include 'variance'",
        "solution": [
            "To find the user who added a bounty amount of 50 to a post title mentioning \"variance,\" follow these steps:\n\n1. **Identify the relevant tables**: The query involves three tables:\n   - `posts` (aliased as `T1`): Contains post details, including the title.\n   - `votes` (aliased as `T2`): Contains vote details, including bounty amounts and user IDs.\n   - `users` (aliased as `T3`): Contains user details, including display names.\n\n2. **Join the tables**:\n   - Join the `posts` table (`T1`) with the `votes` table (`T2`) using the `Id` column from `posts` and the `PostId` column from `votes`.\n   - Join the result with the `users` table (`T3`) using the `UserId` column from `votes` and the `Id` column from `users`.\n\n3. **Apply the filters**:\n   - Filter the `votes` table (`T2`) to include only rows where the `BountyAmount` is 50.\n   - Filter the `posts` table (`T1`) to include only rows where the `Title` contains the word \"variance.\"\n\n4. **Retrieve the results**:\n   - Select the `DisplayName` column from the `users` table (`T3`) to get the name of the user.\n   - Select the `Title` column from the `posts` table (`T1`) to confirm the post title.\n\nThis process ensures that you retrieve the display name of the user who added a bounty of 50 to a post with \"variance\" in its title, along with the title of the post."
        ]
    },
    "1239": {
        "sql": "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age\nFROM Patient P\nWHERE P.ID IN (\n    SELECT L.ID\n    FROM Laboratory L\n    WHERE L.HCT >= 52\n    GROUP BY L.ID\n    HAVING COUNT(L.ID) >= 2\n);",
        "question": "Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )",
        "explain": "age = SUBTRACT(year(current_timestamp), year(Birthday)); patient with two or more laboratory examinations refers to COUNT(ID) > 2; hematoclit level exceeded the normal range refers to HCT > = 52;",
        "solution": []
    },
    "1032": {
        "sql": "WITH LeagueMatchCount AS (\n    SELECT league_id, COUNT(id) AS cnt\n    FROM \"Match\"\n    GROUP BY league_id\n),\nMaxMatchCount AS (\n    SELECT MAX(cnt) AS max_count\n    FROM LeagueMatchCount\n)\nSELECT t2.name AS league_name, t1.max_count AS match_count\nFROM MaxMatchCount t1\nJOIN LeagueMatchCount lmc ON t1.max_count = lmc.cnt\nJOIN League t2 ON lmc.league_id = t2.id;",
        "question": "Give the name of the league with the highest matches of all time and how many matches were played in the said league.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t2.name, t1.max_count FROM League AS t2 JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery) AS t1 ON t1.league_id = t2.id",
        "explain": " league with highest matches of all time refers to MAX(COUNT(league_id));",
        "solution": [
            "To solve the question, we need to find the name of the league with the highest number of matches played and the count of those matches. Here's the step-by-step solution:\n\n1. **Count Matches per League**: First, count the number of matches for each league by grouping the matches by their `league_id` and counting the `id` of each match. This gives us a list of leagues with their respective match counts.\n\n2. **Find the Maximum Count**: From the list of match counts, identify the highest number of matches played in any league. This is done by applying the `MAX` function to the counts obtained in the previous step.\n\n3. **Retrieve League Name**: Join the result from the previous step with the `League` table to get the name of the league that corresponds to the `league_id` with the highest match count.\n\n4. **Output the Result**: The final output will display the name of the league and the count of matches played in that league.\n\nThis process ensures we accurately identify the league with the most matches and provide the required details.",
            "To solve the question, we need to find the name of the league with the highest number of matches played and the count of those matches. Here's the detailed step-by-step solution:\n\n1. **Count Matches per League**: \n   - Start by counting the number of matches for each league. This is done by grouping the `Match` table by the `league_id` column and counting the `id` of each match. The result is a temporary table (subquery) with each `league_id` and its corresponding match count (`cnt`).\n\n2. **Find the Maximum Count**: \n   - From the temporary table obtained in the previous step, identify the highest number of matches played in any league. This is achieved by applying the `MAX` function to the `cnt` column, which gives the maximum match count (`max_count`).\n\n3. **Join with League Table**: \n   - Join the result from the previous step (which contains the `league_id` and `max_count`) with the `League` table (`t2`) on the `league_id` to retrieve the name of the league (`t2.name`) that corresponds to the `league_id` with the highest match count.\n\n4. **Output the Result**: \n   - The final output will display the name of the league (`t2.name`) and the count of matches played in that league (`t1.max_count`).\n\nThis process ensures we accurately identify the league with the most matches and provide the required details without altering any information from the original SQL query."
        ]
    },
    "1256": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.CRP = '+' AND T1.Description IS NULL;",
        "question": "How many patients with a abnormal C-reactive protein don't have their data recorded?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP = '+' ) AND T1.Description IS NULL",
        "explain": "abnormal C-reactive protein refers to CRP ='+'; don't have data recorded refers to Description IS NULL;",
        "solution": [
            "To solve the question, \"How many patients with an abnormal C-reactive protein don't have their data recorded?\", the following steps are performed:\n\n1. **Join the Patient and Laboratory tables**: The tables are joined using the patient ID (`ID`) to link the patient records with their laboratory test results.\n\n2. **Filter for abnormal C-reactive protein (CRP)**: Only patients with an abnormal CRP result (indicated by `CRP = '+'`) are selected.\n\n3. **Check for missing patient data**: Among the patients with abnormal CRP, only those whose description is missing (`Description IS NULL`) are included.\n\n4. **Count the qualifying patients**: The total number of patients meeting both criteria (abnormal CRP and missing description) is counted and returned as the result.\n\nThis process ensures that we accurately count patients with abnormal CRP results who also lack recorded data in their patient descriptions.",
            "To solve the question, \"How many patients with an abnormal C-reactive protein don't have their data recorded?\", the following detailed steps are performed:\n\n1. **Select the Patient and Laboratory tables**: The query starts by selecting data from the `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`).\n\n2. **Join the tables on patient ID**: The `Patient` and `Laboratory` tables are joined using the `ID` column to ensure that each patient's records are linked with their corresponding laboratory test results.\n\n3. **Filter for abnormal C-reactive protein (CRP)**: The query filters the results to include only those patients who have an abnormal CRP result, indicated by the condition `T2.CRP = '+'`.\n\n4. **Check for missing patient data**: Among the patients with abnormal CRP, the query further filters to include only those patients whose `Description` field in the `Patient` table is `NULL`, indicating missing or unrecorded data.\n\n5. **Count the qualifying patients**: Finally, the query counts the number of patient IDs (`T1.ID`) that meet both criteria (abnormal CRP and missing description) and returns this count as the result.\n\nThis process ensures an accurate count of patients with abnormal CRP results who also lack recorded data in their patient descriptions."
        ]
    },
    "631": {
        "sql": "SELECT COUNT(*) AS post_count\nFROM postHistory\nWHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'Daniel Vassallo');",
        "question": "How many posts were created by Daniel Vassallo?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "explain": "DisplayName = 'Daniel Vassallo';",
        "solution": [
            "To determine how many posts were created by Daniel Vassallo, follow these steps:\n\n1. **Identify the user**: Locate the user with the display name 'Daniel Vassallo' in the `users` table.\n2. **Join with post history**: Link the user's record to the `postHistory` table using the `Id` from the `users` table and the `UserId` from the `postHistory` table.\n3. **Count the posts**: Count the number of entries in the `postHistory` table that are associated with the identified user.\n\nThe result will be the total number of posts created by Daniel Vassallo."
        ]
    },
    "356": {
        "sql": "SELECT COUNT(*) FROM cards WHERE power = '*';",
        "question": "How many cards have infinite power?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM cards WHERE power = '*'",
        "explain": "infinite power refers to power = '*';",
        "solution": []
    },
    "715": {
        "sql": "SELECT DISTINCT u.DisplayName\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE c.Score BETWEEN 1 AND 5\nAND u.DownVotes = 0;",
        "question": "In comments with score between 1 to 5, list down the display names of the users with 0 down votes.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score BETWEEN 1 AND 5 AND T2.DownVotes = 0",
        "explain": "DownVotes = 0; Score BETWEEN 1 and 5",
        "solution": []
    },
    "1502": {
        "sql": "SELECT DISTINCT g.ChainID\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE c.Currency = 'EUR';",
        "question": "Please list the chains of the gas stations with transactions in euro.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.ChainID FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN gasstations AS T3 ON T1.GasStationID = T3.GasStationID WHERE T2.Currency = 'EUR'",
        "explain": "",
        "solution": []
    },
    "847": {
        "sql": "SELECT d.surname \nFROM qualifying q \nJOIN drivers d ON q.driverId = d.driverId \nWHERE q.raceId = 19 \nORDER BY q.q2 ASC \nLIMIT 1;",
        "question": "What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 19 ORDER BY T1.q2 ASC LIMIT 1",
        "explain": "race number refers to raceId; second qualifying period refers to q2; best lap time refers to MIN(q2);",
        "solution": [
            "To find the surname of the driver with the best lap time in race number 19 during the second qualifying period (q2), follow these steps:\n\n1. **Join the Tables**: Combine the `qualifying` table (referred to as T1) with the `drivers` table (referred to as T2) using the `driverId` field. This links each qualifying record to the corresponding driver's details.\n\n2. **Filter by Race**: From the joined tables, filter the records to include only those where the `raceId` is 19. This narrows down the data to the specific race in question.\n\n3. **Sort by Lap Time**: Sort the filtered records by the `q2` field in ascending order (ASC). Since lower lap times indicate better performance, the first record after sorting will have the best lap time.\n\n4. **Retrieve the Surname**: Select the `surname` field from the `drivers` table (T2) for the top record after sorting. This gives the surname of the driver with the best lap time in the specified race and qualifying period.\n\n5. **Limit the Result**: Ensure only the top result is returned by applying a limit of 1 to the sorted and filtered data."
        ]
    },
    "601": {
        "sql": "SELECT p.Score, pl.LinkTypeId FROM posts p LEFT JOIN postLinks pl ON p.Id = pl.PostId WHERE p.Id = 395;",
        "question": "What is the score and the link type ID for post ID 395?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395",
        "explain": "",
        "solution": []
    },
    "237": {
        "sql": "SELECT a.molecule_id, CASE WHEN m.label = '+' THEN 'YES' ELSE 'NO' END AS is_carcinogenic\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.atom_id = 'TR001_10';",
        "question": "Which molecule does the atom TR001_10 belong to? Please state whether this molecule is carcinogenic or not.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.molecule_id , IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'",
        "explain": "TR001_10 is the atom id; label = '+' mean molecules are carcinogenic",
        "solution": [
            "To determine which molecule the atom TR001_10 belongs to and whether this molecule is carcinogenic, follow these steps:\n\n1. **Identify the molecule**: Locate the atom with the ID 'TR001_10' in the 'atom' table. Retrieve the 'molecule_id' associated with this atom.\n\n2. **Retrieve molecule details**: Using the 'molecule_id' obtained from the previous step, query the 'molecule' table to fetch the details of the molecule, including its 'label'.\n\n3. **Determine carcinogenicity**: Check the 'label' of the molecule. If the label is '+', the molecule is carcinogenic (flag as 'YES'). If the label is not '+', the molecule is not carcinogenic (flag as 'NO').\n\n4. **Return the result**: Display the 'molecule_id' of the molecule and the carcinogenic flag ('YES' or 'NO')."
        ]
    },
    "814": {
        "sql": "SELECT c.colour\nFROM hero_attribute ha\nJOIN superhero s ON ha.hero_id = s.id\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE ha.attribute_value = 100;",
        "question": "List the skin colour of the superheroes with 100 attribute value.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id WHERE T3.attribute_value = 100",
        "explain": "skin colour refers to colour.colour where skin_colour_id = colour.id; 100 attribute value refers to attribute_value = 100;",
        "solution": []
    },
    "1271": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE (T2.SSA = 'negative' OR T2.SSA = '0') \nAND strftime('%Y', T2.Date) < '2000';",
        "question": "How many patients with a normal anti-SSA came to the hospital before 2000?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '2000'",
        "explain": "normal anti-SSA refers to SSA IN('-','+-'); came to the hospital before 2000 refers to YEAR(`First Date`) < 2000; Should compute the number of distinct ones",
        "solution": [
            "To solve the question \"How many patients with a normal anti-SSA came to the hospital before 2000?\", follow these steps:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (aliased as `T1`)\n   - `Laboratory` (aliased as `T2`)\n\n2. **Join the Tables**: Combine the `Patient` and `Laboratory` tables using an inner join on the `ID` column. This ensures that only records with matching `ID` values in both tables are considered.\n\n3. **Filter for Normal Anti-SSA**: From the joined tables, filter the records to include only those where the `SSA` column in the `Laboratory` table has a value of either 'negative' or '0'. This represents patients with a normal anti-SSA result.\n\n4. **Filter for Date Before 2000**: Further filter the records to include only those where the year extracted from the `Date` column in the `Laboratory` table is before '2000'.\n\n5. **Count Distinct Patients**: Finally, count the distinct `ID` values from the `Patient` table to determine the number of unique patients who meet the specified criteria.\n\nThe SQL query accomplishes this by:\n- Joining the `Patient` and `Laboratory` tables.\n- Applying the filters for `SSA` values and the date.\n- Counting the distinct patient IDs."
        ]
    },
    "196": {
        "sql": "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '-' AND a.element = 'cl';",
        "question": "In the non-carcinogenic molecules, how many contain chlorine atoms?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'cl' AND T1.label = '-'",
        "explain": "non-carcinogenic molecules refers to label = '-'; chlorine atoms refers to element = 'cl'",
        "solution": []
    },
    "270": {
        "sql": "SELECT m.label, COUNT(*) AS count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'Ca'\nGROUP BY m.label\nORDER BY count DESC\nLIMIT 1;",
        "question": "Among the molecules with element Calcium, are they mostly carcinogenic or non carcinogenic?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca' GROUP BY T2.label ORDER BY COUNT(T2.label) DESC LIMIT 1",
        "explain": "calcium refers to element = 'ca'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; MAX(label)",
        "solution": [
            "To determine whether molecules containing the element Calcium (Ca) are mostly carcinogenic or non-carcinogenic, follow these steps:\n\n1. **Filter by Element**: Identify all atoms in the database where the element is Calcium ('Ca').\n2. **Join with Molecules**: Link these atoms to their corresponding molecules using the molecule_id as the common key.\n3. **Group by Carcinogenicity**: Group the resulting molecules by their carcinogenicity label (e.g., 'carcinogenic' or 'non-carcinogenic').\n4. **Count Labels**: Count the number of molecules in each group to determine the frequency of each label.\n5. **Order by Count**: Sort the groups in descending order based on the count of molecules.\n6. **Select the Most Common Label**: Retrieve the label (carcinogenic or non-carcinogenic) that appears most frequently among the molecules containing Calcium.\n\nThis process will reveal whether Calcium-containing molecules are predominantly carcinogenic or non-carcinogenic.",
            "To determine whether molecules containing the element Calcium (Ca) are mostly carcinogenic or non-carcinogenic, follow these detailed steps:\n\n1. **Filter by Element**: Query the `atom` table to select all atoms where the element is 'Ca' (Calcium).\n2. **Join with Molecules**: Perform an inner join between the `atom` table (T1) and the `molecule` table (T2) using the `molecule_id` as the common key. This links each Calcium atom to its corresponding molecule.\n3. **Group by Carcinogenicity**: Group the resulting molecules by their `label` field in the `molecule` table, which indicates whether the molecule is carcinogenic or non-carcinogenic.\n4. **Count Labels**: For each group (carcinogenic or non-carcinogenic), count the number of molecules.\n5. **Order by Count**: Sort the groups in descending order based on the count of molecules in each group.\n6. **Select the Most Common Label**: Retrieve the `label` (either 'carcinogenic' or 'non-carcinogenic') that has the highest count, indicating the most common carcinogenicity status among Calcium-containing molecules.\n\nThis process ensures that the result accurately reflects whether Calcium-containing molecules are predominantly carcinogenic or non-carcinogenic."
        ]
    },
    "242": {
        "sql": "SELECT DISTINCT m.molecule_id\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '+' AND (SUBSTR(a.atom_id, -2) BETWEEN '21' AND '25');",
        "question": "Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25' AND T2.label = '+'",
        "explain": "atoms from 21 to 25 refers to SUBSTR(atom_id, 7, 2) between '21' and '25'; label = '+' mean molecules are carcinogenic",
        "solution": [
            "To solve the question, we need to find all distinct molecules that are carcinogenic (labeled with '+') and contain atoms with IDs ending in numbers between 21 and 25. The steps are as follows:\n\n1. **Filter Atoms**: Identify all atoms where the last two characters of their atom IDs are between '21' and '25'.\n2. **Join with Molecules**: Link these atoms to their corresponding molecules using the molecule_id.\n3. **Filter Carcinogenic Molecules**: From the linked molecules, select only those that are labeled as carcinogenic (i.e., their label is '+').\n4. **Remove Duplicates**: Ensure the final list contains only unique molecule IDs to avoid repetition.\n\nThe SQL query accomplishes this by joining the `atom` and `molecule` tables, applying the necessary filters, and using `DISTINCT` to eliminate duplicates."
        ]
    },
    "1432": {
        "sql": "SELECT (SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0.0 END) / COUNT(T2.income_id)) * 100 AS percentage\nFROM member T1\nJOIN income T2 ON T1.member_id = T2.link_to_member\nWHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium';",
        "question": "Among the members with t-shirt size of medium, what is the percentage of the amount 50 received by the Student_Club?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) AS REAL) * 100 / COUNT(T2.income_id) FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium'",
        "explain": "t_shirt_size = 'Medium' where position = 'Member'; percentage = DIVIDE(COUNT(amount = 50), COUNT(member_id)) * 100",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: Combine the `member` table (aliased as `T1`) and the `income` table (aliased as `T2`) using the `member_id` from `T1` and `link_to_member` from `T2` to link the records.\n\n2. **Filter the Data**: From the joined tables, filter the records to include only those where:\n   - The `position` in the `member` table is 'Member'.\n   - The `t_shirt_size` in the `member` table is 'Medium'.\n\n3. **Calculate the Percentage**:\n   - For each record in the filtered data, check if the `amount` in the `income` table is 50. If it is, count it as 1.0; otherwise, count it as 0.\n   - Sum these values to get the total number of records where the amount is 50.\n   - Divide this sum by the total number of records in the filtered data (counted by `income_id`).\n   - Multiply the result by 100 to convert it into a percentage.\n\n4. **Return the Result**: The final result is the calculated percentage of the amount 50 received by the Student_Club among members with a medium t-shirt size."
        ]
    },
    "1061": {
        "sql": "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Adam%' AND weight > 170;",
        "question": "How many players whose first names are Adam and weigh more than 170?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE weight > 170 AND player_name LIKE 'Adam%'",
        "explain": "team names refers to team_long_name; speed class refers to buildUpPlaySpeedClass; buildUpPlaySpeedClass = 'Fast';",
        "solution": []
    },
    "485": {
        "sql": "SELECT r.date FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Reminisce';",
        "question": "When was the ruling for the card 'Reminisce' created?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Reminisce'",
        "explain": "Reminisce refers to name = 'Reminisce'; when created is the date",
        "solution": []
    },
    "1127": {
        "sql": "SELECT DISTINCT c.name AS country_name\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nJOIN Match m ON p.player_api_id = m.home_player_8\nJOIN Country c ON m.country_id = c.id\nWHERE pa.vision >= 90;",
        "question": "Locate players with vision scores of 90 and above, state the country of these players.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t4.name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id INNER JOIN Match AS t3 ON t2.player_api_id = t3.home_player_8 INNER JOIN Country AS t4 ON t3.country_id = t4.id WHERE t1.vision > 89",
        "explain": "vision scores of 90 and above refers to vision > 89",
        "solution": [
            "To locate players with vision scores of 90 and above and state the country of these players, follow these steps:\n\n1. **Filter Players by Vision Score**: Identify all players in the `Player_Attributes` table whose vision score is greater than 89.\n\n2. **Join Player Information**: Link these players to their corresponding records in the `Player` table using the `player_api_id` field to retrieve additional player details.\n\n3. **Link to Match Data**: Connect the players to the `Match` table by matching the `player_api_id` with the `home_player_8` field in the `Match` table. This associates the players with specific matches they participated in.\n\n4. **Retrieve Country Information**: From the `Match` table, use the `country_id` field to join with the `Country` table and fetch the name of the country where the match took place.\n\n5. **Select Distinct Country Names**: Ensure the results are distinct to avoid duplicate country names in the output.\n\nThe final output will list the names of countries where players with vision scores of 90 or above have participated in matches."
        ]
    },
    "155": {
        "sql": "SELECT (COUNT(CASE WHEN type = 'gold' AND issued < '1998-01-01' THEN 1 END) * 100.0 / COUNT(*)) AS percent_gold_pre_1998\nFROM card;",
        "question": "How many percent of 'Gold' cards were issued prior to 1998?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') AS REAL) * 100 / COUNT(card_id) FROM card",
        "explain": "Percent of Gold = [ count(type = 'gold' and issued date < 1998) / count(all cards)] * 100%",
        "solution": []
    },
    "646": {
        "sql": "SELECT T1.Title, T2.UserDisplayName\nFROM posts T1\nJOIN comments T2 ON T1.Id = T2.PostId\nWHERE T1.Score > 60;",
        "question": "Describe the post title which got positive comments and display names of the users who posted those comments.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT T1.Title, T2.UserDisplayName FROM posts AS T1 INNER JOIN comments AS T2 ON T2.PostId = T2.Id WHERE T1.Score > 60",
        "explain": "positive comments refer to Score > 60;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select the post title and user display names**: The query retrieves the `Title` from the `posts` table (aliased as `T1`) and the `UserDisplayName` from the `comments` table (aliased as `T2`).\n\n2. **Join the tables**: The `posts` table is joined with the `comments` table using the condition `T2.PostId = T2.Id`. This ensures that only comments related to the posts are considered.\n\n3. **Filter for positive comments**: The query includes a condition `T1.Score > 60` to filter out posts that have a score greater than 60, indicating positive comments.\n\n4. **Return the result**: The final result is a list of post titles and the display names of users who posted comments on those positively scored posts.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Select the post title and user display names**: The query retrieves the `Title` column from the `posts` table (aliased as `T1`) and the `UserDisplayName` column from the `comments` table (aliased as `T2`).\n\n2. **Join the tables**: The `posts` table (`T1`) is joined with the `comments` table (`T2`) using the condition `T2.PostId = T2.Id`. This ensures that only comments related to the corresponding posts are included in the result set.\n\n3. **Filter for positive comments**: The query includes a condition `T1.Score > 60` to filter out posts that have a score greater than 60. This indicates that the comments on these posts are considered positive.\n\n4. **Return the result**: The final result is a list of post titles (`Title`) and the display names of users (`UserDisplayName`) who posted comments on those positively scored posts.\n\nThis solution ensures that the operations align perfectly with the given SQL query and can be converted back to the original SQL without any loss of information."
        ]
    },
    "1022": {
        "sql": "SELECT preferred_foot \nFROM Player_Attributes \nWHERE potential = (SELECT MIN(potential) FROM Player_Attributes);",
        "question": "What is the preferred foot when attacking of the player with the lowest potential?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT preferred_foot FROM Player_Attributes WHERE potential IS NOT NULL ORDER BY potential ASC LIMIT 1",
        "explain": "preferred foot when attacking refers to preferred_foot; lowest potential refers to MIN(potential);",
        "solution": []
    },
    "1421": {
        "sql": "SELECT (SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.member_id)) AS percentage_business_majors\nFROM member T1\nJOIN major T2 ON T2.major_id = T1.link_to_major\nWHERE T1.position = 'Member';",
        "question": "Calculate the percentage of members who are major Business in the list?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member'",
        "explain": "DIVIDE(SUM(position = 'Member' and major_name = 'Business'), COUNT(member_id)) * 100",
        "solution": [
            "To calculate the percentage of members who are majoring in Business, follow these steps:\n\n1. **Join the Tables**: Combine the `member` table (aliased as `T1`) with the `major` table (aliased as `T2`) using the condition `T2.major_id = T1.link_to_major`. This links each member to their respective major.\n\n2. **Filter Members**: From the joined tables, filter out only those records where the member's position is 'Member'.\n\n3. **Count Business Majors**: For each member, check if their major name is 'Business'. If it is, count it as 1; otherwise, count it as 0. Sum these values to get the total number of Business majors.\n\n4. **Total Members**: Count the total number of members (using `T1.member_id`) who meet the filtering criteria (position is 'Member').\n\n5. **Calculate Percentage**: Divide the number of Business majors by the total number of members and multiply by 100 to get the percentage. Cast the sum of Business majors to a real number to ensure accurate division.\n\nThe final result is the percentage of members who are majoring in Business."
        ]
    },
    "58": {
        "sql": "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704';",
        "question": "What is the phone number and extension number for the school with the zip code 95203-3704? Indicate the school's name.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704'",
        "explain": "",
        "solution": [
            "To find the phone number, extension number, and name of the school located in the zip code '95203-3704', you need to query the 'schools' table. Specifically, you should retrieve the 'Phone' (phone number), 'Ext' (extension number), and 'School' (school name) columns from the table where the 'Zip' column matches the value '95203-3704'."
        ]
    },
    "435": {
        "sql": "SELECT id FROM cards WHERE borderColor = 'black';",
        "question": "How many card border with black color ? List out the card id.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id",
        "explain": "border with black color refers to borderColor = 'black'",
        "solution": []
    },
    "825": {
        "sql": "SELECT g.gender\nFROM gender g\nJOIN superhero s ON g.id = s.gender_id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Phoenix Force';",
        "question": "Identify the gender of the superhero who has the ability of Phoenix Force.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Phoenix Force'",
        "explain": "ability of Phoenix Force refers to power_name = 'Phoenix Force';",
        "solution": []
    },
    "1410": {
        "sql": "SELECT T1.first_name, T1.last_name, SUM(T2.cost) AS total_cost\nFROM member T1\nINNER JOIN expense T2 ON T1.member_id = T2.link_to_member\nWHERE T1.member_id = 'rec4BLdZHS2Blfp4v'",
        "question": "List out the full name and total cost that member id \"rec4BLdZHS2Blfp4v\" incurred?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'",
        "explain": "full name refers to first_name, last name",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select the member's first and last name**: The query retrieves the `first_name` and `last_name` columns from the `member` table (aliased as `T1`) for the member with the ID `rec4BLdZHS2Blfp4v`.\n\n2. **Calculate the total cost incurred by the member**: The query sums up the `cost` column from the `expense` table (aliased as `T2`) for all expenses linked to the member with the ID `rec4BLdZHS2Blfp4v`.\n\n3. **Join the member and expense tables**: The query performs an inner join between the `member` table (`T1`) and the `expense` table (`T2`) using the condition `T1.member_id = T2.link_to_member` to ensure only expenses linked to the specified member are considered.\n\n4. **Filter by the specific member ID**: The query includes a condition `WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'` to focus solely on the member with the given ID.\n\nThe result will display the full name (first and last name) of the member and the total cost they incurred."
        ]
    },
    "1038": {
        "sql": "SELECT l.name AS league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM Match m\nJOIN League l ON m.league_id = l.id\nGROUP BY m.league_id\nORDER BY total_goals ASC\nLIMIT 5;",
        "question": "List the top 5 leagues in ascending order of the number of goals made in all seasons combined.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name, SUM(t2.home_team_goal) + SUM(t2.away_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id GROUP BY t1.name ORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC LIMIT 5",
        "explain": "number of goals made in all seasons combine = SUM(home_team_goal, away_team_goal);",
        "solution": []
    },
    "253": {
        "sql": "SELECT DISTINCT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '#';",
        "question": "List the elements of all the triple bonds.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T3.element FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T1.bond_type = '#'",
        "explain": "triple bond refers to bond_type = '#';",
        "solution": [
            "To list the elements of all the triple bonds, follow these steps:\n\n1. **Identify the bond type**: Filter the bonds in the `bond` table to only include those where the `bond_type` is `'#'`, which represents a triple bond.\n\n2. **Find connected atoms**: For each triple bond identified, use the `connected` table to find the atoms that are part of these bonds. The `connected` table links the `bond_id` from the `bond` table to the `atom_id` in the `atom` table.\n\n3. **Retrieve element information**: For each atom connected to a triple bond, retrieve the `element` from the `atom` table.\n\n4. **Ensure uniqueness**: Use `DISTINCT` to ensure that each element is listed only once, even if it appears in multiple triple bonds.\n\nThis process will yield a list of distinct elements involved in any triple bond in the database."
        ]
    },
    "1426": {
        "sql": "SELECT m.last_name, ma.department, ma.college\nFROM member m\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE ma.major_name = 'Environmental Engineering';",
        "question": "List the last name of members with a major in environmental engineering and include its department and college name.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.last_name, T1.department, T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'",
        "explain": "'Environmental Engineering' is the major_name;",
        "solution": []
    },
    "1427": {
        "sql": "SELECT DISTINCT T2.category, T1.type\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nWHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker';",
        "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
        "explain": "budget category refers to category; events located at refers to location; type = 'Guest Speaker'; 0 budget spent refers to spent = 0; ",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct Categories and Types**: Retrieve distinct combinations of `category` from the `budget` table and `type` from the `event` table.\n\n2. **Join Tables**: Combine the `event` table (aliased as `T1`) and the `budget` table (aliased as `T2`) using an inner join. The join condition is that the `event_id` in the `event` table matches the `link_to_event` in the `budget` table.\n\n3. **Filter by Location**: Only include events where the `location` is 'MU 215'.\n\n4. **Filter by Budget Spent**: Only include records where the `spent` amount in the `budget` table is 0.\n\n5. **Filter by Event Type**: Only include events where the `type` is 'Guest Speaker'.\n\nThe result will be the distinct budget categories and event types that meet all these criteria."
        ]
    },
    "908": {
        "sql": "SELECT MAX(T3.lap) AS max_laps, T2.name AS race_name, T2.year, T1.location AS circuit_location\nFROM circuits T1\nJOIN races T2 ON T1.circuitId = T2.circuitId\nJOIN lapTimes T3 ON T2.raceId = T3.raceId\nGROUP BY T2.raceId\nORDER BY max_laps DESC\nLIMIT 1;",
        "question": "What is the most laps f1 races had? Name the race, year and circuit location where the races with most laps was hosted.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.lap, T2.name, T2.year, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId INNER JOIN lapTimes AS T3 ON T3.raceId = T2.raceId ORDER BY T3.lap DESC LIMIT 1",
        "explain": "",
        "solution": [
            "To find the race with the most laps in F1 history, follow these steps:\n\n1. **Join the tables**: \n   - Start by joining the `circuits` table (aliased as `T1`) with the `races` table (aliased as `T2`) using the `circuitId` field. This links each race to its corresponding circuit location.\n   - Next, join the result with the `lapTimes` table (aliased as `T3`) using the `raceId` field. This connects each race to its lap data.\n\n2. **Sort the data**: \n   - Order the combined data by the `lap` field from the `lapTimes` table in descending order (`DESC`). This ensures the race with the highest number of laps appears first.\n\n3. **Retrieve the top result**: \n   - Use `LIMIT 1` to select only the top row from the sorted data, which represents the race with the most laps.\n\n4. **Display the required information**: \n   - Extract and display the `lap` count, the `name` of the race, the `year` it occurred, and the `location` of the circuit where it was hosted from the joined tables.",
            "To determine the Formula 1 race with the most laps in history, including the race name, year, and circuit location, follow these detailed steps:\n\n1. **Join the Circuits and Races Tables**:\n   - Begin by linking the `circuits` table (referred to as `T1`) with the `races` table (referred to as `T2`) using the `circuitId` field. This establishes a connection between each race and its corresponding circuit location.\n\n2. **Join the Result with Lap Times**:\n   - Next, join the intermediate result from the previous step with the `lapTimes` table (referred to as `T3`) using the `raceId` field. This associates each race with its lap data.\n\n3. **Sort by Lap Count in Descending Order**:\n   - Arrange the combined dataset by the `lap` field from the `lapTimes` table in descending order (`DESC`). This ensures the race with the highest number of laps is positioned at the top.\n\n4. **Retrieve the Top Entry**:\n   - Use `LIMIT 1` to fetch only the first row from the sorted dataset, which corresponds to the race with the maximum number of laps.\n\n5. **Extract and Display the Required Information**:\n   - From the final dataset, select and display the following details:\n     - The `lap` count (number of laps).\n     - The `name` of the race.\n     - The `year` the race took place.\n     - The `location` of the circuit where the race was hosted.\n\nThis process ensures that the query accurately identifies and presents the race with the most laps in F1 history, along with its relevant details."
        ]
    },
    "99": {
        "sql": "SELECT l.account_id\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nWHERE l.duration > 12\nAND strftime('%Y', a.date) = '1993'\nORDER BY l.amount DESC\nLIMIT 1;",
        "question": "Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1",
        "explain": "Loan validity more than 12 months refers to duration > 12",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Filter accounts with loan validity more than 12 months**: Identify all accounts in the `loan` table where the `duration` of the loan is greater than 12 months.\n\n2. **Filter accounts opened in 1993**: From the filtered accounts in step 1, further narrow down the results to only those accounts in the `account` table where the year of the `date` column is 1993. This is done by extracting the year from the `date` column and comparing it to '1993'.\n\n3. **Sort by approved amount in descending order**: Arrange the remaining accounts in descending order based on the `amount` column in the `loan` table to prioritize accounts with the highest approved loan amounts.\n\n4. **Select the top account**: From the sorted list, select the account with the highest approved amount by limiting the result to just the first row.\n\n5. **Return the account ID**: The final output is the `account_id` of the account that meets all the above criteria.\n\nThis process ensures that the account listed is the one with the highest approved loan amount among those opened in 1993 and having a loan duration of more than 12 months."
        ]
    },
    "1478": {
        "sql": "SELECT T1.Segment\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nGROUP BY T1.Segment\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1;",
        "question": "Which segment had the least consumption?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Segment ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "explain": "",
        "solution": [
            "To determine which segment had the least consumption, follow these steps:\n\n1. **Join the Tables**: Combine the `customers` table (aliased as `T1`) with the `yearmonth` table (aliased as `T2`) using the `CustomerID` field as the common key. This ensures that each customer's segment is linked to their consumption records.\n\n2. **Group by Segment**: Group the joined data by the `Segment` column from the `customers` table. This aggregates all consumption records for each segment.\n\n3. **Calculate Total Consumption**: For each segment, sum the `Consumption` values from the `yearmonth` table to get the total consumption per segment.\n\n4. **Order by Consumption**: Sort the segments in ascending order based on their total consumption. This places the segment with the least consumption at the top of the list.\n\n5. **Retrieve the Result**: Limit the output to the first row of the sorted list, which corresponds to the segment with the least consumption.\n\nThe final result will display the segment with the lowest total consumption.",
            "To determine which segment had the least consumption, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `customers` table (aliased as `T1`) and the `yearmonth` table (aliased as `T2`) using the `CustomerID` field as the join condition. This ensures that each customer's segment is correctly linked to their respective consumption records in the `yearmonth` table.\n\n2. **Group by Segment**: Group the resulting dataset by the `Segment` column from the `customers` table (`T1.Segment`). This step aggregates all consumption records for each unique segment.\n\n3. **Calculate Total Consumption**: For each segment group, compute the sum of the `Consumption` values from the `yearmonth` table (`T2.Consumption`). This gives the total consumption for each segment.\n\n4. **Order by Total Consumption**: Sort the grouped segments in ascending order based on their total consumption (the summed `T2.Consumption` values). This ensures that the segment with the least total consumption appears first in the result set.\n\n5. **Retrieve the Result**: Limit the output to the first row of the sorted result set using `LIMIT 1`. This row contains the segment with the least consumption.\n\nThe final output will be the `Segment` value from the `customers` table that has the lowest total consumption across all records in the `yearmonth` table."
        ]
    },
    "199": {
        "sql": "SELECT COUNT(DISTINCT m.molecule_id) \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE a.element = 'na' AND m.label = '-';",
        "question": "In the molecule containing sodium atoms, how many are non-carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'na' AND T2.label = '-'",
        "explain": "non-carcinogenic refers to label = '-'; sodium atoms refers to element = 'na'",
        "solution": []
    },
    "1314": {
        "sql": "SELECT T1.first_name, T1.last_name FROM member T1 JOIN major T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department';",
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "explain": "full name refers to first_name, last_name;",
        "solution": [
            "To list the full names of the students in the Student_Club who come from the Art and Design Department, follow these steps:\n\n1. **Retrieve the student records**: Access the `member` table (aliased as `T1`) to get the first and last names of the students.\n\n2. **Join with the major information**: Link the `member` table to the `major` table (aliased as `T2`) using the `link_to_major` field in the `member` table and the `major_id` field in the `major` table.\n\n3. **Filter by department**: Apply a filter to only include students whose department in the `major` table is 'Art and Design Department'.\n\n4. **Select the required fields**: From the joined and filtered data, select the `first_name` and `last_name` fields to display the full names of the students."
        ]
    },
    "304": {
        "sql": "SELECT DISTINCT m.molecule_id, a.element FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+';",
        "question": "List all carcinogenic molecules and their elements.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "explain": "label = '+' mean molecules are carcinogenic; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "solution": [
            "To list all carcinogenic molecules and their elements, follow these steps:\n\n1. **Identify carcinogenic molecules**: Filter the `molecule` table to include only those molecules where the `label` is '+', indicating they are carcinogenic.\n\n2. **Retrieve elements of these molecules**: Join the filtered `molecule` table with the `atom` table using the `molecule_id` field to get the elements associated with each carcinogenic molecule.\n\n3. **Ensure uniqueness**: Use the `DISTINCT` keyword to avoid duplicate entries in the result, ensuring each molecule and element pair is listed only once.\n\nThe final result will be a list of unique molecule IDs and their corresponding elements for all carcinogenic molecules."
        ]
    },
    "1328": {
        "sql": "SELECT m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Law and Constitutional Studies';",
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "explain": "'Law and Constitutional Studies' is the major name",
        "solution": []
    },
    "47": {
        "sql": "SELECT COUNT(*) / 12.0 AS monthly_average\nFROM schools\nWHERE County = 'Alameda'\n  AND DOC = '52'\n  AND strftime('%Y', OpenDate) = '1980';",
        "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
        "explain": "Elementary School District refers to DOC = 52; Monthly average number of schools that opened in 1980 = count(schools that opened in 1980) / 12",
        "solution": []
    },
    "1051": {
        "sql": "WITH MaxPotential AS (\n    SELECT MAX(potential) AS max_potential\n    FROM Player_Attributes\n)\nSELECT DISTINCT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nJOIN MaxPotential mp ON pa.potential = mp.max_potential;",
        "question": "List all the football player with the highest potential score.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT(t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = (SELECT MAX(potential) FROM Player_Attributes) ",
        "explain": "potential score refers to potential; highest potential score refers to MAX(potential);",
        "solution": [
            "To list all the football players with the highest potential score, follow these steps:\n\n1. **Identify the highest potential score**: First, find the maximum value in the `potential` column from the `Player_Attributes` table. This value represents the highest potential score any player can have.\n\n2. **Retrieve players with the highest potential**: Using the identified maximum potential score, query the `Player` table joined with the `Player_Attributes` table. The join is performed on the `player_api_id` column to link players with their attributes.\n\n3. **Filter for the highest potential**: In the joined table, filter the records to only include players whose `potential` value matches the maximum potential score identified in the first step.\n\n4. **Select distinct player names**: Finally, select the distinct names of the players from the filtered results to ensure no duplicates are included in the output.\n\nThis process ensures that only players with the highest potential score are listed, and their names are unique in the result set."
        ]
    },
    "1521": {
        "sql": "SELECT COUNT(*) \nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-26' \nAND t.Time BETWEEN '08:00:00' AND '09:00:00'\nAND g.Country = 'CZE';",
        "question": "For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'",
        "explain": "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; '2012/8/26' can be represented by '2012-08-26'; during 8:00-9:00 can be represented as Time BETWEEN '08:00:00' AND '09:00:00'",
        "solution": []
    },
    "4": {
        "sql": "SELECT T2.Phone\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Charter Funding Type\" = 'Directly funded'\n  AND T1.\"Charter School (Y/N)\" = 1\n  AND T2.OpenDate > '2000-01-01';",
        "question": "Please list the phone numbers of the direct charter-funded schools that are opened after 2000/1/1.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`Charter School (Y/N)` = 1 AND T2.OpenDate > '2000-01-01'",
        "explain": "Charter schools refers to `Charter School (Y/N)` = 1 in the frpm",
        "solution": [
            "1. **Joining the enrollment and schools data:**  \n   The query uses an `INNER JOIN` between two tables: `frpm` (aliased as T1) and `schools` (aliased as T2). These tables are linked using the `CDSCode` column, ensuring that each enrollment record is matched with its corresponding school data.\n\n2. **Filtering for charter-funded schools:**  \n   The query applies a filter to the `frpm` table (T1) to include only schools where the `Charter Funding Type` is 'Directly funded' and the `Charter School (Y/N)` flag is set to 1. This ensures that only directly funded charter schools are considered.\n\n3. **Filtering for schools opened after 2000/1/1:**  \n   The query further filters the `schools` table (T2) to include only records where the `OpenDate` is later than January 1, 2000. This ensures that only schools opened after this date are included in the results.\n\n4. **Selecting the phone numbers:**  \n   From the `schools` table (T2), the query selects the `Phone` column, which contains the phone numbers of the schools that meet the specified criteria."
        ]
    },
    "694": {
        "sql": "SELECT T3.Text, T1.DisplayName\nFROM users T1\nJOIN posts T2 ON T1.Id = T2.OwnerUserId\nJOIN comments T3 ON T2.Id = T3.PostId\nWHERE T2.Title = 'Analysing wind data with R'\nORDER BY T3.CreationDate DESC\nLIMIT 10;",
        "question": "Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Text, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T2.Title = 'Analysing wind data with R' ORDER BY T1.CreationDate DESC LIMIT 10",
        "explain": "the latest comment refers to MAX(CreationDate);",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join the `users` table (aliased as T1) with the `posts` table (aliased as T2)**: This join connects users to their posts by matching the `Id` from the `users` table with the `OwnerUserId` from the `posts` table.\n\n2. **Join the result with the `comments` table (aliased as T3)**: This join connects posts to their comments by matching the `Id` from the `posts` table with the `PostId` from the `comments` table.\n\n3. **Filter the posts**: Only posts with the title 'Analysing wind data with R' are selected.\n\n4. **Order the results**: The results are ordered by the `CreationDate` of the users in descending order to get the latest comments.\n\n5. **Limit the results**: Only the top 10 results are returned to provide the latest 10 comments.\n\n6. **Select the required fields**: The text of the comments (`T3.Text`) and the display name of the users who left them (`T1.DisplayName`) are selected for the final output."
        ]
    },
    "1081": {
        "sql": "SELECT c.name AS country_name\nFROM League l\nJOIN Country c ON l.country_id = c.id\nWHERE l.name = 'Belgium Jupiler League';",
        "question": "Which country is the Belgium Jupiler League from?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "explain": "Belgium Jupiler League refers to League.name = 'Belgium Jupiler League';",
        "solution": []
    },
    "1226": {
        "sql": "SELECT p.ID, l.\"T-CHO\"\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.\"T-CHO\" = (SELECT MAX(\"T-CHO\") FROM Laboratory)\nORDER BY (julianday('now') - julianday(p.Birthday)) DESC\nLIMIT 1;",
        "question": "Who is the oldest patient with the highest total cholesterol (T-CHO). State the patient ID and T-CHO index.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID, T2.`T-CHO` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-CHO` DESC, T1.Birthday ASC LIMIT 1",
        "explain": "oldest patient refers to MIN(birthday); highest total cholesterol refers to MAX(T-CHO);",
        "solution": []
    },
    "687": {
        "sql": "SELECT COUNT(T2.Id) AS CommentCount\nFROM posts T1\nINNER JOIN comments T2 ON T1.Id = T2.PostId\nGROUP BY T1.Id\nORDER BY T1.Score DESC\nLIMIT 1;",
        "question": "How many comments were added to the post with the highest score?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T2.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId GROUP BY T1.Id ORDER BY SUM(T1.Score) DESC LIMIT 1",
        "explain": "the highest score refers to MAX(Score);",
        "solution": [
            "To find out how many comments were added to the post with the highest score, follow these steps:\n\n1. **Join the tables**: Combine the `posts` table (referred to as `T1`) and the `comments` table (referred to as `T2`) using an inner join. The join condition is that the `Id` column in `T1` (the post's ID) matches the `PostId` column in `T2` (the comment's post ID).\n\n2. **Group the results**: Group the joined data by the `Id` column of the `posts` table (`T1.Id`). This groups all comments by the post they belong to.\n\n3. **Calculate the total score for each post**: For each group (post), calculate the sum of the `Score` column from the `posts` table (`T1.Score`). This gives the total score for each post.\n\n4. **Order the posts by total score**: Sort the grouped results in descending order based on the total score of each post. This ensures the post with the highest score appears first.\n\n5. **Limit the results**: Retrieve only the first row from the sorted results, which corresponds to the post with the highest score.\n\n6. **Count the comments**: For this post, count the number of comments by counting the `Id` values from the `comments` table (`T2.Id`).\n\nThe final result is the count of comments for the post with the highest score.",
            "To determine how many comments were added to the post with the highest score, follow these detailed steps:\n\n1. **Join the tables**: Perform an inner join between the `posts` table (aliased as `T1`) and the `comments` table (aliased as `T2`). The join condition is that the `Id` column in `T1` (representing the post's ID) must match the `PostId` column in `T2` (representing the comment's post ID). This ensures that each comment is linked to its corresponding post.\n\n2. **Group the results**: Group the joined data by the `Id` column of the `posts` table (`T1.Id`). This grouping ensures that all comments are aggregated by the post they belong to.\n\n3. **Calculate the total score for each post**: For each group (post), compute the sum of the `Score` column from the `posts` table (`T1.Score`). This sum represents the total score of each post.\n\n4. **Order the posts by total score**: Sort the grouped results in descending order based on the total score of each post. This sorting ensures that the post with the highest score appears at the top of the list.\n\n5. **Limit the results**: Retrieve only the first row from the sorted results. This row corresponds to the post with the highest score.\n\n6. **Count the comments**: For this specific post, count the number of comments by counting the `Id` values from the `comments` table (`T2.Id`). This count represents the number of comments added to the post with the highest score.\n\nThe final output is the count of comments for the post that has the highest score."
        ]
    },
    "703": {
        "sql": "SELECT COUNT(*) FROM tags WHERE Id < 15 AND Count <= 20;",
        "question": "Among the tags with tag ID below 15, how many of them have 20 count of posts and below?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM tags WHERE Count <= 20 AND Id < 15",
        "explain": "ID below 15 refers to Id < 15; have 20 count of posts and below refers to Count < = 20;",
        "solution": []
    },
    "664": {
        "sql": "SELECT SUM(Score) FROM posts WHERE LasActivityDate LIKE '2010-07-19%';",
        "question": "What is the sum of score of the post on 2010-07-19?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(Score) FROM posts WHERE LasActivityDate LIKE '2010-07-19%'",
        "explain": "on 2010-07-19 refers to LasActivityDate LIKE '2010-07-19%';",
        "solution": []
    },
    "317": {
        "sql": "SELECT (COUNT(DISTINCT CASE WHEN T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100.0 / COUNT(DISTINCT T2.molecule_id)) AS percentage\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+';",
        "question": "Calculate the percentage of carcinogenic molecules which contain the Chlorine element.",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "explain": "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+' and element = 'cl'), COUNT(molecule_id)) as percentage",
        "solution": [
            "To calculate the percentage of carcinogenic molecules that contain the Chlorine element, follow these steps:\n\n1. **Join the Tables**: Combine the `atom` table (referred to as `T1`) and the `molecule` table (referred to as `T2`) using the `molecule_id` field as the common key. This links each atom to its corresponding molecule.\n\n2. **Filter Carcinogenic Molecules**: From the joined data, identify molecules that are carcinogenic by checking if the `label` field in the `molecule` table (`T2.label`) is '+'. This indicates the molecule is carcinogenic.\n\n3. **Filter Chlorine-Containing Molecules**: Further filter the data to include only those molecules where the `element` field in the `atom` table (`T1.element`) is 'cl' (Chlorine).\n\n4. **Count Relevant Molecules**: Count the number of molecules that meet both criteria (carcinogenic and containing Chlorine) using the `COUNT` function. For this, use a `CASE` statement to count only the molecules where both conditions are true (`T2.label = '+' AND T1.element = 'cl'`).\n\n5. **Count Total Carcinogenic Molecules**: Count the total number of carcinogenic molecules (where `T2.label = '+'`) regardless of whether they contain Chlorine or not.\n\n6. **Calculate Percentage**: Divide the count of carcinogenic molecules containing Chlorine by the total count of carcinogenic molecules, then multiply by 100 to get the percentage.\n\nThe final result is the percentage of carcinogenic molecules that contain the Chlorine element.",
            "To calculate the percentage of carcinogenic molecules that contain the Chlorine element, the following steps are performed in the SQL query:\n\n1. **Join the Tables**: The `atom` table (aliased as `T1`) is joined with the `molecule` table (aliased as `T2`) using the `molecule_id` field as the common key. This ensures that each atom is linked to its corresponding molecule.\n\n2. **Filter Carcinogenic Molecules**: The query filters for molecules that are carcinogenic by checking if the `label` field in the `molecule` table (`T2.label`) is '+', indicating a carcinogenic molecule.\n\n3. **Filter Chlorine-Containing Molecules**: The query further filters the data to include only those molecules where the `element` field in the `atom` table (`T1.element`) is 'cl' (Chlorine).\n\n4. **Count Relevant Molecules**: The `COUNT` function is used with a `CASE` statement to count only the molecules where both conditions are met (`T2.label = '+' AND T1.element = 'cl'`). The `CASE` statement returns `T2.molecule_id` if the conditions are satisfied, otherwise `NULL`.\n\n5. **Count Total Carcinogenic Molecules**: The query counts the total number of carcinogenic molecules (where `T2.label = '+'`) by counting all `T2.molecule_id` entries in the joined table.\n\n6. **Calculate Percentage**: The count of carcinogenic molecules containing Chlorine is divided by the total count of carcinogenic molecules, and the result is multiplied by 100 to obtain the percentage.\n\nThe final output of the query is the percentage of carcinogenic molecules that contain the Chlorine element."
        ]
    },
    "449": {
        "sql": "SELECT fd.language, c.type\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'azorius';",
        "question": "What is the language of the card that has azorius watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.language, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'azorius'",
        "explain": "",
        "solution": []
    },
    "1491": {
        "sql": "SELECT Country, COUNT(*) AS TotalValueForMoneyGasStations\nFROM gasstations\nWHERE Segment = 'Value for money'\nGROUP BY Country\nORDER BY TotalValueForMoneyGasStations DESC\nLIMIT 1;",
        "question": "Which country has more \"value for money\" gas stations? Please give a total number of \"value for money\" gas stations in each country.",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT Country , ( SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money' ) FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY COUNT(GasStationID) DESC LIMIT 1",
        "explain": "",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Filter Gas Stations**: First, filter all gas stations where the `Segment` is 'Value for money'.\n\n2. **Group by Country**: Group the filtered gas stations by their `Country`.\n\n3. **Count Gas Stations**: For each country, count the number of gas stations that meet the 'Value for money' segment criteria.\n\n4. **Order by Count**: Order the results in descending order based on the count of gas stations per country.\n\n5. **Limit Results**: Retrieve only the top result (the country with the highest number of 'Value for money' gas stations).\n\n6. **Display Country and Count**: The final output displays the country name and the total count of 'Value for money' gas stations in that country.",
            "To solve the question, the following operations are performed on the database:\n\n1. **Filter Gas Stations**: First, filter all gas stations where the `Segment` is 'Value for money'.\n\n2. **Subquery for Total Count**: For each country, use a subquery to count the total number of gas stations where the `Segment` is 'Value for money'. This subquery is executed for each row in the result set.\n\n3. **Group by Country**: Group the filtered gas stations by their `Country`.\n\n4. **Order by Count**: Order the results in descending order based on the count of gas stations per country.\n\n5. **Limit Results**: Retrieve only the top result (the country with the highest number of 'Value for money' gas stations).\n\n6. **Display Country and Count**: The final output displays the country name and the total count of 'Value for money' gas stations in that country."
        ]
    },
    "1185": {
        "sql": "WITH PatientData AS (\n    SELECT ID\n    FROM Patient\n    WHERE Birthday = '1959-02-18'\n),\nNovemberCholesterol AS (\n    SELECT SUM(\"T-CHO\") AS NovemberTotal\n    FROM Laboratory\n    WHERE ID IN (SELECT ID FROM PatientData)\n    AND strftime('%Y-%m', Date) = '1981-11'\n),\nDecemberCholesterol AS (\n    SELECT SUM(\"T-CHO\") AS DecemberTotal\n    FROM Laboratory\n    WHERE ID IN (SELECT ID FROM PatientData)\n    AND strftime('%Y-%m', Date) = '1981-12'\n)\nSELECT \n    (NovemberTotal - DecemberTotal) / DecemberTotal * 100 AS DecreaseRate\nFROM NovemberCholesterol, DecemberCholesterol;",
        "question": "For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) AS REAL) / SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-02-18'",
        "explain": "born on 1959/2/18 refers to Birthday = '1959-02-18'; calculation = SUBTRACT(SUM(Birthday = '1959-02-18' and Date like '1981-11-%' THEN `T-CHO`), SUM(Birthday = '1959-02-18' and Date like '1981-12-%' THEN `T-CHO`))",
        "solution": [
            "To solve the question, we need to calculate the decrease rate of the total cholesterol (T-CHO) for the patient born on February 18, 1959, from November to December in 1981. Here are the steps:\n\n1. **Identify the Patient**: Locate the patient in the `Patient` table whose birthday is February 18, 1959.\n2. **Retrieve Laboratory Data**: Join the `Patient` table with the `Laboratory` table using the patient's ID to access their laboratory records.\n3. **Filter by Date**: Focus on the laboratory records from November and December 1981.\n4. **Calculate Total Cholesterol for November**: Sum the total cholesterol values (`T-CHO`) for all records dated in November 1981.\n5. **Calculate Total Cholesterol for December**: Sum the total cholesterol values (`T-CHO`) for all records dated in December 1981.\n6. **Compute the Decrease Rate**: Subtract the December total from the November total to find the decrease in cholesterol. Then, divide this decrease by the December total to get the decrease rate.\n7. **Return the Result**: The final result is the computed decrease rate."
        ]
    },
    "761": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Male'\nAND s.weight_kg > (\n    SELECT AVG(weight_kg) * 0.79\n    FROM superhero\n);",
        "question": "Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79",
        "explain": "super hero names refers to superhero_name;male superheros refers to gender = 'Male';Calculation = weight_kg > MULTIPLY(AVG(weight_kg), 0.79)",
        "solution": []
    },
    "399": {
        "sql": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL;",
        "question": "Lists all types of cards available in arena.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL",
        "explain": "all types refer to subtypes and supertypes\n\navailble in arena refers to availability = 'arena'",
        "solution": [
            "To list all types of cards available in Arena, perform the following operations:\n\n1. **Filter the cards table**: Select only those cards where the `availability` column is set to 'arena'.\n2. **Exclude null values**: Ensure that both the `subtypes` and `supertypes` columns are not null for the selected cards.\n3. **Retrieve distinct combinations**: From the filtered cards, retrieve all unique combinations of `subtypes` and `supertypes` to avoid duplicates.\n\nThis will provide a list of all distinct card types (both subtypes and supertypes) available in Arena."
        ]
    },
    "1182": {
        "sql": "SELECT COUNT(*) AS TotalLabTestsIn1995\nFROM Laboratory\nWHERE ID = (SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS')\nAND strftime('%Y', Date) = '1995';",
        "question": "For the patient who first came to the hospital on 1991/6/13 who was diagnosed with SJS, what is the total number of his/her Laboratory tests in 1995?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM Laboratory WHERE ID = ( SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS' ) AND STRFTIME('%Y', Date) = '1995'",
        "explain": "1991/6/13 refers to `First Date` = '1991-06-13'; 'SJS' refers to Diagnosis; total number of his/her Laboratory tests refers to COUNT(ID); 1995 refers to Date",
        "solution": []
    },
    "3": {
        "sql": "SELECT s.MailStreet\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE f.\"FRPM Count (K-12)\" = (SELECT MAX(\"FRPM Count (K-12)\") FROM frpm);",
        "question": "What is the unabbreviated mailing street address of the school with the highest FRPM count for K-12 students?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.MailStreet FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 1",
        "explain": "",
        "solution": []
    },
    "456": {
        "sql": "SELECT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';",
        "question": "What's the list of all types for the card \"Molimo, Maro-Sorcerer\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'",
        "explain": "card \"Molimo, Maro-Sorcerer\" refers to name = 'Molimo, Maro-Sorcerer'; list of all types refers to subtypes,supertypes",
        "solution": []
    },
    "1317": {
        "sql": "SELECT COUNT(*) AS medium_tshirt_count\nFROM event T1\nJOIN attendance T2 ON T1.event_id = T2.link_to_event\nJOIN member T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium';",
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
        "explain": "Women's Soccer is an event name; T-shirt that is in medium size refers to t_shirt_size = 'Medium'",
        "solution": [
            "To solve the question, we need to perform the following operations:\n\n1. **Filter Events**: Identify the event with the name \"Women's Soccer\" from the `event` table (referred to as T1).\n\n2. **Join with Attendance**: Link the filtered event to the `attendance` table (T2) using the event ID (`event_id` in T1 matches `link_to_event` in T2). This will give us all attendance records for the \"Women's Soccer\" event.\n\n3. **Join with Member**: Further link the attendance records to the `member` table (T3) using the member ID (`link_to_member` in T2 matches `member_id` in T3). This will provide details of the members who attended the event.\n\n4. **Filter by T-shirt Size**: From the linked records, filter out only those members who have a T-shirt size of 'Medium'.\n\n5. **Count the Results**: Finally, count the number of records that meet all the above criteria. This count represents the number of students from the Student_Club who attended the \"Women's Soccer\" event and want a T-shirt in medium size."
        ]
    },
    "260": {
        "sql": "SELECT COUNT(a.atom_id) AS total_atoms\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE b.bond_type = '#' AND (a.element = 'p' OR a.element = 'br');",
        "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
        "explain": "triple bond refers to bond_type = '#'; phosphorus refers to element = 'p'; bromine refers to element = 'br'",
        "solution": []
    },
    "1261": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.RF < 20 AND E.Thrombosis = 0;",
        "question": "How many patients with a normal RF don't have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND T1.Thrombosis = 0",
        "explain": "normal RF refers to RF < 20; don't have thrombosis refers to Thrombosis = '0';",
        "solution": []
    },
    "1039": {
        "sql": "SELECT AVG(long_shots) AS average_long_shots\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Ahmed Samir Farag');",
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
        "explain": "average number of long shot = DIVIDE(SUM(long_shots), COUNT(player_fifa_api_id));",
        "solution": []
    },
    "677": {
        "sql": "SELECT COUNT(*) AS post_count\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE users.DisplayName = 'Jay Stevens'\nAND strftime('%Y', posts.CreaionDate) = '2010';",
        "question": "How many posts did Jay Stevens have in 2010?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2010' AND T1.DisplayName = 'Jay Stevens'",
        "explain": "DisplayName = 'Jay Stevens'; in 2010 refers to YEAR(CreationDate) = 2010;",
        "solution": []
    },
    "88": {
        "sql": "SELECT s.AdmEmail1, sc.sname\nFROM schools s\nJOIN satscores sc ON s.CDSCode = sc.cds\nWHERE sc.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);",
        "question": "What is the administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500?Provide the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.AdmEmail1, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "explain": "",
        "solution": []
    },
    "960": {
        "sql": "SELECT AVG(CAST(fastestLapSpeed AS REAL)) AS average_fastest_lap_speed\nFROM results\nJOIN races ON results.raceId = races.raceId\nWHERE races.year = 2009 AND races.name = 'Spanish Grand Prix';",
        "question": "What is the average of fastest lap speed in the 2009 Spanish Grand Prix race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "explain": "Spanish Grand Prix is the name of race refers to name = 'Spanish Grand Prix'; average fastest lap speed refers to avg(fastestLapSpeed);",
        "solution": []
    },
    "428": {
        "sql": "SELECT T1.name, T2.translation\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.id = 5\nGROUP BY T1.name, T2.translation;",
        "question": "What is the name of set number 5 and its translation?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 5 GROUP BY T1.name, T2.translation",
        "explain": "set number 5 refers to id = 5",
        "solution": [
            "To find the name of set number 5 and its translation, follow these steps:\n1. Start by identifying the set with the ID 5 in the `set_translations` table.\n2. Join this set with the `sets` table using the `code` field from the `sets` table and the `setCode` field from the `set_translations` table.\n3. From the joined tables, select the `name` field from the `sets` table and the `translation` field from the `set_translations` table.\n4. Ensure the results are grouped by both the `name` and `translation` fields to avoid duplicates.\n\nThe result will provide the name of set number 5 and its corresponding translation.",
            "To find the name of set number 5 and its translation, follow these steps:\n1. Begin by querying the `sets` table (aliased as T1) and the `set_translations` table (aliased as T2).\n2. Perform an inner join between these two tables using the condition `T1.code = T2.setCode` to link the set with its translation.\n3. Apply a filter to the joined tables to only include the row where the `id` field in the `set_translations` table (T2) is equal to 5.\n4. From the filtered and joined tables, select the `name` field from the `sets` table (T1) and the `translation` field from the `set_translations` table (T2).\n5. Group the results by both the `name` and `translation` fields to ensure no duplicate entries are returned.\n\nThe result will display the name of set number 5 and its corresponding translation."
        ]
    },
    "883": {
        "sql": "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC;",
        "question": "How many races were there in 2005? Name all the races in descending order.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC",
        "explain": "",
        "solution": [
            "To answer the question \"How many races were there in 2005? Name all the races in descending order,\" the following steps are performed:\n\n1. **Filter the Races by Year**: The database is queried to select only those races that occurred in the year 2005. This is done by applying a condition (`WHERE year = 2005`) to filter the records.\n\n2. **Select the Race Names**: From the filtered records, only the `name` column is selected to retrieve the names of the races.\n\n3. **Order the Results**: The names of the races are then sorted in descending alphabetical order (`ORDER BY name DESC`).\n\nThis process ensures that the output is a list of all race names from 2005, presented in reverse alphabetical order."
        ]
    },
    "1392": {
        "sql": "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' ORDER BY amount DESC LIMIT 1;",
        "question": "Indicate the top source of funds received in September 2019 based on their amount.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' and '2019-09-30' ORDER BY source DESC LIMIT 1",
        "explain": "top source funds refers to MAX(source); September 2019 means date_received BETWEEN '2019-09-01' and '2019-09-30'",
        "solution": [
            "To determine the top source of funds received in September 2019 based on their amount, follow these steps:\n\n1. **Filter the Data**: Extract all records from the `income` table where the `date_received` falls within September 2019 (i.e., between '2019-09-01' and '2019-09-30').\n\n2. **Sort the Data**: Arrange the filtered records in descending order based on the `source` column. This will help identify the highest source of funds.\n\n3. **Select the Top Entry**: Retrieve only the top entry from the sorted list, which represents the highest source of funds received in September 2019.\n\nThe final result will display the `source` of the highest funds received during the specified period.",
            "To determine the top source of funds received in September 2019 based on their amount, follow these detailed steps:\n\n1. **Filter the Data**: Query the `income` table to extract all records where the `date_received` column falls within the month of September 2019. Specifically, the date should be between '2019-09-01' (inclusive) and '2019-09-30' (inclusive).\n\n2. **Sort the Data**: After filtering, sort the resulting records in descending order based on the `source` column. This ensures that the highest source of funds appears at the top of the list.\n\n3. **Limit the Results**: Retrieve only the first record from the sorted list using the `LIMIT 1` clause. This record represents the top source of funds received in September 2019.\n\nThe final output will display the `source` value of the highest funds received during the specified period."
        ]
    },
    "874": {
        "sql": "SELECT d.forename, d.surname\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE rc.name = 'San Marino Grand Prix' AND rc.year = 2006 AND r.position = 2;",
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
        "explain": "finished second refers to position = 2;",
        "solution": []
    },
    "895": {
        "sql": "SELECT AVG(l.milliseconds) AS average_lap_time\nFROM lapTimes l\nJOIN races r ON l.raceId = r.raceId\nJOIN drivers d ON l.driverId = d.driverId\nWHERE r.year = 2009 AND r.name = 'Malaysian Grand Prix' AND d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "question": "What is the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.milliseconds) FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.year = 2009 AND T1.name = 'Malaysian Grand Prix'",
        "explain": "average lap time = AVG(milliseconds); 'Lewis Hamilton' refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; 'Malaysian Grand Prix' refers to races.name = 'Malaysian Grand Prix'",
        "solution": []
    },
    "870": {
        "sql": "SELECT q.q1\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 345 AND d.forename = 'Lucas' AND d.surname = 'di Grassi';",
        "question": "What's Lucas di Grassi's Q1 result in the race No. 345?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 345 AND T2.forename = 'Lucas' AND T2.surname = 'di Grassi'",
        "explain": "race number refers to raceId;",
        "solution": []
    },
    "1388": {
        "sql": "SELECT T1.first_name, T1.last_name, T2.source, SUM(T2.amount) AS total_income\nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nGROUP BY T1.first_name, T1.last_name, T2.source\nORDER BY total_income DESC\nLIMIT 1;",
        "question": "Which students manage to generate the highest income. State his/her full name along with the income source.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T1.first_name, T1.last_name, T2.source FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.first_name, T1.last_name, T2.source ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "explain": "name of students means the full name; full name refers to first_name, last_name; generate the highest income refers to MAX(income.amount);",
        "solution": [
            "To find the student who generates the highest income along with their income source, follow these steps:\n\n1. **Join the Tables**: Combine the `member` table (referred to as `T1`) and the `income` table (referred to as `T2`) using the `member_id` from `T1` and `link_to_member` from `T2` to match records.\n\n2. **Group the Data**: Group the joined data by the student's first name (`T1.first_name`), last name (`T1.last_name`), and the income source (`T2.source`). This ensures that each unique combination of student and income source is treated as a separate group.\n\n3. **Calculate Total Income**: For each group, calculate the sum of the income amounts (`SUM(T2.amount)`). This gives the total income generated by each student from each source.\n\n4. **Sort by Total Income**: Sort the groups in descending order based on the total income calculated in the previous step. This places the student with the highest income at the top of the list.\n\n5. **Limit Results**: Retrieve only the top result from the sorted list, which corresponds to the student with the highest income and their income source.\n\nThe final output will include the student's first name, last name, and the source of their highest income.",
            "To determine which student generates the highest income along with their income source, execute the following steps:\n\n1. **Join the Tables**: Perform an inner join between the `member` table (aliased as `T1`) and the `income` table (aliased as `T2`). The join condition is `T1.member_id = T2.link_to_member`, ensuring that each student is matched with their corresponding income records.\n\n2. **Group the Data**: Group the joined data by the student's first name (`T1.first_name`), last name (`T1.last_name`), and the income source (`T2.source`). This grouping ensures that each unique combination of student and income source is treated as a distinct entity.\n\n3. **Calculate Total Income**: For each group, compute the sum of the income amounts (`SUM(T2.amount)`). This step aggregates the total income generated by each student from each source.\n\n4. **Sort by Total Income**: Sort the grouped data in descending order based on the total income calculated in the previous step. This arrangement places the student with the highest income at the top of the list.\n\n5. **Limit Results**: Retrieve only the first row from the sorted list, which represents the student with the highest income and their corresponding income source.\n\nThe final output will display the student's first name, last name, and the source of their highest income."
        ]
    },
    "1367": {
        "sql": "SELECT m.college\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nGROUP BY m.college\nORDER BY COUNT(mb.member_id) DESC\nLIMIT 1;",
        "question": "Which college do most of the members go to?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "explain": "college most members go refers to MAX(COUNT(major.college))",
        "solution": []
    },
    "1516": {
        "sql": "SELECT COUNT(*) AS NumberOfTransactions\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-26'\n  AND t.Time < '13:00:00'\n  AND c.Currency = 'CZK';",
        "question": "How many transactions were paid in CZK in the morning of 2012/8/26?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-26' AND T1.Time < '13:00:00' AND T2.Currency = 'CZK'",
        "explain": "'2012/8/26' can be represented by '2012-08-26'; The morning refers to the time before '13:00:00'",
        "solution": []
    },
    "1345": {
        "sql": "SELECT COUNT(*) FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "question": "How many majors are there in \"College of Humanities and Social Sciences\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(major_name) FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "explain": "",
        "solution": []
    },
    "1268": {
        "sql": "SELECT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.SM NOT IN ('negative', '0')\nORDER BY p.Birthday DESC\nLIMIT 3;",
        "question": "For the patients with an abnormal anti-SM, please list the IDs of the three youngest ones.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM NOT IN ('negative','0') ORDER BY T1.Birthday DESC LIMIT 3",
        "explain": "abnormal anti-SM refers to SM NOT IN ('negative', '0'); youngest refers to MAX(Birthday);",
        "solution": []
    },
    "1523": {
        "sql": "SELECT g.Country \nFROM transactions_1k t \nJOIN gasstations g ON t.GasStationID = g.GasStationID \nWHERE t.CardID = 667467;",
        "question": "Which country was the card owner of No.667467 in?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.CardID = '667467'",
        "explain": "",
        "solution": []
    },
    "764": {
        "sql": "SELECT sp.power_name FROM hero_power hp JOIN superpower sp ON hp.power_id = sp.id WHERE hp.hero_id = 1;",
        "question": "What are the superpowers of heroes with ID 1?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1",
        "explain": "superpowers refers to power_name; heroes with ID 1 refers to hero_id = 1;",
        "solution": []
    },
    "1307": {
        "sql": "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE (L.RBC <= 3.5 OR L.RBC >= 6.0) AND P.Admission = '-';",
        "question": "Please list the patient's ID if he or she has an abnormal level of red blood cell and is followed at the outpatient clinic.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RBC <= 3.5 OR T2.RBC >= 6) AND T1.Admission = '-'",
        "explain": "RBC < = 3.5 or RBC > = 6.0 means the patient has an abnormal level of red blood cell; 3.5 < RBC < 6.0 means the patient has a normal level of red blood cell; followed at the outpatient clinic refers to Admission = '-';",
        "solution": []
    },
    "835": {
        "sql": "SELECT \n    (COUNT(CASE WHEN a.alignment = 'Good' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_good\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    alignment a ON s.alignment_id = a.id\nWHERE \n    p.publisher_name = 'Marvel Comics';",
        "question": "Among all superheroes in Marvel Comics, identify the percentage of 'good' superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics'",
        "explain": "Marvel Comics refers to publisher_name = 'Marvel Comics'; percentage = MULTIPLY(DIVIDE(SUM(alignment = 'Good' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100.0); good superheroes refers to alignment = 'Good';",
        "solution": []
    },
    "1043": {
        "sql": "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers';",
        "question": "What is the short name of the football team Queens Park Rangers?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers'",
        "explain": "short name of the football team refers to team_short_name; Queens Park Rangers refers to team_long_name = 'Queens Park Rangers';",
        "solution": []
    },
    "1096": {
        "sql": "SELECT AVG(overall_rating) AS average_overall_rating\nFROM Player_Attributes\nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Pietro Marino');",
        "question": "Calculate the average overall rating of Pietro Marino.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Pietro Marino'",
        "explain": "Pietro Marino refers to player_name = 'Pietro Marino'; average overall rating AVG(T1.overall_rating)",
        "solution": []
    },
    "67": {
        "sql": "SELECT COUNT(*) AS TotalClosures\nFROM schools\nWHERE strftime('%Y', ClosedDate) = '1989'\nAND City = 'San Francisco'\nAND DOCType = 'Community College District';",
        "question": "What is the total amount of Community College District closure in 1989 in the city of San Francisco?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', ClosedDate) = '1989' AND City = 'San Francisco' AND DOCType = 'Community College District'",
        "explain": "",
        "solution": [
            "To find the total amount of Community College District closures in 1989 in the city of San Francisco, follow these steps:\n\n1. **Filter the Data**: From the 'schools' table, select only those records where:\n   - The 'ClosedDate' year is 1989 (using the `strftime` function to extract the year).\n   - The 'City' is 'San Francisco'.\n   - The 'DOCType' is 'Community College District'.\n\n2. **Count the Schools**: Count the number of 'School' entries that meet the above criteria.\n\n3. **Return the Result**: The result will be the total count of Community College District closures in San Francisco in 1989."
        ]
    }
}