{
    "722": {
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE s.superhero_name = 'Apocalypse';",
        "question": "What is the colour of Apocalypse's skin?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id WHERE T1.superhero_name = 'Apocalypse'",
        "explain": "Apocalypse refers to superhero_name = 'Apocalypse'; colour of skin refers to colour where skin_colour_id = colour.id",
        "solution": []
    },
    "181": {
        "sql": "SELECT c.client_id\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN loan l ON a.account_id = l.account_id\nWHERE c.gender = 'F'\nORDER BY l.amount DESC\nLIMIT 3;",
        "question": "Please provide the IDs of the 3 female clients with the largest loans.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T4 on T1.client_id= T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id  INNER JOIN loan AS T3 ON T2.account_id = T3.account_id and T4.account_id = T3.account_id WHERE T1.gender = 'F' ORDER BY T3.amount DESC LIMIT 3",
        "explain": "Female refers to gender = 'F'",
        "solution": []
    },
    "581": {
        "sql": "SELECT u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Open source tools for visualizing multi-dimensional data?';",
        "question": "Who is the editor of the post titled 'Open source tools for visualizing multi-dimensional data?'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'",
        "explain": "'Open source tools for visualizing multi-dimensional data' is the Title of Post; editor refers to DisplayName;",
        "solution": [
            "To find the editor of the post titled 'Open source tools for visualizing multi-dimensional data?', follow these steps:\n\n1. **Identify the post**: Locate the post in the `posts` table where the `Title` column matches the exact string 'Open source tools for visualizing multi-dimensional data?'.\n\n2. **Retrieve the owner's user ID**: From the identified post, extract the `OwnerUserId` value, which links the post to its owner in the `users` table.\n\n3. **Find the user details**: Using the `OwnerUserId` obtained in the previous step, search the `users` table for the corresponding user record.\n\n4. **Display the editor's name**: From the user record found, retrieve the value in the `DisplayName` column, which represents the name of the editor.\n\nThis process ensures that you correctly identify and display the editor of the specified post by linking the post to its owner in the database."
        ]
    },
    "25": {
        "sql": "SELECT T1.sname AS \"School Name\", T2.`Charter Funding Type` AS \"Funding Type\"\nFROM satscores T1\nINNER JOIN frpm T2 ON T1.cds = T2.CDSCode\nWHERE T2.`District Name` LIKE 'Riverside%'\nGROUP BY T1.sname, T2.`Charter Funding Type`\nHAVING AVG(T1.AvgScrMath) > 400;",
        "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.sname, T2.`Charter Funding Type` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T2.`District Name` LIKE 'Riverside%' GROUP BY T1.sname, T2.`Charter Funding Type` HAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400",
        "explain": "Average of average math = sum(average math scores) / count(schools).",
        "solution": [
            "1. **Joining the SAT scores and funding data:**  \n   The query uses an `INNER JOIN` between two tables: `satscores` (aliased as T1) and `frpm` (aliased as T2). These tables are linked using the `CDSCode` from the `frpm` table and the `cds` column from the `satscores` table. This ensures that each school's SAT score data is matched with its corresponding funding information.\n\n2. **Filtering for Riverside schools:**  \n   The query includes a `WHERE` clause to filter schools located in districts with names starting with \"Riverside\". This is done using the condition `T2.`District Name` LIKE 'Riverside%'`.\n\n3. **Grouping by school name and funding type:**  \n   The results are grouped by the school name (`T1.sname`) and the funding type (`T2.`Charter Funding Type`). This ensures that each unique combination of school name and funding type is treated as a distinct group.\n\n4. **Calculating the average math score:**  \n   For each group, the query calculates the average of the `AvgScrMath` column from the `satscores` table. This is done by summing all the math scores (`SUM(T1.AvgScrMath)`) and dividing by the count of records (`COUNT(T1.cds)`). The result is cast to a `REAL` type for precision.\n\n5. **Filtering by average math score:**  \n   The `HAVING` clause filters the groups to include only those where the calculated average math score is greater than 400. This ensures that only schools meeting this academic threshold are included in the results.\n\n6. **Selecting the school name and funding type:**  \n   The final output includes the school name (`T1.sname`) and the corresponding funding type (`T2.`Charter Funding Type`), as requested in the question."
        ]
    },
    "156": {
        "sql": "SELECT T1.client_id\nFROM disp T1\nJOIN loan T2 ON T1.account_id = T2.account_id\nJOIN account T3 ON T1.account_id = T3.account_id\nWHERE T1.type = 'OWNER'\nORDER BY T2.amount DESC\nLIMIT 1;",
        "question": "Who is the owner of the account with the largest loan amount?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.client_id FROM disp AS T1 INNER JOIN account AS T3 ON T1.account_id = T3.account_id INNER JOIN loan AS T2 ON T3.account_id = T2.account_id WHERE T1.type = 'OWNER' ORDER BY T2.amount DESC LIMIT 1",
        "explain": "",
        "solution": [
            "To find the owner of the account with the largest loan amount, follow these steps:\n\n1. **Join the `disp` table (aliased as T1) with the `account` table (aliased as T3)** using the `account_id` field. This links each account to its associated disposition records.\n\n2. **Join the result with the `loan` table (aliased as T2)** using the `account_id` field. This links each account to its loan details.\n\n3. **Filter the records** to include only those where the `type` field in the `disp` table (T1) is 'OWNER'. This ensures we only consider account owners.\n\n4. **Sort the filtered records** by the `amount` field in the `loan` table (T2) in descending order. This arranges the loans from the largest to the smallest.\n\n5. **Limit the result to the first record** to retrieve the owner of the account with the largest loan amount.\n\n6. **Select the `client_id` field** from the `disp` table (T1) to identify the owner.\n\nThe final output will be the `client_id` of the owner of the account with the largest loan amount."
        ]
    },
    "269": {
        "sql": "SELECT COUNT(DISTINCT T3.bond_id) AS bond_count\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nJOIN bond T3 ON T2.molecule_id = T3.molecule_id\nWHERE T1.element = 'i';",
        "question": "How many bond id have element iodine?",
        "db_id": "toxicology",
        "res": 0,
        "ground_truth": "SELECT COUNT(T3.bond_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T1.element = 'i'",
        "explain": "iodine refers to element = 'i'",
        "solution": [
            "To determine how many bond IDs have the element iodine, follow these steps:\n\n1. **Join the `atom` table (aliased as T1) with the `molecule` table (aliased as T2)**:\n   - Use the `molecule_id` column to link records from both tables. This ensures that each atom is associated with its corresponding molecule.\n\n2. **Join the result with the `bond` table (aliased as T3)**:\n   - Again, use the `molecule_id` column to link records from the `molecule` table (T2) with the `bond` table (T3). This ensures that each bond is associated with its corresponding molecule.\n\n3. **Filter the records**:\n   - Apply a condition to only include records where the `element` column in the `atom` table (T1) is equal to 'i' (iodine).\n\n4. **Count the bond IDs**:\n   - Finally, count the number of distinct `bond_id` values from the `bond` table (T3) that meet the above criteria.\n\nThe result will be the total number of bond IDs associated with the element iodine.",
            "To determine how many bond IDs have the element iodine, follow these detailed steps:\n\n1. **Join the `atom` table (aliased as T1) with the `molecule` table (aliased as T2)**:\n   - Use the `molecule_id` column as the joining condition to link records from the `atom` table (T1) to the `molecule` table (T2). This ensures that each atom is correctly associated with its corresponding molecule.\n\n2. **Join the resulting dataset with the `bond` table (aliased as T3)**:\n   - Use the `molecule_id` column again to link records from the `molecule` table (T2) to the `bond` table (T3). This ensures that each bond is associated with its corresponding molecule.\n\n3. **Filter the records to include only those with the element iodine**:\n   - Apply a condition to the `element` column in the `atom` table (T1) to only include records where the element is 'i' (iodine).\n\n4. **Count the distinct bond IDs**:\n   - Calculate the count of distinct `bond_id` values from the `bond` table (T3) that meet the filtering condition.\n\nThe final result will be the total number of bond IDs associated with the element iodine."
        ]
    },
    "125": {
        "sql": "SELECT \n    T3.A2 AS district_name,\n    ((T3.A13 - T3.A12) * 100.0 / T3.A12) AS unemployment_rate_increment_percentage\nFROM \n    loan T1\nJOIN \n    account T2 ON T1.account_id = T2.account_id\nJOIN \n    district T3 ON T2.district_id = T3.district_id\nWHERE \n    T1.status = 'D';",
        "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
        "explain": "Unemployment increment rate in percentage = [(unemployment rate 2016 - unemployment rate 2015) / unemployment rate 2015] * 100; unemployment rate 2015 appears in the A12; unemployment rate 2016 appears in the A13; Loan contracts which are still running where client are in debt can be presented as status = 'D'",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Filter Loans in Debt**: Select all loan records where the status is 'D' (indicating the client is in debt).\n\n2. **Join with Account Information**: For each loan record, join it with the corresponding account record using the `account_id` field to get the account details.\n\n3. **Join with District Information**: For each account record, join it with the corresponding district record using the `district_id` field to access the district's unemployment rates for the years 1995 (A12) and 1996 (A13).\n\n4. **Calculate Percentage Increment**: For each district, calculate the percentage increment in the unemployment rate from 1995 to 1996 using the formula: \n   \n   ```\n   ((A13 - A12) * 100) / A12\n   ```\n   \n   This gives the percentage change in unemployment rate.\n\n5. **Output the Result**: The final output is the calculated percentage increment for each district where the loan is still running and the client is in debt.",
            "To solve the question, the following operations are performed in the given SQL query:\n\n1. **Filter Loans in Debt**: The query filters the `loan` table (aliased as `T1`) to include only records where the `status` is 'D', indicating the client is in debt.\n\n2. **Join with Account Information**: The filtered loan records are then joined with the `account` table (aliased as `T2`) using the `account_id` field. This ensures that each loan record is linked to its corresponding account details.\n\n3. **Join with District Information**: The account records are further joined with the `district` table (aliased as `T3`) using the `district_id` field. This allows access to the district's unemployment rates for the years 1995 (`A12`) and 1996 (`A13`).\n\n4. **Calculate Percentage Increment**: For each district, the query calculates the percentage increment in the unemployment rate from 1995 to 1996 using the formula:\n   \n   ```\n   ((A13 - A12) * 100) / A12\n   ```\n   \n   Here, `A13` represents the unemployment rate in 1996, and `A12` represents the unemployment rate in 1995. The result is cast to a `REAL` type to ensure accurate decimal representation.\n\n5. **Output the Result**: The final output of the query is the calculated percentage increment for each district where the loan is still running and the client is in debt."
        ]
    },
    "830": {
        "sql": "SELECT a.attribute_name \nFROM hero_attribute ha \nJOIN attribute a ON ha.attribute_id = a.id \nJOIN superhero s ON ha.hero_id = s.id \nWHERE s.superhero_name = 'Black Panther' \nORDER BY ha.attribute_value ASC \nLIMIT 1;",
        "question": "Identify the weakest attribute of the Black Panther.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.attribute_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = 'Black Panther' ORDER BY T2.attribute_value ASC LIMIT 1",
        "explain": "weakest attribute refers to attribute_name WHERE MIN(attribute_value); Black Panther refers to superhero_name = 'Black Panther';",
        "solution": []
    },
    "661": {
        "sql": "SELECT Age FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);",
        "question": "How old is the most influential user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Age FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "explain": "How old describes age; the most influential refers to user where MAX(Reputation);",
        "solution": []
    },
    "1121": {
        "sql": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_1 WHERE (strftime('%Y', 'now') - strftime('%Y', t1.birthday)) <= 30",
        "question": "Calculate the total home team goal scored by players whose age are 30 years old and below.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_1 WHERE datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31",
        "explain": "age are 30 years old and below refers to SUBTRACT(datetime(CURRENT_TIMESTAMP,'localtime'), datetime(birthday) < 31)",
        "solution": [
            "To calculate the total home team goals scored by players who are 30 years old or younger, follow these steps:\n\n1. **Identify the Players**: First, locate all players in the `Player` table (referred to as `t1`) who are 30 years old or younger. This is determined by comparing the current local timestamp with the player's birthday. If the difference between the current date and the player's birthday is less than 31 years, the player meets the age criteria.\n\n2. **Join with Match Data**: Next, join the filtered players with the `match` table (referred to as `t2`) using the `player_api_id` from the `Player` table and the `away_player_1` field from the `match` table. This ensures that only matches involving the identified players are considered.\n\n3. **Sum the Home Team Goals**: Finally, sum the `home_team_goal` values from the `match` table for the joined records. This total represents the combined home team goals scored by players who are 30 years old or younger.",
            "To calculate the total home team goals scored by players who are 30 years old or younger, follow these detailed steps:\n\n1. **Filter Players by Age**: Query the `Player` table (referred to as `t1`) to identify players whose age is 30 years or younger. This is done by calculating the difference between the current local timestamp (`datetime(CURRENT_TIMESTAMP, 'localtime')`) and the player's birthday (`datetime(T1.birthday)`). If this difference is less than 31 years, the player meets the age criteria.\n\n2. **Join with Match Data**: Perform an inner join between the filtered players (from the `Player` table) and the `match` table (referred to as `t2`). The join condition is based on matching the `player_api_id` from the `Player` table with the `away_player_1` field in the `match` table. This ensures that only matches involving the identified players are included in the result set.\n\n3. **Sum Home Team Goals**: Aggregate the `home_team_goal` values from the `match` table for the joined records. The sum of these values represents the total home team goals scored by players who are 30 years old or younger.\n\nThe SQL query for this operation is:\n```sql\nSELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_1 WHERE datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31\n```"
        ]
    },
    "663": {
        "sql": "SELECT Id FROM users WHERE Age = (SELECT MIN(Age) FROM users);",
        "question": "What is the id of the youngest user?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id FROM users WHERE Age = ( SELECT MIN(Age) FROM users )",
        "explain": "the youngest user refers to MIN(Age);",
        "solution": []
    },
    "1380": {
        "sql": "SELECT SUM(spent) AS total_spent_food FROM budget WHERE category = 'Food';",
        "question": "What is the total amount of money spent for food?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(spent) FROM budget WHERE category = 'Food'",
        "explain": "total amount of money spent refers to SUM(spent); spent for food refers to category = 'Food'",
        "solution": []
    },
    "115": {
        "sql": "WITH max_inhabitants_district AS (\n    SELECT district_id\n    FROM district\n    WHERE A3 = 'south Bohemia'\n    ORDER BY A4 DESC\n    LIMIT 1\n),\nclient_counts AS (\n    SELECT \n        COUNT(*) AS total_clients,\n        SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) AS male_clients\n    FROM client\n    WHERE district_id = (SELECT district_id FROM max_inhabitants_district)\n)\nSELECT \n    (male_clients * 100.0 / total_clients) AS male_percentage\nFROM client_counts;",
        "error": "something went wrong, tool did not call.",
        "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
        "explain": "Percentage of the male clients = DIVIDE(COUNT(male clients), COUNT(clients)) * 100; Male refers to gender = 'M', A3 is the region name. A4 contains the information about inhabitants.",
        "solution": []
    },
    "1483": {
        "sql": "SELECT SUM(Consumption) AS TotalConsumption FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311';",
        "question": "How much did customer 6 consume in total between August and November 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'",
        "explain": "Between August And November 2013 refers to Between 201308 And 201311; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "solution": []
    },
    "132": {
        "sql": "SELECT AVG(l.amount) AS average_loan_amount\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN disp d ON a.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE c.gender = 'M';",
        "question": "What is the average loan amount by male borrowers?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT AVG(T4.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'M'",
        "explain": "Male refers to gender = 'M'",
        "solution": []
    },
    "186": {
        "sql": "WITH weekly_clients AS (\n    SELECT c.client_id, c.gender\n    FROM client c\n    JOIN disp d ON c.client_id = d.client_id\n    JOIN account a ON d.account_id = a.account_id\n    WHERE a.frequency = 'POPLATEK TYDNE'\n)\nSELECT \n    (COUNT(CASE WHEN gender = 'M' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_male_weekly_clients\nFROM weekly_clients;",
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "db_id": "financial",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "explain": "Percentage of male clients = [count(male clients who requested weekly statements / count(clients who requested weekly statements)] * 100%; Male means gender = 'M'; 'POPLATEK TYDNE' stands for weekly issuance",
        "solution": [
            "To determine the percentage of male clients who request weekly statements to be issued, follow these steps:\n\n1. **Join the Tables**: Combine the `client` table (T1), `district` table (T3), `account` table (T2), and `disp` table (T4) based on the following relationships:\n   - Link `client` (T1) and `district` (T3) using the `district_id` field.\n   - Link `account` (T2) and `district` (T3) using the `district_id` field.\n   - Link `client` (T1) and `disp` (T4) using the `client_id` field.\n   - Link `account` (T2) and `disp` (T4) using the `account_id` field.\n\n2. **Filter for Weekly Statements**: From the joined data, filter the records where the `frequency` field in the `account` table (T2) is set to 'POPLATEK TYDNE' (indicating weekly statements).\n\n3. **Calculate the Percentage**: \n   - Count the total number of clients (using `client_id` from the `client` table (T1)) who meet the filtered criteria.\n   - Count the number of male clients (where `gender` in the `client` table (T1) is 'M') among these filtered records.\n   - Calculate the percentage by dividing the number of male clients by the total number of clients and multiplying by 100.\n\n4. **Return the Result**: The final result is the calculated percentage of male clients requesting weekly statements.",
            "To determine the percentage of male clients who request weekly statements to be issued, follow these steps:\n\n1. **Join the Tables**: Combine the `client` table (T1), `district` table (T3), `account` table (T2), and `disp` table (T4) based on the following relationships:\n   - Link `client` (T1) and `district` (T3) using the `district_id` field.\n   - Link `account` (T2) and `district` (T3) using the `district_id` field.\n   - Link `client` (T1) and `disp` (T4) using the `client_id` field.\n   - Link `account` (T2) and `disp` (T4) using the `account_id` field.\n\n2. **Filter for Weekly Statements**: From the joined data, filter the records where the `frequency` field in the `account` table (T2) is set to 'POPLATEK TYDNE' (indicating weekly statements).\n\n3. **Calculate the Percentage**: \n   - Count the total number of clients (using `client_id` from the `client` table (T1)) who meet the filtered criteria.\n   - Count the number of male clients (where `gender` in the `client` table (T1) is 'M') among these filtered records.\n   - Calculate the percentage by dividing the number of male clients by the total number of clients and multiplying by 100.\n\n4. **Return the Result**: The final result is the calculated percentage of male clients requesting weekly statements."
        ]
    },
    "915": {
        "sql": "SELECT nationality FROM drivers WHERE dob = (SELECT MIN(dob) FROM drivers);",
        "question": "Which country is the oldest driver from?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1",
        "explain": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
        "solution": []
    },
    "776": {
        "sql": "SELECT s.superhero_name, r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.full_name = 'Charles Chandler';",
        "question": "Provide the hero name and race of Charles Chandler.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.full_name = 'Charles Chandler'",
        "explain": "hero name refers to superhero_name; Charles Chandler is the full name of superhero;",
        "solution": []
    },
    "1246": {
        "sql": "SELECT COUNT(DISTINCT L.ID) \nFROM Laboratory L\nJOIN Examination E ON L.ID = E.ID\nWHERE (L.APTT < 25 OR L.APTT > 35) AND E.Thrombosis = 0;",
        "question": "For the patients with an abnormal activated partial prothrom bin time, how many of them does not have thrombosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T3.Thrombosis = 0 AND T2.APTT > 45",
        "explain": "abnormal activated partial prothrom bin time refers to APTT > 45; does not have thrombosis refers to Thrombosis = 0; Only count ones without repetitive.",
        "solution": []
    },
    "440": {
        "sql": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar';",
        "question": "Which foreign language used by \"A Pedra Fellwar\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'",
        "explain": "\"A Pedra Fellwar\" refers to name = 'A Pedra Fellwar'",
        "solution": [
            "To find out which foreign language is used by \"A Pedra Fellwar\", you need to query the database for the distinct language entries associated with the name \"A Pedra Fellwar\" in the table named \"foreign_data\". The query will return all unique languages linked to this name."
        ]
    },
    "674": {
        "sql": "SELECT DisplayName FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);",
        "question": "Who has the highest reputation? Please give the display name.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "explain": "the highest reputation refers to MAX(Reputation);",
        "solution": []
    },
    "893": {
        "sql": "SELECT d.forename, d.surname, ds.points\nFROM races r\nJOIN driverStandings ds ON r.raceId = ds.raceId\nJOIN drivers d ON ds.driverId = d.driverId\nWHERE r.name = 'Chinese Grand Prix' AND r.year = 2017\nORDER BY ds.points DESC\nLIMIT 3;",
        "question": "Name the top 3 drivers and the points they scored in the 2017 Chinese Grand Prix.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017 ORDER BY T2.points DESC LIMIT 3",
        "explain": "",
        "solution": [
            "To find the top 3 drivers and the points they scored in the 2017 Chinese Grand Prix, follow these steps:\n\n1. **Identify the race**: Locate the race record in the `races` table where the name is 'Chinese Grand Prix' and the year is 2017.\n2. **Join with driver standings**: Link the identified race to the `driverStandings` table using the `raceId` to get the standings of drivers in that race.\n3. **Join with drivers**: Connect the `driverStandings` table to the `drivers` table using the `driverId` to retrieve the names of the drivers.\n4. **Sort by points**: Arrange the results in descending order based on the points scored by each driver.\n5. **Limit results**: Select only the top 3 drivers with the highest points.\n\nThe final output will display the forename, surname, and points of these top 3 drivers."
        ]
    },
    "1374": {
        "sql": "SELECT COUNT(*) \nFROM attendance \nWHERE link_to_member = (SELECT member_id FROM member WHERE phone = '954-555-6240');",
        "question": "How many events did the member with the phone number \"954-555-6240\" attend?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.link_to_event) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member WHERE T1.phone = '954-555-6240'",
        "explain": "",
        "solution": []
    },
    "1014": {
        "sql": "error",
        "question": "Please list the lap records for the circuits in Italy.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "explain": "lap record means the fastest time recorded which refers to time",
        "solution": [
            "To list the lap records for the circuits in Italy, the following steps are performed:\n\n1. **Calculate Fastest Lap Times in Seconds**:\n   - Extract the fastest lap times from the `results` table where the `FastestLapTime` is not null.\n   - Convert the `FastestLapTime` (formatted as `MM:SS.sss`) into seconds for easier comparison. This involves:\n     - Extracting the minutes part (before the colon), converting it to seconds by multiplying by 60.\n     - Extracting the seconds part (between the colon and the dot), converting it to seconds.\n     - Extracting the milliseconds part (after the dot), converting it to seconds by dividing by 1000.\n     - Summing these three values to get the total time in seconds.\n\n2. **Identify the Minimum Lap Time for Italian Circuits**:\n   - Join the `fastest_lap_times` with the `races` and `circuits` tables to filter only those races held in Italy (`T3.country = 'Italy'`).\n   - Find the minimum lap time in seconds from this filtered dataset.\n\n3. **Retrieve the Lap Record**:\n   - Join the `results` table with the `races` and `circuits` tables to ensure the data is filtered to Italian circuits.\n   - Compare the converted lap time (in seconds) of each record with the minimum lap time identified in the previous step.\n   - Select the `FastestLapTime` that matches the minimum lap time, which represents the lap record for Italian circuits.\n   - Limit the result to 1 record to ensure only the fastest lap is returned.\n\nThis process ensures that the fastest lap time for circuits in Italy is accurately identified and returned.",
            "To list the lap records for the circuits in Italy, the following detailed steps are performed:\n\n1. **Create a Temporary Table for Fastest Lap Times**:\n   - Select the `raceId` and `FastestLapTime` from the `results` table where `FastestLapTime` is not null.\n   - Convert the `FastestLapTime` (formatted as `MM:SS.sss`) into seconds for easier comparison. This involves:\n     - Extracting the minutes part (before the colon) and converting it to seconds by multiplying by 60.\n     - Extracting the seconds part (between the colon and the dot) and converting it to seconds.\n     - Extracting the milliseconds part (after the dot) and converting it to seconds by dividing by 1000.\n     - Summing these three values to get the total time in seconds.\n   - Store this data in a temporary table named `fastest_lap_times`.\n\n2. **Identify the Minimum Lap Time for Italian Circuits**:\n   - Join the `fastest_lap_times` table with the `races` and `circuits` tables to filter only those races held in Italy (`T3.country = 'Italy'`).\n   - Calculate the minimum lap time in seconds from this filtered dataset and store it as `min_time_in_seconds`.\n\n3. **Retrieve the Lap Record**:\n   - Join the `results` table with the `races` and `circuits` tables to ensure the data is filtered to Italian circuits.\n   - Convert the `FastestLapTime` of each record into seconds using the same method as in step 1.\n   - Compare the converted lap time (in seconds) of each record with the `min_time_in_seconds` identified in the previous step.\n   - Select the `FastestLapTime` that matches the `min_time_in_seconds`, which represents the lap record for Italian circuits.\n   - Limit the result to 1 record to ensure only the fastest lap is returned.\n\nThis process ensures that the fastest lap time for circuits in Italy is accurately identified and returned."
        ]
    },
    "1157": {
        "sql": "SELECT DISTINCT P.ID, P.SEX, P.Diagnosis\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE E.Thrombosis = 2;",
        "question": "For patients with severe degree of thrombosis, list their ID, sex and disease the patient is diagnosed with.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 2",
        "explain": "severe degree of thrombosis refers to thrombosis = 2; disease refers to diagnosis;",
        "solution": [
            "To solve the question, we need to list the ID, sex, and diagnosis of patients who have a severe degree of thrombosis. The solution involves the following steps:\n\n1. **Identify the Tables**: The data is stored in two tables:\n   - `Patient` (referred to as `T1` in the SQL) contains patient details like ID, sex, and diagnosis.\n   - `Examination` (referred to as `T2` in the SQL) contains examination details, including the thrombosis severity level.\n\n2. **Join the Tables**: Combine the `Patient` and `Examination` tables using the patient ID as the common key. This ensures we can access both patient details and their examination results in one dataset.\n\n3. **Filter for Severe Thrombosis**: Only include patients where the thrombosis severity level is 2 (indicating severe thrombosis).\n\n4. **Select Required Fields**: From the joined and filtered dataset, extract the patient ID, sex, and diagnosis.\n\n5. **Ensure Distinct Records**: Remove any duplicate entries to ensure each patient is listed only once.\n\nThe final result will be a list of unique patient IDs, their sex, and their diagnoses, all of whom have been diagnosed with severe thrombosis."
        ]
    },
    "93": {
        "sql": "SELECT COUNT(T1.client_id) AS male_customers_count\nFROM client T1\nJOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'M'\n  AND T2.A3 = 'north Bohemia'\n  AND T2.A11 > 8000;",
        "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
        "explain": "Male means that gender = 'M'; A3 refers to region; A11 pertains to average salary.",
        "solution": [
            "To solve the question, \"How many male customers who are living in North Bohemia have an average salary greater than 8000?\", the following steps are performed:\n\n1. **Join the Tables**: The `client` table (aliased as `T1`) is joined with the `district` table (aliased as `T2`) using the `district_id` column. This links each client to their respective district.\n\n2. **Filter by Gender**: From the joined tables, only the records where the `gender` column in the `client` table (`T1.gender`) is 'M' (male) are selected.\n\n3. **Filter by Region**: Further filter the records to include only those where the `A3` column in the `district` table (`T2.A3`) is 'north Bohemia', indicating the client lives in North Bohemia.\n\n4. **Filter by Salary**: Additionally, filter the records to include only those where the `A11` column in the `district` table (`T2.A11`) is greater than 8000, representing an average salary greater than 8000.\n\n5. **Count the Results**: Finally, count the number of `client_id` entries from the `client` table (`T1.client_id`) that meet all the above criteria. This count represents the number of male customers living in North Bohemia with an average salary greater than 8000."
        ]
    },
    "732": {
        "sql": "SELECT p.publisher_name\nFROM publisher p\nJOIN superhero s ON p.id = s.publisher_id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Speed'\nORDER BY ha.attribute_value ASC\nLIMIT 1;",
        "question": "Which publisher published the slowest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed' ORDER BY T3.attribute_value LIMIT 1",
        "explain": "the slowest superhero refers to attribute_name = 'Speed' where MIN(attribute_value); publisher refers to publisher_name",
        "solution": []
    },
    "1151": {
        "sql": "SELECT (COUNT(CASE WHEN Admission = '+' THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInpatients\nFROM Patient\nWHERE strftime('%Y', Birthday) BETWEEN '1930' AND '1940';",
        "question": "For patient born between Year 1930 to 1940, how many percent of them were inpatient?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940'",
        "explain": "patient born between Year 1930 to 1940 refers to year(Birthday) BETWEEN '1930-01-01' AND '1940-12-31'; inpatient refers to Admission = '+'",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Filter Patients by Birth Year**: Select all patients whose birth year falls between 1930 and 1940. This is done by extracting the year from the `Birthday` column and checking if it lies within the range '1930' to '1940'.\n\n2. **Count Total Patients**: Calculate the total number of patients who meet the birth year criteria.\n\n3. **Count Inpatients**: Among the filtered patients, count how many have an `Admission` value of '+', indicating they were inpatients.\n\n4. **Calculate Percentage**: Divide the number of inpatients by the total number of patients and multiply by 100 to get the percentage of inpatients.\n\nThe final result is the percentage of inpatients among patients born between 1930 and 1940."
        ]
    },
    "596": {
        "sql": "SELECT T1.Name AS BadgeName, COUNT(T2.UserId) AS CommentCount\nFROM badges T1\nINNER JOIN comments T2 ON T1.UserId = T2.UserId\nGROUP BY T2.UserId\nORDER BY CommentCount DESC\nLIMIT 1;",
        "question": "Which users have posted the most comments. List out the user's badge?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT Name FROM badges AS T1 INNER JOIN comments AS T2 ON T1.UserId = t2.UserId GROUP BY T2.UserId ORDER BY COUNT(T2.UserId) DESC LIMIT 1",
        "explain": "user with the most comments refers to UserId where Max(Count(Id)",
        "solution": [
            "To determine which users have posted the most comments and list out their badges, follow these steps:\n\n1. **Join the Tables**: Combine the `badges` table (referred to as `T1`) and the `comments` table (referred to as `T2`) using the `UserId` field as the common key. This ensures that each comment is linked to the user who posted it.\n\n2. **Group by User**: Group the joined data by the `UserId` from the `comments` table (`T2.UserId`). This groups all comments made by the same user together.\n\n3. **Count Comments**: For each user, count the number of comments they have posted. This is done using the `COUNT` function on `T2.UserId`.\n\n4. **Order by Comment Count**: Sort the grouped results in descending order based on the count of comments. This places the user with the highest number of comments at the top of the list.\n\n5. **Limit Results**: Retrieve only the top result (the user with the most comments) using the `LIMIT 1` clause.\n\n6. **Select the Name**: Finally, select the `Name` field from the `badges` table (`T1.Name`) to display the badge name of the user who posted the most comments.\n\nThe SQL query accomplishes this by joining the tables, grouping, counting, ordering, and limiting the results to the top user.",
            "To determine which users have posted the most comments and list out their badges, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `badges` table (aliased as `T1`) and the `comments` table (aliased as `T2`) using the `UserId` field as the common key. This ensures that each comment is linked to the user who posted it, and only records with matching `UserId` in both tables are included.\n\n2. **Group by User**: Group the joined data by the `UserId` from the `comments` table (`T2.UserId`). This groups all comments made by the same user together, allowing us to aggregate data per user.\n\n3. **Count Comments**: For each user group, count the number of comments they have posted using the `COUNT` function on `T2.UserId`. This gives the total number of comments per user.\n\n4. **Order by Comment Count**: Sort the grouped results in descending order based on the count of comments (`COUNT(T2.UserId)`). This ensures the user with the highest number of comments appears first in the result set.\n\n5. **Limit Results**: Retrieve only the top result (the user with the most comments) using the `LIMIT 1` clause. This restricts the output to the single user who has posted the most comments.\n\n6. **Select the Badge Name**: Finally, select the `Name` field from the `badges` table (`T1.Name`) to display the badge name of the user who posted the most comments. This is the final output of the query.\n\nThe SQL query accomplishes this by joining the tables, grouping, counting, ordering, and limiting the results to the top user, ensuring the solution is both accurate and efficient."
        ]
    },
    "396": {
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE frameVersion = '1993' \nAND (hasNonFoil = 1 OR hasFoil = 1) \nAND hasContentWarning = 1;",
        "question": "How many cards with a 1993 frame version and available on paper have a sensitive content warning?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE frameVersion = 1993 AND availability = 'paper' AND hasContentWarning = 1",
        "explain": "sensitive content warning refer to hasContentWarning = 1; available on paper refer to availability = 'paper' 1993 refer to frameVersion",
        "solution": []
    },
    "1510": {
        "sql": "SELECT AVG(T1.Price) AS AveragePrice FROM transactions_1k T1 JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE';",
        "question": "What is the average total price of the transactions taken place in gas stations in the Czech Republic?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE'",
        "explain": "Gas station in the Czech Republic implies that Country = 'CZE'",
        "solution": [
            "To find the average total price of transactions that took place in gas stations located in the Czech Republic, follow these steps:\n\n1. **Join the Tables**: Combine the `transactions_1k` table (aliased as `T1`) with the `gasstations` table (aliased as `T2`) using the `GasStationID` field. This links each transaction to its corresponding gas station.\n\n2. **Filter by Country**: From the joined tables, filter the records to include only those where the `Country` field in the `gasstations` table (`T2.Country`) is equal to 'CZE' (Czech Republic).\n\n3. **Calculate the Average**: Compute the average of the `Price` field from the `transactions_1k` table (`T1.Price`) for the filtered records. This gives the average total price of transactions in Czech Republic gas stations."
        ]
    },
    "1243": {
        "sql": "SELECT (CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)) AS percentage_female_abnormal_pt\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) > 55;",
        "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
        "explain": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; ",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Filter Patients Older Than 55 Years**:\n   - The `Patient` table (aliased as `T1`) is filtered to include only those patients whose age, calculated as the difference between the current year and their birth year, is greater than 55.\n\n2. **Join with Laboratory Data**:\n   - The filtered `Patient` table is joined with the `Laboratory` table (aliased as `T2`) using the patient ID (`ID`) as the join key. This ensures that each patient's laboratory results are linked to their demographic data.\n\n3. **Calculate the Percentage of Females with Abnormal PT**:\n   - For each patient in the joined dataset, check if they are female (`SEX = 'F'`) and have an abnormal prothrombin time (`PT >= 14`).\n   - Count the number of such patients and divide it by the total number of patients in the filtered dataset (those older than 55).\n   - Multiply the result by 100 to convert it into a percentage.\n\nThis sequence of operations directly translates to the given SQL query and provides the percentage of female patients older than 55 with abnormal prothrombin time.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Filter Patients Older Than 55 Years**:\n   - The `Patient` table (aliased as `T1`) is filtered to include only those patients whose age, calculated as the difference between the current year and their birth year (`STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)`), is greater than 55.\n\n2. **Join with Laboratory Data**:\n   - The filtered `Patient` table is joined with the `Laboratory` table (aliased as `T2`) using the patient ID (`ID`) as the join key. This ensures that each patient's laboratory results are linked to their demographic data.\n\n3. **Calculate the Percentage of Females with Abnormal PT**:\n   - For each patient in the joined dataset, check if they are female (`T1.SEX = 'F'`) and have an abnormal prothrombin time (`T2.PT >= 14`).\n   - Sum the cases where both conditions are met (`SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END)`).\n   - Divide this sum by the total number of patients in the filtered dataset (`COUNT(*)`).\n   - Multiply the result by 100 to convert it into a percentage (`CAST(... AS REAL) * 100 / COUNT(*)`).\n\nThis sequence of operations directly translates to the given SQL query and provides the percentage of female patients older than 55 with abnormal prothrombin time."
        ]
    },
    "912": {
        "sql": "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit';",
        "question": "What's the reference name of Marina Bay Street Circuit?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit'",
        "explain": "reference name refers to circuitRef; Marina Bay Street Circuit refers to circuits.name = 'Marina Bay Street Circuit'",
        "solution": []
    },
    "31": {
        "sql": "SELECT \n    `Free Meal Count (K-12)` / `Enrollment (K-12)` AS `Eligible Free Rate`\nFROM \n    frpm\nORDER BY \n    `Enrollment (K-12)` DESC\nLIMIT 2 OFFSET 9;",
        "question": "What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)` FROM frpm ORDER BY `Enrollment (K-12)` DESC LIMIT 9, 2",
        "explain": "K-12 refers to students in grades 1 through 12; Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Order the Data**: The data in the `frpm` table is sorted in descending order based on the `Enrollment (K-12)` column. This arranges the schools from the highest to the lowest enrollment.\n\n2. **Limit the Results**: After sorting, the query skips the first 9 rows (which represent the top 9 schools with the highest enrollment) and then selects the next 2 rows. These rows correspond to the 10th and 11th schools with the highest enrollment.\n\n3. **Calculate the Free Meal Rate**: For each of these two schools, the query calculates the eligible free meal rate by dividing the `Free Meal Count (K-12)` by the `Enrollment (K-12)`. The result is cast to a real number to ensure precision in the division.\n\nThe final output is the eligible free meal rate for the 10th and 11th schools with the highest enrollment for students in grades 1 through 12.",
            "To solve the question, the following operations are performed on the database:\n\n1. **Select and Calculate the Free Meal Rate**: The query selects the `Free Meal Count (K-12)` and `Enrollment (K-12)` columns from the `frpm` table. It then calculates the eligible free meal rate by dividing the `Free Meal Count (K-12)` by the `Enrollment (K-12)`. The result is cast to a real number to ensure precision in the division.\n\n2. **Order the Data**: The results are sorted in descending order based on the `Enrollment (K-12)` column. This arranges the schools from the highest to the lowest enrollment.\n\n3. **Limit the Results**: After sorting, the query skips the first 9 rows (which represent the top 9 schools with the highest enrollment) and then selects the next 2 rows. These rows correspond to the 10th and 11th schools with the highest enrollment.\n\nThe final output is the eligible free meal rate for the 10th and 11th schools with the highest enrollment for students in grades 1 through 12."
        ]
    },
    "1420": {
        "sql": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.position = 'Vice President';",
        "question": "State the name of major that Vice President has joined.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Vice President'",
        "explain": "name of major refers to major_name; 'Vice President' is position of Student Club",
        "solution": []
    },
    "1321": {
        "sql": "SELECT COUNT(*) AS event_count\nFROM attendance a\nJOIN member m ON a.link_to_member = m.member_id\nJOIN event e ON a.link_to_event = e.event_id\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison'\nAND strftime('%Y', e.event_date) = '2019';",
        "question": "How many events of the Student_Club did Sacha Harrison attend in 2019?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Sacha' AND T3.last_name = 'Harrison' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "explain": "events attended in 2019 refers to YEAR(event_date) = 2019",
        "solution": []
    },
    "1142": {
        "sql": "SELECT COUNT(*) AS total_games\nFROM \"Match\"\nWHERE league_id = (SELECT id FROM \"League\" WHERE name = 'Italy Serie A')\nAND season = '2015/2016';",
        "question": "In the 2015\u20132016 season, how many games were played in the Italian Serie A league?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Italy Serie A' AND t2.season = '2015/2016'",
        "explain": "In the 2015\u20132016 season refers to season = '2015/2016'",
        "solution": []
    },
    "876": {
        "sql": "SELECT COUNT(*) AS drivers_not_finished\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nJOIN status s ON r.statusId = s.statusId\nWHERE rc.date = '2015-11-29' AND s.status != 'Finished';",
        "question": "For the race happened in 2015/11/29, how many drivers did not finish the game?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NULL",
        "explain": "game and race are synonyms; drivers who didn't finish the race should have record in time;",
        "solution": []
    },
    "1083": {
        "sql": "SELECT t1.player_name\nFROM Player t1\nJOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t2.overall_rating DESC\nLIMIT 1;",
        "question": "Which player has the strongest overall strength?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
        "explain": "overall strength refers to overall_rating; strongest overall strength refers to MAX(overall_rating);",
        "solution": [
            "To find the player with the strongest overall strength, follow these steps:\n\n1. **Join the Tables**: Combine the `Player` table (aliased as `t1`) with the `Player_Attributes` table (aliased as `t2`) using the `player_api_id` field as the common key. This ensures that each player's attributes are linked to their respective player record.\n\n2. **Sort by Overall Rating**: Arrange the combined records in descending order based on the `overall_rating` column from the `Player_Attributes` table. This places the player with the highest overall rating at the top of the list.\n\n3. **Select the Top Player**: Retrieve only the top record from the sorted list, which corresponds to the player with the strongest overall strength.\n\n4. **Output the Result**: Display the `player_name` from the `Player` table for the selected player."
        ]
    },
    "228": {
        "sql": "SELECT ROUND(CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) * 100 / COUNT(atom_id), 4) AS hydrogen_percentage\nFROM atom\nWHERE molecule_id = 'TR206';",
        "question": "How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id),4) FROM atom AS T WHERE T.molecule_id = 'TR206'",
        "explain": "hydrogen refers to element = 'h'; TR206 is the molecule id; percentage = DIVIDE(SUM(element = 'h'), COUNT(atom_id)) as percent where molecule_id = 'TR206'",
        "solution": [
            "To determine how much of the hydrogen in molecule TR206 is accounted for, follow these steps:\n\n1. **Filter the Data**: Select all atoms from the `atom` table where the `molecule_id` is 'TR206'.\n2. **Count Hydrogen Atoms**: From the filtered data, count the number of atoms where the `element` is 'h' (hydrogen).\n3. **Count Total Atoms**: Also, count the total number of atoms in the filtered data.\n4. **Calculate Percentage**: Divide the count of hydrogen atoms by the total count of atoms, multiply by 100 to convert it to a percentage, and round the result to four decimal places.\n\nThe final result will be the percentage of hydrogen in molecule TR206, rounded to four decimal places.",
            "To determine how much of the hydrogen in molecule TR206 is accounted for, follow these steps:\n\n1. **Filter the Data**: Query the `atom` table to retrieve all atoms where the `molecule_id` is 'TR206'.\n2. **Count Hydrogen Atoms**: From the filtered data, count the number of atoms where the `element` column is 'h' (hydrogen). This is done using a conditional count (`COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END)`).\n3. **Count Total Atoms**: Count the total number of atoms in the filtered data (`COUNT(T.atom_id)`).\n4. **Calculate Percentage**: Divide the count of hydrogen atoms by the total count of atoms, multiply the result by 100 to convert it to a percentage, and round the final value to four decimal places (`ROUND(CAST(...) * 100 / COUNT(T.atom_id), 4)`).\n\nThe final result will be the percentage of hydrogen in molecule TR206, rounded to four decimal places."
        ]
    },
    "162": {
        "sql": "SELECT d.A3 AS region\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.client_id = 3541;",
        "question": "What is the region of the client with the id 3541 from?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
        "explain": "A3 refers to region",
        "solution": []
    },
    "640": {
        "sql": "SELECT \n    (SUM(CASE WHEN u.DisplayName = 'Mornington' THEN p.ViewCount ELSE 0 END) - \n     SUM(CASE WHEN u.DisplayName = 'Amos' THEN p.ViewCount ELSE 0 END)) AS diff\nFROM \n    users u\nJOIN \n    postHistory ph ON u.Id = ph.UserId\nJOIN \n    posts p ON ph.PostId = p.Id\nWHERE \n    u.DisplayName IN ('Mornington', 'Amos');",
        "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "explain": "calculation = SUBTRACT(SUM(ViewCount where DisplayName = 'Mornington'), SUM(ViewCount where DisplayName = 'Amos'));",
        "solution": [
            "To calculate the difference in view count between posts posted by Mornington and posts posted by Amos, follow these steps:\n\n1. **Join the Tables**: Combine the `users` table (T1), the `postHistory` table (T2), and the `posts` table (T3) using the following relationships:\n   - Link `users` (T1) to `postHistory` (T2) by matching the `Id` column in `users` with the `UserId` column in `postHistory`.\n   - Link `postHistory` (T2) to `posts` (T3) by matching the `PostId` column in `postHistory` with the `Id` column in `posts`.\n\n2. **Filter and Sum View Counts**: For each post, check the `DisplayName` in the `users` table (T1):\n   - If the `DisplayName` is 'Mornington', include the `ViewCount` from the `posts` table (T3) in the sum for Mornington.\n   - If the `DisplayName` is 'Amos', include the `ViewCount` from the `posts` table (T3) in the sum for Amos.\n   - For all other names, exclude the `ViewCount` from both sums.\n\n3. **Calculate the Difference**: Subtract the total view count for posts by Amos from the total view count for posts by Mornington to get the difference.\n\n4. **Output the Result**: The result is labeled as `diff` in the output."
        ]
    },
    "1176": {
        "sql": "SELECT `ANA` FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02';",
        "question": "What was the anti-nucleus antibody concentration level for the patient id 3605340 on 1996/12/2?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT ANA FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02'",
        "explain": "anti-nucleus antibody refers to ANA; 1996/12/2 refers to `Examination Date` = '1996-12-02'",
        "solution": []
    },
    "1191": {
        "sql": "SELECT \n    (SUM(CASE WHEN p.Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient p\nWHERE \n    p.SEX = 'M' AND \n    strftime('%Y', p.`First Date`) = '1981';",
        "question": "What percentage of male patients who first presented to the hospital in 1981 were diagnosed with BEHCET?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE STRFTIME('%Y', `First Date`) = '1981' AND SEX = 'M'",
        "explain": "male refers to SEX = 'M'; first presented to the hospital in 1981 refers to YEAR(`FIRST DATE`) = '1981'; BEHCET refers to diagnosis; calculation = DIVIDE(SUM(DIAGNOSIS = 'BEHCET') where YEAR(`FIRST DATE`) = '1981', MULTIPLY(COUNT(YEAR(`FIRST DATE`) = '1981')), 100)",
        "solution": []
    },
    "1364": {
        "sql": "SELECT z.city, z.county, z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Amy' AND m.last_name = 'Firth';",
        "question": "Where is Amy Firth's hometown?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.city, T2.county, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Amy' AND T1.last_name = 'Firth'",
        "explain": "hometown refers to city, county, state",
        "solution": []
    },
    "882": {
        "sql": "SELECT MIN(year) AS first_year FROM races WHERE name LIKE '%Singapore Grand Prix%';",
        "question": "Which year was the first Singapore Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT year FROM races WHERE name = 'Singapore Grand Prix' ORDER BY year ASC LIMIT 1",
        "explain": "the first race refers to race happened in min(year);",
        "solution": []
    },
    "1139": {
        "sql": "SELECT home_team_goal, away_team_goal \nFROM Match \nWHERE date LIKE '2008-09-24%' \nAND league_id = (SELECT id FROM League WHERE name = 'Belgium Jupiler League');",
        "question": "What was the final score for the match on September 24, 2008, in the Belgian Jupiler League between the home team and the away team?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.home_team_goal, t2.away_team_goal FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND t2.`date` LIKE '2008-09-24%'",
        "explain": "September 24, 2008 refers to date like '2008-09-24%'; in the Belgian Jupiler League refers to League.name = 'Belgium Jupiler League'; final score for home team refers to home_team_goal; final score for away team refers to away_team_goal",
        "solution": []
    },
    "868": {
        "sql": "SELECT c.lat, c.lng\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE r.name = 'Malaysian Grand Prix';",
        "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix'",
        "explain": "location coordinates refers to (lat, lng); Malaysian Grand Prix refers to races.name = 'Malaysian Grand Prix'",
        "solution": []
    },
    "827": {
        "sql": "SELECT AVG(s.height_cm) AS average_height\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN race r ON s.race_id = r.id\nWHERE p.publisher_name = 'Dark Horse Comics'\nAND r.race != 'Human';",
        "question": "What is the average height of a non-human superhero in Dark Horse Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.race != 'Human'",
        "explain": "average = AVG(height_cm); non-human superhero refers to race <> 'Human'; Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "solution": []
    },
    "1500": {
        "sql": "SELECT DISTINCT p.Description\nFROM products p\nJOIN transactions_1k t ON p.ProductID = t.ProductID\nJOIN yearmonth ym ON t.CustomerID = ym.CustomerID AND ym.Date = '201309';",
        "question": "Please list the product description of the products consumed in September, 2013.",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "explain": "September 2013 refers to 201309; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "solution": []
    },
    "322": {
        "sql": "SELECT element FROM atom WHERE atom_id = 'TR000_1';",
        "question": "What is the element of toxicology for the atom with the ID of TR000_1?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.element FROM atom AS T WHERE T.atom_id = 'TR000_1'",
        "explain": "atom with ID refers to atom_id; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "solution": []
    },
    "1398": {
        "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.category = 'Advertisement'\nORDER BY b.spent DESC\nLIMIT 1;",
        "question": "Name the event with the highest amount spent on advertisement.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' ORDER BY T1.spent DESC LIMIT 1",
        "explain": "Name of event refers to event_name; highest amount spent on advertisement refers to MAX(spent) where category = 'Advertisement'",
        "solution": []
    },
    "154": {
        "sql": "SELECT COUNT(*) \nFROM client \nWHERE gender = 'M' AND district_id = (SELECT district_id FROM district WHERE A2 = 'Hl.m. Praha');",
        "question": "How many male clients in 'Hl.m. Praha' district?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'",
        "explain": "District data appears in the A2; Male means that gender = 'M'",
        "solution": []
    },
    "1174": {
        "sql": "SELECT AVG(1999 - STRFTIME('%Y', P.Birthday)) AS AverageAge\nFROM Laboratory L\nJOIN Patient P ON L.ID = P.ID\nWHERE L.Date BETWEEN '1991-10-01' AND '1991-10-31'",
        "question": "What is the average age of patients as of year 1999 examined in the laboratory for the October of the year 1991?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT AVG('1999'  - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "explain": "average age of patients as of year 1999 refers to AVG(SUBTRACT('1999', year(Birthday))); October of 1991 refers to Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Filter the Laboratory Records**: Select all records from the `Laboratory` table where the `Date` falls within October 1991 (i.e., between '1991-10-01' and '1991-10-30').\n\n2. **Join with Patient Records**: For each filtered laboratory record, join it with the corresponding record in the `Patient` table using the `ID` field to access the patient's birth date.\n\n3. **Calculate Age as of 1999**: For each patient, compute their age as of the year 1999 by subtracting their birth year (extracted from the `Birthday` field) from 1999.\n\n4. **Compute the Average Age**: Calculate the average of all computed ages to determine the average age of the patients examined in the laboratory during October 1991 as of the year 1999.",
            "To solve the question, the following operations are performed:\n\n1. **Filter the Laboratory Records**: Select all records from the `Laboratory` table where the `Date` falls within October 1991 (i.e., between '1991-10-01' and '1991-10-31').\n\n2. **Join with Patient Records**: For each filtered laboratory record, join it with the corresponding record in the `Patient` table using the `ID` field to access the patient's birth date (`Birthday`).\n\n3. **Calculate Age as of 1999**: For each patient, compute their age as of the year 1999 by subtracting their birth year (extracted from the `Birthday` field using `STRFTIME('%Y', T2.Birthday)`) from 1999.\n\n4. **Compute the Average Age**: Calculate the average of all computed ages using the `AVG` function to determine the average age of the patients examined in the laboratory during October 1991 as of the year 1999."
        ]
    },
    "510": {
        "sql": "SELECT artist FROM cards WHERE otherFaceIds IS NULL ORDER BY convertedManaCost DESC LIMIT 1;",
        "question": "Among the cards that doesn't have multiple faces on the same card, who is the illustrator of the card art that has the highest cost of converted mana?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1",
        "explain": "doesn't have multiple faces refers to side IS NULL; illustrator refers to artist",
        "solution": []
    },
    "204": {
        "sql": "SELECT COUNT(*) FROM molecule WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND label = '+';",
        "question": "Of the first 100 molecules in number order, how many are carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'",
        "explain": "first 100 molecules in number order refers to molecule_id between 'TR000' and 'TR099'; label = '+' means molecules are carcinogenic",
        "solution": []
    },
    "666": {
        "sql": "SELECT p.Id \nFROM posts p \nJOIN votes v ON p.Id = v.PostId \nWHERE v.UserId = 1465 \nORDER BY p.Score DESC \nLIMIT 1;",
        "question": "Among the posts that were voted by user 1465, what is the id of the most valuable post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Id FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 1465 ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "explain": "user 1465 refers to UserId = 1465; the most valuable post refers to MAX(FavoriteCount);",
        "solution": []
    },
    "1336": {
        "sql": "SELECT DISTINCT m.department\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.last_name IN ('Pierce', 'Guidi');",
        "question": "What department offers the major that Pierce and Guidi took?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.last_name = 'Pierce' OR T1.last_name = 'Guidi'",
        "explain": "",
        "solution": []
    },
    "229": {
        "sql": "SELECT b.bond_type FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR000';",
        "question": "What is the type of bond that molecule TR000 has when involved in any bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T.bond_type FROM bond AS T WHERE T.molecule_id = 'TR000'",
        "explain": "type of bond refers to bond_type; TR000 is the molecule id",
        "solution": []
    },
    "444": {
        "sql": "SELECT DISTINCT T2.name, T1.type FROM cards T1 INNER JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T1.watermark = 'boros';",
        "question": "Name the foreign name of the card that has boros watermark? List out the type of this card.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'boros'",
        "explain": "",
        "solution": [
            "To solve the question, the database performs the following operations:\n\n1. **Selecting Data**: The query retrieves distinct values of the `name` and `type` columns from the `cards` table (aliased as `T1`).\n\n2. **Joining Tables**: It joins the `cards` table (`T1`) with the `foreign_data` table (aliased as `T2`) using the `uuid` column as the common key. This ensures that only cards with corresponding entries in the `foreign_data` table are considered.\n\n3. **Filtering Data**: The query filters the results to include only those cards where the `watermark` column in the `cards` table (`T1`) has the value 'boros'.\n\n4. **Output**: The final output is a list of distinct card names and their types that meet the specified criteria (i.e., cards with a 'boros' watermark and corresponding foreign data).",
            "To solve the question, the database performs the following operations:\n\n1. **Selecting Data**: The query retrieves distinct values of the `name` and `type` columns from the `cards` table (aliased as `T1`). This ensures that each card's name and type are listed only once in the results.\n\n2. **Joining Tables**: It performs an inner join between the `cards` table (`T1`) and the `foreign_data` table (aliased as `T2`) using the `uuid` column as the common key. This join ensures that only cards with corresponding entries in the `foreign_data` table are included in the results.\n\n3. **Filtering Data**: The query applies a filter to include only those cards where the `watermark` column in the `cards` table (`T1`) has the exact value 'boros'. This narrows down the results to cards specifically marked with the 'boros' watermark.\n\n4. **Output**: The final output is a distinct list of card names and their types that meet all the specified criteria (i.e., cards with a 'boros' watermark and corresponding foreign data)."
        ]
    },
    "479": {
        "sql": "SELECT COUNT(*) \nFROM cards \nJOIN sets ON cards.setCode = sets.code \nWHERE sets.name = 'Coldsnap' \nAND cards.convertedManaCost > 5 \nAND (cards.power = '*' OR cards.power IS NULL);",
        "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
        "explain": "card set Coldsnap refers to name = 'Coldsnap'; converted mana cost higher than 5 refers to convertedManaCost > 5; unknown power refers to power = '*' or T1.power is null",
        "solution": []
    },
    "931": {
        "sql": "SELECT MAX(r.fastestLapSpeed) AS fastest_lap_speed\nFROM results r\nJOIN races rc ON r.raceId = rc.raceId\nWHERE rc.year = 2009 AND rc.name = 'Spanish Grand Prix';",
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "explain": "the fastest lap speed among all refers to max(fastestLapSpeed); Spanish Grand Prix refers to races.name = 'Spanish Grand Prix';",
        "solution": []
    },
    "1449": {
        "sql": "SELECT m.first_name, m.last_name, ma.major_name\nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE e.cost > 100;",
        "question": "What is the name and major of members who had to spend more than a hundred dollars on an expense?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.first_name, T1.last_name, T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE T3.cost > 100",
        "explain": "full name refers to first_name, last_name; major of members refers to major_name; spend more than a hundred dollars on an expense refers to cost > 100",
        "solution": []
    },
    "1480": {
        "sql": "SELECT SUBSTR(T2.Date, 5, 2) AS PeakMonth\nFROM customers T1\nJOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME'\nGROUP BY PeakMonth\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1;",
        "question": "What was the gas consumption peak month for SME customers in 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUBSTR(T2.Date, 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME' GROUP BY SUBSTR(T2.Date, 5, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "explain": "Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "solution": [
            "To find the gas consumption peak month for SME customers in 2013, follow these steps:\n\n1. **Join Tables**: Combine the `customers` table (aliased as `T1`) with the `yearmonth` table (aliased as `T2`) using the `CustomerID` field to link them.\n\n2. **Filter by Year and Segment**:\n   - Extract the year from the `Date` field in `T2` (using `SUBSTR(T2.Date, 1, 4)`) and filter for records where the year is '2013'.\n   - Filter the `customers` table to include only SME customers by checking `T1.Segment = 'SME'`.\n\n3. **Group by Month**: Extract the month from the `Date` field in `T2` (using `SUBSTR(T2.Date, 5, 2)`) and group the records by this month value.\n\n4. **Calculate Total Consumption**: For each month, calculate the sum of the `Consumption` values from `T2`.\n\n5. **Order and Limit**:\n   - Order the results by the total consumption in descending order to find the month with the highest consumption.\n   - Limit the result to the top record to identify the peak month.\n\nThe final output will be the month (as a two-digit string) with the highest gas consumption for SME customers in 2013."
        ]
    },
    "762": {
        "sql": "SELECT T2.power_name\nFROM hero_power T1\nJOIN superpower T2 ON T1.power_id = T2.id\nGROUP BY T2.power_name\nORDER BY COUNT(DISTINCT T1.hero_id) DESC\nLIMIT 1;",
        "question": "Which power do superheroes have the most of?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T1.hero_id) DESC LIMIT 1",
        "explain": "power that superheroes have the most refers to MAX(COUNT(power_name))",
        "solution": [
            "To determine which power superheroes have the most of, follow these steps:\n\n1. **Join the Tables**: Combine the `hero_power` table (referred to as `T1`) with the `superpower` table (referred to as `T2`) using the `power_id` from `T1` and the `id` from `T2`.\n\n2. **Group by Power Name**: Group the combined data by the `power_name` column from the `superpower` table (`T2`).\n\n3. **Count Heroes per Power**: For each power name, count the number of `hero_id` entries from the `hero_power` table (`T1`). This gives the number of superheroes associated with each power.\n\n4. **Order by Count in Descending Order**: Sort the results by the count of superheroes in descending order to prioritize the most common powers.\n\n5. **Limit to Top Result**: Retrieve only the top result (the power with the highest count of superheroes).\n\nThe final output will be the name of the power that the most superheroes possess.",
            "To determine which power superheroes have the most of, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `hero_power` table (aliased as `T1`) and the `superpower` table (aliased as `T2`). The join condition is `T1.power_id = T2.id`, which links each power entry in `hero_power` to its corresponding entry in `superpower`.\n\n2. **Group by Power Name**: After joining, group the resulting dataset by the `power_name` column from the `superpower` table (`T2`). This ensures that all entries for the same power are aggregated together.\n\n3. **Count Heroes per Power**: For each group (i.e., each unique `power_name`), count the number of distinct `hero_id` entries from the `hero_power` table (`T1`). This count represents the number of superheroes associated with each power.\n\n4. **Order by Count in Descending Order**: Sort the grouped and counted results by the count of `hero_id` in descending order. This places the power with the highest number of superheroes at the top of the list.\n\n5. **Limit to Top Result**: Retrieve only the first row from the sorted results using `LIMIT 1`. This ensures the output is the single power name with the highest count of superheroes.\n\nThe final output will be the name of the power that the most superheroes possess, as determined by the above operations."
        ]
    },
    "286": {
        "sql": "SELECT (COUNT(CASE WHEN bond_type = '#' THEN bond_id ELSE NULL END) * 100.0 / COUNT(bond_id)) AS percentage_triple_bonds FROM bond;",
        "question": "Among all chemical compounds identified in the database, what percent of compounds form a triple-bond.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T",
        "explain": "triple bond refers to bond_type = '#';",
        "solution": [
            "To determine the percentage of chemical compounds that form a triple bond among all compounds in the database, follow these steps:\n\n1. **Count the total number of bonds** in the database. This is done by counting all entries in the `bond` table.\n\n2. **Count the number of triple bonds** by filtering the `bond` table for entries where the `bond_type` is '#' (which represents a triple bond).\n\n3. **Calculate the percentage** by dividing the count of triple bonds by the total count of bonds and then multiplying by 100. This gives the percentage of triple bonds relative to all bonds.\n\nThe SQL query performs these operations by:\n- Using `COUNT(T.bond_id)` to count all bonds.\n- Using `COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END)` to count only triple bonds.\n- Casting the triple bond count to a real number to ensure accurate division.\n- Multiplying the result by 100 to convert the fraction into a percentage."
        ]
    },
    "843": {
        "sql": "SELECT hp.hero_id\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Intelligence';",
        "question": "List the hero ID of superheroes have intellegence as their power.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.hero_id FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Intelligence'",
        "explain": "hero ID refers to superhero.id; have intelligence as their power refers to power_name = 'Intelligence';",
        "solution": []
    },
    "63": {
        "sql": "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2';",
        "question": "In chartered schools with charter number 00D2, what are the names of all the administrators? Include the name of the school and the city to which it belongs",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2'",
        "explain": "Chartered schools refer to Charter = 1 in the table schools; Full name refers to first name, last name",
        "solution": [
            "To find the names of all administrators in chartered schools with the charter number '00D2', along with the name of the school and the city it belongs to, follow these steps:\n\n1. **Identify the table**: The data is stored in the 'schools' table.\n2. **Filter the records**: Select only those records where the 'Charter' field is equal to 1 (indicating the school is chartered) and the 'CharterNum' field is equal to '00D2'.\n3. **Retrieve the required fields**: From the filtered records, extract the following fields:\n   - 'AdmFName1': The first name of the administrator.\n   - 'AdmLName1': The last name of the administrator.\n   - 'School': The name of the school.\n   - 'City': The city where the school is located.\n\nThis operation will return a list of administrators' names, along with their respective school names and cities, for the specified charter number."
        ]
    },
    "389": {
        "sql": "SELECT T1.name, T2.date FROM cards T1 INNER JOIN rulings T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf';",
        "question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'",
        "explain": "Creature - Elf is the originalType;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Data from Tables**: The query retrieves data from two tables: `cards` (aliased as `T1`) and `rulings` (aliased as `T2`).\n\n2. **Join Tables**: The tables are joined using the `INNER JOIN` operation. The join condition is that the `uuid` column in the `cards` table (`T1.uuid`) must match the `uuid` column in the `rulings` table (`T2.uuid`).\n\n3. **Filter Data**: The query filters the data to only include rows where the `originalType` column in the `cards` table (`T1.originalType`) is equal to the string 'Creature - Elf'.\n\n4. **Select Columns**: The query selects two columns for the output:\n   - `T1.id`: The ID of the card from the `cards` table.\n   - `T2.date`: The date of the ruling from the `rulings` table.\n\nThis operation ensures that only cards with the original type 'Creature - Elf' and their corresponding ruling dates are listed.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Select Data from Tables**: The query retrieves data from two tables:\n   - `cards` (aliased as `T1`): This table contains information about the cards, including their names and original types.\n   - `rulings` (aliased as `T2`): This table contains information about the rulings for the cards, including the dates of the rulings.\n\n2. **Join Tables**: The tables are joined using an `INNER JOIN` operation. The join condition specifies that the `uuid` column in the `cards` table (`T1.uuid`) must match the `uuid` column in the `rulings` table (`T2.uuid`). This ensures that only cards with corresponding rulings are included in the result.\n\n3. **Filter Data**: The query filters the data to only include rows where the `originalType` column in the `cards` table (`T1.originalType`) is exactly equal to the string 'Creature - Elf'. This ensures that only cards of the specified type are selected.\n\n4. **Select Columns**: The query selects the following columns for the output:\n   - `T1.id`: The ID of the card from the `cards` table, which uniquely identifies each card.\n   - `T2.date`: The date of the ruling from the `rulings` table, which provides the timestamp for when the ruling was made.\n\nThis sequence of operations ensures that the result includes only the names of cards with the original type 'Creature - Elf' along with the dates of their corresponding rulings."
        ]
    },
    "129": {
        "sql": "SELECT DISTINCT T1.A2 AS district_name\nFROM district T1\nJOIN account T2 ON T1.district_id = T2.district_id\nJOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%'\nORDER BY T1.A2 ASC\nLIMIT 10;",
        "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%' ORDER BY A2 ASC LIMIT 10",
        "explain": "Non-credit card withdraws refers to type = 'VYDAJ'; January 1996 can be found by date LIKE '1996-01%' in the database; A2 means district names",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Distinct District Names**: Retrieve unique district names from the `district` table (referred to as `T1`).\n\n2. **Join with Account Table**: Join the `district` table (`T1`) with the `account` table (`T2`) using the `district_id` field to link districts to their respective accounts.\n\n3. **Join with Transaction Table**: Further join the result with the `trans` table (`T3`) using the `account_id` field to link accounts to their transactions.\n\n4. **Filter Transactions**: Filter the transactions to include only those of type `'VYDAJ'` (withdrawals) and where the transaction date falls within January 1996 (using the pattern `'1996-01%'`).\n\n5. **Order Results**: Order the resulting district names in ascending order (`A2 ASC`).\n\n6. **Limit Results**: Limit the output to the top 10 distinct district names.\n\nThis sequence of operations ensures that the query retrieves the top ten districts with the most withdrawals (non-credit card) for January 1996, as specified in the question."
        ]
    },
    "1419": {
        "sql": "SELECT T2.category FROM event T1 JOIN budget T2 ON T1.event_id = T2.link_to_event WHERE T1.event_date = '2020-03-24T12:00:00';",
        "question": "What is the category of event which was taken place in 2020-03-24T12:00:00?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_date = '2020-03-24T12:00:00'",
        "explain": "taken place in 2020-03-24T12:00:00 refers to event_date = '2020-03-24T12:00:00'",
        "solution": [
            "To find the category of the event that took place on 2020-03-24T12:00:00, follow these steps:\n\n1. **Identify the event**: Look for the event in the `event` table (referred to as T1) where the `event_date` matches '2020-03-24T12:00:00'.\n\n2. **Join with the budget table**: Use the `event_id` from the identified event to join with the `budget` table (referred to as T2) where the `link_to_event` in T2 matches the `event_id` from T1.\n\n3. **Retrieve the category**: From the joined result, select the `category` field from the `budget` table (T2).\n\nThis process ensures you get the category of the event that occurred on the specified date and time."
        ]
    },
    "1116": {
        "sql": "SELECT player_name FROM Player WHERE height = (SELECT MAX(height) FROM Player);",
        "question": "List down most tallest players' name.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM (SELECT player_name, height, DENSE_RANK() OVER (ORDER BY height DESC) as rank FROM Player) WHERE rank = 1",
        "explain": "tallest refers to rank based on the height in descending order; Most tallest players refers to rank = 1 ",
        "solution": []
    },
    "1": {
        "sql": "SELECT \n    (`Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`) AS FreeMealRate\nFROM \n    frpm\nWHERE \n    `Educational Option Type` = 'Continuation School'\n    AND `Enrollment (Ages 5-17)` IS NOT NULL\n    AND `Free Meal Count (Ages 5-17)` IS NOT NULL\nORDER BY \n    FreeMealRate ASC\nLIMIT 3;",
        "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3",
        "explain": "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Filter the Data**: Select records from the `frpm` table where the `Educational Option Type` is 'Continuation School' and the ratio of `Free Meal Count (Ages 5-17)` to `Enrollment (Ages 5-17)` is not null. This ensures we only consider valid entries for students aged 5-17 in continuation schools.\n\n2. **Calculate the Ratio**: For each eligible record, compute the ratio of `Free Meal Count (Ages 5-17)` to `Enrollment (Ages 5-17)`. This ratio represents the free meal rate for students in the specified age group.\n\n3. **Sort the Ratios**: Order the computed ratios in ascending order to identify the lowest free meal rates.\n\n4. **Limit the Results**: Retrieve only the top 3 records with the lowest free meal rates, as these are the three lowest eligible rates for the given criteria.\n\nThe final output is a list of the three lowest free meal rates for students aged 5-17 in continuation schools.",
            "To solve the question, the following detailed steps are performed:\n\n1. **Filter the Data**: The query starts by selecting records from the `frpm` table where the `Educational Option Type` is exactly 'Continuation School'. Additionally, it ensures that the ratio of `Free Meal Count (Ages 5-17)` to `Enrollment (Ages 5-17)` is not null. This step filters out any invalid or incomplete records, focusing only on valid entries for students aged 5-17 in continuation schools.\n\n2. **Calculate the Free Meal Rate**: For each of the filtered records, the query calculates the ratio of `Free Meal Count (Ages 5-17)` to `Enrollment (Ages 5-17)`. This ratio represents the free meal rate for students in the specified age group and school type.\n\n3. **Sort the Results**: The computed free meal rates are then sorted in ascending order. This ordering ensures that the lowest free meal rates appear first in the result set.\n\n4. **Limit the Output**: Finally, the query limits the results to the top 3 records with the lowest free meal rates. This step directly answers the question by providing the three lowest eligible free meal rates for students aged 5-17 in continuation schools.\n\nThe output is a list of these three lowest free meal rates, each represented as a numerical value derived from the calculated ratio."
        ]
    },
    "222": {
        "sql": "SELECT (SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN label = '-' THEN 1 ELSE 0 END)) AS difference FROM molecule;",
        "question": "What is the difference between the number of molecules that are carcinogenic and those that are not?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar FROM molecule t",
        "explain": "label = '+' means molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; difference = SUBTRACT(SUM(label = '+'), SUM(label = '-'))",
        "solution": []
    },
    "361": {
        "sql": "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1 \nJOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Restricted' AND T1.isTextless = 0;",
        "question": "How many cards of legalities whose status is restricted have text boxes?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isTextless = 0",
        "explain": "restricted refers to status = 'restricted'; have text boxes refers to is Textless = 0;",
        "solution": [
            "To solve the question \"How many cards of legalities whose status is restricted have text boxes?\", follow these steps:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `cards` (aliased as `T1`)\n   - `legalities` (aliased as `T2`)\n\n2. **Join the Tables**: The tables are joined using the `uuid` column, which is common to both tables. This ensures that each card in the `cards` table is matched with its corresponding entry in the `legalities` table.\n\n3. **Filter by Status**: From the joined data, filter the records to include only those where the `status` in the `legalities` table is \"Restricted\".\n\n4. **Filter by Text Boxes**: Further filter the records to include only those cards where the `isTextless` column in the `cards` table is `0`, indicating that the card has text boxes (i.e., it is not textless).\n\n5. **Count Distinct Cards**: Finally, count the distinct `id` values from the `cards` table that meet the above criteria. This gives the total number of unique cards that are both restricted in legal status and have text boxes.\n\nThe SQL query accomplishes this by performing an inner join between the `cards` and `legalities` tables, applying the necessary filters, and then counting the distinct card IDs."
        ]
    },
    "880": {
        "sql": "WITH paul_driver AS (\n    SELECT driverId FROM drivers WHERE forename = 'Paul' AND surname = 'di Resta'\n),\nspeed_853 AS (\n    SELECT fastestLapSpeed FROM results \n    WHERE raceId = 853 AND driverId = (SELECT driverId FROM paul_driver)\n),\nspeed_854 AS (\n    SELECT fastestLapSpeed FROM results \n    WHERE raceId = 854 AND driverId = (SELECT driverId FROM paul_driver)\n)\nSELECT \n    CASE \n        WHEN (SELECT fastestLapSpeed FROM speed_853) IS NOT NULL AND (SELECT fastestLapSpeed FROM speed_854) IS NOT NULL THEN\n            ((CAST((SELECT fastestLapSpeed FROM speed_853) AS REAL) - CAST((SELECT fastestLapSpeed FROM speed_854) AS REAL)) / \n            CAST((SELECT fastestLapSpeed FROM speed_853) AS REAL)) * 100\n        ELSE NULL\n    END AS percentage_faster;",
        "error": "something went wrong, tool did not call.",
        "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
        "explain": "Paul di Resta refers to the full name of the driver; Full name of the driver refers to drivers.forename ='Paul' and drivers.surname = 'di Resta'; race number refers to raceId; percentage = DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), (fastestLapSpeed (raceId = 854)) * 100 , (fastestLapSpeed(raceId = 853))",
        "solution": []
    },
    "593": {
        "sql": "SELECT COUNT(DISTINCT T1.UserId) \nFROM badges T1 \nINNER JOIN users T2 ON T1.UserId = T2.Id \nWHERE T2.Location = 'New York' \nAND T1.Name IN ('Supporter', 'Teacher');",
        "question": "How many users from New York have a teacher and supporter badge?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(DISTINCT T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name IN ('Supporter', 'Teacher') AND T2.Location = 'New York'",
        "explain": "\"Supporter\" and \"Teachers\" are both Name of badge; 'New York' is the Location; user refers to UserId",
        "solution": [
            "To solve the question \"How many users from New York have a teacher and supporter badge?\", the following steps are performed:\n\n1. **Join the Tables**: Combine the `badges` table (referred to as `T1`) and the `users` table (referred to as `T2`) using the condition that the `UserId` in the `badges` table matches the `Id` in the `users` table.\n\n2. **Filter by Location**: From the joined tables, filter the rows where the `Location` column in the `users` table is equal to 'New York'.\n\n3. **Filter by Badge Name**: Further filter the rows to include only those where the `Name` column in the `badges` table is either 'Supporter' or 'Teacher'.\n\n4. **Count Distinct Users**: Count the distinct `Id` values from the `badges` table (i.e., count each user only once, even if they have multiple badges).\n\nThis process ensures that we accurately count the number of unique users from New York who have either a 'Supporter' or 'Teacher' badge.",
            "To solve the question \"How many users from New York have a teacher and supporter badge?\", the following detailed steps are performed:\n\n1. **Join the Tables**: Combine the `badges` table (referred to as `T1`) and the `users` table (referred to as `T2`) using an inner join. The join condition is that the `UserId` column in the `badges` table (`T1.UserId`) matches the `Id` column in the `users` table (`T2.Id`). This ensures that only rows with matching user IDs in both tables are included.\n\n2. **Filter by Location**: From the joined result, filter the rows to include only those where the `Location` column in the `users` table (`T2.Location`) is exactly equal to 'New York'. This narrows down the data to users located in New York.\n\n3. **Filter by Badge Name**: Further filter the rows to include only those where the `Name` column in the `badges` table (`T1.Name`) is either 'Supporter' or 'Teacher'. This ensures that only users with these specific badges are considered.\n\n4. **Count Distinct Users**: Finally, count the distinct `Id` values from the `badges` table (`T1.Id`). This step ensures that each user is counted only once, even if they have multiple badges (either 'Supporter' or 'Teacher').\n\nThe result of this process is the exact count of unique users from New York who have either a 'Supporter' or 'Teacher' badge."
        ]
    },
    "348": {
        "sql": "SELECT r.text FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Sublime Epiphany' AND c.number = '74s';",
        "question": "Describe the information about rulings for card named 'Sublime Epiphany' with number 74s.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'",
        "explain": "Sublime Epiphany' is name of cards; number 74s refers to number = '74s'; information refers to text;",
        "solution": [
            "To describe the information about rulings for the card named 'Sublime Epiphany' with the number '74s', follow these steps:\n\n1. **Identify the card**: Locate the card in the 'cards' table where the name is 'Sublime Epiphany' and the number is '74s'.\n2. **Retrieve the rulings**: Using the UUID (unique identifier) of the identified card, join the 'rulings' table to fetch all the text entries associated with that card.\n3. **Display the rulings**: The result will be the text of the rulings for the specified card.\n\nThis process ensures that only the rulings for the exact card matching the name 'Sublime Epiphany' and number '74s' are retrieved.",
            "To describe the information about rulings for the card named 'Sublime Epiphany' with the number '74s', follow these steps:\n\n1. **Identify the card**: Query the 'cards' table to find the card where the 'name' column matches 'Sublime Epiphany' and the 'number' column matches '74s'. This will retrieve the unique identifier (UUID) of the card.\n\n2. **Retrieve the rulings**: Using the UUID obtained from the previous step, join the 'rulings' table with the 'cards' table where the 'uuid' column in both tables matches. This will fetch all the text entries from the 'rulings' table that are associated with the identified card.\n\n3. **Display the rulings**: The result of this operation will be the text of the rulings for the card 'Sublime Epiphany' with the number '74s', as stored in the 'text' column of the 'rulings' table.\n\nThis process ensures that only the rulings for the exact card matching the specified name and number are retrieved."
        ]
    },
    "676": {
        "sql": "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65;",
        "question": "Please list all display names of users who are adults.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65",
        "explain": "adults refer to users where Age BETWEEN 19 and 65;",
        "solution": []
    },
    "744": {
        "sql": "SELECT \n    (SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics') - \n    (SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'DC Comics') AS difference;",
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "explain": "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = SUBTRACT(SUM(publisher_name = 'Marvel Comics'), SUM(publisher_name = 'DC Comics'))",
        "solution": []
    },
    "898": {
        "sql": "SELECT strftime('%Y', 'now') - strftime('%Y', dob) AS age, forename, surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1;",
        "question": "How old is the youngest Japanese driver? What is his name?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
        "explain": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);",
        "solution": [
            "To find the youngest Japanese driver and determine their age and name, follow these steps:\n\n1. **Filter Drivers by Nationality**: Select all drivers from the database whose nationality is 'Japanese'.\n\n2. **Sort by Date of Birth**: Arrange these drivers in descending order based on their date of birth (dob). This ensures the youngest driver (with the most recent dob) appears first.\n\n3. **Calculate Age**: For the youngest driver, calculate their age by subtracting their birth year (extracted from their dob) from the current year (extracted from the current timestamp).\n\n4. **Retrieve Name**: Extract the forename and surname of this youngest driver.\n\n5. **Limit Results**: Return only the top result (the youngest driver) from the sorted list.\n\nThe final output will include the age, forename, and surname of the youngest Japanese driver."
        ]
    },
    "378": {
        "sql": "SELECT id FROM cards WHERE hasFoil = 1 AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
        "question": "What are the foiled cards that are incredibly powerful when paired with non foiled cards? List the IDs.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "explain": "Incredibly powerful refers to both cardKingdomFoilId and cardKingdomId IS NOT Null;",
        "solution": []
    },
    "672": {
        "sql": "SELECT COUNT(DISTINCT T1.Id) \nFROM users T1 \nJOIN posts T2 ON T1.Id = T2.OwnerUserId \nWHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4;",
        "question": "Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4",
        "explain": "favorite amount of 4 or more refers to FavoriteCount > = 4; Location = 'United Kingdom';",
        "solution": [
            "To solve the question, we need to perform the following operations:\n\n1. **Filter Users by Location**: Identify all users whose location is specified as 'United Kingdom'.\n\n2. **Join Users with Posts**: For each user identified in step 1, find all their posts by joining the users table with the posts table using the user's ID (from the users table) and the post's owner user ID (from the posts table).\n\n3. **Filter Posts by Favorite Count**: From the joined data, select only those posts where the favorite count is 4 or more.\n\n4. **Count the Users**: Finally, count the number of distinct users who have at least one post meeting the criteria from step 3.\n\nThis sequence of operations ensures that we accurately count the number of users in the United Kingdom who have posts with a total favorite amount of 4 or more.",
            "To solve the question, we need to perform the following operations:\n\n1. **Filter Users by Location**: Identify all users whose location is specified as 'United Kingdom' in the `users` table (referred to as `T1` in the SQL).\n\n2. **Join Users with Posts**: For each user identified in step 1, find all their posts by joining the `users` table (`T1`) with the `posts` table (`T2`) using the user's ID (`T1.Id`) and the post's owner user ID (`T2.OwnerUserId`).\n\n3. **Filter Posts by Favorite Count**: From the joined data, select only those posts where the favorite count (`T2.FavoriteCount`) is 4 or more.\n\n4. **Count the Users**: Finally, count the number of distinct users (`COUNT(T1.Id)`) who have at least one post meeting the criteria from step 3.\n\nThis sequence of operations ensures that we accurately count the number of users in the United Kingdom who have posts with a total favorite amount of 4 or more."
        ]
    },
    "881": {
        "sql": "WITH race_on_date AS (\n    SELECT raceId FROM races WHERE date = '1983-07-16'\n),\ndriver_participation AS (\n    SELECT r.driverId, s.status\n    FROM results r\n    JOIN race_on_date rod ON r.raceId = rod.raceId\n    JOIN status s ON r.statusId = s.statusId\n),\ncompletion_stats AS (\n    SELECT \n        COUNT(*) AS total_drivers,\n        SUM(CASE WHEN status = 'Finished' THEN 1 ELSE 0 END) AS completed_drivers\n    FROM driver_participation\n)\nSELECT \n    (completed_drivers * 100.0 / total_drivers) AS completion_rate_percentage\nFROM completion_stats;",
        "question": "For the drivers who took part in the race in 1983/7/16, what's their race completion rate?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'",
        "explain": "DIVIDE(COUNT(driverid when time has value ), (COUNT(driverid )) as percentage; in 1983/7/16 refers to when date = '1983-07-16'",
        "solution": []
    },
    "293": {
        "sql": "SELECT COUNT(*) AS atom_count\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = '+';",
        "question": "How many atoms belong to the molecule labeled with carcinogenic compounds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "explain": "label = '+' mean molecules are carcinogenic;",
        "solution": []
    },
    "1253": {
        "sql": "SELECT patientData.Diagnosis\nFROM Patient AS patientData\nJOIN Laboratory AS labData ON patientData.ID = labData.ID\nWHERE labData.IGA BETWEEN 80 AND 500\nORDER BY labData.IGA DESC\nLIMIT 1;",
        "question": "For the patient who has the highest Ig A within the normal range, what is his or her diagnosis?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT patientData.Diagnosis FROM Patient AS patientData INNER JOIN Laboratory AS labData ON patientData.ID = labData.ID WHERE labData.IGA BETWEEN 80 AND 500 ORDER BY labData.IGA DESC LIMIT 1",
        "explain": "highest Ig A within the normal range refers to MAX(IGA BETWEEN 80 AND 500);",
        "solution": [
            "To find the diagnosis of the patient who has the highest IgA level within the normal range (80 to 500), follow these steps:\n\n1. **Join the Patient and Laboratory tables**: Link the records from the Patient table (aliased as `patientData`) and the Laboratory table (aliased as `labData`) using the common ID field.\n\n2. **Filter for normal IgA levels**: From the joined data, select only those records where the IgA value (`labData.IGA`) falls within the normal range of 80 to 500.\n\n3. **Sort by IgA levels in descending order**: Arrange the filtered records in descending order based on the IgA values to prioritize the highest IgA level.\n\n4. **Select the top record**: Retrieve only the first record from the sorted list, which corresponds to the patient with the highest IgA level within the normal range.\n\n5. **Extract the diagnosis**: From the selected record, return the diagnosis field (`patientData.Diagnosis`) as the final result."
        ]
    },
    "592": {
        "sql": "SELECT COUNT(*) AS UserCount\nFROM (\n    SELECT UserId\n    FROM badges\n    GROUP BY UserId\n    HAVING COUNT(*) > 5\n) AS UsersWithMoreThan5Badges;",
        "question": "How many users are awarded with more than 5 badges?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(UserId) FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "explain": "more than 5 badges refers to Count (Name) > 5; user refers to UserId",
        "solution": []
    },
    "791": {
        "sql": "SELECT AVG(CAST(height_cm AS REAL)) AS average_height FROM superhero;",
        "question": "Calculate the average height for each superhero.",
        "db_id": "superhero",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero",
        "explain": "average = DIVIDE(SUM(height_cm), COUNT(all heros));",
        "solution": [
            "To calculate the average height for each superhero, perform the following operations on the database:\n\n1. Sum all the values in the `height_cm` column of the `superhero` table.\n2. Count the number of records (rows) in the `superhero` table using the `id` column.\n3. Divide the sum of the heights by the count of records to compute the average height.\n4. Ensure the division result is cast to a real number to handle any fractional values accurately.\n\nThe result will be the average height of all superheroes in the table.",
            "To calculate the average height for each superhero, perform the following operations on the database:\n\n1. Sum all the values in the `height_cm` column of the `superhero` table using the `SUM` function.\n2. Count the number of records (rows) in the `superhero` table using the `COUNT` function on the `id` column.\n3. Divide the sum of the heights by the count of records to compute the average height.\n4. Cast the division result to a real number using the `CAST` function to ensure accurate handling of fractional values.\n\nThe result will be the average height of all superheroes in the table, represented as a real number."
        ]
    },
    "504": {
        "sql": "SELECT COUNT(*) \nFROM cards \nWHERE setCode = (SELECT code FROM sets WHERE name = 'World Championship Decks 2004') \nAND convertedManaCost = 3;",
        "question": "How many cards are there in the set 'World Championship Decks 2004' with the converted mana cost as '3'.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE setCode IN ( SELECT code FROM sets WHERE name = 'World Championship Decks 2004' ) AND convertedManaCost = 3",
        "explain": "the set 'World Championship Decks 2004' refers to name = 'World Championship Decks 2004'",
        "solution": []
    },
    "906": {
        "sql": "SELECT T1.name AS race_name, T2.points\nFROM races T1\nJOIN driverStandings T2 ON T1.raceId = T2.raceId\nJOIN drivers T3 ON T2.driverId = T3.driverId\nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\nORDER BY T1.year ASC\nLIMIT 1;",
        "question": "Which was Lewis Hamilton first race? What was his points recorded for his first race event?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year ASC LIMIT 1",
        "explain": "first race refers to min(Year); Lewis Hamiltonrefers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "solution": [
            "To find Lewis Hamilton's first race and the points he recorded in that event, the following steps are performed:\n\n1. **Join the tables**: \n   - The `races` table (aliased as `T1`) is joined with the `driverStandings` table (aliased as `T2`) on the condition that the `raceId` in both tables matches.\n   - The result is further joined with the `drivers` table (aliased as `T3`) on the condition that the `driverId` in `T2` matches the `driverId` in `T3`.\n\n2. **Filter for Lewis Hamilton**: \n   - The query filters the results to only include records where the driver's forename is 'Lewis' and the surname is 'Hamilton'.\n\n3. **Sort by year**: \n   - The results are sorted in ascending order by the `year` column from the `races` table to ensure the earliest race appears first.\n\n4. **Limit the result**: \n   - The query limits the result to the first record, which corresponds to Lewis Hamilton's first race.\n\n5. **Select the required fields**: \n   - The query selects the `name` of the race from the `races` table and the `points` recorded from the `driverStandings` table for the identified race.\n\nThis process ensures that the output includes the name of Lewis Hamilton's first race and the points he earned in that event."
        ]
    },
    "1241": {
        "sql": "SELECT \n    SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) AS lower_count,\n    SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) AS higher_count,\n    SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) AS difference\nFROM \n    Patient T1\nJOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T2.PLT <= 100 OR T2.PLT >= 400;",
        "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "explain": "abnormal platelet level refers to PLT <= 100 or PLT >= 400; platelet level lower than normal range refers to PLT < 100; calculation = SUBTRACT(SUM(PLT < 100), SUM(PLT > 400)); platelet level higher than normal range refers to PLT > 400;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: Combine the `Patient` table (referred to as `T1`) and the `Laboratory` table (referred to as `T2`) using the `ID` column as the common key. This ensures that each patient's laboratory results are linked to their respective patient records.\n\n2. **Filter Abnormal Platelet Levels**: Focus on patients with abnormal platelet levels. The platelet levels are stored in the `PLT` column of the `Laboratory` table.\n\n3. **Count Lower Than Normal Range**: Calculate the number of patients whose platelet levels (`PLT`) are lower than or equal to 100. This is done using a conditional sum where each patient with `PLT <= 100` is counted as 1, and others as 0.\n\n4. **Count Higher Than Normal Range**: Similarly, calculate the number of patients whose platelet levels (`PLT`) are higher than or equal to 400. This is done using another conditional sum where each patient with `PLT >= 400` is counted as 1, and others as 0.\n\n5. **Compare the Counts**: Subtract the count of patients with higher than normal platelet levels from the count of patients with lower than normal platelet levels. This provides the difference between the two groups.\n\nThe final result is a single value representing the difference between the number of patients with lower than normal platelet levels and those with higher than normal platelet levels.",
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: Combine the `Patient` table (referred to as `T1`) and the `Laboratory` table (referred to as `T2`) using the `ID` column as the common key. This ensures that each patient's laboratory results are linked to their respective patient records.\n\n2. **Filter Abnormal Platelet Levels**: Focus on patients with abnormal platelet levels. The platelet levels are stored in the `PLT` column of the `Laboratory` table.\n\n3. **Count Lower Than Normal Range**: Calculate the number of patients whose platelet levels (`PLT`) are lower than or equal to 100. This is done using a conditional sum where each patient with `PLT <= 100` is counted as 1, and others as 0.\n\n4. **Count Higher Than Normal Range**: Similarly, calculate the number of patients whose platelet levels (`PLT`) are higher than or equal to 400. This is done using another conditional sum where each patient with `PLT >= 400` is counted as 1, and others as 0.\n\n5. **Compare the Counts**: Subtract the count of patients with higher than normal platelet levels from the count of patients with lower than normal platelet levels. This provides the difference between the two groups.\n\nThe final result is a single value representing the difference between the number of patients with lower than normal platelet levels and those with higher than normal platelet levels."
        ]
    },
    "786": {
        "sql": "WITH strength_attribute AS (\n    SELECT id FROM attribute WHERE attribute_name = 'Strength'\n),\nmax_strength AS (\n    SELECT MAX(attribute_value) AS max_value\n    FROM hero_attribute\n    WHERE attribute_id = (SELECT id FROM strength_attribute)\n)\nSELECT COUNT(DISTINCT hero_id) AS hero_count\nFROM hero_attribute\nWHERE attribute_id = (SELECT id FROM strength_attribute)\nAND attribute_value = (SELECT max_value FROM max_strength);",
        "question": "How many heroes have the highest attribute value in strength?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )",
        "explain": "highest attribute value in strength refers to MAX(attribute_value) WHERE attribute_name = 'Strength';",
        "solution": []
    },
    "1160": {
        "sql": "SELECT (SUM(CASE WHEN (l.TP < 6.0 OR l.TP > 8.5) THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_abnormal\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.SEX = 'F';",
        "question": "What is the percentage of female patient had total protein not within the normal range?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F'",
        "explain": "female refers to sex = 'F'; total protein not within the normal range refers to TP < '6.0' or TP > '8.5'; calculation = DIVIDE((ID where sex = 'F' and TP < '6.0' or TP > '8.5'), COUNT(ID)) * 100",
        "solution": [
            "To determine the percentage of female patients whose total protein (TP) levels are not within the normal range (6.0 to 8.5), follow these steps:\n\n1. **Identify Female Patients**: Filter the `Patient` table to include only female patients (where `SEX = 'F'`).\n\n2. **Join with Laboratory Data**: Link the filtered female patients with their corresponding laboratory results in the `Laboratory` table using the patient `ID` as the common key.\n\n3. **Check Total Protein Levels**: For each female patient, check if their total protein (`TP`) level is either below 6.0 or above 8.5 (i.e., not within the normal range).\n\n4. **Count Abnormal Cases**: Count how many female patients have abnormal total protein levels.\n\n5. **Calculate Percentage**: Divide the count of abnormal cases by the total number of female patients and multiply by 100 to get the percentage.\n\nThe SQL query performs these operations by:\n- Using a `CASE` statement to flag abnormal cases (1 for abnormal, 0 otherwise).\n- Summing the flagged cases to get the total count of abnormal results.\n- Dividing this sum by the total count of female patients and multiplying by 100 to compute the percentage.\n\nThe result is the percentage of female patients with total protein levels outside the normal range."
        ]
    },
    "916": {
        "sql": "SELECT surname FROM drivers WHERE nationality = 'Italian';",
        "question": "Please list the surnames of all the Italian drivers.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT surname FROM drivers WHERE nationality = 'Italian'",
        "explain": "Italian refers to nationality = 'italian'",
        "solution": []
    },
    "224": {
        "sql": "SELECT DISTINCT c1.bond_id\nFROM connected c1\nJOIN connected c2 ON c1.atom_id2 = c2.atom_id2\nWHERE c2.atom_id = 'TR000_2' OR c2.atom_id2 = 'TR000_2';",
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "explain": "TR000_2 is the atom id; atom ID 2 refers to atom_id2",
        "solution": []
    },
    "375": {
        "sql": "SELECT id FROM cards WHERE convertedManaCost = 0;",
        "question": "List down all the card IDs with converted mana cost of 0.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE convertedManaCost = 0",
        "explain": "converted mana cost of 0 refers to covertedManaCost = 0;",
        "solution": []
    },
    "227": {
        "sql": "SELECT ROUND((SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(molecule_id)), 3) AS percentage\nFROM molecule;",
        "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3) FROM molecule t",
        "explain": "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent",
        "solution": []
    },
    "289": {
        "sql": "SELECT label FROM molecule WHERE molecule_id = 'TR151';",
        "question": "Is molecule TR151 carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR151'",
        "explain": "label = '+' mean molecules are carcinogenic;",
        "solution": []
    },
    "584": {
        "sql": "SELECT ph.Comment\nFROM posts p\nJOIN postHistory ph ON p.Id = ph.PostId\nWHERE p.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'\nAND ph.Comment IS NOT NULL;",
        "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "explain": "\"Why square the difference instead of taking the absolute value in standard deviation?\" is the Title of post;",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Identify the target post**: Locate the post in the `posts` table where the title is 'Why square the difference instead of taking the absolute value in standard deviation?'.\n\n2. **Retrieve the post's ID**: Extract the `Id` of the identified post from the `posts` table.\n\n3. **Join with post history**: Use the retrieved post ID to join the `posts` table with the `postHistory` table on the `PostId` field, which links the post to its editing history.\n\n4. **Filter comments**: From the joined tables, select only the `Comment` entries from the `postHistory` table, which represent the comments left by users who edited the post.\n\n5. **Output the results**: Display the retrieved comments as the final output.\n\nThis process ensures that all comments left by users who edited the specified post are accurately retrieved and displayed."
        ]
    },
    "626": {
        "sql": "SELECT COUNT(*) AS vote_count FROM votes WHERE strftime('%Y', CreationDate) = '2010';",
        "question": "How many votes were made in 2010?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM votes WHERE STRFTIME('%Y', CreationDate) = '2010'",
        "explain": "YEAR(CreationDate) = 2010;",
        "solution": []
    },
    "1365": {
        "sql": "SELECT T2.expense_description\nFROM budget T1\nJOIN expense T2 ON T1.budget_id = T2.link_to_budget\nORDER BY T1.remaining ASC\nLIMIT 1;",
        "question": "What are the expenses of the budget with the lowest remaining?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.expense_description FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget ORDER BY T1.remaining LIMIT 1",
        "explain": "expense of budget refers to expense_description; lowest remaining refers to MIN(remaining)",
        "solution": [
            "To find the expenses of the budget with the lowest remaining amount, follow these steps:\n\n1. **Join the Tables**: Combine the `budget` table (referred to as `T1`) with the `expense` table (referred to as `T2`) using the `budget_id` from `T1` and the `link_to_budget` from `T2`. This ensures that each expense is linked to its corresponding budget.\n\n2. **Sort by Remaining Amount**: Arrange the joined records in ascending order based on the `remaining` column from the `budget` table (`T1`). This will place the budget with the lowest remaining amount at the top of the list.\n\n3. **Select the Top Record**: Retrieve only the first record from the sorted list, which corresponds to the budget with the lowest remaining amount.\n\n4. **Extract Expense Description**: From the selected record, extract the `expense_description` from the `expense` table (`T2`), which provides the details of the expenses associated with the identified budget.\n\nThis process ensures that you accurately identify and display the expenses linked to the budget that has the least remaining funds."
        ]
    },
    "1484": {
        "sql": "SELECT \n    (SELECT COUNT(*) FROM gasstations WHERE Segment = 'Discount' AND Country = 'CZE') - \n    (SELECT COUNT(*) FROM gasstations WHERE Segment = 'Discount' AND Country = 'SVK') AS Difference;",
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "explain": "Czech Republic can be represented as the Country value in gasstations table is 'CZE'; Slovakia can be represented as the Country value in the gasstations table is 'SVK';  Computation of more \"discount\" gas stations= Total no. of discount gas stations in Czech Republic - Total no. of discount gas stations in Slovakia",
        "solution": [
            "To determine how many more \"discount\" gas stations the Czech Republic (CZE) has compared to Slovakia (SVK), follow these steps:\n\n1. **Filter the Data**: Select all gas stations where the segment is labeled as \"Discount\".\n2. **Count for Czech Republic (CZE)**: For each gas station, check if the country is \"CZE\". If it is, count it as 1; otherwise, count it as 0. Sum these values to get the total number of \"discount\" gas stations in the Czech Republic.\n3. **Count for Slovakia (SVK)**: Similarly, for each gas station, check if the country is \"SVK\". If it is, count it as 1; otherwise, count it as 0. Sum these values to get the total number of \"discount\" gas stations in Slovakia.\n4. **Calculate the Difference**: Subtract the total number of \"discount\" gas stations in Slovakia from the total number in the Czech Republic to find out how many more \"discount\" gas stations the Czech Republic has compared to Slovakia.\n\nThe result will be the numerical difference in the count of \"discount\" gas stations between the two countries."
        ]
    },
    "1318": {
        "sql": "SELECT T1.event_name\nFROM event T1\nJOIN attendance T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_name\nORDER BY COUNT(T2.link_to_event) DESC\nLIMIT 1;",
        "question": "What is the event that has the highest attendance of the students from the Student_Club?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_name ORDER BY COUNT(T2.link_to_event) DESC LIMIT 1",
        "explain": "event with highest attendance refers to MAX(COUNT(link_to_event))",
        "solution": [
            "To find the event with the highest attendance of students from the Student_Club, follow these steps:\n\n1. **Join the Tables**: Combine the `event` table (aliased as `T1`) with the `attendance` table (aliased as `T2`) using the `event_id` from the `event` table and the `link_to_event` from the `attendance` table. This ensures that each event is matched with its corresponding attendance records.\n\n2. **Group by Event Name**: Group the results by the `event_name` from the `event` table. This allows us to aggregate attendance data for each unique event.\n\n3. **Count Attendance**: For each event, count the number of attendance records (i.e., the number of times `link_to_event` appears in the `attendance` table). This gives the total attendance for each event.\n\n4. **Order by Attendance Count**: Sort the grouped results in descending order based on the attendance count. This places the event with the highest attendance at the top of the list.\n\n5. **Limit to Top Result**: Retrieve only the first row from the sorted list, which corresponds to the event with the highest attendance.\n\nThe final output will be the name of the event (`event_name`) that has the highest number of student attendees from the Student_Club."
        ]
    },
    "1363": {
        "sql": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "question": "List all of the College of Humanities and Social Sciences' departments.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "explain": "",
        "solution": [
            "To list all departments in the 'College of Humanities and Social Sciences', you need to retrieve the 'department' column from the 'major' table where the 'college' column matches the value 'College of Humanities and Social Sciences'."
        ]
    },
    "555": {
        "sql": "SELECT AVG(p.Score) AS AverageScore\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';",
        "question": "What is the average score of the posts owned by the user csgillespie?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.Score) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "explain": "\"csgillespie\" is the DisplayName of user; average score refers to AVG(Score)",
        "solution": []
    },
    "811": {
        "sql": "SELECT a.alignment, GROUP_CONCAT(sp.power_name, ', ') AS superpowers\nFROM superhero sh\nJOIN alignment a ON sh.alignment_id = a.id\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Atom IV'\nGROUP BY a.alignment;",
        "question": "Give the alignment and superpowers of the superhero named Atom IV.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T4.alignment, T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN alignment AS T4 ON T1.alignment_id = T4.id WHERE T1.superhero_name = 'Atom IV'",
        "explain": "superpowers refers to power_name;",
        "solution": []
    },
    "143": {
        "sql": "SELECT DISTINCT d.account_id\nFROM card c\nJOIN disp d ON c.disp_id = d.disp_id\nWHERE c.type = 'gold';",
        "question": "What are the accounts that have gold credit cards?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T2.account_id FROM disp AS T2  INNER JOIN card AS T1 ON T1.disp_id = T2.disp_id  WHERE T1.type = 'gold'",
        "explain": "",
        "solution": []
    },
    "1294": {
        "sql": "SELECT T2.ID\nFROM Laboratory T1\nJOIN Examination T2 ON T1.ID = T2.ID\nWHERE T1.CRE < 1.5\nORDER BY T2.`aCL IgA` DESC\nLIMIT 1;",
        "question": "Please list the patient's ID whose creatinine level is normal and whose anti Cardiolipin antibody concentration level is the highest.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.CRE < 1.5 ORDER BY T2.`aCL IgA` DESC LIMIT 1",
        "explain": "creatinine level is normal refers to CRE < 1.5; anti Cardiolipin antibody concentration level is the highest refers to MAX(aCL IgA);",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Join the Tables**: Combine the `Laboratory` table (referred to as `T1`) and the `Examination` table (referred to as `T2`) using the `ID` column as the common key. This ensures that we are working with data that exists in both tables for the same patient.\n\n2. **Filter by Normal Creatinine Level**: From the joined data, filter out records where the creatinine level (`CRE`) is less than 1.5. This ensures we only consider patients with normal creatinine levels.\n\n3. **Sort by Anti-Cardiolipin Antibody Concentration**: Sort the filtered records in descending order based on the `aCL IgA` column (anti-Cardiolipin antibody concentration level). This places the patient with the highest concentration at the top of the list.\n\n4. **Select the Top Record**: Limit the result to only the top record (using `LIMIT 1`), which corresponds to the patient with the highest anti-Cardiolipin antibody concentration among those with normal creatinine levels.\n\n5. **Output the Patient ID**: Finally, retrieve and display the `ID` of the selected patient from the `Examination` table (`T2`)."
        ]
    },
    "521": {
        "sql": "SELECT l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.frameVersion = '1997'\nAND c.artist = 'D. Alexander Gregory'\nAND (c.hasContentWarning = 1 OR c.flavorText LIKE '%Wizards of the Coast%')\nAND l.format = 'legacy';",
        "question": "Among the cards whose version of frame style is 1997, what is the status of the card illustrated by D. Alexander Gregory in legacy play format that has sensitive content or Wizards of the Coast?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.frameVersion = 1997 AND T1.hasContentWarning = 1 AND T1.artist = 'D. Alexander Gregory' AND T2.format = 'legacy'",
        "explain": "version of frame style is 1997 refers to frameVersion = '1997'; illustrated by D. Alexander Gregory refers to artist = 'D. Alexander Gregory'; sensitive content refers to hasContentWarning = 1; legacy play format refers to format = 'legacy'; status of the card refers to status",
        "solution": []
    },
    "342": {
        "sql": "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1",
        "question": "List the card names with value that cost more converted mana for the face.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1",
        "explain": "more converted mana for the face refers to Max(faceConvertedManaCost);",
        "solution": [
            "To solve the question, which asks for the card names with the highest converted mana cost for the face, the following steps are performed:\n\n1. **Select the Name Column**: The query retrieves the `name` column from the `cards` table.\n2. **Order by Converted Mana Cost**: The results are ordered by the `faceConvertedManaCost` column in ascending order. This means the card with the lowest converted mana cost will appear first.\n3. **Limit to One Result**: The `LIMIT 1` clause ensures only the first result (the card with the lowest converted mana cost) is returned.\n\nThis operation directly translates to the SQL query: `SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1`."
        ]
    },
    "902": {
        "sql": "SELECT T1.name FROM races T1 JOIN driverStandings T2 ON T1.raceId = T2.raceId JOIN drivers T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20;",
        "question": "Which race was Alex Yoong in when he was in track number less than 20?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
        "explain": "Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;track number less than 10 refers to position < 20",
        "solution": [
            "To find out which race Alex Yoong participated in when he was in a track position less than 20, follow these steps:\n\n1. **Identify the tables involved**: The query uses three tables:\n   - `races` (aliased as `T1`) to get the race details.\n   - `driverStandings` (aliased as `T2`) to get the driver's standings in the race.\n   - `drivers` (aliased as `T3`) to get the driver's details.\n\n2. **Join the tables**:\n   - Join `driverStandings` (`T2`) with `races` (`T1`) on the `raceId` field to link the standings to the specific race.\n   - Join `driverStandings` (`T2`) with `drivers` (`T3`) on the `driverId` field to link the standings to the specific driver.\n\n3. **Apply the filters**:\n   - Filter the `drivers` table (`T3`) to only include records where the driver's forename is 'Alex' and surname is 'Yoong'.\n   - Filter the `driverStandings` table (`T2`) to only include records where the position is less than 20.\n\n4. **Retrieve the result**:\n   - Select the `name` field from the `races` table (`T1`) to get the name of the race(s) that meet the above criteria.\n\nThis process ensures that the query returns the names of all races where Alex Yoong was in a track position less than 20."
        ]
    },
    "1372": {
        "sql": "SELECT i.date_received\nFROM income i\nJOIN member m ON i.link_to_member = m.member_id\nWHERE m.first_name = 'Casey' AND m.last_name = 'Mason';",
        "question": "When did the member, Casey Mason, received the income?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "explain": "when the income was received refers to date_received",
        "solution": []
    },
    "80": {
        "sql": "SELECT T1.\"School Type\", T1.\"School Name\", T2.Latitude\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.Latitude DESC\nLIMIT 1;",
        "question": "What is the school type of the school with the highest latitude? Indicate the name of the school as well as the latitude coordinates.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`School Type`, T1.`School Name`, T2.Latitude FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.Latitude DESC LIMIT 1",
        "explain": "",
        "solution": [
            "To find the school type, name, and latitude coordinates of the school with the highest latitude, follow these steps:\n\n1. **Join the Tables**: Combine the data from the `frpm` table (referred to as `T1`) and the `schools` table (referred to as `T2`) using the `CDSCode` column as the common key. This ensures that each school's information from both tables is linked correctly.\n\n2. **Sort by Latitude**: Arrange the combined data in descending order based on the `Latitude` column from the `schools` table (`T2.Latitude`). This places the school with the highest latitude at the top of the list.\n\n3. **Select the Top Entry**: Retrieve only the first entry from the sorted list, which corresponds to the school with the highest latitude. From this entry, extract the following details:\n   - `School Type` from the `frpm` table (`T1.`School Type`).\n   - `School Name` from the `frpm` table (`T1.`School Name`).\n   - `Latitude` from the `schools` table (`T2.Latitude`).\n\nThis process ensures that you accurately identify the school with the highest latitude and provide its type, name, and coordinates."
        ]
    },
    "316": {
        "sql": "SELECT DISTINCT a.molecule_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'c' AND m.label = '-';",
        "question": "Among the molecules which contain \"c\" element, which of them are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
        "explain": "label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "878": {
        "sql": "SELECT T2.forename || ' ' || T2.surname AS full_name\nFROM lapTimes T1\nJOIN drivers T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 348\nORDER BY T1.time ASC\nLIMIT 1;",
        "question": "Who was the driver that got the best lap time in the race No. 348? Give his full name.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T2.forename, T2.surname FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 348 ORDER BY T1.time ASC LIMIT 1",
        "explain": "race number refers to raceId; the best lap time refers to MIN(time)",
        "solution": [
            "To find the driver who achieved the best lap time in race number 348, follow these steps:\n\n1. **Access the lap times data**: Retrieve the lap times recorded for all drivers in the race with the ID 348 from the `lapTimes` table.\n\n2. **Join with drivers data**: Link the lap times data to the `drivers` table using the `driverId` field to get the corresponding driver details.\n\n3. **Sort by lap time**: Arrange the combined data in ascending order based on the lap time (`time` field) to identify the fastest lap.\n\n4. **Select the top result**: Pick the first entry from the sorted list, which represents the driver with the best lap time.\n\n5. **Retrieve the driver's full name**: Extract the `forename` and `surname` of the identified driver to get their full name.\n\nThe final output will display the full name of the driver who recorded the fastest lap time in race 348.",
            "To determine the driver who achieved the best lap time in race number 348, follow these detailed steps:\n\n1. **Filter lap times by race ID**: From the `lapTimes` table (referred to as `T1`), select all records where the `raceId` is equal to 348. This isolates the lap times for the specified race.\n\n2. **Join with drivers table**: Perform an inner join between the filtered `lapTimes` table (`T1`) and the `drivers` table (referred to as `T2`). The join condition is `T2.driverId = T1.driverId`, ensuring that each lap time is linked to the corresponding driver's details.\n\n3. **Sort lap times in ascending order**: Arrange the joined results by the `time` field from the `lapTimes` table (`T1.time`) in ascending order. This places the fastest lap time at the top of the list.\n\n4. **Limit to the top result**: Use the `LIMIT 1` clause to select only the first row from the sorted results. This row contains the driver with the best lap time.\n\n5. **Retrieve the driver's full name**: From the selected row, extract the `forename` and `surname` fields from the `drivers` table (`T2`). These fields are combined to form the driver's full name.\n\nThe final output will be the full name of the driver who recorded the fastest lap time in race 348."
        ]
    },
    "737": {
        "sql": "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.superhero_name = 'Copycat';",
        "question": "What is Copycat's race?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'Copycat'",
        "explain": "Copycat is the superhero_name;",
        "solution": []
    },
    "353": {
        "sql": "SELECT T1.name, T1.totalSetSize\nFROM sets T1\nJOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.language = 'Italian';",
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "explain": "Italian translation refers to language = 'Italian'; total number of card per set refers to totalSetSize;",
        "solution": [
            "To list all the sets available in Italian translation along with the total number of cards per set, follow these steps:\n\n1. **Identify the tables involved**: The query uses two tables, `sets` (referred to as `T1`) and `set_translations` (referred to as `T2`).\n\n2. **Understand the join condition**: The query joins these two tables on the condition that the `code` column in the `sets` table (`T1.code`) matches the `setCode` column in the `set_translations` table (`T2.setCode`).\n\n3. **Apply the filter**: The query filters the results to only include rows where the `language` column in the `set_translations` table (`T2.language`) is equal to 'Italian'.\n\n4. **Select the required columns**: The query retrieves the `name` column from the `sets` table (`T1.name`) and the `totalSetSize` column from the `sets` table (`T1.totalSetSize`).\n\n5. **Output the results**: The final output will be a list of set names and their corresponding total number of cards, but only for sets that have an Italian translation."
        ]
    },
    "1330": {
        "sql": "SELECT m.college\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Tyler' AND mb.last_name = 'Hewitt';",
        "question": "What college offers the major that Tyler Hewitt took?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'",
        "explain": "",
        "solution": []
    },
    "528": {
        "sql": "SELECT c.name, l.format\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.setCode = (SELECT code FROM sets WHERE name = 'Hour of Devastation');",
        "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
        "explain": "the set Hour of Devastation refers to set.name = 'Hour of Devastation'; names of all the cards in the set refers to cards.name; legal cards refers to status = 'Legal'; the formats refers to format",
        "solution": []
    },
    "1077": {
        "sql": "SELECT team_long_name FROM Team WHERE team_short_name = 'GEN';",
        "question": "What's the long name for the team GEN?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT team_long_name FROM Team WHERE team_short_name = 'GEN'",
        "explain": "long name for the team refers to team_long_name; team_short_name = 'GEN';",
        "solution": []
    },
    "949": {
        "sql": "SELECT T2.name\nFROM constructorStandings T1\nJOIN constructors T2 ON T1.constructorId = T2.constructorId\nORDER BY T1.points DESC\nLIMIT 1;",
        "question": "Which constructor has the highest point?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId ORDER BY T1.points DESC LIMIT 1",
        "explain": "",
        "solution": [
            "To determine which constructor has the highest points, follow these steps:\n\n1. **Join the Tables**: Combine the `constructorStandings` table (referred to as `T1`) with the `constructors` table (referred to as `T2`) using the `constructorId` field as the common key. This ensures that each constructor's standings are matched with their respective details.\n\n2. **Sort by Points**: Arrange the joined records in descending order based on the `points` column from the `constructorStandings` table (`T1.points`). This places the constructor with the highest points at the top of the list.\n\n3. **Select the Top Constructor**: Retrieve only the first record from the sorted list, which corresponds to the constructor with the highest points. The `name` column from the `constructors` table (`T2.name`) is selected to display the constructor's name.\n\nThis process ensures that the query accurately identifies and returns the constructor with the highest points."
        ]
    },
    "699": {
        "sql": "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat';",
        "question": "When did the user known as 'IrishStat' create his or her account?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat'",
        "explain": "DisplayName = 'IrishStat'; when create his or her account refers to CreationDate;",
        "solution": []
    },
    "1192": {
        "sql": "SELECT DISTINCT T1.ID\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '-'\nAND T2.Date LIKE '1991-10-%'\nAND T2.\"T-BIL\" < 2.0;",
        "question": "List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.`T-BIL` < 2.0 AND T2.Date LIKE '1991-10-%'",
        "explain": "followed up at the outpatient clinic refers to Admission = '-'; laboratory test in April 1981 refers to Date like '1991-10%'; blood bilirubin level within the normal range refers to T-BIL < 2.0; ",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Select Distinct Patient IDs**: Retrieve unique patient IDs to ensure no duplicates in the result.\n\n2. **Join Tables**: Combine the `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) using the patient ID as the common key.\n\n3. **Filter Outpatient Clinic Patients**: Include only patients who were followed up at the outpatient clinic by checking if the `Admission` field in the `Patient` table is marked as `'-'`.\n\n4. **Filter Laboratory Tests in October 1991**: Include only laboratory tests conducted in October 1991 by checking if the `Date` field in the `Laboratory` table starts with `'1991-10-'`.\n\n5. **Filter Normal Bilirubin Levels**: Include only patients whose total blood bilirubin level (`T-BIL`) in the `Laboratory` table is less than `2.0`, which is within the normal range.\n\nThe final result is a list of distinct patient IDs who meet all the above criteria."
        ]
    },
    "1163": {
        "sql": "SELECT MIN(strftime('%Y', `First Date`) - strftime('%Y', Birthday) - (strftime('%m-%d', `First Date`) < strftime('%m-%d', Birthday))) AS youngest_age FROM Patient;",
        "question": "What was the age of the youngest patient when they initially arrived at the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT MIN(STRFTIME('%Y', `First Date`) - STRFTIME('%Y', Birthday)) FROM Patient",
        "explain": "age refers to SUBTRACT(YEAR(`First Date`),YEAR(Birthday))",
        "solution": []
    },
    "324": {
        "sql": "SELECT (SUM(CASE WHEN bond_type = '-' THEN 1 ELSE 0 END) * 100.0 / COUNT(bond_id)) AS percentage_single_bonds FROM bond;",
        "question": "Find the percentage of atoms with single bond.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond t",
        "explain": "single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(bond_type = '-'), COUNT(bond_id)) as percentage",
        "solution": []
    },
    "1214": {
        "sql": "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TP < 6.0;",
        "question": "List ID, sex and date of birth of patient whose total protein (TP) below the lower range of the normal index.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0",
        "explain": "total protein (TP) below the lower range of the normal index refers to TP < 6.0",
        "solution": []
    },
    "1513": {
        "sql": "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-25'\nORDER BY t.Time ASC\nLIMIT 1;",
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "explain": "'2012/8/25' can be represented by '2012-08-25'",
        "solution": []
    },
    "551": {
        "sql": "SELECT COUNT(*) AS badge_count\nFROM badges\nWHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');",
        "question": "How many badges has the user csgillespie obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "explain": "\"csgillespie\" is the DisplayName of user",
        "solution": []
    },
    "1295": {
        "sql": "SELECT COUNT(T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nJOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.`T-BIL` >= 2 AND T3.`ANA Pattern` LIKE '%P%'",
        "question": "Among the patients whose total bilirubin is over the normal range, how many of them have a peripheral pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` >= 2 AND T3.`ANA Pattern` LIKE '%P%'",
        "explain": "total bilirubin is over the normal range refers to `T-BIL` > = 2.0; peripheral pattern is observed in the sheet of ANA examination refers to that ANA Pattern contains 'P';",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Identify Patients with High Total Bilirubin**: Filter the `Patient` table to include only those patients whose total bilirubin (`T-BIL`) is 2 or higher. This is done by joining the `Patient` table (`T1`) with the `Laboratory` table (`T2`) where the patient ID matches and the `T-BIL` value is at least 2.\n\n2. **Check ANA Examination for Peripheral Pattern**: Further filter these patients by joining the `Patient` table (`T1`) with the `Examination` table (`T3`) where the patient ID matches and the `ANA Pattern` contains the letter 'P' (indicating a peripheral pattern).\n\n3. **Count the Matching Patients**: Finally, count the number of patients who meet both criteria (high total bilirubin and peripheral pattern in ANA examination).\n\nThe SQL query combines these steps into a single operation, counting the number of patients (`COUNT(T1.ID)`) who satisfy both conditions."
        ]
    },
    "1403": {
        "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.status = 'Closed' AND b.remaining < 0\nORDER BY b.remaining ASC\nLIMIT 1;",
        "question": "Indicate the name of the closed event whose cost has exceeded the budget the most.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event WHERE T1.event_status = 'Closed' AND T1.remaining < 0 ORDER BY T1.remaining LIMIT 1",
        "explain": "closed events refers to event_name where status = 'Closed'; exceed the budget the most refers to MIN(remaining) where remaining < 0",
        "solution": []
    },
    "1371": {
        "sql": "SELECT COUNT(DISTINCT link_to_member) AS member_count\nFROM attendance\nWHERE link_to_event = (SELECT event_id FROM event WHERE event_name = \"Women's Soccer\");",
        "question": "How many members attended the \"Women's Soccer\" event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
        "explain": "'Women's Soccer' is the event name;",
        "solution": []
    },
    "262": {
        "sql": "SELECT DISTINCT b.molecule_id\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE b.bond_type = '-' AND m.label = '-';",
        "question": "Among the single bond molecule id, which molecules are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
        "explain": "label = '-' means molecules are non-carcinogenic; single bond refers to bond_type = '-';",
        "solution": []
    },
    "990": {
        "sql": "SELECT c.constructorRef, c.url\nFROM constructors c\nJOIN results r ON c.constructorId = r.constructorId\nJOIN races ra ON r.raceId = ra.raceId\nWHERE ra.year = 2009 AND ra.name = 'Singapore Grand Prix' AND r.positionOrder = 1;",
        "question": "What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "explain": "the time of the champion shows in the format of \"minutes: seconds.millionsecond\" in which Max(time); constructor reference name refers to constructorRef; website refers to url",
        "solution": []
    },
    "177": {
        "sql": "SELECT \n    t.balance AS sum_after_transaction,\n    c.gender AS account_owner_gender\nFROM \n    trans t\nJOIN \n    account a ON t.account_id = a.account_id\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    client c ON d.client_id = c.client_id\nWHERE \n    c.client_id = 4\n    AND t.trans_id = 851;",
        "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
        "explain": "",
        "solution": []
    },
    "808": {
        "sql": "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.weight_kg = 108 AND s.height_cm = 188;",
        "question": "Find the race of the superhero who weighs 108kg and is 188cm tall.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 108 AND T1.height_cm = 188",
        "explain": "weighs 108kg refers to weight_kg = 108; 188cm tall refers to height_cm = 188;",
        "solution": []
    },
    "757": {
        "sql": "SELECT r.race\nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.weight_kg = 169;",
        "question": "Identify the race of the superhero who weighed 169 kg.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 169",
        "explain": "weighed 169 kg refers to weight_kg = 169",
        "solution": []
    },
    "1019": {
        "sql": "SELECT AVG(l.milliseconds) AS average_lap_time_ms\nFROM lapTimes l\nJOIN races r ON l.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Italy';",
        "question": "What is the average lap time in milliseconds of all the lap records set on the various circuits in Italy?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy'",
        "explain": "average = AVG(milliseconds)",
        "solution": []
    },
    "1498": {
        "sql": "SELECT MAX(monthly_consumption) AS highest_monthly_consumption\nFROM (\n    SELECT SUM(Consumption) AS monthly_consumption\n    FROM yearmonth\n    WHERE substr(Date, 1, 4) = '2012'\n    GROUP BY substr(Date, 5, 2)\n);",
        "question": "What is the highest monthly consumption in the year 2012?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1",
        "explain": "The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "solution": []
    },
    "921": {
        "sql": "SELECT DISTINCT c.url\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nWHERE c.name = 'Silverstone Circuit';",
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "explain": "more information refers to url",
        "solution": [
            "To retrieve more information about the Formula 1 races that used the Silverstone Circuit, follow these steps:\n\n1. **Identify the Circuit**: First, locate the circuit named 'Silverstone Circuit' in the `circuits` table. This table contains details about various racing circuits.\n\n2. **Join with Races Table**: Next, join the `circuits` table with the `races` table using the `circuitID` field. This links the Silverstone Circuit to all the races that took place there.\n\n3. **Select Distinct URLs**: Finally, select the distinct URLs from the `circuits` table (aliased as T1) that correspond to the races held at the Silverstone Circuit. This ensures you get unique URLs for further information about these races.\n\nThe SQL query achieves this by performing an inner join between the `circuits` and `races` tables, filtering for the 'Silverstone Circuit', and returning the distinct URLs associated with those races."
        ]
    },
    "819": {
        "sql": "SELECT \n    (SUM(CASE WHEN s.eye_colour_id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN s.eye_colour_id = 1 THEN 1 ELSE 0 END)) AS difference\nFROM \n    superhero s\nWHERE \n    s.weight_kg = 0 OR s.weight_kg IS NULL;",
        "question": "In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL",
        "explain": "missing weight data refers to weight_kg = 0 OR T1.weight_kg = NULL; difference = SUBTRACT(SUM(colour.id = 7), SUM(colour.id = 1)); blue eyes refers to eye_colour_id WHERE colour.id = 7; no eye color refers to eye_colour_id WHERE colour.id = 1;",
        "solution": []
    },
    "926": {
        "sql": "SELECT MIN(r.fastestLapTime) AS fastest_lap_time\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "question": "What's the fastest lap time ever in a race for Lewis Hamilton?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.fastestLapTime FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "explain": "fastest lap time ever refers to min(fastestLapTime)",
        "solution": []
    },
    "283": {
        "sql": "SELECT m.label AS flag_carcinogenic FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'ca';",
        "question": "Identify whether the chemical compound that contains Calcium is carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'",
        "explain": "calcium refers to element = 'ca'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic;",
        "solution": [
            "To determine whether the chemical compound containing Calcium (Ca) is carcinogenic, follow these steps:\n\n1. **Access the `atom` table (T1)**: This table contains information about individual atoms, including their elements and the molecules they belong to.\n\n2. **Access the `molecule` table (T2)**: This table contains information about molecules, including their labels (such as whether they are carcinogenic).\n\n3. **Join the tables**: Link the `atom` table (T1) and the `molecule` table (T2) using the `molecule_id` field. This ensures that each atom is associated with its corresponding molecule.\n\n4. **Filter for Calcium (Ca)**: From the joined tables, filter the records to include only those where the element in the `atom` table is Calcium (denoted as 'ca').\n\n5. **Retrieve the carcinogenic flag**: From the filtered results, extract the `label` field from the `molecule` table (T2), which indicates whether the molecule is carcinogenic.\n\n6. **Output the result**: The final output will be the `label` (flag_carcinogenic) from the `molecule` table for the compound(s) containing Calcium."
        ]
    },
    "502": {
        "sql": "SELECT s.releaseDate \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Ola de fr\u00edo';",
        "question": "What is the release date for the set \"Ola de fr\u00edo\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.releaseDate FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Ola de fr\u00edo'",
        "explain": "release date is the date of card set being released; set \"Ola de fr\u00edo\" refers to translation = 'Ola de fr\u00edo'",
        "solution": []
    },
    "1103": {
        "sql": "SELECT pa.overall_rating \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Aaron Mooy' \nAND pa.date LIKE '2016-02-04%';",
        "question": "What was the overall rating for Aaron Mooy on 2016/2/4?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-02-04' AND t1.player_name = 'Aaron Mooy'",
        "explain": "Aaron Mooy refers to player_name = 'Aaron Mooy'; on 2016/2/4 refers to date LIKE '2016-02-04%';",
        "solution": []
    },
    "1162": {
        "sql": "SELECT COUNT(*) \nFROM Patient \nWHERE SEX = 'F' \nAND strftime('%Y', Description) = '1997' \nAND Admission = '-';",
        "question": "How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM Patient WHERE STRFTIME('%Y', Description) = '1997' AND SEX = 'F' AND Admission = '-'",
        "explain": "female refers to sex = 'F'; came at the hospital in 1997 refers to year(Description) = '1997'; immediately followed at the outpatient clinic refers to Admission = '-'",
        "solution": []
    },
    "75": {
        "sql": "SELECT T2.EILName AS \"Educational Level Name\", T2.School AS \"School Name\"\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"NSLP Provision Status\" = 'Breakfast Provision 2'\nAND T1.\"County Code\" = '37';",
        "question": "What is the educational level name for the schools with Breakfast Provision 2 in county code 37? Indicate the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.EILName, T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2' AND T1.`County Code` = 37",
        "explain": "",
        "solution": [
            "To find the educational level name and the name of the schools with Breakfast Provision 2 in county code 37, follow these steps:\n\n1. **Join the Tables**: Combine the data from the `frpm` table (referred to as `T1`) and the `schools` table (referred to as `T2`) using the `CDSCode` field as the common key.\n\n2. **Filter by Breakfast Provision**: From the joined data, filter the records where the `NSLP Provision Status` in the `frpm` table is exactly 'Breakfast Provision 2'.\n\n3. **Filter by County Code**: Further filter the results to include only those records where the `County Code` in the `frpm` table is 37.\n\n4. **Select the Required Fields**: From the filtered results, retrieve the `EILName` (educational level name) and `School` (name of the school) fields from the `schools` table.\n\nThe final output will list the educational level names and the corresponding school names that meet the specified criteria."
        ]
    },
    "961": {
        "sql": "SELECT r.name AS race_name, r.year\nFROM results res\nJOIN races r ON res.raceId = r.raceId\nWHERE res.milliseconds IS NOT NULL\nORDER BY res.milliseconds ASC\nLIMIT 1;",
        "question": "Which race has the shortest actual finishing time? Please give the name and year.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN results AS T2 on T1.raceId = T2.raceId WHERE T2.milliseconds IS NOT NULL ORDER BY T2.milliseconds LIMIT 1",
        "explain": "shortest actual finishing time refers to Min(milliseconds) except milliseconds = null;",
        "solution": []
    },
    "774": {
        "sql": "SELECT r.race \nFROM superhero s\nJOIN race r ON s.race_id = r.id\nWHERE s.superhero_name = 'A-Bomb';",
        "question": "Which group does superhero A-Bomb belong to?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'",
        "explain": "group refers to race; A-Bomb refers to superhero_name = 'A-Bomb';",
        "solution": []
    },
    "928": {
        "sql": "SELECT T3.forename, T3.surname, T3.driverRef\nFROM races T1\nJOIN results T2 ON T1.raceId = T2.raceId\nJOIN drivers T3 ON T2.driverId = T3.driverId\nWHERE T1.name = 'Canadian Grand Prix' AND T1.year = 2007 AND T2.rank = 1;",
        "question": "Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T3.forename, T3.surname, T3.driverRef FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Canadian Grand Prix' AND T2.rank = 1 AND T1.year = 2007",
        "explain": "reference name refers to driverRef; Canadian Grand Prix refers to races.name = 'Canadian Grand Prix';",
        "solution": [
            "To find the driver who ranked first in the Canadian Grand Prix in 2007 and retrieve his reference name, follow these steps:\n\n1. **Identify the race**: Locate the race record in the `races` table where the `name` is 'Canadian Grand Prix' and the `year` is 2007. This will give you the specific race ID.\n\n2. **Find the race results**: Using the race ID obtained from the previous step, search the `results` table for the entry where the `rank` is 1 (indicating the first-place finish). This will provide the `driverId` of the winning driver.\n\n3. **Retrieve the driver's details**: With the `driverId` from the results table, query the `drivers` table to fetch the driver's `forename`, `surname`, and `driverRef` (reference name).\n\n4. **Combine the data**: The final output will be the concatenation of the driver's forename, surname, and reference name, representing the first-place driver in the 2007 Canadian Grand Prix.",
            "To determine the driver who ranked first in the Canadian Grand Prix in 2007 and retrieve his reference name, the following steps are executed in the SQL query:\n\n1. **Join the `races` and `results` tables**: The query starts by joining the `races` table (aliased as `T1`) with the `results` table (aliased as `T2`) using the `raceId` column. This links each race to its corresponding results.\n\n2. **Filter for the specific race**: The query filters the joined data to include only the race where the `name` is 'Canadian Grand Prix' and the `year` is 2007. This ensures the focus is on the correct event.\n\n3. **Filter for the first-place result**: The query further filters the results to include only entries where the `rank` is 1, indicating the driver who finished first in the race.\n\n4. **Join with the `drivers` table**: The query then joins the filtered results with the `drivers` table (aliased as `T3`) using the `driverId` column. This links the first-place result to the driver's details.\n\n5. **Select the driver's details**: Finally, the query selects the `forename`, `surname`, and `driverRef` (reference name) columns from the `drivers` table for the identified driver.\n\nThe output of this query will be the forename, surname, and reference name of the driver who ranked first in the 2007 Canadian Grand Prix."
        ]
    },
    "1262": {
        "sql": "SELECT COUNT(DISTINCT p.ID) AS PatientCount\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nJOIN Examination e ON p.ID = e.ID\nWHERE e.\"ANA Pattern\" = 'P' AND l.C3 IS NOT NULL;",
        "question": "How many patients with a normal level of complement 3 have a P pattern observed in the sheet of ANA examination?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C3 > 35 AND T1.`ANA Pattern` = 'P'",
        "explain": "normal level of complement 3 refers to C3 > 35; have a P pattern observed in the sheet of ANA examination refers to ANA Pattern = 'P'; Should compute the number of distinct ones",
        "solution": []
    },
    "119": {
        "sql": "SELECT a.account_id, d.A2 AS district_name, d.A3 AS district_region\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE strftime('%Y', a.date) = '1993' AND a.frequency = 'POPLATEK PO OBRATU';",
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "explain": "Records about district names could be found in A2; A3 contains the information about regions. 'POPLATEK PO OBRATU' stands for issuance after transaction",
        "solution": []
    },
    "681": {
        "sql": "SELECT DISTINCT u.DisplayName\nFROM users u\nJOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.ViewCount > 20000\nAND strftime('%Y', p.CreaionDate) = '2011';",
        "question": "Please list the users' display names whose posts had over 20000 views in 2011.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2011' AND T2.ViewCount > 20000",
        "explain": "had over 20000 views in 2011 refers to ViewCount > 20000 where YEAR(CreationDate) = 2011;",
        "solution": []
    },
    "887": {
        "sql": "SELECT r2017.name\nFROM races r2017\nWHERE r2017.year = 2017\nAND r2017.name NOT IN (\n    SELECT r2000.name\n    FROM races r2000\n    WHERE r2000.year = 2000\n);",
        "question": "Name the races in year 2017 that are not hosted in year 2000.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT name FROM races WHERE year = 2017 AND name NOT IN ( SELECT name FROM races WHERE year = 2000 )",
        "explain": "not hosted means not in;",
        "solution": [
            "To solve the question, we need to identify the names of races that occurred in the year 2017 but were not hosted in the year 2000. The solution involves the following steps:\n\n1. **Retrieve races from 2017**: First, we gather all the race names from the `races` table where the `year` is 2017.\n\n2. **Retrieve races from 2000**: Next, we collect all the race names from the `races` table where the `year` is 2000.\n\n3. **Filter out races from 2000**: Finally, we exclude any race names from the 2017 list that also appear in the 2000 list. The remaining race names are the ones that were hosted in 2017 but not in 2000.\n\nThis ensures we only get the names of races unique to the year 2017 compared to 2000."
        ]
    },
    "484": {
        "sql": "SELECT T1.name AS italian_name\nFROM foreign_data T1\nJOIN cards T2 ON T1.uuid = T2.uuid\nJOIN sets T3 ON T2.setCode = T3.code\nWHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'\nORDER BY T2.convertedManaCost DESC;",
        "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
        "explain": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'; highest converted mana cost refers to MAX(convertedManaCost)",
        "solution": [
            "To list the Italian names of the cards in the set 'Coldsnap' with the highest converted mana cost, follow these steps:\n\n1. **Join the tables**: Combine the `foreign_data` table (aliased as `T1`), the `cards` table (aliased as `T2`), and the `sets` table (aliased as `T3`) based on the following relationships:\n   - Link `T1` and `T2` using the `uuid` field.\n   - Link `T2` and `T3` using the `setCode` field from `T2` and the `code` field from `T3`.\n\n2. **Filter the data**: Apply the following filters:\n   - Ensure the set name in `T3` is 'Coldsnap'.\n   - Ensure the language in `T1` is 'Italian'.\n\n3. **Sort the results**: Order the results by the `convertedManaCost` field from `T2` in descending order to prioritize cards with the highest mana cost.\n\n4. **Select the output**: Retrieve the `name` field from `T2`, which contains the Italian names of the cards.\n\nThis process ensures that the Italian names of the cards in the 'Coldsnap' set are listed, sorted by their converted mana cost from highest to lowest.",
            "To list the Italian names of the cards in the set 'Coldsnap' with the highest converted mana cost, follow these detailed steps:\n\n1. **Join the tables**:\n   - Combine the `foreign_data` table (aliased as `T1`) with the `cards` table (aliased as `T2`) using the `uuid` field to link them. This ensures that the card data is matched with its corresponding foreign language data.\n   - Further join the result with the `sets` table (aliased as `T3`) by linking the `setCode` field from `T2` with the `code` field from `T3`. This connects the card data to its respective set information.\n\n2. **Filter the data**:\n   - Apply a filter to the `sets` table (`T3`) to only include records where the `name` field is 'Coldsnap'. This narrows down the data to the specific set of interest.\n   - Additionally, filter the `foreign_data` table (`T1`) to include only records where the `language` field is 'Italian'. This ensures that only Italian names of the cards are considered.\n\n3. **Sort the results**:\n   - Order the filtered results by the `convertedManaCost` field from the `cards` table (`T2`) in descending order (`DESC`). This prioritizes cards with the highest converted mana cost at the top of the list.\n\n4. **Select the output**:\n   - Retrieve the `name` field from the `cards` table (`T2`), which contains the Italian names of the cards, as the final output.\n\nThis process ensures that the Italian names of the cards in the 'Coldsnap' set are listed, sorted by their converted mana cost from highest to lowest, without altering any information from the original SQL query."
        ]
    },
    "1370": {
        "sql": "SELECT T2.expense_id, T2.expense_description\nFROM member T1\nJOIN expense T2 ON T1.member_id = T2.link_to_member\nWHERE T1.position = 'Vice President';",
        "question": "List all the expenses incurred by the vice president.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.expense_id, T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "explain": "expense refers to expense_description; 'Vice President' is a position of the Student Club",
        "solution": [
            "To list all the expenses incurred by the vice president, perform the following steps:\n\n1. **Identify the Vice President**: First, locate the member in the `member` table (referred to as `T1`) whose position is 'Vice President'.\n\n2. **Retrieve Expenses**: Once the vice president is identified, join the `member` table (`T1`) with the `expense` table (referred to as `T2`) using the `member_id` from `T1` and the `link_to_member` field from `T2`. This ensures that only expenses linked to the vice president are considered.\n\n3. **Select Relevant Data**: From the joined tables, select the `expense_id` and `expense_description` fields from the `expense` table (`T2`). These fields provide the details of each expense incurred by the vice president.\n\n4. **Output the Results**: The final output will be a list of all expenses (identified by `expense_id` and described by `expense_description`) that are linked to the vice president."
        ]
    },
    "1308": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.PLT > 100 AND T2.PLT < 400 \nAND T1.Diagnosis IS NOT NULL;",
        "question": "Among the patients who have a normal platelet level, how many of them have other symptoms observed?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 100 AND T2.PLT < 400 AND T1.Diagnosis IS NOT NULL",
        "explain": "normal platelet level refers to PLT > 100 and PLT < 400; have other symptoms refers to Diagnosis is not null;",
        "solution": [
            "To solve the question, \"Among the patients who have a normal platelet level, how many of them have other symptoms observed?\", the following steps are performed:\n\n1. **Identify Patients with Normal Platelet Levels**: Filter the `Laboratory` table to include only those records where the platelet count (`PLT`) is within the normal range (greater than 100 and less than 400).\n\n2. **Join with Patient Data**: Combine the filtered `Laboratory` records with the `Patient` table using the patient ID (`ID`) to access additional patient information.\n\n3. **Filter Patients with Symptoms**: From the joined data, select only those patients who have a recorded diagnosis (i.e., `Diagnosis` is not `NULL`), indicating that other symptoms were observed.\n\n4. **Count the Patients**: Finally, count the number of patients who meet all the above criteria.\n\nThe SQL query accomplishes this by joining the `Patient` and `Laboratory` tables, applying the necessary filters, and counting the relevant patients.",
            "To solve the question, \"Among the patients who have a normal platelet level, how many of them have other symptoms observed?\", the following detailed steps are performed:\n\n1. **Filter Patients with Normal Platelet Levels**: Query the `Laboratory` table to select records where the platelet count (`PLT`) is within the normal range (greater than 100 and less than 400). This ensures we only consider patients with normal platelet levels.\n\n2. **Join with Patient Data**: Perform an inner join between the filtered `Laboratory` records (aliased as `T2`) and the `Patient` table (aliased as `T1`) using the patient ID (`ID`) as the join key. This combines the laboratory data with patient information.\n\n3. **Filter Patients with Symptoms**: From the joined dataset, filter to include only those patients where the `Diagnosis` field in the `Patient` table is not `NULL`. This indicates that other symptoms were observed for these patients.\n\n4. **Count the Patients**: Finally, count the number of distinct patient IDs (`T1.ID`) that meet all the above criteria. This gives the total number of patients with normal platelet levels and observed symptoms.\n\nThe SQL query achieves this by:\n- Joining the `Patient` (`T1`) and `Laboratory` (`T2`) tables on the `ID` field.\n- Applying the condition `T2.PLT > 100 AND T2.PLT < 400` to filter for normal platelet levels.\n- Adding the condition `T1.Diagnosis IS NOT NULL` to ensure symptoms were observed.\n- Counting the resulting patient IDs."
        ]
    },
    "391": {
        "sql": "SELECT DISTINCT T1.name\nFROM cards T1\nJOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.originalType = 'Artifact' AND T1.colors = 'B';",
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "explain": "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data",
        "solution": [
            "To solve the question, we need to find the names of Artifact cards that are black in color and have foreign language translations. The solution involves the following steps:\n\n1. **Select Distinct Names**: Retrieve the unique names of the cards to avoid duplicates.\n\n2. **Join Tables**: Combine the `cards` table (referred to as `T1`) with the `foreign_data` table (referred to as `T2`) using the `uuid` field as the common key. This ensures we only consider cards that have entries in the `foreign_data` table, indicating they have foreign language translations.\n\n3. **Filter by Card Type**: From the joined tables, filter the results to include only cards where the `originalType` is 'Artifact'.\n\n4. **Filter by Color**: Further refine the results to include only cards where the `colors` field is 'B', indicating the card is black in color.\n\nThe final output will be a list of distinct names of Artifact cards that meet both the color and foreign language translation criteria."
        ]
    },
    "1015": {
        "sql": "WITH FastestLapTimes AS (\n    SELECT \n        r.raceId,\n        r.name AS raceName,\n        c.name AS circuitName,\n        res.fastestLapTime,\n        CAST(SUBSTR(res.fastestLapTime, 1, INSTR(res.fastestLapTime, ':') - 1) AS minutes,\n        CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, ':') + 1, INSTR(res.fastestLapTime, '.') - INSTR(res.fastestLapTime, ':') - 1) AS seconds,\n        CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, '.') + 1) AS milliseconds,\n        (CAST(SUBSTR(res.fastestLapTime, 1, INSTR(res.fastestLapTime, ':') - 1) * 60) +\n         CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, ':') + 1, INSTR(res.fastestLapTime, '.') - INSTR(res.fastestLapTime, ':') - 1)) +\n         (CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, '.') + 1) / 1000) AS totalSeconds\n    FROM \n        races r\n    JOIN \n        circuits c ON r.circuitId = c.circuitId\n    JOIN \n        results res ON r.raceId = res.raceId\n    WHERE \n        r.name = 'Austrian Grand Prix'\n        AND res.fastestLapTime IS NOT NULL\n)\nSELECT \n    raceName\nFROM \n    FastestLapTimes\nWHERE \n    totalSeconds = (SELECT MIN(totalSeconds) FROM FastestLapTimes);",
        "question": "In which Formula_1 race was the lap record for the Austrian Grand Prix Circuit set?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T2.name FROM races AS T2 INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN results AS T1 on T2.raceId = T1.raceId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix'",
        "explain": "lap record means the fastest time recorded which refers to time",
        "solution": [
            "To determine the Formula 1 race where the lap record for the Austrian Grand Prix Circuit was set, follow these steps:\n\n1. **Extract Fastest Lap Times**:\n   - Retrieve all race results where the fastest lap time (`FastestLapTime`) is recorded.\n   - Convert each `FastestLapTime` into seconds for easier comparison. The conversion involves:\n     - Extracting the minutes (part before the colon `:`), converting to seconds by multiplying by 60.\n     - Extracting the seconds (part between the colon `:` and the dot `.`).\n     - Extracting the milliseconds (part after the dot `.`), converting to seconds by dividing by 1000.\n     - Summing these values to get the total time in seconds.\n\n2. **Identify the Fastest Lap for Austrian Grand Prix**:\n   - From the extracted fastest lap times, find the minimum time in seconds for races named 'Austrian Grand Prix'.\n\n3. **Match the Fastest Lap to the Race**:\n   - Join the `races` table with the `circuits` table to ensure the race is held at the Austrian Grand Prix Circuit.\n   - Join the `results` table to get the fastest lap times for each race.\n   - Filter the results to only include races named 'Austrian Grand Prix'.\n   - Compare the converted fastest lap times in seconds to the identified minimum time to find the matching race.\n\n4. **Retrieve the Race Name**:\n   - The name of the race where the fastest lap time matches the minimum time for the Austrian Grand Prix is the answer.",
            "To determine the Formula 1 race where the lap record for the Austrian Grand Prix Circuit was set, follow these detailed steps:\n\n1. **Extract Fastest Lap Times**:\n   - Retrieve all race results where the fastest lap time (`FastestLapTime`) is recorded.\n   - For each `FastestLapTime`, convert it into seconds for comparison:\n     - Extract the minutes (part before the colon `:`), convert to seconds by multiplying by 60.\n     - Extract the seconds (part between the colon `:` and the dot `.`).\n     - Extract the milliseconds (part after the dot `.`), convert to seconds by dividing by 1000.\n     - Sum these values to get the total time in seconds.\n\n2. **Identify the Fastest Lap for Austrian Grand Prix**:\n   - From the extracted fastest lap times, find the minimum time in seconds for races named 'Austrian Grand Prix'.\n\n3. **Match the Fastest Lap to the Race**:\n   - Join the `races` table with the `circuits` table to ensure the race is held at the Austrian Grand Prix Circuit.\n   - Join the `results` table to get the fastest lap times for each race.\n   - Filter the results to only include races named 'Austrian Grand Prix'.\n   - Compare the converted fastest lap times in seconds to the identified minimum time to find the matching race.\n\n4. **Retrieve the Race Name**:\n   - The name of the race where the fastest lap time matches the minimum time for the Austrian Grand Prix is the answer.\n\nThis process ensures that the correct race is identified by accurately converting and comparing lap times, and verifying the race location and name."
        ]
    },
    "651": {
        "sql": "SELECT p2.Title AS RelatedPostTitle\nFROM posts p1\nJOIN postLinks pl ON p1.Id = pl.PostId\nJOIN posts p2 ON pl.RelatedPostId = p2.Id\nWHERE p1.Title = 'How to tell if something happened in a data set which monitors a value over time';",
        "question": "Provide the related post title of \"How to tell if something happened in a data set which monitors a value over time\".",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T3.Title FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN posts AS T3 ON T1.RelatedPostId = T3.Id WHERE T2.Title = 'How to tell if something happened in a data set which monitors a value over time'",
        "explain": "",
        "solution": []
    },
    "331": {
        "sql": "SELECT COUNT(*) FROM molecule WHERE label = '+';",
        "question": "How many of the molecules are carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
        "explain": "label = '+' mean molecules are carcinogenic;",
        "solution": []
    },
    "769": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'Dark Horse Comics'\nAND a.attribute_name = 'Durability'\nORDER BY ha.attribute_value DESC\nLIMIT 1;",
        "question": "Which superhero has the most durability published by Dark Horse Comics?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
        "explain": "which superhero refers to superhero_name; most durability refers to MAX(attribute_value) WHERE attribute_name = 'durability'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "solution": [
            "To find the superhero with the most durability published by Dark Horse Comics, follow these steps:\n\n1. **Identify the superhero table (T1)**: This table contains information about superheroes, including their names and publisher IDs.\n\n2. **Join with the hero_attribute table (T2)**: This table links superheroes to their attributes (like durability) and contains the attribute values.\n\n3. **Join with the attribute table (T3)**: This table defines the attributes, such as 'Durability'.\n\n4. **Join with the publisher table (T4)**: This table contains publisher information, including the name 'Dark Horse Comics'.\n\n5. **Filter the data**:\n   - Ensure the publisher is 'Dark Horse Comics'.\n   - Ensure the attribute is 'Durability'.\n\n6. **Sort the results**: Order the superheroes by their durability attribute value in descending order to find the highest value.\n\n7. **Limit the results**: Return only the top result (the superhero with the highest durability).\n\nThe final output will be the name of the superhero from the superhero table (T1) who meets all these criteria."
        ]
    },
    "288": {
        "sql": "SELECT m.label \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE a.atom_id = 'TR001_1';",
        "question": "Identify whether the molecule that contains atom TR001_1 is carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_1'",
        "explain": "label = '+' mean molecules are carcinogenic;",
        "solution": []
    },
    "1159": {
        "sql": "SELECT p.ID, p.SEX, p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.ALB < 3.5;",
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
        "explain": "albumin level lower than 3.5 refers to ALB < 3.5;",
        "solution": []
    },
    "834": {
        "sql": "SELECT \n    (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nJOIN \n    gender g ON s.gender_id = g.id\nWHERE \n    p.publisher_name = 'George Lucas';",
        "question": "Among all superheroes created by George Lucas, identify the percentage of female superheroes.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas'",
        "explain": "created by George Lucas refers to publisher_name = 'George Lucas'; percentage = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'George Lucas'), COUNT(publisher_name = 'George Lucas')), 100.0); female refers to gender = 'Female';",
        "solution": []
    },
    "632": {
        "sql": "SELECT COUNT(*) AS VoteCount\nFROM votes v\nJOIN postHistory ph ON v.PostId = ph.PostId\nJOIN users u ON ph.UserId = u.Id\nWHERE u.DisplayName = 'Harlan';",
        "question": "How many votes were made by Harlan?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId WHERE T1.DisplayName = 'Harlan'",
        "explain": "DisplayName = 'Harlan';",
        "solution": [
            "To determine how many votes were made by Harlan, follow these steps:\n\n1. **Identify the user named Harlan**:\n   - Access the `users` table (referred to as `T1` in the SQL).\n   - Locate the record where the `DisplayName` column equals 'Harlan'.\n   - Retrieve the `Id` of this user.\n\n2. **Find posts associated with Harlan**:\n   - Access the `postHistory` table (referred to as `T2` in the SQL).\n   - Join this table with the `users` table (`T1`) using the `UserId` column in `postHistory` and the `Id` column in `users`.\n   - Filter the results to include only posts where the `UserId` matches Harlan's `Id`.\n\n3. **Count the votes on Harlan's posts**:\n   - Access the `votes` table (referred to as `T3` in the SQL).\n   - Join this table with the `postHistory` table (`T2`) using the `PostId` column in both tables.\n   - Count the number of records in the `votes` table that correspond to Harlan's posts.\n\n4. **Return the total count of votes**:\n   - The final result is the count of votes made on posts associated with Harlan."
        ]
    },
    "1375": {
        "sql": "SELECT m.first_name, m.last_name\nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.department = 'School of Applied Sciences, Technology and Education';",
        "question": "List all the members of the \"School of Applied Sciences, Technology and Education\" department.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'",
        "explain": "list all members means to list all the full name; full name refers to first_name, last_name;",
        "solution": []
    },
    "1433": {
        "sql": "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL;",
        "question": "Which countries have zip codes with post office boxes?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL",
        "explain": "zip codes that have post office boxes refers to type = 'PO Box'",
        "solution": [
            "To find the countries that have zip codes with post office boxes, follow these steps:\n\n1. **Filter the Data**: From the `zip_code` table, select only the rows where the `type` column is equal to 'PO Box' and the `county` column is not null. This ensures that we only consider valid entries for post office boxes.\n\n2. **Remove Duplicates**: Apply the `DISTINCT` keyword to the `county` column to eliminate any duplicate country names, ensuring each country is listed only once in the results.\n\n3. **Retrieve the Results**: The final output will be a list of unique country names that meet the specified criteria."
        ]
    },
    "665": {
        "sql": "SELECT COUNT(T1.Id) / 12.0 AS average_monthly_links\nFROM postLinks T1\nJOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.AnswerCount <= 2\nAND STRFTIME('%Y', T1.CreationDate) = '2010';",
        "question": "What is the average monthly number of links created in 2010 for posts that have no more than 2 answers?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / 12 FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.AnswerCount <= 2 AND STRFTIME('%Y', T1.CreationDate) = '2010'",
        "explain": "calculation = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2010 and AnswerCount < = 2), 12)",
        "solution": [
            "To find the average monthly number of links created in 2010 for posts that have no more than 2 answers, follow these steps:\n\n1. **Join the Tables**: Combine the `postLinks` table (referred to as T1) with the `posts` table (referred to as T2) using the `PostId` from T1 and the `Id` from T2. This ensures that each link is associated with its corresponding post.\n\n2. **Filter the Data**:\n   - Ensure that the posts have no more than 2 answers by checking the `AnswerCount` column in the `posts` table (T2). Only include posts where `AnswerCount` is less than or equal to 2.\n   - Filter the links to include only those created in the year 2010 by checking the `CreationDate` column in the `postLinks` table (T1). Use the `STRFTIME` function to extract the year from the date and compare it to '2010'.\n\n3. **Count the Links**: Count the number of links (using the `Id` column from T1) that meet the above criteria.\n\n4. **Calculate the Average**: Divide the total count of links by 12 to get the average monthly number of links for the year 2010.\n\n5. **Output the Result**: The result is a single value representing the average monthly number of links created in 2010 for posts with no more than 2 answers."
        ]
    },
    "520": {
        "sql": "SELECT T1.artist, T2.format\nFROM cards T1\nJOIN legalities T2 ON T1.uuid = T2.uuid\nGROUP BY T1.artist\nORDER BY COUNT(T1.id) ASC\nLIMIT 1;",
        "question": "Who is the illustrator that illustrated the least amount of cards? List the format of play of the cards that he/she illustrated.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.artist, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid GROUP BY T1.artist ORDER BY COUNT(T1.id) ASC LIMIT 1",
        "explain": "format of the cards refers to format; illustrator refers to artist; the least amount of cards refers to MIN(artist)",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Join the Tables**: The `cards` table (referred to as `T1`) is joined with the `legalities` table (referred to as `T2`) using the `uuid` column as the common key. This ensures that each card's artist information is linked to its corresponding format of play.\n\n2. **Group by Artist**: The joined data is grouped by the `artist` column from the `cards` table (`T1.artist`). This groups all cards illustrated by the same artist together.\n\n3. **Count Cards per Artist**: For each artist, the number of cards they illustrated is counted using `COUNT(T1.id)`. This gives the total number of cards each artist has worked on.\n\n4. **Order by Card Count**: The results are ordered in ascending order based on the count of cards (`COUNT(T1.id) ASC`). This ensures that the artist with the least number of illustrated cards appears first in the list.\n\n5. **Limit Results**: The `LIMIT 1` clause restricts the output to only the top result, which is the artist with the least number of illustrated cards.\n\n6. **Select Columns**: The final output includes the `artist` column from the `cards` table (`T1.artist`) and the `format` column from the `legalities` table (`T2.format`). This provides the name of the artist and the format of play for the cards they illustrated.\n\nThe SQL query effectively identifies the illustrator with the fewest illustrated cards and lists the format of play for those cards."
        ]
    },
    "1518": {
        "sql": "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-24' AND t.Time = '12:42:00';",
        "question": "For the deal happened at 2012/8/24 12:42:00, which country was it?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Time = '12:42:00'",
        "explain": "'2012/8/24 12:42:00' can refer to date = '2012-08-24' AND T1.time = '12:42:00' in the database",
        "solution": []
    },
    "619": {
        "sql": "SELECT COUNT(DISTINCT u.Id) AS AdultSupporters\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE u.Age BETWEEN 19 AND 65\nAND b.Name = 'Supporter';",
        "question": "How many adults who obtained the badge Supporter?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Supporter' AND T1.Age BETWEEN 19 AND 65",
        "explain": "Supporter is the Name of badge; adult refers to Age BETWEEN 19 AND 65",
        "solution": []
    },
    "741": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nGROUP BY s.superhero_name\nORDER BY COUNT(hp.power_id) DESC\nLIMIT 1;",
        "question": "What is the name of the superhero that has the most powers?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "explain": "name of the superhero refers to superhero_name; superhero that has the most powers refers to MAX(COUNT(superhero_name))",
        "solution": []
    },
    "33": {
        "sql": "SELECT T2.Website, T1.`School Name`\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000\nAND T2.Website IS NOT NULL;",
        "question": "If there are any, what are the websites address of the schools with a free meal count of 1,900-2,000 to students aged 5-17? Include the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Website, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000 AND T2.Website IS NOT NULL",
        "explain": "",
        "solution": [
            "To find the websites and names of schools where the free meal count for students aged 5-17 is between 1,900 and 2,000, follow these steps:\n\n1. **Join the Tables**: Combine the data from the `frpm` table (referred to as T1) and the `schools` table (referred to as T2) using the `CDSCode` field as the common key.\n\n2. **Filter the Data**: From the joined tables, filter the records where the `Free Meal Count (Ages 5-17)` in the `frpm` table (T1) is between 1,900 and 2,000.\n\n3. **Exclude Null Websites**: Ensure that only records with a non-null `Website` field in the `schools` table (T2) are included.\n\n4. **Select the Required Fields**: Retrieve the `Website` field from the `schools` table (T2) and the `School Name` field from the `frpm` table (T1) for the filtered records.\n\nThe result will be a list of school names and their corresponding website addresses that meet the specified criteria."
        ]
    },
    "799": {
        "sql": "SELECT COUNT(*) FROM superhero WHERE publisher_id IS NULL;",
        "question": "How many superheroes didn't have any publisher?",
        "db_id": "superhero",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.id = 1",
        "explain": "didn't have any publisher refers to publisher.id = 1;",
        "solution": [
            "To find out how many superheroes didn't have any publisher, the database performs the following operations:\n\n1. **Join Tables**: It joins the `superhero` table (referred to as `T1`) with the `publisher` table (referred to as `T2`) using the condition `T1.publisher_id = T2.id`. This links each superhero to their respective publisher.\n\n2. **Filter Records**: It filters the joined records to only include those where the publisher's `id` is `1`. This condition (`T2.id = 1`) specifies that we are looking for superheroes associated with the publisher whose `id` is `1`.\n\n3. **Count Records**: It counts the number of superhero records (`T1.id`) that meet the above condition. The result is the count of superheroes who are associated with the publisher having `id` `1`.\n\nThis SQL query essentially counts the number of superheroes linked to a specific publisher (with `id` `1`), which answers the question of how many superheroes didn't have any publisher if `id` `1` represents a null or default publisher.",
            "To determine how many superheroes didn't have any publisher, the database executes the following steps:\n\n1. **Join Tables**: The `superhero` table (referred to as `T1`) is joined with the `publisher` table (referred to as `T2`) using the condition `T1.publisher_id = T2.id`. This operation links each superhero to their respective publisher based on the `publisher_id` field in the `superhero` table and the `id` field in the `publisher` table.\n\n2. **Filter Records**: The joined records are filtered to include only those where the publisher's `id` is `1`. This condition (`T2.id = 1`) specifies that the query is looking for superheroes associated with the publisher whose `id` is `1`.\n\n3. **Count Records**: The query counts the number of superhero records (`T1.id`) that satisfy the above condition. The result is the count of superheroes linked to the publisher with `id` `1`.\n\nThis SQL query counts the number of superheroes associated with the publisher whose `id` is `1`, which answers the question of how many superheroes didn't have any publisher if `id` `1` represents a null or default publisher."
        ]
    },
    "341": {
        "sql": "SELECT id FROM cards WHERE borderColor = 'borderless' AND cardKingdomId IS NULL;",
        "question": "What are the borderless cards available without powerful foils?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)",
        "explain": "borderless' refers to borderColor; poweful foils refers to cardKingdomFoilId paired with cardKingdomId AND cardKingdomId is not null",
        "solution": [
            "To find the borderless cards available without powerful foils, the database performs the following operations:\n\n1. **Selects** the `id` column from the `cards` table.\n2. **Filters** the records to only include cards where the `borderColor` is 'borderless'.\n3. **Further filters** these records to exclude any cards that have a `cardKingdomId` (i.e., where `cardKingdomId` is NULL).\n\nThis ensures that only borderless cards without powerful foils (indicated by the absence of a `cardKingdomId`) are returned."
        ]
    },
    "1220": {
        "sql": "SELECT p.ID, p.SEX, p.Birthday\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.UN = 29;",
        "question": "Provide all ID, sex and birthday of patients whose urea nitrogen (UN) just within the borderline of passing?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN = 29",
        "explain": "urea nitrogen (UN) just within the borderline of passing refers to UN = 29; ",
        "solution": []
    },
    "1275": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) AS MalePatientsWithNormalLevels\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.CENTROMEA = 'negative' OR T2.CENTROMEA = '0')\n  AND (T2.SSB = 'negative' OR T2.SSB = '0')\n  AND T1.SEX = 'M';",
        "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
        "explain": "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;",
        "solution": [
            "To solve the question, we need to count the number of distinct male patients who have normal levels of both anti-centromere and anti-SSB. Here are the steps:\n\n1. **Identify the Tables**: The query involves two tables:\n   - `Patient` (aliased as `T1`), which contains patient information including their ID and sex.\n   - `Laboratory` (aliased as `T2`), which contains laboratory test results including anti-centromere (`CENTROMEA`) and anti-SSB (`SSB`) levels.\n\n2. **Join the Tables**: The tables are joined on the `ID` field to link patient information with their laboratory results.\n\n3. **Filter Conditions**: The query filters for patients where:\n   - The anti-centromere level (`CENTROMEA`) is either 'negative' or '0' (indicating a normal level).\n   - The anti-SSB level (`SSB`) is either 'negative' or '0' (indicating a normal level).\n   - The patient's sex (`SEX`) is 'M' (male).\n\n4. **Count Distinct Patients**: The query counts the distinct `ID` values from the `Patient` table that meet all the above conditions, ensuring each patient is only counted once even if they have multiple matching records.\n\nThe final result is the count of unique male patients with normal levels of both anti-centromere and anti-SSB."
        ]
    },
    "86": {
        "sql": "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040';",
        "question": "What is the administrator's last name that oversees the school with Charter number 40? Indicate the district, the county where the school is situated, and the name of the school.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'",
        "explain": "",
        "solution": [
            "To find the administrator's last name that oversees the school with Charter number 40, along with the district, county, and the name of the school, follow these steps:\n\n1. **Access the database table named `schools`.**\n2. **Filter the records** to only include the school where the `CharterNum` is equal to '0040'.\n3. **Retrieve the following fields** from the filtered record:\n   - `AdmLName1`: The administrator's last name.\n   - `District`: The district where the school is located.\n   - `County`: The county where the school is situated.\n   - `School`: The name of the school.\n\nThis operation will return the required information for the school with Charter number 40."
        ]
    },
    "24": {
        "sql": "SELECT f.\"School Name\"\nFROM frpm f\nJOIN satscores s ON f.CDSCode = s.cds\nWHERE f.\"Percent (%) Eligible Free (K-12)\" > 0.1 AND s.NumGE1500 >= 1;",
        "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.`School Name` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(T2.`Free Meal Count (K-12)` AS REAL) / T2.`Enrollment (K-12)` > 0.1 AND T1.NumGE1500 > 0",
        "explain": "Percent eligible for free meals = Free Meal Count (K-12) / Total (Enrollment (K-12)",
        "solution": []
    },
    "660": {
        "sql": "SELECT OwnerUserId FROM posts WHERE Score = (SELECT MAX(Score) FROM posts);",
        "question": "What is the owner user id of the most valuable post?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT OwnerUserId FROM posts WHERE FavoriteCount = ( SELECT MAX(FavoriteCount) FROM posts )",
        "explain": "the most valuable post refers to MAX(FavoriteCount);",
        "solution": []
    },
    "250": {
        "sql": "SELECT m.molecule_id\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE m.label = '+' AND b.bond_type = '='\nGROUP BY m.molecule_id\nORDER BY COUNT(b.bond_id) DESC\nLIMIT 1;",
        "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
        "explain": "label = '+' mean molecules are carcinogenic; double bond refers to bond_type = ' = ';",
        "solution": [
            "To find the carcinogenic molecule with the most double bonds, follow these steps:\n\n1. **Filter Carcinogenic Molecules**: Identify all molecules labeled as carcinogenic (denoted by the label '+').\n\n2. **Count Double Bonds**: For each carcinogenic molecule, count the number of double bonds (denoted by the bond type '=').\n\n3. **Sort by Bond Count**: Arrange the molecules in descending order based on the count of double bonds.\n\n4. **Select the Top Molecule**: Retrieve the molecule with the highest count of double bonds.\n\nThe final result will be the molecule ID of the carcinogenic molecule with the most double bonds."
        ]
    },
    "940": {
        "sql": "WITH chinese_gp_2008 AS (\n    SELECT raceId\n    FROM races\n    WHERE year = 2008 AND name = 'Chinese Grand Prix'\n),\nfinished_drivers AS (\n    SELECT driverId\n    FROM results\n    WHERE raceId = (SELECT raceId FROM chinese_gp_2008) AND time IS NOT NULL\n),\nparticipated_drivers AS (\n    SELECT r.driverId\n    FROM results r\n    JOIN finished_drivers fd ON r.driverId = fd.driverId\n    WHERE r.raceId != (SELECT raceId FROM chinese_gp_2008)\n    GROUP BY r.driverId\n    HAVING COUNT(r.raceId) > 0\n)\nSELECT COUNT(*) AS num_drivers\nFROM participated_drivers;",
        "question": "Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )",
        "explain": "COUNT(raceID) > 0 reveals that this driver participated in races; drivers who finished the race refers to time has value.",
        "solution": []
    },
    "935": {
        "sql": "SELECT COUNT(DISTINCT driverId) \nFROM results \nWHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') \nAND time IS NOT NULL;",
        "question": "How many drivers managed to finish the race in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Australian Grand Prix' AND T1.year = 2008 AND T2.time IS NOT NULL",
        "explain": "managed to finish the race refers to time is not null",
        "solution": []
    },
    "948": {
        "sql": "SELECT MAX(cs.points) AS max_points\nFROM constructors c\nJOIN constructorStandings cs ON c.constructorId = cs.constructorId\nWHERE c.nationality = 'British';",
        "question": "What are the maximum points of British constructors?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT MAX(T1.points) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T2.nationality = 'British'",
        "explain": "maximum points = MAX(points); British is a nationality",
        "solution": []
    },
    "1458": {
        "sql": "WITH total_members AS (\n    SELECT COUNT(*) AS total FROM member\n),\nnew_jersey_members AS (\n    SELECT COUNT(*) AS nj_count\n    FROM member\n    JOIN zip_code ON member.zip = zip_code.zip_code\n    WHERE zip_code.short_state = 'NJ'\n),\nvermont_members AS (\n    SELECT COUNT(*) AS vt_count\n    FROM member\n    JOIN zip_code ON member.zip = zip_code.zip_code\n    WHERE zip_code.short_state = 'VT'\n)\nSELECT \n    ((nj_count * 100.0 / total) - (vt_count * 100.0 / total)) AS percentage_difference\nFROM total_members, new_jersey_members, vermont_members;",
        "question": "Calculate the difference in the percentage of members in New Jersey and Vermont.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.member_id) AS diff FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip",
        "explain": "SUBTRACT( DIVIDE( SUM(state = 'New Jersey'), COUNT(position = 'Member')), DIVIDE( SUM(state = 'Vermont'), COUNT(position = 'Member')) )",
        "solution": []
    },
    "151": {
        "sql": "SELECT DISTINCT d.A2 AS district_name\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE t.type = 'VYDAJ';",
        "question": "Please list the name of the districts with accounts that made withdrawal transactions.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ'",
        "explain": "A2 refers to district name; type = 'VYDAJ' stands for withdrawal transactions",
        "solution": []
    },
    "44": {
        "sql": "SELECT s.AvgScrWrite, sc.City\nFROM satscores s\nJOIN schools sc ON s.cds = sc.CDSCode\nWHERE s.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);",
        "question": "What is the average writing score of the school who has the highest number of test takers whose total SAT sscores are greater or equal to 1500? Indicate the city to where the school is situated.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.AvgScrWrite, T2.City FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "explain": "",
        "solution": []
    },
    "1250": {
        "sql": "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.\"U-PRO\" > 0 AND L.\"U-PRO\" < 30 AND P.Diagnosis = 'SLE';",
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "explain": "normal proteinuria level refers to 0 < `U-PRO` < 30; diagnosed with SLE refers to Diagnosis = 'SLE';",
        "solution": []
    },
    "951": {
        "sql": "SELECT COUNT(DISTINCT T2.constructorId) AS japanese_constructors_with_zero_points_in_two_races\nFROM constructorStandings T1\nJOIN constructors T2 ON T1.constructorId = T2.constructorId\nWHERE T2.nationality = 'Japanese' AND T1.points = 0\nGROUP BY T2.constructorId\nHAVING COUNT(T1.raceId) = 2;",
        "question": "How many Japanese constructors have 0 points in 2 races?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.raceId) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T2.nationality = 'Japanese' GROUP BY T1.constructorId HAVING COUNT(raceId) = 2",
        "explain": "2 races refers to COUNT(raceID) = 2; Japanese refers to constructors.nationality = 'Japanese';",
        "solution": [
            "To solve the question \"How many Japanese constructors have 0 points in 2 races?\", follow these steps:\n\n1. **Join the Tables**: Combine the `constructorStandings` table (aliased as `T1`) with the `constructors` table (aliased as `T2`) using the `constructorId` field. This links the standings data with the constructor details.\n\n2. **Filter by Nationality and Points**: From the joined tables, filter the records to include only those where the constructor's nationality is 'Japanese' (`T2.nationality = 'Japanese'`) and the points in the standings are 0 (`T1.points = 0`).\n\n3. **Group by Constructor**: Group the filtered records by the `constructorId` to aggregate the data for each constructor.\n\n4. **Count Races per Constructor**: For each constructor, count the number of races where they have 0 points.\n\n5. **Filter by Race Count**: Further filter the grouped data to include only those constructors who have exactly 2 races with 0 points (`HAVING COUNT(raceId) = 2`).\n\n6. **Count the Constructors**: Finally, count the number of constructors that meet all the above criteria.\n\nThis process ensures that you accurately identify and count Japanese constructors with 0 points in exactly 2 races.",
            "To solve the question \"How many Japanese constructors have 0 points in 2 races?\", follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `constructorStandings` table (aliased as `T1`) and the `constructors` table (aliased as `T2`) using the `constructorId` field. This ensures that each record in `constructorStandings` is linked to its corresponding constructor details in the `constructors` table.\n\n2. **Filter by Nationality and Points**: Apply a filter to the joined tables to include only records where:\n   - The constructor's nationality is 'Japanese' (`T2.nationality = 'Japanese'`).\n   - The points in the standings are 0 (`T1.points = 0`).\n\n3. **Group by Constructor**: Group the filtered records by the `constructorId` field. This step aggregates the data for each unique constructor.\n\n4. **Count Races per Constructor**: For each constructor in the grouped data, count the number of races where they have 0 points. This is done using the `COUNT(T1.raceId)` function.\n\n5. **Filter by Race Count**: Further refine the grouped data to include only those constructors who have exactly 2 races with 0 points. This is achieved with the `HAVING COUNT(raceId) = 2` clause.\n\n6. **Count the Constructors**: Finally, count the number of constructors that meet all the specified criteria. The result of this count answers the original question.\n\nThis step-by-step process ensures that the query accurately identifies and counts Japanese constructors with 0 points in exactly 2 races."
        ]
    },
    "1445": {
        "sql": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large';",
        "question": "Find the full name of members whose t-shirt size is extra large.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large'",
        "explain": "full name refers to first_name, last_name; t_shirt_size = 'X-Large'",
        "solution": [
            "To find the full name of members whose t-shirt size is extra large, you need to retrieve the first name and last name from the 'member' table where the 't_shirt_size' column is equal to 'X-Large'."
        ]
    },
    "1048": {
        "sql": "SELECT pa.overall_rating\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Gabriel Tamas' AND strftime('%Y', pa.date) = '2011';",
        "question": "What is the overall rating of the football player Gabriel Tamas in year 2011?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Gabriel Tamas' AND strftime('%Y', t2.date) = '2011'",
        "explain": "in year 2011 refers to strftime('%Y', date) = '2011';",
        "solution": []
    },
    "1126": {
        "sql": "SELECT DISTINCT p.player_name\nFROM Player p\nJOIN Match m ON p.player_api_id = m.home_player_1\nJOIN Country c ON m.country_id = c.id\nWHERE c.name = 'Belgium';",
        "question": "State the name of players who came from Belgium.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Belgium'",
        "explain": "name of players refers to player_name; Belgium is name of country",
        "solution": [
            "To find the names of players who came from Belgium, follow these steps:\n\n1. **Identify the Country**: Start by locating the country 'Belgium' in the `Country` table. This table contains information about countries, including their unique identifiers (`id`) and names (`name`).\n\n2. **Link to Matches**: Use the `id` of Belgium from the `Country` table to find all matches associated with Belgium in the `Match` table. This is done by matching the `country_id` in the `Match` table with the `id` of Belgium.\n\n3. **Identify Players**: For each match found, identify the player who was the first home player (`home_player_1`) in the match. This player's unique identifier (`player_api_id`) is linked to the `Player` table.\n\n4. **Retrieve Player Names**: Finally, retrieve the names of these players from the `Player` table using their `player_api_id`.\n\nThe result will be a list of player names who came from Belgium."
        ]
    },
    "1289": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SJS' AND T2.TP > 6.0 AND T2.TP < 8.5",
        "question": "For the patients who are diagnosed with SJS, how many of them have a normal level of total protein?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SJS' AND T2.TP > 6.0 AND T2.TP < 8.5",
        "explain": "diagnosed with SJS refers to Diagnosis = 'SJS'; normal level of total protein refers to TP > 6.0 and TP < 8.5;",
        "solution": [
            "To solve the question, 'For the patients who are diagnosed with SJS, how many of them have a normal level of total protein?', the following steps are performed:\n\n1. **Identify Patients with SJS Diagnosis**: First, filter the `Patient` table to include only those patients whose `Diagnosis` is 'SJS'.\n\n2. **Join with Laboratory Data**: Next, join the filtered `Patient` table with the `Laboratory` table using the `ID` field to access the laboratory results for these patients.\n\n3. **Filter for Normal Total Protein Levels**: From the joined data, further filter the records to include only those where the `TP` (Total Protein) value is greater than 6.0 and less than 8.5, which indicates a normal level.\n\n4. **Count the Patients**: Finally, count the number of patients who meet all the above criteria.\n\nThe SQL query accomplishes this by selecting the count of `ID` from the joined tables where the conditions are met.",
            "To solve the question, 'For the patients who are diagnosed with SJS, how many of them have a normal level of total protein?', the following detailed steps are performed:\n\n1. **Filter Patients by Diagnosis**: The `Patient` table is queried to select only those records where the `Diagnosis` column has the value 'SJS'. This isolates the patients diagnosed with SJS.\n\n2. **Join with Laboratory Data**: The filtered `Patient` table is then joined with the `Laboratory` table using the `ID` column as the join key. This ensures that each patient's laboratory results are linked to their respective records.\n\n3. **Filter for Normal Total Protein Levels**: From the joined dataset, only the records where the `TP` (Total Protein) value falls within the normal range (greater than 6.0 and less than 8.5) are retained. This step ensures that only patients with normal total protein levels are considered.\n\n4. **Count the Eligible Patients**: The final step involves counting the number of unique patient `ID`s from the filtered and joined dataset. This count represents the number of SJS-diagnosed patients with normal total protein levels.\n\nThe SQL query `SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SJS' AND T2.TP > 6.0 AND T2.TP < 8.5` precisely executes these operations to arrive at the answer."
        ]
    },
    "1202": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.SEX = 'M'\nAND E.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31'\nAND E.Diagnosis = 'Behcet'\nAND P.Admission = '-';",
        "question": "How many male patients who underwent testing between 1995 and 1997 and were subsequently diagnosed with Behcet disease did not stay in the hospital for treatment?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'Behcet' AND T1.SEX = 'M' AND STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1995' AND '1997' AND T1.Admission = '-'",
        "explain": "male refers to SEX = 'M'; underwent testing between 1995 and 1997 refers to `Examination Date` between '1995' and '1997'; Behcet refers to diagnosis; did not stay in the hospital refers to Admission = '-'",
        "solution": []
    },
    "433": {
        "sql": "SELECT (COUNT(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM sets T1\nJOIN set_translations T2 ON T1.code = T2.setCode;",
        "question": "What is the percentage of the set of cards that have Chinese Simplified as the language and are only available for online games?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode",
        "explain": "are only available for online games refers to isOnlineOnly = 1; percentage = DIVIDE(COUNT(isOnlineOnly = 1),COUNT(isOnlineOnly))*100",
        "solution": [
            "To determine the percentage of the set of cards that have Chinese Simplified as the language and are only available for online games, follow these steps:\n\n1. **Join the Tables**: Combine the `sets` table (referred to as T1) with the `set_translations` table (referred to as T2) using the `code` column from T1 and the `setCode` column from T2. This links each set to its translations.\n\n2. **Filter the Data**: For each row in the joined tables, check if the `language` column in T2 is 'Chinese Simplified' and if the `isOnlineOnly` column in T1 is 1 (indicating the set is only available for online games).\n\n3. **Count Matching Rows**: Count how many rows meet both conditions (Chinese Simplified language and online-only availability).\n\n4. **Calculate the Percentage**: Divide the count of matching rows by the total number of rows in the joined tables, then multiply by 100 to convert the result into a percentage.\n\n5. **Cast to Real**: Ensure the division is performed as a real number (floating-point) to get an accurate percentage.\n\nThe final result is the percentage of sets that meet both criteria."
        ]
    },
    "571": {
        "sql": "SELECT CAST(COUNT(DISTINCT posts.Id) AS REAL) / COUNT(DISTINCT votes.Id) AS posts_to_votes_ratio\nFROM votes\nJOIN posts ON votes.UserId = posts.OwnerUserId\nWHERE votes.UserId = 24;",
        "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
        "explain": "user no. 24 refers to UserId = OwnerUserId = '24'; times of his/her post than votes = Divide (Count(post.Id), Count(votes.Id))",
        "solution": [
            "To solve the question, we need to compare the number of posts made by user No. 24 to the number of votes they have received. The SQL query calculates this by dividing the count of posts (T2.Id) by the count of distinct votes (T1.Id) for the user with UserId 24. Here's the step-by-step breakdown:\n\n1. **Join the Tables**: Combine the `votes` table (T1) and the `posts` table (T2) where the `UserId` in the `votes` table matches the `OwnerUserId` in the `posts` table.\n2. **Filter for User No. 24**: Only include records where the `UserId` in the `votes` table is 24.\n3. **Count Posts**: Count the number of posts (T2.Id) made by user No. 24.\n4. **Count Distinct Votes**: Count the distinct number of votes (T1.Id) received by user No. 24.\n5. **Calculate the Ratio**: Divide the count of posts by the count of distinct votes to get the comparison ratio.\n\nThe result will show how many times the number of posts is compared to the number of votes for user No. 24.",
            "To solve the question, we need to compare the number of posts made by user No. 24 to the number of votes they have received. The SQL query calculates this by dividing the count of posts by the count of distinct votes for the user with UserId 24. Here's the detailed step-by-step breakdown:\n\n1. **Join the Tables**: Combine the `votes` table (T1) and the `posts` table (T2) where the `UserId` in the `votes` table matches the `OwnerUserId` in the `posts` table. This ensures we link votes to the posts they are associated with.\n\n2. **Filter for User No. 24**: Only include records where the `UserId` in the `votes` table is 24. This narrows down the data to only the user of interest.\n\n3. **Count Posts**: Count the number of posts (T2.Id) made by user No. 24. This gives the total number of posts authored by the user.\n\n4. **Count Distinct Votes**: Count the distinct number of votes (T1.Id) received by user No. 24. Using `DISTINCT` ensures that each vote is counted only once, even if a user has voted multiple times on the same post.\n\n5. **Calculate the Ratio**: Divide the count of posts by the count of distinct votes to get the comparison ratio. The `CAST(COUNT(T2.Id) AS REAL)` ensures the division is performed as a floating-point operation to avoid integer division truncation.\n\nThe result will show how many times the number of posts is compared to the number of votes for user No. 24."
        ]
    },
    "590": {
        "sql": "SELECT Id FROM users WHERE Views = (SELECT MIN(Views) FROM users);",
        "question": "Which user ID has the lowest view?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id FROM users WHERE Views = ( SELECT MIN(Views) FROM users )",
        "explain": "lowest views refers to Min(Views)",
        "solution": []
    },
    "803": {
        "sql": "SELECT id FROM superpower WHERE power_name = 'Cryokinesis';",
        "question": "What is the power ID of cryokinesis?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT id FROM superpower WHERE power_name = 'Cryokinesis'",
        "explain": "power ID refers to superpower.id; cryokinesis refers to power_name = 'cryokinesis';",
        "solution": [
            "To find the power ID of 'Cryokinesis', you need to query the 'superpower' table and retrieve the 'id' column where the 'power_name' column matches the value 'Cryokinesis'."
        ]
    },
    "1059": {
        "sql": "SELECT player_name FROM Player WHERE height > 180;",
        "question": "Please list player names which are higher than 180.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT player_name FROM Player WHERE height > 180",
        "explain": "height>180;",
        "solution": []
    },
    "1094": {
        "sql": "WITH ariel_rating AS (\n    SELECT SUM(overall_rating) AS total_rating\n    FROM Player_Attributes\n    WHERE player_api_id IN (SELECT player_api_id FROM Player WHERE player_name = 'Ariel Borysiuk')\n),\npaulin_rating AS (\n    SELECT SUM(overall_rating) AS total_rating\n    FROM Player_Attributes\n    WHERE player_api_id IN (SELECT player_api_id FROM Player WHERE player_name = 'Paulin Puel')\n)\nSELECT ((ariel_rating.total_rating - paulin_rating.total_rating) * 100.0 / paulin_rating.total_rating) AS percentage_higher\nFROM ariel_rating, paulin_rating;",
        "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "explain": "how much higher in percentage = MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100);",
        "solution": [
            "To determine how much higher Ariel Borysiuk's overall rating is compared to Paulin Puel's in percentage, follow these steps:\n\n1. **Retrieve the overall ratings**:\n   - For Ariel Borysiuk, sum up all his overall ratings from the `Player_Attributes` table where his name matches 'Ariel Borysiuk'.\n   - For Paulin Puel, sum up all his overall ratings from the `Player_Attributes` table where his name matches 'Paulin Puel'.\n\n2. **Calculate the difference**:\n   - Subtract the sum of Paulin Puel's overall ratings from the sum of Ariel Borysiuk's overall ratings.\n\n3. **Compute the percentage difference**:\n   - Divide the difference obtained in step 2 by the sum of Paulin Puel's overall ratings.\n   - Multiply the result by 100 to convert it into a percentage.\n\n4. **Return the result**:\n   - The final value represents the percentage by which Ariel Borysiuk's overall rating is higher than Paulin Puel's."
        ]
    },
    "446": {
        "sql": "SELECT \n    (SUM(CASE WHEN c.convertedManaCost = 10 THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id)) AS percentage,\n    c.name AS card_name\nFROM \n    cards c\nJOIN \n    sets s ON c.setCode = s.code\nWHERE \n    c.name = 'Abyssal Horror'\nGROUP BY \n    c.name;",
        "question": "What is percentage of the cards with a converted Mana Cost of 10 in set of Abyssal Horror?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'",
        "explain": "set of Abyssal Horror refers to name = 'Abyssal Horror'; percentage refers to DIVIDE(COUNT(convertedManaCost = 16),COUNT(convertedManaCost))*100",
        "solution": [
            "To determine the percentage of cards with a converted Mana Cost of 10 in the set of 'Abyssal Horror', follow these steps:\n\n1. **Join the Tables**: Combine the 'cards' table (referred to as T1) with the 'sets' table (referred to as T2) using the condition that the set code in the 'cards' table matches the code in the 'sets' table.\n\n2. **Filter by Card Name**: From the joined tables, filter the records to include only those where the card name is 'Abyssal Horror'.\n\n3. **Count Total Cards**: Calculate the total number of cards in the filtered set by counting the unique identifiers (id) of the cards.\n\n4. **Count Cards with Mana Cost 10**: For each card in the filtered set, check if its converted Mana Cost is 10. If it is, count it as 1; otherwise, count it as 0. Sum these values to get the total number of cards with a converted Mana Cost of 10.\n\n5. **Calculate Percentage**: Divide the count of cards with a converted Mana Cost of 10 by the total number of cards in the set. Multiply the result by 100 to convert it into a percentage.\n\n6. **Return the Result**: The final result will include the calculated percentage and the name of the card ('Abyssal Horror')."
        ]
    },
    "920": {
        "sql": "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.name = 'Silverstone Circuit';",
        "question": "Please list all the years that Silverstone Circuit was used in a Formula_1 race.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "explain": "",
        "solution": []
    },
    "1288": {
        "sql": "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.TP < 6.0;",
        "question": "Please list the diagnosis of the patients whose total protein is lower than normal.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0",
        "explain": "total protein is lower than normal refers to TP < 6.0;",
        "solution": []
    },
    "706": {
        "sql": "SELECT c.Text \nFROM comments c \nJOIN posts p ON c.PostId = p.Id \nWHERE p.Title LIKE '%linear regression%' OR p.Tags LIKE '%linear regression%';",
        "question": "Give the texts commented on the post about linear regression.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title LIKE '%linear regression%'",
        "explain": "about linear regression refers to Title contains 'linear regression'",
        "solution": []
    },
    "429": {
        "sql": "SELECT T2.language, T1.type FROM sets T1 JOIN set_translations T2 ON T1.code = T2.setCode WHERE T2.id = 206;",
        "question": "What is the language and expansion type of set number 206?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language, T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 206",
        "explain": "set number 206 refers to id = 206",
        "solution": [
            "To find the language and expansion type of the set with the number 206, follow these steps:\n\n1. **Identify the tables involved**: The query uses two tables:\n   - `sets` (aliased as `T1`)\n   - `set_translations` (aliased as `T2`)\n\n2. **Understand the join condition**: The query joins these two tables on the condition that the `code` column in the `sets` table (`T1.code`) matches the `setCode` column in the `set_translations` table (`T2.setCode`).\n\n3. **Apply the filter**: The query filters the results to only include rows where the `id` column in the `set_translations` table (`T2.id`) is equal to 206.\n\n4. **Select the required columns**: The query retrieves the `language` column from the `set_translations` table (`T2.language`) and the `type` column from the `sets` table (`T1.type`).\n\n5. **Result**: The output will be the language and expansion type of the set with the number 206."
        ]
    },
    "35": {
        "sql": "SELECT s.AdmEmail1\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE f.`Charter School (Y/N)` = 1\nORDER BY f.`Enrollment (K-12)` ASC\nLIMIT 1;",
        "question": "What is the administrator's email address of the chartered school with the fewest students enrolled in grades 1 through 12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.AdmEmail1 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter School (Y/N)` = 1 ORDER BY T1.`Enrollment (K-12)` ASC LIMIT 1",
        "explain": "Charted school means `Charter School (Y/N)` = 1 in the table frpm; Students enrolled in grades 1 through 12 refers to `Enrollment (K-12)`",
        "solution": []
    },
    "587": {
        "sql": "SELECT AVG(T2.ViewCount) AS AverageViewCount, T2.Title, T1.Text\nFROM comments T1\nJOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Tags LIKE '%<humor>%'\nGROUP BY T2.Title, T1.Text;",
        "question": "Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.",
        "db_id": "codebase_community",
        "res": 0,
        "ground_truth": "SELECT AVG(T2.ViewCount), T2.Title, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.PostId  WHERE T2.Tags = '<humor>' GROUP BY T2.Title, T1.Text ",
        "explain": "tagged as  'humor' refers to tag = '<humor>'; comment of the post refers to Text; average view count = AVG(ViewCount)",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: The `comments` table (referred to as `T1`) is joined with the `posts` table (referred to as `T2`) using the `PostId` from the `comments` table and the `Id` from the `posts` table. This ensures that each comment is linked to its corresponding post.\n\n2. **Filter by Tag**: Only posts that are tagged as 'humor' are selected. This is done by applying a filter condition `T2.Tags = '<humor>'`.\n\n3. **Group the Results**: The results are grouped by the `Title` of the post and the `Text` of the comment. This grouping ensures that each unique combination of post title and comment text is treated as a distinct group.\n\n4. **Calculate the Average View Count**: For each group (i.e., each unique combination of post title and comment text), the average `ViewCount` of the posts is calculated using the `AVG` function.\n\n5. **Select the Required Fields**: The query selects the calculated average view count (`AVG(T2.ViewCount)`), the post title (`T2.Title`), and the comment text (`T1.Text`) for each group.\n\nThe final output will list the average view count of each post tagged as 'humor', along with the title of the post and the text of the associated comment.",
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: The `comments` table (referred to as `T1`) is joined with the `posts` table (referred to as `T2`) using the `PostId` from the `comments` table and the `Id` from the `posts` table. This ensures that each comment is linked to its corresponding post.\n\n2. **Filter by Tag**: Only posts that are tagged as 'humor' are selected. This is done by applying a filter condition `T2.Tags = '<humor>'`.\n\n3. **Group the Results**: The results are grouped by the `Title` of the post and the `Text` of the comment. This grouping ensures that each unique combination of post title and comment text is treated as a distinct group.\n\n4. **Calculate the Average View Count**: For each group (i.e., each unique combination of post title and comment text), the average `ViewCount` of the posts is calculated using the `AVG` function.\n\n5. **Select the Required Fields**: The query selects the calculated average view count (`AVG(T2.ViewCount)`), the post title (`T2.Title`), and the comment text (`T1.Text`) for each group.\n\nThe final output will list the average view count of each post tagged as 'humor', along with the title of the post and the text of the associated comment."
        ]
    },
    "78": {
        "sql": "SELECT GSserved, COUNT(GSserved) AS count\nFROM schools\nWHERE City = 'Adelanto'\nGROUP BY GSserved\nORDER BY count DESC\nLIMIT 1;",
        "question": "What is the most common type of grade span served in the city of Adelanto?",
        "db_id": "california_schools",
        "res": 0,
        "ground_truth": "SELECT GSserved FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1",
        "explain": "",
        "solution": [
            "To determine the most common type of grade span served in the city of Adelanto, follow these steps:\n\n1. **Filter Schools by City**: First, select all schools located in the city of Adelanto.\n2. **Group by Grade Span**: Group these schools by their grade span (GSserved).\n3. **Count Occurrences**: For each grade span, count how many schools serve that grade span.\n4. **Order by Count**: Sort the grade spans in descending order based on the count of schools serving each grade span.\n5. **Select the Most Common**: Retrieve the grade span with the highest count, which will be the first result after sorting.\n\nThe result will be the most common grade span served in Adelanto.",
            "To determine the most common type of grade span served in the city of Adelanto, follow these detailed steps:\n\n1. **Filter Schools by City**: Query the database to retrieve all schools where the `City` column matches 'Adelanto'. This ensures we only consider schools located in Adelanto.\n\n2. **Group by Grade Span**: Group the filtered schools by the `GSserved` column. This step organizes the data by each unique grade span.\n\n3. **Count Occurrences**: For each group (grade span), count the number of schools that serve that specific grade span. This count is derived using the `COUNT` function on the `GSserved` column.\n\n4. **Order by Count in Descending Order**: Sort the grouped results by the count of schools in descending order. This places the grade span with the highest count at the top of the list.\n\n5. **Limit to Top Result**: Retrieve only the first result from the sorted list, which corresponds to the grade span with the highest count of schools serving it.\n\nThe final output will be the most common grade span (`GSserved`) served in the city of Adelanto."
        ]
    },
    "1140": {
        "sql": "SELECT sprint_speed, agility, acceleration FROM Player_Attributes WHERE player_api_id IN (SELECT player_api_id FROM Player WHERE player_name = 'Alexis Blin');",
        "question": "What are Alexis Blin's sprint speed, agility, and acceleration scores?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT sprint_speed, agility, acceleration FROM Player_Attributes WHERE player_api_id IN ( SELECT player_api_id FROM Player WHERE player_name = 'Alexis Blin' )",
        "explain": "Alexis Blin's refers to player_name = 'Alexis Blin'",
        "solution": [
            "To find Alexis Blin's sprint speed, agility, and acceleration scores, follow these steps:\n1. First, locate Alexis Blin's unique player identifier (player_api_id) in the Player table by searching for the player_name 'Alexis Blin'.\n2. Once you have the player_api_id, use it to query the Player_Attributes table to retrieve the sprint_speed, agility, and acceleration scores associated with that player_api_id.\n3. The result will display the sprint speed, agility, and acceleration scores for Alexis Blin.",
            "To retrieve Alexis Blin's sprint speed, agility, and acceleration scores, follow these detailed steps:\n\n1. **Identify the Player's Unique Identifier**: \n   - Query the `Player` table to find the unique identifier (`player_api_id`) for the player named 'Alexis Blin'. This is done using the condition `player_name = 'Alexis Blin'`.\n\n2. **Retrieve the Player's Attributes**: \n   - Using the `player_api_id` obtained from the previous step, query the `Player_Attributes` table to fetch the specific attributes: `sprint_speed`, `agility`, and `acceleration`. The condition `player_api_id IN (SELECT player_api_id FROM Player WHERE player_name = 'Alexis Blin')` ensures that only Alexis Blin's attributes are retrieved.\n\n3. **Display the Results**: \n   - The final output will be a table with three columns: `sprint_speed`, `agility`, and `acceleration`, containing the respective scores for Alexis Blin.\n\nThis process ensures that the query accurately targets Alexis Blin's data and returns the requested attributes without any modifications to the original SQL logic."
        ]
    },
    "946": {
        "sql": "SELECT lat, lng FROM circuits WHERE country = 'USA';",
        "question": "Please list the location coordinates of the US circuits.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT lat, lng FROM circuits WHERE country = 'USA'",
        "explain": "location coordinates refers to (lat, lng); the US refers to country = 'USA';",
        "solution": [
            "To list the location coordinates of the US circuits, you need to retrieve the latitude (`lat`) and longitude (`lng`) values from the `circuits` table where the `country` column is equal to 'USA'."
        ]
    },
    "1311": {
        "sql": "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p \nJOIN Examination e ON p.ID = e.ID \nJOIN Laboratory l ON p.ID = l.ID \nWHERE e.Thrombosis = 1 \nAND l.PT BETWEEN 10 AND 14;",
        "question": "How many patients with severe thrombosis have a normal prothrombin time?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.PT < 14 AND T3.Thrombosis < 3 AND T3.Thrombosis > 0",
        "explain": "severe thrombosis refers to Thrombosis = 2 or 1; normal prothrombin time refers to PT < 14;",
        "solution": []
    },
    "40": {
        "sql": "SELECT T2.Phone\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;",
        "question": "What is the telephone number for the school with the lowest average score in reading in Fresno Unified?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "explain": "Fresno Unified is a name of district;",
        "solution": [
            "1. **Joining the SAT scores and schools data:**  \n   The query uses an `INNER JOIN` between two tables: `satscores` (aliased as T1) and `schools` (aliased as T2). These tables are linked using the `cds` column from `satscores` and the `CDSCode` column from `schools`. This ensures that each school's SAT score data is matched with its corresponding school record.\n\n2. **Filtering for Fresno Unified and valid reading scores:**  \n   The query includes a `WHERE` clause to filter results for schools in the district \"Fresno Unified\" (`T2.District = 'Fresno Unified'`). Additionally, it ensures that only records with non-null average reading scores (`T1.AvgScrRead IS NOT NULL`) are considered, excluding any incomplete data.\n\n3. **Ordering by reading scores:**  \n   The results are ordered based on the `AvgScrRead` column from the `satscores` table in ascending order (`ASC`). This places the school with the lowest average reading score at the top of the list.\n\n4. **Selecting the telephone number:**  \n   From the `schools` table (T2), the query selects the `Phone` column, which contains the telephone number of the school. This is the specific information requested by the question.\n\n5. **Limiting to the lowest-scoring school:**  \n   The query applies a `LIMIT 1` clause, which restricts the output to only the first record. This ensures that only the school with the lowest average reading score in Fresno Unified is returned, along with its telephone number."
        ]
    },
    "384": {
        "sql": "SELECT T1.uuid, T3.language\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nINNER JOIN foreign_data T3 ON T1.uuid = T3.uuid\nWHERE T2.format = 'legacy';",
        "question": "List down the uuid for legacy cards and the foreign language of these cards.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'",
        "explain": "legacy card refers to format = 'legacy'; foreign language refers to language in foreign_data",
        "solution": [
            "To list the UUIDs for legacy cards and the foreign language of these cards, follow these steps:\n\n1. **Select the UUID and Language**: Retrieve the `uuid` from the `cards` table (aliased as `T1`) and the `language` from the `foreign_data` table (aliased as `T3`).\n\n2. **Join the Tables**:\n   - Perform an inner join between the `cards` table (`T1`) and the `legalities` table (`T2`) using the `uuid` column as the common key.\n   - Perform another inner join between the `cards` table (`T1`) and the `foreign_data` table (`T3`) using the `uuid` column as the common key.\n\n3. **Filter for Legacy Cards**: Apply a filter condition to only include records where the `format` column in the `legalities` table (`T2`) is equal to 'legacy'.\n\nThe result will be a list of UUIDs and their corresponding foreign languages for all legacy cards."
        ]
    },
    "28": {
        "sql": "SELECT T2.School, T2.DOC\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.FundingType = 'Locally funded'\nAND (T1.[Enrollment (K-12)] - T1.[Enrollment (Ages 5-17)]) > (\n    SELECT AVG(T3.[Enrollment (K-12)] - T3.[Enrollment (Ages 5-17)])\n    FROM frpm AS T3\n    INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode\n    WHERE T4.FundingType = 'Locally funded'\n);",
        "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
        "explain": "Difference between K-12 enrollment and 15-17 enrollment can be computed by `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
        "solution": [
            "1. **Joining the enrollment and schools data:**  \n   The query uses an `INNER JOIN` between two tables: `frpm` (aliased as T1) and `schools` (aliased as T2). These tables are linked using the `CDSCode` column, ensuring that each enrollment record is matched with its corresponding school record.\n\n2. **Filtering for locally funded schools:**  \n   The query includes a condition (`WHERE T2.FundingType = 'Locally funded'`) to restrict the results to only those schools that are funded locally.\n\n3. **Calculating the enrollment difference:**  \n   For each school, the query calculates the difference between the `Enrollment (K-12)` and `Enrollment (Ages 5-17)` columns from the `frpm` table (T1). This difference represents the gap between K-12 enrollment and enrollment for ages 5-17.\n\n4. **Comparing to the average difference:**  \n   The query includes a subquery to compute the average difference between `Enrollment (K-12)` and `Enrollment (Ages 5-17)` for all locally funded schools. The main query then filters to include only those schools where the calculated difference exceeds this average.\n\n5. **Selecting school names and DOC types:**  \n   The final output includes the `School` name and `DOC` type from the `schools` table (T2) for the qualifying schools."
        ]
    },
    "1046": {
        "sql": "SELECT ta.buildUpPlayPositioningClass \nFROM Team_Attributes ta \nJOIN Team t ON ta.team_api_id = t.team_api_id \nWHERE t.team_long_name = 'ADO Den Haag';",
        "question": "What is the ADO Den Haag team freedom of movement in the 1st two thirds of the pitch?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPositioningClass FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_fifa_api_id = t2.team_fifa_api_id WHERE t1.team_long_name = 'ADO Den Haag'",
        "explain": "ADO Den Haag refers to team_long_name = 'ADO Den Haag'; freedom of movement in the 1st two thirds of the pitch refers to buildUpPlayPositioningClass;",
        "solution": []
    },
    "73": {
        "sql": "SELECT T1.\"FRPM Count (Ages 5-17)\"\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.MailStreet = 'PO Box 1040'\nAND T2.SOCType = 'Youth Authority Facilities';",
        "question": "What is the free or reduced price meal count for ages 5 to 17 in the Youth Authority School with a mailing street address of PO Box 1040?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`FRPM Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.MailStreet = 'PO Box 1040' AND T2.SOCType = 'Youth Authority Facilities'",
        "explain": "",
        "solution": [
            "To find the free or reduced price meal count for ages 5 to 17 in the Youth Authority School with a mailing street address of PO Box 1040, follow these steps:\n\n1. **Join the Tables**: Combine the `frpm` table (aliased as `T1`) and the `schools` table (aliased as `T2`) using the common column `CDSCode`.\n\n2. **Filter the Data**: From the joined tables, filter the records where:\n   - The `MailStreet` column in the `schools` table (`T2`) matches the value 'PO Box 1040'.\n   - The `SOCType` column in the `schools` table (`T2`) is 'Youth Authority Facilities'.\n\n3. **Retrieve the Result**: Select the column `FRPM Count (Ages 5-17)` from the `frpm` table (`T1`) for the filtered records.\n\nThis will give you the count of free or reduced price meals for students aged 5 to 17 in the specified school."
        ]
    },
    "267": {
        "sql": "SELECT T2.molecule_id, T2.bond_type FROM molecule T1 JOIN bond T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id BETWEEN 'TR000' AND 'TR050';",
        "question": "List down the bond type for molecules from molecule id TR000 to TR050.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'",
        "explain": "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join Tables**: The `molecule` table (aliased as T1) is joined with the `bond` table (aliased as T2) using the `molecule_id` column as the common key. This ensures that each molecule is linked to its corresponding bond information.\n\n2. **Filter Records**: After joining, the records are filtered to include only those molecules where the `molecule_id` falls within the range from 'TR000' to 'TR050' (inclusive). This is done using the `BETWEEN` clause.\n\n3. **Select Columns**: From the resulting joined and filtered dataset, only the `molecule_id` (from the `bond` table) and the `bond_type` columns are selected for the final output.\n\nThis sequence of operations ensures that the query lists the bond types for molecules with IDs ranging from 'TR000' to 'TR050'."
        ]
    },
    "110": {
        "sql": "SELECT T1.disp_id\nFROM disp T1\nJOIN account T2 ON T1.account_id = T2.account_id\nJOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T3.date = '1997-08-20' AND T3.amount = 5100;",
        "question": "What is the disposition id of the client who made 5100 USD transaction in 1998/9/2?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.disp_id FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.date='1997-08-20' AND T3.amount = 5100",
        "explain": "",
        "solution": [
            "To find the disposition ID of the client who made a transaction of 5100 USD on August 20, 1997, follow these steps:\n\n1. **Join the `disp` table (aliased as T1) with the `account` table (aliased as T2)** using the `account_id` field to link them.\n2. **Join the resulting table with the `trans` table (aliased as T3)** again using the `account_id` field to link them.\n3. **Filter the transactions** to only include those where the date is '1997-08-20' and the amount is 5100 USD.\n4. **Select the `disp_id` field** from the `disp` table (T1) for the matching records.\n\nThis will return the disposition ID of the client who made the specified transaction."
        ]
    },
    "539": {
        "sql": "SELECT u.DisplayName\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Title = 'Eliciting priors from experts';",
        "question": "Who is the owner of the post \"Eliciting priors from experts\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'",
        "explain": "\"Eliciting priors from experts\" is the Title of post; owner refers to DisplayName",
        "solution": []
    },
    "333": {
        "sql": "SELECT COUNT(*) AS carbon_count\nFROM atom\nJOIN molecule ON atom.molecule_id = molecule.molecule_id\nWHERE molecule.molecule_id = 'TR008' AND atom.element = 'c';",
        "question": "In the molecule TR008, how many carbons are present?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR008' AND T.element = 'c'",
        "explain": "carbon refers to element = 'c'",
        "solution": []
    },
    "1208": {
        "sql": "SELECT DISTINCT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'M' AND L.GPT >= 60;",
        "question": "Provide IDs for male patients with ALT glutamic pylvic transaminase (GPT) that have history of ALT glutamic pylvic transaminase (GPT) exceed the normal range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.GPT >= 60",
        "explain": "male refers to SEX = 'M'; ALT glutamic pylvic transaminase (GPT) exceed the normal range refers to GPT > = 60",
        "solution": []
    },
    "469": {
        "sql": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
        "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
        "explain": "card set \"Angel of Mercy\" refers to name = 'Angel of Mercy'; appear on Magic: The Gathering Online refers to mtgoCode is NOT NULL and vice versa",
        "solution": [
            "To determine if the set of cards with \"Angel of Mercy\" appeared on Magic: The Gathering Online, follow these steps:\n\n1. **Identify the card**: Look for the card named \"Angel of Mercy\" in the `cards` table (referred to as `T1`).\n\n2. **Join with sets table**: Connect the `cards` table (`T1`) with the `sets` table (`T2`) using the `setCode` from `T1` and the `code` from `T2`. This links each card to its corresponding set.\n\n3. **Check for MTGO presence**: For the matched set in `T2`, check if the `mtgoCode` field is not null. The `mtgoCode` indicates whether the set is available on Magic: The Gathering Online.\n\n4. **Return result**: If the `mtgoCode` is not null, return \"YES\" (indicating the set appeared on MTGO). Otherwise, return \"NO\" (indicating it did not).\n\nThe SQL query performs these operations to provide the answer.",
            "To determine if the set of cards with \"Angel of Mercy\" appeared on Magic: The Gathering Online, follow these detailed steps:\n\n1. **Identify the Card**: Query the `cards` table (referred to as `T1`) to find the card named \"Angel of Mercy\" using the condition `T1.name = 'Angel of Mercy'`.\n\n2. **Join with Sets Table**: Perform an inner join between the `cards` table (`T1`) and the `sets` table (`T2`) using the `setCode` field from `T1` and the `code` field from `T2`. This ensures that each card is linked to its corresponding set.\n\n3. **Check MTGO Availability**: For the matched set in `T2`, evaluate the `mtgoCode` field. If `T2.mtgoCode` is not null, it indicates that the set is available on Magic: The Gathering Online.\n\n4. **Return the Result**: Use the `IIF` function to return \"YES\" if `T2.mtgoCode` is not null (indicating the set appeared on MTGO) or \"NO\" if it is null (indicating it did not).\n\nThe SQL query `SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'` precisely executes these steps to provide the answer."
        ]
    },
    "1113": {
        "sql": "SELECT t2.defenceAggressionClass \nFROM Team t1 \nJOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Hannover 96' \nAND t2.date LIKE '2015-09-10%'",
        "question": "For the team \"Hannover 96\", what was its defence aggression class on 2015/9/10?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT t2.chanceCreationShootingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hannover 96' AND t2.`date` LIKE '2015-09-10%'",
        "explain": "\"Hannover 96\" refers to team_long_name = 'Hannover 96'; on 2015/9/10 refers to date LIKE '2015-09-10%';",
        "solution": [
            "To find the defence aggression class for the team \"Hannover 96\" on September 10, 2015, follow these steps:\n\n1. **Identify the Team**: Locate the team \"Hannover 96\" in the `Team` table using its long name.\n2. **Join with Team Attributes**: Connect the `Team` table with the `Team_Attributes` table using the `team_api_id` field to access the team's attributes.\n3. **Filter by Date**: Narrow down the attributes to those recorded on September 10, 2015, by checking the `date` field in the `Team_Attributes` table.\n4. **Retrieve the Attribute**: From the filtered results, extract the `chanceCreationShootingClass` value, which represents the defence aggression class for the specified date.\n\nThe SQL query performs these operations to return the desired information.",
            "To determine the defence aggression class for the team \"Hannover 96\" on September 10, 2015, the following steps are executed:\n\n1. **Select the Team**: The `Team` table is queried to locate the team with the long name \"Hannover 96\". This is done using the condition `t1.team_long_name = 'Hannover 96'`.\n\n2. **Join with Team Attributes**: The `Team` table is then joined with the `Team_Attributes` table using the `team_api_id` field. This ensures that the attributes of the team \"Hannover 96\" are accessible. The join condition is `t1.team_api_id = t2.team_api_id`.\n\n3. **Filter by Date**: The results are filtered to include only the attributes recorded on September 10, 2015. This is achieved by checking the `date` field in the `Team_Attributes` table with the condition `t2.date LIKE '2015-09-10%'`.\n\n4. **Retrieve the Attribute**: From the filtered results, the `chanceCreationShootingClass` value is selected. This value represents the defence aggression class for the specified date.\n\nThe SQL query combines these steps to return the defence aggression class for \"Hannover 96\" on September 10, 2015."
        ]
    },
    "1373": {
        "sql": "SELECT COUNT(DISTINCT m.member_id) \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE z.state = 'Maryland';",
        "question": "How many of the members' hometowns are from Maryland state?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.member_id) FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T1.state = 'Maryland'",
        "explain": "",
        "solution": []
    },
    "643": {
        "sql": "SELECT DisplayName, Age FROM users ORDER BY Views DESC LIMIT 1;",
        "question": "What are the display names and ages of user who got the highest in views?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT DisplayName, Age FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "explain": "the highest in views refers to MAX(Views);",
        "solution": []
    },
    "121": {
        "sql": "SELECT a.account_id, a.date\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE d.A2 = 'Prachatice';",
        "question": "List account ID and account opening date for accounts from 'Prachatice'.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T1.date FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Prachatice'",
        "explain": "A2 refers to the names of districts.",
        "solution": []
    },
    "1053": {
        "sql": "SELECT t.team_short_name\nFROM Team_Attributes ta\nJOIN Team t ON ta.team_api_id = t.team_api_id\nWHERE ta.chanceCreationPassingClass = 'Risky';",
        "question": "List the football teams that has a chance creation passing class of Risky. Inidcate its short name only.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Risky'",
        "explain": "chance creation passing class refers to chanceCreationPassingClass; chanceCreationPassingClass = 'Risky'; short name refers to team_short_name;",
        "solution": []
    },
    "108": {
        "sql": "WITH BiggestLoan AS (\n    SELECT account_id\n    FROM loan\n    ORDER BY amount DESC\n    LIMIT 1\n),\nFirstTransaction AS (\n    SELECT t.amount\n    FROM trans t\n    JOIN BiggestLoan bl ON t.account_id = bl.account_id\n    ORDER BY t.date ASC\n    LIMIT 1\n)\nSELECT amount\nFROM FirstTransaction;",
        "question": "For the client who applied the biggest loan, what was his/her first amount of transaction after opened the account?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY T1.amount DESC, T3.date ASC LIMIT 1",
        "explain": "",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Identify the client with the biggest loan**:\n   - Start by examining the `loan` table (referred to as `T1`).\n   - Sort the loans in descending order based on the `amount` column to find the largest loan.\n\n2. **Link the loan to the corresponding account**:\n   - Join the `loan` table (`T1`) with the `account` table (`T2`) using the `account_id` column to find the account associated with the largest loan.\n\n3. **Find the first transaction for the account**:\n   - Join the `account` table (`T2`) with the `trans` table (`T3`) using the `account_id` column to retrieve all transactions for the account.\n   - Sort these transactions in ascending order based on the `date` column to identify the earliest transaction.\n\n4. **Retrieve the amount of the first transaction**:\n   - Select the `amount` column from the `trans` table (`T3`) for the earliest transaction.\n   - Limit the result to the first row to ensure only the earliest transaction's amount is returned.\n\nThis process ensures that you identify the client with the largest loan and then find the amount of their first transaction after opening the account."
        ]
    },
    "175": {
        "sql": "SELECT COUNT(DISTINCT a.account_id) AS account_count\nFROM account a\nJOIN disp d ON a.account_id = d.account_id\nWHERE d.type = 'OWNER' AND a.frequency = 'POPLATEK PO OBRATU';",
        "question": "How many accounts have an owner disposition and request for a statement to be generated upon a transaction?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK PO OBRATU'",
        "explain": "Frequency = 'POPLATEK PO OBRATU' stands for issuance after transaction",
        "solution": []
    },
    "83": {
        "sql": "SELECT T2.City, COUNT(T2.CDSCode) AS NumberOfSchools\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.Magnet = 1\nAND T2.GSoffered = 'K-8'\nAND T1.[NSLP Provision Status] = 'Multiple Provision Types'\nGROUP BY T2.City;",
        "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
        "explain": "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1; Multiple Provision Types refers to `NSLP Provision Status` = 'Multiple Provision Types'",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join Tables**: The `frpm` table (aliased as `T1`) is joined with the `schools` table (aliased as `T2`) using the `CDSCode` field as the common key.\n\n2. **Filter Conditions**: The joined data is filtered based on the following criteria:\n   - The school must offer a magnet program (`T2.Magnet = 1`).\n   - The school must serve a grade span from Kindergarten to 8th grade (`T2.GSoffered = 'K-8'`).\n   - The school must offer multiple provision types under the NSLP program (`T1.`NSLP Provision Status` = 'Multiple Provision Types'`).\n\n3. **Group and Count**: The filtered data is grouped by the `City` field from the `schools` table (`T2.City`). For each city, the count of schools (`COUNT(T2.CDSCode)`) that meet the above criteria is calculated.\n\n4. **Output**: The result displays each city along with the number of schools in that city that meet the specified conditions."
        ]
    },
    "46": {
        "sql": "SELECT T2.School\nFROM frpm T1\nJOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.DOC = '31'\nORDER BY T1.[Enrollment (K-12)] DESC\nLIMIT 1;",
        "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "explain": "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12",
        "solution": [
            "To determine which state special school has the highest number of enrollees from grades 1 through 12, follow these steps:\n\n1. **Join the Tables**: Combine the `frpm` table (T1) and the `schools` table (T2) using the `CDSCode` field as the common key. This links the enrollment data with the school details.\n\n2. **Filter for State Special Schools**: From the joined tables, filter the records to include only those where the `DOC` (Department of Code) field in the `schools` table (T2) is equal to 31. This identifies state special schools.\n\n3. **Sort by Enrollment**: Order the filtered results by the `Enrollment (K-12)` field in descending order. This places the school with the highest enrollment at the top of the list.\n\n4. **Retrieve the Top Result**: Limit the output to the first record in the sorted list, which represents the state special school with the highest number of enrollees from grades 1 through 12.\n\nThe final output will be the name of the school (`School` field from T2) that meets these criteria."
        ]
    },
    "1456": {
        "sql": "SELECT T3.first_name, T3.last_name\nFROM expense T1\nJOIN budget T2 ON T1.link_to_budget = T2.budget_id\nJOIN member T3 ON T1.link_to_member = T3.member_id\nORDER BY T2.spent DESC\nLIMIT 5;",
        "question": "List the full name of the top five members who spend the most money in the descending order of spending.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T3.first_name, T3.last_name FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id ORDER BY T2.spent DESC LIMIT 5",
        "explain": "full name refers to first_name, last_name; spend the most money refers to MAX(expense.cost)",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Join the Tables**: Combine the `expense` table (`T1`), the `budget` table (`T2`), and the `member` table (`T3`) using the following relationships:\n   - Link the `expense` table to the `budget` table using the condition `T1.link_to_budget = T2.budget_id`.\n   - Link the `expense` table to the `member` table using the condition `T1.link_to_member = T3.member_id`.\n\n2. **Order by Spending**: Sort the combined data in descending order based on the `spent` column from the `budget` table (`T2.spent DESC`).\n\n3. **Limit the Results**: Retrieve only the top 5 records from the sorted list to get the members who spent the most money.\n\n4. **Select the Required Fields**: From the result, extract the `first_name` and `last_name` columns from the `member` table (`T3.first_name` and `T3.last_name`).\n\nThis process ensures that the full names of the top five members who spent the most money are listed in descending order of their spending."
        ]
    },
    "1172": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.`T-BIL` >= 2.0;",
        "question": "How many male patients have elevated total bilirubin count?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "explain": "male refers to SEX = 'M'; elevated means above the normal range; total bilirubin above the normal range refers to `T-BIL` >= '2.0'",
        "solution": []
    },
    "1326": {
        "sql": "SELECT COUNT(*) \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.major_name = 'Environmental Engineering';",
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
        "explain": "'Environmental Engineering' is the major name",
        "solution": []
    },
    "1249": {
        "sql": "SELECT DISTINCT p.Diagnosis\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE l.\"U-PRO\" >= 30;",
        "question": "Please list the disease names of the patients that have a proteinuria level higher than normal.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` >= 30",
        "explain": "disease names refers to Diagnosis; proteinuria level higher than normal refers to `U-PRO` > = 30;",
        "solution": []
    },
    "124": {
        "sql": "SELECT l.loan_id, d.A2 AS district, d.A11 AS average_salary\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE l.duration = 60;",
        "question": "List the loan ID, district and average salary for loan with duration of 60 months.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T3.loan_id, T2.A2, T2.A11 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.duration = 60",
        "explain": "A3 refers to regions; A11 refers to average salary",
        "solution": []
    },
    "1233": {
        "sql": "SELECT DISTINCT T1.ID, T2.GLU\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE strftime('%Y', T1.\"First Date\") = '1991'\nAND T2.GLU < 180;",
        "question": "List each patient's ID and blood glucose (GLU) index that were within normal range for patient's whose data was first recorded in 1991.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID, T2.GLU FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) = '1991' AND T2.GLU < 180",
        "explain": "blood glucose (GLU) index that were within normal range refers to GLU < 180; data that was first recorded in 1991 refers to year(Description) = 1991;",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Select Distinct Patient IDs and Blood Glucose (GLU) Index**: The query retrieves unique combinations of patient IDs and their corresponding GLU values from the database.\n\n2. **Join Tables**: The query joins the `Patient` table (aliased as `T1`) with the `Laboratory` table (aliased as `T2`) using the patient ID as the common key. This ensures that only records with matching patient IDs in both tables are considered.\n\n3. **Filter by First Recorded Date in 1991**: The query filters the results to include only those patients whose data was first recorded in the year 1991. This is done by extracting the year from the `First Date` column in the `Patient` table and comparing it to '1991'.\n\n4. **Filter by Normal Blood Glucose Range**: The query further filters the results to include only those records where the blood glucose (GLU) index is less than 180, which is considered within the normal range.\n\n5. **Output the Results**: The final output is a list of distinct patient IDs and their corresponding GLU values that meet all the specified conditions."
        ]
    },
    "1418": {
        "sql": "SELECT T2.category FROM event T1 INNER JOIN budget T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';",
        "question": "Mention the category of events which were held at MU 215.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "explain": "held at MU 215 refers to location = 'MU 215'",
        "solution": [
            "To find the category of events held at 'MU 215', follow these steps:\n1. Start by identifying the 'event' table (referred to as T1) and the 'budget' table (referred to as T2).\n2. Perform an inner join between these two tables using the condition that the 'event_id' from the 'event' table (T1) matches the 'link_to_event' field in the 'budget' table (T2).\n3. Filter the results to include only those records where the 'location' field in the 'event' table (T1) is 'MU 215'.\n4. Finally, select and return the 'category' field from the 'budget' table (T2) for the filtered records."
        ]
    },
    "39": {
        "sql": "SELECT AVG(s.NumTstTakr) AS average_test_takers\nFROM schools sc\nJOIN satscores s ON sc.CDSCode = s.cds\nWHERE sc.County = 'Fresno'\nAND sc.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';",
        "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T2.County = 'Fresno'",
        "explain": "between 1/1/1980 and 12/31/1980 means the year = 1980",
        "solution": []
    },
    "618": {
        "sql": "SELECT u.Age\nFROM users u\nINNER JOIN badges b ON u.Id = b.UserId\nWHERE u.Location = 'Vienna, Austria';",
        "question": "List out the age of users who located in Vienna, Austria obtained the badge?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Age FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'Vienna, Austria'",
        "explain": "\"Vienna, Austria\" is the Location",
        "solution": []
    },
    "739": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Death Touch';",
        "question": "What are the names of the superheroes with the power of death touch?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'",
        "explain": "name of superheroes refers to refers to superhero_name; the power of death touch refers to power_name = 'Death Touch'",
        "solution": []
    },
    "797": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN colour eye_colour ON s.eye_colour_id = eye_colour.id\nJOIN colour hair_colour ON s.hair_colour_id = hair_colour.id\nWHERE eye_colour.colour = 'Blue' AND hair_colour.colour = 'Brown';",
        "question": "Which superheroes have blue eyes with brown hair?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'",
        "explain": "which superheroes refers to superhero_name; blue eyes refers to color = 'Blue' and color.id = eye_colour_id; brown hair refers to color = 'Brown' and color.id = hair_colour_id;",
        "solution": []
    },
    "1352": {
        "sql": "SELECT COUNT(*) \nFROM member m\nJOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' AND m.t_shirt_size = 'Medium';",
        "question": "For all the club members from \"Business\" major, how many of them wear medium size t-shirt?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'",
        "explain": "'Business' is a major name; wear medium size t-shirt refers to t_shirt_size = 'Medium'",
        "solution": []
    },
    "609": {
        "sql": "SELECT COUNT(*) FROM posts WHERE Score = 10;",
        "question": "How many posts have a score of 10 on the list?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score = 10",
        "explain": "score of 10 refers to Score = 10; post refers to Id",
        "solution": []
    },
    "312": {
        "sql": "SELECT m.label \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.bond_id = 'TR001_2_4';",
        "question": "What is the carcinogenic label for bond TR001_2_4?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
        "explain": "label = '+' mean molecules are carcinogenic",
        "solution": []
    },
    "452": {
        "sql": "SELECT name FROM cards WHERE isTextless = 0;",
        "question": "Please list the names of the cards that have a text box.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE isTextless = 0",
        "explain": "have a text box refers to isTextless = 0",
        "solution": []
    },
    "860": {
        "sql": "SELECT d.nationality\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 355 AND q.q2 LIKE '1:40%';",
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "explain": "race number refers to raceId;",
        "solution": [
            "To find the nationality of the driver who had a Q2 time of 0:01:40 in the qualifying race No. 355, follow these steps:\n\n1. **Identify the qualifying race**: Focus on the qualifying race with the ID 355.\n2. **Filter by Q2 time**: Within this race, look for drivers whose Q2 time starts with '1:40' (indicating a time of 0:01:40).\n3. **Join with drivers table**: Link the qualifying data with the drivers table using the driver ID to access the driver's details.\n4. **Retrieve nationality**: From the linked data, extract the nationality of the identified driver.\n\nThe result will be the nationality of the driver who met the specified criteria in the qualifying race."
        ]
    },
    "72": {
        "sql": "SELECT f.\"Enrollment (Ages 5-17)\" \nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE s.EdOpsCode = 'SSS' \nAND s.City = 'Fremont' \nAND f.\"Academic Year\" = '2014-2015';",
        "question": "How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1.`Academic Year` BETWEEN 2014 AND 2015",
        "explain": "State Special School means EdOpsCode = 'SSS'",
        "solution": []
    },
    "415": {
        "sql": "SELECT (COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_without_content_warning\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'commander' AND l.status = 'Legal';",
        "question": "What percentage of cards with format commander and legal status do not have a content warning?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
        "explain": "do not have a content warning refers to hasContentWarning = 0; percentage refers to DIVIDE(COUNT(hasContentWarning = 0),COUNT(ID))*100 where format = 'commander' AND Status = 'legal';",
        "solution": [
            "To determine the percentage of cards with the format 'commander' and legal status that do not have a content warning, follow these steps:\n\n1. **Join the Tables**: Combine the `cards` table (referred to as T1) with the `legalities` table (referred to as T2) using the `uuid` field as the common key.\n\n2. **Filter the Data**: From the joined tables, filter the records to include only those where:\n   - The `format` in the `legalities` table (T2) is 'commander'.\n   - The `status` in the `legalities` table (T2) is 'Legal'.\n\n3. **Count the Total Cards**: Calculate the total number of cards that meet the above criteria by counting the `id` field in the `cards` table (T1).\n\n4. **Count Cards Without Content Warnings**: For each card, check if the `hasContentWarning` field in the `cards` table (T1) is 0 (indicating no content warning). Sum these cases to get the count of cards without content warnings.\n\n5. **Calculate the Percentage**: Divide the count of cards without content warnings by the total count of cards, then multiply by 100 to convert the result into a percentage.\n\n6. **Output the Result**: The final result is the calculated percentage of cards without content warnings among the filtered set."
        ]
    },
    "944": {
        "sql": "WITH race_data AS (\n    SELECT \n        r.raceId,\n        r.name AS race_name,\n        r.year,\n        r.circuitId\n    FROM \n        races r\n    JOIN \n        circuits c ON r.circuitId = c.circuitId\n    WHERE \n        r.year = 2008 AND c.name = 'Albert Park Grand Prix Circuit'\n),\nchampion_time AS (\n    SELECT \n        res.time AS champion_time\n    FROM \n        results res\n    JOIN \n        race_data rd ON res.raceId = rd.raceId\n    WHERE \n        res.positionOrder = 1 AND res.time IS NOT NULL\n),\nlast_driver_time AS (\n    SELECT \n        res.time AS last_time\n    FROM \n        results res\n    JOIN \n        race_data rd ON res.raceId = rd.raceId\n    WHERE \n        res.positionOrder = (SELECT MAX(positionOrder) FROM results WHERE raceId = rd.raceId) AND res.time IS NOT NULL\n)\nSELECT \n    ((last_time * 100) / (champion_time + last_time)) AS percentage_faster\nFROM \n    champion_time, last_driver_time;",
        "question": "How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "WITH time_in_seconds AS ( SELECT T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6) AS REAL) ELSE CAST(SUBSTR(T1.time, 2) AS REAL) END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL AND T2.year = 2008 ), champion_time AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = 1), last_driver_incremental AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds) ) SELECT (CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)",
        "explain": "how much faster in percentage = divide(subtract(incremental time, champion time), last_driver time) * 100; last driver finished time = incremental time + champion time; only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null",
        "solution": [
            "To determine how much faster in percentage the champion was than the driver who finished last in the 2008 Australian Grand Prix, follow these steps:\n\n1. **Extract and Convert Times to Seconds**:\n   - For the champion (positionOrder = 1), convert their time from the format `H:MM:SS` to total seconds. This involves:\n     - Extracting the hour part (first character), multiplying by 3600.\n     - Extracting the minute part (characters 3-4), multiplying by 60.\n     - Extracting the second part (from character 6 onwards) and adding it.\n   - For all other drivers, their time is already in seconds (as an incremental value), so extract it directly from the second character onwards.\n\n2. **Filter Data**:\n   - Retrieve results for the 2008 Australian Grand Prix where the time is not null.\n\n3. **Identify Champion and Last Driver**:\n   - The champion is the driver with `positionOrder = 1`.\n   - The last driver is the one with the highest `positionOrder` value in the results.\n\n4. **Calculate Percentage Difference**:\n   - Compute the percentage by which the champion's time is faster than the last driver's time using the formula:\n     ```\n     (Last Driver's Time * 100) / (Champion's Time + Last Driver's Time)\n     ```\n   - This formula ensures the result represents the percentage difference in speed.\n\nThis process mirrors the SQL query's logic, ensuring the same calculations and data filtering are applied.",
            "To determine how much faster in percentage the champion was than the driver who finished last in the 2008 Australian Grand Prix, follow these detailed steps:\n\n1. **Extract and Convert Times to Seconds**: \n   - For the champion (positionOrder = 1), convert their time from the format `H:MM:SS` to total seconds. This involves:\n     - Extracting the hour part (first character), multiplying by 3600.\n     - Extracting the minute part (characters 3-4), multiplying by 60.\n     - Extracting the second part (from character 6 onwards) and adding it.\n   - For all other drivers, their time is already in seconds (as an incremental value), so extract it directly from the second character onwards.\n\n2. **Filter Data**: \n   - Retrieve results for the 2008 Australian Grand Prix where the time is not null.\n\n3. **Identify Champion and Last Driver**: \n   - The champion is the driver with `positionOrder = 1`.\n   - The last driver is the one with the highest `positionOrder` value in the results.\n\n4. **Calculate Percentage Difference**: \n   - Compute the percentage by which the champion's time is faster than the last driver's time using the formula:\n     ```\n     (Last Driver's Time * 100) / (Champion's Time + Last Driver's Time)\n     ```\n   - This formula ensures the result represents the percentage difference in speed.\n\nThis process mirrors the SQL query's logic, ensuring the same calculations and data filtering are applied."
        ]
    },
    "812": {
        "sql": "SELECT s.full_name\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE c.colour = 'Blue'\nLIMIT 5;",
        "question": "List down at least five full names of superheroes with blue eyes.",
        "db_id": "superhero",
        "res": 0,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5",
        "explain": "blue eyes refers to colour.colour = 'Blue' WHERE eye_colour_id = colour.id; Name of superheroes refers to superhero_name;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join Tables**: The `superhero` table (referred to as T1) is joined with the `colour` table (referred to as T2) using the condition `T1.eye_colour_id = T2.id`. This links each superhero to their eye color.\n\n2. **Filter by Color**: The joined data is filtered to include only those records where the `colour` column in the `colour` table (T2) has the value 'Blue'. This ensures only superheroes with blue eyes are considered.\n\n3. **Select Superhero Names**: From the filtered results, the `superhero_name` column from the `superhero` table (T1) is selected to retrieve the names of the superheroes.\n\n4. **Limit Results**: The results are limited to at least five records to meet the requirement of listing down at least five full names of superheroes with blue eyes.\n\nThis sequence of operations ensures that the query retrieves the desired information accurately and efficiently.",
            "To solve the question, the following detailed operations are performed on the database:\n\n1. **Table Selection**: The `superhero` table (referred to as T1) and the `colour` table (referred to as T2) are selected for the query. These tables contain the necessary data about superheroes and their eye colors.\n\n2. **Join Operation**: An inner join is performed between the `superhero` table (T1) and the `colour` table (T2) using the condition `T1.eye_colour_id = T2.id`. This operation links each superhero to their corresponding eye color in the `colour` table.\n\n3. **Filtering by Eye Color**: The joined data is filtered to include only those records where the `colour` column in the `colour` table (T2) has the exact value 'Blue'. This ensures that only superheroes with blue eyes are included in the results.\n\n4. **Projection of Superhero Names**: From the filtered dataset, the `superhero_name` column from the `superhero` table (T1) is projected (selected) to retrieve the names of the superheroes.\n\n5. **Result Limitation**: The results are limited to exactly five records using the `LIMIT 5` clause. This ensures that the query returns at least five full names of superheroes with blue eyes, as required by the question.\n\nThis sequence of operations ensures that the query accurately retrieves the desired information while adhering to the constraints specified in the question."
        ]
    },
    "846": {
        "sql": "SELECT d.driverRef\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 20 AND q.q1 IS NOT NULL\nORDER BY q.q1 DESC\nLIMIT 5;",
        "question": "Please list the reference names of the drivers who are eliminated in the first period in race number 20.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.driverRef FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 20 ORDER BY T1.q1 DESC LIMIT 5",
        "explain": "driver reference name refers to driverRef; first qualifying period refers to q1; drivers who are eliminated in the first qualifying period refers to 5 drivers with MAX(q1); race number refers to raceId;",
        "solution": []
    },
    "191": {
        "sql": "SELECT COUNT(*) AS loan_account_count\nFROM loan\nJOIN account ON loan.account_id = account.account_id\nWHERE loan.duration = 24\nAND account.frequency = 'POPLATEK TYDNE';",
        "question": "How many loan accounts are for pre-payment of duration of 24 months with weekly issuance of statement.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.duration = 24 AND T1.frequency = 'POPLATEK TYDNE'",
        "explain": "Frequency = 'POPLATEK TYDNE' referes to weekly statement",
        "solution": []
    },
    "540": {
        "sql": "SELECT p.Title\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie'\nORDER BY p.ViewCount DESC\nLIMIT 1;",
        "question": "What is the title of the post that is owned by csgillespie and has the highest popularity?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' ORDER BY T1.ViewCount DESC LIMIT 1",
        "explain": "\"csgillespie\" is the DisplayName of user; highest popularity refers to Max(ViewCount)",
        "solution": []
    },
    "530": {
        "sql": "SELECT DISTINCT T1.frameVersion, T1.name, \n       CASE WHEN T2.status = 'Banned' THEN 'Banned' ELSE 'NO' END AS banned_status\nFROM cards T1\nLEFT JOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Allen Williams';",
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "explain": "frame styles refers to frameVersion; cards Allen Williams worked on refers to artist = 'Allen Williams'; banned cards refers to status = 'Banned'",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Select Distinct Frame Styles and Cards**: The query retrieves distinct frame versions (`frameVersion`) and names (`name`) of cards from the `cards` table (aliased as `T1`).\n\n2. **Filter by Artist**: The query filters the results to only include cards where the artist is 'Allen Williams'.\n\n3. **Join with Legalities Table**: The query joins the `cards` table with the `legalities` table (aliased as `T2`) using the `uuid` field to check the legality status of each card.\n\n4. **Check for Banned Cards**: For each card, the query checks if its status in the `legalities` table is 'Banned'. If it is, the card's name is returned; otherwise, 'NO' is returned.\n\n5. **Output**: The final output includes the frame version, card name, and a column indicating whether the card is banned ('Banned' if true, 'NO' otherwise).\n\nThis ensures that all frame styles and cards worked on by Allen Williams are listed, along with any banned cards among them."
        ]
    },
    "1322": {
        "sql": "SELECT COUNT(*) AS meeting_event_count\nFROM (\n    SELECT T1.event_id\n    FROM event T1\n    JOIN attendance T2 ON T1.event_id = T2.link_to_event\n    GROUP BY T1.event_id\n    HAVING COUNT(T2.link_to_event) > 10\n) AS high_attendance_events\nJOIN event ON high_attendance_events.event_id = event.event_id\nWHERE event.type = 'Meeting';",
        "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
        "explain": "meetings events refers to type = 'Meeting'; attended by more than 10 members refers to COUNT(event_id) > 10",
        "solution": [
            "To solve the question, we need to find the number of events attended by more than 10 members of the Student_Club that are not meetings. Here are the steps to achieve this:\n\n1. **Join the `event` and `attendance` tables**: Link the `event` table (aliased as `T1`) with the `attendance` table (aliased as `T2`) using the `event_id` from `T1` and `link_to_event` from `T2`.\n\n2. **Group the results by `event_id`**: This allows us to count the number of attendees for each event.\n\n3. **Filter for events with more than 10 attendees**: Use the `HAVING` clause to include only those events where the count of `link_to_event` (i.e., attendees) exceeds 10.\n\n4. **Exclude meetings**: Subtract (using `EXCEPT`) all events where the `type` is 'Meeting' from the results obtained in the previous step.\n\n5. **Select the `event_name`**: Finally, retrieve the names of the events that meet the criteria.\n\nThis process ensures we only count non-meeting events with high attendance.",
            "To solve the question, we need to find the number of events attended by more than 10 members of the Student_Club that are meetings. Here are the detailed steps to achieve this:\n\n1. **Join the `event` and `attendance` tables**: Link the `event` table (aliased as `T1`) with the `attendance` table (aliased as `T2`) using the `event_id` from `T1` and `link_to_event` from `T2`. This ensures we have a combined dataset of events and their respective attendances.\n\n2. **Group the results by `event_id`**: Grouping by `event_id` allows us to aggregate the attendance data for each event, enabling us to count the number of attendees per event.\n\n3. **Filter for events with more than 10 attendees**: Use the `HAVING` clause to include only those events where the count of `link_to_event` (i.e., the number of attendees) exceeds 10. This ensures we focus on events with high attendance.\n\n4. **Select the `event_name`**: Retrieve the names of the events that meet the criteria of having more than 10 attendees.\n\n5. **Exclude non-meeting events**: Subtract (using `EXCEPT`) all events where the `type` is not 'Meeting' from the results obtained in the previous step. This ensures we only count events that are meetings.\n\nThis process ensures we accurately count the number of meeting events with high attendance."
        ]
    },
    "264": {
        "sql": "SELECT molecule_id, label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "question": "What are the labels for TR000, TR001 and TR002?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
        "explain": "TR000, TR001 and TR002 are molecule id; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "236": {
        "sql": "SELECT b.bond_type, c.atom_id, c.atom_id2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.bond_id = 'TR001_6_9';",
        "question": "What are the bond type and the atoms of the bond ID of TR001_6_9?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_id = 'TR001_6_9'",
        "explain": "atoms refer to atom_id or atom_id2",
        "solution": []
    },
    "120": {
        "sql": "SELECT a.account_id, a.frequency\nFROM account a\nJOIN district d ON a.district_id = d.district_id\nWHERE d.A3 = 'east Bohemia'\nAND a.date BETWEEN '1995-01-01' AND '2000-12-31';",
        "question": "From Year 1995 to 2000, who are the accounts holders from 'east Bohemia'. State the account ID the frequency of statement issuance.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.account_id, T1.frequency FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000'",
        "explain": "Accounts holder refers to the person who own this account.",
        "solution": []
    },
    "292": {
        "sql": "SELECT atom_id FROM atom WHERE molecule_id BETWEEN 'TR010' AND 'TR050' AND element = 'c';",
        "question": "Identify the atoms belong to the molecule with ID between TR010 to TR050 that contain the element carbon.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'c'",
        "explain": "carbon refers to element = 'c'; between TR010 to TR050 refers to substr(molecule_id, 3, 3)>=10 AND substr(molecule_id, 3, 3) <= 50",
        "solution": [
            "To identify the atoms that belong to molecules with IDs ranging from 'TR010' to 'TR050' and contain the element carbon, perform the following steps:\n\n1. Access the 'atom' table in the database.\n2. Filter the records to include only those where the 'molecule_id' falls within the range 'TR010' to 'TR050'.\n3. Further filter these records to include only those where the 'element' is 'c' (carbon).\n4. Retrieve the 'atom_id' values from the filtered records.\n\nThis process ensures that only the relevant atoms are selected based on the specified criteria."
        ]
    },
    "582": {
        "sql": "SELECT DISTINCT p.Title\nFROM posts p\nJOIN postHistory ph ON p.Id = ph.PostId\nJOIN users u ON ph.UserId = u.Id\nWHERE u.DisplayName = 'Vebjorn Ljosa' AND ph.PostHistoryTypeId IS NOT NULL;",
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "explain": "\"Vebjorn Ljosa\" is the DisplayName; last edited refers to LastEditorUserId",
        "solution": []
    },
    "525": {
        "sql": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted');",
        "question": "Find the uuid of cards in which the old school format is restricted or banned.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')",
        "explain": "old school format refers to format = 'oldschool'; restricted or banned refers to status = 'banned' or 'restricted'",
        "solution": [
            "To find the UUIDs of cards that are either restricted or banned in the old school format, follow these steps:\n\n1. **Access the Legalities Table**: The data is stored in a table named `legalities`.\n2. **Filter by Format**: Narrow down the records to only those where the `format` column has the value 'oldschool'.\n3. **Filter by Status**: Further filter these records to include only those where the `status` column is either 'Banned' or 'Restricted'.\n4. **Retrieve UUIDs**: From the filtered records, extract the values from the `uuid` column.\n\nThis process ensures that you get all UUIDs of cards that are either banned or restricted in the old school format."
        ]
    },
    "1100": {
        "sql": "SELECT MAX(pa.overall_rating) AS highest_overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE p.player_name = 'Dorlan Pabon';",
        "question": "What is the highest overall rating received by Dorlan Pabon?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT MAX(t2.overall_rating) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Dorlan Pabon'",
        "explain": "Dorlan Pabon refers to T2.player_name = 'Dorlan Pabon'; highest overall rating refers to MAX(overall_rating)",
        "solution": []
    },
    "647": {
        "sql": "SELECT b.Name \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE u.Location = 'North Pole' \nAND strftime('%Y', b.Date) = '2011';",
        "question": "Provide the badge names received in 2011 for the user whose location is in the North Pole.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE STRFTIME('%Y', T2.Date) = '2011' AND T1.Location = 'North Pole'",
        "explain": "received in 2011 refers to year(Date) = 2011;",
        "solution": []
    },
    "914": {
        "sql": "SELECT COUNT(*) FROM drivers WHERE code IS NULL OR code = '';",
        "question": "How many drivers don't have a code?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) - COUNT(CASE WHEN code IS NOT NULL THEN code END) FROM drivers",
        "explain": "don't have a code refers to code is null",
        "solution": []
    },
    "257": {
        "sql": "SELECT c.atom_id2\nFROM connected c\nJOIN atom a ON c.atom_id = a.atom_id\nWHERE a.element = 's';",
        "question": "List down atom id2 for atoms with element sulfur.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'",
        "explain": "element sulfur refers to element = 's'",
        "solution": []
    },
    "427": {
        "sql": "SELECT DISTINCT st.language FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.code = 'ARC';",
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "explain": "known as Archenemy refers to mcmName = 'Archenemy'; having the code ARC refers to setCode = 'ARC'",
        "solution": []
    },
    "383": {
        "sql": "SELECT COUNT(*) AS banned_white_border_cards\nFROM legalities\nJOIN cards ON legalities.uuid = cards.uuid\nWHERE legalities.status = 'Banned' AND cards.borderColor = 'white';",
        "question": "How many of the banned cards are white border?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Banned' AND T1.borderColor = 'white'",
        "explain": "banned card refers to status = 'Banned'; white border refers to borderColor = 'white';",
        "solution": []
    },
    "241": {
        "sql": "SELECT COUNT(*) FROM molecule WHERE label = '-';",
        "question": "How many of the molecules are not carcinogenic?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '-'",
        "explain": "label = '-' means molecules are non-carcinogenic",
        "solution": []
    },
    "850": {
        "sql": "SELECT r.name AS race_name\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Germany';",
        "question": "Please give the name of the race held on the circuits in Germany.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "explain": "Germany is a name of country;",
        "solution": []
    },
    "1093": {
        "sql": "SELECT AVG(t2.overall_rating) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) < '1986'",
        "question": "What is the average overall rating of the players born before the year 1986?",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT SUM(t2.overall_rating) / COUNT(t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) < '1986'",
        "explain": "average overall rating = DIVIDE(SUM(overall_rating), COUNT(id)); born before the year 1986 refers to strftime('%Y', birthday) < '1986';",
        "solution": [
            "To find the average overall rating of players born before the year 1986, follow these steps:\n\n1. **Join the Tables**: Combine the \"Player\" table (referred to as `t1`) and the \"Player_Attributes\" table (referred to as `t2`) using the `player_api_id` field. This ensures that each player's attributes are linked to their personal details.\n\n2. **Filter by Birth Year**: From the joined data, filter out only those players whose birth year (extracted from the `birthday` field in `t1`) is before 1986. This is done by checking the first four characters of the `birthday` string (which represent the year) and comparing it to '1986'.\n\n3. **Calculate the Average**: For the filtered players, compute the average overall rating by dividing the sum of all `overall_rating` values (from `t2`) by the total number of players (counted using `t1.id`).\n\nThe result will be the average overall rating of players born before 1986.",
            "To determine the average overall rating of players born before the year 1986, the following steps are executed:\n\n1. **Table Join**: The \"Player\" table (aliased as `t1`) is joined with the \"Player_Attributes\" table (aliased as `t2`) using the `player_api_id` field. This ensures that each player's attributes are correctly matched with their personal details.\n\n2. **Filtering by Birth Year**: From the joined dataset, only players whose birth year is before 1986 are selected. This is achieved by extracting the first four characters of the `birthday` field in `t1` (representing the year) and comparing it to the string '1986'. Players with a birth year earlier than 1986 are included in the result.\n\n3. **Calculation of Average Rating**: The average overall rating is computed by dividing the sum of all `overall_rating` values (from `t2`) by the total count of players (counted using `t1.id`). This yields the desired average rating for the specified group of players.\n\nThe SQL query for this operation is:\n```sql\nSELECT SUM(t2.overall_rating) / COUNT(t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) < '1986'\n```"
        ]
    },
    "783": {
        "sql": "SELECT DISTINCT c.colour AS eye_colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.skin_colour_id = (SELECT id FROM colour WHERE colour = 'Gold');",
        "question": "Provide the eye colours of the heroes whose skin colours are gold.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T3.colour = 'Gold'",
        "explain": "skin colours are gold refers to colour.colour = 'Gold' WHERE skin_colour_id = colour.id;",
        "solution": []
    },
    "702": {
        "sql": "SELECT COUNT(*) FROM posts WHERE Score < 20;",
        "question": "How many posts have a score less than 20?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score < 20",
        "explain": "score less than 20 refers to Score < 20;",
        "solution": []
    },
    "1457": {
        "sql": "WITH avg_expense_cost AS (\n    SELECT AVG(cost) AS avg_cost\n    FROM expense\n)\nSELECT DISTINCT T3.first_name || ' ' || T3.last_name AS full_name, T3.phone\nFROM expense T1\nJOIN budget T2 ON T1.link_to_budget = T2.budget_id\nJOIN member T3 ON T3.member_id = T1.link_to_member\nCROSS JOIN avg_expense_cost\nWHERE T1.cost > avg_expense_cost.avg_cost;",
        "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
        "db_id": "student_club",
        "res": 0,
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
        "explain": "full name refers to first_name, last_name; contact number refers to phone; had spent more than average on each expense refers to cost > AVG(cost)",
        "solution": [
            "To solve the question, we need to find the full name and contact number of members who had to spend more than the average amount on each expense. Here are the steps to achieve this:\n\n1. **Calculate the Average Expense Cost**: First, compute the average cost of all expenses by joining the `expense` table with the `budget` and `member` tables. This gives the baseline average amount spent on expenses.\n\n2. **Identify Members with Above-Average Expenses**: Next, filter the `expense` table to include only those records where the cost is greater than the calculated average. This involves joining the `expense` table with the `budget` and `member` tables again to ensure the correct linkage.\n\n3. **Retrieve Member Details**: For each expense that meets the above-average criterion, retrieve the corresponding member's first name, last name, and phone number from the `member` table.\n\n4. **Ensure Distinct Results**: Since a member might have multiple expenses above the average, use `DISTINCT` to avoid duplicate entries in the final result.\n\nThe final output will list the full names and contact numbers of members who spent more than the average on their expenses.",
            "To solve the question, we need to find the full name and contact number of members who had to spend more than the average amount on each expense. Here are the detailed steps to achieve this:\n\n1. **Calculate the Average Expense Cost**: \n   - Join the `expense` table (aliased as `T1`) with the `budget` table (aliased as `T2`) using the condition `T1.link_to_budget = T2.budget_id`.\n   - Further join the result with the `member` table (aliased as `T3`) using the condition `T3.member_id = T1.link_to_member`.\n   - Compute the average cost of all expenses from this joined dataset using the `AVG(T1.cost)` function.\n\n2. **Identify Members with Above-Average Expenses**: \n   - Use the same join conditions as above to link the `expense`, `budget`, and `member` tables.\n   - Filter the records to include only those where the `T1.cost` is greater than the average cost calculated in the previous step.\n\n3. **Retrieve Member Details**: \n   - From the filtered dataset, select the `first_name`, `last_name`, and `phone` columns from the `member` table (aliased as `T3`).\n\n4. **Ensure Distinct Results**: \n   - Apply the `DISTINCT` keyword to the selected columns to eliminate duplicate entries, ensuring each member appears only once in the final result.\n\nThe final output will list the distinct full names and contact numbers of members whose expenses exceed the average expense cost."
        ]
    },
    "1004": {
        "sql": "SELECT SUM(T1.wins) AS total_wins, T2.forename || ' ' || T2.surname AS full_name\nFROM driverStandings T1\nJOIN drivers T2 ON T1.driverId = T2.driverId\nORDER BY T2.dob ASC\nLIMIT 1;",
        "question": "How many wins was achieved by the oldest racer? Indicate his/her full name.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT SUM(T1.wins),T2.forename, T2.surname FROM driverStandings AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId ORDER BY T2.dob ASC LIMIT 1",
        "explain": "oldest racer refers to MIN(dob); full name refers to forename, surname.",
        "solution": [
            "To find out how many wins were achieved by the oldest racer and indicate his/her full name, follow these steps:\n\n1. **Join the Tables**: Combine the `driverStandings` table (aliased as `T1`) and the `drivers` table (aliased as `T2`) using the `driverId` field as the common key. This links each driver's standings to their personal details.\n\n2. **Sort by Date of Birth**: Arrange the combined records in ascending order based on the `dob` (date of birth) field from the `drivers` table. This ensures the oldest racer appears first in the list.\n\n3. **Limit the Results**: Retrieve only the first record from the sorted list, which corresponds to the oldest racer.\n\n4. **Calculate Total Wins**: Sum the `wins` field from the `driverStandings` table for the selected racer to get the total number of wins.\n\n5. **Display Full Name**: Extract the `forename` and `surname` fields from the `drivers` table to display the full name of the oldest racer.\n\nThe final output will show the total wins and the full name of the oldest racer.",
            "To determine how many wins were achieved by the oldest racer and to indicate his/her full name, the following steps are executed in the SQL query:\n\n1. **Table Join**: The `driverStandings` table (aliased as `T1`) is joined with the `drivers` table (aliased as `T2`) using the `driverId` field as the common key. This ensures that each driver's standings are linked to their personal details.\n\n2. **Sorting by Date of Birth**: The combined records are sorted in ascending order based on the `dob` (date of birth) field from the `drivers` table. This places the oldest racer at the top of the list.\n\n3. **Limiting Results**: Only the first record from the sorted list is selected, which corresponds to the oldest racer.\n\n4. **Summing Wins**: The `wins` field from the `driverStandings` table is summed for the selected racer to calculate the total number of wins.\n\n5. **Displaying Full Name**: The `forename` and `surname` fields from the `drivers` table are retrieved to display the full name of the oldest racer.\n\nThe final output of the query will show the total wins and the full name of the oldest racer."
        ]
    },
    "223": {
        "sql": "SELECT atom_id FROM connected WHERE bond_id = 'TR000_2_5';",
        "question": "What are the atom IDs of the bond TR000_2_5?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.atom_id FROM connected AS T WHERE T.bond_id = 'TR000_2_5'",
        "explain": "TR000_2_5 is the bond id",
        "solution": [
            "To find the atom IDs of the bond 'TR000_2_5', you need to query the 'connected' table. Specifically, you should retrieve the 'atom_id' column from the 'connected' table where the 'bond_id' column matches the value 'TR000_2_5'."
        ]
    },
    "1517": {
        "sql": "SELECT T2.Segment FROM transactions_1k T1 JOIN customers T2 ON T1.CustomerID = T2.CustomerID ORDER BY T1.Date ASC LIMIT 1;",
        "question": "For the earliest customer, what segment did he/she have?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID ORDER BY Date ASC LIMIT 1",
        "explain": "",
        "solution": [
            "To find the segment of the earliest customer, follow these steps:\n1. Join the `transactions_1k` table (aliased as `T1`) with the `customers` table (aliased as `T2`) using the `CustomerID` field to link the records.\n2. Sort the combined records by the `Date` field in ascending order to ensure the earliest transaction appears first.\n3. Limit the results to the first record to retrieve only the earliest customer.\n4. Select the `Segment` field from the `customers` table (`T2`) for this earliest customer."
        ]
    },
    "536": {
        "sql": "SELECT COUNT(*) \nFROM users \nWHERE Views > 10 \nAND strftime('%Y', CreationDate) > '2013';",
        "question": "How many users with more than 10 views created their account after the year 2013?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM users WHERE STRFTIME('%Y', CreationDate) > '2013' AND Views > 10",
        "explain": "more than 10 views refers to Views > 10; created after the year 2013 refers to year (CreationDate) > 2013",
        "solution": []
    },
    "1479": {
        "sql": "SELECT SUBSTR(T2.Date, 1, 4) AS Year, SUM(T2.Consumption) AS TotalConsumption\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK'\nGROUP BY Year\nORDER BY TotalConsumption DESC\nLIMIT 1;",
        "question": "Which year recorded the most consumption of gas paid in CZK?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "explain": "The first 4 strings of the Date values in the yearmonth table can represent year.",
        "solution": [
            "To determine the year with the highest gas consumption paid in CZK, follow these steps:\n\n1. **Join the Tables**: Combine the `customers` table (referred to as `T1`) with the `yearmonth` table (referred to as `T2`) using the `CustomerID` field as the common key.\n\n2. **Filter by Currency**: From the joined data, filter out records where the currency is 'CZK'.\n\n3. **Extract the Year**: For each record, extract the year from the `Date` field in the `yearmonth` table. This is done by taking the first four characters of the `Date` string.\n\n4. **Group by Year**: Group the filtered and processed data by the extracted year.\n\n5. **Calculate Total Consumption**: For each year, calculate the sum of the `Consumption` values from the `yearmonth` table.\n\n6. **Order by Consumption**: Sort the grouped data in descending order based on the total consumption calculated in the previous step.\n\n7. **Select the Top Year**: Retrieve the year at the top of the sorted list, which represents the year with the highest gas consumption paid in CZK.\n\nThis process ensures that the result is the year with the most gas consumption recorded in CZK.",
            "To determine the year with the highest gas consumption paid in CZK, follow these detailed steps:\n\n1. **Join the Tables**: Perform an inner join between the `customers` table (aliased as `T1`) and the `yearmonth` table (aliased as `T2`) using the `CustomerID` field as the joining condition. This ensures that only records with matching `CustomerID` in both tables are included.\n\n2. **Filter by Currency**: From the joined dataset, filter out all records where the `Currency` field in the `customers` table (`T1`) is not equal to 'CZK'. This isolates the data to only those transactions paid in CZK.\n\n3. **Extract the Year**: For each remaining record, extract the year from the `Date` field in the `yearmonth` table (`T2`). This is achieved by taking the first four characters of the `Date` string, which represents the year in the format 'YYYY'.\n\n4. **Group by Year**: Group the filtered and processed data by the extracted year. This step aggregates all records that share the same year.\n\n5. **Calculate Total Consumption**: For each group (year), compute the sum of the `Consumption` values from the `yearmonth` table (`T2`). This gives the total gas consumption for each year.\n\n6. **Order by Consumption**: Sort the grouped data in descending order based on the total consumption calculated in the previous step. This places the year with the highest consumption at the top of the list.\n\n7. **Select the Top Year**: Retrieve the first record from the sorted list, which corresponds to the year with the highest gas consumption paid in CZK. This is done using the `LIMIT 1` clause to ensure only the top result is returned.\n\nThis method ensures that the result accurately reflects the year with the most gas consumption recorded in CZK, adhering strictly to the logic of the provided SQL query."
        ]
    },
    "1088": {
        "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.volleys > 70 AND pa.dribbling > 70;",
        "question": "Please list the names of the players whose volley score and dribbling score are over 70.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.volleys > 70 AND t2.dribbling > 70",
        "explain": "volley score are over 70 refers to volleys > 70; dribbling score refers to dribbling are over 70 refers to dribbling > 70;",
        "solution": []
    },
    "497": {
        "sql": "SELECT s.type \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Huiti\u00e8me \u00e9dition';",
        "question": "List the expansion type of the set \"Huiti\u00e8me \u00e9dition\".",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition' )",
        "explain": "the set \"Huiti\u00e8me \u00e9dition\" refers to translation = 'Huiti\u00e8me \u00e9dition'; expansion type refers to type",
        "solution": []
    },
    "1270": {
        "sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nJOIN Examination E ON P.ID = E.ID\nWHERE L.SC170 IN('negative', '0') \nAND P.SEX = 'F' \nAND E.Symptoms IS NULL;",
        "question": "Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.SC170 = 'negative' OR T2.SC170 = '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL",
        "explain": "normal anti-scl70 refers to SC170 IN('negative', '0'); female refers to Sex = 'F'; does not have any symptom refers to symptoms IS NULL; Should consider DISTINCT in the final result;",
        "solution": []
    },
    "467": {
        "sql": "SELECT s.baseSetSize \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE st.translation = 'Hauptset Zehnte Edition';",
        "question": "How many cards are there in the base set of \"Hauptset Zehnte Edition\"?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "explain": "\"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; number of cards refers to baseSetSize",
        "solution": []
    },
    "166": {
        "sql": "SELECT COUNT(*) \nFROM account \nWHERE district_id = (SELECT district_id FROM district WHERE A2 = 'Jesenik');",
        "question": "How many of the accounts are from Jesenik district?",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A2 = 'Jesenik'",
        "explain": "",
        "solution": []
    },
    "966": {
        "sql": "SELECT COUNT(DISTINCT driverId) FROM driverStandings WHERE raceId = 18;",
        "question": "How many driver participated in race ID number 18?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18",
        "explain": "",
        "solution": [
            "To determine how many drivers participated in race ID number 18, the solution involves counting the number of unique driver IDs recorded in the 'driverStandings' table where the 'raceId' is equal to 18. This is achieved by using the SQL function COUNT(driverId) on the filtered dataset."
        ]
    },
    "1120": {
        "sql": "SELECT SUM(t2.away_team_goal) AS total_away_goals\nFROM Player t1\nJOIN Match t2 ON t1.player_api_id = t2.away_player_5\nWHERE t1.player_name IN ('Daan Smith', 'Filipe Ferreira');",
        "question": "Sum up the away team goal scored by both Daan Smith and Filipe Ferreira.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.away_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_5 WHERE t1.player_name IN ('Daan Smith', 'Filipe Ferreira')",
        "explain": "Daan Smith refers to player_name = 'Daan Smith'; Filipe Ferreira refers to player_name = 'Filipe Ferreira'",
        "solution": [
            "To solve the question, the database performs the following operations:\n\n1. **Join Tables**: It joins the `Player` table (aliased as `t1`) with the `match` table (aliased as `t2`) using the condition `t1.player_api_id = t2.away_player_5`. This links each player to their corresponding match records where they played as the fifth away player.\n\n2. **Filter Players**: It filters the joined records to include only those players whose names are either 'Daan Smith' or 'Filipe Ferreira' using the condition `t1.player_name IN ('Daan Smith', 'Filipe Ferreira')`.\n\n3. **Sum Goals**: It calculates the sum of the `away_team_goal` values from the filtered records in the `match` table (`t2.away_team_goal`). This gives the total goals scored by the away team in matches where either Daan Smith or Filipe Ferreira was the fifth away player.\n\nThe final result is the sum of away team goals scored by both players in the specified matches."
        ]
    },
    "305": {
        "sql": "SELECT b.bond_id, c.atom_id, c.atom_id2 FROM bond b JOIN connected c ON b.bond_id = c.bond_id WHERE b.bond_type = '-'",
        "question": "Name all bonds with single bond types and what atoms are connected to the molecules.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T1.bond_id, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "explain": "single bond refers to bond_type = '-';",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select the bond_id, atom_id, and atom_id2**: These columns are retrieved from the database to identify the bonds and the atoms they connect.\n\n2. **Filter bonds with a single bond type**: Only bonds where the `bond_type` is a single bond (represented by '-') are included in the results.\n\n3. **Join the `bond` and `connected` tables**: The `bond` table is joined with the `connected` table using the `bond_id` column to link each bond to the atoms it connects.\n\n4. **Return the results**: The final output includes the `bond_id` of the single bonds and the `atom_id` and `atom_id2` of the atoms connected by these bonds."
        ]
    },
    "512": {
        "sql": "SELECT COUNT(*) FROM cards WHERE (power IS NULL OR power = '*') AND hasFoil = 0 AND duelDeck = 'a';",
        "question": "How many cards with unknown power that can't be found in foil is in duel deck A?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE hasFoil = 0 AND duelDeck = 'a'",
        "explain": "unknown power refers to power IS NULL or power = '*'; can't be found in foil refers to hasFoil = 0; duel deck A refers to duelDeck = 'a'",
        "solution": []
    },
    "766": {
        "sql": "SELECT T1.full_name\nFROM superhero T1\nJOIN hero_attribute T2 ON T1.id = T2.hero_id\nJOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Strength'\nORDER BY T2.attribute_value DESC\nLIMIT 1;",
        "question": "What is the hero's full name with the highest attribute in strength?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "explain": "highest attribute in strength refers to MAX(attribute_value) WHERE attribute_name = 'strength';",
        "solution": [
            "To find the hero's full name with the highest attribute in strength, follow these steps:\n\n1. **Join the Tables**: Combine the `superhero` table (aliased as `T1`), the `hero_attribute` table (aliased as `T2`), and the `attribute` table (aliased as `T3`). The join conditions are:\n   - `T1.id` (the hero's ID in the `superhero` table) matches `T2.hero_id` (the hero's ID in the `hero_attribute` table).\n   - `T2.attribute_id` (the attribute ID in the `hero_attribute` table) matches `T3.id` (the attribute ID in the `attribute` table).\n\n2. **Filter for Strength Attribute**: Only include rows where the `attribute_name` in the `attribute` table (`T3.attribute_name`) is 'Strength'.\n\n3. **Sort by Attribute Value**: Order the results by the `attribute_value` in the `hero_attribute` table (`T2.attribute_value`) in descending order to prioritize the highest values.\n\n4. **Limit the Result**: Retrieve only the top result (the hero with the highest strength attribute value) by applying a limit of 1.\n\n5. **Select the Full Name**: Finally, extract the `full_name` from the `superhero` table (`T1.full_name`) for the hero identified in the previous steps."
        ]
    },
    "490": {
        "sql": "SELECT mcmId FROM sets WHERE code = 'SS2';",
        "question": "For the set which had 'SS2' as the code, what is its magic card market id?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT mcmId FROM sets WHERE code = 'SS2'",
        "explain": "magic card market id refers to mcmId",
        "solution": []
    },
    "793": {
        "sql": "SELECT COUNT(*) FROM superhero WHERE race_id = 21 AND gender_id = 1;",
        "question": "Among the superheroes with the race of god/eternal, how many of them are male",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT COUNT(*) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T1.race_id = 21 AND T1.gender_id = 1",
        "explain": "race \"god/eternal\" refers to race_id = 21; male refers to gender.id = 1",
        "solution": []
    },
    "650": {
        "sql": "SELECT T1.LastAccessDate, T1.Location\nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T2.Name = 'outliers';",
        "question": "Describe the last accessed date and location of the users who received the outliers badge.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.LastAccessDate, T1.Location FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'outliers'",
        "explain": "Outliers is the name of the badge;",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Select Data from Users Table**: Retrieve the `LastAccessDate` and `Location` columns from the `users` table (aliased as `T1`).\n\n2. **Join with Badges Table**: Perform an inner join between the `users` table (`T1`) and the `badges` table (aliased as `T2`) using the `Id` column from the `users` table and the `UserId` column from the `badges` table. This ensures that only users who have entries in both tables are considered.\n\n3. **Filter for Outliers Badge**: Apply a filter to the joined data to include only those records where the `Name` column in the `badges` table (`T2`) is equal to 'outliers'.\n\n4. **Return Results**: The final result set includes the `LastAccessDate` and `Location` of users who have received the 'outliers' badge."
        ]
    },
    "771": {
        "sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Flight';",
        "question": "List the name of superheroes with flight power.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Flight'",
        "explain": "name of superheroes refers to superhero_name; flight power refers to power_name = 'Flight';",
        "solution": []
    },
    "680": {
        "sql": "SELECT AVG(Score) AS AverageScore\nFROM posts\nWHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Stephen Turner');",
        "question": "What is the average score of Stephen Turner's posts?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.Score) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Stephen Turner'",
        "explain": "DisplayName = 'Stephen Turner'; average score refers to AVG(Score);",
        "solution": []
    },
    "869": {
        "sql": "SELECT c.url\nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nWHERE cr.raceId = 9\nORDER BY cr.points DESC\nLIMIT 1;",
        "question": "For the constructor which got the highest point in the race No. 9 , what is its introduction website?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T2.url FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 9 ORDER BY T1.points DESC LIMIT 1",
        "explain": "race number refers to raceId; constructor which got the highest point refers to MAX(constructorResults.points); introduction website of the constructor refers to url;",
        "solution": []
    },
    "351": {
        "sql": "SELECT DISTINCT c.name FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Japanese';",
        "question": "Name all the cards which have alternative language in Japanese.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'",
        "explain": "Japanese' is the language;",
        "solution": []
    },
    "1204": {
        "sql": "SELECT (STRFTIME('%d', T3.\"Examination Date\") - STRFTIME('%d', T1.\"First Date\")) AS days_before_evaluation\nFROM Patient T1\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T1.ID = 821298;",
        "question": "How long did it take after patient number 821298 arrived at the hospital for the first time before her evaluation began?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT STRFTIME('%d', T3.`Examination Date`) - STRFTIME('%d', T1.`First Date`) FROM Patient AS T1 INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.ID = 821298",
        "explain": "DATEDIFF(`Examination Date`, `First Date`)",
        "solution": [
            "To determine how long it took after patient number 821298 arrived at the hospital for the first time before her evaluation began, follow these steps:\n\n1. **Retrieve the patient's first arrival date**: Access the `Patient` table (referred to as `T1`) and locate the record where the `ID` is 821298. Extract the `First Date` from this record.\n\n2. **Retrieve the patient's examination date**: Access the `Examination` table (referred to as `T3`) and locate the record where the `ID` is 821298. Extract the `Examination Date` from this record.\n\n3. **Calculate the difference in days**: Subtract the day component of the `First Date` from the day component of the `Examination Date` using the `STRFTIME` function to format both dates as days (`%d`). This will give the number of days between the patient's first arrival and the examination.\n\n4. **Return the result**: The result of the subtraction is the number of days it took for the evaluation to begin after the patient's first arrival.",
            "To determine how long it took after patient number 821298 arrived at the hospital for the first time before her evaluation began, follow these detailed steps:\n\n1. **Join the Patient and Examination tables**: Perform an inner join between the `Patient` table (referred to as `T1`) and the `Examination` table (referred to as `T3`) using the `ID` column as the common key. This ensures that only records with matching patient IDs are considered.\n\n2. **Filter for the specific patient**: Apply a filter to the joined tables to select only the record where the `ID` is 821298. This isolates the data for the patient in question.\n\n3. **Extract the day components of the dates**: For the filtered record, use the `STRFTIME` function to format both the `First Date` from the `Patient` table and the `Examination Date` from the `Examination` table as days (`%d`). This converts the dates into their respective day-of-the-month values.\n\n4. **Calculate the difference in days**: Subtract the day component of the `First Date` from the day component of the `Examination Date`. This operation yields the number of days between the patient's first arrival at the hospital and the start of her evaluation.\n\n5. **Return the result**: The result of the subtraction is the final output, representing the duration in days between the patient's arrival and the beginning of her evaluation."
        ]
    },
    "576": {
        "sql": "SELECT u.DisplayName FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Text = 'thank you user93!';",
        "question": "Name the user that commented 'thank you user93!'",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'thank you user93!'",
        "explain": "\"thank you user93\" is the Text of comment; user refers to DisplayName",
        "solution": []
    },
    "707": {
        "sql": "SELECT Text FROM comments WHERE PostId IN ( SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150 ) ORDER BY Score DESC LIMIT 1;",
        "question": "Among the posts with views ranging from 100 to 150, what is the comment with the highest score?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Text FROM comments WHERE PostId IN ( SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150 ) ORDER BY Score DESC LIMIT 1",
        "explain": "views ranging from 100 to 150 refers to ViewCount BETWEEN 100 and 150; comment with the highest score refers to Text where MAX(Score);",
        "solution": [
            "To find the comment with the highest score among posts that have views ranging from 100 to 150, follow these steps:\n\n1. **Identify the Relevant Posts**: First, locate all posts where the view count is between 100 and 150. This is done by querying the `posts` table for records where the `ViewCount` falls within this range.\n\n2. **Retrieve the Comments**: Using the list of post IDs obtained from the first step, query the `comments` table to find all comments associated with these posts.\n\n3. **Sort by Score**: Order the retrieved comments by their `Score` in descending order to prioritize comments with higher scores.\n\n4. **Select the Top Comment**: From the sorted list, select the comment with the highest score (the first one in the list).\n\nThis process ensures that you accurately identify the comment with the highest score from the specified range of post views.",
            "To find the comment with the highest score among posts that have views ranging from 100 to 150, follow these steps:\n\n1. **Filter Posts by View Count**: Query the `posts` table to retrieve all posts where the `ViewCount` is between 100 and 150. This is done using the condition `ViewCount BETWEEN 100 AND 150`.\n\n2. **Extract Post IDs**: From the filtered posts, extract the `Id` values of these posts. These IDs will be used to locate the corresponding comments.\n\n3. **Filter Comments by Post IDs**: Query the `comments` table to retrieve all comments where the `PostId` matches any of the IDs obtained in the previous step. This is done using the condition `PostId IN (list_of_post_ids)`.\n\n4. **Sort Comments by Score**: Order the retrieved comments by their `Score` in descending order (`ORDER BY Score DESC`) to prioritize comments with higher scores.\n\n5. **Select the Top Comment**: Limit the result to the first comment in the sorted list (`LIMIT 1`), which will be the comment with the highest score.\n\nThe final SQL query combines these steps:\n```sql\nSELECT Text FROM comments WHERE PostId IN ( SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150 ) ORDER BY Score DESC LIMIT 1\n```\nThis query ensures that the comment with the highest score from the specified range of post views is accurately identified."
        ]
    },
    "610": {
        "sql": "SELECT T2.Name FROM users T1 INNER JOIN badges T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1;",
        "question": "What are the name of badge that users who have the highest reputation obtained?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1",
        "explain": "highest reputation refers to Max(Reputation); user refers to UserId",
        "solution": [
            "To find the name of the badge obtained by the user with the highest reputation, follow these steps:\n\n1. **Join the Tables**: Combine the `users` table (referred to as `T1`) and the `badges` table (referred to as `T2`) using the `INNER JOIN` operation. The join condition is that the `Id` column in the `users` table matches the `UserId` column in the `badges` table.\n\n2. **Sort by Reputation**: Order the resulting rows from the join operation in descending order based on the `Reputation` column in the `users` table. This ensures that the user with the highest reputation appears first.\n\n3. **Limit the Results**: Retrieve only the first row from the sorted result, which corresponds to the user with the highest reputation.\n\n4. **Select the Badge Name**: From the selected row, extract the value from the `name` column in the `badges` table (`T2.name`), which represents the name of the badge obtained by the user with the highest reputation."
        ]
    },
    "249": {
        "sql": "SELECT T2.element FROM connected T1 JOIN atom T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19';",
        "question": "What are the elements of the atoms of TR144_8_19?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'",
        "explain": "TR144_8_19 is the bond id; ",
        "solution": [
            "To find the elements of the atoms of TR144_8_19, perform the following steps:\n1. Join the 'connected' table (aliased as T1) with the 'atom' table (aliased as T2) using the 'atom_id' field as the common key.\n2. Filter the joined records to only include those where the 'bond_id' in the 'connected' table matches 'TR144_8_19'.\n3. From the filtered records, select the 'element' column from the 'atom' table (T2).\n\nThis will return all elements associated with the atoms connected by the bond TR144_8_19."
        ]
    },
    "1216": {
        "sql": "SELECT DISTINCT T1.ID\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5)\nORDER BY T1.Birthday DESC;",
        "question": "Sort in descending order all patients by birthday for male patient with albumin not within range.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5) ORDER BY T1.Birthday DESC",
        "explain": "male = SEX = 'M'; albumin not within range refers to ALB < = 3.5 or ALB > = 5.5",
        "solution": [
            "To solve the question, the following steps are performed:\n\n1. **Select Distinct Patient IDs**: Retrieve unique patient IDs to ensure no duplicates in the result.\n\n2. **Join Tables**: Combine the `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`) using the patient ID as the joining condition.\n\n3. **Filter by Gender**: Include only male patients by checking the `SEX` column in the `Patient` table (`T1.SEX = 'M'`).\n\n4. **Filter by Albumin Range**: Include patients whose albumin levels (`ALB`) are outside the normal range (either less than or equal to 3.5 or greater than or equal to 5.5). This is done by checking `T2.ALB <= 3.5 OR T2.ALB >= 5.5`.\n\n5. **Sort by Birthday**: Arrange the results in descending order based on the patients' birthdays (`T1.Birthday DESC`).\n\nThe final output is a list of distinct male patient IDs with abnormal albumin levels, sorted by their birthdays in descending order."
        ]
    },
    "851": {
        "sql": "SELECT DISTINCT T1.position FROM constructorStandings T1 INNER JOIN constructors T2 ON T1.constructorId = T2.constructorId WHERE T2.name = 'Renault';",
        "question": "Please list the positions of the circuits built by the constructor Renault.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.position FROM constructorStandings AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T2.name = 'Renault'",
        "explain": "Renault is a name of constructor;",
        "solution": [
            "To list the positions of the circuits built by the constructor Renault, follow these steps:\n\n1. **Identify the relevant tables**: The data is stored in two tables:\n   - `constructorStandings` (aliased as `T1`)\n   - `constructors` (aliased as `T2`)\n\n2. **Join the tables**: Perform an inner join between `constructorStandings` (`T1`) and `constructors` (`T2`) using the `constructorId` field as the common key. This ensures that only records with matching `constructorId` values in both tables are included.\n\n3. **Filter for Renault**: Apply a filter to the `constructors` table (`T2`) to include only records where the `name` field equals 'Renault'.\n\n4. **Select distinct positions**: From the joined and filtered result, select the `position` field from the `constructorStandings` table (`T1`). The `DISTINCT` keyword ensures that each position is listed only once, even if it appears multiple times in the results.\n\nThe final output will be a list of unique positions achieved by circuits built by the constructor Renault."
        ]
    },
    "1018": {
        "sql": "SELECT AVG(p.milliseconds) AS average_pitstop_time_ms\nFROM pitStops p\nJOIN drivers d ON p.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "question": "What was the average time in milliseconds Lewis Hamilton spent at a pit stop during Formula_1 races?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT AVG(milliseconds) FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'",
        "explain": "average time in milliseconds spent at pit stop refers to AVG(milliseconds)",
        "solution": []
    },
    "1050": {
        "sql": "SELECT pa.preferred_foot\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY p.birthday DESC\nLIMIT 1;",
        "question": "What is the preferred foot when attacking of the youngest football player?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday DESC LIMIT 1",
        "explain": "preferred foot when attacking refers to preferred_foot; youngest football player refers to latest birthday;",
        "solution": []
    },
    "1119": {
        "sql": "SELECT SUM(t2.home_team_goal) AS total_home_team_goals\nFROM Player t1\nJOIN \"Match\" t2 ON t1.player_api_id = t2.away_player_9\nWHERE t1.player_name = 'Aaron Lennon';",
        "question": "How many home team goal have been scored by Aaron Lennon?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_9 WHERE t1.player_name = 'Aaron Lennon'",
        "explain": "Aaron Lennon refers to player_name = 'Aaron Lennon'",
        "solution": [
            "To find out how many home team goals have been scored by Aaron Lennon, follow these steps:\n\n1. **Identify the Player**: Locate the player named 'Aaron Lennon' in the `Player` table (referred to as `t1`).\n\n2. **Join with Match Data**: Connect the `Player` table (`t1`) with the `match` table (referred to as `t2`) using the `player_api_id` from the `Player` table and the `away_player_9` field from the `match` table. This join ensures we only consider matches where Aaron Lennon was the away player 9.\n\n3. **Sum Home Team Goals**: For the matches identified in the previous step, sum the values in the `home_team_goal` column from the `match` table (`t2`). This gives the total number of home team goals scored in those matches.\n\n4. **Result**: The result of this operation is the total number of home team goals scored in matches where Aaron Lennon was the away player 9."
        ]
    },
    "1125": {
        "sql": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.finishing = 1\nORDER BY p.birthday ASC\nLIMIT 1;",
        "question": "Among the players with finishing rate of 1, pick the eldest player and state the player's name.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.finishing = 1 ORDER BY t1.birthday ASC LIMIT 1",
        "explain": "eldest player refers to MAX(SUBTRACT(datetime(CURRENT_TIMESTAMP,'localtime'),datetime(birthday))); finishing rate of 1 refers to finishing = 1",
        "solution": []
    },
    "34": {
        "sql": "SELECT (T2.\"Free Meal Count (Ages 5-17)\" / T2.\"Enrollment (Ages 5-17)\") AS \"Free Meal Rate\"\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson';",
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "explain": "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
        "solution": [
            "1. **Joining the schools and enrollment data:**  \n   The query uses an `INNER JOIN` between two tables: `schools` (aliased as T1) and `frpm` (aliased as T2). These tables are linked using the `CDSCode` column, ensuring that each school record is matched with its corresponding enrollment and meal count data.\n\n2. **Filtering for the specific school administrator:**  \n   The query includes a `WHERE` clause to filter the results to only those records where the administrator's first name (`AdmFName1`) is 'Kacey' and the administrator's last name (`AdmLName1`) is 'Gibson'. This narrows down the data to the school run by Kacey Gibson.\n\n3. **Calculating the free meal rate:**  \n   The query calculates the free meal rate for students aged 5\u201317 by dividing the `Free Meal Count (Ages 5-17)` by the `Enrollment (Ages 5-17)`. The `Free Meal Count (Ages 5-17)` is cast to a `REAL` type to ensure accurate division. This ratio represents the proportion of students in the specified age group who receive free meals at the school.\n\n4. **Returning the result:**  \n   The query returns the calculated free meal rate as the final output, providing the answer to the question about the free meal rate at Kacey Gibson's school."
        ]
    },
    "973": {
        "sql": "SELECT T2.driverId, T2.forename, T2.surname, T2.dob, T1.time AS latest_lap_time\nFROM pitStops T1\nJOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982'\nORDER BY T1.time DESC\nLIMIT 10;",
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "explain": "born before 1982 refers to year(dob) < 1982; latest lap time refers to Max(time);",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join Tables**: Combine the `pitStops` table (referred to as `T1`) and the `drivers` table (referred to as `T2`) using the `driverId` field as the common key.\n\n2. **Filter by Nationality**: From the joined tables, filter out only those drivers whose nationality is 'Spanish'.\n\n3. **Filter by Birth Year**: Further filter the results to include only drivers who were born before the year 1982. This is done by extracting the year from the `dob` (date of birth) field and comparing it to '1982'.\n\n4. **Sort by Lap Time**: Order the filtered results by the `time` field in the `pitStops` table in descending order to get the latest lap times first.\n\n5. **Limit Results**: Finally, limit the output to the top 10 records to get the top 10 Spanish drivers who meet the criteria.\n\nThe SQL query ensures that all these steps are executed in sequence to produce the desired result.",
            "To solve the question, the following detailed operations are performed:\n\n1. **Table Join**: The `pitStops` table (aliased as `T1`) is joined with the `drivers` table (aliased as `T2`) using the `driverId` field as the common key. This ensures that each pit stop record is linked to its corresponding driver.\n\n2. **Filter by Nationality**: From the joined tables, only records where the `nationality` field in the `drivers` table (`T2`) is 'Spanish' are retained. This filters out all non-Spanish drivers.\n\n3. **Filter by Birth Year**: The results are further filtered to include only drivers whose birth year (extracted from the `dob` field in the `drivers` table) is before 1982. This is done using the `STRFTIME('%Y', T2.dob) < '1982'` condition.\n\n4. **Sort by Lap Time**: The filtered records are then sorted in descending order based on the `time` field in the `pitStops` table (`T1`). This ensures that the latest lap times appear first.\n\n5. **Limit Results**: The final step limits the output to the top 10 records, providing the list of the top 10 Spanish drivers who were born before 1982 and have the latest lap times.\n\nThe SQL query precisely executes these steps in sequence to produce the desired result."
        ]
    },
    "700": {
        "sql": "SELECT COUNT(*) AS NumberOfPostsWithBountyOver30 FROM votes WHERE BountyAmount >= 30;",
        "question": "Identify the number of posts that offer a bounty amount over 30.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM votes WHERE BountyAmount >= 30",
        "explain": "bounty amount over 30 refers to BountyAmount > = 30;",
        "solution": []
    },
    "1012": {
        "sql": "SELECT T1.position FROM lapTimes T1 JOIN drivers T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.time ASC LIMIT 1;",
        "question": "What was the position of the circuits during Lewis Hamilton's fastest lap in a Formula_1 race?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.position FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.time ASC LIMIT 1",
        "explain": "fastest lap refers to MIN(time)",
        "solution": [
            "To find the position of the circuits during Lewis Hamilton's fastest lap in a Formula 1 race, follow these steps:\n\n1. **Join the Tables**: Combine the `lapTimes` table (referred to as `T1`) with the `drivers` table (referred to as `T2`) using the `driverId` field as the common key.\n\n2. **Filter for Lewis Hamilton**: From the joined tables, filter the records to only include those where the driver's forename is 'Lewis' and the surname is 'Hamilton'.\n\n3. **Sort by Lap Time**: Order the filtered records by the `time` field in ascending order to find the fastest lap (the smallest time value).\n\n4. **Retrieve the Position**: Select the `position` field from the top record (the fastest lap) to get the position of the circuits during Lewis Hamilton's fastest lap.\n\n5. **Limit the Result**: Ensure only the top record (the fastest lap) is returned by applying a limit of 1 to the result set."
        ]
    },
    "953": {
        "sql": "SELECT COUNT(DISTINCT c.constructorId) \nFROM constructors c\nJOIN results r ON c.constructorId = r.constructorId\nWHERE c.nationality = 'French' AND r.laps > 50;",
        "question": "How many French constructors have a lap number of over 50?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "explain": "lap numbers of over 50 refers to laps > 50;",
        "solution": []
    },
    "1442": {
        "sql": "SELECT \n    (COUNT(CASE WHEN b.spent > b.amount THEN 1 END) * 100.0 / COUNT(*)) AS percentage_over_budget\nFROM \n    event e\nJOIN \n    budget b ON e.event_id = b.link_to_event;",
        "question": "What is the percentage of the events that went over budget?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(budget_id) FROM budget",
        "explain": "went over budget refers to remaining < 0; percentage = DIVIDE(SUM(remaining < 0), COUNT(event_id)) * 100",
        "solution": []
    },
    "529": {
        "sql": "SELECT s.name \nFROM sets s \nWHERE s.code IN (\n    SELECT st.setCode \n    FROM set_translations st \n    WHERE st.language = 'Korean' \n    AND st.setCode NOT IN (\n        SELECT st2.setCode \n        FROM set_translations st2 \n        WHERE st2.language = 'Japanese'\n    )\n)",
        "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
        "explain": "names of sets refers to name; doesn't have Japanese translation refers to language not like '%Japanese%'; have Korean translation refers to language = 'Korean'",
        "solution": [
            "To solve the question, we need to find the names of sets that do not have a Japanese translation but do have a Korean translation. Here are the steps to achieve this:\n\n1. **Identify Sets with Korean Translations**: First, we look for all sets that have a translation in the Korean language. This is done by querying the `set_translations` table for entries where the `language` field is 'Korean'.\n\n2. **Exclude Sets with Japanese Translations**: From the list of sets obtained in the first step, we exclude any sets that also have a translation in Japanese. This is done by ensuring that the `language` field does not contain 'Japanese'.\n\n3. **Retrieve Set Names**: Finally, we retrieve the names of the sets that meet the above criteria from the `sets` table.\n\nThe SQL query accomplishes this by using a subquery to first filter the `set_translations` table for Korean translations and then excluding any sets that also have Japanese translations. The main query then fetches the names of these sets from the `sets` table.",
            "To solve the question, we need to find the names of sets that do not have a Japanese translation but do have a Korean translation. Here are the detailed steps to achieve this:\n\n1. **Filter Sets with Korean Translations**: Query the `set_translations` table to identify all sets that have a translation in the Korean language. This is done by selecting entries where the `language` field is exactly 'Korean'.\n\n2. **Exclude Sets with Japanese Translations**: From the filtered list of sets with Korean translations, exclude any sets that also have a translation in Japanese. This is ensured by checking that the `language` field does not contain the substring 'Japanese'.\n\n3. **Retrieve Set Names**: Using the filtered set codes from the previous step, query the `sets` table to retrieve the names of these sets. The `code` field in the `sets` table is matched with the `setCode` field from the filtered `set_translations` table.\n\nThe SQL query accomplishes this by using a subquery to first filter the `set_translations` table for Korean translations and then excluding any sets that also have Japanese translations. The main query then fetches the names of these sets from the `sets` table."
        ]
    },
    "205": {
        "sql": "SELECT DISTINCT a.molecule_id FROM atom a WHERE a.element = 'c';",
        "question": "Identify by their ID the molecules in which there is carbon.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T.molecule_id FROM atom AS T WHERE T.element = 'c'",
        "explain": "carbon refers to element = 'c';",
        "solution": []
    },
    "1463": {
        "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE b.category = 'Food';",
        "question": "List the event names which were budgeted for the food.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Food'",
        "explain": "budgeted for food refers to category = 'Food'",
        "solution": []
    },
    "70": {
        "sql": "SELECT COUNT(School) FROM schools WHERE (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = '69' AND County = 'Alpine'",
        "question": "How many active and closed District Community Day Schools are there in the county of Alpine?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69 AND County = 'Alpine'",
        "explain": "",
        "solution": [
            "To solve the question, \"How many active and closed District Community Day Schools are there in the county of Alpine?\", the following steps are performed:\n\n1. **Filter the Schools Table**: The query filters the `schools` table to include only those records where the `StatusType` is either 'Closed' or 'Active'. This ensures that only schools with these statuses are considered.\n\n2. **Apply Additional Filters**: The query further filters the records to include only those schools where the `SOC` (Standard Occupational Classification) is 69, indicating District Community Day Schools, and the `County` is 'Alpine'.\n\n3. **Count the Schools**: Finally, the query counts the number of schools that meet all the above criteria. The result is the total count of active and closed District Community Day Schools in Alpine County.\n\nThe SQL query for this operation is:\n```sql\nSELECT COUNT(School) FROM schools WHERE (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69 AND County = 'Alpine'\n```"
        ]
    },
    "506": {
        "sql": "SELECT (COUNT(CASE WHEN s.isNonFoilOnly = 1 THEN 1 ELSE NULL END) * 100.0 / COUNT(s.id)) AS percentage_non_foil_only\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nWHERE st.language = 'Japanese';",
        "question": "For all the set of cards that has Japanese translation, what is the percentage of them are only available in non-foil?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Japanese' )",
        "explain": "Japanese translation refers to language = 'Japanese'; in non-foil refers to isNonFoilOnly = 1; percentage of Japanese non foil in Japanese cards refers to DIVIDE(SUM(isNonFoilOnly = 1), SUM(language = 'Japanese'))*100",
        "solution": [
            "To solve the question, we need to calculate the percentage of card sets that have Japanese translations and are only available in non-foil. Here are the steps:\n\n1. **Identify Sets with Japanese Translations**: First, find all the sets that have translations in Japanese. This is done by querying the `set_translations` table for entries where the `language` is 'Japanese' and extracting the `setCode` values.\n\n2. **Filter Sets**: Use the `setCode` values obtained in the previous step to filter the `sets` table. This ensures we only consider sets that have Japanese translations.\n\n3. **Count Total Sets**: Count the total number of sets in the filtered list (i.e., sets with Japanese translations). This is represented by `COUNT(id)` in the SQL.\n\n4. **Count Non-Foil Only Sets**: Among the filtered sets, count how many are marked as `isNonFoilOnly = 1` (i.e., sets that are only available in non-foil). This is done using a `CASE` statement that increments the count by 1 for each set where `isNonFoilOnly` is 1, otherwise increments by 0.\n\n5. **Calculate Percentage**: Divide the count of non-foil only sets by the total count of sets with Japanese translations, then multiply by 100 to get the percentage. The `CAST` to `REAL` ensures the division is performed as a floating-point operation for accuracy.\n\nThe final result is the percentage of sets with Japanese translations that are only available in non-foil."
        ]
    },
    "1532": {
        "sql": "SELECT g.Country\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.ProductID = 2\nORDER BY t.Price DESC\nLIMIT 1;",
        "question": "Which country had the gas station that sold the most expensive product id No.2 for one unit?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.ProductID = 2 ORDER BY T1.Price DESC LIMIT 1",
        "explain": "",
        "solution": []
    },
    "865": {
        "sql": "SELECT T1.forename, T1.surname FROM drivers T1 JOIN results T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1;",
        "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
        "explain": "drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL); race number refers to raceId; date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
        "solution": [
            "To find the oldest driver who finished the game in race No. 592, follow these steps:\n\n1. **Join the tables**: Combine the `drivers` table (aliased as T1) with the `results` table (aliased as T2) using the `driverId` field to link them.\n\n2. **Filter the results**:\n   - Ensure the race ID is 592 (`T2.raceId = 592`).\n   - Ensure the driver has a recorded finish time (`T2.time IS NOT NULL`).\n   - Ensure the driver's date of birth is available (`T1.dob IS NOT NULL`).\n\n3. **Sort the drivers**: Order the drivers by their date of birth in ascending order (`ORDER BY T1.dob ASC`). This will place the oldest driver (earliest date of birth) at the top of the list.\n\n4. **Select the oldest driver**: Limit the result to the first record (`LIMIT 1`), which will be the oldest driver who meets all the criteria.\n\n5. **Retrieve the driver's name**: Return the `forename` and `surname` of the selected driver from the `drivers` table."
        ]
    },
    "271": {
        "sql": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl\nFROM atom T1\nJOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id = 'TR001_1_8'\nAND (T1.element = 'c1' OR T1.element = 'c');",
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "explain": "chlorine refers to element = 'cl'; carbon refers to element = 'c'",
        "solution": [
            "To determine if bond ID 'TR001_1_8' contains both chlorine and carbon elements, the following steps are performed:\n\n1. **Join Tables**: The `atom` table (aliased as `T1`) is joined with the `connected` table (aliased as `T2`) using the `atom_id` field from `T1` and the `atom_id` field from `T2`.\n\n2. **Filter by Bond ID**: The query filters the results to only include records where the `bond_id` in `T2` is 'TR001_1_8'.\n\n3. **Check for Elements**: The query further filters the results to include only atoms where the `element` in `T1` is either 'c1' (representing chlorine) or 'c' (representing carbon).\n\n4. **Output**: The query outputs the `bond_id`, `atom_id2`, and the `element` (aliased as `flag_have_CaCl`) for the matching records.\n\nThis ensures that the query retrieves all atoms connected to bond 'TR001_1_8' that are either carbon or chlorine, allowing verification of the presence of both elements."
        ]
    },
    "1031": {
        "sql": "SELECT DISTINCT (strftime('%Y', 'now') - strftime('%Y', t2.birthday)) - (strftime('%m-%d', 'now') < strftime('%m-%d', t2.birthday)) AS age\nFROM Player_Attributes t1\nJOIN Player t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.sprint_speed >= 97\nAND strftime('%Y', t1.date) BETWEEN '2013' AND '2015';",
        "question": "At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",
        "db_id": "european_football_2",
        "res": 0,
        "ground_truth": "SELECT DISTINCT DATETIME() - T2.birthday age FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.`date`) >= '2013' AND STRFTIME('%Y',t1.`date`) <= '2015' AND t1.sprint_speed >= 97",
        "explain": "players age at present = SUBTRACT((DATETIME(), birthday)); sprint speed of no less than 97 refers to sprint_speed > = 97; between 2013 to 2015 refers to YEAR(date) > = '2013' AND YEAR(date) < = '2015'; ",
        "solution": [
            "To solve the question, the following operations are performed:\n\n1. **Join Tables**: Combine the `Player_Attributes` table (aliased as `t1`) with the `Player` table (aliased as `t2`) using the `player_api_id` field to link them.\n\n2. **Filter by Date**: From the joined tables, filter the records to include only those where the year extracted from the `date` field in `t1` is between 2013 and 2015 (inclusive).\n\n3. **Filter by Sprint Speed**: Further filter the records to include only those where the `sprint_speed` in `t1` is at least 97.\n\n4. **Calculate Age**: For each remaining record, calculate the player's age by subtracting their `birthday` (from `t2`) from the current date and time (using `DATETIME()`).\n\n5. **Remove Duplicates**: Ensure the results are distinct to avoid duplicate age entries for the same player.\n\nThe final output is a list of distinct ages for players who meet the specified criteria.",
            "To solve the question, the following detailed operations are performed:\n\n1. **Join Tables**: The `Player_Attributes` table (aliased as `t1`) is joined with the `Player` table (aliased as `t2`) using the `player_api_id` field to link them. This ensures that player attributes are matched with their corresponding player details.\n\n2. **Filter by Date Range**: From the joined tables, filter the records to include only those where the year extracted from the `date` field in `t1` falls between 2013 and 2015 (inclusive). This is done using the `STRFTIME('%Y', t1.date)` function to extract the year and compare it with the specified range.\n\n3. **Filter by Sprint Speed**: Further filter the records to include only those where the `sprint_speed` attribute in `t1` is at least 97. This ensures only players with the required sprint speed are considered.\n\n4. **Calculate Age**: For each remaining record, calculate the player's age by subtracting their `birthday` (from `t2`) from the current date and time (obtained using `DATETIME()`). This gives the age of the player at the current moment.\n\n5. **Remove Duplicates**: Ensure the results are distinct by using the `DISTINCT` keyword to avoid duplicate age entries for the same player. This guarantees that each age is listed only once in the final output.\n\nThe final output is a list of distinct ages for players who meet the specified criteria of having a sprint speed of no less than 97 between the years 2013 and 2015."
        ]
    },
    "1334": {
        "sql": "SELECT T1.first_name, T1.last_name FROM member T1 INNER JOIN zip_code T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois';",
        "question": "List the full name of the Student_Club members that grew up in Illinois state.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'",
        "explain": "full name of member refers to first_name, last_name",
        "solution": [
            "To solve the question, we need to list the full names of the Student_Club members who grew up in Illinois state. Here are the steps to achieve this:\n\n1. **Identify the Tables Involved**: The query involves two tables:\n   - `member` (aliased as `T1`): Contains information about the Student_Club members, including their first names, last names, and zip codes.\n   - `zip_code` (aliased as `T2`): Contains information about zip codes, including the state associated with each zip code.\n\n2. **Join the Tables**: The query performs an inner join between the `member` table (`T1`) and the `zip_code` table (`T2`) using the `zip` column from the `member` table and the `zip_code` column from the `zip_code` table. This join ensures that we only consider members whose zip codes are present in the `zip_code` table.\n\n3. **Filter by State**: The query filters the results to include only those members whose associated zip code corresponds to the state of Illinois (`T2.state = 'Illinois'`).\n\n4. **Select the Required Columns**: Finally, the query selects the `first_name` and `last_name` columns from the `member` table (`T1`) to display the full names of the qualifying members.\n\nThis process ensures that we retrieve the full names of all Student_Club members who grew up in Illinois."
        ]
    },
    "720": {
        "sql": "SELECT s.full_name\nFROM superhero s\nJOIN hero_power hp ON s.id = hp.hero_id\nGROUP BY s.full_name\nHAVING COUNT(hp.power_id) > 15;",
        "question": "Please list the full names of all the superheroes with over 15 super powers.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.full_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.full_name HAVING COUNT(T2.power_id) > 15",
        "explain": "15 super powers refers to COUNT(full_name) > 15",
        "solution": []
    },
    "1136": {
        "sql": "SELECT COUNT(*) AS number_of_players\nFROM Player_Attributes\nWHERE crossing = (SELECT MAX(crossing) FROM Player_Attributes)\nAND preferred_foot = 'left'\nAND attacking_work_rate IS NOT NULL;",
        "question": "How many players had the highest potential score for crossing that preferred to use their left foots while attacking?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT COUNT(t1.id) FROM Player_Attributes AS t1 WHERE t1.preferred_foot = 'left' AND t1.crossing = ( SELECT MAX(crossing) FROM Player_Attributes)",
        "explain": "highest potential score for crossing refers to MAX(crossing); preferred to use their left foots while attacking refers to preferred_foot = 'left'",
        "solution": []
    },
    "1167": {
        "sql": "SELECT CAST(COUNT(DISTINCT T1.ID) AS REAL) / 12 AS average_male_patients_per_month\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T2.Date) = '1998'\nAND T1.SEX = 'M';",
        "question": "For the year that concluded on December 31, 1998, how many male patients on average were tested in the lab each month?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT CAST(COUNT(T1.ID) AS REAL) / 12 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.Date) = '1998' AND T1.SEX = 'M'",
        "explain": "the year that concluded on December 31, 1998 refers to Date BETWEEN '1998-01-01' AND '1998-12-31'; male refers to SEX = 'M'; calculation = DIVIDE(COUNT(ID), 12)",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: Combine the `Patient` table (referred to as `T1`) and the `Laboratory` table (referred to as `T2`) using the `ID` column as the common key. This ensures that each patient's laboratory records are linked to their personal details.\n\n2. **Filter by Year**: From the joined data, filter out records where the `Date` in the `Laboratory` table (`T2.Date`) corresponds to the year 1998. This is done using the `STRFTIME` function to extract the year part of the date and compare it to '1998'.\n\n3. **Filter by Gender**: Further filter the data to include only male patients by checking the `SEX` column in the `Patient` table (`T1.SEX`) for the value 'M'.\n\n4. **Count the Records**: Count the number of unique patient IDs (`T1.ID`) that meet the above criteria. This gives the total number of male patients tested in the lab during 1998.\n\n5. **Calculate the Monthly Average**: Divide the total count by 12 to find the average number of male patients tested per month in 1998. The result is cast to a `REAL` data type to ensure the division yields a floating-point number.\n\nThe final result is the average number of male patients tested in the lab each month during the year 1998.",
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Tables**: Combine the `Patient` table (referred to as `T1`) and the `Laboratory` table (referred to as `T2`) using the `ID` column as the common key. This ensures that each patient's laboratory records are linked to their personal details.\n\n2. **Filter by Year**: From the joined data, filter out records where the `Date` in the `Laboratory` table (`T2.Date`) corresponds to the year 1998. This is done using the `STRFTIME` function to extract the year part of the date and compare it to '1998'.\n\n3. **Filter by Gender**: Further filter the data to include only male patients by checking the `SEX` column in the `Patient` table (`T1.SEX`) for the value 'M'.\n\n4. **Count the Records**: Count the number of unique patient IDs (`T1.ID`) that meet the above criteria. This gives the total number of male patients tested in the lab during 1998.\n\n5. **Calculate the Monthly Average**: Divide the total count by 12 to find the average number of male patients tested per month in 1998. The result is cast to a `REAL` data type to ensure the division yields a floating-point number.\n\nThe final result is the average number of male patients tested in the lab each month during the year 1998."
        ]
    },
    "398": {
        "sql": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
        "question": "What is the  unconverted mana do all the cards created by Rob Alexander cost in total?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
        "explain": "unconverted mana refer to manaCost; Rob Alexander refer to artist",
        "solution": [
            "To find the total unconverted mana cost of all the cards created by Rob Alexander, the database performs the following operations:\n\n1. **Filtering the Data**: The database filters the `cards` table to select only those records where the `artist` column matches the value 'Rob Alexander'.\n\n2. **Retrieving the Mana Cost**: For each of the filtered records, the database retrieves the value stored in the `manaCost` column.\n\n3. **Output the Results**: The database outputs the `manaCost` values for all the cards created by Rob Alexander.\n\nThis operation corresponds to the SQL query: `SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'`."
        ]
    },
    "1101": {
        "sql": "SELECT AVG(m.away_team_goal) AS average_goals\nFROM Match m\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nJOIN League l ON m.league_id = l.id\nJOIN Country c ON l.country_id = c.id\nWHERE t.team_long_name = 'Parma' AND c.name = 'Italy';",
        "question": "What is the average number of goals made by Parma as the away team while playing in Italy?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) FROM \"Match\" AS T1 INNER JOIN TEAM AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN Country AS T3 ON T1.country_id = T3.id WHERE T2.team_long_name = 'Parma' AND T3.name = 'Italy'",
        "explain": "Parma refers to team_long_name = 'Parma'; average number of goals refers to AVG(away_team_goal)",
        "solution": []
    },
    "217": {
        "sql": "SELECT DISTINCT c.atom_id, c.atom_id2\nFROM connected c\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE a1.molecule_id = 'TR181' OR a2.molecule_id = 'TR181';",
        "question": "Identify all the atoms that are connected to the atoms of the TR181 molecule.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T1.molecule_id = 'TR181'",
        "explain": "TR181 molecule refers to molecule_id = 'TR181'",
        "solution": [
            "To identify all the atoms connected to the atoms of the TR181 molecule, follow these steps:\n\n1. **Filter the Atoms of TR181**: First, locate all the atoms that belong to the molecule with the ID 'TR181' in the 'atom' table. This is done by checking the 'molecule_id' column in the 'atom' table for the value 'TR181'.\n\n2. **Find Connected Atoms**: For each atom identified in the first step, look up all the connections (or bonds) involving these atoms in the 'connected' table. The 'connected' table contains pairs of atom IDs (atom_id and atom_id2) that are connected to each other.\n\n3. **Retrieve Connected Atom IDs**: For each connection found, retrieve the IDs of the connected atoms (both atom_id and atom_id2) from the 'connected' table. This ensures that all atoms connected to the atoms of the TR181 molecule are identified.\n\n4. **Output the Results**: The final output will be a list of atom IDs (both from the 'atom_id' and 'atom_id2' columns in the 'connected' table) that are connected to any atom in the TR181 molecule."
        ]
    },
    "344": {
        "sql": "SELECT DISTINCT T1.id FROM cards T1 JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic';",
        "question": "List all the mythic rarity print cards banned in gladiator format.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "explain": "mythic rarity printing refers to rarity = 'mythic'; card banned refers to status = 'Banned'; in gladiator format refers to format = 'gladiator';",
        "solution": [
            "To list all the mythic rarity print cards banned in the gladiator format, follow these steps:\n\n1. **Identify the tables involved**: The query uses two tables, `cards` (referred to as `T1`) and `legalities` (referred to as `T2`).\n\n2. **Join the tables**: The query joins the `cards` table (`T1`) with the `legalities` table (`T2`) using the `uuid` field as the common key.\n\n3. **Apply the filters**:\n   - Filter the `legalities` table (`T2`) to include only records where the `format` is 'gladiator' and the `status` is 'Banned'.\n   - Filter the `cards` table (`T1`) to include only records where the `rarity` is 'mythic'.\n\n4. **Select the distinct card IDs**: The query selects the `id` field from the `cards` table (`T1`) and ensures the results are distinct to avoid duplicates.\n\nThis process ensures that only mythic rarity cards banned in the gladiator format are listed."
        ]
    },
    "386": {
        "sql": "SELECT COUNT(DISTINCT T1.id) AS future_frame_cards_count\nFROM cards T1\nJOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.frameVersion = 'future';",
        "question": "How many cards are having future frame version and what are the legality status of these cards?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future'",
        "explain": "future frame version refers to frameVersion = 'future'; legility status refers to status = 'legal';",
        "solution": [
            "To solve the question, the database performs the following operations:\n\n1. **Join Tables**: The `cards` table (aliased as `T1`) is joined with the `legalities` table (aliased as `T2`) using the `uuid` column as the common key. This ensures that each card in the `cards` table is matched with its corresponding legality status in the `legalities` table.\n\n2. **Filter Cards**: The query filters the joined data to include only those cards where the `frameVersion` column in the `cards` table is equal to 'future'. This isolates cards that have a future frame version.\n\n3. **Count Cards**: The query then counts the number of unique card IDs (`id` column in the `cards` table) that meet the filtering criteria. This gives the total number of cards with a future frame version.\n\n4. **Output Result**: The result of the count is returned as the output, answering the first part of the question about how many cards have a future frame version.\n\nNote: The second part of the question, regarding the legality status of these cards, is not addressed in the provided SQL. The SQL only counts the cards but does not retrieve their legality statuses.",
            "To solve the question, the database performs the following operations:\n\n1. **Join Tables**: The `cards` table (aliased as `T1`) is joined with the `legalities` table (aliased as `T2`) using the `uuid` column as the common key. This ensures that each card in the `cards` table is matched with its corresponding legality status in the `legalities` table.\n\n2. **Filter Cards**: The query filters the joined data to include only those cards where the `frameVersion` column in the `cards` table is equal to 'future'. This isolates cards that have a future frame version.\n\n3. **Count Cards**: The query then counts the number of unique card IDs (`id` column in the `cards` table) that meet the filtering criteria. This gives the total number of cards with a future frame version.\n\n4. **Output Result**: The result of the count is returned as the output, answering the first part of the question about how many cards have a future frame version.\n\nNote: The second part of the question, regarding the legality status of these cards, is not addressed in the provided SQL. The SQL only counts the cards but does not retrieve their legality statuses."
        ]
    },
    "42": {
        "sql": "SELECT T2.EdOpsName\nFROM satscores T1\nJOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 1;",
        "question": "What is the type of education offered in the school who scored the highest average in Math?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT T2.EdOpsName FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 1",
        "explain": "",
        "solution": [
            "To find the type of education offered in the school that scored the highest average in Math, follow these steps:\n\n1. **Join the Tables**: Combine the `satscores` table (aliased as `T1`) with the `schools` table (aliased as `T2`) using the common field `cds` from `satscores` and `CDSCode` from `schools`.\n\n2. **Sort by Math Scores**: Arrange the joined records in descending order based on the `AvgScrMath` column from the `satscores` table to prioritize schools with the highest average Math scores.\n\n3. **Select the Top School**: Retrieve only the top record from the sorted list, which represents the school with the highest average Math score.\n\n4. **Extract Education Type**: From the selected record, extract the `EdOpsName` column from the `schools` table, which indicates the type of education offered by the school.\n\nThe final result will display the type of education offered by the school with the highest average Math score."
        ]
    },
    "210": {
        "sql": "SELECT c.atom_id, c.atom_id2 FROM connected c JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '-';",
        "question": "What atoms are connected in single type bonds?",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "explain": "single type bond refers to bond_type = '-';",
        "solution": [
            "To find the atoms connected by single type bonds, perform the following operations:\n\n1. **Filter Bonds by Type**: Identify all bonds in the `bond` table where the `bond_type` is a single bond, represented by the symbol '-'.\n\n2. **Join with Connected Atoms**: Join the filtered bonds with the `connected` table using the `bond_id` as the common key. This will link each single bond to the pairs of atoms it connects.\n\n3. **Retrieve Atom Pairs**: From the joined result, select the `atom_id` and `atom_id2` columns to get the identifiers of the atoms connected by each single bond.\n\nThis process ensures that only atoms connected by single bonds are returned, matching the criteria specified in the question."
        ]
    },
    "1395": {
        "sql": "SELECT COUNT(DISTINCT a.link_to_member) AS member_count\nFROM attendance a\nJOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Community Theater' AND strftime('%Y', e.event_date) = '2019';",
        "question": "How many members did attend the event 'Community Theater' in 2019?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Community Theater' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "explain": "event 'Community Theater' in 2019 refers to event_name = 'Community Theater' where YEAR(event_date) = 2019",
        "solution": []
    },
    "48": {
        "sql": "WITH merged_schools AS (\n    SELECT CDSCode, DOC\n    FROM schools\n    WHERE StatusType = 'Merged' AND County = 'Orange'\n),\nunified_count AS (\n    SELECT COUNT(*) AS count\n    FROM merged_schools\n    WHERE DOC = '54'\n),\nelementary_count AS (\n    SELECT COUNT(*) AS count\n    FROM merged_schools\n    WHERE DOC = '52'\n)\nSELECT \n    (SELECT count FROM unified_count) * 1.0 / \n    (SELECT count FROM elementary_count) AS ratio",
        "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
        "db_id": "california_schools",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
        "explain": "Elementary School District refers to DOC = 52; Unified School District refers to DOC = 54.",
        "solution": [
            "To solve the question, we need to calculate the ratio of merged Unified School District schools to merged Elementary School District schools in Orange County. Here are the steps:\n\n1. **Filter the Data**: Select all schools from the database where the status is 'Merged' and the county is 'Orange'.\n\n2. **Count Unified School District Schools**: For each school in the filtered data, check if the 'DOC' (District Organization Code) is 54 (indicating a Unified School District). Count the number of schools that meet this condition.\n\n3. **Count Elementary School District Schools**: Similarly, check if the 'DOC' is 52 (indicating an Elementary School District) and count the number of schools that meet this condition.\n\n4. **Calculate the Ratio**: Divide the count of Unified School District schools by the count of Elementary School District schools to get the ratio.\n\n5. **Return the Result**: The result is the ratio of merged Unified School District schools to merged Elementary School District schools in Orange County."
        ]
    },
    "1454": {
        "sql": "SELECT \n    (SUM(CASE WHEN e.type = 'Meeting' THEN ex.cost ELSE 0 END) * 100.0 / SUM(ex.cost)) AS percentage_meeting_cost\nFROM \n    event e\nJOIN \n    budget b ON e.event_id = b.link_to_event\nJOIN \n    expense ex ON b.budget_id = ex.link_to_budget;",
        "question": "What is the percentage of the cost for the meeting events?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "explain": "meeting events refers to type = 'Meeting'; percentage = DIVIDE( SUM(cost), COUNT(event_id)) * 100",
        "solution": [
            "To determine the percentage of the cost for meeting events, follow these steps:\n\n1. **Join the Tables**: Combine the `event`, `budget`, and `expense` tables. Link the `event` table to the `budget` table using the `event_id` and `link_to_event` fields. Then, link the `budget` table to the `expense` table using the `budget_id` and `link_to_budget` fields.\n\n2. **Filter Meeting Events**: For each row in the joined result, check if the `type` field in the `event` table is 'Meeting'. If it is, include the `cost` from the `expense` table; otherwise, treat the cost as 0.\n\n3. **Calculate the Sum of Meeting Costs**: Sum all the costs identified as meeting-related (i.e., where the `type` is 'Meeting').\n\n4. **Calculate the Total Sum of Costs**: Sum all the costs from the `expense` table, regardless of the event type.\n\n5. **Compute the Percentage**: Divide the sum of meeting costs by the total sum of costs and multiply by 100 to get the percentage.\n\nThe final result will be the percentage of the total cost attributed to meeting events."
        ]
    },
    "1230": {
        "sql": "SELECT DISTINCT p.ID\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Admission = '-' AND l.CPK < 250;",
        "question": "List all outpatient within normal range of creatinine phosphokinase. Give me the distinct ids.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CPK < 250 AND T1.Admission = '-'",
        "explain": "outpatient refers to Admission = '-'; normal range of creatinine phosphokinase refers to CPK < 250;",
        "solution": []
    },
    "817": {
        "sql": "SELECT r.race\nFROM superhero s\nJOIN colour c ON s.hair_colour_id = c.id\nJOIN gender g ON s.gender_id = g.id\nJOIN race r ON s.race_id = r.id\nWHERE c.colour = 'Blue' AND g.gender = 'Male';",
        "question": "Give the race of the blue-haired male superhero.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T2.colour = 'Blue' AND T4.gender = 'Male'",
        "explain": "blue-haired refers to colour.colour = 'blue' WHERE hair_colour_id = colour.id; male refers to gender = 'male';",
        "solution": [
            "To find the race of the blue-haired male superhero, follow these steps:\n\n1. **Identify the superhero table (T1)**: This table contains information about superheroes, including their hair color, race, and gender.\n\n2. **Join the colour table (T2)**: Link the superhero table to the colour table using the `hair_colour_id` field in the superhero table and the `id` field in the colour table. This allows us to filter superheroes based on their hair color.\n\n3. **Filter for blue hair**: From the colour table, select only those records where the `colour` field is 'Blue'.\n\n4. **Join the gender table (T4)**: Link the superhero table to the gender table using the `gender_id` field in the superhero table and the `id` field in the gender table. This allows us to filter superheroes based on their gender.\n\n5. **Filter for male gender**: From the gender table, select only those records where the `gender` field is 'Male'.\n\n6. **Join the race table (T3)**: Link the superhero table to the race table using the `race_id` field in the superhero table and the `id` field in the race table. This allows us to retrieve the race information for the filtered superheroes.\n\n7. **Retrieve the race**: Finally, select the `race` field from the race table (T3) for the superheroes that meet the criteria of having blue hair and being male."
        ]
    },
    "853": {
        "sql": "SELECT r.name \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.country = 'Spain';",
        "question": "Please give the names of the races held on the circuits in Spain.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "explain": "Spain is a name of country;",
        "solution": []
    },
    "1106": {
        "sql": "SELECT pa.defensive_work_rate \nFROM Player_Attributes pa \nJOIN Player p ON pa.player_api_id = p.player_api_id \nWHERE p.player_name = 'Kevin Berigaud' \nAND pa.date = '2013-02-22 00:00:00';",
        "question": "Tell the defensive work rate for Kevin Berigaud on 2013/2/22.",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT t2.defensive_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-02-22' AND t1.player_name = 'Kevin Berigaud'",
        "explain": "Kevin Berigaud refers to player_name = 'Kevin Berigaud'; on 2013/2/22 refers to date = '2013-02-22 00:00:00'",
        "solution": []
    },
    "1508": {
        "sql": "SELECT COUNT(*) \nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'CZE' AND t.Price > 1000;",
        "question": "How many transactions taken place in the gas station in the Czech Republic are with a price of over 1000?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND T1.Price > 1000",
        "explain": "Gas station in the Czech Republic implies that Country = 'CZE'",
        "solution": []
    },
    "809": {
        "sql": "SELECT p.publisher_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nWHERE s.id = 38;",
        "question": "What is the publisher name of the superhero ID 38?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.id = 38",
        "explain": "superhero ID 38 refers to superhero.id = 38;",
        "solution": []
    },
    "633": {
        "sql": "SELECT p.Id\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'slashnick'\nORDER BY p.AnswerCount DESC\nLIMIT 1;",
        "question": "Which post by slashnick has the most answers count? State the post ID.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.PostId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'slashnick' ORDER BY T3.AnswerCount DESC LIMIT 1",
        "explain": "most answers count refers to MAX(AnswerCount); post by slashnick refers to DisplayName = 'slashnick';",
        "solution": []
    },
    "1319": {
        "sql": "SELECT m.college\nFROM member AS mem\nJOIN major AS m ON mem.link_to_major = m.major_id\nWHERE mem.position = 'Vice President';",
        "question": "Which college is the vice president of the Student_Club from?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position LIKE 'vice president'",
        "explain": "Vice President is a position of the Student Club",
        "solution": []
    },
    "1376": {
        "sql": "SELECT e.event_name\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.status = 'Closed'\nORDER BY (b.spent / b.amount) DESC\nLIMIT 1;",
        "question": "Among all the closed events, which event has the highest spend-to-budget ratio?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
        "explain": "closed events refers to event_name where status = 'Closed'; highest spend-to budget ratio refers to MAX(DIVIDE(spent, amount))",
        "solution": [
            "To find the event with the highest spend-to-budget ratio among all closed events, follow these steps:\n\n1. **Filter Closed Events**: Identify all events in the `event` table where the `status` is marked as 'Closed'.\n\n2. **Join with Budget Data**: For each closed event, retrieve its corresponding budget information from the `budget` table by matching the `link_to_event` field in the `budget` table with the `event_id` in the `event` table.\n\n3. **Calculate Spend-to-Budget Ratio**: For each matched pair of event and budget, compute the ratio of `spent` to `amount` (i.e., `spent / amount`).\n\n4. **Sort by Ratio**: Arrange the results in descending order based on the calculated spend-to-budget ratio.\n\n5. **Select the Top Result**: From the sorted list, pick the top entry, which represents the event with the highest spend-to-budget ratio.\n\nThe final output will be the name of this event."
        ]
    },
    "573": {
        "sql": "SELECT Text FROM comments WHERE Score = 17;",
        "question": "Write the contents of comments with a score of 17.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Text FROM comments WHERE Score = 17",
        "explain": "score of 17 refers to Score = 17; contents of comments refers to Text",
        "solution": []
    },
    "658": {
        "sql": "SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5;",
        "question": "What are the titles of the top 5 posts with the highest popularity?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5",
        "explain": "Higher view count means the post has higher popularity; the highest popularity refers to MAX(ViewCount);",
        "solution": []
    },
    "1486": {
        "sql": "SELECT \n    (SELECT COUNT(*) FROM customers WHERE Segment = 'SME' AND Currency = 'CZK') - \n    (SELECT COUNT(*) FROM customers WHERE Segment = 'SME' AND Currency = 'EUR') AS Difference",
        "question": "Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') FROM customers WHERE Segment = 'SME'",
        "explain": "Amount of more SMEs = Total of SMEs pay using Currency CZK - Total of SMEs pay using Currency EUR",
        "solution": [
            "To determine whether more SMEs pay in Czech koruna (CZK) than in euros (EUR) and by how many, the following steps are performed:\n\n1. **Filter the Data**: First, filter the `customers` table to include only those records where the `Segment` is 'SME'.\n\n2. **Count Payments in CZK**: Calculate the total number of SMEs that pay in Czech koruna (CZK) by summing the occurrences where the `Currency` column equals 'CZK'.\n\n3. **Count Payments in EUR**: Similarly, calculate the total number of SMEs that pay in euros (EUR) by summing the occurrences where the `Currency` column equals 'EUR'.\n\n4. **Calculate the Difference**: Subtract the count of EUR payments from the count of CZK payments to find out how many more SMEs pay in CZK than in EUR.\n\nThe result of this operation will be a single number indicating the difference between the number of SMEs paying in CZK and those paying in EUR. If the result is positive, it means more SMEs pay in CZK; if negative, more pay in EUR."
        ]
    },
    "261": {
        "sql": "SELECT b.bond_id\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE m.label = '+';",
        "question": "Write down bond id for molecules that are carcinogenic.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "explain": "label = '+' mean molecules are carcinogenic",
        "solution": []
    },
    "837": {
        "sql": "SELECT hero_id FROM hero_attribute WHERE attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute);",
        "question": "Give the hero ID of superhero with the lowest attribute value.",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT hero_id FROM hero_attribute WHERE attribute_value = ( SELECT MIN(attribute_value) FROM hero_attribute )",
        "explain": "lowest attribute value refers to MIN(attribute_value);",
        "solution": []
    },
    "911": {
        "sql": "SELECT name, lat FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;",
        "question": "Which of these circuits is located at a higher latitude, Silverstone Circuit, Hockenheimring or Hungaroring?",
        "db_id": "formula_1",
        "res": 0,
        "ground_truth": "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1",
        "explain": "higher latitude refers to max(lat)",
        "solution": [
            "To determine which of the circuits (Silverstone Circuit, Hockenheimring, or Hungaroring) is located at the highest latitude, follow these steps:\n\n1. **Identify the circuits**: Focus on the circuits named 'Silverstone Circuit', 'Hockenheimring', and 'Hungaroring'.\n2. **Retrieve their latitude values**: For each of these circuits, obtain their latitude (lat) values from the database.\n3. **Compare the latitudes**: Arrange the circuits in descending order based on their latitude values.\n4. **Select the highest**: The circuit that appears first in this ordered list is the one located at the highest latitude.\n5. **Return the result**: Output the name of this circuit.\n\nThis process ensures that the circuit with the highest latitude among the three is identified and returned.",
            "To determine which of the circuits (Silverstone Circuit, Hockenheimring, or Hungaroring) is located at the highest latitude, follow these detailed steps:\n\n1. **Filter the circuits**: Narrow down the database records to only include the circuits named 'Silverstone Circuit', 'Hockenheimring', and 'Hungaroring'.\n2. **Retrieve latitude values**: For each of these filtered circuits, extract their latitude (lat) values from the database.\n3. **Sort by latitude**: Arrange the filtered circuits in descending order based on their latitude values. This means the circuit with the highest latitude will appear first.\n4. **Select the top result**: From the sorted list, pick the first entry, which represents the circuit with the highest latitude.\n5. **Output the name**: Return the name of this top circuit as the final result.\n\nThis method ensures that the circuit with the highest latitude among the three specified is accurately identified and returned, matching the logic of the provided SQL query."
        ]
    },
    "1238": {
        "sql": "SELECT p.ID, p.SEX\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.Diagnosis = 'SLE'\n  AND l.HGB BETWEEN 12 AND 17.5\nORDER BY p.Birthday ASC\nLIMIT 1;",
        "question": "Among the patients who were diagnosed with SLE, who is the oldest with normal hemoglobin level. Provide the ID and sex.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.HGB > 10 AND T2.HGB < 17 ORDER BY T1.Birthday ASC LIMIT 1",
        "explain": "diagnosed with SLE refers to Diagnosis = 'SLE'; The larger the birthday value, the younger the person is, and vice versa; normal hemoglobin level refers to 10 < HGB < 17;",
        "solution": []
    },
    "675": {
        "sql": "SELECT COUNT(*) FROM users WHERE Reputation > 2000 AND Views > 1000;",
        "question": "How many users whose reputations are higher than 2000 and the number of views is higher than 1000?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT COUNT(id) FROM users WHERE Reputation > 2000 AND Views > 1000",
        "explain": "reputations are higher than 2000 refer to Reputation > 2000; number of views is higher than 1000 refers to Views > 1000;",
        "solution": []
    },
    "1152": {
        "sql": "SELECT \n    SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS outpatient_count,\n    SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS inpatient_count,\n    CASE \n        WHEN SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) = 0 THEN NULL\n        ELSE CAST(SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)\n    END AS outpatient_to_inpatient_ratio\nFROM Patient\nWHERE Diagnosis = 'SLE';",
        "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
        "explain": "'SLE' diagnosed patient means Diagnosis = 'SLE'; inpatient refers to Admission = '+'; outpatient refers to Admission = '-'; calculation =  DIVIDE(COUNT(ID) where Diagnosis = 'SLE' and Admission = '+', COUNT(ID) where Diagnosis = 'SLE' and Admission = '-')",
        "solution": [
            "To find the ratio of outpatient to inpatient follow-up treatments among all patients diagnosed with 'SLE', the following steps are performed:\n\n1. **Filter Patients**: Select all patients from the `Patient` table where the `Diagnosis` is 'SLE'.\n2. **Count Inpatient Treatments**: For each patient, check if the `Admission` column has a value of '+'. If it does, count it as an inpatient treatment (value 1.0); otherwise, count it as 0.\n3. **Count Outpatient Treatments**: For each patient, check if the `Admission` column has a value of '-'. If it does, count it as an outpatient treatment (value 1); otherwise, count it as 0.\n4. **Calculate the Ratio**: Sum the counts of inpatient treatments and divide this sum by the sum of the counts of outpatient treatments to get the desired ratio.\n\nThe SQL query accomplishes this by using conditional aggregation with `CASE` statements to differentiate between inpatient and outpatient treatments and then computing their ratio.",
            "To determine the ratio of outpatient to inpatient follow-up treatments among all patients diagnosed with 'SLE', the following detailed steps are executed:\n\n1. **Filter Patients**: The database is queried to select all records from the `Patient` table where the `Diagnosis` column exactly matches the value 'SLE'.\n\n2. **Identify Inpatient Treatments**: For each patient record retrieved, the `Admission` column is examined. If the value in this column is '+', it is counted as an inpatient treatment (assigned a value of 1.0). Otherwise, it is not counted (assigned a value of 0).\n\n3. **Identify Outpatient Treatments**: Similarly, for each patient record, if the `Admission` column contains '-', it is counted as an outpatient treatment (assigned a value of 1). Otherwise, it is not counted (assigned a value of 0).\n\n4. **Sum the Counts**: The total count of inpatient treatments is calculated by summing all the 1.0 values from the inpatient identification step. The total count of outpatient treatments is calculated by summing all the 1 values from the outpatient identification step.\n\n5. **Compute the Ratio**: The ratio of outpatient to inpatient treatments is derived by dividing the sum of inpatient treatments by the sum of outpatient treatments. This final ratio is the result returned by the query.\n\nThe SQL query achieves this by using conditional aggregation with `CASE` statements to differentiate between inpatient and outpatient treatments and then performing the division to compute the ratio."
        ]
    },
    "337": {
        "sql": "SELECT a.element, b.bond_type\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.molecule_id = 'TR002';\n",
        "question": "List the element and bond type included in the molecule with molecule ID of TR002.",
        "db_id": "toxicology",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T1.element, T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR002'",
        "explain": "TR002 is the molecule id",
        "solution": []
    },
    "1355": {
        "sql": "SELECT z.state\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.first_name = 'Sacha' AND m.last_name = 'Harrison';",
        "question": "Where is the hometown state for \"Sacha Harrison\"?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
        "explain": "hometown state refers to state;",
        "solution": []
    },
    "708": {
        "sql": "SELECT u.CreationDate, u.Age\nFROM users u\nJOIN comments c ON u.Id = c.UserId\nWHERE c.Text LIKE '%http://%';",
        "question": "List the creation date and age of the user that commented with webiste.",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.CreationDate, T2.Age FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.text LIKE '%http://%'",
        "explain": "commented with webiste refers to the value contains 'http://'",
        "solution": []
    },
    "917": {
        "sql": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "question": "Which website should I go to if I want to know more about Anthony Davidson?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
        "explain": "website refers to url",
        "solution": []
    },
    "1215": {
        "sql": "SELECT l.TP - 8.5 AS TP_Deviation\nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE p.SEX = 'F' AND l.TP > 8.5;",
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "explain": "female refers to SEX = 'F'; total protein (TP) beyond the normal index refers to TP > 8.5; deviation of TP index from normal refers to SUBTRACT(TP, 8.5)",
        "solution": [
            "To solve the question, the following operations are performed on the database:\n\n1. **Join the Patient and Laboratory tables**: The tables are joined using the `ID` column to link patient records with their laboratory results.\n\n2. **Filter female patients**: Only records where the `SEX` column in the Patient table is 'F' (indicating female patients) are selected.\n\n3. **Filter abnormal TP values**: Only records where the `TP` (Total Protein) value in the Laboratory table is greater than 8.5 (the normal index) are selected.\n\n4. **Calculate the deviation**: For each qualifying record, the deviation of the TP value from the normal index (8.5) is calculated by subtracting 8.5 from the TP value.\n\nThe result is a list of deviations for all female patients whose TP values exceed the normal index."
        ]
    },
    "1525": {
        "sql": "SELECT (CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100.0 / COUNT(DISTINCT T1.CustomerID)) AS Percentage_EUR_Customers\nFROM transactions_1k T1\nJOIN customers T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Date = '2012-08-25';",
        "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
        "db_id": "debit_card_specializing",
        "res": 0,
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
        "explain": "'2012/8/25' can be represented by '2012-08-25'",
        "solution": [
            "To solve the question \"What is the percentage of the customers who used EUR in 2012/8/25?\", the following steps are performed:\n\n1. **Join the Tables**: Combine the `transactions_1k` table (aliased as `T1`) with the `customers` table (aliased as `T2`) using the `CustomerID` field to link the records.\n\n2. **Filter by Date**: From the joined tables, filter the records to include only those transactions that occurred on the date '2012-08-25'.\n\n3. **Count Total Customers**: Calculate the total number of unique customers involved in transactions on the specified date by counting the `CustomerID` values in the filtered records.\n\n4. **Count EUR Users**: For each customer in the filtered records, check if their currency is 'EUR'. Sum the instances where the currency is 'EUR' (each instance is counted as 1, others as 0).\n\n5. **Calculate Percentage**: Convert the sum of EUR users to a float, multiply by 100, and then divide by the total number of customers to get the percentage.\n\nThe final result is the percentage of customers who used EUR on 2012-08-25.",
            "To solve the question \"What is the percentage of the customers who used EUR in 2012/8/25?\", the following detailed steps are performed:\n\n1. **Join the Tables**: The `transactions_1k` table (aliased as `T1`) is joined with the `customers` table (aliased as `T2`) using the `CustomerID` field to link the records. This ensures that each transaction is associated with its corresponding customer details.\n\n2. **Filter by Date**: From the joined tables, filter the records to include only those transactions that occurred on the date '2012-08-25'. This is done using the condition `T1.Date = '2012-08-25'`.\n\n3. **Count Total Customers**: Calculate the total number of unique customers involved in transactions on the specified date by counting the `CustomerID` values in the filtered records. This is represented by `COUNT(T1.CustomerID)` in the SQL.\n\n4. **Count EUR Users**: For each customer in the filtered records, check if their currency is 'EUR'. The SQL uses `IIF(T2.Currency = 'EUR', 1, 0)` to assign a value of 1 if the currency is 'EUR' and 0 otherwise. The `SUM` function then aggregates these values to get the total number of customers who used 'EUR'.\n\n5. **Calculate Percentage**: Convert the sum of EUR users to a float using `CAST(SUM(...) AS FLOAT)`, multiply by 100, and then divide by the total number of customers to get the percentage. The final result is the percentage of customers who used EUR on 2012-08-25.\n\nThe SQL query combines these steps into a single operation to efficiently compute the desired percentage."
        ]
    },
    "1196": {
        "sql": "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1",
        "question": "What is the most common sign of patients with SLE disease?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1",
        "explain": "the most common sign refers to MAX(symptoms); 'SLE' refers to diagnosis",
        "solution": [
            "To determine the most common sign of patients with SLE disease, the following steps are performed:\n\n1. **Filter the Data**: The database is queried to retrieve all records from the `Examination` table where the `Diagnosis` column has the value 'SLE'.\n\n2. **Group by Symptoms**: The filtered records are then grouped by the `Symptoms` column. This means all records with the same symptom are grouped together.\n\n3. **Count Occurrences**: For each group of symptoms, the number of occurrences (i.e., how many times each symptom appears) is counted.\n\n4. **Order by Frequency**: The groups are then ordered in descending order based on the count of occurrences. This places the most frequently occurring symptom at the top of the list.\n\n5. **Select the Top Result**: Finally, the top result (the symptom with the highest count) is selected as the most common sign of patients with SLE disease.",
            "To determine the most common sign of patients with SLE disease, the following detailed steps are executed:\n\n1. **Data Retrieval**: The database is queried to extract all records from the `Examination` table where the `Diagnosis` column specifically matches the value 'SLE'. This ensures only relevant patient data is considered.\n\n2. **Grouping by Symptoms**: The retrieved records are then grouped by the `Symptoms` column. This step aggregates all records that share the same symptom into distinct groups, allowing for frequency analysis.\n\n3. **Frequency Calculation**: For each symptom group, the number of occurrences is counted. This count represents how frequently each symptom appears among patients diagnosed with SLE.\n\n4. **Sorting by Frequency**: The symptom groups are sorted in descending order based on their respective counts. This arrangement places the symptom with the highest frequency at the top of the list.\n\n5. **Result Extraction**: The topmost symptom from the sorted list is selected, which corresponds to the most common sign observed in patients with SLE disease. This is achieved by limiting the output to just the first record.\n\nThe SQL query `SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1` precisely encapsulates these operations, ensuring accurate and efficient retrieval of the desired information."
        ]
    },
    "1203": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'F' AND T2.WBC < 3.5;",
        "question": "How many patients who were female got white blood cells that were below 3.5?",
        "db_id": "thrombosis_prediction",
        "res": 0,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC < 3.5 AND T1.SEX = 'F'",
        "explain": "female refers to SEX = 'F'; white blood cells that were below 3.5 refers to WBC < 3.5",
        "solution": [
            "To solve the question \"How many patients who were female got white blood cells that were below 3.5?\", follow these steps:\n\n1. **Identify the tables involved**: The query uses two tables, `Patient` (referred to as `T1`) and `Laboratory` (referred to as `T2`).\n\n2. **Join the tables**: The query performs an inner join between the `Patient` table (`T1`) and the `Laboratory` table (`T2`) using the `ID` column as the common key. This ensures that only records with matching `ID` values in both tables are considered.\n\n3. **Apply the filtering conditions**:\n   - The query filters the `Laboratory` table (`T2`) to include only records where the white blood cell count (`WBC`) is less than 3.5.\n   - The query also filters the `Patient` table (`T1`) to include only records where the sex (`SEX`) is 'F' (female).\n\n4. **Count the results**: The query counts the number of `ID` values from the `Patient` table (`T1`) that meet both filtering conditions. This count represents the number of female patients with white blood cell counts below 3.5.\n\nThe final result is the count of such patients.",
            "To solve the question \"How many patients who were female got white blood cells that were below 3.5?\", follow these detailed steps:\n\n1. **Identify the tables involved**: The query uses the `Patient` table (aliased as `T1`) and the `Laboratory` table (aliased as `T2`).\n\n2. **Join the tables**: The query performs an inner join between the `Patient` table (`T1`) and the `Laboratory` table (`T2`) using the `ID` column as the common key. This ensures that only records with matching `ID` values in both tables are included in the result set.\n\n3. **Apply the filtering conditions**:\n   - The query filters the `Laboratory` table (`T2`) to include only records where the white blood cell count (`WBC`) is strictly less than 3.5.\n   - The query also filters the `Patient` table (`T1`) to include only records where the sex (`SEX`) is 'F' (female).\n\n4. **Count the results**: The query counts the number of distinct `ID` values from the `Patient` table (`T1`) that satisfy both filtering conditions. This count represents the number of female patients with white blood cell counts below 3.5.\n\nThe final result is the count of such patients, which is the output of the query."
        ]
    },
    "1264": {
        "sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C4 > 10 AND T1.Diagnosis = 'APS'",
        "question": "Among the patients have blood clots in veins, how many of them have a normal level of complement 4?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C4 > 10 AND T1.Diagnosis = 'APS'",
        "explain": "APS will result in Blood Clots in veins; normal level of complement 4 refers to C4 > 10; Should compute the number of different ones",
        "solution": [
            "To solve the question, \"Among the patients who have blood clots in veins, how many of them have a normal level of complement 4?\", the following steps are performed:\n\n1. **Identify Patients with Blood Clots in Veins**: Filter the `Patient` table to include only those patients whose `Diagnosis` is 'APS' (indicating blood clots in veins).\n\n2. **Join with Laboratory Data**: Combine the filtered `Patient` table with the `Laboratory` table using the patient `ID` as the common key to access their laboratory results.\n\n3. **Filter for Normal Complement 4 Levels**: From the joined data, further filter to include only those patients whose `C4` level in the `Laboratory` table is greater than 10 (indicating a normal level of complement 4).\n\n4. **Count Distinct Patients**: Count the number of distinct patient `ID`s that meet all the above criteria to determine how many patients with blood clots in veins have a normal level of complement 4.\n\nThe SQL query `SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C4 > 10 AND T1.Diagnosis = 'APS'` precisely executes these steps."
        ]
    },
    "476": {
        "sql": "SELECT T1.name FROM cards T1 JOIN sets T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1;",
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "explain": "card set Coldsnap refers to name = 'Coldsnap'",
        "solution": [
            "To solve the question, follow these steps:\n\n1. **Join the Tables**: Combine the `cards` table (referred to as `T1`) with the `sets` table (referred to as `T2`) using the `setCode` from `T1` and the `code` from `T2`.\n\n2. **Filter by Set Name**: From the joined tables, filter the records to only include those where the set name (`T2.name`) is 'Coldsnap'.\n\n3. **Sort by Converted Mana Cost**: Order the filtered records by the `convertedManaCost` column in descending order (`DESC`) to ensure the highest value appears first.\n\n4. **Limit the Results**: Retrieve only the top record (the one with the highest converted mana cost) by applying a `LIMIT 1` clause.\n\n5. **Select the Card Name**: Finally, select and return the `name` column from the `cards` table (`T1.name`) for the record identified in the previous steps.\n\nThis process ensures that you list the name of the card in the 'Coldsnap' set with the highest converted mana cost."
        ]
    },
    "1341": {
        "sql": "SELECT location FROM event WHERE event_name = 'Spring Budget Review';",
        "question": "Give the location for \"Spring Budget Review\".",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT location FROM event WHERE event_name = 'Spring Budget Review'",
        "explain": "'Spring Budget Review' is an event name;",
        "solution": []
    },
    "544": {
        "sql": "SELECT u.DisplayName \nFROM posts p \nJOIN users u ON p.LastEditorUserId = u.Id \nWHERE p.Title = 'Examples for teaching: Correlation does not mean causation';",
        "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'",
        "explain": "\"Examples for teaching: Correlation does not mean causation\" is the Title of post; user who last edited refers to LastEditorUserId",
        "solution": []
    },
    "105": {
        "sql": "SELECT a.district_id\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.date = '1994-08-25';",
        "question": "There was a loan approved in 1994/8/25, where was that account opened, give the district Id of the branch.",
        "db_id": "financial",
        "res": 1,
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'",
        "explain": "",
        "solution": []
    },
    "1179": {
        "sql": "SELECT E.\"aCL IgA\", E.\"aCL IgG\", E.\"aCL IgM\"\nFROM Examination E\nJOIN Patient P ON E.ID = P.ID\nWHERE P.Diagnosis = 'SLE' AND P.Description = '1994-02-19'\nAND E.\"Examination Date\" = '1993-11-12';",
        "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` FROM Examination WHERE ID IN ( SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19' ) AND `Examination Date` = '1993-11-12'",
        "explain": "diagnosed with SLE refers to Diagnosis = 'SLE'; 1994/2/19 refers to Description = '1994-02-19'; anti-Cardiolipin refers to aCL IgM; 1993/11/12 refers to Examination Date = '1993/11/12'",
        "solution": [
            "To find the anti-Cardiolipin antibody concentration status (aCL IgA, aCL IgG, aCL IgM) for the patient diagnosed with SLE on 1994/2/19, on the examination date 1993/11/12, follow these steps:\n\n1. **Identify the Patient**: First, locate the patient in the database who was diagnosed with SLE (Systemic Lupus Erythematosus) on February 19, 1994. This is done by querying the `Patient` table for records where the `Diagnosis` is 'SLE' and the `Description` (or diagnosis date) is '1994-02-19'.\n\n2. **Retrieve Examination Data**: Once the patient's ID is identified, use it to query the `Examination` table for records where the `Examination Date` is November 12, 1993.\n\n3. **Extract Antibody Status**: From the matching examination record, retrieve the values of the columns `aCL IgA`, `aCL IgG`, and `aCL IgM`, which represent the patient's anti-Cardiolipin antibody concentration status on the specified date.\n\nThis process ensures that the data retrieved is specific to the patient diagnosed with SLE on the given date and the examination date in question."
        ]
    },
    "1422": {
        "sql": "SELECT DISTINCT T2.category FROM event T1 INNER JOIN budget T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';",
        "question": "State the category of events were held at MU 215.",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT DISTINCT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "explain": "'MU 215' is the location of event; ",
        "solution": [
            "To find the distinct categories of events held at the location 'MU 215', follow these steps:\n1. Start by identifying the 'event' table (referred to as T1) and the 'budget' table (referred to as T2).\n2. Perform an inner join between these two tables using the condition that the 'event_id' column in the 'event' table (T1) matches the 'link_to_event' column in the 'budget' table (T2).\n3. Filter the results to include only those records where the 'location' column in the 'event' table (T1) is equal to 'MU 215'.\n4. From the filtered and joined data, select the distinct values from the 'category' column in the 'budget' table (T2).\n5. The result will be a list of unique categories for events held at 'MU 215'."
        ]
    },
    "877": {
        "sql": "SELECT T1.forename, T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 872 AND T2.time IS NOT NULL ORDER BY T1.dob DESC LIMIT 1;",
        "question": "For all the drivers who finished the game in race No. 872, who is the youngest?",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 872 AND T2.time IS NOT NULL ORDER BY T1.dob DESC LIMIT 1",
        "explain": "race number refers to raceId; drivers who finished the race refers to time has value; the youngest is a driver where MAX(dob);",
        "solution": [
            "To find the youngest driver who finished the game in race No. 872, follow these steps:\n\n1. **Join the Tables**: Combine the `drivers` table (aliased as `T1`) with the `results` table (aliased as `T2`) using the `driverId` field to link them.\n\n2. **Filter the Results**: From the joined tables, select only those records where:\n   - The `raceId` in the `results` table is 872 (indicating the race number).\n   - The `time` field in the `results` table is not `NULL` (indicating the driver finished the race).\n\n3. **Sort by Date of Birth**: Order the filtered records by the `dob` (date of birth) field in descending order. This ensures the youngest driver (with the most recent date of birth) appears at the top.\n\n4. **Limit the Result**: Retrieve only the first record from the sorted list, which corresponds to the youngest driver who finished the race.\n\n5. **Select the Driver's Name**: From the final record, extract the `forename` and `surname` fields to display the name of the youngest driver."
        ]
    },
    "1473": {
        "sql": "SELECT AVG(Consumption) / 12 AS AverageMonthlyConsumption\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Segment = 'SME' AND SUBSTR(ym.Date, 1, 4) = '2013';",
        "question": "What was the average monthly consumption of customers in SME for the year 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT AVG(T2.Consumption) / 12 FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME'",
        "explain": "Average Monthly consumption = AVG(Consumption) / 12; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year.",
        "solution": []
    },
    "1114": {
        "sql": "SELECT AVG(t2.overall_rating) AS average_overall_rating\nFROM Player t1\nJOIN Player_Attributes t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\nWHERE t1.player_name = 'Marko Arnautovic'\nAND SUBSTR(t2.date, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21';",
        "question": "What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?",
        "db_id": "european_football_2",
        "res": 1,
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Marko Arnautovic' AND SUBSTR(t2.`date`, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'",
        "explain": "average overall rating refers to avg(overall_rating); Marko Arnautovic refers to player_name = 'Marko Arnautovic'; from 2007/2/22 to 2016/4/21 refers to the first 10 characters of date BETWEEN '2007-02-22' and '2016-04-21'",
        "solution": [
            "To find the average overall rating for Marko Arnautovic from February 22, 2007, to April 21, 2016, follow these steps:\n\n1. **Identify the Player**: Locate the player named 'Marko Arnautovic' in the `Player` table.\n2. **Join Player Attributes**: Link the player's FIFA API ID from the `Player` table to the corresponding entries in the `Player_Attributes` table.\n3. **Filter by Date**: Select only those records from the `Player_Attributes` table where the date falls between February 22, 2007, and April 21, 2016.\n4. **Calculate the Average**: Sum all the `overall_rating` values for the filtered records and divide by the total number of records to compute the average.\n\nThe result will be the average overall rating for Marko Arnautovic during the specified period.",
            "To determine the average overall rating for Marko Arnautovic from February 22, 2007, to April 21, 2016, execute the following steps:\n\n1. **Select the Player**: Retrieve the player record for 'Marko Arnautovic' from the `Player` table (aliased as `t1`).\n2. **Join Player Attributes**: Link the player's FIFA API ID (`player_fifa_api_id`) from the `Player` table to the corresponding entries in the `Player_Attributes` table (aliased as `t2`).\n3. **Filter by Date Range**: Narrow down the records in the `Player_Attributes` table to those where the date (extracted as the first 10 characters of the `date` column) falls between '2007-02-22' and '2016-04-21'.\n4. **Calculate the Average**:\n   - Sum all the `overall_rating` values from the filtered records in the `Player_Attributes` table.\n   - Count the number of records (using `id` as a unique identifier) in the filtered set.\n   - Divide the sum of `overall_rating` by the count of records to compute the average.\n\nThe result will be the average overall rating for Marko Arnautovic during the specified period."
        ]
    },
    "1385": {
        "sql": "SELECT m.first_name, m.last_name\nFROM member m\nJOIN income i ON m.member_id = i.link_to_member\nWHERE i.amount > 40;",
        "question": "Which student was able to generate income more than $40?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.amount > 40",
        "explain": "name of students means the full name; full name refers to first_name, last_name; generate income more than $50 refers to income.amount > 40",
        "solution": []
    },
    "759": {
        "sql": "SELECT c.colour\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE s.weight_kg = (SELECT MAX(weight_kg) FROM superhero);",
        "question": "What is the eye clolour of the heaviest superhero?",
        "db_id": "superhero",
        "res": 1,
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id ORDER BY T1.weight_kg DESC LIMIT 1",
        "explain": "the heaviest superhero refers to MAX(weight_kg); eye colour refers to colour where eye_colour_id = colour.id;",
        "solution": []
    },
    "359": {
        "sql": "SELECT originalType FROM cards WHERE name = 'Ancestor\\'s Chosen' AND originalType IS NOT NULL;",
        "question": "What is the type of the card \"Ancestor's Chosen\" as originally printed?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL",
        "explain": "Ancestor's Chosen' is the name of card; type of the card as originally printed refers to originaltype;",
        "solution": [
            "To find the type of the card \"Ancestor's Chosen\" as originally printed, you need to query the database for the `originalType` of the card where the `name` matches \"Ancestor's Chosen\" and ensure that the `originalType` is not null. This will return the original type of the card as stored in the database.",
            "To determine the type of the card \"Ancestor's Chosen\" as originally printed, you must retrieve the `originalType` field from the `cards` table where the `name` field exactly matches \"Ancestor's Chosen\" and the `originalType` field is not null. This query ensures that only the original type of the card, as stored in the database, is returned."
        ]
    },
    "1378": {
        "sql": "SELECT MAX(spent) AS highest_budget_spend FROM budget;",
        "question": "What is the highest amount of budget spend for an event?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT MAX(spent) FROM budget",
        "explain": "highest amount of budget spend refers to MAX(spent)",
        "solution": []
    },
    "976": {
        "sql": "SELECT l.driverId\nFROM lapTimes l\nJOIN drivers d ON l.driverId = d.driverId\nWHERE l.lap = 1\nORDER BY l.time ASC\nLIMIT 5;",
        "question": "List the driver's ID of the top five driver, by descending order, the fastest time during the first lap of the race.",
        "db_id": "formula_1",
        "res": 1,
        "ground_truth": "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY time LIMIT 5",
        "explain": "fastest time refers to Min(time);",
        "solution": []
    },
    "589": {
        "sql": "SELECT Id FROM users ORDER BY Reputation DESC LIMIT 1;",
        "question": "Which user ID has the highest reputation?",
        "db_id": "codebase_community",
        "res": 1,
        "ground_truth": "SELECT Id FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "explain": "highest reputation refers to Max(Reputation)",
        "solution": []
    },
    "1278": {
        "sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG > 900 AND T2.IGG < 2000 AND T1.Admission = '+';",
        "question": "Of the patients with an normal level of IGG, how many of them admitted to the hospital?",
        "db_id": "thrombosis_prediction",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG > 900 AND T2.IGG <2000 AND  T1.Admission = '+'",
        "explain": "normal level of IGG refers to 900 < IGG < 2000; admitted to the hospital refers to Admission = '+';",
        "solution": [
            "To solve the question, 'Of the patients with a normal level of IGG, how many of them were admitted to the hospital?', the following steps are performed:\n\n1. **Identify Patients with Normal IGG Levels**: Filter the `Laboratory` table to find patients whose IGG levels are greater than 900 and less than 2000. This range defines a normal level of IGG.\n\n2. **Join with Patient Data**: Combine the filtered results from the `Laboratory` table with the `Patient` table using the patient ID (`ID`) as the common key. This ensures we have access to the admission status of each patient.\n\n3. **Filter Admitted Patients**: From the joined data, select only those patients who have an admission status marked as '+' (indicating they were admitted to the hospital).\n\n4. **Count the Admitted Patients**: Finally, count the number of patients who meet both criteria (normal IGG levels and admitted to the hospital).\n\nThe SQL query `SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG > 900 AND T2.IGG <2000 AND T1.Admission = '+'` directly translates to these operations."
        ]
    },
    "517": {
        "sql": "SELECT COUNT(T1.id) \nFROM cards T1 \nJOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T1.rarity = 'rare' \nAND T1.types = 'Enchantment' \nAND T1.name = 'Abundance' \nAND T2.status = 'Legal';",
        "question": "How many rare enchantment Abundance cards are there whose play format status are all legal?",
        "db_id": "card_games",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.rarity = 'rare' AND T1.types = 'Enchantment' AND T1.name = 'Abundance' AND T2.status = 'Legal'",
        "explain": "rare refers to rarity = 'rare'; enchantment card refers to types = 'Enchantment'; Abundance cards refers to name = 'Abundance'; format status are all legal refers to status = 'Legal'",
        "solution": [
            "To determine how many rare enchantment Abundance cards have a play format status that is entirely legal, follow these steps:\n\n1. **Identify the cards table (T1) and the legalities table (T2)**: These tables contain information about the cards and their legal statuses, respectively.\n\n2. **Join the tables**: Link the cards table (T1) with the legalities table (T2) using the `uuid` field, which is common to both tables.\n\n3. **Filter the cards**: From the joined tables, select only those cards that meet the following criteria:\n   - The card's rarity is 'rare' (`T1.rarity = 'rare'`).\n   - The card's type is 'Enchantment' (`T1.types = 'Enchantment'`).\n   - The card's name is 'Abundance' (`T1.name = 'Abundance'`).\n   - The card's legal status is 'Legal' (`T2.status = 'Legal'`).\n\n4. **Count the results**: Calculate the total number of cards that satisfy all the above conditions using the `COUNT` function on the `id` field of the cards table (T1).\n\nThe final result will be the count of rare enchantment Abundance cards that are legal in the specified play format."
        ]
    },
    "1489": {
        "sql": "SELECT SUM(y.Consumption) AS TotalConsumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'KAM' AND y.Date = '201305';",
        "question": "How much did the KAM customers consume in total in May 2013?",
        "db_id": "debit_card_specializing",
        "res": 1,
        "ground_truth": "SELECT SUM(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201305' AND T1.Segment = 'KAM'",
        "explain": "May 2013 refers to yearmonth.date = 201305",
        "solution": []
    },
    "1313": {
        "sql": "SELECT COUNT(DISTINCT m.member_id) \nFROM member m \nJOIN major maj ON m.link_to_major = maj.major_id \nWHERE maj.college = 'College of Engineering';",
        "question": "How many students in the Student_Club are from the College of Engineering?",
        "db_id": "student_club",
        "res": 1,
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.college = 'College of Engineering'",
        "explain": "",
        "solution": []
    },
    "511": {
        "sql": "SELECT frameEffects, COUNT(*) AS effect_count\nFROM cards\nWHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL\nGROUP BY frameEffects\nORDER BY effect_count DESC\nLIMIT 1;",
        "question": "What is the most common visual frame effects among the incredibly powerful foils?",
        "db_id": "card_games",
        "res": 0,
        "ground_truth": "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1",
        "explain": "when both cardKingdomFoilId and cardKingdomId are not null, this foil is incredibly powerful; most common visual frame effects refers to MAX(frameEffects)",
        "solution": [
            "To find the most common visual frame effects among the incredibly powerful foils, follow these steps:\n\n1. **Filter the Data**: From the `cards` table, select only those records where both `cardKingdomFoilId` and `cardKingdomId` are not null. This ensures we are focusing on the incredibly powerful foils.\n\n2. **Group by Frame Effects**: Group the filtered records by the `frameEffects` column. This will organize the data into groups where each group represents a unique frame effect.\n\n3. **Count Occurrences**: For each group (i.e., each unique frame effect), count how many times it appears in the filtered data.\n\n4. **Order by Count**: Sort the groups in descending order based on the count of each frame effect. This will place the most common frame effect at the top of the list.\n\n5. **Limit Results**: Retrieve only the top result (the most common frame effect) from the sorted list.\n\nThe final output will be the most common visual frame effect among the incredibly powerful foils.",
            "To determine the most common visual frame effects among the incredibly powerful foils, the following steps are executed:\n\n1. **Data Selection**: The query starts by selecting the `frameEffects` column from the `cards` table.\n\n2. **Filtering**: It filters the records to include only those where both `cardKingdomFoilId` and `cardKingdomId` are not null. This ensures the analysis is focused on the incredibly powerful foils.\n\n3. **Grouping**: The filtered records are then grouped by the `frameEffects` column. This step organizes the data into distinct groups, each representing a unique frame effect.\n\n4. **Counting**: For each group (i.e., each unique frame effect), the query counts the number of occurrences in the filtered dataset.\n\n5. **Ordering**: The groups are sorted in descending order based on the count of each frame effect. This places the most frequently occurring frame effect at the top of the list.\n\n6. **Limiting**: Finally, the query limits the result to only the top entry, which represents the most common visual frame effect among the incredibly powerful foils.\n\nThe output of this query is the most common visual frame effect found in the specified subset of the `cards` table."
        ]
    }
}